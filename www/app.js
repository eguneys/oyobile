(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.Okeyground=e()}}(function(){var e;return function(){function e(t,n,r){function a(i,u){if(!n[i]){if(!t[i]){var l="function"==typeof require&&require;if(!u&&l)return l(i,!0);if(o)return o(i,!0);var d=new Error("Cannot find module '"+i+"'");throw d.code="MODULE_NOT_FOUND",d}var s=n[i]={exports:{}};t[i][0].call(s.exports,function(e){var n=t[i][1][e];return a(n||e)},s,s.exports,e,t,n,r)}return n[i].exports}for(var o="function"==typeof require&&require,i=0;i<r.length;i++)a(r[i]);return a}return e}()({1:[function(e,t,n){!function(e){function n(e,t){if("object"!==a(e))return t;for(var r in t)"object"===a(e[r])&&"object"===a(t[r])?e[r]=n(e[r],t[r]):e[r]=t[r];return e}function r(e,t,r){var i=r[0],u=r.length;(e||"object"!==a(i))&&(i={});for(var l=0;l<u;++l){var d=r[l],s=a(d);if("object"===s)for(var c in d)if("__proto__"!==c){var f=e?o.clone(d[c]):d[c];t?i[c]=n(i[c],f):i[c]=f}}return i}function a(e){return{}.toString.call(e).slice(8,-1).toLowerCase()}var o=function(e){return r(e===!0,!1,arguments)},i="merge";o.recursive=function(e){return r(e===!0,!0,arguments)},o.clone=function(e){var t,n,r=e,i=a(e);if("array"===i)for(r=[],n=e.length,t=0;t<n;++t)r[t]=o.clone(e[t]);else if("object"===i){r={};for(t in e)r[t]=o.clone(e[t])}return r},e?t.exports=o:window[i]=o}("object"==typeof t&&t&&"object"==typeof t.exports&&t.exports)},{}],2:[function(t,n,r){!function(t,r){"use strict";var a=r(t);"undefined"==typeof window&&a.deps({document:"undefined"!=typeof document?document:{},location:"undefined"!=typeof location?location:{},clearTimeout:clearTimeout,setTimeout:setTimeout}),"object"==typeof n&&null!=n&&n.exports?n.exports=a:"function"==typeof e&&e.amd?e(function(){return a}):t.m=a}("undefined"!=typeof window?window:this,function a(e,t){"use strict";function n(e){return"function"==typeof e}function r(e){return"[object Object]"===De.call(e)}function o(e){return"[object String]"===De.call(e)}function i(){}function u(e){xe=e.document,Se=e.location,Me=e.cancelAnimationFrame||e.clearTimeout,Ee=e.requestAnimationFrame||e.setTimeout}function l(e,t){for(var n,r=[],a=/(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;n=a.exec(t);)if(""===n[1]&&n[2])e.tag=n[2];else if("#"===n[1])e.attrs.id=n[2];else if("."===n[1])r.push(n[2]);else if("["===n[3].charAt(0)){var o=n[6];o&&(o=o.replace(/\\(["'])/g,"$1")),"class"===n[4]?r.push(o):e.attrs[n[4]]=o||!0}return r}function d(e,t){var n=t?e.slice(1):e;return 1===n.length&&Ke(n[0])?n[0]:n}function s(e,t,n){var r="class"in t?"class":"className";for(var a in t)Ce.call(t,a)&&(a===r&&null!=t[a]&&""!==t[a]?(n.push(t[a]),e[a]=""):e[a]=t[a]);n.length&&(e[r]=n.join(" "))}function c(e,t){for(var a=[],i=1,u=arguments.length;i<u;i++)a[i-1]=arguments[i];if(e&&n(e.view))return ae(e,a);if(!o(e))throw new Error("selector in m(selector, attrs, children) should be a string");var c=null!=t&&r(t)&&!("tag"in t||"view"in t||"subtree"in t),f=c?t:{},p={tag:"div",attrs:{},children:d(a,c)};return s(p.attrs,f,l(p,e)),p}function f(e,t){for(var n=0;n<e.length&&!t(e[n],n++););}function p(e,t){f(e,function(e,n){return(e=e&&e.attrs)&&null!=e.key&&t(e,n)})}function v(e){try{if("boolean"!=typeof e&&null!=e&&null!=e.toString())return e}catch(t){}return""}function m(e,t,n,r){try{h(e,t,n),t.nodeValue=r}catch(a){}}function g(e){for(var t=0;t<e.length;t++)Ke(e[t])&&(e=e.concat.apply([],e),t--);return e}function h(e,t,n){e.insertBefore(t,e.childNodes[n]||null)}function y(e,t,n,r){p(e,function(e,r){t[e=e.key]=t[e]?{action:je,index:r,from:t[e].index,element:n.nodes[t[e].index]||xe.createElement("div")}:{action:Be,index:r}});var a=[];for(var o in t)Ce.call(t,o)&&a.push(t[o]);var i=a.sort(H),u=new Array(n.length);return u.nodes=n.nodes.slice(),f(i,function(t){var a=t.index;if(t.action===Te&&(V(n[a].nodes,n[a]),u.splice(a,1)),t.action===Be){var o=xe.createElement("div");o.key=e[a].attrs.key,h(r,o,a),u.splice(a,0,{attrs:{key:e[a].attrs.key},nodes:[o]}),u.nodes[a]=o}if(t.action===je){var i=t.element,l=r.childNodes[a];l!==i&&null!==i&&r.insertBefore(i,l||null),u[a]=n[t.from],u.nodes[a]=i}}),u}function w(e,t,n,r){var a=e.length!==t.length;return a||p(e,function(e,n){var r=t[n];return a=r&&r.attrs&&r.attrs.key!==e.key}),a?y(e,n,t,r):t}function b(e,t,n){f(e,function(e,r){null!=t[r]&&n.push.apply(n,t[r].nodes)}),f(t.nodes,function(e,r){null!=e.parentNode&&n.indexOf(e)<0&&V([e],[t[r]])}),e.length<t.length&&(t.length=e.length),t.nodes=n}function P(e){var t=0;p(e,function(){return f(e,function(e){(e=e&&e.attrs)&&null==e.key&&(e.key="__mithril__"+t++)}),1})}function k(e,t,n){return e.tag!==t.tag||(n.sort().join()!==Object.keys(t.attrs).sort().join()||(e.attrs.id!==t.attrs.id||(e.attrs.key!==t.attrs.key||("all"===c.redraw.strategy()?!t.configContext||t.configContext.retain!==!0:"diff"===c.redraw.strategy()&&(t.configContext&&t.configContext.retain===!1)))))}function O(e,t,r){k(e,t,r)&&(t.nodes.length&&V(t.nodes),t.configContext&&n(t.configContext.onunload)&&t.configContext.onunload(),t.controllers&&f(t.controllers,function(e){e.onunload&&e.onunload({preventDefault:i})}))}function x(e,t){return e.attrs.xmlns?e.attrs.xmlns:"svg"===e.tag?"http://www.w3.org/2000/svg":"math"===e.tag?"http://www.w3.org/1998/Math/MathML":t}function S(e,t,n){n.length&&(e.views=t,e.controllers=n,f(n,function(e){if(e.onunload&&e.onunload.$old&&(e.onunload=e.onunload.$old),Re&&e.onunload){var t=e.onunload;e.onunload=function(){},e.onunload.$old=t}}))}function E(e,t,r,a,o){if(n(t.attrs.config)){var i=o.configContext=o.configContext||{};e.push(function(){return t.attrs.config.call(t,r,!a,i,o)})}}function M(e,n,r,a,o,i,u,l){var d=e.nodes[0];return a&&J(d,n.tag,n.attrs,e.attrs,o),e.children=q(d,n.tag,t,t,n.children,e.children,!1,0,n.attrs.contenteditable?d:r,o,u),e.nodes.intact=!0,l.length&&(e.views=i,e.controllers=l),d}function C(e,t,n){var r;e.$trusted?r=ee(t,n,e):(r=[xe.createTextNode(e)],t.nodeName in Ae||h(t,r[0],n));var a;return a="string"==typeof e||"number"==typeof e||"boolean"==typeof e?new e.constructor(e):e,a.nodes=r,a}function D(e,t,n,r,a,o){var i=t.nodes;return r&&r===xe.activeElement&&e===t||(e.$trusted?(V(i,t),i=ee(n,a,e)):"textarea"===o?n.value=e:r?(r.innerHTML=e,i=[].slice.call(r.childNodes)):((1===i[0].nodeType||i.length>1||i[0].nodeValue.trim&&!i[0].nodeValue.trim())&&(V(t.nodes,t),i=[xe.createTextNode(e)]),m(n,i[0],a,e))),t=new e.constructor(e),t.nodes=i,t.$trusted=e.$trusted,t}function K(e,t,n,r,a,o,i){return e.nodes.length?e.valueOf()!==t.valueOf()||a?D(t,e,r,o,n,i):(e.nodes.intact=!0,e):C(t,r,n)}function A(e){return e.$trusted?e.nodes.length:Ke(e)?e.length:1}function T(e,n,r,a,o,i,u,l,d){e=g(e);var s=[],c=n.length===e.length,f=0,v={},m=!1;p(n,function(e,t){m=!0,v[n[t].attrs.key]={action:Te,index:t}}),P(e),m&&(n=w(e,n,v,r));for(var h=0,y=0,k=e.length;y<k;y++){var O=q(r,o,n,a,e[y],n[h],i,a+f||f,u,l,d);O!==t&&(c=c&&O.nodes.intact,f+=A(O),n[h++]=O)}return c||b(e,n,s),n}function B(e,t,n,r,a){if(null!=t){if(De.call(t)===De.call(e))return t;if(a&&a.nodes){var o=n-r,i=o+(Ke(e)?e:t.nodes).length;V(a.nodes.slice(o,i),a.slice(o,i))}else t.nodes&&V(t.nodes,t)}return t=new e.constructor,t.tag&&(t={}),t.nodes=[],t}function j(e,t){return e.attrs.is?null==t?xe.createElement(e.tag,e.attrs.is):xe.createElementNS(t,e.tag,e.attrs.is):null==t?xe.createElement(e.tag):xe.createElementNS(t,e.tag)}function R(e,t,n,r){return r?J(t,e.tag,e.attrs,{},n):e.attrs}function N(e,n,r,a,o,i){return null!=e.children&&e.children.length>0?q(n,e.tag,t,t,e.children,r.children,!0,0,e.attrs.contenteditable?n:a,o,i):e.children}function G(e,t,n,r,a,o,i){var u={tag:e.tag,attrs:t,children:n,nodes:[r]};return S(u,o,i),u.children&&!u.children.nodes&&(u.children.nodes=[]),u}function F(e,t,r,a){var o;return o="diff"===c.redraw.strategy()&&e?e.indexOf(t):-1,o>-1?r[o]:n(a)?new a:{}}function _(e,t,n,r){null!=r.onunload&&Ge.map(function(e){return e.handler}).indexOf(r.onunload)<0&&Ge.push({controller:r,handler:r.onunload}),e.push(n),t.push(r)}function L(e,t,n,r,a,o){var i=F(n.views,t,r,e.controller),u=e&&e.attrs&&e.attrs.key;return e=0===Re||Fe||r&&r.indexOf(i)>-1?e.view(i):{tag:"placeholder"},"retain"===e.subtree?e:(e.attrs=e.attrs||{},e.attrs.key=u,_(o,a,t,i),e)}function I(e,t,n,r){for(var a=t&&t.controllers;null!=e.view;)e=L(e,e.view.$original||e.view,t,a,r,n);return e}function U(e,t,n,r,a,i,u,l){var d=[],s=[];if(e=I(e,t,d,s),"retain"===e.subtree)return t;if(!e.tag&&s.length)throw new Error("Component template must return a virtual element, not an array, string, etc.");e.attrs=e.attrs||{},t.attrs=t.attrs||{};var c=Object.keys(e.attrs),f=c.length>("key"in e.attrs?1:0);if(O(e,t,c),o(e.tag)){var p=0===t.nodes.length;u=x(e,u);var v;if(p){v=j(e,u);var m=R(e,v,u,f);h(r,v,a);var g=N(e,v,t,n,u,l);t=G(e,m,g,v,u,d,s)}else v=M(t,e,n,f,u,d,l,s);return"select"===e.tag&&"value"in e.attrs&&J(v,e.tag,{value:e.attrs.value},{},u),p||i!==!0||null==v||h(r,v,a),E(l,e,v,p,t),t}}function q(e,t,a,o,i,u,l,d,s,c,f){return i=v(i),"retain"===i.subtree?u:(u=B(i,u,d,o,a),Ke(i)?T(i,u,e,d,t,l,s,c,f):null!=i&&r(i)?U(i,u,s,e,d,l,c,f):n(i)?u:K(u,i,d,e,l,s,t))}function H(e,t){return e.action-t.action||e.index-t.index}function X(e,t,n){n===t&&(e.style="",n={});for(var r in t)Ce.call(t,r)&&(null!=n&&n[r]===t[r]||(e.style[r]=t[r]));for(r in n)Ce.call(n,r)&&(Ce.call(t,r)||(e.style[r]=""))}function z(e,t,a,o,i,u){if("config"===t||"key"===t)return!0;if(n(a)&&"on"===t.slice(0,2))e[t]=te(a,e);else if("style"===t&&null!=a&&r(a))X(e,a,o);else if(null!=u)"href"===t?e.setAttributeNS("http://www.w3.org/1999/xlink","href",a):e.setAttribute("className"===t?"class":t,a);else if(t in e&&!_e[t])try{("input"!==i&&!e.isContentEditable||e[t]!=a)&&(e[t]=a)}catch(l){e.setAttribute(t,a)}else try{e.setAttribute(t,a)}catch(l){}}function $(e,t,n,r,a,o,i){if(t in a&&r===n&&"object"!=typeof n&&xe.activeElement!==e)"value"===t&&"input"===o&&e.value!=n&&(e.value=n);else{a[t]=n;try{return z(e,t,n,r,o,i)}catch(u){if(u.message.indexOf("Invalid argument")<0)throw u}}}function J(e,t,n,r,a){for(var o in n)!Ce.call(n,o)||!$(e,o,n[o],r[o],r,t,a);return r}function V(e,t){for(var n=e.length-1;n>-1;n--)if(e[n]&&e[n].parentNode){try{e[n].parentNode.removeChild(e[n])}catch(r){}t=[].concat(t),t[n]&&Y(t[n])}e.length&&(e.length=0)}function Y(e){e.configContext&&n(e.configContext.onunload)&&(e.configContext.onunload(),e.configContext.onunload=null),e.controllers&&f(e.controllers,function(e){n(e.onunload)&&e.onunload({preventDefault:i})}),e.children&&(Ke(e.children)?f(e.children,Y):e.children.tag&&Y(e.children))}function Q(e,t){try{e.appendChild(xe.createRange().createContextualFragment(t))}catch(n){e.insertAdjacentHTML("beforeend",t),W(e)}}function W(e){if("SCRIPT"===e.tagName)e.parentNode.replaceChild(Z(e),e);else{var t=e.childNodes;if(t&&t.length)for(var n=0;n<t.length;n++)W(t[n])}return e}function Z(e){for(var t=document.createElement("script"),n=e.attributes,r=0;r<n.length;r++)t.setAttribute(n[r].name,n[r].value);return t.text=e.innerHTML,t}function ee(e,t,n){var r=e.childNodes[t];if(r){var a=1!==r.nodeType,o=xe.createElement("span");a?(e.insertBefore(o,r||null),o.insertAdjacentHTML("beforebegin",n),e.removeChild(o)):r.insertAdjacentHTML("beforebegin",n)}else Q(e,n);for(var i=[];e.childNodes[t]!==r;)i.push(e.childNodes[t]),t++;return i}function te(e,t){return function(n){n=n||event,c.redraw.strategy("diff"),c.startComputation();try{return e.call(t,n)}finally{le()}}}function ne(e){var t=Ie.indexOf(e);return t<0?Ie.push(e)-1:t}function re(e){function t(){return arguments.length&&(e=arguments[0]),e}return t.toJSON=function(){return e&&n(e.toJSON)?e.toJSON():e},t}function ae(e,t){function n(){return(e.controller||i).apply(this,t)||this}function r(n){for(var r=[n].concat(t),a=1;a<arguments.length;a++)r.push(arguments[a]);return e.view.apply(e,r)}e.controller&&(n.prototype=e.controller.prototype),r.$original=e.view;var a={controller:n,view:r};return t[0]&&null!=t[0].key&&(a.attrs={key:t[0].key}),a}function oe(e,t,n,r){if(!r){c.redraw.strategy("all"),c.startComputation(),He[n]=t;var a;a=qe=e?e:e={controller:i};var o=new(e.controller||i);return a===qe&&(ze[n]=o,Xe[n]=e),le(),null===e&&ie(t,n),ze[n]}null==e&&ie(t,n),Ze&&(We=Ze)}function ie(e,t){He.splice(t,1),ze.splice(t,1),Xe.splice(t,1),me(e),Ie.splice(ne(e),1),Ge=[]}function ue(){Ve&&(Ve(),Ve=null),f(He,function(e,t){var n=Xe[t];if(ze[t]){var r=[ze[t]];c.render(e,n.view?n.view(ze[t],r):"")}}),Ye&&(Ye(),Ye=null),$e=null,Je=new Date,c.redraw.strategy("diff")}function le(){"none"===c.redraw.strategy()?(Re--,c.redraw.strategy("diff")):c.endComputation()}function de(e){return e.slice(nt[c.route.mode].length)}function se(e,t,n){tt={};var r=n.indexOf("?");r!==-1&&(tt=ve(n.substr(r+1,n.length)),n=n.substr(0,r));var a=Object.keys(t),o=a.indexOf(n);if(o!==-1)return c.mount(e,t[a[o]]),!0;for(var i in t)if(Ce.call(t,i)){if(i===n)return c.mount(e,t[i]),!0;var u=new RegExp("^"+i.replace(/:[^\/]+?\.{3}/g,"(.*?)").replace(/:[^\/]+/g,"([^\\/]+)")+"/?$");if(u.test(n))return n.replace(u,function(){var n=i.match(/:[^\/]+/g)||[],r=[].slice.call(arguments,1,-2);f(n,function(e,t){tt[e.replace(/:|\./g,"")]=decodeURIComponent(r[t])}),c.mount(e,t[i])}),!0}}function ce(e){if(e=e||event,!(e.ctrlKey||e.metaKey||e.shiftKey||2===e.which)){e.preventDefault?e.preventDefault():e.returnValue=!1;var t,n=e.currentTarget||e.srcElement;for(t="pathname"===c.route.mode&&n.search?ve(n.search.slice(1)):{};n&&!/a/i.test(n.nodeName);)n=n.parentNode;Re=0,c.route(n[c.route.mode].slice(nt[c.route.mode].length),t)}}function fe(){"hash"!==c.route.mode&&Se.hash?Se.hash=Se.hash:e.scrollTo(0,0)}function pe(e,n){var a={},o=[];for(var i in e)if(Ce.call(e,i)){var u=n?n+"["+i+"]":i,l=e[i];if(null===l)o.push(encodeURIComponent(u));else if(r(l))o.push(pe(l,u));else if(Ke(l)){var d=[];a[u]=a[u]||{},f(l,function(e){a[u][e]||(a[u][e]=!0,d.push(encodeURIComponent(u)+"="+encodeURIComponent(e)))}),o.push(d.join("&"))}else l!==t&&o.push(encodeURIComponent(u)+"="+encodeURIComponent(l))}return o.join("&")}function ve(e){if(""===e||null==e)return{};"?"===e.charAt(0)&&(e=e.slice(1));var t=e.split("&"),n={};return f(t,function(e){var t=e.split("="),r=decodeURIComponent(t[0]),a=2===t.length?decodeURIComponent(t[1]):null;null!=n[r]?(Ke(n[r])||(n[r]=[n[r]]),n[r].push(a)):n[r]=a}),n}function me(e){var n=ne(e);V(e.childNodes,Ue[n]),Ue[n]=t}function ge(e,t){var n=c.prop(t);return e.then(n),n.then=function(n,r){return ge(e.then(n,r),t)},n["catch"]=n.then.bind(null,null),n}function he(e,t){function a(e){l=e||lt,s.map(function(e){l===ut?e.resolve(d):e.reject(d)})}function o(e,t,a,o){if((null!=d&&r(d)||n(d))&&n(e))try{var i=0;e.call(d,function(e){i++||(d=e,t())},function(e){i++||(d=e,a())})}catch(u){c.deferred.onerror(u),d=u,a()}else o()}function i(){var r;try{r=d&&d.then}catch(s){return c.deferred.onerror(s),d=s,l=it,i()}l===it&&c.deferred.onerror(d),o(r,function(){l=ot,i()},function(){l=it,i()},function(){try{l===ot&&n(e)?d=e(d):l===it&&n(t)&&(d=t(d),l=ot)}catch(i){return c.deferred.onerror(i),d=i,a()}d===u?(d=TypeError(),a()):o(r,function(){a(ut)},a,function(){a(l===ot&&ut)})})}var u=this,l=0,d=0,s=[];u.promise={},u.resolve=function(e){return l||(d=e,l=ot,i()),u},u.reject=function(e){return l||(d=e,l=it,i()),u},u.promise.then=function(e,t){var n=new he(e,t);return l===ut?n.resolve(d):l===lt?n.reject(d):s.push(n),n.promise}}function ye(e){return e}function we(n){var r=n.callbackName||"mithril_callback_"+(new Date).getTime()+"_"+Math.round(1e16*Math.random()).toString(36),a=xe.createElement("script");e[r]=function(o){a.parentNode.removeChild(a),n.onload({type:"load",target:{responseText:o}}),e[r]=t},a.onerror=function(){return a.parentNode.removeChild(a),n.onerror({type:"error",target:{status:500,responseText:JSON.stringify({error:"Error making jsonp request"})}}),e[r]=t,!1},a.onload=function(){return!1},a.src=n.url+(n.url.indexOf("?")>0?"&":"?")+(n.callbackKey?n.callbackKey:"callback")+"="+r+"&"+pe(n.data||{}),xe.body.appendChild(a)}function be(t){var a=new e.XMLHttpRequest;if(a.open(t.method,t.url,!0,t.user,t.password),a.onreadystatechange=function(){4===a.readyState&&(a.status>=200&&a.status<300?t.onload({type:"load",target:a}):t.onerror({type:"error",target:a}))},t.serialize===JSON.stringify&&t.data&&"GET"!==t.method&&a.setRequestHeader("Content-Type","application/json; charset=utf-8"),t.deserialize===JSON.parse&&a.setRequestHeader("Accept","application/json, text/*"),r(t.headers))for(var i in t.headers)Ce.call(t.headers,i)&&a.setRequestHeader(i,t.headers[i]);if(n(t.config)){var u=t.config(a,t);null!=u&&(a=u)}var l="GET"!==t.method&&t.data?t.data:"";if(l&&!o(l)&&l.constructor!==e.FormData)throw new Error("Request data should be either be a string or FormData. Check the `serialize` option in `m.request`");return a.send(l),a}function Pe(e){return e.dataType&&"jsonp"===e.dataType.toLowerCase()?we(e):be(e)}function ke(e,t,n){if("GET"===e.method&&"jsonp"!==e.dataType){var r=e.url.indexOf("?")<0?"?":"&",a=pe(t);e.url+=a?r+a:""}else e.data=n(t)}function Oe(e,t){return t&&(e=e.replace(/:[a-z]\w+/gi,function(e){var n=e.slice(1),r=t[n]||e;return delete t[n],r})),e}c.version=function(){return"v0.2.8"};var xe,Se,Ee,Me,Ce={}.hasOwnProperty,De={}.toString,Ke=Array.isArray||function(e){return"[object Array]"===De.call(e)},Ae={AREA:1,BASE:1,BR:1,COL:1,COMMAND:1,EMBED:1,HR:1,IMG:1,INPUT:1,KEYGEN:1,LINK:1,META:1,PARAM:1,SOURCE:1,TRACK:1,WBR:1};c.deps=function(t){return u(e=t||window),e},c.deps.factory=c.factory=a,c.deps(e);var Te=1,Be=2,je=3,Re=0;c.startComputation=function(){Re++},c.endComputation=function(){Re>1?Re--:(Re=0,c.redraw())};var Ne,Ge=[],Fe=!1,_e={list:1,style:1,form:1,type:1,width:1,height:1},Le={appendChild:function(e){Ne===t&&(Ne=xe.createElement("html")),xe.documentElement&&xe.documentElement!==e?xe.replaceChild(e,xe.documentElement):xe.appendChild(e),this.childNodes=xe.childNodes},insertBefore:function(e){this.appendChild(e)},childNodes:[]},Ie=[],Ue={};c.render=function(e,n,r){if(!e)throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");var a,o=[],i=ne(e),u=e===xe;a=u||e===xe.documentElement?Le:e,u&&"html"!==n.tag&&(n={tag:"html",attrs:{},children:n}),Ue[i]===t&&V(a.childNodes),r===!0&&me(e),Ue[i]=q(a,null,t,t,n,Ue[i],!1,0,null,t,o),f(o,function(e){e()})},c.trust=function(e){return e=new String(e),e.$trusted=!0,e},c.prop=function(e){return(null!=e&&(r(e)||n(e))||"undefined"!=typeof Promise&&e instanceof Promise)&&n(e.then)?ge(e):re(e)};var qe,He=[],Xe=[],ze=[],$e=null,Je=0,Ve=null,Ye=null,Qe=16;c.component=function(e){for(var t=new Array(arguments.length-1),n=1;n<arguments.length;n++)t[n-1]=arguments[n];return ae(e,t)};var We,Ze;c.mount=c.module=function(e,t){if(!e)throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");var r=He.indexOf(e);r<0&&(r=He.length);var a=!1,o={preventDefault:function(){a=!0,Ve=Ye=null}};return f(Ge,function(e){e.handler.call(e.controller,o),e.controller.onunload=null}),a?f(Ge,function(e){e.controller.onunload=e.handler}):Ge=[],ze[r]&&n(ze[r].onunload)&&ze[r].onunload(o),oe(t,e,r,a)};var et=!1;c.redraw=function(t){if(!et){et=!0,t&&(Fe=!0);try{$e&&!t?(Ee===e.requestAnimationFrame||new Date-Je>Qe)&&($e>0&&Me($e),$e=Ee(ue,Qe)):(ue(),$e=Ee(function(){$e=null},Qe))}finally{et=Fe=!1}}},c.redraw.strategy=c.prop(),c.withAttr=function(e,t,n){return function(r){r=r||window.event;var a=r.currentTarget||this,o=n||this,i=e in a?a[e]:a.getAttribute(e);t.call(o,i)}};var tt,nt={pathname:"",hash:"#",search:"?"},rt=i,at=!1;c.route=function(t,n,r,a){if(0===arguments.length)return We;if(3===arguments.length&&o(n)){rt=function(e){var a=We=de(e);if(!se(t,r,a)){if(at)throw new Error("Ensure the default route matches one of the routes defined in m.route");at=!0,c.route(n,!0),at=!1}};var i="hash"===c.route.mode?"onhashchange":"onpopstate";return e[i]=function(){var e=Se[c.route.mode];"pathname"===c.route.mode&&(e+=Se.search),We!==de(e)&&rt(e)},Ve=fe,void e[i]()}if(t.addEventListener||t.attachEvent){var u="pathname"!==c.route.mode?Se.pathname:"";return t.href=u+nt[c.route.mode]+a.attrs.href,void(t.addEventListener?(t.removeEventListener("click",ce),t.addEventListener("click",ce)):(t.detachEvent("onclick",ce),t.attachEvent("onclick",ce)))}if(o(t)){Ze=We,We=t;var l,d=n||{},s=We.indexOf("?");l=s>-1?ve(We.slice(s+1)):{};for(var f in d)Ce.call(d,f)&&(l[f]=d[f]);var p,v=pe(l);p=s>-1?We.slice(0,s):We,v&&(We=p+(p.indexOf("?")===-1?"?":"&")+v);var m=(3===arguments.length?r:n)===!0||Ze===We;if(e.history.pushState){var g=m?"replaceState":"pushState";Ve=fe,Ye=function(){try{e.history[g](null,xe.title,nt[c.route.mode]+We)}catch(t){Se[c.route.mode]=We}},rt(nt[c.route.mode]+We)}else Se[c.route.mode]=We,rt(nt[c.route.mode]+We);Ze=null}},c.route.param=function(e){if(!tt)throw new Error("You must call m.route(element, defaultRoute, routes) before calling m.route.param()");return e?tt[e]:tt},c.route.mode="search",c.route.buildQueryString=pe,c.route.parseQueryString=ve,c.deferred=function(){var e=new he;return e.promise=ge(e.promise),e};var ot=1,it=2,ut=3,lt=4;return c.deferred.onerror=function(e){if("[object Error]"===De.call(e)&&!/ Error/.test(e.constructor.toString()))throw Re=0,e},c.sync=function(e){function t(e,t){return function(i){return a[e]=i,t||(o="reject"),0===--r&&(n.promise(a),n[o](a)),i}}var n=c.deferred(),r=e.length,a=[],o="resolve";return e.length>0?f(e,function(e,n){e.then(t(n,!0),t(n,!1))}):n.resolve([]),n.promise},c.request=function(e){e.background!==!0&&c.startComputation();var t,n,r,a=new he,o=e.dataType&&"jsonp"===e.dataType.toLowerCase();return o?(t=e.serialize=n=e.deserialize=ye,r=function(e){return e.responseText}):(t=e.serialize=e.serialize||JSON.stringify,n=e.deserialize=e.deserialize||JSON.parse,r=e.extract||function(e){return e.responseText.length||n!==JSON.parse?e.responseText:null}),e.method=(e.method||"GET").toUpperCase(),e.url=Oe(e.url,e.data),ke(e,e.data,t),e.onload=e.onerror=function(t){try{t=t||event;var o=n(r(t.target,e));"load"===t.type?(e.unwrapSuccess&&(o=e.unwrapSuccess(o,t.target)),Ke(o)&&e.type?f(o,function(t,n){o[n]=new e.type(t)}):e.type&&(o=new e.type(o)),a.resolve(o)):(e.unwrapError&&(o=e.unwrapError(o,t.target)),a.reject(o))}catch(i){a.reject(i),c.deferred.onerror(i)}finally{e.background!==!0&&c.endComputation()}},Pe(e),a.promise=ge(a.promise,e.initialValue),a.promise},c})},{}],3:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){var n,r,a,o=t.animation.current,i=d["default"].findPov(t.povSide,t.turnSide),u=d["default"].vectorByPov(i),l=t.bounds(),s=4/3,f=1*l.width,p=(l.height*(s/24.32),608/350),v=f,m=l.height*(s/p),g=.0625*v,h=.14*m,y={},w=[];if(o.hint===c["default"].drawMiddle){n=[12*g,m],r=[v*u[0],m*u[1]];var a=[r[0]-n[0],r[1]-n[1]];y[d["default"].middleCount]=[a,a,!0]}else if(o.hint===c["default"].discard){var b=d["default"].discardByPov(i),P=d["default"].topKey2pos(b);n=[g*P[0],h*P[1]],r=[v*u[0],m*u[1]],a=[r[0]-n[0],r[1]-n[1]],y[b]=[a,a]}return{anims:y,fadings:w}}function o(e,t){return Math.round(e*t)/t}function i(e){if(e.animation.current.start){var t=1-((new Date).getTime()-e.animation.current.start)/e.animation.current.duration;if(t<=0)e.animation.current={},e.render();else{var n=f.easeInOutCubic(t);for(var r in e.animation.current.anims){var a=e.animation.current.anims[r];a[1]=[o(a[0][0]*n,10),o(a[0][1]*n,10)],a[2]&&(a[1]=[a[0][0]-a[1][0],a[0][1]-a[1][1]])}for(var u in e.animation.current.fadings)e.animations.current.fadings[u].opacity=o(n,100);e.render(),d["default"].requestAnimationFrame(function(){i(e)})}}}function u(e,t){var n={pieces:{},opens:{},middles:{}};for(var r in t.pieces)t.pieces[r]&&(n.pieces[r]={color:t.pieces[r].color,number:t.pieces[r].number});var o=e(),u=a(n,t);if(Object.keys(u.anims).length>0||u.fadings.length>0){var l=t.animation.current.start;t.animation.current={start:(new Date).getTime(),duration:t.animation.duration,anims:u.anims,fadings:u.fadings},l||i(t)}else t.renderRAF();return o}var l=e("./util"),d=r(l),s=e("./move"),c=r(s),f={easeInOutCubic:function(e){return e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1}};t.exports=function(e,t){return function(){var n=[t].concat(Array.prototype.slice.call(arguments,0));if(t.animation.enabled)return u(d["default"].partialApply(e,n),t);var r=e.apply(null,n);return t.renderRAF(),r}}},{"./move":11,"./util":15}],4:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=e("mithril"),o=r(a),i=e("./view"),u=r(i),l=e("./board"),d=r(l);t.exports=function(e){return{attach:function(t){o["default"].render(t,(0,u["default"])(e))},detach:function(){},set:e.set,getPieceGroups:function(){return d["default"].getPieceGroups(e.data)},apiMove:e.apiMove,apiDrawMiddleEnd:e.apiDrawMiddleEnd,playOpenSeries:e.playOpenSeries,playOpenPairs:e.playOpenPairs,stop:e.stop,getPieceGroupSeries:e.getPieceGroupSeries,getPieceGroupPairs:e.getPieceGroupPairs,getFen:e.getFen}}},{"./board":5,"./view":16,mithril:2}],5:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e){if(K(e)){var t=e.middles[J["default"].gosterge],n=H(e);if(n=n.filter(function(n){return ee["default"].series(n.map(function(t){return e.pieces[t]}),t)}),n.length>0){var r=L(n.map(function(t){return t.map(function(t){return e.pieces[t]})}));return s(e,n),ne(J["default"].partial(e.movable.events.after,Y["default"].openSeries,te(r))),!0}}return!1}function i(e){if(A(e)){var t=e.middles[J["default"].gosterge],n=H(e);if(n=n.filter(function(n){return ee["default"].pairs(n.map(function(t){return e.pieces[t]}),t)}),n.length>0){var r=L(n.map(function(t){return t.map(function(t){return e.pieces[t]})}));return d(e,n),ne(J["default"].partial(e.movable.events.after,Y["default"].openPairs,te(r))),!0}}return!1}function u(e,t){var n=J["default"].middleCount;v(e,n),p(e,n),l(e,t)}function l(e,t){"string"==typeof t&&(t=W["default"].readPiece(t).piece),e.middleHolder.piece=t,c(e)}function d(e,t){var n=t.map(function(t){return t.map(function(t){return e.pieces[t]})}),r=L(n);ne(J["default"].partial(e.events.move,Y["default"].openPairs,te(r))),t.forEach(function(t){return t.map(function(t){return delete e.pieces[t]})});var a=e.opens.pairs.concat(n);e.opens.pairs=a,e.opens.relayout(e)}function s(e,t){var n=t.map(function(t){return t.map(function(t){return e.pieces[t]})}),r=L(n);ne(J["default"].partial(e.events.move,Y["default"].openSeries,te(r))),t.forEach(function(t){return t.map(function(t){return delete e.pieces[t]})});var a=e.opens.series.concat(n);e.opens.series=a,e.opens.relayout(e)}function c(e){var t=e.middleHolder.key,n=e.middleHolder.piece;t&&n&&(e.pieces[t]=n,e.lastMove=[J["default"].middleCount],e.middleHolder.current=!1,e.middleHolder.key=null,e.middleHolder.piece=null)}function f(e,t,n){if(t===n||!e.pieces[t])return!1;var r=e.pieces[n];return e.pieces[n]=e.pieces[t],e.pieces[t]=r,!0}function p(e,t,n){if(!n||e.pieces[n]){var r=G(e);n=r}return ne(J["default"].partial(e.events.move,Y["default"].drawMiddleEnd)),e.middleHolder.key=n,c(e),!0}function v(e,t){return ne(J["default"].partial(e.events.move,Y["default"].drawMiddle)),e.middles[J["default"].middleCount]--,e.middleHolder.current=!0,!0}function m(e,t,n){return!e.pieces[n]&&(ne(J["default"].partial(e.events.move,Y["default"].drawLeft)),e.pieces[n]=e.discards[J["default"].discards[1]][0],e.discards[J["default"].discards[1]].shift(),!0)}function g(e,t,n){if(n&&J["default"].isBoardKey(t)&&J["default"].isBoardKey(n)&&S(e,t,n)&&f(e,t,n))return!0}function h(e,t){if(J["default"].isMiddleKey(t)&&M(e,t))return v(e,t),!0}function y(e,t,n){if(J["default"].isMiddleKey(t)&&C(e,t))return p(e,t,n),!0}function w(e,t,n){if(n&&J["default"].isBoardKey(n)&&J["default"].isDrawLeftKey(t)&&D(e,t,n)&&m(e,t,n))return ne(J["default"].partial(e.movable.events.after,Y["default"].drawLeft)),!0}function b(e,t,n){n||(J["default"].isMiddleKey(t)?h(e,t)&&k(e,t):J["default"].isDrawLeftKey(t)&&D(e)&&k(e,t))}function P(e,t){e.selected?(t?e.selected!==t&&(g(e,e.selected,t)||w(e,e.selected,t)||y(e,e.selected,t)):y(e,e.selected,t),k(e,null)):x(e,t)&&k(e,t)}function k(e,t){if(e.selected=t,t&&J["default"].isBoardKey(t))if(N(e,t)){var n=e.middles[J["default"].gosterge];e.openable.dests=ee["default"].compute(e.opens,e.pieces[t],n)}else e.openable.dests=[];else e.openable.dests=[]}function O(e){return e.povSide===e.turnSide}function x(e,t){var n=e.pieces[t];return n&&e.movable.board}function S(e,t,n){return t!=n&&x(e,t)}function E(e){return O(e)}function M(e,t){return E(e)&&!e.middleHolder.current&&J["default"].containsX(e.movable.dests,Y["default"].drawMiddle)}function C(e){return e.middleHolder.current}function D(e,t,n){return E(e)&&!C(e)&&J["default"].containsX(e.movable.dests,Y["default"].drawLeft)}function K(e){return O(e)&&J["default"].containsX(e.movable.dests,Y["default"].openSeries)}function A(e){return O(e)&&J["default"].containsX(e.movable.dests,Y["default"].openPairs)}function T(e){return O(e)&&J["default"].containsX(e.movable.dests,Y["default"].leaveTaken)}function B(e){return O(e)&&J["default"].containsX(e.movable.dests,Y["default"].collectOpen)}function j(e){P(e,null)}function R(e){e.movable.side=null,e.movable.dests=[],e.openable.dests=[],e.movable.board=!1,j(e)}function N(e,t){var n=e.pieces[t];return!(!n||e.povSide!==e.turnSide)}function G(e){var t=J["default"].allAllowedBoardKeys.slice(1),n=J["default"].allAllowedBoardKeys.slice(2),r=J["default"].allAllowedBoardKeys.map(function(e,r){return[e,t[r],n[r]]}).filter(function(t){var n=z(t,3),r=n[0],a=n[1],o=n[2];return r&&a&&o&&!e.pieces[r]&&!e.pieces[a]&&!e.pieces[o]});return r[r.length-1][1]}function F(e,t,n,r){var a=_(e,t,n);if(!a)return a;var o=J["default"].decBoardKey(a);return o!==r&&e.pieces[o]&&(a=o),J["default"].notAllowedBoardKeys.indexOf(a)!==-1?null:a}function _(e,t,n){if(n||e.bounds){n=n||e.bounds();var r=Math.floor(J["default"].columns*((t[0]-n.left)/n.width)),a=Math.floor(J["default"].rows*((t[1]-n.top)/n.height));return a>=0&&a<J["default"].rows&&r>=0&&r<J["default"].columns?J["default"].pos2key([r,a]):void 0}}function L(e){return e.map(function(e){return e.map(function(e){return e.key}).join("")}).join(" ")}function I(e){var t=e.middles[J["default"].gosterge],n=e.withTore,r=q(e).filter(function(e){return ee["default"].series(e,t,n)});return L(r)}function U(e){var t=e.middles[J["default"].gosterge],n=q(e).filter(function(e){return ee["default"].pairs(e,t)});return L(n)}function q(e){return H(e).map(function(t){return t.map(function(t){return e.pieces[t]})})}function H(e){var t=J["default"].pos2key([J["default"].columns-1,0]),n=J["default"].allKeys.slice(1),r=J["default"].allKeys.map(function(e,t){return[e,n[t]]}).reduce(function(n,r){var a=z(n,2),o=a[0],i=a[1],u=z(r,2),l=u[0],d=u[1];return e.pieces[l]&&o.push(l),(l&&!e.pieces[l]&&d&&!e.pieces[d]||l===t)&&0!==o.length&&(i.push(o),o=[]),[o,i]},[[],[]]),a=z(r,2),o=a[0],i=a[1];return 0!==o.length&&i.push(o),i}var X,z=function(){function e(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var i,u=e[Symbol.iterator]();!(r=(i=u.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(l){a=!0,o=l}finally{try{!r&&u["return"]&&u["return"]()}finally{if(a)throw o}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),$=e("./util"),J=r($),V=e("./move"),Y=r(V),Q=e("./pieces"),W=r(Q),Z=e("./open"),ee=r(Z),te=J["default"].wrapGroup,ne=J["default"].callUserFunction;t.exports=(X={playOpenSeries:o,playOpenPairs:i,apiDrawMiddleEnd:l},a(X,"apiDrawMiddleEnd",l),a(X,"apiForceDrawMiddleEnd",u),a(X,"apiForceDrawMiddleEnd",u),a(X,"userMove",g),a(X,"userDrawLeft",w),a(X,"userBeginDrawMiddle",h),a(X,"userEndDrawMiddle",y),a(X,"selectSquare",P),
a(X,"selectTop",b),a(X,"setSelected",k),a(X,"canOpenSeries",K),a(X,"canOpenPairs",A),a(X,"canLeaveTaken",T),a(X,"canCollectOpen",B),a(X,"stop",R),a(X,"isDroppableOpens",N),a(X,"getKeyAtDomPos",_),a(X,"getKeyAtDomPosOnPiece",F),a(X,"getPieceGroups",q),a(X,"getPieceGroupSeries",I),a(X,"getPieceGroupPairs",U),X)},{"./move":11,"./open":12,"./pieces":13,"./util":15}],6:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=e("merge"),o=r(a),i=e("./pieces"),u=r(i);t.exports=function(e,t){if(t&&(o["default"].recursive(e,t),e.fen)){var n=u["default"].read(e.fen);e.pieces=n.pieces,e.discards=n.discards,e.opens=n.opens,e.middles=n.middles,delete e.fen}}},{"./pieces":13,merge:1}],7:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=e("./table"),o=r(a),i=e("./board"),u=r(i),l=e("./data"),d=r(l),s=e("./configure"),c=r(s),f=e("./util"),p=r(f),v=e("./anim"),m=r(v),g=e("./drag"),h=r(g),y=e("./pieces"),w=r(y);t.exports=function(e){var t=this;this.data=(0,d["default"])(e),this.getFen=function(){return w["default"].write(t.data.pieces)},this.getPieceGroupSeries=function(){return u["default"].getPieceGroupSeries(t.data)},this.getPieceGroupPairs=function(){return u["default"].getPieceGroupPairs(t.data)},this.set=(0,m["default"])(c["default"],this.data),this.apiMove=(0,m["default"])(o["default"].apiMove,this.data),this.apiDrawMiddleEnd=(0,m["default"])(u["default"].apiDrawMiddleEnd,this.data),this.playOpenSeries=(0,m["default"])(u["default"].playOpenSeries,this.data),this.playOpenPairs=(0,m["default"])(u["default"].playOpenPairs,this.data),this.canLeaveTaken=p["default"].partial(u["default"].canLeaveTaken,this.data),this.canCollectOpen=p["default"].partial(u["default"].canCollectOpen,this.data),this.canOpenSeries=p["default"].partial(u["default"].canOpenSeries,this.data),this.canOpenPairs=p["default"].partial(u["default"].canOpenPairs,this.data),this.stop=(0,m["default"])(function(e){u["default"].stop(e),h["default"].cancel(e)},this.data)}},{"./anim":3,"./board":5,"./configure":6,"./data":8,"./drag":9,"./pieces":13,"./table":14,"./util":15}],8:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=e("merge"),o=(r(a),e("./pieces")),i=r(o),u=e("./configure"),l=r(u);t.exports=function(e){var t={povSide:"east",turnSide:"east",lastMove:null,withTore:!1,pieces:i["default"].readBoard(i["default"].mixed),discards:i["default"].readDiscards(i["default"].initialDiscards,"east"),opens:i["default"].readOpenGroups(i["default"].initialOpenGroups),middles:i["default"].readMiddles(i["default"].initialMiddles),selected:null,middleHolder:{current:!1,key:null,piece:null},animation:{enabled:!0,duration:500,current:{}},draggable:{enabled:!0,distance:3,current:{}},movable:{board:!0,free:!0,events:{after:function(e,t){}}},openable:{dests:[]},events:{move:function(e,t){}}};return(0,l["default"])(t,e||{}),t}},{"./configure":6,"./pieces":13,merge:1}],9:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g["default"].rows,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:g["default"].columns;return{left:t.left+t.width*n[0]/a,top:t.top+t.height*n[1]/r,width:t.width/a,height:t.height/r}}function o(e,t){if(void 0===t.button||0===t.button){t.stopPropagation(),t.preventDefault(),s=t.target;var n=e.selected,r=g["default"].eventPosition(t),o=e.boardBounds(),u=e.opensBounds(),l=e.topBounds(),d=f["default"].getKeyAtDomPosOnPiece(e,r,o);f["default"].selectSquare(e,d),d||(d=v["default"].getDrawKeyAtDomPos(e,r,l))&&f["default"].selectTop(e,d,n),!d&&n&&((d=v["default"].getOpensKeyAtDomPos(e,r,u))?v["default"].dropOpens(e,n,d):(d=v["default"].getDiscardKeyAtDomPos(e,r,l))&&v["default"].dropTop(e,n,d));var c=e.selected===d;if(c&&v["default"].isDraggable(e,d)){var p=g["default"].isBoardKey(d)?a(e,o,g["default"].key2pos(d)):a(e,l,g["default"].topKey2pos(d),g["default"].topRows,g["default"].topColumns);e.draggable.current={orig:d,rel:r,epos:r,pos:[0,0],dec:[r[0]-(p.left+p.width/2),r[1]-(p.top+p.height/2)],boardBounds:o,opensBounds:u,topBounds:l,started:!1}}i(e)}}function i(e){g["default"].requestAnimationFrame(function(){var t=e.draggable.current;t.orig&&(!t.started&&g["default"].distance(t.epos,t.rel)>=e.draggable.distance&&(t.started=!0),t.started&&(t.pos=[t.epos[0]-t.rel[0],t.epos[1]-t.rel[1]],t.over=f["default"].getKeyAtDomPosOnPiece(e,t.epos,t.boardBounds,t.orig),!t.over&&g["default"].isBoardKey(t.orig)&&(t.over=v["default"].getOpensKeyAtDomPos(e,t.epos,t.opensBounds)||v["default"].getDiscardKeyAtDomPos(e,t.epos,t.topBounds)))),e.render(),t.orig&&i(e)})}function u(e,t){e.draggable.current.orig&&(e.draggable.current.epos=g["default"].eventPosition(t))}function l(e,t){var n=e.draggable,r=n.current?n.current.orig:null;if(r){var a=n.current.over;n.current.started&&(f["default"].setSelected(e,null),f["default"].userMove(e,r,a)||v["default"].dropOpens(e,r,a)||v["default"].dropTop(e,r,a)||f["default"].userDrawLeft(e,r,a)||f["default"].userEndDrawMiddle(e,r,a)),n.current={}}}function d(e){e.draggable.current.orig&&(e.draggable.current={},f["default"].selectSquare(e,null))}var s,c=e("./board"),f=r(c),p=e("./table"),v=r(p),m=e("./util"),g=r(m);t.exports={start:o,move:u,end:l,cancel:d}},{"./board":5,"./table":14,"./util":15}],10:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){var t=new i["default"](e);return(0,f["default"])(t)}var o=e("./ctrl"),i=r(o),u=e("./util"),l=r(u),d=e("./move"),s=r(d),c=e("./api"),f=r(c);t.exports=a,t.exports.controller=i["default"],t.exports.util=l["default"],t.exports.move=s["default"]},{"./api":4,"./ctrl":7,"./move":11,"./util":15}],11:[function(e,t,n){"use strict";var r="dm",a="dl",o="dd",i="lt",u="ss",l="os",d="op",s="co",c="dos",f="dop",p="dds",v="ddp",m="l",g="r",h="p";t.exports={drawMiddle:r,drawLeft:a,discard:o,leaveTaken:i,sign:u,openSeries:l,openPairs:d,collectOpen:s,dropOpenSeries:c,dropOpenPairs:f,dropLeft:m,dropRight:g,dropReplace:h,discardEndSeries:p,discardEndPairs:v}},{}],12:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){return e.length===t.length&&e.every(function(e,n){return e===t[n]})}function o(e,t){return t.every(function(t,n){return t.color===e[n]})}function i(e,t){if(e.length<3)return!1;var n=e.length,r=e[0].color,o=e.map(function(e){return e.key}),i=o.slice(0).reverse(),u=h["default"].seriesByColor(r);t&&(u=u.slice(0),u.push(u[0]));for(var l=0;l<=u.length-n;l++){var d=u.slice(l,l+n);if(a(d,o)|a(d,i))return!0}return!1}function u(e){var t=e.length,n=e[0].number;return!!(3===t|4===t)&&(!!e.every(function(e){return e.number===n})&&y.some(function(t){return o(t.slice(0,e.length),e)}))}function l(e,t){var n=h["default"].makePiece(t.c,t.n);return n.isFake=!0,h["default"].pieceFake(e)?n:e}function d(e,t){return!e.isFake&&e.key===t.key}function s(e,t){function n(e,t){return e.filter(function(e){return t.indexOf(e)<0})}function r(e,t){return e.key===t.key}function a(e,t){var r=["r","g","b","l"],a=e.filter(function(e){return!d(e,t)}),o=n(r,a.map(function(e){return e.c}));if(o.length<1)return e;if(a.length<1)return e;if(!(a.length<e.length))return e;var i=o[0],u=a[0].n,l=h["default"].makePiece(i,u);return a.push(l),a}function o(e,t){var n;if(0===e.length)return e;if(e.length<3)return e;var a=m(e,3),i=a[0],u=a[1],l=a[2],s=[i,u,l];if(n=e.slice(3,e.length),d(i,t))r(h["default"].pieceUp(u),l)?s=[h["default"].pieceDown(u),u,l]:r(h["default"].pieceDown(u),l)&&(s=[h["default"].pieceUp(u),u,l]);else if(d(u,t))r(h["default"].pieceUp(h["default"].pieceUp(i)),l)?s=[i,h["default"].pieceUp(i),l]:r(h["default"].pieceDown(h["default"].pieceDown(i)),l)&&(s=[i,h["default"].pieceDown(i),l]);else{if(!d(l,t))return n=o(e.slice(1,e.length),t),n.unshift(e[0]),n;r(h["default"].pieceUp(i),u)?s=[i,u,h["default"].pieceUp(u)]:r(h["default"].pieceDown(i),u)&&(s=[i,u,h["default"].pieceDown(u)])}return s.concat(n)}function i(e,t){if(2!=e.length)return e;var n=m(e,2),r=n[0],a=n[1];return d(r,t)?[a,a]:d(a,t)?[r,r]:e}if(e.filter(function(e){return d(e,t)}).length>1)return e;if(e.length<3)return i(e,t);var u=e.filter(function(e){return!d(e,t)});return u.every(function(e){return e.n===u[0].n})?a(e,t):u.every(function(e){return e.c===u[0].c})?o(e,t):e}function c(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=h["default"].pieceUp(t),a=e.map(function(e){return l(e,r)}),o=s(a,r);return i(o,n)|u(o)}function f(e,t){if(2!==e.length)return!1;var n=h["default"].pieceUp(t),r=e.map(function(e){return l(e,n)}),a=s(r,n),o=m(a,2),i=o[0],u=o[1];return i.key===u.key}function p(e,t,n){var r=[],a=h["default"].pieceUp(n);return t=l(t,a),e.series.forEach(function(o,i){var u=o.slice(0),l=o.slice(0);u.splice(0,0,t),l.splice(o.length,0,t),c(u,n)&&r.push(h["default"].getOpenSerieKeyFromGroupIndex(e,i,0)),c(l,n)&&r.push(h["default"].getOpenSerieKeyFromGroupIndex(e,i,o.length+1));var s=o.map(function(e){return d(e,a)?t:e});if(c(s,n)){var f;o.forEach(function(e,t){d(e,a)&&(f=t)}),r.push(h["default"].getOpenSerieKeyFromGroupIndex(e,i,f+1))}}),e.pairs.forEach(function(o,i){var u=o.map(function(e){return d(e,a)?t:e});if(f(u,n)){var l=v(o,a);r.push(h["default"].getOpenPairKeyFromGroupIndex(e,i,l))}}),r}function v(e,t){var n;return e.forEach(function(e,r){d(e,t)&&(n=r)}),n}Object.defineProperty(n,"__esModule",{value:!0});var m=function(){function e(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var i,u=e[Symbol.iterator]();!(r=(i=u.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(l){a=!0,o=l}finally{try{!r&&u["return"]&&u["return"]()}finally{if(a)throw o}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),g=e("./pieces"),h=r(g),y=function(){var e=h["default"].colors,t=[];for(var n in e)for(var r in e)for(var a in e)for(var o in e)n!==r&&n!==a&&n!==o&&r!==a&&r!==o&&a!==o&&t.push([e[n],e[r],e[a],e[o]]);return t}();n["default"]={compute:p,series:c,pairs:f,findOkeyIndex:v},t.exports=n["default"]},{"./pieces":13}],13:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){var t=[];for(var n in A)t.push(k(e,n).key);return t}function o(e){var t={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9},n=t[e[0]],r=t[e[1]];return void 0===r?void 0===n?{left:e.slice(1)}:{number:n,left:e.slice(1)}:{number:10*n+r,left:e.slice(2)}}function i(e){var t=/([l|r|p])(\d\d?)/,n=e.match(t),r=n[1],a=parseInt(n[2]);return{type:r,groupIndex:a}}function u(e){var t=e[0],n=e[1],r=e[2],a=2;return K[t]?(A[n+r]&&(n+=r,a=3),{piece:k(t,n),left:e.slice(a)}):{left:e.slice(1)}}function l(e){var t=[],n=[];for(e+="\n";e.length>0;){var r=u(e);r.piece?n.push(r.piece):(n.length>0&&t.push(n),n=[]),e=r.left}return t}function d(e){for(var t=[],n=0;e.length>0;){var r=u(e);r.piece&&(t[n]=r.piece),n++,e=r.left}return t}function s(e){var t={};e=d(e);for(var n=0,r=0;r<e.length;r++){if(e[r]){for(;n<100&&!D["default"].isAllowedBoardKey(D["default"].encodeKey(n,"b"));)n++;t[D["default"].encodeKey(n,"b")]=e[r],n++}n++}return t}function c(e,t){e=e.split(" ");var n={};return D["default"].allSides.map(function(e){return D["default"].findPov(t,e)}).forEach(function(t,r){var a=d(e[r]||"");n[D["default"].discardByPov(t)]=a}),n}function f(e){var t=e.split("/"),n=M(t,2),r=n[0],a=n[1];r=l(r),a=l(a);var o=p(r,a);return{series:r,pairs:a,layout:o,relayout:function(e){e.opens.layout=p(e.opens.series,e.opens.pairs)}}}function p(e,t){var n,r,a,o,i,u={},l={series:{},pairs:{}},d=[],s=0;for(n=0;n<e.length;n++){var c=e[n];o=(d[s]||1)-1,i=s,l.series[D["default"].miniPos2key([o,i])]=n;for(var f=0;f<c.length;f++)a=d[s]||1,r=D["default"].miniPos2key([a,s]),u[r]=c[f],d[s]=a+1;d[s]+=2,s++,s>=D["default"].miniRows&&(s=0)}for(d=[],n=0,f=0,r=0,a=0,s=0,n=0;n<t.length;n++){var p=t[n];for(o=(d[s]||D["default"].miniColumns-1)-1,i=s,l.pairs[D["default"].miniPos2key([o,i])]=n,f=p.length-1;f>=0;f--)a=d[s]||D["default"].miniColumns-1,r=D["default"].miniPos2key([a,s]),u[r]=p[f],d[s]=a-1;d[s]-=1,s++,s>=D["default"].miniRows&&(s=0)}return{layout:u,groupMap:l}}function v(e,t,n){for(var r in e)if(e[r]===t){var a=D["default"].miniKey2pos(r),o=M(a,2),i=o[0],u=o[1],l=[i+n,u];return D["default"].miniPos2key(l)}}function m(e,t,n){var r=e.layout.groupMap.pairs;return v(r,t,n)}function g(e,t,n){var r=e.layout.groupMap.series;return v(r,t,n)}function h(e,t){var n=e.opens,r=n.series,a=n.layout.groupMap,o=M(t,2),i=o[0],u=o[1];for(var l in a.series){var d=a.series[l],s=r[d],c=D["default"].miniKey2pos(l),f=M(c,2),p=f[0],v=f[1],m=i-p;if(!(m<0||m>s.length+1||u!=v))return[d,m]}}function y(e,t){var n=e.opens,r=n.pairs,a=n.layout.groupMap,o=M(t,2),i=o[0],u=o[1];for(var l in a.pairs){var d=a.pairs[l],s=(r[d],D["default"].miniKey2pos(l)),c=M(s,2),f=c[0],p=c[1],v=i-f;if(!(v<0||v>1||u!=p))return[d,v]}}function w(e){var t={},n=o(e);return t[D["default"].middleCount]=n.number,n=u(n.left),t[D["default"].gosterge]=n.piece,t}function b(e){e=e.split("/");var t=2,n=3,r=4,a=1,o=0,i={e:"east",w:"west",n:"north",s:"south"}[e[o]];return{pieces:s(e[t]),discards:c(e[n],i),opens:f([e[r],e[r+1]].join("/")),middles:w(e[a])}}function P(e){var t=D["default"].allKeys.map(function(t){return e[t]}).map(function(e){return e&&e.key||" "}).join("");return t.replace(/([^\s])\s/g,"$1")}function k(e,t){return{color:K[e],number:A[t],c:e,n:parseInt(t),key:e+t}}function O(e){var t=e.c,n=e.n%13+1;return k(t,n)}function x(e){var t=e.c,n=(e.n+11)%13+1;return k(t,n)}function S(e){return"fake"===e.color}function E(e){return e.length>0&&14===e.match(T).length}var M=function(){function e(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var i,u=e[Symbol.iterator]();!(r=(i=u.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(l){a=!0,o=l}finally{try{!r&&u["return"]&&u["return"]()}finally{if(a)throw o}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),C=e("./util"),D=r(C),K={b:"blue",r:"red",g:"green",l:"black",f:"fake"},A={1:"one",2:"two",3:"three",4:"four",5:"five",6:"six",7:"seven",8:"eight",9:"nine",10:"ten",11:"eleven",12:"twelve",13:"thirteen"},T=/[f|r|l|b|g]\d\d?/g,B=function(){var e={};for(var t in K)e[K[t]]=a(t);return e}(),j=function(e){return B[e]},R="g7r7b7l7 g8r8b8l8 g13r13b13l13 l12 r6r5r4r12r13 g9g8g13 g6 l8l7l12",N="r1g1l1b1 r2g2l2b2 r3g3l3b3 r4g4l4b4 r13g13l13b13 r1g1l1b1",G="r1r2 r3r4r5r6r7r8r9r10r11r12r13l1l2l3l4l5l6l7   g1g2  l3",F="20l3",_="b1  r1r2 g1",L="r8l8b8\nb1b2b3\nb9b10b11b12\nl13r13b13\nr12b12g12\nr7r8r9r10\ng10g11g12\nl6b6r6\nl9l10l11\nb7l7r7g7\nr13l13b13g13\nl10r10b10g10\nl6r6g6\nl1b1g1\n/r1r1\ng1g1\ng2g2\ng3g3\ng4g4\ng5g5\ng6g6\ng7g7\ng8g8\ng9g9\ng10g10\ng11g11\ng12g12\n\n";t.exports={validDuzOkeyGroupFen:E,initial:G,rainbow:N,mixed:R,write:P,read:b,readDropPos:i,readPiece:u,readBoard:s,initialMiddles:F,initialDiscards:_,initialOpenGroups:L,readMiddles:w,readDiscards:c,readPieceGroup:l,readOpenGroups:f,layoutOpens:p,seriesByColor:j,makePiece:k,pieceUp:O,pieceDown:x,pieceFake:S,colors:K,getOpenSerieKeyFromGroupIndex:g,getOpenPairKeyFromGroupIndex:m,getOpenSerieFromPos:h,getOpenPairFromPos:y}},{"./util":15}],14:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.piece,a=n.group,p=n.pos;if(e.turnSide===e.povSide)switch(t){case R["default"].discard:r=G["default"].readPiece(r).piece,m(e,r,B["default"].discards[2]);break;case R["default"].drawMiddle:r=G["default"].readPiece(r).piece,e.middleHolder.current?I["default"].apiDrawMiddleEnd(e,r):I["default"].apiForceDrawMiddleEnd(e,r)}else{var v=B["default"].findPov(e.povSide,e.turnSide);switch(t){case R["default"].drawMiddle:s(e),e.animation.current.hint=R["default"].drawMiddle;break;case R["default"].drawLeft:c(e,B["default"].drawByPov(v));break;case R["default"].discard:r=G["default"].readPiece(r).piece,d(e,B["default"].discardByPov(v),r),e.animation.current.hint=R["default"].discard;break;case R["default"].leaveTaken:r=G["default"].readPiece(r).piece,f(e,B["default"].drawByPov(v),r);break;case R["default"].openSeries:a=G["default"].readPieceGroup(a),u(e,a);break;case R["default"].openPairs:a=G["default"].readPieceGroup(a),l(e,a);break;case R["default"].dropOpenSeries:r=G["default"].readPiece(r).piece,p=G["default"].readDropPos(p),o(e,r,p);break;case R["default"].dropOpenPairs:r=G["default"].readPiece(r).piece,p=G["default"].readDropPos(p),i(e,r,p);break;default:console.error("unknown move")}}}function o(e,t,n){var r=n.type,a=n.groupIndex,o=e.opens.series[a],i=r!==R["default"].dropReplace?0:1,u=0;if(r===R["default"].dropLeft)u=0;else if(r===R["default"].dropRight)u=o.length+1;else{var l=G["default"].pieceUp(e.middles[B["default"].gosterge]);u=_["default"].findOkeyIndex(o,l)+1}o.splice(u-i,i,t),e.opens.relayout(e)}function i(e,t,n){var r=n.groupIndex,a=e.opens.pairs[r],o=G["default"].pieceUp(e.middles[B["default"].gosterge]),i=_["default"].findOkeyIndex(a,o);a.splice(i,1,t),e.opens.relayout(e)}function u(e,t){var n=t,r=e.opens.series.concat(n);e.opens.series=r,e.opens.relayout(e)}function l(e,t){var n=t,r=e.opens.pairs.concat(n);e.opens.pairs=r,e.opens.relayout(e)}function d(e,t,n){return e.discards[t].unshift(n),e.lastMove=[t],!0}function s(e){return e.middles[B["default"].middleCount]--,e.lastMove=[B["default"].middleCount],!0}function c(e,t){return e.discards[t].shift(),!0}function f(e,t,n){return e.discards[t].unshift(n),!0}function p(e,t,n,r){if(!e.pieces[t]||!r)return!1;var a=e.pieces[t];X(B["default"].partial(e.events.move,R["default"].dropOpenSeries,q(a.key)));var o=A(r,2),i=o[0],u=o[1],l=e.opens.series[i],d=w(l,u),s=d!==R["default"].dropReplace?0:1;if(l.splice(u-s,s,a),e.opens.relayout(e),delete e.pieces[t],d===R["default"].dropReplace){var c=G["default"].pieceUp(e.middles[B["default"].gosterge]);e.pieces[t]=c}return!0}function v(e,t,n,r){if(!e.pieces[t]||!r)return!1;var a=e.pieces[t];X(B["default"].partial(e.events.move,R["default"].dropOpenPairs,q(a.key)));var o=A(r,2),i=o[0],u=o[1],l=e.opens.pairs[i];l.splice(u,1,a),e.opens.relayout(e),delete e.pieces[t];var d=G["default"].pieceUp(e.middles[B["default"].gosterge]);return e.pieces[t]=d,!0}function m(e,t,n){for(var r in e.pieces){var a=e.pieces[r];if(a&&B["default"].pieceEqual(t,a))return g(e,r,n),!0}return!1}function g(e,t,n){var r=e.pieces[t];return!!r&&(X(B["default"].partial(e.events.move,R["default"].discard,q(r.key))),e.discards[n].unshift(e.pieces[t]),delete e.pieces[t],e.lastMove=[n],!0)}function h(e,t){var n=e.pieces[t];return!!n&&(!!B["default"].pieceEqual(n,e.middles[B["default"].gosterge])&&(X(B["default"].partial(e.events.move,R["default"].sign,q(n.key))),!0))}function y(e,t){var n=e.pieces[t];if(!n)return!1;delete e.pieces[t];var r=(G["default"].write(e.pieces),I["default"].getPieceGroupSeries(e)),a=I["default"].getPieceGroupPairs(e);if(G["default"].validDuzOkeyGroupFen(r))X(B["default"].partial(e.events.move,R["default"].discardEndSeries,H(r)));else{if(!G["default"].validDuzOkeyGroupFen(a))return e.pieces[t]=n,!1;X(B["default"].partial(e.events.move,R["default"].discardEndPairs,H(a)))}return!0}function w(e,t){return 0===t?R["default"].dropLeft:t===e.length+1?R["default"].dropRight:R["default"].dropReplace}function b(e,t,n){if(n&&B["default"].isOpensKey(n)&&E(e,t,n)){var r,a,o,i,u,l=e.pieces[t],d=G["default"].getOpenSerieFromPos(e,B["default"].miniKey2pos(n));if(d){var s=A(d,2);r=s[0],a=s[1],o=e.opens.series[r],i=w(o,a),u=i+r}if(p(e,t,n,d))return X(B["default"].partial(e.movable.events.after,R["default"].dropOpenSeries,U(l.key,u))),!0;var c=G["default"].getOpenPairFromPos(e,B["default"].miniKey2pos(n));if(c){var f=A(c,2);r=f[0],a=f[1],o=e.opens.pairs[r],i=w(o,a),u=i+r}if(v(e,t,n,c))return X(B["default"].partial(e.movable.events.after,R["default"].dropOpenPairs,U(l.key,u))),!0}return!1}function P(e,t,n){var r=e.pieces[t];if(n&&n===B["default"].discards[2]){if(M(e,t,n)&&g(e,t,n))return X(B["default"].partial(e.movable.events.after,R["default"].discard,q(r.key))),!0}else if(n===B["default"].gosterge){if(D(e,t)&&h(e,t))return X(B["default"].partial(e.movable.events.after,R["default"].sign,q(r.key))),!0;if(C(e,t)&&y(e,t)){var a=(G["default"].write(e.pieces),I["default"].getPieceGroupSeries(e)),o=I["default"].getPieceGroupPairs(e);return G["default"].validDuzOkeyGroupFen(a)?X(B["default"].partial(e.movable.events.after,R["default"].discardEndSeries,H(a))):G["default"].validDuzOkeyGroupFen(o)&&X(B["default"].partial(e.movable.events.after,R["default"].discardEndPairs,H(o))),!0}}return!1}function k(e,t){O(e,t)}function O(e,t){e.selected=t}function x(e,t){return B["default"].isMiddleKey(t)||B["default"].isDrawLeftKey(t)?e.povSide===e.turnSide:B["default"].isBoardKey(t)}function S(e){return e.povSide===e.turnSide}function E(e,t,n){var r=e.middles[B["default"].gosterge];return I["default"].isDroppableOpens(e,t)&&B["default"].isBoardKey(t)&&B["default"].isOpensKey(n)&&B["default"].containsX(e.movable.dests,R["default"].dropOpenSeries)&&B["default"].containsX(e.movable.dests,R["default"].dropOpenPairs)&&B["default"].containsX(_["default"].compute(e.opens,e.pieces[t],r),n)}function M(e,t,n){return S(e)&&B["default"].containsX(e.movable.dests,R["default"].discard)}function C(e,t){return S(e)&&B["default"].containsX(e.movable.dests,R["default"].discardEndSeries)}function D(e,t){return S(e)&&B["default"].containsX(e.movable.dests,R["default"].showSign)}function K(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B["default"].topColumns,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B["default"].topRows;return function(r,a,o){if(o||r.bounds){o=o||r.bounds();var i=Math.floor(t*((a[0]-o.left)/o.width)),u=Math.floor(n*((a[1]-o.top)/o.height));return u>=0&&u<n&&i>=0&&i<t?e(u,i):void 0}}}Object.defineProperty(n,"__esModule",{value:!0});var A=function(){function e(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var i,u=e[Symbol.iterator]();!(r=(i=u.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(l){a=!0,o=l}finally{try{!r&&u["return"]&&u["return"]()}finally{if(a)throw o}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),T=e("./util"),B=r(T),j=e("./move"),R=r(j),N=e("./pieces"),G=r(N),F=e("./open"),_=r(F),L=e("./board"),I=r(L),U=B["default"].wrapDrop,q=B["default"].wrapPiece,H=B["default"].wrapGroup,X=B["default"].callUserFunction,z=K(function(e,t){return B["default"].miniPos2key([t,e])},B["default"].miniColumns,B["default"].miniRows),$=K(function(e,t){if(e===B["default"].topRows-1){if(0===t)return B["default"].discards[1];if(t===B["default"].topColumns-4)return B["default"].middleCount}}),J=K(function(e,t){if(e===B["default"].topRows-1){if(t===B["default"].topColumns-1)return B["default"].discards[2];if(t===B["default"].topColumns-3)return B["default"].gosterge}});n["default"]={apiMove:a,selectTop:k,dropTop:P,dropOpens:b,isDraggable:x,getDrawKeyAtDomPos:$,getDiscardKeyAtDomPos:J,getOpensKeyAtDomPos:z},t.exports=n["default"]},{"./board":5,"./move":11,"./open":12,"./pieces":13,"./util":15}],15:[function(e,t,n){"use strict";function r(e,t){return G[e][t]}function a(e,t){return e.color===t.color&&e.number===t.number}function o(e,t){for(var n=[],r=0;r<e;r++)for(var a=0;a<t;a++)n.push([a,r]);return n}function i(e,t){return t+e}function u(e,t){return parseInt(e.slice(1))}function l(e){return i(u(e)-1,V)}function d(e){return e[0]===V}function s(e){return e[0]===Y}function c(e){return e===X}function f(e){return e===H[1]}function p(e){var t=e[1]*K+e[0];return i(t,V)}function v(e){return e=u(e),[e%K,Math.floor(e/K)]}function m(e){return $[e]}function g(e){var t=e[1]*j+e[0];return i(t,Y)}function h(e){return e=u(e),[e%j,Math.floor(e/j)]}function y(e){var t=[];for(var n in e)e[n]&&t.push(n);return t.join(" ")}function w(e,t){return e&&e.indexOf(t)!==-1}function b(e){return e.touches?[e.targetTouches[0].clientX,e.targetTouches[0].clientY]:[e.clientX,e.clientY]}function P(e,t){return Math.sqrt(Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2))}function k(){return"transform"in document.body.style?"transform":"webkitTransform"in document.body.style?"webkitTransform":"mozTransform"in document.body.style?"mozTransform":"oTransform"in document.body.style?"oTransform":"msTransform"}function O(){return D||(D=k()),D}function x(e){return"translate("+e[0]+"px,"+e[1]+"px)"}function S(e,t){return e.bind.apply(e,[null].concat(t))}function E(){return S(arguments[0],Array.prototype.slice.call(arguments,1))}function M(e){var t,n=function(){return void 0===t&&(t=e()),t};return n.clear=function(){t=void 0},n}function C(e){setTimeout(e,1)}var D,K=32,A=2,T=16,B=7,j=20,R=8,N=["east","west","north","south"],G={east:{east:"down",west:"up",north:"right",south:"left"},west:{east:"up",west:"down",north:"left",south:"right"},north:{east:"left",west:"right",north:"down",south:"up"},south:{east:"right",west:"left",north:"up",south:"down"}},F={up:0,left:1,down:2,right:3},_={up:3,left:0,down:1,right:2},L={up:[.5,0],left:[0,.5],right:[1,.5],down:[.5,1]},I=function(e){return L[e]},U=function(e){return H[F[e]]},q=function(e){return H[_[e]]},H=["dup","dleft","ddown","dright"],X="mmiddleCount",z="mgosterge",$={dup:[0,0],dleft:[0,B-1],ddown:[T-1,B-1],dright:[T-1,0],mmiddleCount:[T-4,B-1],mgosterge:[T-3,B-1]},J={color:"empty",number:1},V="b",Y="o",Q=o(A,K),W=o(R,j),Z=[[0,0],[30,0],[31,0],[32,0],[62,0],[63,0]].map(p),ee=function(e){return Z.indexOf(e)===-1},te=Q.map(p),ne=te.filter(ee),re=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t.piece=e,t},ae=function(e){return{group:e}},oe=function(e,t){return{piece:e,pos:t}};t.exports={topColumns:T,topRows:B,columns:K,rows:A,emptyPiece:J,pieceEqual:a,allSides:N,allPos:Q,allKeys:te,topKey2pos:m,pos2key:p,key2pos:v,miniColumns:j,miniRows:R,miniAllPos:W,miniPos2key:g,miniKey2pos:h,encodeKey:i,decBoardKey:l,notAllowedBoardKeys:Z,isAllowedBoardKey:ee,allAllowedBoardKeys:ne,isBoardKey:d,isOpensKey:s,isMiddleKey:c,isDrawLeftKey:f,findPov:r,vectorByPov:I,drawByPov:q,discardByPov:U,discards:H,middleCount:X,gosterge:z,classSet:y,containsX:w,eventPosition:b,distance:P,transformProp:O,translate:x,requestAnimationFrame:(window.requestAnimationFrame||window.setTimeout).bind(window),partialApply:S,partial:E,memo:M,wrapPiece:re,wrapGroup:ae,wrapDrop:oe,callUserFunction:C}},{}],16:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){return e.color+" "+e.number}function o(e){return{left:e[0]*(100/K["default"].columns)+"%",top:e[1]*(100/K["default"].rows)+"%"}}function i(e){return{left:e[0]*(100/K["default"].miniColumns)+"%",top:e[1]*(100/K["default"].miniRows)+"%"}}function u(e,t,n,r){var o=(e.data,{key:n,style:i(t),"class":a(r)+" mini"});return{tag:"piece",attrs:o}}function l(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=e.data,i=K["default"].classSet({selected:o.selected===t,"last-move":o.lastMove&&K["default"].containsX(o.lastMove,t)}),u={style:{},"class":[a(n),t,i].join(" "),"data-middle-count":e.data.middles[t]},l=e.data.draggable.current;if(r&&l.orig===t)u.style[K["default"].transformProp()]=K["default"].translate([l.pos[0]+l.dec[0],l.pos[1]+l.dec[1]]),u["class"]+=" dragging";else if(!r&&e.data.animation.current.anims){var d=e.data.animation.current.anims[t];d&&(u.style[K["default"].transformProp()]=K["default"].translate(d[1]))}return{tag:"piece",attrs:u}}function d(e,t,n,r){var o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=e.data,u=K["default"].classSet({selected:i.selected===t}),l={key:t+(o?"":"d"),style:{},"class":[a(n),t,u].join(" ")};r&&(l["class"]+=" "+r);var d=e.data.draggable.current;if(o&&d.orig===t)l.style[K["default"].transformProp()]=K["default"].translate([d.pos[0]+d.dec[0],d.pos[1]+d.dec[1]]),l["class"]+=" dragging";else if(o&&e.data.animation.current.anims){var s=e.data.animation.current.anims[t];s&&(l.style[K["default"].transformProp()]=K["default"].translate(s[1]))}return{tag:"piece",attrs:l}}function s(e,t,n){var r=(e.data,K["default"].classSet({"piece-holder":!0})),a={key:t,style:{},"class":[t,r,n].join(" ")};return{tag:"div",attrs:a}}function c(e,t,n,r,i){var u=e.data,l=K["default"].classSet({selected:u.selected===n}),d={key:n,style:o(t),"class":[a(r),l].join(" ")};i&&(d["class"]+=" "+i);var s=e.data.draggable.current;return s.orig===n&&(s.over&&K["default"].isOpensKey(s.over)&&(d.style.width=s.opensBounds.width/K["default"].miniColumns+"px",d.style.height=s.opensBounds.height/K["default"].miniRows+"px"),d.style[K["default"].transformProp()]=K["default"].translate([s.pos[0]+s.dec[0],s.pos[1]+s.dec[1]]),d["class"]+=" dragging"),{tag:"piece",attrs:d}}function f(e,t,n){return{tag:"div",attrs:{"class":e+" oc "+n}}}function p(e,t,n){return{tag:"div",attrs:{style:i(n),"class":e+" oc"}}}function v(e,t,n){return{tag:"div",attrs:{style:o(n),"class":e}}}function m(e){function t(e){return{tag:"div",attrs:{"class":"wood "+e}}}var n,r=e.data,a=K["default"].allPos,o=[];o.push(t("left"),t("right"));for(var i=0;i<a.length;i++){var u=K["default"].pos2key(a[i]),l=r.pieces[u];l&&o.push(c(e,a[i],u,l)),r.draggable.current.over===u&&(n=v("drag-over",e,a[i]))}return r.middleHolder.key&&o.push(c(e,K["default"].key2pos(r.middleHolder.key),r.middleHolder.key,K["default"].emptyPiece,"loading")),n&&o.push(n),{tag:"div",attrs:{config:function(t,n,r){n||(e.data.boardBounds=K["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-board"},children:o}}function g(e,t){for(var n=e.data,r=K["default"].miniAllPos,a=[],o=[],i=0;i<r.length;i++){var l=K["default"].miniPos2key(r[i]),d=t[l];d&&a.push(u(e,r[i],l,d));var s=K["default"].classSet({"drag-over":n.draggable.current.over===l,"move-dest":K["default"].containsX(n.openable.dests,l)});""!==s&&o.push(p(s,e,r[i]))}return a.push(o),a}function h(e){var t=e.data,n=g(e,t.opens.layout.layout);return{tag:"div",attrs:{config:function(t,n,r){n||(e.data.opensBounds=K["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-opens"},children:n}}function y(e){var t=e.data,n=[],r=[];for(var a in t.discards){var o=t.discards[a][0],i=K["default"].classSet({"drag-over":t.draggable.current.over===a,"move-dest":"ddown"===a&&t.selected&&K["default"].isBoardKey(t.selected)&&K["default"].containsX(t.movable.dests,T["default"].discard),"last-move":t.lastMove&&K["default"].containsX(t.lastMove,a)});o?(t.discards[a][1]&&r.push(d(e,a,t.discards[a][1],"fake",!1)),r.push(d(e,a,o,i))):n.push(s(e,a,i))}return n.push(r),n}function w(e){var t=e.data,n=[],r=t.middleHolder.piece||K["default"].emptyPiece;return n.push(d(e,K["default"].gosterge,t.middles[K["default"].gosterge])),n.push(l(e,K["default"].middleCount,K["default"].emptyPiece)),(K["default"].isMiddleKey(t.draggable.current.orig)||t.animation.current.anims&&t.animation.current.anims[K["default"].middleCount])&&n.push(l(e,K["default"].middleCount,r,!0)),t.draggable.current.over===K["default"].gosterge&&n.push(f("drag-over",e,K["default"].gosterge)),n}function b(e){var t=[w(e),y(e),h(e)];return{tag:"div",attrs:{config:function(t,n,r){n||(e.data.topBounds=K["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-top"},children:t}}function P(e){return[b(e),m(e)]}function k(e,t){return function(n){t(e,n)}}function O(e,t,n){var r=e.data,a=k(r,C["default"].start),o=k(r,C["default"].move),i=k(r,C["default"].end),u=["touchstart","mousedown"],l=["touchmove","mousemove"],d=["touchend","mouseup"];u.forEach(function(e){t.addEventListener(e,a)}),l.forEach(function(e){document.addEventListener(e,o)}),d.forEach(function(e){document.addEventListener(e,i)}),n.onunload=function(){u.forEach(function(e){t.removeEventListener(e,a)}),l.forEach(function(e){document.removeEventListener(e,o)}),d.forEach(function(e){document.removeEventListener(e,i);
})}}function x(e){return{tag:"div",attrs:{"class":"og-table",config:function(t,n,r){n||(O(e,t,r),e.data.render=function(){E["default"].render(t,P(e))},e.data.renderRAF=function(){K["default"].requestAnimationFrame(e.data.render)},e.data.bounds=K["default"].memo(t.getBoundingClientRect.bind(t)),e.data.element=t,e.data.render())}},children:[]}}var S=e("mithril"),E=r(S),M=e("./drag"),C=r(M),D=e("./util"),K=r(D),A=e("./move"),T=r(A);t.exports=function(e){return{tag:"div",attrs:{config:function(t,n){n||["onscroll","onresize"].forEach(function(t){var n=window[t];window[t]=function(){n&&n(),e.data.bounds.clear(),e.data.boardBounds.clear(),e.data.opensBounds.clear(),e.data.topBounds.clear()}})},"class":["og-table-wrap"].join(" ")},children:[x(e)]}}},{"./drag":9,"./move":11,"./util":15,mithril:2}]},{},[10])(10)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

},{}],3:[function(require,module,exports){
var conversions = require("./conversions");

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;
},{"./conversions":2}],4:[function(require,module,exports){
module.exports={
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
}
},{}],5:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');

module.exports = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
}

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr =  /^#([a-fA-F0-9]{3})$/,
       hex =  /^#([a-fA-F0-9]{6})$/,
       rgba = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d\.]+)\s*)?\)$/,
       per = /^rgba?\(\s*([\d\.]+)\%\s*,\s*([\d\.]+)\%\s*,\s*([\d\.]+)\%\s*(?:,\s*([\d\.]+)\s*)?\)$/,
       keyword = /(\D+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr);
   if (match) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   }
   else if (match = string.match(hex)) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   }
   else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   }
   else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*(\d+)(?:deg)?\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*(?:,\s*([\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(parseFloat(match[4]) || 1, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*(\d+)(?:deg)?\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*(?:,\s*([\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(parseFloat(match[4]) || 1, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   }
   else if (vals = getHsla(string)) {
      return vals[3];
   }
   else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgb) {
   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
              + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return (str.length < 2) ? "0" + str : str;
}


//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
   reverseNames[colorNames[name]] = name;
}
},{"color-name":4}],6:[function(require,module,exports){
/* MIT license */
var convert = require("color-convert"),
    string = require("color-string");

var Color = function(cssString) {
  if (cssString instanceof Color) return cssString;
  if (! (this instanceof Color)) return new Color(cssString);

   this.values = {
      rgb: [0, 0, 0],
      hsl: [0, 0, 0],
      hsv: [0, 0, 0],
      hwb: [0, 0, 0],
      cmyk: [0, 0, 0, 0],
      alpha: 1
   }

   // parse Color() argument
   if (typeof cssString == "string") {
      var vals = string.getRgba(cssString);
      if (vals) {
         this.setValues("rgb", vals);
      }
      else if(vals = string.getHsla(cssString)) {
         this.setValues("hsl", vals);
      }
      else if(vals = string.getHwb(cssString)) {
         this.setValues("hwb", vals);
      }
      else {
        throw new Error("Unable to parse color from string \"" + cssString + "\"");
      }
   }
   else if (typeof cssString == "object") {
      var vals = cssString;
      if(vals["r"] !== undefined || vals["red"] !== undefined) {
         this.setValues("rgb", vals)
      }
      else if(vals["l"] !== undefined || vals["lightness"] !== undefined) {
         this.setValues("hsl", vals)
      }
      else if(vals["v"] !== undefined || vals["value"] !== undefined) {
         this.setValues("hsv", vals)
      }
      else if(vals["w"] !== undefined || vals["whiteness"] !== undefined) {
         this.setValues("hwb", vals)
      }
      else if(vals["c"] !== undefined || vals["cyan"] !== undefined) {
         this.setValues("cmyk", vals)
      }
      else {
        throw new Error("Unable to parse color from object " + JSON.stringify(cssString));
      }
   }
}

Color.prototype = {
   rgb: function (vals) {
      return this.setSpace("rgb", arguments);
   },
   hsl: function(vals) {
      return this.setSpace("hsl", arguments);
   },
   hsv: function(vals) {
      return this.setSpace("hsv", arguments);
   },
   hwb: function(vals) {
      return this.setSpace("hwb", arguments);
   },
   cmyk: function(vals) {
      return this.setSpace("cmyk", arguments);
   },

   rgbArray: function() {
      return this.values.rgb;
   },
   hslArray: function() {
      return this.values.hsl;
   },
   hsvArray: function() {
      return this.values.hsv;
   },
   hwbArray: function() {
      if (this.values.alpha !== 1) {
        return this.values.hwb.concat([this.values.alpha])
      }
      return this.values.hwb;
   },
   cmykArray: function() {
      return this.values.cmyk;
   },
   rgbaArray: function() {
      var rgb = this.values.rgb;
      return rgb.concat([this.values.alpha]);
   },
   hslaArray: function() {
      var hsl = this.values.hsl;
      return hsl.concat([this.values.alpha]);
   },
   alpha: function(val) {
      if (val === undefined) {
         return this.values.alpha;
      }
      this.setValues("alpha", val);
      return this;
   },

   red: function(val) {
      return this.setChannel("rgb", 0, val);
   },
   green: function(val) {
      return this.setChannel("rgb", 1, val);
   },
   blue: function(val) {
      return this.setChannel("rgb", 2, val);
   },
   hue: function(val) {
      return this.setChannel("hsl", 0, val);
   },
   saturation: function(val) {
      return this.setChannel("hsl", 1, val);
   },
   lightness: function(val) {
      return this.setChannel("hsl", 2, val);
   },
   saturationv: function(val) {
      return this.setChannel("hsv", 1, val);
   },
   whiteness: function(val) {
      return this.setChannel("hwb", 1, val);
   },
   blackness: function(val) {
      return this.setChannel("hwb", 2, val);
   },
   value: function(val) {
      return this.setChannel("hsv", 2, val);
   },
   cyan: function(val) {
      return this.setChannel("cmyk", 0, val);
   },
   magenta: function(val) {
      return this.setChannel("cmyk", 1, val);
   },
   yellow: function(val) {
      return this.setChannel("cmyk", 2, val);
   },
   black: function(val) {
      return this.setChannel("cmyk", 3, val);
   },

   hexString: function() {
      return string.hexString(this.values.rgb);
   },
   rgbString: function() {
      return string.rgbString(this.values.rgb, this.values.alpha);
   },
   rgbaString: function() {
      return string.rgbaString(this.values.rgb, this.values.alpha);
   },
   percentString: function() {
      return string.percentString(this.values.rgb, this.values.alpha);
   },
   hslString: function() {
      return string.hslString(this.values.hsl, this.values.alpha);
   },
   hslaString: function() {
      return string.hslaString(this.values.hsl, this.values.alpha);
   },
   hwbString: function() {
      return string.hwbString(this.values.hwb, this.values.alpha);
   },
   keyword: function() {
      return string.keyword(this.values.rgb, this.values.alpha);
   },

   rgbNumber: function() {
      return (this.values.rgb[0] << 16) | (this.values.rgb[1] << 8) | this.values.rgb[2];
   },

   luminosity: function() {
      // http://www.w3.org/TR/WCAG20/#relativeluminancedef
      var rgb = this.values.rgb;
      var lum = [];
      for (var i = 0; i < rgb.length; i++) {
         var chan = rgb[i] / 255;
         lum[i] = (chan <= 0.03928) ? chan / 12.92
                  : Math.pow(((chan + 0.055) / 1.055), 2.4)
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
   },

   contrast: function(color2) {
      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
         return (lum1 + 0.05) / (lum2 + 0.05)
      };
      return (lum2 + 0.05) / (lum1 + 0.05);
   },

   level: function(color2) {
     var contrastRatio = this.contrast(color2);
     return (contrastRatio >= 7.1)
       ? 'AAA'
       : (contrastRatio >= 4.5)
        ? 'AA'
        : '';
   },

   dark: function() {
      // YIQ equation from http://24ways.org/2010/calculating-color-contrast
      var rgb = this.values.rgb,
          yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
   	return yiq < 128;
   },

   light: function() {
      return !this.dark();
   },

   negate: function() {
      var rgb = []
      for (var i = 0; i < 3; i++) {
         rgb[i] = 255 - this.values.rgb[i];
      }
      this.setValues("rgb", rgb);
      return this;
   },

   lighten: function(ratio) {
      this.values.hsl[2] += this.values.hsl[2] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   darken: function(ratio) {
      this.values.hsl[2] -= this.values.hsl[2] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   saturate: function(ratio) {
      this.values.hsl[1] += this.values.hsl[1] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   desaturate: function(ratio) {
      this.values.hsl[1] -= this.values.hsl[1] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   whiten: function(ratio) {
      this.values.hwb[1] += this.values.hwb[1] * ratio;
      this.setValues("hwb", this.values.hwb);
      return this;
   },

   blacken: function(ratio) {
      this.values.hwb[2] += this.values.hwb[2] * ratio;
      this.setValues("hwb", this.values.hwb);
      return this;
   },

   greyscale: function() {
      var rgb = this.values.rgb;
      // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      this.setValues("rgb", [val, val, val]);
      return this;
   },

   clearer: function(ratio) {
      this.setValues("alpha", this.values.alpha - (this.values.alpha * ratio));
      return this;
   },

   opaquer: function(ratio) {
      this.setValues("alpha", this.values.alpha + (this.values.alpha * ratio));
      return this;
   },

   rotate: function(degrees) {
      var hue = this.values.hsl[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      this.values.hsl[0] = hue;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   mix: function(color2, weight) {
      weight = 1 - (weight == null ? 0.5 : weight);

      // algorithm from Sass's mix(). Ratio of first color in mix is
      // determined by the alphas of both colors and the weight
      var t1 = weight * 2 - 1,
          d = this.alpha() - color2.alpha();

      var weight1 = (((t1 * d == -1) ? t1 : (t1 + d) / (1 + t1 * d)) + 1) / 2;
      var weight2 = 1 - weight1;

      var rgb = this.rgbArray();
      var rgb2 = color2.rgbArray();

      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = rgb[i] * weight1 + rgb2[i] * weight2;
      }
      this.setValues("rgb", rgb);

      var alpha = this.alpha() * weight + color2.alpha() * (1 - weight);
      this.setValues("alpha", alpha);

      return this;
   },

   toJSON: function() {
     return this.rgb();
   },

   clone: function() {
     return new Color(this.rgb());
   }
}


Color.prototype.getValues = function(space) {
   var vals = {};
   for (var i = 0; i < space.length; i++) {
      vals[space[i]] = this.values[space][i];
   }
   if (this.values.alpha != 1) {
      vals["a"] = this.values.alpha;
   }
   // {r: 255, g: 255, b: 255, a: 0.4}
   return vals;
}

Color.prototype.setValues = function(space, vals) {
   var spaces = {
      "rgb": ["red", "green", "blue"],
      "hsl": ["hue", "saturation", "lightness"],
      "hsv": ["hue", "saturation", "value"],
      "hwb": ["hue", "whiteness", "blackness"],
      "cmyk": ["cyan", "magenta", "yellow", "black"]
   };

   var maxes = {
      "rgb": [255, 255, 255],
      "hsl": [360, 100, 100],
      "hsv": [360, 100, 100],
      "hwb": [360, 100, 100],
      "cmyk": [100, 100, 100, 100]
   };

   var alpha = 1;
   if (space == "alpha") {
      alpha = vals;
   }
   else if (vals.length) {
      // [10, 10, 10]
      this.values[space] = vals.slice(0, space.length);
      alpha = vals[space.length];
   }
   else if (vals[space[0]] !== undefined) {
      // {r: 10, g: 10, b: 10}
      for (var i = 0; i < space.length; i++) {
        this.values[space][i] = vals[space[i]];
      }
      alpha = vals.a;
   }
   else if (vals[spaces[space][0]] !== undefined) {
      // {red: 10, green: 10, blue: 10}
      var chans = spaces[space];
      for (var i = 0; i < space.length; i++) {
        this.values[space][i] = vals[chans[i]];
      }
      alpha = vals.alpha;
   }
   this.values.alpha = Math.max(0, Math.min(1, (alpha !== undefined ? alpha : this.values.alpha) ));
   if (space == "alpha") {
      return;
   }

   // cap values of the space prior converting all values
   for (var i = 0; i < space.length; i++) {
      var capped = Math.max(0, Math.min(maxes[space][i], this.values[space][i]));
      this.values[space][i] = Math.round(capped);
   }

   // convert to all the other color spaces
   for (var sname in spaces) {
      if (sname != space) {
         this.values[sname] = convert[space][sname](this.values[space])
      }

      // cap values
      for (var i = 0; i < sname.length; i++) {
         var capped = Math.max(0, Math.min(maxes[sname][i], this.values[sname][i]));
         this.values[sname][i] = Math.round(capped);
      }
   }
   return true;
}

Color.prototype.setSpace = function(space, args) {
   var vals = args[0];
   if (vals === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof vals == "number") {
      vals = Array.prototype.slice.call(args);
   }
   this.setValues(space, vals);
   return this;
}

Color.prototype.setChannel = function(space, index, val) {
   if (val === undefined) {
      // color.red()
      return this.values[space][index];
   }
   // color.red(100)
   this.values[space][index] = val;
   this.setValues(space, this.values[space]);
   return this;
}

module.exports = Color;

},{"color-convert":3,"color-string":5}],7:[function(require,module,exports){
/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
(function (window, document, Math) {
var rAF = window.requestAnimationFrame	||
	window.webkitRequestAnimationFrame	||
	window.mozRequestAnimationFrame		||
	window.oRequestAnimationFrame		||
	window.msRequestAnimationFrame		||
	function (callback) { window.setTimeout(callback, 1000 / 60); };

var utils = (function () {
	var me = {};

	var _elementStyle = document.createElement('div').style;
	var _vendor = (function () {
		var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			transform,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			transform = vendors[i] + 'ransform';
			if ( transform in _elementStyle ) return vendors[i].substr(0, vendors[i].length-1);
		}

		return false;
	})();

	function _prefixStyle (style) {
		if ( _vendor === false ) return false;
		if ( _vendor === '' ) return style;
		return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
	}

	me.getTime = Date.now || function getTime () { return new Date().getTime(); };

	me.extend = function (target, obj) {
		for ( var i in obj ) {
			target[i] = obj[i];
		}
	};

	me.addEvent = function (el, type, fn, capture) {
		el.addEventListener(type, fn, !!capture);
	};

	me.removeEvent = function (el, type, fn, capture) {
		el.removeEventListener(type, fn, !!capture);
	};

	me.prefixPointerEvent = function (pointerEvent) {
		return window.MSPointerEvent ?
			'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8):
			pointerEvent;
	};

	me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
		var distance = current - start,
			speed = Math.abs(distance) / time,
			destination,
			duration;

		deceleration = deceleration === undefined ? 0.0006 : deceleration;

		destination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance < 0 ? -1 : 1 );
		duration = speed / deceleration;

		if ( destination < lowerMargin ) {
			destination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin;
			distance = Math.abs(destination - current);
			duration = distance / speed;
		} else if ( destination > 0 ) {
			destination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0;
			distance = Math.abs(current) + destination;
			duration = distance / speed;
		}

		return {
			destination: Math.round(destination),
			duration: duration
		};
	};

	var _transform = _prefixStyle('transform');

	me.extend(me, {
		hasTransform: _transform !== false,
		hasPerspective: _prefixStyle('perspective') in _elementStyle,
		hasTouch: 'ontouchstart' in window,
		hasPointer: !!(window.PointerEvent || window.MSPointerEvent), // IE10 is prefixed
		hasTransition: _prefixStyle('transition') in _elementStyle
	});

	/*
	This should find all Android browsers lower than build 535.19 (both stock browser and webview)
	- galaxy S2 is ok
    - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`
    - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S3 is badAndroid (stock brower, webview)
     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S4 is badAndroid (stock brower, webview)
     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S5 is OK
     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
   - galaxy S6 is OK
     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
  */
	me.isBadAndroid = (function() {
		var appVersion = window.navigator.appVersion;
		// Android browser is not a chrome browser.
		if (/Android/.test(appVersion) && !(/Chrome\/\d/.test(appVersion))) {
			var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);
			if(safariVersion && typeof safariVersion === "object" && safariVersion.length >= 2) {
				return parseFloat(safariVersion[1]) < 535.19;
			} else {
				return true;
			}
		} else {
			return false;
		}
	})();

	me.extend(me.style = {}, {
		transform: _transform,
		transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
		transitionDuration: _prefixStyle('transitionDuration'),
		transitionDelay: _prefixStyle('transitionDelay'),
		transformOrigin: _prefixStyle('transformOrigin')
	});

	me.hasClass = function (e, c) {
		var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
		return re.test(e.className);
	};

	me.addClass = function (e, c) {
		if ( me.hasClass(e, c) ) {
			return;
		}

		var newclass = e.className.split(' ');
		newclass.push(c);
		e.className = newclass.join(' ');
	};

	me.removeClass = function (e, c) {
		if ( !me.hasClass(e, c) ) {
			return;
		}

		var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
		e.className = e.className.replace(re, ' ');
	};

	me.offset = function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;

		// jshint -W084
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		// jshint +W084

		return {
			left: left,
			top: top
		};
	};

	me.preventDefaultException = function (el, exceptions) {
		for ( var i in exceptions ) {
			if ( exceptions[i].test(el[i]) ) {
				return true;
			}
		}

		return false;
	};

	me.extend(me.eventType = {}, {
		touchstart: 1,
		touchmove: 1,
		touchend: 1,

		mousedown: 2,
		mousemove: 2,
		mouseup: 2,

		pointerdown: 3,
		pointermove: 3,
		pointerup: 3,

		MSPointerDown: 3,
		MSPointerMove: 3,
		MSPointerUp: 3
	});

	me.extend(me.ease = {}, {
		quadratic: {
			style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
			fn: function (k) {
				return k * ( 2 - k );
			}
		},
		circular: {
			style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',	// Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
			fn: function (k) {
				return Math.sqrt( 1 - ( --k * k ) );
			}
		},
		back: {
			style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
			fn: function (k) {
				var b = 4;
				return ( k = k - 1 ) * k * ( ( b + 1 ) * k + b ) + 1;
			}
		},
		bounce: {
			style: '',
			fn: function (k) {
				if ( ( k /= 1 ) < ( 1 / 2.75 ) ) {
					return 7.5625 * k * k;
				} else if ( k < ( 2 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
				} else if ( k < ( 2.5 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
				} else {
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
				}
			}
		},
		elastic: {
			style: '',
			fn: function (k) {
				var f = 0.22,
					e = 0.4;

				if ( k === 0 ) { return 0; }
				if ( k == 1 ) { return 1; }

				return ( e * Math.pow( 2, - 10 * k ) * Math.sin( ( k - f / 4 ) * ( 2 * Math.PI ) / f ) + 1 );
			}
		}
	});

	me.tap = function (e, eventName) {
		var ev = document.createEvent('Event');
		ev.initEvent(eventName, true, true);
		ev.pageX = e.pageX;
		ev.pageY = e.pageY;
		e.target.dispatchEvent(ev);
	};

	me.click = function (e) {
		var target = e.target,
			ev;

		if ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) {
			ev = document.createEvent('MouseEvents');
			ev.initMouseEvent('click', true, true, e.view, 1,
				target.screenX, target.screenY, target.clientX, target.clientY,
				e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
				0, null);

			ev._constructed = true;
			target.dispatchEvent(ev);
		}
	};

	return me;
})();
function IScroll (el, options) {
	this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
	this.scroller = this.wrapper.children[0];
	this.scrollerStyle = this.scroller.style;		// cache style for better performance

	this.options = {

		resizeScrollbars: true,

		mouseWheelSpeed: 20,

		snapThreshold: 0.334,

// INSERT POINT: OPTIONS
		disablePointer : !utils.hasPointer,
		disableTouch : utils.hasPointer || !utils.hasTouch,
		disableMouse : utils.hasPointer || utils.hasTouch,
		startX: 0,
		startY: 0,
		scrollY: true,
		directionLockThreshold: 5,
		momentum: true,

		bounce: true,
		bounceTime: 600,
		bounceEasing: '',

		preventDefault: true,
		preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

		HWCompositing: true,
		useTransition: true,
		useTransform: true,
		bindToWrapper: typeof window.onmousedown === "undefined"
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	// Normalize options
	this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

	this.options.useTransition = utils.hasTransition && this.options.useTransition;
	this.options.useTransform = utils.hasTransform && this.options.useTransform;

	this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
	this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

	// If you want eventPassthrough I have to lock one of the axes
	this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
	this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

	// With eventPassthrough we also need lockDirection mechanism
	this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
	this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

	this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

	this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

	if ( this.options.tap === true ) {
		this.options.tap = 'tap';
	}

	if ( this.options.shrinkScrollbars == 'scale' ) {
		this.options.useTransition = false;
	}

	this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

// INSERT POINT: NORMALIZATION

	// Some defaults
	this.x = 0;
	this.y = 0;
	this.directionX = 0;
	this.directionY = 0;
	this._events = {};

// INSERT POINT: DEFAULTS

	this._init();
	this.refresh();

	this.scrollTo(this.options.startX, this.options.startY);
	this.enable();
}

IScroll.prototype = {
	version: '5.2.0',

	_init: function () {
		this._initEvents();

		if ( this.options.scrollbars || this.options.indicators ) {
			this._initIndicators();
		}

		if ( this.options.mouseWheel ) {
			this._initWheel();
		}

		if ( this.options.snap ) {
			this._initSnap();
		}

		if ( this.options.keyBindings ) {
			this._initKeys();
		}

// INSERT POINT: _init

	},

	destroy: function () {
		this._initEvents(true);
		clearTimeout(this.resizeTimeout);
 		this.resizeTimeout = null;
		this._execEvent('destroy');
	},

	_transitionEnd: function (e) {
		if ( e.target != this.scroller || !this.isInTransition ) {
			return;
		}

		this._transitionTime();
		if ( !this.resetPosition(this.options.bounceTime) ) {
			this.isInTransition = false;
			this._execEvent('scrollEnd');
		}
	},

	_start: function (e) {
		// React to left mouse button only
		if ( utils.eventType[e.type] != 1 ) {
		  // for button property
		  // http://unixpapa.com/js/mouse.html
		  var button;
	    if (!e.which) {
	      /* IE case */
	      button = (e.button < 2) ? 0 :
	               ((e.button == 4) ? 1 : 2);
	    } else {
	      /* All others */
	      button = e.button;
	    }
			if ( button !== 0 ) {
				return;
			}
		}

		if ( !this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated) ) {
			return;
		}

		if ( this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.touches ? e.touches[0] : e,
			pos;

		this.initiated	= utils.eventType[e.type];
		this.moved		= false;
		this.distX		= 0;
		this.distY		= 0;
		this.directionX = 0;
		this.directionY = 0;
		this.directionLocked = 0;

		this.startTime = utils.getTime();

		if ( this.options.useTransition && this.isInTransition ) {
			this._transitionTime();
			this.isInTransition = false;
			pos = this.getComputedPosition();
			this._translate(Math.round(pos.x), Math.round(pos.y));
			this._execEvent('scrollEnd');
		} else if ( !this.options.useTransition && this.isAnimating ) {
			this.isAnimating = false;
			this._execEvent('scrollEnd');
		}

		this.startX    = this.x;
		this.startY    = this.y;
		this.absStartX = this.x;
		this.absStartY = this.y;
		this.pointX    = point.pageX;
		this.pointY    = point.pageY;

		this._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault ) {	// increases performance on Android? TODO: check!
			e.preventDefault();
		}

		var point		= e.touches ? e.touches[0] : e,
			deltaX		= point.pageX - this.pointX,
			deltaY		= point.pageY - this.pointY,
			timestamp	= utils.getTime(),
			newX, newY,
			absDistX, absDistY;

		this.pointX		= point.pageX;
		this.pointY		= point.pageY;

		this.distX		+= deltaX;
		this.distY		+= deltaY;
		absDistX		= Math.abs(this.distX);
		absDistY		= Math.abs(this.distY);

		// We need to move at least 10 pixels for the scrolling to initiate
		if ( timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10) ) {
			return;
		}

		// If you are scrolling in one direction lock the other
		if ( !this.directionLocked && !this.options.freeScroll ) {
			if ( absDistX > absDistY + this.options.directionLockThreshold ) {
				this.directionLocked = 'h';		// lock horizontally
			} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {
				this.directionLocked = 'v';		// lock vertically
			} else {
				this.directionLocked = 'n';		// no lock
			}
		}

		if ( this.directionLocked == 'h' ) {
			if ( this.options.eventPassthrough == 'vertical' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'horizontal' ) {
				this.initiated = false;
				return;
			}

			deltaY = 0;
		} else if ( this.directionLocked == 'v' ) {
			if ( this.options.eventPassthrough == 'horizontal' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'vertical' ) {
				this.initiated = false;
				return;
			}

			deltaX = 0;
		}

		deltaX = this.hasHorizontalScroll ? deltaX : 0;
		deltaY = this.hasVerticalScroll ? deltaY : 0;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		// Slow down if outside of the boundaries
		if ( newX > 0 || newX < this.maxScrollX ) {
			newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
		}
		if ( newY > 0 || newY < this.maxScrollY ) {
			newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
		}

		this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if ( !this.moved ) {
			this._execEvent('scrollStart');
		}

		this.moved = true;

		this._translate(newX, newY);

/* REPLACE START: _move */

		if ( timestamp - this.startTime > 300 ) {
			this.startTime = timestamp;
			this.startX = this.x;
			this.startY = this.y;
		}

/* REPLACE END: _move */

	},

	_end: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.changedTouches ? e.changedTouches[0] : e,
			momentumX,
			momentumY,
			duration = utils.getTime() - this.startTime,
			newX = Math.round(this.x),
			newY = Math.round(this.y),
			distanceX = Math.abs(newX - this.startX),
			distanceY = Math.abs(newY - this.startY),
			time = 0,
			easing = '';

		this.isInTransition = 0;
		this.initiated = 0;
		this.endTime = utils.getTime();

		// reset if we are outside of the boundaries
		if ( this.resetPosition(this.options.bounceTime) ) {
			return;
		}

		this.scrollTo(newX, newY);	// ensures that the last position is rounded

		// we scrolled less than 10 pixels
		if ( !this.moved ) {
			if ( this.options.tap ) {
				utils.tap(e, this.options.tap);
			}

			if ( this.options.click ) {
				utils.click(e);
			}

			this._execEvent('scrollCancel');
			return;
		}

		if ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {
			this._execEvent('flick');
			return;
		}

		// start momentum animation if needed
		if ( this.options.momentum && duration < 300 ) {
			momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
			momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
			newX = momentumX.destination;
			newY = momentumY.destination;
			time = Math.max(momentumX.duration, momentumY.duration);
			this.isInTransition = 1;
		}


		if ( this.options.snap ) {
			var snap = this._nearestSnap(newX, newY);
			this.currentPage = snap;
			time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(newX - snap.x), 1000),
						Math.min(Math.abs(newY - snap.y), 1000)
					), 300);
			newX = snap.x;
			newY = snap.y;

			this.directionX = 0;
			this.directionY = 0;
			easing = this.options.bounceEasing;
		}

// INSERT POINT: _end

		if ( newX != this.x || newY != this.y ) {
			// change easing function when scroller goes out of the boundaries
			if ( newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY ) {
				easing = utils.ease.quadratic;
			}

			this.scrollTo(newX, newY, time, easing);
			return;
		}

		this._execEvent('scrollEnd');
	},

	_resize: function () {
		var that = this;

		clearTimeout(this.resizeTimeout);

		this.resizeTimeout = setTimeout(function () {
			that.refresh();
		}, this.options.resizePolling);
	},

	resetPosition: function (time) {
		var x = this.x,
			y = this.y;

		time = time || 0;

		if ( !this.hasHorizontalScroll || this.x > 0 ) {
			x = 0;
		} else if ( this.x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( !this.hasVerticalScroll || this.y > 0 ) {
			y = 0;
		} else if ( this.y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		if ( x == this.x && y == this.y ) {
			return false;
		}

		this.scrollTo(x, y, time, this.options.bounceEasing);

		return true;
	},

	disable: function () {
		this.enabled = false;
	},

	enable: function () {
		this.enabled = true;
	},

	refresh: function () {
		var rf = this.wrapper.offsetHeight;		// Force reflow

		this.wrapperWidth	= this.wrapper.clientWidth;
		this.wrapperHeight	= this.wrapper.clientHeight;

/* REPLACE START: refresh */

		this.scrollerWidth	= this.scroller.offsetWidth;
		this.scrollerHeight	= this.scroller.offsetHeight;

		this.maxScrollX		= this.wrapperWidth - this.scrollerWidth;
		this.maxScrollY		= this.wrapperHeight - this.scrollerHeight;

/* REPLACE END: refresh */

		this.hasHorizontalScroll	= this.options.scrollX && this.maxScrollX < 0;
		this.hasVerticalScroll		= this.options.scrollY && this.maxScrollY < 0;

		if ( !this.hasHorizontalScroll ) {
			this.maxScrollX = 0;
			this.scrollerWidth = this.wrapperWidth;
		}

		if ( !this.hasVerticalScroll ) {
			this.maxScrollY = 0;
			this.scrollerHeight = this.wrapperHeight;
		}

		this.endTime = 0;
		this.directionX = 0;
		this.directionY = 0;

		this.wrapperOffset = utils.offset(this.wrapper);

		this._execEvent('refresh');

		this.resetPosition();

// INSERT POINT: _refresh

	},

	on: function (type, fn) {
		if ( !this._events[type] ) {
			this._events[type] = [];
		}

		this._events[type].push(fn);
	},

	off: function (type, fn) {
		if ( !this._events[type] ) {
			return;
		}

		var index = this._events[type].indexOf(fn);

		if ( index > -1 ) {
			this._events[type].splice(index, 1);
		}
	},

	_execEvent: function (type) {
		if ( !this._events[type] ) {
			return;
		}

		var i = 0,
			l = this._events[type].length;

		if ( !l ) {
			return;
		}

		for ( ; i < l; i++ ) {
			this._events[type][i].apply(this, [].slice.call(arguments, 1));
		}
	},

	scrollBy: function (x, y, time, easing) {
		x = this.x + x;
		y = this.y + y;
		time = time || 0;

		this.scrollTo(x, y, time, easing);
	},

	scrollTo: function (x, y, time, easing) {
		easing = easing || utils.ease.circular;

		this.isInTransition = this.options.useTransition && time > 0;
		var transitionType = this.options.useTransition && easing.style;
		if ( !time || transitionType ) {
				if(transitionType) {
					this._transitionTimingFunction(easing.style);
					this._transitionTime(time);
				}
			this._translate(x, y);
		} else {
			this._animate(x, y, time, easing.fn);
		}
	},

	scrollToElement: function (el, time, offsetX, offsetY, easing) {
		el = el.nodeType ? el : this.scroller.querySelector(el);

		if ( !el ) {
			return;
		}

		var pos = utils.offset(el);

		pos.left -= this.wrapperOffset.left;
		pos.top  -= this.wrapperOffset.top;

		// if offsetX/Y are true we center the element to the screen
		if ( offsetX === true ) {
			offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
		}
		if ( offsetY === true ) {
			offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
		}

		pos.left -= offsetX || 0;
		pos.top  -= offsetY || 0;

		pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
		pos.top  = pos.top  > 0 ? 0 : pos.top  < this.maxScrollY ? this.maxScrollY : pos.top;

		time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x-pos.left), Math.abs(this.y-pos.top)) : time;

		this.scrollTo(pos.left, pos.top, time, easing);
	},

	_transitionTime: function (time) {
		time = time || 0;

		var durationProp = utils.style.transitionDuration;
		this.scrollerStyle[durationProp] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.scrollerStyle[durationProp] = '0.0001ms';
			// remove 0.0001ms
			var self = this;
			rAF(function() {
				if(self.scrollerStyle[durationProp] === '0.0001ms') {
					self.scrollerStyle[durationProp] = '0s';
				}
			});
		}


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTime(time);
			}
		}


// INSERT POINT: _transitionTime

	},

	_transitionTimingFunction: function (easing) {
		this.scrollerStyle[utils.style.transitionTimingFunction] = easing;


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTimingFunction(easing);
			}
		}


// INSERT POINT: _transitionTimingFunction

	},

	_translate: function (x, y) {
		if ( this.options.useTransform ) {

/* REPLACE START: _translate */

			this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

/* REPLACE END: _translate */

		} else {
			x = Math.round(x);
			y = Math.round(y);
			this.scrollerStyle.left = x + 'px';
			this.scrollerStyle.top = y + 'px';
		}

		this.x = x;
		this.y = y;


	if ( this.indicators ) {
		for ( var i = this.indicators.length; i--; ) {
			this.indicators[i].updatePosition();
		}
	}


// INSERT POINT: _translate

	},

	_initEvents: function (remove) {
		var eventType = remove ? utils.removeEvent : utils.addEvent,
			target = this.options.bindToWrapper ? this.wrapper : window;

		eventType(window, 'orientationchange', this);
		eventType(window, 'resize', this);

		if ( this.options.click ) {
			eventType(this.wrapper, 'click', this, true);
		}

		if ( !this.options.disableMouse ) {
			eventType(this.wrapper, 'mousedown', this);
			eventType(target, 'mousemove', this);
			eventType(target, 'mousecancel', this);
			eventType(target, 'mouseup', this);
		}

		if ( utils.hasPointer && !this.options.disablePointer ) {
			eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
			eventType(target, utils.prefixPointerEvent('pointermove'), this);
			eventType(target, utils.prefixPointerEvent('pointercancel'), this);
			eventType(target, utils.prefixPointerEvent('pointerup'), this);
		}

		if ( utils.hasTouch && !this.options.disableTouch ) {
			eventType(this.wrapper, 'touchstart', this);
			eventType(target, 'touchmove', this);
			eventType(target, 'touchcancel', this);
			eventType(target, 'touchend', this);
		}

		eventType(this.scroller, 'transitionend', this);
		eventType(this.scroller, 'webkitTransitionEnd', this);
		eventType(this.scroller, 'oTransitionEnd', this);
		eventType(this.scroller, 'MSTransitionEnd', this);
	},

	getComputedPosition: function () {
		var matrix = window.getComputedStyle(this.scroller, null),
			x, y;

		if ( this.options.useTransform ) {
			matrix = matrix[utils.style.transform].split(')')[0].split(', ');
			x = +(matrix[12] || matrix[4]);
			y = +(matrix[13] || matrix[5]);
		} else {
			x = +matrix.left.replace(/[^-\d.]/g, '');
			y = +matrix.top.replace(/[^-\d.]/g, '');
		}

		return { x: x, y: y };
	},
	_initIndicators: function () {
		var interactive = this.options.interactiveScrollbars,
			customStyle = typeof this.options.scrollbars != 'string',
			indicators = [],
			indicator;

		var that = this;

		this.indicators = [];

		if ( this.options.scrollbars ) {
			// Vertical scrollbar
			if ( this.options.scrollY ) {
				indicator = {
					el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenX: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}

			// Horizontal scrollbar
			if ( this.options.scrollX ) {
				indicator = {
					el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenY: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}
		}

		if ( this.options.indicators ) {
			// TODO: check concat compatibility
			indicators = indicators.concat(this.options.indicators);
		}

		for ( var i = indicators.length; i--; ) {
			this.indicators.push( new Indicator(this, indicators[i]) );
		}

		// TODO: check if we can use array.map (wide compatibility and performance issues)
		function _indicatorsMap (fn) {
			if (that.indicators) {
				for ( var i = that.indicators.length; i--; ) {
					fn.call(that.indicators[i]);
				}
			}
		}

		if ( this.options.fadeScrollbars ) {
			this.on('scrollEnd', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollCancel', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1);
				});
			});

			this.on('beforeScrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1, true);
				});
			});
		}


		this.on('refresh', function () {
			_indicatorsMap(function () {
				this.refresh();
			});
		});

		this.on('destroy', function () {
			_indicatorsMap(function () {
				this.destroy();
			});

			delete this.indicators;
		});
	},

	_initWheel: function () {
		utils.addEvent(this.wrapper, 'wheel', this);
		utils.addEvent(this.wrapper, 'mousewheel', this);
		utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

		this.on('destroy', function () {
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = null;
			utils.removeEvent(this.wrapper, 'wheel', this);
			utils.removeEvent(this.wrapper, 'mousewheel', this);
			utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
		});
	},

	_wheel: function (e) {
		if ( !this.enabled ) {
			return;
		}

		e.preventDefault();

		var wheelDeltaX, wheelDeltaY,
			newX, newY,
			that = this;

		if ( this.wheelTimeout === undefined ) {
			that._execEvent('scrollStart');
		}

		// Execute the scrollEnd event after 400ms the wheel stopped scrolling
		clearTimeout(this.wheelTimeout);
		this.wheelTimeout = setTimeout(function () {
			if(!that.options.snap) {
				that._execEvent('scrollEnd');
			}
			that.wheelTimeout = undefined;
		}, 400);

		if ( 'deltaX' in e ) {
			if (e.deltaMode === 1) {
				wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
				wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
			} else {
				wheelDeltaX = -e.deltaX;
				wheelDeltaY = -e.deltaY;
			}
		} else if ( 'wheelDeltaX' in e ) {
			wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
			wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
		} else if ( 'wheelDelta' in e ) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
		} else if ( 'detail' in e ) {
			wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
		} else {
			return;
		}

		wheelDeltaX *= this.options.invertWheelDirection;
		wheelDeltaY *= this.options.invertWheelDirection;

		if ( !this.hasVerticalScroll ) {
			wheelDeltaX = wheelDeltaY;
			wheelDeltaY = 0;
		}

		if ( this.options.snap ) {
			newX = this.currentPage.pageX;
			newY = this.currentPage.pageY;

			if ( wheelDeltaX > 0 ) {
				newX--;
			} else if ( wheelDeltaX < 0 ) {
				newX++;
			}

			if ( wheelDeltaY > 0 ) {
				newY--;
			} else if ( wheelDeltaY < 0 ) {
				newY++;
			}

			this.goToPage(newX, newY);

			return;
		}

		newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
		newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

		this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
		this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;

		if ( newX > 0 ) {
			newX = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
		}

		if ( newY > 0 ) {
			newY = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
		}

		this.scrollTo(newX, newY, 0);

// INSERT POINT: _wheel
	},

	_initSnap: function () {
		this.currentPage = {};

		if ( typeof this.options.snap == 'string' ) {
			this.options.snap = this.scroller.querySelectorAll(this.options.snap);
		}

		this.on('refresh', function () {
			var i = 0, l,
				m = 0, n,
				cx, cy,
				x = 0, y,
				stepX = this.options.snapStepX || this.wrapperWidth,
				stepY = this.options.snapStepY || this.wrapperHeight,
				el;

			this.pages = [];

			if ( !this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight ) {
				return;
			}

			if ( this.options.snap === true ) {
				cx = Math.round( stepX / 2 );
				cy = Math.round( stepY / 2 );

				while ( x > -this.scrollerWidth ) {
					this.pages[i] = [];
					l = 0;
					y = 0;

					while ( y > -this.scrollerHeight ) {
						this.pages[i][l] = {
							x: Math.max(x, this.maxScrollX),
							y: Math.max(y, this.maxScrollY),
							width: stepX,
							height: stepY,
							cx: x - cx,
							cy: y - cy
						};

						y -= stepY;
						l++;
					}

					x -= stepX;
					i++;
				}
			} else {
				el = this.options.snap;
				l = el.length;
				n = -1;

				for ( ; i < l; i++ ) {
					if ( i === 0 || el[i].offsetLeft <= el[i-1].offsetLeft ) {
						m = 0;
						n++;
					}

					if ( !this.pages[m] ) {
						this.pages[m] = [];
					}

					x = Math.max(-el[i].offsetLeft, this.maxScrollX);
					y = Math.max(-el[i].offsetTop, this.maxScrollY);
					cx = x - Math.round(el[i].offsetWidth / 2);
					cy = y - Math.round(el[i].offsetHeight / 2);

					this.pages[m][n] = {
						x: x,
						y: y,
						width: el[i].offsetWidth,
						height: el[i].offsetHeight,
						cx: cx,
						cy: cy
					};

					if ( x > this.maxScrollX ) {
						m++;
					}
				}
			}

			this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

			// Update snap threshold if needed
			if ( this.options.snapThreshold % 1 === 0 ) {
				this.snapThresholdX = this.options.snapThreshold;
				this.snapThresholdY = this.options.snapThreshold;
			} else {
				this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
				this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
			}
		});

		this.on('flick', function () {
			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.x - this.startX), 1000),
						Math.min(Math.abs(this.y - this.startY), 1000)
					), 300);

			this.goToPage(
				this.currentPage.pageX + this.directionX,
				this.currentPage.pageY + this.directionY,
				time
			);
		});
	},

	_nearestSnap: function (x, y) {
		if ( !this.pages.length ) {
			return { x: 0, y: 0, pageX: 0, pageY: 0 };
		}

		var i = 0,
			l = this.pages.length,
			m = 0;

		// Check if we exceeded the snap threshold
		if ( Math.abs(x - this.absStartX) < this.snapThresholdX &&
			Math.abs(y - this.absStartY) < this.snapThresholdY ) {
			return this.currentPage;
		}

		if ( x > 0 ) {
			x = 0;
		} else if ( x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( y > 0 ) {
			y = 0;
		} else if ( y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		for ( ; i < l; i++ ) {
			if ( x >= this.pages[i][0].cx ) {
				x = this.pages[i][0].x;
				break;
			}
		}

		l = this.pages[i].length;

		for ( ; m < l; m++ ) {
			if ( y >= this.pages[0][m].cy ) {
				y = this.pages[0][m].y;
				break;
			}
		}

		if ( i == this.currentPage.pageX ) {
			i += this.directionX;

			if ( i < 0 ) {
				i = 0;
			} else if ( i >= this.pages.length ) {
				i = this.pages.length - 1;
			}

			x = this.pages[i][0].x;
		}

		if ( m == this.currentPage.pageY ) {
			m += this.directionY;

			if ( m < 0 ) {
				m = 0;
			} else if ( m >= this.pages[0].length ) {
				m = this.pages[0].length - 1;
			}

			y = this.pages[0][m].y;
		}

		return {
			x: x,
			y: y,
			pageX: i,
			pageY: m
		};
	},

	goToPage: function (x, y, time, easing) {
		easing = easing || this.options.bounceEasing;

		if ( x >= this.pages.length ) {
			x = this.pages.length - 1;
		} else if ( x < 0 ) {
			x = 0;
		}

		if ( y >= this.pages[x].length ) {
			y = this.pages[x].length - 1;
		} else if ( y < 0 ) {
			y = 0;
		}

		var posX = this.pages[x][y].x,
			posY = this.pages[x][y].y;

		time = time === undefined ? this.options.snapSpeed || Math.max(
			Math.max(
				Math.min(Math.abs(posX - this.x), 1000),
				Math.min(Math.abs(posY - this.y), 1000)
			), 300) : time;

		this.currentPage = {
			x: posX,
			y: posY,
			pageX: x,
			pageY: y
		};

		this.scrollTo(posX, posY, time, easing);
	},

	next: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x++;

		if ( x >= this.pages.length && this.hasVerticalScroll ) {
			x = 0;
			y++;
		}

		this.goToPage(x, y, time, easing);
	},

	prev: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x--;

		if ( x < 0 && this.hasVerticalScroll ) {
			x = 0;
			y--;
		}

		this.goToPage(x, y, time, easing);
	},

	_initKeys: function (e) {
		// default key bindings
		var keys = {
			pageUp: 33,
			pageDown: 34,
			end: 35,
			home: 36,
			left: 37,
			up: 38,
			right: 39,
			down: 40
		};
		var i;

		// if you give me characters I give you keycode
		if ( typeof this.options.keyBindings == 'object' ) {
			for ( i in this.options.keyBindings ) {
				if ( typeof this.options.keyBindings[i] == 'string' ) {
					this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
				}
			}
		} else {
			this.options.keyBindings = {};
		}

		for ( i in keys ) {
			this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
		}

		utils.addEvent(window, 'keydown', this);

		this.on('destroy', function () {
			utils.removeEvent(window, 'keydown', this);
		});
	},

	_key: function (e) {
		if ( !this.enabled ) {
			return;
		}

		var snap = this.options.snap,	// we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			newY = snap ? this.currentPage.pageY : this.y,
			now = utils.getTime(),
			prevTime = this.keyTime || 0,
			acceleration = 0.250,
			pos;

		if ( this.options.useTransition && this.isInTransition ) {
			pos = this.getComputedPosition();

			this._translate(Math.round(pos.x), Math.round(pos.y));
			this.isInTransition = false;
		}

		this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

		switch ( e.keyCode ) {
			case this.options.keyBindings.pageUp:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX += snap ? 1 : this.wrapperWidth;
				} else {
					newY += snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.pageDown:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX -= snap ? 1 : this.wrapperWidth;
				} else {
					newY -= snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.end:
				newX = snap ? this.pages.length-1 : this.maxScrollX;
				newY = snap ? this.pages[0].length-1 : this.maxScrollY;
				break;
			case this.options.keyBindings.home:
				newX = 0;
				newY = 0;
				break;
			case this.options.keyBindings.left:
				newX += snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.up:
				newY += snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.right:
				newX -= snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.down:
				newY -= snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			default:
				return;
		}

		if ( snap ) {
			this.goToPage(newX, newY);
			return;
		}

		if ( newX > 0 ) {
			newX = 0;
			this.keyAcceleration = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
			this.keyAcceleration = 0;
		}

		if ( newY > 0 ) {
			newY = 0;
			this.keyAcceleration = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
			this.keyAcceleration = 0;
		}

		this.scrollTo(newX, newY, 0);

		this.keyTime = now;
	},

	_animate: function (destX, destY, duration, easingFn) {
		var that = this,
			startX = this.x,
			startY = this.y,
			startTime = utils.getTime(),
			destTime = startTime + duration;

		function step () {
			var now = utils.getTime(),
				newX, newY,
				easing;

			if ( now >= destTime ) {
				that.isAnimating = false;
				that._translate(destX, destY);

				if ( !that.resetPosition(that.options.bounceTime) ) {
					that._execEvent('scrollEnd');
				}

				return;
			}

			now = ( now - startTime ) / duration;
			easing = easingFn(now);
			newX = ( destX - startX ) * easing + startX;
			newY = ( destY - startY ) * easing + startY;
			that._translate(newX, newY);

			if ( that.isAnimating ) {
				rAF(step);
			}
		}

		this.isAnimating = true;
		step();
	},
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
			case 'orientationchange':
			case 'resize':
				this._resize();
				break;
			case 'transitionend':
			case 'webkitTransitionEnd':
			case 'oTransitionEnd':
			case 'MSTransitionEnd':
				this._transitionEnd(e);
				break;
			case 'wheel':
			case 'DOMMouseScroll':
			case 'mousewheel':
				this._wheel(e);
				break;
			case 'keydown':
				this._key(e);
				break;
			case 'click':
				if ( this.enabled && !e._constructed ) {
					e.preventDefault();
					e.stopPropagation();
				}
				break;
		}
	}
};
function createDefaultScrollbar (direction, interactive, type) {
	var scrollbar = document.createElement('div'),
		indicator = document.createElement('div');

	if ( type === true ) {
		scrollbar.style.cssText = 'position:absolute;z-index:9999';
		indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
	}

	indicator.className = 'iScrollIndicator';

	if ( direction == 'h' ) {
		if ( type === true ) {
			scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
			indicator.style.height = '100%';
		}
		scrollbar.className = 'iScrollHorizontalScrollbar';
	} else {
		if ( type === true ) {
			scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
			indicator.style.width = '100%';
		}
		scrollbar.className = 'iScrollVerticalScrollbar';
	}

	scrollbar.style.cssText += ';overflow:hidden';

	if ( !interactive ) {
		scrollbar.style.pointerEvents = 'none';
	}

	scrollbar.appendChild(indicator);

	return scrollbar;
}

function Indicator (scroller, options) {
	this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
	this.wrapperStyle = this.wrapper.style;
	this.indicator = this.wrapper.children[0];
	this.indicatorStyle = this.indicator.style;
	this.scroller = scroller;

	this.options = {
		listenX: true,
		listenY: true,
		interactive: false,
		resize: true,
		defaultScrollbars: false,
		shrink: false,
		fade: false,
		speedRatioX: 0,
		speedRatioY: 0
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	this.sizeRatioX = 1;
	this.sizeRatioY = 1;
	this.maxPosX = 0;
	this.maxPosY = 0;

	if ( this.options.interactive ) {
		if ( !this.options.disableTouch ) {
			utils.addEvent(this.indicator, 'touchstart', this);
			utils.addEvent(window, 'touchend', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
			utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(this.indicator, 'mousedown', this);
			utils.addEvent(window, 'mouseup', this);
		}
	}

	if ( this.options.fade ) {
		this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
		var durationProp = utils.style.transitionDuration;
		this.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms';
		// remove 0.0001ms
		var self = this;
		if(utils.isBadAndroid) {
			rAF(function() {
				if(self.wrapperStyle[durationProp] === '0.0001ms') {
					self.wrapperStyle[durationProp] = '0s';
				}
			});
		}
		this.wrapperStyle.opacity = '0';
	}
}

Indicator.prototype = {
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
		}
	},

	destroy: function () {
		if ( this.options.fadeScrollbars ) {
			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;
		}
		if ( this.options.interactive ) {
			utils.removeEvent(this.indicator, 'touchstart', this);
			utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
			utils.removeEvent(this.indicator, 'mousedown', this);

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			utils.removeEvent(window, 'touchend', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
			utils.removeEvent(window, 'mouseup', this);
		}

		if ( this.options.defaultScrollbars ) {
			this.wrapper.parentNode.removeChild(this.wrapper);
		}
	},

	_start: function (e) {
		var point = e.touches ? e.touches[0] : e;

		e.preventDefault();
		e.stopPropagation();

		this.transitionTime();

		this.initiated = true;
		this.moved = false;
		this.lastPointX	= point.pageX;
		this.lastPointY	= point.pageY;

		this.startTime	= utils.getTime();

		if ( !this.options.disableTouch ) {
			utils.addEvent(window, 'touchmove', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(window, 'mousemove', this);
		}

		this.scroller._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		var point = e.touches ? e.touches[0] : e,
			deltaX, deltaY,
			newX, newY,
			timestamp = utils.getTime();

		if ( !this.moved ) {
			this.scroller._execEvent('scrollStart');
		}

		this.moved = true;

		deltaX = point.pageX - this.lastPointX;
		this.lastPointX = point.pageX;

		deltaY = point.pageY - this.lastPointY;
		this.lastPointY = point.pageY;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		this._pos(newX, newY);

// INSERT POINT: indicator._move

		e.preventDefault();
		e.stopPropagation();
	},

	_end: function (e) {
		if ( !this.initiated ) {
			return;
		}

		this.initiated = false;

		e.preventDefault();
		e.stopPropagation();

		utils.removeEvent(window, 'touchmove', this);
		utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
		utils.removeEvent(window, 'mousemove', this);

		if ( this.scroller.options.snap ) {
			var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.scroller.x - snap.x), 1000),
						Math.min(Math.abs(this.scroller.y - snap.y), 1000)
					), 300);

			if ( this.scroller.x != snap.x || this.scroller.y != snap.y ) {
				this.scroller.directionX = 0;
				this.scroller.directionY = 0;
				this.scroller.currentPage = snap;
				this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
			}
		}

		if ( this.moved ) {
			this.scroller._execEvent('scrollEnd');
		}
	},

	transitionTime: function (time) {
		time = time || 0;
		var durationProp = utils.style.transitionDuration;
		this.indicatorStyle[durationProp] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.indicatorStyle[durationProp] = '0.0001ms';
			// remove 0.0001ms
			var self = this;
			rAF(function() {
				if(self.indicatorStyle[durationProp] === '0.0001ms') {
					self.indicatorStyle[durationProp] = '0s';
				}
			});
		}
	},

	transitionTimingFunction: function (easing) {
		this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
	},

	refresh: function () {
		this.transitionTime();

		if ( this.options.listenX && !this.options.listenY ) {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
		} else if ( this.options.listenY && !this.options.listenX ) {
			this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
		} else {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
		}

		if ( this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ) {
			utils.addClass(this.wrapper, 'iScrollBothScrollbars');
			utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '8px';
				} else {
					this.wrapper.style.bottom = '8px';
				}
			}
		} else {
			utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
			utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '2px';
				} else {
					this.wrapper.style.bottom = '2px';
				}
			}
		}

		var r = this.wrapper.offsetHeight;	// force refresh

		if ( this.options.listenX ) {
			this.wrapperWidth = this.wrapper.clientWidth;
			if ( this.options.resize ) {
				this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
				this.indicatorStyle.width = this.indicatorWidth + 'px';
			} else {
				this.indicatorWidth = this.indicator.clientWidth;
			}

			this.maxPosX = this.wrapperWidth - this.indicatorWidth;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryX = -this.indicatorWidth + 8;
				this.maxBoundaryX = this.wrapperWidth - 8;
			} else {
				this.minBoundaryX = 0;
				this.maxBoundaryX = this.maxPosX;
			}

			this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));
		}

		if ( this.options.listenY ) {
			this.wrapperHeight = this.wrapper.clientHeight;
			if ( this.options.resize ) {
				this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
				this.indicatorStyle.height = this.indicatorHeight + 'px';
			} else {
				this.indicatorHeight = this.indicator.clientHeight;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryY = -this.indicatorHeight + 8;
				this.maxBoundaryY = this.wrapperHeight - 8;
			} else {
				this.minBoundaryY = 0;
				this.maxBoundaryY = this.maxPosY;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;
			this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
		}

		this.updatePosition();
	},

	updatePosition: function () {
		var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

		if ( !this.options.ignoreBoundaries ) {
			if ( x < this.minBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth + x, 8);
					this.indicatorStyle.width = this.width + 'px';
				}
				x = this.minBoundaryX;
			} else if ( x > this.maxBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
					this.indicatorStyle.width = this.width + 'px';
					x = this.maxPosX + this.indicatorWidth - this.width;
				} else {
					x = this.maxBoundaryX;
				}
			} else if ( this.options.shrink == 'scale' && this.width != this.indicatorWidth ) {
				this.width = this.indicatorWidth;
				this.indicatorStyle.width = this.width + 'px';
			}

			if ( y < this.minBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight + y * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
				}
				y = this.minBoundaryY;
			} else if ( y > this.maxBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
					y = this.maxPosY + this.indicatorHeight - this.height;
				} else {
					y = this.maxBoundaryY;
				}
			} else if ( this.options.shrink == 'scale' && this.height != this.indicatorHeight ) {
				this.height = this.indicatorHeight;
				this.indicatorStyle.height = this.height + 'px';
			}
		}

		this.x = x;
		this.y = y;

		if ( this.scroller.options.useTransform ) {
			this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
		} else {
			this.indicatorStyle.left = x + 'px';
			this.indicatorStyle.top = y + 'px';
		}
	},

	_pos: function (x, y) {
		if ( x < 0 ) {
			x = 0;
		} else if ( x > this.maxPosX ) {
			x = this.maxPosX;
		}

		if ( y < 0 ) {
			y = 0;
		} else if ( y > this.maxPosY ) {
			y = this.maxPosY;
		}

		x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
		y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

		this.scroller.scrollTo(x, y);
	},

	fade: function (val, hold) {
		if ( hold && !this.visible ) {
			return;
		}

		clearTimeout(this.fadeTimeout);
		this.fadeTimeout = null;

		var time = val ? 250 : 500,
			delay = val ? 0 : 300;

		val = val ? '1' : '0';

		this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

		this.fadeTimeout = setTimeout((function (val) {
			this.wrapperStyle.opacity = val;
			this.visible = +val;
		}).bind(this, val), delay);
	}
};

IScroll.utils = utils;

if ( typeof module != 'undefined' && module.exports ) {
	module.exports = IScroll;
} else if ( typeof define == 'function' && define.amd ) {
        define( function () { return IScroll; } );
} else {
	window.IScroll = IScroll;
}

})(window, document, Math);

},{}],8:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":51,"./_hashDelete":52,"./_hashGet":53,"./_hashHas":54,"./_hashSet":55}],9:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":62,"./_listCacheDelete":63,"./_listCacheGet":64,"./_listCacheHas":65,"./_listCacheSet":66}],10:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":47,"./_root":78}],11:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":67,"./_mapCacheDelete":68,"./_mapCacheGet":69,"./_mapCacheHas":70,"./_mapCacheSet":71}],12:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":9,"./_stackClear":82,"./_stackDelete":83,"./_stackGet":84,"./_stackHas":85,"./_stackSet":86}],13:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":78}],14:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":78}],15:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],16:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":33,"./_isIndex":57,"./isArguments":92,"./isArray":93,"./isBuffer":96,"./isTypedArray":103}],17:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":20,"./eq":90}],18:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":20,"./eq":90}],19:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":90}],20:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":44}],21:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":99}],22:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":42}],23:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":13,"./_getRawTag":49,"./_objectToString":75}],24:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":23,"./isObjectLike":100}],25:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":60,"./_toSource":87,"./isFunction":97,"./isObject":99}],26:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":23,"./isLength":98,"./isObjectLike":100}],27:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":61,"./_nativeKeysIn":73,"./isObject":99}],28:[function(require,module,exports){
var Stack = require('./_Stack'),
    assignMergeValue = require('./_assignMergeValue'),
    baseFor = require('./_baseFor'),
    baseMergeDeep = require('./_baseMergeDeep'),
    isObject = require('./isObject'),
    keysIn = require('./keysIn'),
    safeGet = require('./_safeGet');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":12,"./_assignMergeValue":17,"./_baseFor":22,"./_baseMergeDeep":29,"./_safeGet":79,"./isObject":99,"./keysIn":104}],29:[function(require,module,exports){
var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    safeGet = require('./_safeGet'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":17,"./_cloneBuffer":36,"./_cloneTypedArray":37,"./_copyArray":38,"./_initCloneObject":56,"./_safeGet":79,"./isArguments":92,"./isArray":93,"./isArrayLikeObject":95,"./isBuffer":96,"./isFunction":97,"./isObject":99,"./isPlainObject":101,"./isTypedArray":103,"./toPlainObject":112}],30:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;

},{}],31:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":77,"./_setToString":80,"./identity":91}],32:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":44,"./constant":88,"./identity":91}],33:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],34:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],35:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":14}],36:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":78}],37:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":35}],38:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],39:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":18,"./_baseAssignValue":20}],40:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":78}],41:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":31,"./_isIterateeCall":58}],42:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],43:[function(require,module,exports){
var baseRange = require('./_baseRange'),
    isIterateeCall = require('./_isIterateeCall'),
    toFinite = require('./toFinite');

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;

},{"./_baseRange":30,"./_isIterateeCall":58,"./toFinite":110}],44:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":47}],45:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],46:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":59}],47:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":25,"./_getValue":50}],48:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":76}],49:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":13}],50:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],51:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":72}],52:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],53:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":72}],54:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":72}],55:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":72}],56:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":21,"./_getPrototype":48,"./_isPrototype":61}],57:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],58:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":57,"./eq":90,"./isArrayLike":94,"./isObject":99}],59:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],60:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":40}],61:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],62:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],63:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":19}],64:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":19}],65:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":19}],66:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":19}],67:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":8,"./_ListCache":9,"./_Map":10}],68:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":46}],69:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":46}],70:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":46}],71:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":46}],72:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":47}],73:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],74:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":45}],75:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],76:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],77:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":15}],78:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":45}],79:[function(require,module,exports){
/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

},{}],80:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":32,"./_shortOut":81}],81:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],82:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":9}],83:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],84:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],85:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],86:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":9,"./_Map":10,"./_MapCache":11}],87:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],88:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],89:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":99,"./now":106,"./toNumber":111}],90:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],91:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],92:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":24,"./isObjectLike":100}],93:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],94:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":97,"./isLength":98}],95:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":94,"./isObjectLike":100}],96:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":78,"./stubFalse":108}],97:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":23,"./isObject":99}],98:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],99:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],100:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],101:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":23,"./_getPrototype":48,"./isObjectLike":100}],102:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":23,"./isObjectLike":100}],103:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":26,"./_baseUnary":34,"./_nodeUtil":74}],104:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":16,"./_baseKeysIn":27,"./isArrayLike":94}],105:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":28,"./_createAssigner":41}],106:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":78}],107:[function(require,module,exports){
var createRange = require('./_createRange');

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;

},{"./_createRange":43}],108:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],109:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":89,"./isObject":99}],110:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":111}],111:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":99,"./isSymbol":102}],112:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":39,"./keysIn":104}],113:[function(require,module,exports){
"use strict"

var hyperscript = require("./render/hyperscript")

hyperscript.trust = require("./render/trust")
hyperscript.fragment = require("./render/fragment")

module.exports = hyperscript

},{"./render/fragment":116,"./render/hyperscript":117,"./render/trust":119}],114:[function(require,module,exports){
(function (global,setImmediate){
;(function() {
"use strict"
function Vnode(tag, key, attrs0, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
}
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i])
	}
	return children
}
var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty
function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}
function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}
function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text
	var className = attrs.className || attrs.class
	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}
		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key]
			}
		}
		attrs = newAttrs
	}
	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key]
		}
	}
	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined
			attrs.className = className
		}
		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className
		}
	}
	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true
			break
		}
	}
	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children
	} else {
		childList = children
	}
	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}
function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}
	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector)
	}
	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = 1
	}
	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}
	var normalized = Vnode.normalizeChildren(children)
	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}
hyperscript.trust = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}
hyperscript.fragment = function(attrs1, children) {
	return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)
}
var m = hyperscript
/** @constructor */
var PromisePolyfill = function(executor) {
	if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")
	if (typeof executor !== "function") throw new TypeError("executor must be a function")
	var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)
	var instance = self._instance = {resolvers: resolvers, rejectors: rejectors}
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
	function handler(list, shouldAbsorb) {
		return function execute(value) {
			var then
			try {
				if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
					if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
					executeOnce(then.bind(value))
				}
				else {
					callAsync(function() {
						if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)
						for (var i = 0; i < list.length; i++) list[i](value)
						resolvers.length = 0, rejectors.length = 0
						instance.state = shouldAbsorb
						instance.retry = function() {execute(value)}
					})
				}
			}
			catch (e) {
				rejectCurrent(e)
			}
		}
	}
	function executeOnce(then) {
		var runs = 0
		function run(fn) {
			return function(value) {
				if (runs++ > 0) return
				fn(value)
			}
		}
		var onerror = run(rejectCurrent)
		try {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}
	}
	executeOnce(executor)
}
PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
	var self = this, instance = self._instance
	function handle(callback, list, next, state) {
		list.push(function(value) {
			if (typeof callback !== "function") next(value)
			else try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}
		})
		if (typeof instance.retry === "function" && state === instance.state) instance.retry()
	}
	var resolveNext, rejectNext
	var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})
	handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)
	return promise
}
PromisePolyfill.prototype.catch = function(onRejection) {
	return this.then(null, onRejection)
}
PromisePolyfill.resolve = function(value) {
	if (value instanceof PromisePolyfill) return value
	return new PromisePolyfill(function(resolve) {resolve(value)})
}
PromisePolyfill.reject = function(value) {
	return new PromisePolyfill(function(resolve, reject) {reject(value)})
}
PromisePolyfill.all = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		var total = list.length, count = 0, values = []
		if (list.length === 0) resolve([])
		else for (var i = 0; i < list.length; i++) {
			(function(i) {
				function consume(value) {
					count++
					values[i] = value
					if (count === total) resolve(values)
				}
				if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
					list[i].then(consume, reject)
				}
				else consume(list[i])
			})(i)
		}
	})
}
PromisePolyfill.race = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		for (var i = 0; i < list.length; i++) {
			list[i].then(resolve, reject)
		}
	})
}
if (typeof window !== "undefined") {
	if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill
	var PromisePolyfill = window.Promise
} else if (typeof global !== "undefined") {
	if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill
	var PromisePolyfill = global.Promise
} else {
}
var buildQueryString = function(object) {
	if (Object.prototype.toString.call(object) !== "[object Object]") return ""
	var args = []
	for (var key0 in object) {
		destructure(key0, object[key0])
	}
	return args.join("&")
	function destructure(key0, value) {
		if (Array.isArray(value)) {
			for (var i = 0; i < value.length; i++) {
				destructure(key0 + "[" + i + "]", value[i])
			}
		}
		else if (Object.prototype.toString.call(value) === "[object Object]") {
			for (var i in value) {
				destructure(key0 + "[" + i + "]", value[i])
			}
		}
		else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))
	}
}
var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")
var _8 = function($window, Promise) {
	var callbackCount = 0
	var oncompletion
	function setCompletionCallback(callback) {oncompletion = callback}
	function finalizer() {
		var count = 0
		function complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}
		return function finalize(promise0) {
			var then0 = promise0.then
			promise0.then = function() {
				count++
				var next = then0.apply(promise0, arguments)
				next.then(complete, function(e) {
					complete()
					if (count === 0) throw e
				})
				return finalize(next)
			}
			return promise0
		}
	}
	function normalize(args, extra) {
		if (typeof args === "string") {
			var url = args
			args = extra || {}
			if (args.url == null) args.url = url
		}
		return args
	}
	function request(args, extra) {
		var finalize = finalizer()
		args = normalize(args, extra)
		var promise0 = new Promise(function(resolve, reject) {
			if (args.method == null) args.method = "GET"
			args.method = args.method.toUpperCase()
			var useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)
			if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify
			if (typeof args.deserialize !== "function") args.deserialize = deserialize
			if (typeof args.extract !== "function") args.extract = extract
			args.url = interpolate(args.url, args.data)
			if (useBody) args.data = args.serialize(args.data)
			else args.url = assemble(args.url, args.data)
			var xhr = new $window.XMLHttpRequest(),
				aborted = false,
				_abort = xhr.abort
			xhr.abort = function abort() {
				aborted = true
				_abort.call(xhr)
			}
			xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)
			if (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty("Content-Type"))) {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
			}
			if (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty("Accept"))) {
				xhr.setRequestHeader("Accept", "application/json, text/*")
			}
			if (args.withCredentials) xhr.withCredentials = args.withCredentials
			for (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {
				xhr.setRequestHeader(key, args.headers[key])
			}
			if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr
			xhr.onreadystatechange = function() {
				// Don't throw errors on xhr.abort().
				if(aborted) return
				if (xhr.readyState === 4) {
					try {
						var response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))
						if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
							resolve(cast(args.type, response))
						}
						else {
							var error = new Error(xhr.responseText)
							for (var key in response) error[key] = response[key]
							reject(error)
						}
					}
					catch (e) {
						reject(e)
					}
				}
			}
			if (useBody && (args.data != null)) xhr.send(args.data)
			else xhr.send()
		})
		return args.background === true ? promise0 : finalize(promise0)
	}
	function jsonp(args, extra) {
		var finalize = finalizer()
		args = normalize(args, extra)
		var promise0 = new Promise(function(resolve, reject) {
			var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++
			var script = $window.document.createElement("script")
			$window[callbackName] = function(data) {
				script.parentNode.removeChild(script)
				resolve(cast(args.type, data))
				delete $window[callbackName]
			}
			script.onerror = function() {
				script.parentNode.removeChild(script)
				reject(new Error("JSONP request failed"))
				delete $window[callbackName]
			}
			if (args.data == null) args.data = {}
			args.url = interpolate(args.url, args.data)
			args.data[args.callbackKey || "callback"] = callbackName
			script.src = assemble(args.url, args.data)
			$window.document.documentElement.appendChild(script)
		})
		return args.background === true? promise0 : finalize(promise0)
	}
	function interpolate(url, data) {
		if (data == null) return url
		var tokens = url.match(/:[^\/]+/gi) || []
		for (var i = 0; i < tokens.length; i++) {
			var key = tokens[i].slice(1)
			if (data[key] != null) {
				url = url.replace(tokens[i], data[key])
			}
		}
		return url
	}
	function assemble(url, data) {
		var querystring = buildQueryString(data)
		if (querystring !== "") {
			var prefix = url.indexOf("?") < 0 ? "?" : "&"
			url += prefix + querystring
		}
		return url
	}
	function deserialize(data) {
		try {return data !== "" ? JSON.parse(data) : null}
		catch (e) {throw new Error(data)}
	}
	function extract(xhr) {return xhr.responseText}
	function cast(type0, data) {
		if (typeof type0 === "function") {
			if (Array.isArray(data)) {
				for (var i = 0; i < data.length; i++) {
					data[i] = new type0(data[i])
				}
			}
			else return new type0(data)
		}
		return data
	}
	return {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}
}
var requestService = _8(window, PromisePolyfill)
var coreRenderer = function($window) {
	var $doc = $window.document
	var $emptyFragment = $doc.createDocumentFragment()
	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}
	var onevent
	function setEventCallback(callback) {return onevent = callback}
	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}
	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match1 = vnode.children.match(/^\s*?<(\w+)/im) || []
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"
		var temp = $doc.createElement(parent1)
		temp.innerHTML = vnode.children
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodes(fragment, children, 0, children.length, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs2 = vnode.attrs
		var is = attrs2 && attrs2.is
		ns = getNameSpace(vnode) || ns
		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element
		if (attrs2 != null) {
			setAttrs(vnode, attrs2, ns)
		}
		insertNode(parent, element, nextSibling)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(element, children, 0, children.length, hooks, null, ns)
				setLateAttrs(vnode)
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		vnode._state = vnode.state
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		initLifecycle(vnode._state, vnode, hooks)
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
			insertNode(parent, element, nextSibling)
			return element
		}
		else {
			vnode.domSize = 0
			return $emptyFragment
		}
	}
	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes)
			if (recycling) {
				var pool = old.pool
				old = old.concat(old.pool)
			}
			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start]
				if (o === v && !recycling) oldStart++, start++
				else if (o == null) oldStart++
				else if (v == null) start++
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
					oldStart++, start++
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
				}
				else {
					var o = old[oldEnd]
					if (o === v && !recycling) oldEnd--, start++
					else if (o == null) oldEnd--
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
						oldEnd--, start++
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end]
				if (o === v && !recycling) oldEnd--, end--
				else if (o == null) oldEnd--
				else if (v == null) end--
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					if (o.dom != null) nextSibling = o.dom
					oldEnd--, end--
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd)
					if (v != null) {
						var oldIndex = map[v.key]
						if (oldIndex != null) {
							var movable = old[oldIndex]
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
							insertNode(parent, toFragment(movable), nextSibling)
							old[oldIndex].skip = true
							if (movable.dom != null) nextSibling = movable.dom
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling)
							nextSibling = dom
						}
					}
					end--
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
			removeNodes(old, oldStart, oldEnd + 1, vnodes)
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode._state = old._state
			vnode.events = old.events
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {}
						initLifecycle(vnode.attrs, vnode, hooks)
					}
					else updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
		}
		else {
			removeNode(old, null)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns
		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle0 multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks)
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
			updateLifecycle(vnode._state, vnode, hooks)
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance, null)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				var key2 = vnode.key
				if (key2 != null) map[key2] = i
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count0 = vnode.domSize
		if (count0 != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count0 > 0) {
				var dom = vnode.dom
				while (--count0) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}
	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}
	function setContentEditable(vnode) {
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}
	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false
				else removeNode(vnode, context)
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				onremove(vnode)
				if (vnode.dom) {
					var count0 = vnode.domSize || 1
					if (count0 > 1) {
						var dom = vnode.dom
						while (--count0) {
							removeNodeFromDOM(dom.nextSibling)
						}
					}
					removeNodeFromDOM(vnode.dom)
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode]
						else context.pool.push(vnode)
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode
		if (parent != null) parent.removeChild(node)
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}
	//attrs2
	function setAttrs(vnode, attrs2, ns) {
		for (var key2 in attrs2) {
			setAttr(vnode, key2, null, attrs2[key2], ns)
		}
	}
	function setAttr(vnode, key2, old, value, ns) {
		var element = vnode.dom
		if (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return
		var nsLastIndex = key2.indexOf(":")
		if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)
		}
		else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)
		else if (key2 === "style") updateStyle(element, old, value)
		else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
			if (key2 === "value") {
				var normalized0 = "" + value // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return
			}
			// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
			if (vnode.tag === "input" && key2 === "type") {
				element.setAttribute(key2, value)
				return
			}
			element[key2] = value
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key2, "")
				else element.removeAttribute(key2)
			}
			else element.setAttribute(key2 === "className" ? "class" : key2, value)
		}
	}
	function setLateAttrs(vnode) {
		var attrs2 = vnode.attrs
		if (vnode.tag === "select" && attrs2 != null) {
			if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)
			if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)
		}
	}
	function updateAttrs(vnode, old, attrs2, ns) {
		if (attrs2 != null) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, old && old[key2], attrs2[key2], ns)
			}
		}
		if (old != null) {
			for (var key2 in old) {
				if (attrs2 == null || !(key2 in attrs2)) {
					if (key2 === "className") key2 = "class"
					if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)
					else if (key2 !== "key") vnode.dom.removeAttribute(key2)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}
	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null
		if (style == null) element.style.cssText = ""
		else if (typeof style === "string") element.style.cssText = style
		else {
			if (typeof old === "string") element.style.cssText = ""
			for (var key2 in style) {
				element.style[key2] = style[key2]
			}
			if (old != null && typeof old !== "string") {
				for (var key2 in old) {
					if (!(key2 in style)) element.style[key2] = ""
				}
			}
		}
	}
	//event
	function updateEvent(vnode, key2, value) {
		var element = vnode.dom
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e)
			onevent.call(element, e)
			return result
		}
		if (key2 in element) element[key2] = typeof value === "function" ? callback : null
		else {
			var eventName = key2.slice(2)
			if (vnode.events === undefined) vnode.events = {}
			if (vnode.events[key2] === callback) return
			if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)
			if (typeof value === "function") {
				vnode.events[key2] = callback
				element.addEventListener(eventName, vnode.events[key2], false)
			}
		}
	}
	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
			vnode.instance = old.instance
			return true
		}
		return false
	}
	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = $doc.activeElement
		var namespace = dom.namespaceURI
		// First time0 rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""
		if (!Array.isArray(vnodes)) vnodes = [vnodes]
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}
	return {render: render, setEventCallback: setEventCallback}
}
function throttle(callback) {
	//60fps translates to 16.6ms, round it down since setTimeout requires int
	var time = 16
	var last = 0, pending = null
	var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout
	return function() {
		var now = Date.now()
		if (last === 0 || now - last >= time) {
			last = now
			callback()
		}
		else if (pending === null) {
			pending = timeout(function() {
				pending = null
				callback()
				last = Date.now()
			}, time - (now - last))
		}
	}
}
var _11 = function($window) {
	var renderService = coreRenderer($window)
	renderService.setEventCallback(function(e) {
		if (e.redraw === false) e.redraw = undefined
		else redraw()
	})
	var callbacks = []
	function subscribe(key1, callback) {
		unsubscribe(key1)
		callbacks.push(key1, throttle(callback))
	}
	function unsubscribe(key1) {
		var index = callbacks.indexOf(key1)
		if (index > -1) callbacks.splice(index, 2)
	}
	function redraw() {
		for (var i = 1; i < callbacks.length; i += 2) {
			callbacks[i]()
		}
	}
	return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
}
var redrawService = _11(window)
requestService.setCompletionCallback(redrawService.redraw)
var _16 = function(redrawService0) {
	return function(root, component) {
		if (component === null) {
			redrawService0.render(root, [])
			redrawService0.unsubscribe(root)
			return
		}
		
		if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")
		
		var run0 = function() {
			redrawService0.render(root, Vnode(component))
		}
		redrawService0.subscribe(root, run0)
		redrawService0.redraw()
	}
}
m.mount = _16(redrawService)
var Promise = PromisePolyfill
var parseQueryString = function(string) {
	if (string === "" || string == null) return {}
	if (string.charAt(0) === "?") string = string.slice(1)
	var entries = string.split("&"), data0 = {}, counters = {}
	for (var i = 0; i < entries.length; i++) {
		var entry = entries[i].split("=")
		var key5 = decodeURIComponent(entry[0])
		var value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""
		if (value === "true") value = true
		else if (value === "false") value = false
		var levels = key5.split(/\]\[?|\[/)
		var cursor = data0
		if (key5.indexOf("[") > -1) levels.pop()
		for (var j = 0; j < levels.length; j++) {
			var level = levels[j], nextLevel = levels[j + 1]
			var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))
			var isValue = j === levels.length - 1
			if (level === "") {
				var key5 = levels.slice(0, j).join()
				if (counters[key5] == null) counters[key5] = 0
				level = counters[key5]++
			}
			if (cursor[level] == null) {
				cursor[level] = isValue ? value : isNumber ? [] : {}
			}
			cursor = cursor[level]
		}
	}
	return data0
}
var coreRouter = function($window) {
	var supportsPushState = typeof $window.history.pushState === "function"
	var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout
	function normalize1(fragment0) {
		var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)
		if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data
		return data
	}
	var asyncId
	function debounceAsync(callback0) {
		return function() {
			if (asyncId != null) return
			asyncId = callAsync0(function() {
				asyncId = null
				callback0()
			})
		}
	}
	function parsePath(path, queryData, hashData) {
		var queryIndex = path.indexOf("?")
		var hashIndex = path.indexOf("#")
		var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length
		if (queryIndex > -1) {
			var queryEnd = hashIndex > -1 ? hashIndex : path.length
			var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))
			for (var key4 in queryParams) queryData[key4] = queryParams[key4]
		}
		if (hashIndex > -1) {
			var hashParams = parseQueryString(path.slice(hashIndex + 1))
			for (var key4 in hashParams) hashData[key4] = hashParams[key4]
		}
		return path.slice(0, pathEnd)
	}
	var router = {prefix: "#!"}
	router.getPath = function() {
		var type2 = router.prefix.charAt(0)
		switch (type2) {
			case "#": return normalize1("hash").slice(router.prefix.length)
			case "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")
			default: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")
		}
	}
	router.setPath = function(path, data, options) {
		var queryData = {}, hashData = {}
		path = parsePath(path, queryData, hashData)
		if (data != null) {
			for (var key4 in data) queryData[key4] = data[key4]
			path = path.replace(/:([^\/]+)/g, function(match2, token) {
				delete queryData[token]
				return data[token]
			})
		}
		var query = buildQueryString(queryData)
		if (query) path += "?" + query
		var hash = buildQueryString(hashData)
		if (hash) path += "#" + hash
		if (supportsPushState) {
			var state = options ? options.state : null
			var title = options ? options.title : null
			$window.onpopstate()
			if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)
			else $window.history.pushState(state, title, router.prefix + path)
		}
		else $window.location.href = router.prefix + path
	}
	router.defineRoutes = function(routes, resolve, reject) {
		function resolveRoute() {
			var path = router.getPath()
			var params = {}
			var pathname = parsePath(path, params, params)
			var state = $window.history.state
			if (state != null) {
				for (var k in state) params[k] = state[k]
			}
			for (var route0 in routes) {
				var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$")
				if (matcher.test(pathname)) {
					pathname.replace(matcher, function() {
						var keys = route0.match(/:[^\/]+/g) || []
						var values = [].slice.call(arguments, 1, -2)
						for (var i = 0; i < keys.length; i++) {
							params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i])
						}
						resolve(routes[route0], params, path, route0)
					})
					return
				}
			}
			reject(path, params)
		}
		if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)
		else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute
		resolveRoute()
	}
	return router
}
var _20 = function($window, redrawService0) {
	var routeService = coreRouter($window)
	var identity = function(v) {return v}
	var render1, component, attrs3, currentPath, lastUpdate
	var route = function(root, defaultRoute, routes) {
		if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
		var run1 = function() {
			if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))
		}
		var bail = function(path) {
			if (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})
			else throw new Error("Could not resolve default route " + defaultRoute)
		}
		routeService.defineRoutes(routes, function(payload, params, path) {
			var update = lastUpdate = function(routeResolver, comp) {
				if (update !== lastUpdate) return
				component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"
				attrs3 = params, currentPath = path, lastUpdate = null
				render1 = (routeResolver.render || identity).bind(routeResolver)
				run1()
			}
			if (payload.view || typeof payload === "function") update({}, payload)
			else {
				if (payload.onmatch) {
					Promise.resolve(payload.onmatch(params, path)).then(function(resolved) {
						update(payload, resolved)
					}, bail)
				}
				else update(payload, "div")
			}
		}, bail)
		redrawService0.subscribe(root, run1)
	}
	route.set = function(path, data, options) {
		if (lastUpdate != null) {
			options = options || {}
			options.replace = true
		}
		lastUpdate = null
		routeService.setPath(path, data, options)
	}
	route.get = function() {return currentPath}
	route.prefix = function(prefix0) {routeService.prefix = prefix0}
	route.link = function(vnode1) {
		vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)
		vnode1.dom.onclick = function(e) {
			if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return
			e.preventDefault()
			e.redraw = false
			var href = this.getAttribute("href")
			if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)
			route.set(href, undefined, undefined)
		}
	}
	route.param = function(key3) {
		if(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]
		return attrs3
	}
	return route
}
m.route = _20(window, redrawService)
m.withAttr = function(attrName, callback1, context) {
	return function(e) {
		callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))
	}
}
var _28 = coreRenderer(window)
m.render = _28.render
m.redraw = redrawService.redraw
m.request = requestService.request
m.jsonp = requestService.jsonp
m.parseQueryString = parseQueryString
m.buildQueryString = buildQueryString
m.version = "1.1.6"
m.vnode = Vnode
if (typeof module !== "undefined") module["exports"] = m
else window.m = m
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":129}],115:[function(require,module,exports){
"use strict"

module.exports = require("./render/render")(window)

},{"./render/render":118}],116:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function(attrs, children) {
	return Vnode("[", attrs.key, attrs, Vnode.normalizeChildren(children), undefined, undefined)
}

},{"../render/vnode":120}],117:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty

function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}

function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}

function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text
	var className = attrs.className || attrs.class

	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}

		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key]
			}
		}

		attrs = newAttrs
	}

	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key]
		}
	}

	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined
			attrs.className = className
		}

		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className
		}
	}

	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true
			break
		}
	}

	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children
	} else {
		childList = children
	}

	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}

function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children

	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}

	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector)
	}

	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = 1
	}

	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}

	var normalized = Vnode.normalizeChildren(children)

	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}

module.exports = hyperscript

},{"../render/vnode":120}],118:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function($window) {
	var $doc = $window.document
	var $emptyFragment = $doc.createDocumentFragment()

	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}

	var onevent
	function setEventCallback(callback) {return onevent = callback}

	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}

	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match = vnode.children.match(/^\s*?<(\w+)/im) || []
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match[1]] || "div"
		var temp = $doc.createElement(parent1)

		temp.innerHTML = vnode.children
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodes(fragment, children, 0, children.length, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs = vnode.attrs
		var is = attrs && attrs.is

		ns = getNameSpace(vnode) || ns

		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element

		if (attrs != null) {
			setAttrs(vnode, attrs, ns)
		}

		insertNode(parent, element, nextSibling)

		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(element, children, 0, children.length, hooks, null, ns)
				setLateAttrs(vnode)
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		vnode._state = vnode.state
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		initLifecycle(vnode._state, vnode, hooks)
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
			insertNode(parent, element, nextSibling)
			return element
		}
		else {
			vnode.domSize = 0
			return $emptyFragment
		}
	}

	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes)
			if (recycling) {
				var pool = old.pool
				old = old.concat(old.pool)
			}

			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start]
				if (o === v && !recycling) oldStart++, start++
				else if (o == null) oldStart++
				else if (v == null) start++
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
					oldStart++, start++
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
				}
				else {
					var o = old[oldEnd]
					if (o === v && !recycling) oldEnd--, start++
					else if (o == null) oldEnd--
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
						oldEnd--, start++
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end]
				if (o === v && !recycling) oldEnd--, end--
				else if (o == null) oldEnd--
				else if (v == null) end--
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					if (o.dom != null) nextSibling = o.dom
					oldEnd--, end--
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd)
					if (v != null) {
						var oldIndex = map[v.key]
						if (oldIndex != null) {
							var movable = old[oldIndex]
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
							insertNode(parent, toFragment(movable), nextSibling)
							old[oldIndex].skip = true
							if (movable.dom != null) nextSibling = movable.dom
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling)
							nextSibling = dom
						}
					}
					end--
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
			removeNodes(old, oldStart, oldEnd + 1, vnodes)
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode._state = old._state
			vnode.events = old.events
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {}
						initLifecycle(vnode.attrs, vnode, hooks)
					}
					else updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
		}
		else {
			removeNode(old, null)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns

		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks)
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
			updateLifecycle(vnode._state, vnode, hooks)
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance, null)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				var key = vnode.key
				if (key != null) map[key] = i
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count = vnode.domSize
		if (count != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count > 0) {
				var dom = vnode.dom
				while (--count) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}

	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}

	function setContentEditable(vnode) {
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}

	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false
				else removeNode(vnode, context)
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				onremove(vnode)
				if (vnode.dom) {
					var count = vnode.domSize || 1
					if (count > 1) {
						var dom = vnode.dom
						while (--count) {
							removeNodeFromDOM(dom.nextSibling)
						}
					}
					removeNodeFromDOM(vnode.dom)
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode]
						else context.pool.push(vnode)
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode
		if (parent != null) parent.removeChild(node)
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}

	//attrs
	function setAttrs(vnode, attrs, ns) {
		for (var key in attrs) {
			setAttr(vnode, key, null, attrs[key], ns)
		}
	}
	function setAttr(vnode, key, old, value, ns) {
		var element = vnode.dom
		if (key === "key" || key === "is" || (old === value && !isFormAttribute(vnode, key)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key)) return
		var nsLastIndex = key.indexOf(":")
		if (nsLastIndex > -1 && key.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(nsLastIndex + 1), value)
		}
		else if (key[0] === "o" && key[1] === "n" && typeof value === "function") updateEvent(vnode, key, value)
		else if (key === "style") updateStyle(element, old, value)
		else if (key in element && !isAttribute(key) && ns === undefined && !isCustomElement(vnode)) {
			if (key === "value") {
				var normalized = "" + value // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized) return
			}
			// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
			if (vnode.tag === "input" && key === "type") {
				element.setAttribute(key, value)
				return
			}
			element[key] = value
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key, "")
				else element.removeAttribute(key)
			}
			else element.setAttribute(key === "className" ? "class" : key, value)
		}
	}
	function setLateAttrs(vnode) {
		var attrs = vnode.attrs
		if (vnode.tag === "select" && attrs != null) {
			if ("value" in attrs) setAttr(vnode, "value", null, attrs.value, undefined)
			if ("selectedIndex" in attrs) setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, undefined)
		}
	}
	function updateAttrs(vnode, old, attrs, ns) {
		if (attrs != null) {
			for (var key in attrs) {
				setAttr(vnode, key, old && old[key], attrs[key], ns)
			}
		}
		if (old != null) {
			for (var key in old) {
				if (attrs == null || !(key in attrs)) {
					if (key === "className") key = "class"
					if (key[0] === "o" && key[1] === "n" && !isLifecycleMethod(key)) updateEvent(vnode, key, undefined)
					else if (key !== "key") vnode.dom.removeAttribute(key)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}

	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null
		if (style == null) element.style.cssText = ""
		else if (typeof style === "string") element.style.cssText = style
		else {
			if (typeof old === "string") element.style.cssText = ""
			for (var key in style) {
				element.style[key] = style[key]
			}
			if (old != null && typeof old !== "string") {
				for (var key in old) {
					if (!(key in style)) element.style[key] = ""
				}
			}
		}
	}

	//event
	function updateEvent(vnode, key, value) {
		var element = vnode.dom
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e)
			onevent.call(element, e)
			return result
		}
		if (key in element) element[key] = typeof value === "function" ? callback : null
		else {
			var eventName = key.slice(2)
			if (vnode.events === undefined) vnode.events = {}
			if (vnode.events[key] === callback) return
			if (vnode.events[key] != null) element.removeEventListener(eventName, vnode.events[key], false)
			if (typeof value === "function") {
				vnode.events[key] = callback
				element.addEventListener(eventName, vnode.events[key], false)
			}
		}
	}

	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
			vnode.instance = old.instance
			return true
		}
		return false
	}

	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = $doc.activeElement
		var namespace = dom.namespaceURI

		// First time rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""

		if (!Array.isArray(vnodes)) vnodes = [vnodes]
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}

	return {render: render, setEventCallback: setEventCallback}
}

},{"../render/vnode":120}],119:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}

},{"../render/vnode":120}],120:[function(require,module,exports){
"use strict"

function Vnode(tag, key, attrs, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
}
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i])
	}
	return children
}

module.exports = Vnode

},{}],121:[function(require,module,exports){
"use strict"

module.exports = require("./stream/stream")

},{"./stream/stream":122}],122:[function(require,module,exports){
/* eslint-disable */
;(function() {
"use strict"
/* eslint-enable */

var guid = 0, HALT = {}
function createStream() {
	function stream() {
		if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])
		return stream._state.value
	}
	initStream(stream)

	if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])

	return stream
}
function initStream(stream) {
	stream.constructor = createStream
	stream._state = {id: guid++, value: undefined, state: 0, derive: undefined, recover: undefined, deps: {}, parents: [], endStream: undefined, unregister: undefined}
	stream.map = stream["fantasy-land/map"] = map, stream["fantasy-land/ap"] = ap, stream["fantasy-land/of"] = createStream
	stream.valueOf = valueOf, stream.toJSON = toJSON, stream.toString = valueOf

	Object.defineProperties(stream, {
		end: {get: function() {
			if (!stream._state.endStream) {
				var endStream = createStream()
				endStream.map(function(value) {
					if (value === true) {
						unregisterStream(stream)
						endStream._state.unregister = function(){unregisterStream(endStream)}
					}
					return value
				})
				stream._state.endStream = endStream
			}
			return stream._state.endStream
		}}
	})
}
function updateStream(stream, value) {
	updateState(stream, value)
	for (var id in stream._state.deps) updateDependency(stream._state.deps[id], false)
	if (stream._state.unregister != null) stream._state.unregister()
	finalize(stream)
}
function updateState(stream, value) {
	stream._state.value = value
	stream._state.changed = true
	if (stream._state.state !== 2) stream._state.state = 1
}
function updateDependency(stream, mustSync) {
	var state = stream._state, parents = state.parents
	if (parents.length > 0 && parents.every(active) && (mustSync || parents.some(changed))) {
		var value = stream._state.derive()
		if (value === HALT) return false
		updateState(stream, value)
	}
}
function finalize(stream) {
	stream._state.changed = false
	for (var id in stream._state.deps) stream._state.deps[id]._state.changed = false
}

function combine(fn, streams) {
	if (!streams.every(valid)) throw new Error("Ensure that each item passed to stream.combine/stream.merge is a stream")
	return initDependency(createStream(), streams, function() {
		return fn.apply(this, streams.concat([streams.filter(changed)]))
	})
}

function initDependency(dep, streams, derive) {
	var state = dep._state
	state.derive = derive
	state.parents = streams.filter(notEnded)

	registerDependency(dep, state.parents)
	updateDependency(dep, true)

	return dep
}
function registerDependency(stream, parents) {
	for (var i = 0; i < parents.length; i++) {
		parents[i]._state.deps[stream._state.id] = stream
		registerDependency(stream, parents[i]._state.parents)
	}
}
function unregisterStream(stream) {
	for (var i = 0; i < stream._state.parents.length; i++) {
		var parent = stream._state.parents[i]
		delete parent._state.deps[stream._state.id]
	}
	for (var id in stream._state.deps) {
		var dependent = stream._state.deps[id]
		var index = dependent._state.parents.indexOf(stream)
		if (index > -1) dependent._state.parents.splice(index, 1)
	}
	stream._state.state = 2 //ended
	stream._state.deps = {}
}

function map(fn) {return combine(function(stream) {return fn(stream())}, [this])}
function ap(stream) {return combine(function(s1, s2) {return s1()(s2())}, [stream, this])}
function valueOf() {return this._state.value}
function toJSON() {return this._state.value != null && typeof this._state.value.toJSON === "function" ? this._state.value.toJSON() : this._state.value}

function valid(stream) {return stream._state }
function active(stream) {return stream._state.state === 1}
function changed(stream) {return stream._state.changed}
function notEnded(stream) {return stream._state.state !== 2}

function merge(streams) {
	return combine(function() {
		return streams.map(function(s) {return s()})
	}, streams)
}

function scan(reducer, seed, stream) {
	var newStream = combine(function (s) {
		return seed = reducer(seed, s._state.value)
	}, [stream])

	if (newStream._state.state === 0) newStream(seed)

	return newStream
}

function scanMerge(tuples, seed) {
	var streams = tuples.map(function(tuple) {
		var stream = tuple[0]
		if (stream._state.state === 0) stream(undefined)
		return stream
	})

	var newStream = combine(function() {
		var changed = arguments[arguments.length - 1]

		streams.forEach(function(stream, idx) {
			if (changed.indexOf(stream) > -1) {
				seed = tuples[idx][1](seed, stream._state.value)
			}
		})

		return seed
	}, streams)

	return newStream
}

createStream["fantasy-land/of"] = createStream
createStream.merge = merge
createStream.combine = combine
createStream.scan = scan
createStream.scanMerge = scanMerge
createStream.HALT = HALT

if (typeof module !== "undefined") module["exports"] = createStream
else if (typeof window.m === "function" && !("stream" in window.m)) window.m.stream = createStream
else window.m = {stream : createStream}

}());

},{}],123:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],124:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],125:[function(require,module,exports){
(function (process,setImmediate){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof self !== "undefined") {
        self.Q = definition();

    } else {
        throw new Error("This environment was not anticiapted by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":124,"timers":129}],126:[function(require,module,exports){
/*
 * Qanimationframe.js - Promisified requestAnimationFrame with Q
 */
/*jslint newcap: true */
(function (definition) {
    if (typeof exports === "object") {
        module.exports = definition();
    } else {
        window.QanimationFrame = definition();
    }
})(function () {
  "use strict";

  // Import Q
  var Q = window.Q || require("q");

  // requestAnimationFrame polyfill
  var requestAnimationFrame = (function(){
    return window.requestAnimationFrame       ||
           window.oRequestAnimationFrame      ||
           window.msRequestAnimationFrame     ||
           window.mozRequestAnimationFrame    ||
           window.webkitRequestAnimationFrame ||
           function (callback) {
             window.setTimeout(callback, 1000 / 60);
           };
  })();

  // QanimationFrame(f: function) => promise containing the return value of f
  // ---
  //
  var QanimationFrame = function (f) {
    var d = Q.defer();
    requestAnimationFrame(function () {
      try {
        d.resolve(f());
      } catch (e) {
        d.reject(e);
      }
    });
    return d.promise;
  };

  return QanimationFrame;
});

},{"q":125}],127:[function(require,module,exports){
// This library started as an experiment to see how small I could make
// a functional router. It has since been optimized (and thus grown).
// The redundancy and inelegance here is for the sake of either size
// or speed.
(function (root, factory) {
  var define = root.define;

  if (define && define.amd) {
    define('rlite', [], factory);
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = factory();
  } else {
    root.Rlite = factory();
  }
}(this, function () { return function() {
    var routes = {},
        decode = decodeURIComponent;

    function noop(s) { return s; }

    function sanitize(url) {
      ~url.indexOf('/?') && (url = url.replace('/?', '?'));
      url[0] == '/' && (url = url.slice(1));
      url[url.length - 1] == '/' && (url = url.slice(0, -1));

      return url;
    }

    function processUrl(url, esc) {
      var pieces = url.split('/'),
          rules = routes,
          params = {};

      for (var i = 0; i < pieces.length && rules; ++i) {
        var piece = esc(pieces[i]);
        rules = rules[piece.toLowerCase()] || rules[':'];
        rules && rules['~'] && (params[rules['~']] = piece);
      }

      return rules && {
        cb: rules['@'],
        params: params
      };
    }

    function processQuery(url, ctx, esc) {
      if (url && ctx.cb) {
        var hash = url.indexOf('#'),
            query = (hash < 0 ? url : url.slice(0, hash)).split('&');

        for (var i = 0; i < query.length; ++i) {
          var nameValue = query[i].split('=');

          ctx.params[nameValue[0]] = esc(nameValue[1]);
        }
      }

      return ctx;
    }

    function lookup(url) {
      var querySplit = sanitize(url).split('?'),
          esc = ~url.indexOf('%') ? decode : noop;

      return processQuery(querySplit[1], processUrl(querySplit[0], esc) || {}, esc);
    }

    return {
      add: function(route, handler) {

        var pieces = route.split('/'),
            rules = routes;

        for (var i = 0; i < pieces.length; ++i) {
          var piece = pieces[i],
              name = piece[0] == ':' ? ':' : piece.toLowerCase();

          rules = rules[name] || (rules[name] = {});

          name == ':' && (rules['~'] = piece.slice(1));
        }

        rules['@'] = handler;
      },

      exists: function (url) {
        return !!lookup(url).cb;
      },

      lookup: lookup,

      run: function(url) {
        var result = lookup(url);

        result.cb && result.cb({
          url: url,
          params: result.params
        });

        return !!result.cb;
      }
    };
  };
}));

},{}],128:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],129:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":124,"timers":129}],130:[function(require,module,exports){
'use strict';

var style = document.createElement('p').style,
    prefixes = 'O ms Moz webkit'.split(' '),
    hasPrefix = /^(o|ms|moz|webkit)/,
    upper = /([A-Z])/g,
    memo = {};

function get(key){
    return (key in memo) ? memo[key] : memo[key] = prefix(key);
}

function prefix(key){
    var capitalizedKey = key.replace(/-([a-z])/g, function(s, match){
            return match.toUpperCase();
        }),
        i = prefixes.length,
        name;

    if (style[capitalizedKey] !== undefined) return capitalizedKey;

    capitalizedKey = capitalize(key);

    while (i--) {
        name = prefixes[i] + capitalizedKey;
        if (style[name] !== undefined) return name;
    }

    throw new Error('unable to prefix ' + key);
}

function capitalize(str){
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function dashedPrefix(key){
    var prefixedKey = get(key),
        upper = /([A-Z])/g;

    if (upper.test(prefixedKey)) {
        prefixedKey = (hasPrefix.test(prefixedKey) ? '-' : '') + prefixedKey.replace(upper, '-$1');
    }

    return prefixedKey.toLowerCase();
}

module.exports = get;
module.exports.dash = dashedPrefix;

},{}],131:[function(require,module,exports){
// Zanimo.js - Promise based CSS3 transitions
// (c) 2011-2014 Paul Panserrieu

'use strict';

var Q = require('q'),
    QanimationFrame = require('qanimationframe'),
    prefix = require('vendor-prefix'),
    normalizeTransformValue = require('../src/normalize-transform-value'),
    shorthand = require('../src/transition-shorthand-property'),
    transition = prefix('transition'),
    transitionend = 'WebkitTransition' in document.body.style ? 'webkitTransitionEnd' : 'transitionend',

    isDOM = function (el) {
        try {
            return el && el.nodeType;
        } catch(err) {
            return false;
        };
    },

    addTransition = function (elt, attr, value, duration, easing) {
        var currentValue = elt.style[transition];
        attr = prefix.dash(attr);
        if (currentValue) {
            elt.style[transition] = currentValue + ", " + shorthand(attr, duration, easing);
        }
        else {
            elt.style[transition] = shorthand(attr, duration, easing);
        }
        elt.style[prefix(attr)] = value;
    },

    removeTransition = function (el, attr) {
        el.style[transition] = el.style[transition]
            .split(',').filter(function(t) {
                return !t.match(attr);
            }).join(',');
    },

    applycss = function (el, attr, value) {
        return QanimationFrame(function(){
            el.style[prefix.dash(attr)] = value;
            return el;
        });
    },

    css = function (el, attr, value) {
        if(el._zanimo && el._zanimo.hasOwnProperty(attr)) {
            el._zanimo[attr].defer.reject(new Error(
                "Zanimo transition with transform=" +
                el._zanimo[attr].value +
                " stopped by transform=" + value
            ));
            el._zanimo[attr].cb();
        }
        return applycss(el, attr, value);
    },

    animate = function (el, attr, value, duration, easing) {
        var prefixed = prefix.dash(attr),
            d = Q.defer(),
            timeout,
            cb = function (clear) {
                if (timeout) { clearTimeout(timeout); timeout = null; }
                removeTransition(el, attr);
                el.removeEventListener(transitionend, cbTransitionend);
                if (clear) { delete el._zanimo[attr]; }
            },
            cbTransitionend = function (evt) {
                if(prefix(evt.propertyName) === prefix(prefixed)) {
                    cb(true);
                    d.resolve(el);
                }
            };

        el.addEventListener(transitionend, cbTransitionend);

        QanimationFrame(function () {
            addTransition(el, attr, normalizeTransformValue(value), duration, easing);
            timeout = setTimeout(function () {
                var rawVal = el.style.getPropertyValue(prefixed),
                    domVal = normalizeTransformValue(rawVal),
                    givenVal = normalizeTransformValue(value);

                cb(true);
                if (domVal === givenVal) { d.resolve(el); }
                else {
                    d.reject( new Error("Zanimo transition: with "
                        + attr + " = " + givenVal + ", DOM value=" + domVal
                    ));
                }
            }, duration + 20 );

            el._zanimo = el._zanimo || { };
            if(el._zanimo[attr]) {
                el._zanimo[attr].defer.reject(new Error(
                    "Zanimo transition with " +
                    attr + "=" + el._zanimo[attr].value +
                    " stopped by transition with " + attr + "=" + value
                ));
                el._zanimo[attr].cb();
            }
            el._zanimo[attr] = {cb: cb, value: value, defer: d};
        });

        return d.promise;
    };

/**
 * Zanimo(el | promise[el])
 * > Returns a Promise of el.
 *
 * Zanimo(el | promise[el], attr, value)
 * > Sets el.style[attr]=value and returns the promise of el.
 *
 * Zanimo(el | promise[el], attr, value, duration, [easing])
 * > Performs a transition.
 */
var Zanimo = function (el, attr, value, duration, easing) {
    var args = arguments,
        arity = arguments.length;
    if (arity === 0 || arity === 2 || arity > 5) {
        return Q.reject(new Error("Zanimo invalid arguments"));
    }
    if (Q.isPromise(el)) {
        return el.then(function (val) {
            return Zanimo.apply(this, [val].concat(Array.prototype.slice.call(args, 1)));
        });
    }
    if (!isDOM(el)) {
        return Q.reject(new Error("Zanimo require an HTMLElement, or a promise of an HTMLElement"));
    }
    if (arity === 1) {
        return Q(el);
    }
    try {
        prefix.dash(attr);
    } catch(err) {
        return Q.reject(new Error("Zanimo transition: " + attr + ' is not supported!'));
    };
    if (arity === 3) {
        return css(el, attr, value);
    }
    if(window.isNaN(parseInt(duration, 10))) {
        return Q.reject(new Error("Zanimo transition: duration must be an integer!"));
    }
    return animate(el, attr, value, duration, easing);
};

/**
 * A function wrapping `Zanimo(el, ...)` as a `f(...)(el)` for easy chaining purpose.
 */
Zanimo.f = function (attr, value, duration, easing) {
    var args = Array.prototype.slice.call(arguments);
    return function (el) {
        return Zanimo.apply(this, [el].concat(args));
    };
};

module.exports = Zanimo;

},{"../src/normalize-transform-value":133,"../src/transition-shorthand-property":134,"q":125,"qanimationframe":126,"vendor-prefix":130}],132:[function(require,module,exports){
'use strict';

var matchParenthesis = /(\(.+?\))/g,
    space = / +/g,
    emptyString = "",
    whitespace = " ",

    normalize = function (match) {
        var args = match.substr(1, match.length-2).split(","),
            rst = args.map(function (arg) {
                return parseFloat(arg.replace(space, emptyString));
            });
        return "(" + rst.join(",") + ")";
    };

module.exports = function (t) {
    return  typeof t === 'string' ? t.replace(space, whitespace).replace(matchParenthesis, normalize) : t;
};

},{}],133:[function(require,module,exports){
'use strict';

var Color = require('color'),
    matchParenthesis = /(\(.+?\))/g,
    matchColors = /(\brgba\b|\bhsl\b|\bhsla\b)(\(.+?\))/g,
    space = / +/g,
    emptyString = "",
    whitespace = " ",
    zeropixel = /^0px$/g,
    zero = "0",

    normArgs = function (match) {
        var args = match.substr(1, match.length-2).split(","),
            rst = args.map(function (arg) {
                return arg.replace(space, emptyString).replace(zeropixel, zero);
            });
        return "(" + rst.join(",") + ")";
    },

    normColors = function (match) {
        var c = Color(match);
        if (c.alpha() ) { c.alpha(Math.round(c.alpha() * 10) / 10); }
        return c.rgbString();
    },

    normalize = function (val) {
        return val.replace(space, whitespace)
            .replace(matchColors, normColors)
            .replace(matchParenthesis, normArgs);
    };

module.exports = function (val) {
    if (val === null || val === undefined) return emptyString;
    return window.isNaN(val) ? normalize(val) : val.toString();
};

},{"color":6}],134:[function(require,module,exports){
'use strict';

var prefix = require('vendor-prefix'),
    normalizeTransformValue = require('./normalize-transform-value'),
    normalizeTimingFunction = require('./normalize-timing-function'),
    transition = prefix.dash('transition'),
    el = document.createElement('div'),
    test = 'opacity 100ms linear 0s',
    normalizedTest = normalizeTransformValue(test),
    shorthand = function shorthand(v, d, t) {
        return v + " " + d + "ms " + (t || "linear");
    };

el.style[transition] = normalizedTest;

if(normalizeTransformValue(el.style[transition]) === normalizedTest) {
    shorthand = function (v, d, t) {
        return v + " " + d + "ms " + (normalizeTimingFunction(t) || "linear") + " 0s";
    };
}

module.exports = shorthand;

},{"./normalize-timing-function":132,"./normalize-transform-value":133,"vendor-prefix":130}],135:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = backbutton;

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('./utils');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stack = [];

function backbutton() {
  var b = stack.pop();
  if ((0, _isFunction2.default)(b)) {
    b('backbutton');
    _mithril2.default.redraw();
  } else if (!/^\/$/.test(_mithril2.default.route())) {
    // if playing a game as anon ask for confirmation
    if (/^\/game\/[a-zA-Z0-9]{12}/.test(_mithril2.default.route())) {
      navigator.notification.confirm((0, _i18n2.default)('thereIsAGameInProgress'), function (i) {
        if (i === 1) (0, _utils.backHistory)();
      });
    } else {
      (0, _utils.backHistory)();
    }
  } else {
    window.navigator.app.exitApp();
  }
};

backbutton.stack = stack;

},{"./i18n":138,"./utils":205,"lodash/isFunction":97,"mithril":114}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var defaults = {
  apiVersion: 1,
  fetchTimeoutMs: 10000
};

var config = Object.assign({}, defaults, window.oyunkeyf);

exports.default = config;

},{}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.apiVersion = exports.SESSION_ID_KEY = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.fetchJSON = fetchJSON;

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _spinner = require('./spinner');

var _spinner2 = _interopRequireDefault(_spinner);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _querystring = require('./utils/querystring');

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SESSION_ID_KEY = exports.SESSION_ID_KEY = 'sessionId';

var baseUrl = _config2.default.apiEndPoint;

function addQueryString(url, queryString) {
  var prefix = url.indexOf('?') < 0 ? '?' : '&';
  var res = url + prefix + queryString;
  return res;
}

function request(url, type, opts, feedback) {

  var timeoutId = void 0;

  function onComplete() {
    clearTimeout(timeoutId);
    if (feedback) _spinner2.default.stop();
  }

  if (opts && opts.query) {
    var query = (0, _querystring.buildQueryString)(opts.query);
    if (query !== '') {
      url = addQueryString(url, query);
    }
    delete opts.query;
  }

  var cfg = {
    method: 'GET',
    headers: {
      'X-Requested-With': 'XMLHttpRequest',
      'Accept': 'application/vnd.oyunkeyf.v' + _config2.default.apiVersion + '+json'
    }
  };

  (0, _merge2.default)(cfg, opts);

  var init = _extends({}, cfg, {
    credentials: 'include',
    headers: new Headers(cfg.headers)
  });

  if ((init.method === 'POST' || init.method === 'PUT') && !init.headers.get('Content-Type')) {
    init.headers.append('Content-Type', 'application/json; charset=UTF-8');
    if (!init.body) {
      init.body = '{}';
    }
  }

  var sid = _storage2.default.get(SESSION_ID_KEY);
  if (sid !== null) {
    init.headers.append(SESSION_ID_KEY, sid);
  }

  var fullUrl = url.indexOf('http') > -1 ? url : baseUrl + url;

  var timeoutPromise = new Promise(function (_, reject) {
    timeoutId = setTimeout(function () {
      return reject(new Error('Request timeout'));
    }, _config2.default.fetchTimeoutMs);
  });

  var respOrTimeout = Promise.race([fetch(fullUrl, init), timeoutPromise]);

  if (feedback) {
    _spinner2.default.spin();
  }

  return new Promise(function (resolve, reject) {
    respOrTimeout.then(function (r) {
      onComplete();
      if (r.ok) {
        resolve(r[type]());
      } else {
        r.text().then(function (bodyText) {
          try {
            reject({
              status: r.status,
              body: JSON.parse(bodyText)
            });
          } catch (_) {
            reject({
              status: r.status,
              body: r.statusText
            });
          }
        });
      }
    }).catch(function (err) {
      onComplete();
      reject({
        status: 0,
        body: err.message
      });
    });
  });
}

function fetchJSON(url, opts) {
  var feedback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  return request(url, 'json', opts, feedback);
}

var apiVersion = exports.apiVersion = 1;

// const baseUrl = window.oyunkeyf.apiEndPoint;

function onSuccess(data) {
  _spinner2.default.stop();
  return data;
}

function onError(data) {
  _spinner2.default.stop();
  throw data;
}

function xhrConfig(xhr) {
  xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  xhr.setRequestHeader('Accept', 'application/vnd.oyunkeyf.v' + apiVersion + '+json');
  xhr.withCredentials = true;
  xhr.timeout = 8000;
}

// convenient wrapper around m.request
// export function request(url, opts, feedback, xhrConf) {
//   var cfg = {
//     url: baseUrl + url,
//     method: 'GET',
//     data: { },
//     config: xhrConf || xhrConfig,
//     deserialize: function(text) {
//       try {
//         return JSON.parse(text);
//       } catch (e) {
//         throw { response: { error: 'Cannot read data from the server' }};
//       }
//     },
//     unwrapError: function(response, xhr) {
//       return { response, status: xhr.status };
//     }
//   };
//   merge(cfg, opts);

//   if (cfg.method === 'GET') {
//     cfg.data._ = Date.now();
//   }

//   var promise = m.request(cfg);

//   if (feedback) {
//     spinner.spin(document.body);
//     return promise.then(onSuccess, onError);
//   } else {
//     return promise;
//   }
// }

},{"./config":136,"./spinner":150,"./storage":151,"./utils/querystring":206,"lodash/merge":105}],138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLang = getLang;
exports.default = i18n;
exports.loadPreferredLanguage = loadPreferredLanguage;
exports.loadLanguage = loadLanguage;

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultCode = 'tr';

var lang = defaultCode;
var messages = {};

var untranslated = {};

function getLang() {
  return lang;
}

function i18n(key) {
  var str = messages[key] || untranslated[key] || key;

  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  args.forEach(function (a) {
    str = str.replace('%s', String(a));
  });

  return str;
}

function loadPreferredLanguage() {
  var fromSettings = _settings2.default.general.lang();
  if (fromSettings) {
    return loadLanguage(fromSettings);
  }

  return new Promise(function (resolve) {
    window.navigator.globalization.getPreferredLanguage(function (l) {
      return resolve(l.value.split('-')[0]);
    }, function () {
      return resolve(defaultCode);
    });
  }).then(function (code) {
    _settings2.default.general.lang(code);
    return code;
  }).then(loadFile).then(loadMomentLocale);
}

function loadLanguage(lang) {
  return loadFile(lang).then(loadMomentLocale);
}

function loadFile(code) {
  return (0, _utils.loadLocalJsonFile)('i18n/' + code + '.json').then(function (data) {
    lang = code;
    messages = data;
    return code;
  }).catch(function (error) {
    if (code === defaultCode) throw new Error(error);
    return loadFile(defaultCode);
  });
}

// export function getAvailableLanguages() {
//   return m.request({
//     url: 'i18n/refs.json',
//     method: 'GET'
//   }).then(data => { return data; }, error => {
//     // same workaround for iOS as above
//     if (error && error[0][0] === 'tr')
//       return error;
//     else
//       throw { error: 'Cannot load languages' };
//   });
// }


// export function loadFromSettings() {
//   return loadFile(settings.general.lang()).then(loadMomentLocale);
// }

// function loadFile(code) {
//   return m.request({
//     url: 'i18n/' + code + '.json',
//     method: 'GET',
//     deserialize: function(text) {
//       try {
//         return JSON.parse(text);
//       } catch (e) {
//         throw { error: 'Lang not available' };
//       }
//     }
//   }).then(function(data) {
//     messages = data;
//     return code;
//   }, function(error) {
//     // workaround for iOS: because xhr for local file has a 0 status it will
//     // reject the promise and still have the response object
//     if (error && error.playWithAFriend) {
//       messages = error;
//       return code;
//     } else {
//       if (code === defaultCode) throw new Error(error);
//       return loadFile(defaultCode);
//     }
//   });
// }

function loadMomentLocale(code) {
  if (code !== 'en') {
    var script = document.createElement('script');
    script.src = 'moment/locale/' + code + '.js';
    document.head.appendChild(script);
  }
  window.moment.locale(code);
  return code;
}

},{"./settings":147,"./utils":205}],139:[function(require,module,exports){
'use strict';

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('./i18n');

var _xhr = require('./xhr');

var xhr = _interopRequireWildcard(_xhr);

var _helper = require('./ui/helper');

var helper = _interopRequireWildcard(_helper);

var _backbutton = require('./backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _socket = require('./socket');

var _socket2 = _interopRequireDefault(_socket);

var _routes = require('./routes');

var _routes2 = _interopRequireDefault(_routes);

var _appMode = require('./utils/appMode');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.moment = _moment2.default; /* application entry point */

// import './polyfills';


// for moment a global object makes loading locales easier


var firstConnection = true;

function main() {
  _routes2.default.init();
  // cache viewport dims
  helper.viewportDim();

  // pull session data once (to log in user automatically thanks to cookie)
  // and also listen to online event in case network was disconnected at app
  // startup
  if (utils.hasNetwork()) {
    onOnline();
  }

  document.addEventListener('online', onOnline, false);
  document.addEventListener('offline', onOffline, false);
  document.addEventListener('resume', onResume, false);
  document.addEventListener('pause', onPause, false);
  document.addEventListener('backbutton', _backbutton2.default, false);
  window.addEventListener('unload', function () {
    _socket2.default.destroy();
    _socket2.default.terminate();
  });
  window.addEventListener('resize', onResize, false);

  if (cordova.platformId === 'android') {
    window.StatusBar.backgroundColorByHexString('#151A1E');
  }

  setTimeout(function () {
    window.navigator.splashscreen.hide();
    window.StatusBar.hide();
    // xhrStatus();
  }, 500);
}

function onOnline() {
  if ((0, _appMode.isForeground)()) {
    if (firstConnection) {
      firstConnection = false;
      // xhr.status();

      _session2.default.rememberLogin().then(function (user) {
        var serverLang = user.language && user.language.split('-')[0];
        if (serverLang) {
          (0, _i18n.ensureLangIsAvailable)(serverLang).then(function (lang) {
            _settings2.default.general.lang(lang);
            (0, _i18n.loadLanguage)(lang);
          });
        }
        (0, _redraw2.default)();
      }).catch(function () {
        console.log('connected as anonymous');
      });
    } else {
      _socket2.default.connect();
      _session2.default.refresh();
    }
  }
}

function onOffline() {
  if ((0, _appMode.isForeground)() && !hasNetwork()) {
    _socket2.default.disconnect();
    (0, _redraw2.default)();
  }
}

function onResize() {
  helper.clearCachedViewportDim();
  (0, _redraw2.default)();
}

function onResume() {
  (0, _appMode.setForeground)();
  _session2.default.refresh();
  _socket2.default.connect();
  (0, _redraw2.default)();
}

function onPause() {
  (0, _appMode.setBackground)();
  _socket2.default.disconnect();
}

// function handleError(event, source, fileno, columNumber) {
//   var description = event + ' at ' + source + ' [' + fileno + ', ' + columNumber + ']';
// }

// window.onerror = handleError;

document.addEventListener('deviceready', function () {
  return (0, _i18n.loadPreferredLanguage)().then(main);
}, false);

},{"./backbutton":135,"./i18n":138,"./routes":145,"./session":146,"./settings":147,"./socket":149,"./ui/helper":156,"./utils":205,"./utils/appMode":203,"./utils/redraw":207,"./xhr":210,"moment":123}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _status = require('./status');

var _status2 = _interopRequireDefault(_status);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function playable(data) {
  return data.game.status.id < _status2.default.ids.aborted;
}

function isPlayerPlaying(data) {
  return playable(data) && !data.player.spectator;
}

function isPlayerTurn(data) {
  return isPlayerPlaying(data) && data.game.player === data.player.side;
}

function getPlayer(data, side) {
  return ['player', 'opponentLeft', 'opponentRight', 'opponentUp'].map(function (k) {
    return data[k];
  }).filter(function (player) {
    return player.side === side;
  })[0];
}

function result(data) {
  if (_status2.default.aborted(data)) {
    return (0, _i18n2.default)('gameAborted');
  } else if (_status2.default.finished(data)) {
    return (0, _i18n2.default)('gameFinished');
  }
};

var sides = ["east", "north", "west", "south"];

function sideByPly(ply) {
  return sides[ply % 4];
}

function setOnGame(data, side, onGame) {
  var player = getPlayer(data, side);
  player.onGame = onGame;
}

// function roundsOrScores(game) {
//   if (game.rounds) {
//     return data.
//   } else if (data.scores) {

//   } else {
//     return '';
//   }
// }

function title(data) {
  var text;
  if (isPlayerTurn(data)) {
    text = (0, _i18n2.default)('yourTurn');
  } else {
    text = (0, _i18n2.default)('waitingForOpponent');
  }
  // const variant = getVariant(data.game.variant.key);
  // const name = variant ? (variant.shortName || variant.name) : '';
  return text;
}

exports.default = {
  isPlayerPlaying: isPlayerPlaying,
  isPlayerTurn: isPlayerTurn,
  getPlayer: getPlayer,
  sideByPly: sideByPly,
  playable: playable,
  setOnGame: setOnGame,
  title: title,
  result: result
};

},{"../i18n":138,"./status":143}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.playerName = playerName;
exports.aiName = aiName;

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function playerName(player) {
  if (player.name || player.username || player.user) {
    var name = player.name || player.username || player.user.username;
    return name;
  }
  if (player.ai) {
    return aiName(player);
  }
  return 'Anonymous';
}

function aiName(player) {
  return (0, _i18n2.default)('aiBot', 1);
}

},{"../i18n":138}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.humanSetupFromSettings = humanSetupFromSettings;
function humanSetupFromSettings(settingsObj) {
  return {
    mode: settingsObj.mode(),
    variant: settingsObj.variant(),
    rounds: settingsObj.rounds()
  };
}

},{}],143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ids = {
  created: 10,
  started: 20,
  aborted: 25,
  middleEnd: 30,
  normalEnd: 40,
  variantEnd: 70
}; // scalaokey/src/main/scala/Status.scala

function started(data) {
  return data.game.status.id >= ids.started;
}

function finished(data) {
  return data.game.status.id >= ids.middleEnd;
}

function aborted(data) {
  return data.game.status.id === ids.aborted;
}

function middleEnd(data) {
  return data.game.status.id === ids.middleEnd;
}

function playing(data) {
  return started(data) && !finished(data) && !aborted(data);
}

function toLabel(status, winner, variant) {
  switch (status) {
    case 'started':
      return (0, _i18n2.default)('playingRightNow');
    case 'aborted':
      return (0, _i18n2.default)('gameAborted');
    case 'middleEnd':
      return (0, _i18n2.default)('gameMiddleFinished');
    case 'normalEnd':
      return (0, _i18n2.default)('gameFinished');
    case 'variantEnd':
      return (0, _i18n2.default)('gameFinished');
  }
};

exports.default = {
  ids: ids,
  started: started,
  finished: finished,
  aborted: aborted,
  playing: playing,
  middleEnd: middleEnd,
  toLabel: toLabel
};

},{"../i18n":138}],144:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineRoutes = defineRoutes;

var _rliteRouter = require('rlite-router');

var _rliteRouter2 = _interopRequireDefault(_rliteRouter);

var _render = require('mithril/render');

var RenderService = _interopRequireWildcard(_render);

var _vnode = require('mithril/render/vnode');

var _vnode2 = _interopRequireDefault(_vnode);

var _signals = require('./signals');

var _signals2 = _interopRequireDefault(_signals);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var router = new _rliteRouter2.default();

var currentStateId = 0;
var viewSlideDirection = 'fwd';

var previousPath = '/';

var uid = function () {
  var id = 0;
  return function () {
    return id++;
  };
}();

var backbutton = function () {
  var x = function x() {

    var b = x.stack.length === 0 ? null : x.stack.pop();

    if (isFunction(b)) {
      b('backbutton');
      (0, _redraw2.default)();
    } else if (!/^\/$/.test(get())) {
      backHistory();
    } else {
      window.navigator.app.exitApp();
    }
  };

  x.stack = [];

  return x;
}();

function defineRoutes(mountPoint, routes) {
  var _loop = function _loop(route) {
    var component = routes[route];
    router.add(route, function onRouteMatch(_ref) {
      var params = _ref.params;

      var RouteComponent = {
        view: function view() {
          var node = (0, _vnode2.default)(component, undefined, params);
          return node;
        }
      };

      function redraw() {
        RenderService.render(mountPoint, (0, _vnode2.default)(RouteComponent));
      }

      _signals2.default.redraw.removeAll();
      _signals2.default.redraw.add(redraw);
      try {
        redraw();
      } catch (e) {
        _signals2.default.redraw.removeAll();
        throw e;
      }
    });
  };

  for (var route in routes) {
    _loop(route);
  }
  window.addEventListener('popstate', processQuerystring);
  processQuerystring();
}

function processQuerystring(e) {
  if (e && e.state) {
    if (e.state.id < currentStateId) {
      viewSlideDirection = 'bwd';
    } else {
      viewSlideDirection = 'fwd';
    }
    currentStateId = e.state.id;
  }
  previousPath = get();
  var qs = window.location.search || '?=';
  var matched = router.run(qs.slice(2));
  if (!matched) router.run('/');
}

function assignState(state, path) {
  try {
    var newState = state ? Object.assign({}, window.history.state, state) : window.history.state;

    if (path !== undefined) {
      window.history.replaceState(newState, '', '?=' + path);
    } else {
      window.history.replaceState(newState, '');
    }
  } catch (e) {
    console.error(e);
  }
}

function replacePath(path) {
  assignState(undefined, path);
}

function doSet(path) {
  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  backbutton.stack = [];
  previousPath = get();
  if (replace) {
    replacePath(path);
  } else {
    var stateId = uid();
    currentStateId = stateId;
    viewSlideDirection = 'fwd';
    try {
      window.history.pushState({ id: stateId }, '', '?=' + path);
    } catch (e) {
      console.error(e);
    }
  }
  var matched = router.run(path);
  if (!matched) router.run('/');
}

function set(path) {
  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  setTimeout(function () {
    return doSet(path, replace);
  }, 0);
}

function get() {
  var path = window.location.search || '?=/';
  return decodeURIComponent(path.substring(2));
}

function backHistory() {
  window.history.go(-1);
}

exports.default = {
  get: get,
  set: set,
  backbutton: backbutton,
  backHistory: backHistory
};

},{"./signals":148,"./utils/redraw":207,"mithril/render":115,"mithril/render/vnode":120,"rlite-router":127}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _home = require('./ui/home');

var _home2 = _interopRequireDefault(_home);

var _game = require('./ui/game');

var _game2 = _interopRequireDefault(_game);

var _user = require('./ui/user');

var _user2 = _interopRequireDefault(_user);

var _players = require('./ui/players');

var _players2 = _interopRequireDefault(_players);

var _detail = require('./ui/masa/detail');

var _detail2 = _interopRequireDefault(_detail);

var _masa = require('./ui/masa');

var _masa2 = _interopRequireDefault(_masa);

var _settings = require('./ui/settings');

var _settings2 = _interopRequireDefault(_settings);

var _lang = require('./ui/settings/lang');

var _lang2 = _interopRequireDefault(_lang);

var _router = require('./router');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  init: function init() {
    (0, _router.defineRoutes)(document.body, {
      '': _home2.default,
      '@/:id': _user2.default,
      'players': _players2.default,
      'game/:id': _game2.default,
      'masa/:masaId/game/:id': _game2.default,
      'masas': _masa2.default,
      'masa/:id': _detail2.default,
      'settings': _settings2.default,
      'settings/lang': _lang2.default
    });
  }
};

},{"./router":144,"./ui/game":152,"./ui/home":158,"./ui/masa":168,"./ui/masa/detail":164,"./ui/players":174,"./ui/settings":178,"./ui/settings/lang":179,"./ui/user":199}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _http = require('./http');

var _utils = require('./utils');

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var session = void 0;

function isConnected() {
  return session !== undefined;
}

function getSession() {
  return session;
}

function isSession(data) {
  return data.id !== undefined;
}

function storeSession(d) {}

function login(username, password) {
  return (0, _http.fetchJSON)('/login', {
    method: 'POST',
    body: JSON.stringify({
      username: username,
      password: password
    })
  }, true).then(function (data) {
    if (isSession(data)) {
      session = data;
      if (session.sessionId) {
        _storage2.default.set(_http.SESSION_ID_KEY, session.sessionId);
      }
      // storeSession(data);
      return session;
    }
    return false;
  });
}

function signup(username, email, password) {
  return (0, _http.fetchJSON)('/signup', {
    method: 'POST',
    body: JSON.stringify({
      username: username,
      email: email,
      password: password
    })
  }, true).then(function (d) {
    if (isSession(d)) {
      session = d;
      if (session.sessionId) {
        _storage2.default.set(_http.SESSION_ID_KEY, session.sessionId);
      }
    }
    return d;
  });
}

function rememberLogin() {
  return (0, _http.fetchJSON)('/account/info').then(function (data) {
    session = data;
    storeSession(data);
    return data;
  });
}

function refresh() {
  return (0, _http.fetchJSON)('/account/info', { cache: 'reload' }).then(function (data) {
    session = data;
    storeSession(data);
    redraw();
  }).catch(function (err) {
    if (session !== undefined && err.status === 401) {
      session = undefined;
      onLogout();
      redraw();
      window.plugins.toast.show((0, _i18n2.default)('signedOut'), 'short', 'center');
    }
  });
}

function onLogout() {
  _storage2.default.remove(_http.SESSION_ID_KEY);
  signals.afterLogout.dispatch();
}

exports.default = {
  isConnected: isConnected,
  signup: signup,
  login: (0, _throttle2.default)(login, 1000),
  rememberLogin: (0, _throttle2.default)(rememberLogin, 1000),
  get: getSession,
  refresh: (0, _throttle2.default)(refresh, 1000)
};

},{"./http":137,"./i18n":138,"./settings":147,"./storage":151,"./utils":205,"lodash/throttle":109}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

var _range = require('lodash/range');

var _range2 = _interopRequireDefault(_range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function tupleOf(x) {
  return [x.toString(), x.toString()];
}

exports.default = {
  general: {
    lang: _storage2.default.prop('settings.lang', null),
    theme: {
      background: _storage2.default.prop('settings.bgTheme', 'dark')
    }
  },
  game: {
    supportedVariants: ['standard', 'yuzbir', 'duzokey']
  },
  gameSetup: {
    availableRounds: [1, 5, 10, 15, 20, 25, 30].map(tupleOf),
    isRoundValid: function isRoundValid(gameSettings) {
      return gameSettings.rounds() !== '0';
    },
    human: {
      availableVariants: [['101 Okey', '1'], ['Düz Okey', '3']],
      variant: _storage2.default.prop('settings.game.human.variant', '1'),
      rounds: _storage2.default.prop('settings.game.human.rounds', '1'),
      mode: _storage2.default.prop('settings.game.human.mode', '0'),
      membersOnly: _storage2.default.prop('settings.game.human.membersOnly', false)
    }
  }
};

},{"./storage":151,"lodash/range":107}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _signals = require('signals');

exports.default = {

  redraw: new _signals.Signal(),

  afterLogin: new _signals.Signal(),

  afterLogout: new _signals.Signal(),

  sessionRestored: new _signals.Signal()

};

},{"signals":128}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

var _http = require('./http');

var _utils = require('./utils');

var _worker = require('./utils/worker');

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function setupConnection(setup, socketHandlers) {
  var sid = _storage2.default.get(_http.SESSION_ID_KEY);
  if (sid !== null) {
    if (setup.opts.params) {
      setup.opts.params[_http.SESSION_ID_KEY] = sid;
    } else {
      setup.opts.params = _defineProperty({}, _http.SESSION_ID_KEY, sid);
    }
  } else if (setup.opts.params) {
    delete setup.opts.params.sessionId;
  }
  setup.opts.options.isAuth = !!sid;
  worker.onmessage = function (msg) {
    switch (msg.data.topic) {
      case 'onOpen':
        if (socketHandlers.onOpen) socketHandlers.onOpen();
        break;
      case 'disconnected':
        onDisconnected();
        break;
      case 'connected':
        onConnected();
        break;
      case 'onError':
        if (socketHandlers.onError) socketHandlers.onError();
        break;
      case 'handle':
        var h = socketHandlers.events[msg.data.payload.t];
        if (h) h(msg.data.payload.d, msg.data.payload);
        break;
    }
  };

  (0, _worker.tellWorker)(worker, 'create', setup);
}

function onConnected() {
  if (!connectedWS) {
    connectedWS = true;
    (0, _redraw2.default)();
  }
}

function onDisconnected() {
  if (connectedWS) {
    connectedWS = false;
    (0, _redraw2.default)();
  }
}

function reconnectCurrent() {}

var connectedWS = false;

var worker = new Worker('lib/socketWorker.js');
var defaultHandlers = {};

function createLobby(name, _onOpen, handlers) {
  var socketHandlers = {
    onOpen: function onOpen() {
      _session2.default.refresh();
      _onOpen();
    },
    events: Object.assign({}, defaultHandlers, handlers)
  };
  var opts = {
    options: {
      name: name,
      debug: _config2.default.mode === 'dev',
      pingDelay: 2000,
      sendOnOpen: [],
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  var setup = {
    clientId: (0, _utils.newSri)(),
    socketEndPoint: _config2.default.socketEndPoint,
    url: '/lobby/socket/v' + _config2.default.apiVersion,
    opts: opts
  };
  setupConnection(setup, socketHandlers);
}

function createMasa(masaId, version, handlers) {
  var url = '/masa/' + masaId + ('/socket/v' + _config2.default.apiVersion);
  var socketHandlers = {
    events: Object.assign({}, defaultHandlers, handlers),
    onOpen: _session2.default.backgroundRefresh
  };
  var opts = {
    options: {
      name: 'masa',
      debug: _config2.default.mode === 'dev',
      pingDelay: 2000,
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  var setup = {
    clientId: (0, _utils.newSri)(),
    socketEndPoint: _config2.default.socketEndPoint,
    url: url,
    version: version,
    opts: opts
  };
  setupConnection(setup, socketHandlers);
}

exports.default = {
  createLobby: createLobby,
  createMasa: createMasa,
  reconnectCurrent: reconnectCurrent,
  isConnected: function isConnected() {
    return connectedWS;
  },
  connect: function connect() {
    (0, _worker.tellWorker)(worker, 'connect');
  },
  destroy: function destroy() {
    (0, _worker.tellWorker)(worker, 'destroy');
  }
};

/// OLD


// const worker = new Worker('lib/socketWorker.js');

// let socketHandlers;
// let errorDetected = false;
// let connectedWS = true;

// let alreadyWarned = false;
// let redrawOnDisconnectedTimeoutID;
// let proxyFailTimeoutID;
// const proxyFailMsg = "Oyunkeyf sunucularına bağlantı koptu. Problem sürekli yaşanıyorsa proxy yada network'la ilgili olabilir.";

// const defaultHandlers = {
// };

// function createGame(url, version, handlers, gameUrl) {
//   errorDetected = false;
//   socketHandlers = {
//     onError: function() {
//       // we can't get socket error, so we send an xhr to test whether the
//       // rejection is an authorization issue
//       if (!errorDetected) {
//         // just to be sure that we don't send an xhr every second when the
//         // websocket is trying to reconnect
//         errorDetected = true;
//         xhr.game(gameUrl.substring(1)).then(function() {}, function(err) {
//           if (err.status === 401) {
//             window.plugins.toast.show(i18n('unauthorizedError'), 'short', 'center');
//             m.route('/');
//           }
//         });
//       }
//     },
//     events: Object.assign({}, defaultHandlers, handlers)
//   };

//   const opts = {
//     options: {
//       name: 'game',
//       debug: false,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version,
//     opts
//   });
// }

// function createMasa(masaId, version, handlers) {
//   let url = '/masa/' + masaId + '/socket/v1';

//   socketHandlers = {
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     options: {
//       name: 'masa',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version,
//     opts
//   });
// }

// function createMasaHome(handlers) {
//   let url = '/socket';

//   socketHandlers = {
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     params: { flag: 'masa' },
//     options: {
//       name: 'masaHome',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version: 0,
//     opts
//   });
// }

// function createLobby(lobbyVersion, onOpen, handlers) {
//   socketHandlers = {
//     onOpen,
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     options: {
//       name: 'lobby',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url: '/lobby/socket/v1',
//     version: lobbyVersion,
//     opts
//   });
// }


// function createDefault() {
//   // default socket is useless when anon.?
//   if (hasNetwork()) {
//     socketHandlers = {
//       events: defaultHandlers
//     };
//     const opts = {
//       options: {
//         name: 'default',
//         debug: false,
//         pingDelay: 2000,
//         registeredEvents: Object.keys(socketHandlers.events)
//       }
//     };
//     tellWorker(worker, 'create', {
//       clientId: oyunkeyfSri,
//       socketEndPoint: window.oyunkeyf.socketEndPoint,
//       url: '/socket',
//       version: 0,
//       opts
//     });
//   }
// }

// function onConnected() {
//   const wasOff = !connectedWS;
//   connectedWS = true;
//   clearTimeout(proxyFailTimeoutID);
//   clearTimeout(redrawOnDisconnectedTimeoutID);
//   if (wasOff) m.redraw();
// }

// function onDisconnected() {
//   const wasOn = connectedWS;
//   connectedWS = false;
//   if (wasOn) redrawOnDisconnectedTimeoutID = setTimeout(function() {
//     m.redraw();
//   }, 2000);
//   if (wasOn && !alreadyWarned && !storage.get('donotshowproxyfailwarning')) proxyFailTimeoutID = setTimeout(() => {
//     // check if disconnection lasts, it could mean a proxy prevents
//     // establishing a tunnel
//     if (hasNetwork() && !connectedWS) {
//       alreadyWarned = true;
//       window.navigator.notification.alert(proxyFailMsg, function() {
//         storage.set('donotshowproxyfailwarning', true);
//       });
//     }
//   }, 20000);
// }

// worker.addEventListener('message', function(msg) {
//   switch(msg.data.topic) {
//   case 'onOpen':
//     if (socketHandlers.onOpen) socketHandlers.onOpen();
//     break;
//   case 'disconnected':
//     onDisconnected();
//     break;
//   case 'connected':
//     onConnected();
//     break;
//   case 'onError':
//     if (socketHandlers.onError) socketHandlers.onError();
//     break;
//   case 'handle':
//     var h = socketHandlers.events[msg.data.payload.t];
//     if (h) h(msg.data.payload.d || null, msg.data.payload);
//     break;
//   }
// });

// // export default {
// //   createDefault,
// //   createMasa,
// //   createMasaHome,
// //   createGame,
// //   createLobby,
// //   setVersion(version) {
// //     tellWorker(worker, 'setVersion', version);
// //   },
// //   send(type, data, opts) {
// //     tellWorker(worker, 'send', [type, data, opts]);
// //   },
// //   connect() {
// //     tellWorker(worker, 'connect');
// //   },
// //   disconnect() {
// //     tellWorker(worker, 'disconnect');
// //   },
// //   isConnected() {
// //     return connectedWS;
// //   },
// //   destroy() {
// //     tellWorker(worker, 'destroy');
// //   },
// //   terminate() {
// //     if (worker) worker.terminate();
// //   }
// // };

},{"./config":136,"./http":137,"./session":146,"./storage":151,"./utils":205,"./utils/redraw":207,"./utils/worker":209}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var timeoutId;

exports.default = {
  spin: function spin() {
    if (timeoutId || document.getElementsByClassName('globalSpinner').length > 0) {
      return false;
    }

    var spinner = document.createElement('div');
    spinner.className = 'spinner globalSpinner';
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 40 40');
    var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', '20');
    circle.setAttribute('cy', '20');
    circle.setAttribute('r', '18');
    circle.setAttribute('fill', 'none');
    svg.appendChild(circle);
    spinner.appendChild(svg);

    timeoutId = setTimeout(function () {
      return document.body.appendChild(spinner);
    }, 200);
  },
  stop: function stop() {
    clearTimeout(timeoutId);
    timeoutId = null;
    var spinners = document.getElementsByClassName('globalSpinner');
    if (spinners.length) {
      setTimeout(function () {
        while (spinners[0]) {
          document.body.removeChild(spinners[0]);
        }
      }, 500);
    }
  },
  getVdom: function getVdom(classes) {
    return h(
      'div',
      { 'class': 'spinner ' + classes },
      h(
        'svg',
        { viewBox: '0 0 40 40' },
        h('circle', { cx: '20', cy: '20', r: '18', fill: 'none' })
      )
    );
  }
};

},{"mithril/hyperscript":113}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function withStorage(f) {
  // can throw an exception if storage is full
  try {
    return !!window.localStorage ? f(window.localStorage) : null;
  } catch (e) {}
}

function get(k) {
  return withStorage(function (s) {
    return JSON.parse(s.getItem(k));
  });
}
function remove(k) {
  return withStorage(function (s) {
    s.removeItem(k);
  });
}
function set(k, v) {
  return withStorage(function (s) {
    s.removeItem(k);
    s.setItem(k, JSON.stringify(v));
  });
}

function prop(key, initialValue) {
  return function () {
    if (arguments.length) set(key, arguments[0]);
    var ret = get(key);
    return ret !== null && ret !== undefined ? ret : initialValue;
  };
}

exports.default = {
  get: get,
  set: set,
  remove: remove,
  prop: prop
};

},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _utils = require('../../utils');

var _xhr = require('../../xhr');

var _sleep = require('../../utils/sleep');

var sleepUtils = _interopRequireWildcard(_sleep);

var _OnlineRound = require('../shared/round/OnlineRound');

var _OnlineRound2 = _interopRequireDefault(_OnlineRound);

var _roundView = require('../shared/round/view/roundView');

var _roundView2 = _interopRequireDefault(_roundView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  oninit: function oninit(_ref) {
    var _this = this;

    var attrs = _ref.attrs;

    var gameData = void 0;

    sleepUtils.keepAwake();

    if ((0, _utils.hasNetwork)()) {
      (0, _xhr.game)(attrs.id).then(function (data) {
        gameData = data;

        setTimeout(function () {
          _this.round = new _OnlineRound2.default(attrs.id, data);
        }, 400);
      }).catch(function (error) {
        (0, _utils.handleXhrError)(error);
        _router2.default.set('/');
      });
    }
  },
  oncreate: function oncreate(vnode) {
    if (vnode.dom) helper.elFadeIn(vnode.dom);
  },
  onremove: function onremove() {
    sleepUtils.allowSleepAgain();
    _socket2.default.destroy();
    if (this.round) {
      this.round.unload();
    }
  },
  view: function view(_ref2) {
    var attrs = _ref2.attrs;

    if (this.round) return (0, _roundView2.default)(this.round);

    return null;
  }
};

},{"../../i18n":138,"../../router":144,"../../socket":149,"../../utils":205,"../../utils/sleep":208,"../../xhr":210,"../helper":156,"../shared/round/OnlineRound":191,"../shared/round/view/roundView":195}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _popup = require('./shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _form = require('./shared/form');

var _form2 = _interopRequireDefault(_form);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _newGameForm = require('./newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _iscroll = require('iscroll');

var _iscroll2 = _interopRequireDefault(_iscroll);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _lobby = require('./lobby');

var _lobby2 = _interopRequireDefault(_lobby);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _ViewOnlyBoard = require('./shared/ViewOnlyBoard');

var _ViewOnlyBoard2 = _interopRequireDefault(_ViewOnlyBoard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scroller = null;

var gamesMenu = {};

gamesMenu.isOpen = false;

gamesMenu.open = function () {
  _backbutton2.default.stack.push(gamesMenu.close);
  gamesMenu.isOpen = true;
  setTimeout(function () {
    if (utils.hasNetwork() && scroller) scroller.goToPage(1, 0);
  }, 400);
  _session2.default.refresh();
};

gamesMenu.close = function (fromBB) {
  if (fromBB !== 'backbutton' && gamesMenu.isOpen) _backbutton2.default.stack.pop();
  gamesMenu.isOpen = false;
};

function joinGame(g) {
  gamesMenu.close();
  _mithril2.default.route('/game/' + g.fullId);
}

function cardDims() {
  var vp = _helper2.default.viewportDim();

  // if we're here it's a phone
  var width = 200;
  var height = width / (4 / 3);
  var margin = 10;
  return {
    w: width + margin * 2,
    h: height + 70,
    innerW: width,
    margin: margin
  };
}

function renderViewOnlyBoard(cDim, fen, orientation, variant) {
  var innerH = cDim ? cDim.innerW / (4 / 3) : 0;
  var innerW = cDim ? cDim.innerW : 0;
  var style = cDim ? { height: innerH + 'px' } : {};
  var bounds = cDim ? { width: innerW, height: innerH } : null;
  return h(
    'div',
    { className: 'boardWrapper', style: style },
    _mithril2.default.component(_ViewOnlyBoard2.default, { bounds: bounds, fen: fen, orientation: orientation, variant: variant })
  );
}

function timeLeft(g) {
  if (!g.isMyTurn) return (0, _i18n2.default)('waitingForOpponent');
  return (0, _i18n2.default)('yourTurn');
}

function renderGame(g, cDim, cardStyle) {
  var icon = utils.gameIcon(g.perf);
  var cardClass = ['card', 'standard'].join(' ');

  var timeClass = ['timeIndication', g.isMyTurn ? 'myTurn' : 'opponentTurn'].join(' ');
  var config = _helper2.default.ontouchX(function () {
    return joinGame(g);
  });

  return h(
    'div',
    { className: cardClass, key: 'game.' + g.gameId, style: cardStyle,
      config: config },
    renderViewOnlyBoard(cDim, g.fen, g.side, g.variant),
    h(
      'div',
      { className: 'infos' },
      h(
        'div',
        { className: 'description' },
        h(
          'p',
          null,
          h(
            'span',
            { className: 'variant' },
            g.variant.name
          ),
          h(
            'span',
            { className: timeClass },
            timeLeft(g)
          )
        )
      )
    )
  );
}

function renderAllGames(cDim) {
  var nowPlaying = _session2.default.nowPlaying(); // .concat(session.nowPlaying());
  var cardStyle = cDim ? {
    width: cDim.w - cDim.margin * 2 + 'px',
    height: cDim.h + 'px',
    marginLeft: cDim.margin + 'px',
    marginRight: cDim.margin + 'px'
  } : {};

  var nbCards = utils.hasNetwork() ? nowPlaying.length + 1 : 0;

  var wrapperStyle = void 0,
      wrapperWidth = void 0;
  if (cDim) {
    // scroller wrapper width
    // calcul is:
    // ((cardWidth + visible part of adjacent card) * nb of cards) +
    // wrapper's marginLeft
    wrapperWidth = (cDim.w + cDim.margin * 2) * nbCards + cDim.margin * 2;
    wrapperStyle = {
      width: wrapperWidth + 'px',
      marginLeft: cDim.margin * 3 + 'px'
    };
  }

  var allCards = nowPlaying.map(function (g) {
    return renderGame(g, cDim, cardStyle);
  });

  if (!_helper2.default.isWideScreen()) {

    var newGameCard = h(
      'div',
      { className: 'card standard', key: 'game.new-game', style: cardStyle,
        config: _helper2.default.ontouchX(function () {
          gamesMenu.close();_newGameForm2.default.open();
        }) },
      renderViewOnlyBoard(cDim),
      h(
        'div',
        { className: 'infos' },
        h(
          'div',
          { className: 'description' },
          h(
            'h2',
            { className: 'title' },
            (0, _i18n2.default)('createAGame')
          ),
          h(
            'p',
            null,
            (0, _i18n2.default)('newOpponent')
          )
        )
      )
    );
    if (utils.hasNetwork()) allCards.unshift(newGameCard);
  }

  return (0, _mithril2.default)('div#all_games', { style: wrapperStyle }, allCards);
}

gamesMenu.view = function () {
  if (!gamesMenu.isOpen) return null;

  var vh = _helper2.default.viewportDim().vh;
  var cDim = cardDims();
  var wrapperStyle = _helper2.default.isWideScreen() ? {} : { top: (vh - cDim.h) / 2 + 'px' };
  var wrapperConfig = _helper2.default.isWideScreen() ? utils.noop : function (el, isUpdate, context) {
    if (!isUpdate) {
      scroller = new _iscroll2.default(el, {
        scrollX: true,
        scrollY: false,
        momentum: false,
        snap: '.card',
        snapSpeed: 400,
        preventDefaultException: {
          tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|LABEL)$/
        }
      });

      context.unonload = function () {
        if (scroller) {
          scroller.destroy();
          scroller = null;
        }
      };
    }
    // see https://github.com/cubiq/iscroll/issues/412
    scroller.options.snap = el.querySelectorAll('.card');
    scroller.refresh();
  };

  var isWideScreen = _helper2.default.isWideScreen();

  var wrapperClass = isWideScreen ? 'overlay_popup' : '';

  return h(
    'div',
    { id: 'games_menu', className: 'overlay_popup_wrapper' },
    h('div', { className: 'wrapper_overlay_close',
      config: _helper2.default.ontouch(_helper2.default.fadesOut(gamesMenu.close, '.overlay_popup_wrapper')) }),
    h(
      'div',
      { id: 'wrapper_games', className: wrapperClass, style: wrapperStyle, config: wrapperConfig },
      isWideScreen ? h(
        'header',
        null,
        (0, _i18n2.default)('nbGamesInPlay', _session2.default.nowPlaying().length)
      ) : null,
      isWideScreen ? h(
        'div',
        { className: 'popup_content' },
        renderAllGames(null)
      ) : renderAllGames(cDim)
    )
  );
};

exports.default = gamesMenu;

},{"../backbutton":135,"../i18n":138,"../session":146,"../settings":147,"../utils":205,"./helper":156,"./lobby":160,"./newGameForm":173,"./shared/ViewOnlyBoard":184,"./shared/form":186,"./shared/popup":190,"iscroll":7,"mithril":114,"mithril/hyperscript":113}],154:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = animator;

var _utils = require('../../utils');

var animating = false;

// Author Barney Caroll
// taken from https://gist.github.com/barneycarroll/c69fbe0786e37c941baf

// Define an animator consisting of optional incoming and outgoing animations.
// alwaysAnimate is false unless specified as true: false means an incoming animation will only trigger if an outgoing animation is also in progress.
// forcing dontClone to true means the outward animation will use the original element rather than a clone. This could improve performance by recycling elements, but can lead to trouble: clones have the advantage of being stripped of all event listeners.
function animator(incoming, outgoing, alwaysAnimate, dontClone) {
  // The resulting animator can be applied to any number of components
  return function animate(x, y, z) {
    var config;
    var parent;
    var next;

    // When used as a config function
    if (x.nodeType) {
      return animationConfig(x, y, z);
    }
    // When passed a virtual DOM node (the output of m)
    else if (x.attrs) {
        return bindConfigTo(x);
      }
      // When applied to a Mithril module / component
      else if (x.view) {
          return {
            controller: x.controller || _utils.noop,
            view: function animatedView(ctrl) {
              return bindConfigTo(x.view(ctrl));
            }
          };
        }

    function bindConfigTo(node) {
      if (!node) return null;

      config = node.attrs.config;

      node.attrs.config = animationConfig;

      return node;
    }

    function animationConfig(el, init, context) {
      var output;
      var onunload;

      if (config) {
        output = config(el, init, context);
        // If the root element already has a config, it may also have an onunload which we should take care to preserve
        onunload = context.onunload;
      }

      if (!init) {
        if (incoming && alwaysAnimate || animating) {
          incoming(el, _utils.noop, context);
        }

        context.onunload = outgoing ? onunload ? function onunloadWrapper() {
          teardown();
          onunload();
        } : teardown : onunload;

        parent = el.parentElement;
        next = el.nextSibling;
      }

      return output;

      function teardown() {
        var insertion = dontClone ? el : el.cloneNode(true);
        var reference = null;

        if (next && parent && next.parentNode === parent) {
          reference = next;
        }

        animating = true;

        setTimeout(function resetAnimationFlag() {
          animating = false;
        }, 0);

        parent.insertBefore(insertion, reference);

        outgoing(insertion, function destroy() {
          if (parent.contains(insertion)) {
            parent.removeChild(insertion);
          }
        }, context);
      }
    }
  };
}

},{"../../utils":205}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ButtonHandler;

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HOLD_DURATION = 600;
var REPEAT_RATE = 20;
var SCROLL_TOLERANCE = 8;
var ACTIVE_CLASS = 'active';

function hasContextMenu() {
  return window.cordova.platformId !== 'ios';
}

function ButtonHandler(el, tapHandler, holdHandler, repeatHandler, scrollX, scrollY, touchEndFeedback) {

  var startX = void 0,
      startY = void 0,
      boundaries = void 0,
      active = void 0,
      holdTimeoutID = void 0,
      repeatTimeoutId = void 0,
      repeatIntervalID = void 0;

  if (typeof tapHandler !== 'function') throw new Error('ButtonHandler 2nd argument must be a function!');

  if (holdHandler && typeof holdHandler !== 'function') throw new Error('ButtonHandler 3rd argument must be a function!');

  if (repeatHandler && typeof repeatHandler !== 'function') throw new Error('ButtonHandler 4rd argument must be a function!');

  // http://ejohn.org/blog/how-javascript-timers-work/
  function onRepeat() {
    var res = repeatHandler();
    repeatIntervalID = setTimeout(onRepeat, REPEAT_RATE);
    if (!res) clearTimeout(repeatIntervalID);
    _mithril2.default.redraw();
  }

  function onTouchStart(e) {
    var touch = e.changedTouches[0];
    var boundingRect = el.getBoundingClientRect();
    startX = touch.clientX;
    startY = touch.clientY;
    boundaries = {
      minX: boundingRect.left,
      maxX: boundingRect.right,
      minY: boundingRect.top,
      maxY: boundingRect.bottom
    };
    active = true;
    setTimeout(function () {
      if (active) el.classList.add(ACTIVE_CLASS);
    }, 200);
    if (!hasContextMenu()) holdTimeoutID = setTimeout(onHold, HOLD_DURATION);
    clearTimeout(repeatIntervalID);
    if (repeatHandler) repeatTimeoutId = setTimeout(function () {
      repeatIntervalID = setTimeout(onRepeat, REPEAT_RATE);
    }, 150);
  }

  function onTouchMove(e) {
    // if going out of bounds, no way to reenable the button
    if (active) {
      var touch = e.changedTouches[0];
      active = isActive(touch);
      if (!active) {
        clearTimeout(holdTimeoutID);
        clearTimeout(repeatTimeoutId);
        clearTimeout(repeatIntervalID);
        el.classList.remove(ACTIVE_CLASS);
      }
    }
  }

  function onTouchEnd(e) {
    if (e.cancelable) e.preventDefault();
    clearTimeout(repeatTimeoutId);
    clearTimeout(repeatIntervalID);
    if (active) {
      clearTimeout(holdTimeoutID);
      if (touchEndFeedback) el.classList.add(ACTIVE_CLASS);
      tapHandler(e);
      active = false;
      setTimeout(function () {
        return el.classList.remove(ACTIVE_CLASS);
      }, 80);
    }
  }

  function onTouchCancel() {
    clearTimeout(holdTimeoutID);
    clearTimeout(repeatTimeoutId);
    clearTimeout(repeatIntervalID);
    active = false;
    el.classList.remove(ACTIVE_CLASS);
  }

  function onContextMenu(e) {
    e.preventDefault();
    e.stopPropagation();
    if (holdTimeoutID === undefined) onHold();
  }

  function onHold() {
    if (holdHandler) {
      holdHandler();
      active = false;
      el.classList.remove(ACTIVE_CLASS);
    }
  }

  function isActive(touch) {
    var x = touch.clientX,
        y = touch.clientY,
        b = boundaries,
        d = 0;
    if (scrollX) d = Math.abs(x - startX);
    if (scrollY) d = Math.abs(y - startY);
    return x < b.maxX && x > b.minX && y < b.maxY && y > b.minY && d < SCROLL_TOLERANCE;
  }

  el.addEventListener('touchstart', onTouchStart, false);
  el.addEventListener('touchmove', onTouchMove, false);
  el.addEventListener('touchend', onTouchEnd, false);
  el.addEventListener('touchcancel', onTouchCancel, false);
  el.addEventListener('contextmenu', onContextMenu, false);
}

},{"mithril":114}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ontap = ontap;
exports.ontapXY = ontapXY;
exports.slidesInUp = slidesInUp;
exports.slidesOutDown = slidesOutDown;
exports.elFadeIn = elFadeIn;
exports.getButton = getButton;
exports.viewportDim = viewportDim;
exports.findParentBySelector = findParentBySelector;
exports.getLI = getLI;
exports.classSet = classSet;

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _button = require('./button');

var _button2 = _interopRequireDefault(_button);

var _animator = require('./animator');

var _animator2 = _interopRequireDefault(_animator);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animDuration = 250;

function createTapHandler(tapHandler, holdHandler, repeatHandler, scrollX, scrollY, getElement, preventEndDefault) {
  return function (vnode) {
    (0, _button2.default)(vnode.dom, function (e) {
      tapHandler(e);
      (0, _redraw2.default)();
    }, holdHandler ? function (e) {
      return utils.autoredraw(function () {
        return holdHandler(e);
      });
    } : undefined, repeatHandler, scrollX, scrollY, getElement, preventEndDefault);
  };
}

function ontap(tapHandler, holdHandler, repeatHandler, getElement) {
  return createTapHandler(tapHandler, holdHandler, repeatHandler, false, false, getElement);
}

function ontapXY(tapHandler, holdHandler, getElement) {
  var preventEndDefault = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  return createTapHandler(tapHandler, holdHandler, undefined, true, true, getElement, preventEndDefault);
}

function slidesInUp(vnode) {
  var el = vnode.dom;
  el.style.transform = 'translateY(100%)';
  vnode.state.lol = el.offsetHeight;
  return (0, _zanimo2.default)(el, 'transform', 'translateY(0)', 250, 'ease-out').catch(console.log.bind(console));
}

function slidesOutDown(callback, elID) {
  return function (fromBB) {
    var el = document.getElementById(elID);
    return (0, _zanimo2.default)(el, 'transform', 'translateY(100%)', 250, 'ease-out').then(function () {
      return utils.autoredraw(function () {
        return callback(fromBB);
      });
    }).catch(console.log.bind(console));
  };
}

// el fade in transition, can be applied to any element
function elFadeIn(el) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : animDuration;
  var origOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0.5';
  var endOpacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '1';

  var tId = void 0;

  el.style.opacity = origOpacity;
  el.style.transition = 'opacity ' + duration + 'ms ease-out';

  setTimeout(function () {
    el.style.opacity = endOpacity;
  });

  function after() {
    clearTimeout(tId);
    if (el) {
      el.removeAttribute('style');
      el.removeEventListener('transitionend', after, false);
    }
  }

  el.addEventListener('transitionend', after, false);
  // in case transitionend does not fire
  tId = setTimeout(after, duration + 10);
}

function getButton(e) {
  var target = e.target;
  return target.tagName === 'BUTTON' ? target : findParentBySelector(target, 'button');
}

// OLD

//store temporarily last route to disable animations on same route
// TODO find a better way cause this is ugly
var lastRoute = void 0;

// this must be cached because of the access to document.body.style
var cachedTransformProp = void 0;
var cachedViewportDim = null;

function viewSlideIn(el, callback) {
  if (_mithril2.default.route() === lastRoute) {
    callback();
    return;
  }

  lastRoute = _mithril2.default.route();

  function after() {
    utils.setViewSlideDirection('fwd');
    el.removeAttribute('style');
    callback();
  }

  var direction = utils.getViewSlideDirection() === 'fwd' ? '100%' : '-100%';
  el.style.transform = 'translate3d(' + direction + ',0,0)';
  el.style.transition = 'transform 200ms ease-out';

  setTimeout(function () {
    el.style.transform = 'translate3d(0%,0,0)';
  });

  el.addEventListener('transitionend', after, false);
}

function viewSlideOut(el, callback) {
  if (_mithril2.default.route() === lastRoute) {
    callback();
    return;
  }

  function after() {
    utils.setViewSlideDirection('fwd');
    callback();
  }

  var direction = utils.getViewSlideDirection() === 'fwd' ? '-100%' : '100%';
  el.style.transform = 'translate3d(0%,0,0)';
  el.style.transition = 'transform 200ms ease-out';

  setTimeout(function () {
    el.style.transform = 'translate3d(' + direction + ',0,0)';
  });

  el.addEventListener('transitionend', after, false);
}

function viewFadesIn(el, callback) {
  var tId;

  el.style.opacity = '0.5';
  el.style.transition = 'opacity 200ms ease-out';

  setTimeout(function () {
    el.style.opacity = '1';
  });

  function after() {
    clearTimeout(tId);
    if (el) {
      el.removeAttribute('style');
      el.removeEventListener('transitioned', after, false);
    }
    callback();
  }

  el.addEventListener('transitioned', after, false);

  // in case transitioned does not fire
  // TODO find a way to avoid it
  tId = setTimeout(after, 250);
}

function viewFadesOut(el, callback) {
  var tId;

  el.style.opacity = '1';
  el.style.transition = 'opacity 200ms ease-out, visibility 0s linear 200ms';

  setTimeout(function () {
    el.style.opacity = '0';
    el.style.visibility = 'hidden';
  });

  function after() {
    clearTimeout(tId);
    callback();
  }

  el.addEventListener('transitioned', after, false);

  // in case transitioned does not fire
  // TODO find a way to avoid it
  tId = setTimeout(after, 250);
}

function collectionHas(coll, el) {
  for (var i = 0, len = coll.length; i < len; i++) {
    if (coll[i] === el) return true;
  }
  return false;
}

function findParentBySelector(el, selector) {
  var matches = document.querySelectorAll(selector);
  var cur = el.parentNode;
  while (cur && !collectionHas(matches, cur)) {
    cur = cur.parentNode;
  }
  return cur;
}

function ontouch(tapHandler, holdHandler, repeatHandler, scrollX, scrollY, touchEndFeedback) {
  return function (el, isUpdate) {
    if (!isUpdate) {
      (0, _button2.default)(el, function (e) {
        _mithril2.default.startComputation();
        try {
          tapHandler(e);
        } finally {
          _mithril2.default.endComputation();
        }
      }, holdHandler ? function () {
        return utils.autoredraw(holdHandler);
      } : null, repeatHandler, scrollX, scrollY, touchEndFeedback);
    }
  };
}

function computeTransformProp() {
  return 'transform' in document.body.style ? 'transform' : 'webkitTransform' in document.body.style ? 'webkitTransform' : 'mozTransform' in document.body.style ? 'mozTransform' : 'oTransform' in document.body.style ? 'oTransform' : 'msTransform';
}

function viewportDim() {
  if (cachedViewportDim) return cachedViewportDim;

  var e = document.documentElement;
  var vpd = cachedViewportDim = {
    vw: e.clientWidth,
    vh: e.clientHeight
  };
  return vpd;
}

function collectionHas(coll, el) {
  for (var i = 0, len = coll.length; i < len; i++) {
    if (coll[i] === el) return true;
  }
  return false;
}

function findParentBySelector(el, selector) {
  var matches = document.querySelectorAll(selector);
  var cur = el;
  while (cur && !collectionHas(matches, cur)) {
    cur = cur.parentNode;
  }
  return cur;
}

function getLI(e) {
  var target = e.target;
  return target.tagName === 'LI' ? target : findParentBySelector(target, 'LI');
}

function classSet(classes) {
  var arr = [];
  for (var i in classes) {
    if (classes[i]) arr.push(i);
  }
  return arr.join(' ');
}

// export default {
//   slidingPage: animator(viewSlideIn, viewSlideOut),
//   fadingPage: animator(viewFadesIn, viewFadesOut),
//   viewportDim,
//   clearCachedViewportDim() {
//     cachedViewportDim = null;
//   },

//   transformProp: function() {
//     if (!cachedTransformProp) cachedTransformProp = computeTransformProp();
//     return cachedTransformProp;
//   },

//   slidesInUp: function(el, isUpdate, context) {
//     if (!isUpdate) {
//       el.style.transform = 'translateY(100%)';
//       // force reflow back
//       context.lol = el.offsetHeight;
//       Zanimo(el, 'transform', 'translateY(0)', 250, 'ease-out')
//         .catch(console.log.bind(console));
//     }
//   },
//   slidesOutDown: function(callback, elID) {
//     return function() {
//       const el = document.getElementById(elID);
//       m.redraw.strategy('none');
//       return Zanimo(el, 'transform', 'translateY(100%)', 250, 'ease-out')
//         .then(utils.autoredraw.bind(null, callback))
//         .catch(callback);
//     };
//   },

//   fadesOut: function(callback, selector, time = 150) {
//     return function(e) {
//       e.stopPropagation();
//       var el = selector ? findParentBySelector(e.target, selector) : e.target;
//       m.redraw.strategy('none');
//       return Zanimo(el, 'opacity', 0, time)
//         .then(() => utils.autoredraw(callback))
//         .catch(console.log.bind(console));
//     };
//   },

//   ontouch: function(tapHandler, holdHandler, repeatHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, repeatHandler, false, false, touchEndFeedback);
//   },
//   ontouchX: function(tapHandler, holdHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, null, true, false, touchEndFeedback);
//   },
//   ontouchY: function(tapHandler, holdHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, null, false, true, touchEndFeedback);
//   },
//   classSet: function(classes) {
//     var arr = [];
//     for (var i in classes) {
//       if (classes[i]) arr.push(i);
//     }
//     return arr.join(' ');
//   },

//   isWideScreen: function() {
//     return viewportDim().vw >= 600;
//   },
//   isIpadLike: function() {
//     const { vh, vw } = viewportDim();
//     return vh >= 700 && vw <= 1050;
//   },
//   isPortrait: function() {
//     return window.matchMedia('(orientation: portrait)').matches;
//   },
//   isLandscape: function() {
//     return window.matchMedia('(orientation: landscape)').matches;
//   },
//   progress: function (p) {
//     if (p === 0) return null;
//     return m('span', {
//       className: 'progress ' + (p > 0 ? 'positive' : 'negative'),
//       'data-icon': p > 0 ? 'N' : 'M'
//     }, Math.abs(p));
//   }
// };

},{"../../utils":205,"../../utils/redraw":207,"./animator":154,"./button":155,"mithril":114,"zanimo":131}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.body = body;

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _common = require('../shared/common');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function body(ctrl) {
  var nbPlayers = (0, _i18n2.default)('nbConnectedPlayers', ctrl.nbConnectedPlayers() || '?');
  var nbGames = (0, _i18n2.default)('nbGamesInPlay', ctrl.nbGamesInPlay() || '?');

  return h(
    'div',
    { className: 'native_scroller page' },
    h(
      'div',
      { className: 'home' },
      h(
        'section',
        { className: 'stats' },
        h(
          'div',
          { className: 'numPlayers' },
          nbPlayers
        ),
        h(
          'div',
          { className: 'numGames' },
          nbGames
        )
      ),
      renderQuickGame()
    )
  );

  // const header = headerWidget.bind(null, 'oyunkeyf.net');

  // return layout.free(header, body);
}

function renderQuickGame() {
  return h('div.homeCreate', [h('h2.homeTitle', 'Hemen oyna'), (0, _newGameForm.renderQuickSetup)(function () {
    return _newGameForm2.default.openRealtime('custom');
  })]);
}

},{"../../i18n":138,"../helper":156,"../layout":159,"../newGameForm":173,"../shared/common":185,"mithril":114,"mithril/hyperscript":113}],158:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stream = require('mithril/stream');

var _stream2 = _interopRequireDefault(_stream);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _utils = require('../../utils');

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _appMode = require('../../utils/appMode');

var _common = require('../shared/common');

var _homeView = require('./homeView');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit() {
    var nbConnectedPlayers = (0, _stream2.default)();
    var nbGamesInPlay = (0, _stream2.default)();

    function init() {
      if ((0, _appMode.isForeground)()) {
        _socket2.default.createLobby('homeLobby', _utils.noop, {
          n: function n(_, d) {
            nbConnectedPlayers(d.d);
            nbGamesInPlay(d.r);
            (0, _redraw2.default)();
          }
        });
      }
    }

    function onResume() {
      (0, _appMode.setForeground)();
      init();
    }

    if ((0, _utils.hasNetwork)()) {
      init();
    }

    document.addEventListener('online', init);
    document.addEventListener('resume', onResume);

    this.ctrl = {
      nbConnectedPlayers: nbConnectedPlayers,
      nbGamesInPlay: nbGamesInPlay
    };
  },
  view: function view() {
    var header = (0, _common.dropShadowHeader)('oyunkeyf.net');

    return _layout2.default.free(header, (0, _homeView.body)(this.ctrl));
  }
};

},{"../../socket":149,"../../utils":205,"../../utils/appMode":203,"../../utils/redraw":207,"../layout":159,"../shared/common":185,"./homeView":157,"mithril/stream":121}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _menu = require('./menu');

var menu = _interopRequireWildcard(_menu);

var _menuView = require('./menu/menuView');

var _menuView2 = _interopRequireDefault(_menuView);

var _MainBoard = require('./shared/layout/MainBoard');

var _MainBoard2 = _interopRequireDefault(_MainBoard);

var _gamesMenu = require('./gamesMenu');

var _gamesMenu2 = _interopRequireDefault(_gamesMenu);

var _newGameForm = require('./newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _loginModal = require('./loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _signupModal = require('./signupModal');

var _signupModal2 = _interopRequireDefault(_signupModal);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var background;

exports.default = {

  board: function board(header, content, overlay) {
    background = background;

    return (0, _hyperscript2.default)('div.view-container', { className: bgClass(background) }, [(0, _hyperscript2.default)(_MainBoard2.default, { header: header }, content), (0, _hyperscript2.default)(_menuView2.default), overlay]);
  },

  free: function free(header, content, footer, overlay) {
    background = background || _settings2.default.general.theme.background();

    return (0, _hyperscript2.default)('div.view-container', { className: bgClass(background) }, [(0, _hyperscript2.default)('main#page', { oncreate: handleMenuOpen }, [(0, _hyperscript2.default)('header.main_header', header), (0, _hyperscript2.default)('div#free_content.content.native_scroller', content), footer ? (0, _hyperscript2.default)('footer.main_footer', footer) : null, (0, _hyperscript2.default)('div#menu-close-overlay.menu-backdrop', { oncreate: menu.backdropCloseHandler })]), (0, _hyperscript2.default)(_menuView2.default), _loginModal2.default.view(), _signupModal2.default.view(), _newGameForm2.default.view(), overlay]);
  }
};


function handleMenuOpen() {}

function bgClass(bgTheme) {
  return bgTheme === 'dark' || bgTheme === 'light' ? bgTheme : 'transp ' + bgTheme;
}

},{"../settings":147,"./gamesMenu":153,"./helper":156,"./loginModal":161,"./menu":171,"./menu/menuView":172,"./newGameForm":173,"./shared/layout/MainBoard":188,"./signupModal":198,"mithril/hyperscript":113}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _xhr = require('../xhr');

var xhr = _interopRequireWildcard(_xhr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  startSeeking: function startSeeking(conf) {
    doStartSeeking(conf);
  }
};


function doStartSeeking(conf) {
  // router.backbutton.stack.push(userCancelSeeking);

  sendHook(conf);
}

function sendHook(setup) {
  xhr.seekGame(setup).then(function (data) {
    // console.log(data);
    _router2.default.set('/masa/' + data.id);
  }).catch(utils.handleXhrError);
}

// import * as utils from '../utils';
// import * as xhr from '../xhr';
// import m from 'mithril';

// let nbPlayers = 0;
// let nbGames = 0;

// const lobby = {};
// lobby.isOpen = false;

// lobby.startSeeking = function() {
//   xhr.newGame().then(function(data) {
//     // analytics
//     m.route('/masa/' + data.id);
//   }, function(error) {
//     utils.handleXhrError(error);
//     throw error;
//   });
// };


// export default lobby;

},{"../router":144,"../utils":205,"../utils/redraw":207,"../xhr":210}],161:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _signals = require('../signals');

var _signals2 = _interopRequireDefault(_signals);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _signupModal = require('./signupModal');

var _signupModal2 = _interopRequireDefault(_signupModal);

var _icons = require('./shared/icons');

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;
var formError = null;

exports.default = {
  open: open,
  close: close,
  view: function view() {
    if (!isOpen) return null;

    return (0, _hyperscript2.default)('div.modal#loginModal', { oncreate: helper.slidesInUp }, [(0, _hyperscript2.default)('header', [(0, _hyperscript2.default)('button.modal_close', {
      oncreate: helper.ontap(helper.slidesOutDown(close, 'loginModal'))
    }, _icons.closeIcon), (0, _hyperscript2.default)('h2', (0, _i18n2.default)('signIn'))]), (0, _hyperscript2.default)('div.modal_content', [(0, _hyperscript2.default)('form.login', {
      onsubmit: function onsubmit(e) {
        e.preventDefault();
        submit(e.target);
      }
    }, [formError ? (0, _hyperscript2.default)('div.form-error', formError) : null, (0, _hyperscript2.default)('div.field', [(0, _hyperscript2.default)('input#username', {
      type: 'text',
      className: formError ? 'form-error' : '',
      placeholder: (0, _i18n2.default)('username'),
      autocomplete: 'off',
      autocapitalize: 'off',
      autocorrect: 'off',
      spellcheck: false,
      required: true
    })]), (0, _hyperscript2.default)('div.field', [(0, _hyperscript2.default)('input#password', {
      type: 'password',
      className: formError ? 'form-error' : '',
      placeholder: (0, _i18n2.default)('password'),
      required: true
    })]), (0, _hyperscript2.default)('div.submit', [(0, _hyperscript2.default)('button.submitButton[data-icon=F]', (0, _i18n2.default)('signIn'))])]), (0, _hyperscript2.default)('div.signup', [(0, _i18n2.default)('newToOyunkeyf') + ' ', (0, _hyperscript2.default)('br'), (0, _hyperscript2.default)('a', {
      oncreate: helper.ontap(_signupModal2.default.open)
    }, [(0, _i18n2.default)('signUp')])])])]);
  }
};


function open() {
  _router2.default.backbutton.stack.push(helper.slidesOutDown(close, 'loginModal'));
  isOpen = true;
  formError = null;
}

function close(fromBB) {
  window.Keyboard.hide();
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

function submit(form) {
  var username = form['username'].value;
  var password = form['password'].value;
  if (!username || !password) return;

  (0, _redraw2.default)();
  window.Keyboard.hide();
  _session2.default.login(username, password).then(function () {
    close();
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    _signals2.default.afterLogin.dispatch();
    (0, _redraw2.default)();
    socket.reconnectCurrent();
    _session2.default.refresh();
  }).catch(function (err) {
    if (err.status !== 400 && err.status !== 401) (0, _utils.handleXhrError)(err);else {
      if (err.body.global) {
        formError = err.body.global[0];
        (0, _redraw2.default)();
      }
    }
  });
}

// OLD

var loginModal = {};

function submitOLD(form) {
  var login = form[0].value.trim();
  var pass = form[1].value;
  if (!login || !pass) return false;
  window.cordova.plugins.Keyboard.close();
  return _session2.default.login(login, pass).then(function () {
    loginModal.close();
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    // push.register();
    _session2.default.refresh().catch(function (err) {
      if (err.status === 401) {
        // https://github.com/veloce/lichobile/blob/master/project/src/js/ui/loginModal.js#L28
        window.navigator.notification.alert('oyunkeyfAuthenticationCannotWorkWithoutCookies');
      }
    });
  }).catch(utils.handleXhrError);
}

loginModal.open = function () {
  _backbutton2.default.stack.push(helper.slidesOutDown(loginModal.close, 'loginModal'));
  isOpen = true;
};

loginModal.close = function (fromBB) {
  window.cordova.plugins.Keyboard.close();
  if (fromBB !== 'backbutton' && isOpen) _backbutton2.default.stack.pop();
  isOpen = false;
};

loginModal.view = function () {
  if (!isOpen) return null;

  return m('div.modal#loginModal', { config: helper.slidesInUp }, [m('header', [m('button.modal_close[data-icon=L]', {
    config: helper.ontouch(helper.slidesOutDown(loginModal.close, 'loginModal'))
  }), m('h2', (0, _i18n2.default)('signIn'))]), m('div.modal_content', [m('form.login', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      return submit(e.target);
    }
  }, [m('input#pseudo[type=text]', {
    placeholder: (0, _i18n2.default)('username'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: 'false',
    required: true
  }), m('input#password[type=password]', {
    placeholder: (0, _i18n2.default)('password'),
    required: true
  }), m('button.fat', (0, _i18n2.default)('signIn'))]), m('div.signup', [m('a', {
    config: helper.ontouch(_signupModal2.default.open)
  }, [(0, _i18n2.default)('newToOyunkeyf'), ' ', (0, _i18n2.default)('signUp')])])])]);
};

// export default loginModal;

},{"../backbutton":135,"../i18n":138,"../router":144,"../session":146,"../signals":148,"../utils":205,"../utils/redraw":207,"./helper":156,"./shared/icons":187,"./signupModal":198,"mithril/hyperscript":113}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MasasListCtrl;

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _utils = require('../../utils');

var _masaXhr = require('./masaXhr');

var xhr = _interopRequireWildcard(_masaXhr);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MasasListCtrl(defaultTab) {
  var _this = this;

  this.currentTab = defaultTab || 0;

  xhr.currentMasas().then(function (data) {
    _this.masas = data;
    (0, _redraw2.default)();
  }).catch(_utils.handleXhrError);

  this.onTabChange = function (tabIndex) {
    var loc = window.location.search.replace(/\?tab\=\w+$/, '');

    try {
      window.history.replaceState(window.history.state, '', loc + '?tab=' + tabIndex);
    } catch (e) {
      console.error(e);
    }
    _this.currentTab = tabIndex;
    (0, _redraw2.default)();
  };
}

},{"../../utils":205,"../../utils/redraw":207,"./masaXhr":169}],163:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MasaCtrl;

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _utils = require('../../../utils');

var utils = _interopRequireWildcard(_utils);

var _masaXhr = require('../masaXhr');

var xhr = _interopRequireWildcard(_masaXhr);

var _faq = require('../faq');

var _faq2 = _interopRequireDefault(_faq);

var _socketHandler = require('./socketHandler');

var _socketHandler2 = _interopRequireDefault(_socketHandler);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MasaCtrl(id) {
  var _this = this;

  this.id = id;

  this.faqCtrl = _faq2.default.controller(this);

  xhr.masa(id).then(function (data) {
    _this.masa = data;
    _this.seatId = data.seatId;

    _this.startsAt = window.moment(data.startsAt).calendar();
    loadCurrentPage(_this.masa.standing);
    _this.hasJoined = !!(data.me && !data.me.withdraw);

    _socket2.default.createMasa(_this.id, _this.masa.socketVersion, (0, _socketHandler2.default)(_this));

    (0, _redraw2.default)();
  }).catch(function (err) {
    if (err.status === 404) {
      _this.notFound = true;
      (0, _redraw2.default)();
    } else {
      utils.handleXhrError(err);
    }
  });

  this.invite = (0, _throttle2.default)(function () {
    xhr.invite(_this.masa.id).then(function () {
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.join = (0, _throttle2.default)(function () {
    xhr.join(_this.masa.id).then(function () {
      _this.hasJoined = true;
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.withdraw = (0, _throttle2.default)(function () {
    xhr.withdraw(_this.masa.id).then(function () {
      _this.hasJoined = false;
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.reload = (0, _throttle2.default)(function () {
    xhr.reload(_this.id).then(onReload).catch(onXhrError);
  }, 2000);

  this.unload = function () {
    document.removeEventListener('resume', _this.reload);
  };

  var onReload = function onReload(data) {
    var oldData = _this.masa;
    _this.masa = data;
    _this.seatId = data.seatId;
    loadCurrentPage(data.standing);
    _this.hasJoined = !!(data.me && !data.me.withdraw);
    redirectToMyGame();
    (0, _redraw2.default)();
  };

  var redirectToMyGame = function redirectToMyGame() {
    var gameId = myCurrentGameId(_this);
    if (gameId) _router2.default.set('/masa/' + _this.masa.id + '/game/' + gameId, true);
  };

  var myCurrentGameId = function myCurrentGameId(ctrl) {
    var ids = {
      created: 10,
      started: 20,
      aborted: 25
    };

    var seatId = ctrl.seatId;
    if (!seatId) return null;
    var pairing = ctrl.masa.pairings.filter(function (p) {
      return p.s < ids.aborted && p.u.filter(function (id) {
        return id.toLowerCase() === seatId.toLowerCase();
      })[0];
    })[0];
    return pairing ? pairing.id : null;
  };

  var onXhrError = function onXhrError(err) {
    if (err.status === 404) {
      _this.notFound = true;
    }
    (0, _redraw2.default)();
  };

  var loadCurrentPage = function loadCurrentPage(data) {
    _this.currentPageResults = data.players;
  };
}

},{"../../../router":144,"../../../socket":149,"../../../utils":205,"../../../utils/redraw":207,"../faq":167,"../masaXhr":169,"./socketHandler":166,"lodash/throttle":109}],164:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _common = require('../../shared/common');

var _helper = require('../../helper');

var helper = _interopRequireWildcard(_helper);

var _layout = require('../../layout');

var _layout2 = _interopRequireDefault(_layout);

var _masaView = require('./masaView');

var _MasaCtrl = require('./MasaCtrl');

var _MasaCtrl2 = _interopRequireDefault(_MasaCtrl);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    this.ctrl = new _MasaCtrl2.default(attrs.id);
  },

  oncreate: helper.viewSlideIn,
  onremove: function onremove() {
    _socket2.default.destroy();
    this.ctrl.unload();
  },
  view: function view() {
    if (this.ctrl.notFound) {
      return _layout2.default.free((0, _common.dropShadowHeader)(null, (0, _common.backButton)((0, _i18n2.default)('masaNotFound'))), (0, _hyperscript2.default)('div.masaNotFound', { key: 'masa-not-found' }, [(0, _hyperscript2.default)('p', (0, _i18n2.default)('masaDoesNotExist')), (0, _hyperscript2.default)('p', (0, _i18n2.default)('masaMayHaveBeenCanceled'))]));
    }

    var masa = this.ctrl.masa;
    var header = void 0;

    if (masa) {
      header = (0, _common.dropShadowHeader)(null, (0, _common.backButton)((0, _hyperscript2.default)('div.main_header_title.withSub', [(0, _hyperscript2.default)('h1', [(0, _hyperscript2.default)('span.fa.fa-trophy'), this.ctrl.masa.fullName]), (0, _hyperscript2.default)('h2.header-subTitle.masa-subTitle', !masa.isFinished && !masa.isStarted ? (0, _masaView.timeInfo)('created', masa.playersToStart, 'Oyuncu bekleniyor') : (0, _masaView.timeInfo)('started', masa.roundsToFinish, ''))])));
    } else {
      header = (0, _common.connectingDropShadowHeader)();
    }

    var body = (0, _masaView.masaBody)(this.ctrl);
    var footer = (0, _masaView.renderFooter)(this.ctrl);
    var faqOverlay = (0, _masaView.renderFAQOverlay)(this.ctrl);
    var overlay = [faqOverlay];

    return _layout2.default.free(header, body, footer, overlay);
  }
};

},{"../../../i18n":138,"../../../socket":149,"../../helper":156,"../../layout":159,"../../shared/common":185,"./MasaCtrl":163,"./masaView":165,"mithril/hyperscript":113}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderFAQOverlay = renderFAQOverlay;
exports.masaBody = masaBody;
exports.renderFooter = renderFooter;
exports.timeInfo = timeInfo;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _session = require('../../../session');

var _session2 = _interopRequireDefault(_session);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../../helper');

var helper = _interopRequireWildcard(_helper);

var _settings = require('../../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _faq = require('../faq');

var _faq2 = _interopRequireDefault(_faq);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderFAQOverlay(ctrl) {
  return [_faq2.default.view(ctrl.faqCtrl)];
}

function masaBody(ctrl) {
  var data = ctrl.masa;
  if (!data) return null;

  return (0, _hyperscript2.default)('div.masaContainer.native_scroller.page', [masaHeader(data, ctrl), data.podium ? masaPodium(data.podium) : null, masaLeaderboard(ctrl)]);
}

function renderFooter(ctrl) {
  var m = ctrl.masa;
  if (!m) return null;
  var mUrl = 'https://oyunkeyf.net/masa/' + m.id;

  return (0, _hyperscript2.default)(
    'div',
    { className: 'actions_bar' },
    (0, _hyperscript2.default)(
      'button',
      { key: 'faq', className: 'action_bar_button', oncreate: helper.ontap(ctrl.faqCtrl.open) },
      (0, _hyperscript2.default)('span', { className: 'fa fa-question-circle' }),
      'SSS'
    ),
    ctrl.hasJoined ? withdrawButton(ctrl, m) : joinButton(ctrl, m)
  );
}

function timeInfo(key, rounds, preceedingText) {
  if (rounds === undefined) return null;

  return [preceedingText ? preceedingText + ' ' : null];
}

function masaHeader(data, ctrl) {
  return (0, _hyperscript2.default)(
    'div',
    { key: 'header', className: 'masaHeader' },
    masaTimeInfo(data),
    masaCreatorInfo(data, ctrl.startsAt)
  );
}

function masaTimeInfo(data) {
  var variant = data.variant;
  var control = data.scores;
  return (0, _hyperscript2.default)(
    'div',
    { className: 'masaTimeInfo' },
    (0, _hyperscript2.default)(
      'strong',
      { className: 'masaInfo withIcon' },
      variant + ' • ' + control
    )
  );
}

function masaCreatorInfo(data, startsAt) {
  return (0, _hyperscript2.default)(
    'div',
    { className: 'masaCreatorInfo' },
    (0, _i18n2.default)('by', data.createdBy),
    '\xA0\u2022\xA0',
    startsAt
  );
}

function joinButton(ctrl, m) {
  if (!_session2.default.isConnected() || m.isFinished) {
    return null;
  }
  var action = function action() {
    return ctrl.join();
  };
  return (0, _hyperscript2.default)(
    'button',
    { key: 'join', className: 'action_bar_button', oncreate: helper.ontap(action) },
    (0, _hyperscript2.default)('span', { className: 'fa fa-play' }),
    (0, _i18n2.default)('join')
  );
}

function withdrawButton(ctrl, m) {
  if (m.isFinished) {
    return null;
  }
  return (0, _hyperscript2.default)(
    'button',
    { key: 'withdraw', className: 'action_bar_button', oncreate: helper.ontap(ctrl.withdraw) },
    (0, _hyperscript2.default)('span', { className: 'fa fa-flag' }),
    (0, _i18n2.default)('withdraw')
  );
}

function masaLeaderboard(ctrl) {

  var data = ctrl.masa;
  var players = ctrl.currentPageResults;
  var user = _session2.default.get();
  var userName = user ? user.username : '';

  return (0, _hyperscript2.default)(
    'div',
    { key: 'leaderboard', className: 'masaLeaderboard' },
    data.nbPlayers > 0 ? (0, _hyperscript2.default)(
      'p',
      { className: 'masaTitle' },
      ' ',
      (0, _i18n2.default)("leaderboard"),
      ' (',
      (0, _i18n2.default)('nbConnectedPlayers', data.nbPlayers),
      ')'
    ) : null,
    (0, _hyperscript2.default)(
      'ul',
      { className: 'masaStandings' },
      players.map(function (p) {
        return renderPlayerEntry(ctrl, userName, p);
      })
    )
  );
}

function renderPlayerEntry(ctrl, userName, player) {
  var isMe = player.name === userName;

  return !player.active ? (0, _hyperscript2.default)(
    'li',
    { key: player.id, className: 'list-item masa-list-player' },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaPlayer' },
      (0, _hyperscript2.default)(
        'span',
        { className: 'flagRank', 'data-icon': player.withdraw ? 'b' : '' },
        ' ',
        player.withdraw ? '' : player.rank + '. '
      ),
      (0, _hyperscript2.default)(
        'span',
        null,
        ' ',
        (0, _i18n2.default)('emptySeat')
      ),
      (0, _hyperscript2.default)(
        'button',
        { oncreate: helper.ontap(ctrl.invite) },
        (0, _i18n2.default)('inviteBot')
      )
    ),
    (0, _hyperscript2.default)(
      'span',
      { className: 'masaPoints ', 'data-icon': 'Q' },
      player.score
    )
  ) : (0, _hyperscript2.default)(
    'li',
    { className: 'list-item masa-list-player ' + (isMe ? 'masa-me' : '') },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaPlayer' },
      (0, _hyperscript2.default)(
        'span',
        { className: 'flagRank', 'data-icon': player.withdraw ? 'b' : '' },
        ' ',
        player.withdraw ? '' : player.rank + '. '
      ),
      (0, _hyperscript2.default)(
        'span',
        null,
        ' ',
        !player.name ? 'Anonymous' : player.name + ' (' + player.rating + ') '
      )
    ),
    (0, _hyperscript2.default)(
      'span',
      { className: 'masaPoints ', 'data-icon': 'Q' },
      player.score
    )
  );
}

},{"../../../i18n":138,"../../../router":144,"../../../session":146,"../../../settings":147,"../../helper":156,"../faq":167,"mithril/hyperscript":113}],166:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ctrl) {
  return {
    reload: ctrl.reload,
    redirect: function redirect(gameId) {
      // doesn't fire for new join
      console.log("redirect" + gameId);
    }
  };
};

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"../../../router":144,"../../../utils/redraw":207}],167:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: function controller(masa) {
    var _isOpen = false;

    function open() {
      _router2.default.backbutton.stack.push(close);
      _isOpen = true;
    }
    function close(fromBB) {
      if (fromBB !== 'backbutton' && _isOpen) _router2.default.backbutton.stack.pop();
      _isOpen = false;
    }

    return {
      open: open,
      close: close,
      isOpen: function isOpen() {
        return _isOpen;
      },
      masa: masa
    };
  },
  view: function view(ctrl) {
    if (!ctrl.isOpen()) return null;
    var masa = ctrl.masa;

    if (!masa) return null;

    return h(
      'div',
      { className: 'modal', id: 'masaFaqModal', config: helper.slidesInUp },
      h(
        'header',
        null,
        h('button', { className: 'modal_close', 'data-icon': 'L',
          oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, "masaFaqModal")) }),
        h(
          'h2',
          null,
          (0, _i18n2.default)('masaFAQ')
        )
      ),
      h(
        'div',
        { className: 'modal_content' },
        h(
          'div',
          { className: 'masaFaq' },
          h(
            'h2',
            null,
            'Puanl\u0131 m\u0131?'
          ),
          masa.rated === undefined ? 'Bazı masalar puanlıdır ve reytinginizi etkiler.' : masa.rated ? 'Bu masa puanlıdır ve reytinginizi etkiler.' : 'Bu masa puanlı *değildir* ve reytinginizi *etkilemez*.',
          h(
            'h2',
            null,
            ' Puanlar nas\u0131l hesaplan\u0131r? '
          ),
          'Masaya kat\u0131l\u0131mda her oyuncu ortaya el say\u0131s\u0131 kadar puan\u0131n\u0131 koyar. Masa sonunda ortadaki puanlar \u015F\xF6yle da\u011F\u0131t\u0131l\u0131r:',
          h(
            'ul',
            null,
            h(
              'li',
              null,
              '1. %50 puan'
            ),
            h(
              'li',
              null,
              '2. %25 puan'
            ),
            h(
              'li',
              null,
              '3. %15 puan'
            ),
            h(
              'li',
              null,
              '4. %10 puan'
            )
          ),
          '\xD6rne\u011Fin 10 ellik bir oyunda oyuncular\u0131n puanlar\u0131 1500 olsun. Masaya kat\u0131ld\u0131klar\u0131nda puanlar\u0131 1490 olur. Ortada toplam 40 puan vard\u0131r, ve \u015F\xF6yle da\u011F\u0131t\u0131l\u0131r:',
          h(
            'ul',
            null,
            h(
              'li',
              null,
              '1. +20 = 1510'
            ),
            h(
              'li',
              null,
              '2. +10 = 1500'
            ),
            h(
              'li',
              null,
              '3. +6 = 1496'
            ),
            h(
              'li',
              null,
              '4. +4 = 1494'
            )
          ),
          'Masa bitmeden ayr\u0131lan oyuncu puan alamaz.',
          h(
            'h2',
            null,
            ' Kazanan nas\u0131l belirlenir? '
          ),
          'Masada b\xFCt\xFCn eller oynand\u0131ktan sonra en az cezas\u0131 olan oyuncu galip ilan edilir.',
          h(
            'h2',
            null,
            ' Masada eslestirme nasil yapilir? '
          ),
          'Masaya 4 oyuncu katildiginda el baslar. Bir el bittikten sonra yeni el baslar, yeni ele katilmak icin oyuncular masaya geri donmelidir.',
          h(
            'h2',
            null,
            ' Masa ne zaman biter? '
          ),
          'Masada el say\u0131s\u0131 kadar oyun oynand\u0131\u011F\u0131nda masa biter.',
          h(
            'h2',
            null,
            ' Oyundan ayr\u0131lma '
          ),
          'Oyun devam ederken oyundan ayrilan oyuncu masadan atilir, ve o el iptal olur. Masa bitmeden masadan ayr\u0131lan oyuncu puan alamaz.',
          h(
            'h2',
            null,
            ' Di\u011Fer \xF6nemli kurallar '
          ),
          'Siraniz geldiginde, oyanama s\xFCrenizi a\u015Farsan\u0131z sistem sizin yerinize oynar.'
        )
      )
    );
  }
};

},{"../../backbutton":135,"../../i18n":138,"../../router":144,"../helper":156,"mithril/hyperscript":113}],168:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('../../utils');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _MasasListCtrl = require('./MasasListCtrl');

var _MasasListCtrl2 = _interopRequireDefault(_MasasListCtrl);

var _masasListView = require('./masasListView');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  oncreate: helper.viewFadeIn,

  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    // socket.createDefault()

    this.ctrl = new _MasasListCtrl2.default((0, _utils.safeStringToNum)(attrs.tab));
  },
  view: function view() {
    var ctrl = this.ctrl;

    var body = (0, _masasListView.renderMasasList)(ctrl);
    var footer = (0, _masasListView.renderFooter)();
    var overlay = null;

    return _layout2.default.free((0, _common.header)((0, _i18n2.default)('masas')), body, footer, overlay);
  }
};

},{"../../i18n":138,"../../session":146,"../../utils":205,"../helper":156,"../layout":159,"../shared/common":185,"./MasasListCtrl":162,"./masasListView":170}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.currentMasas = currentMasas;
exports.masa = masa;
exports.reload = reload;
exports.join = join;
exports.invite = invite;
exports.withdraw = withdraw;

var _http = require('../../http');

function currentMasas() {
  return (0, _http.fetchJSON)('/masa', {}, true);
}

function masa(id) {
  return (0, _http.fetchJSON)('/masa/' + id, { query: { socketVersion: 1 } }, true);
}

function reload(id, page) {
  return (0, _http.fetchJSON)('/masa/' + id, { method: 'GET', query: page ? { page: page } : {} });
}

function join(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/join', { method: 'POST' }, true);
}

function invite(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/invite', { method: 'POST' }, true);
}

function withdraw(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/withdraw', { method: 'POST' }, true);
}

// import { request } from '../../http';

// export function currentMasas() {
//   return request('/masa', {}, true);
// }

// export function masa(id) {
//   return request('/masa/' + id, { data: {socketVersion: 1}}, true);
// }

// export function reload(id) {
//   return request('/masa/' + id,
//                  {
//                    method: 'GET',
//                    data: {},
//                    background: true
//                  });
// }

// export function join(id, side) {
//   side = side ? `?side=${side}`: '';
//   return request('/masa/' + id + '/join' + side, { method: 'POST' }, true);
// }

// export function withdraw(id) {
//   return request('/masa/' + id + '/withdraw', { method: 'POST' }, true);
// }

},{"../../http":137}],170:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderMasasList = renderMasasList;
exports.renderMasaList = renderMasaList;
exports.renderFooter = renderFooter;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _utils = require('../../utils');

var _TabNavigation = require('../shared/TabNavigation');

var _TabNavigation2 = _interopRequireDefault(_TabNavigation);

var _TabView = require('../shared/TabView');

var _TabView2 = _interopRequireDefault(_TabView);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TABS = [{
  label: 'Açık'
}, {
  label: 'Oynanan'
}, {
  label: 'Biten'
}];

function onMasaTap(e) {
  var el = helper.getLI(e);
  var ds = el.dataset;
  if (el && ds.id) {
    _router2.default.set('/masa/' + ds.id);
  }
}

function renderMasasList(ctrl) {
  if (!ctrl.masas) return null;

  var tabsContent = [ctrl.masas['created'], ctrl.masas['started'], ctrl.masas['finished']];

  return [(0, _hyperscript2.default)('div.tabs-nav-header.subHeader', (0, _hyperscript2.default)(_TabNavigation2.default, {
    buttons: TABS,
    selectedIndex: ctrl.currentTab,
    onTabChange: ctrl.onTabChange
  }), (0, _hyperscript2.default)('div.main_header_drop_shadow')), (0, _hyperscript2.default)(_TabView2.default, {
    className: 'masaTabsWrapper',
    selectedIndex: ctrl.currentTab,
    content: tabsContent,
    renderer: renderMasaList,
    onTabChange: ctrl.onTabChange
  })];
}

function renderMasaList(list) {
  return (0, _hyperscript2.default)('ul.native_scroller.masaList', {
    oncreate: helper.ontapXY(onMasaTap, undefined, helper.getLI)
  }, list.map(renderMasaListItem));
}

function renderMasaListItem(masa, index) {
  var mode = masa.rated ? (0, _i18n2.default)('rated') : (0, _i18n2.default)('casual');
  var variant = (0, _utils.capitalize)(masa.variant.short);
  var evenOrOdd = index % 2 === 0 ? ' even ' : ' odd ';
  var scores = masa.scores;
  var rounds = masa.rounds;

  return (0, _hyperscript2.default)(
    'li',
    { key: masa.id,
      className: 'list_item masa_item' + evenOrOdd,
      'data-id': masa.id
    },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaListName' },
      (0, _hyperscript2.default)(
        'div',
        { className: 'fullName' },
        masa.fullName
      ),
      (0, _hyperscript2.default)(
        'small',
        { className: 'infos' },
        variant,
        ' ',
        mode,
        ' \u2022 ',
        scores ? scores + ' ' + (0, _i18n2.default)('points') : (0, _i18n2.default)('rounds', rounds)
      )
    ),
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaListTime' },
      (0, _hyperscript2.default)(
        'small',
        { className: 'nbUsers withIcon', 'data-icon': 'r' },
        masa.nbPlayers
      )
    )
  );
}

function renderFooter() {
  return (0, _hyperscript2.default)(
    'div',
    { className: 'actions_bar' },
    (0, _hyperscript2.default)(
      'button',
      { key: 'createMasa', className: 'action_create_button' },
      (0, _hyperscript2.default)('span', { className: 'fa fa-plus-circle' }),
      (0, _i18n2.default)('createANewMasa')
    )
  );
}

},{"../../i18n":138,"../../router":144,"../../utils":205,"../helper":156,"../shared/TabNavigation":182,"../shared/TabView":183,"mithril/hyperscript":113}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backdropCloseHandler = exports.mainMenuCtrl = exports.profileMenuOpen = undefined;
exports.route = route;
exports.popup = popup;

var _stream = require('mithril/stream');

var _stream2 = _interopRequireDefault(_stream);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _SideMenuCtrl = require('../shared/sideMenu/SideMenuCtrl');

var _SideMenuCtrl2 = _interopRequireDefault(_SideMenuCtrl);

var _helper = require('../helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var profileMenuOpen = exports.profileMenuOpen = (0, _stream2.default)(false);

function onMenuOpen() {}

function onMenuClose() {}

var mainMenuCtrl = exports.mainMenuCtrl = new _SideMenuCtrl2.default('left', 'side_menu', 'menu-close-overlay', onMenuOpen, onMenuClose);

function route(route) {
  return function () {
    return mainMenuCtrl.close().then(function () {
      return _router2.default.set(route);
    });
  };
}

function popup(action) {
  return function () {
    return mainMenuCtrl.close().then(function () {
      action();
      (0, _redraw2.default)();
    });
  };
}

var backdropCloseHandler = exports.backdropCloseHandler = (0, _helper.ontap)(function () {
  mainMenuCtrl.close();
});

var menu = {};

/* properties */
menu.isOpen = false;
// menu.headerOpen = m.prop(false);

menu.route = function (route) {
  return function () {
    return menu.close().then(_mithril2.default.route.bind(null, route));
  };
};

menu.popup = function (action) {
  return function () {
    return menu.close().then(function () {
      action();
      _mithril2.default.redraw();
    });
  };
};

menu.toggle = function () {
  if (menu.isOpen) menu.close();else menu.open();
};

menu.open = function () {
  _backbutton2.default.stack.push(menu.close);
  menu.isOpen = true;
};

menu.willClose = false;
menu.close = function (fromBB) {
  var sideMenu = document.getElementById('side_menu');

  if (menu.willClose || !sideMenu) return Promise.resolve(null);

  menu.willClose = true;
  if (fromBB !== 'backbutton' && menu.isOpen) _backbutton2.default.stack.pop();
  _mithril2.default.redraw.strategy('none');
  return (0, _zanimo2.default)(sideMenu, 'transform', 'translate3d(-100%,0,0', 250, 'ease-out').then(function () {
    menu.headerOpen(false);
    menu.isOpen = false;
    menu.willClose = false;
    _mithril2.default.redraw();
  }).catch(function (err) {
    console.error(err);
    menu.headerOpen(false);
    menu.isOpen = false;
    menu.willClose = false;
    _mithril2.default.redraw();
  });
};

menu.toggleHeader = function () {
  return menu.headerOpen() ? menu.headerOpen(false) : menu.headerOpen(true);
};

exports.default = menu;

},{"../../backbutton":135,"../../router":144,"../../utils/redraw":207,"../helper":156,"../shared/sideMenu/SideMenuCtrl":196,"mithril":114,"mithril/stream":121,"zanimo":131}],172:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _loginModal = require('../loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _utils = require('../../utils');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _ = require('.');

var menu = _interopRequireWildcard(_);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  onbeforeupdate: function onbeforeupdate() {
    return menu.mainMenuCtrl.isOpen;
  },
  view: function view() {
    var user = _session2.default.get();

    return h(
      'aside',
      { id: 'side_menu' },
      renderHeader(user),
      h(
        'div',
        { className: 'native_scroller side_menu_scroller' },
        user && menu.profileMenuOpen() ? renderProfileActions(user) : renderLinks(user)
      )
    );
  }
};


function renderHeader(user) {
  var profileLink = user ? menu.route('/@/' + user.id) : _utils.noop;

  return h(
    'header',
    { className: 'side_menu_header' },
    (0, _utils.hasNetwork)() && !user ? h(
      'button',
      { className: 'signInButton', oncreate: helper.ontapXY(_loginModal2.default.open) },
      (0, _i18n2.default)('signIn')
    ) : null,
    user ? h(
      'h2',
      { className: 'username', oncreate: helper.ontapXY(profileLink) },
      user.username
    ) : null
  );
}

function slidesInUp(el, isUpdate, context) {
  if (!isUpdate) {
    el.style.transform = 'translate3d(-100%, 0, 0)';
    // force reflow back
    context.lol = el.offsetHeight;
    (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out');
  }
}

function renderLinks(user) {

  return h(
    'ul',
    { className: 'side_links',
      oncreate: helper.ontapXY(onLinkTap, undefined, helper.getLI) },
    h(
      'li',
      { className: 'side_link', 'data-route': '/' },
      h('span', { className: 'fa fa-home' }),
      (0, _i18n2.default)('home')
    ),
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'sep_link', key: 'sep_link_online' },
      (0, _i18n2.default)('playOnline')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-popup': 'createAGame' },
      h('span', { className: 'fa fa-plus-circle' }),
      (0, _i18n2.default)('createAGame')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/masas' },
      h('span', { className: 'fa fa-trophy' }),
      (0, _i18n2.default)('masas')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/players' },
      h('span', { className: 'fa fa-at' }),
      (0, _i18n2.default)('players')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/ranking' },
      h('span', { className: 'fa fa-cubes' }),
      (0, _i18n2.default)('leaderboard')
    ) : null,
    h('li', { className: 'hr' }),
    h(
      'li',
      { className: 'side_link', 'data-route': '/settings' },
      h('span', { className: 'fa fa-cog' }),
      (0, _i18n2.default)('settings')
    )
  );
}

function renderProfileActions(user) {
  return h(
    'ul',
    { className: 'side_links profileActions' },
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(menu.route('/@/' + user.id)) },
      h('span', { 'data-icon': 'r' }),
      (0, _i18n2.default)('profile')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(menu.route('/settings/preferences')) },
      h('span', { 'data-icon': '%' }),
      (0, _i18n2.default)('preferences')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(function () {
          _session2.default.logout();
          menu.headerOpen(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

var popupActionMap = {
  'createAGame': function createAGame() {
    return _newGameForm2.default.openRealtime();
  }
};

function onLinkTap(e) {
  var el = helper.getLI(e);
  var ds = el.dataset;
  if (el && ds.route) {
    menu.route(ds.route)();
  } else if (el && ds.popup) {
    menu.popup(popupActionMap[ds.popup])();
  }
}

// OLD

function renderProfileActionsOLD(user) {
  return h(
    'ul',
    { className: 'side_links profileActions' },
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(menu.route('/@/' + user.id)) },
      h('span', { className: 'fa fa-user' }),
      (0, _i18n2.default)('profile')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(menu.route('/settings/preferences')) },
      h('span', { 'data-icon': '%' }),
      (0, _i18n2.default)('preferences')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(function () {
          _session2.default.logout();
          menu.profileMenuOpen(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

function renderMenu() {
  var user = _session2.default.get();
  return h(
    'div',
    { className: 'native_scroller' },
    renderHeader(user),
    user && menu.headerOpen() ? renderProfileActions(user) : renderLinks(user)
  );
}

},{".":171,"../../i18n":138,"../../session":146,"../../utils":205,"../helper":156,"../loginModal":161,"../newGameForm":173,"mithril/hyperscript":113,"zanimo":131}],173:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderQuickSetup = renderQuickSetup;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _setup = require('../oyunkeyf/setup');

var _popup = require('./shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _form = require('./shared/form');

var _form2 = _interopRequireDefault(_form);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _xhr = require('../xhr');

var xhr = _interopRequireWildcard(_xhr);

var _lobby = require('./lobby');

var _lobby2 = _interopRequireDefault(_lobby);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;

var humanSetup = _settings2.default.gameSetup.human;

exports.default = {
  open: open,
  close: close,
  openRealtime: function openRealtime() {
    open();
  },
  view: function view() {
    return (0, _popup2.default)('new_game_form_popup game_form_popup', undefined, renderContent, isOpen, close);
  }
};


function open() {
  _router2.default.backbutton.stack.push(close);
  isOpen = true;
}

function close(fromBB) {
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

function renderContent() {
  var conf = humanSetup;

  return (0, _hyperscript2.default)('div', [(0, _hyperscript2.default)('div.newGame-preset_switch', [renderCustomSetup('human', conf, conf.availableVariants)])]);
}

function renderCustomSetup(formName, settingsObj, variants) {
  var generalFieldset = [(0, _hyperscript2.default)('div.select_input', {
    key: formName + 'variant'
  }, _form2.default.renderSelect('variant', formName + 'variant', variants, settingsObj.variant))];

  var modes = [['casual', '0'], ['rated', '1']];

  generalFieldset.push((0, _hyperscript2.default)('div.select_input', {
    key: formName + 'mode'
  }, _form2.default.renderSelect('mode', formName + 'mode', modes, settingsObj.mode)));

  var timeFieldset = [];

  timeFieldset.push((0, _hyperscript2.default)('div.select_input.inline', {
    key: formName + 'round'
  }, _form2.default.renderSelect('rounds', formName + 'rounds', _settings2.default.gameSetup.availableRounds, settingsObj.rounds, false)));

  return (0, _hyperscript2.default)('form.game_form', {
    key: 'customSetup',
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      close();
      goSeek((0, _setup.humanSetupFromSettings)(settingsObj));
    }
  }, [(0, _hyperscript2.default)('fieldset', generalFieldset), (0, _hyperscript2.default)('fieldset', timeFieldset), (0, _hyperscript2.default)('div.popupActionWrapper', [(0, _hyperscript2.default)('button[data-icon=E][type=submit].popupAction', (0, _i18n2.default)('createAGame'))])]);
}

function renderQuickSetup(onCustom) {
  return (0, _hyperscript2.default)('div.newGame-pools', { key: 'quickSetup' }, (0, _hyperscript2.default)('div.newGame-pool', {
    key: 'pool-custom',
    oncreate: helper.ontap(onCustom)
  }, (0, _hyperscript2.default)('div.newGame-custom', 'Özel')));
}

function goSeek(conf) {
  close();

  _lobby2.default.startSeeking(conf);
}

// export function renderQuickSetup() {
//   return h('div.newGame-pools', { key: 'quickSetup' },
//            xhr.cachedPools.map(p => renderPool(p))
//           );
// }

// function renderPool(p) {
//   return h('div.newGame-pool', {
//     key: 'pool-' + p.id,
//     oncreate: helper.ontap(() => {
//       console.log('oncreate');
//     })
//   }, [h('div.newGame-rounds', p.id),
//       h('div.newGame-perf', p.perf)
//      ]);
// }

// const newGameForm = {};

// newGameForm.isOpen = false;

// newGameForm.open = function() {
//   backbutton.stack.push(newGameForm.close);
//   newGameForm.isOpen = true;
// };

// newGameForm.close = function(fromBB) {
//   if (fromBB !== 'backbutton' && newGameForm.isOpen) backbutton.stack.pop();
//   newGameForm.isOpen = false;
// };

// newGameForm.openRealtime = function() {
//   newGameForm.open();
// };

// function seekHumanGame() {
//   newGameForm.close();
//   lobby.startSeeking();
// }

// function renderForm(formName, action, settingsObj, variants) {
//   var generalFieldset = [
//     m('div.select_input', {
//       key: formName + 'variant'
//     }, [
//       formWidgets.renderSelect('variant', formName + ' variant', variants, settingsObj.variant)
//     ])
//   ];


//   // Human only
//   if (settingsObj.mode) {
//     var modes = (session.isConnected()) ? [
//       ['casual', '0'],
//       ['rated', '1']
//     ] : [ ['casual', '0'] ];

//     generalFieldset.push(m('div.select_input', {
//       key: formName + 'mode'
//     }, [
//       formWidgets.renderSelect('mode', formName + 'mode', modes, settingsObj.mode)
//     ]));

//     if (session.isConnected() && settingsObj.mode() === '0') {
//       generalFieldset.push(
//         formWidgets.renderCheckbox(i18n('membersOnly'), 'membersOnly', settingsObj.membersOnly));
//     }
//   }

//   // both human
//   var roundFieldset = [
//     // m('div.select_input', {
//     //   key: formName + 'rounds'
//     // }, [
//     //   formWidgets.renderSelect('round', formName + 'rounds', roundModes, settingsObj.roundMode)
//     // ])
//   ];

//   if (true) {
//     roundFieldset.push(
//       m('div.select_input', {
//         key: formName + 'rounds'
//       }, [
//         formWidgets.renderSelect('rounds', formName + 'round',
//                                  settings.gameSetup.availableRounds, settingsObj.rounds, false)
//       ])
//     );
//   }

//   return m('form#new_game_form.game_form', {
//     onsubmit: function(e) {
//       e.preventDefault();
//       if (!settings.gameSetup.isRoundValid(settingsObj)) return;
//       newGameForm.close();
//       action();
//     }
//   }, [
//     m('fieldset', [
//     ]),
//     m('fieldset', generalFieldset),
//     m('fieldset#round', roundFieldset),
//     m('button[data-icon=E][type=submit].newGameButton', i18n('createAGame'))
//   ]);
// }

// newGameForm.view = function() {
//   function form() {
//     return renderForm(
//       'human',
//       seekHumanGame,
//       settings.gameSetup.human,
//       settings.gameSetup.human.availableVariants);
// };

//   return popupWidget(
//     'new_game_form_popup game_form_popup',
//     null,
//     form,
//     newGameForm.isOpen,
//     newGameForm.close
//   );
// };

// export default newGameForm;

},{"../backbutton":135,"../i18n":138,"../oyunkeyf/setup":142,"../router":144,"../session":146,"../settings":147,"../xhr":210,"./helper":156,"./lobby":160,"./shared/form":186,"./shared/popup":190,"mithril":114,"mithril/hyperscript":113}],174:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _playersCtrl = require('./playersCtrl');

var _playersCtrl2 = _interopRequireDefault(_playersCtrl);

var _playersView = require('./playersView');

var _playersView2 = _interopRequireDefault(_playersView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _playersCtrl2.default,
  view: _playersView2.default
};

},{"./playersCtrl":176,"./playersView":177}],175:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onlinePlayers = onlinePlayers;

var _http = require('../../http');

function onlinePlayers() {
  return (0, _http.request)('/player/online', {}, true);
}

},{"../../http":137}],176:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _playerXhr = require('./playerXhr');

var xhr = _interopRequireWildcard(_playerXhr);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  _socket2.default.createDefault();

  var players = _mithril2.default.prop([]);

  xhr.onlinePlayers().then(players, function (err) {
    return utils.handleXhrError(err);
  });

  return {
    players: players,
    goToProfile: function goToProfile(u) {
      _mithril2.default.route('/@/' + u);
    },

    onunload: function onunload() {}
  };
}

},{"../../socket":149,"../../utils":205,"./playerXhr":175,"mithril":114}],177:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _common = require('../shared/common');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function view(ctrl) {

  var headerCtrl = header.bind(null, ctrl);
  var bodyCtrl = body.bind(null, ctrl);

  return _layout2.default.free(headerCtrl, bodyCtrl, null);
}

function header(ctrl) {
  return (0, _helper2.default)(
    'nav',
    null,
    (0, _common.menuButton)(),
    (0, _helper2.default)(
      'h1',
      null,
      (0, _i18n2.default)('players')
    ),
    (0, _helper2.default)(
      'div',
      { className: 'buttons' },
      (0, _helper2.default)('button', { className: 'main_header_button', key: 'searchPlayers', 'data-icon': 'y' })
    )
  );
}

function body(ctrl) {
  return (0, _helper2.default)(
    'ul',
    { className: 'playersSuggestion native_scroller_page' },
    ctrl.players().map(renderPlayer)
  );
}

function renderPlayer(user) {
  // find best perf
  var perf = Object.keys(user.perfs).reduce(function (prev, curr) {
    if (!prev) return curr;
    if (user.perfs[prev].rating < user.perfs[curr].rating) return curr;else return prev;
  });

  return (0, _helper2.default)(
    'li',
    { className: 'list_item playerSuggestion nav', config: _helper2.default.ontouchY(function () {
        return _mithril2.default.route('/@/' + user.id);
      }) },
    (0, _common.userStatus)(user),
    (0, _helper2.default)(
      'span',
      { className: 'rating', 'data-icon': utils.gameIcon(perf) },
      user.perfs[perf].rating
    )
  );
}

},{"../../i18n":138,"../../utils":205,"../helper":156,"../layout":159,"../shared/common":185,"mithril":114,"mithril/hyperscript":113}],178:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _form = require('../shared/form');

var _form2 = _interopRequireDefault(_form);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  controller: function controller() {
    _socket2.default.createDefault();
  },
  view: function view() {
    var header = utils.partialf(_common.header, null, (0, _common.backButton)((0, _i18n2.default)('settings')));

    return _layout2.default.free(header, renderBody);
  }
};


function renderBody() {
  return (0, _mithril2.default)('div', {
    style: { width: '100%', height: '100%' }
  }, [(0, _mithril2.default)('ul.settings_list.general.native_scroller.page', [(0, _mithril2.default)('li.list_item.nav', {
    key: 'lang',
    config: _helper2.default.ontouchY(utils.f(_mithril2.default.route, '/settings/lang'))
  }, (0, _i18n2.default)('language')), (0, _mithril2.default)('li.list_item.settingsChoicesInline', {
    key: 'backgroundTheme'
  }, [(0, _mithril2.default)('label', (0, _i18n2.default)('background')), (0, _mithril2.default)('fieldset', [(0, _mithril2.default)('div.nice-radio', _form2.default.renderRadio((0, _i18n2.default)('dark'), 'bgTheme', 'dark', _settings2.default.general.theme.background() === 'dark', function (e) {
    _settings2.default.general.theme.background(e.target.value);
    _layout2.default.onBackgroundChange(e.target.value);
  })), (0, _mithril2.default)('div.nice-radio', _form2.default.renderRadio((0, _i18n2.default)('light'), 'bgTheme', 'light', _settings2.default.general.theme.background() === 'light', function (e) {
    _settings2.default.general.theme.background(e.target.value);
    _layout2.default.onBackgroundChange(e.target.value);
  }))])])]), window.oyunkeyf.version ? (0, _mithril2.default)('section.app_version', 'v' + window.oyunkeyf.version) : null]);
}

},{"../../i18n":138,"../../settings":147,"../../socket":149,"../../utils":205,"../helper":156,"../layout":159,"../shared/common":185,"../shared/form":186,"mithril":114}],179:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _form = require('../shared/form');

var _form2 = _interopRequireDefault(_form);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _xhr = require('../../xhr');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  controller: function controller() {
    var langs = _mithril2.default.prop([]);
    (0, _i18n.getAvailableLanguages)().then(langs);

    return {
      langs: langs
    };
  },
  view: function view(ctrl) {
    var header = utils.partialf(_common.header, null, (0, _common.backButton)((0, _i18n2.default)('language')));

    function renderLang(l) {
      return h(
        'li',
        { className: 'list_item' },
        _form2.default.renderRadio(l[1], 'lang', l[0], _settings2.default.general.lang() === l[0], function (e) {
          _settings2.default.general.lang(e.target.value);
          (0, _xhr.setServerLang)(e.target.value);
          (0, _i18n.loadFromSettings)();
        })
      );
    }

    function renderBody() {
      return h(
        'ul',
        { className: 'native_scroller page settings_list radio_list' },
        ctrl.langs().map(function (l) {
          return renderLang(l);
        })
      );
    }
    return _layout2.default.free(header, renderBody);
  }
};

},{"../../i18n":138,"../../settings":147,"../../utils":205,"../../xhr":210,"../layout":159,"../shared/common":185,"../shared/form":186,"mithril":114,"mithril/hyperscript":113}],180:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    var okeyground = vnode.attrs.okeyground;


    this.wrapperOnCreate = function (_ref) {
      var dom = _ref.dom;
    };

    this.boardOnCreate = function (_ref2) {
      var dom = _ref2.dom;

      okeyground.attach(dom);
    };

    this.boardOnRemove = function () {
      okeyground.detach();
    };
  },
  view: function view(vnode) {
    var bounds = vnode.attrs.bounds;


    var boardClass = ['display_board'].join(' ');

    var wrapperClass = 'game_board_wrapper';

    var wrapperStyle = bounds ? {
      height: bounds.height + 'px',
      width: bounds.width + 'px'
    } : {};

    return h(
      'section',
      { oncreate: this.wrapperOnCreate, className: wrapperClass, style: wrapperStyle },
      h('div', { className: boardClass,
        oncreate: this.boardOnCreate,
        onremove: this.boardOnRemove })
    );
  }
};

// function renderTopMenu() {
//   return (
//     <div class="display_menu">
//       {menuButton()}
//     </div>
//   );
// }

// function renderPlayerInfo(ctrl, player, position) {
//   const wrapperClass = helper.classSet({
//     'playerInfos': true,
//   }) + ` ${position}`;

//   const playerName = player.ai ?
//                      i18n('aiBot', player.ai) :
//                      utils.playerName(player);
//   const playerOnGame = (player.onGame || player.ai ?
//                         <span className="ongame yes" data-icon="3"/> :
//                         <span className="ongame no" data-icon="0"/>
//   );

//   const togglePopup = ctrl.toggleUserPopup.bind(ctrl, position, player.user);
//   const vConf = helper.ontouch(togglePopup);

//   const runningSide = ctrl.isClockRunning() ? ctrl.data.game.player : null;
//   const running = ctrl.data.game.player === player.side;

//   const opens = ctrl.data.game.oscores ? ctrl.data.game.oscores[player.side] : null;
//   const opensHint = opens ? (opens.series ? 'openedSeries' : 'openedPairs') : null;
//   const opensClass = "opens" + ((opens && opens.new) ? " new" : "");

//   return (
//     <div className={wrapperClass} config={vConf}>
//       <div class="wrap_info">
//         {opens ?
//          <div class={opensClass}>
//            {(opens.series ? opens.series : opens.pairs)}
//            {' '}
//            {i18n(opensHint).split(' ')[0]}
//          </div>: null
//         }
//       </div>
//       <div class="wrap_user">
//         <h2 className="playerUser">
//           {playerName}
//           {playerOnGame}
//         </h2>
//         { (ctrl.clock && running) ?
//           renderClock(ctrl.clock, player.side, runningSide, position) : null
//         }
//       </div>
//     </div>
//   );
// }

// export default function(
//   ctrl,
//   okeygroundCtrl,
//   bounds,
//   isPortrait,
//   wrapperClasses) {
//     const data = ctrl.data;

//     const boardClass = [
//       'display_board',
//     ].join(' ');

//     const key = 'board' + (isPortrait ? 'portrait' : 'landscape');
//     let wrapperClass = 'game_board_wrapper';

//     if (wrapperClasses) {
//       wrapperClass += ' ' + wrapperClasses;
//     }

//     const wrapperStyle = bounds ? {
//       height: bounds.height + 'px',
//       width: bounds.width + 'px'
//     } : {};


//     function wrapperConfig(el, isUpdate) {
//       if (!isUpdate) {
//       }
//     }

//     function boardConfig(el, isUpdate) {
//       if (!isUpdate) {
//         if (!bounds) {
//         }
//         okeyground.render(el, okeygroundCtrl);
//       }
//     }

//     okeygroundCtrl.data.topHooks = [
//       // renderTopMenu(),
//       renderPlayerInfo(ctrl, data.opponentUp, 'top'),
//       renderPlayerInfo(ctrl, data.opponentLeft, 'left'),
//       renderPlayerInfo(ctrl, data.player, 'bottom'),
//       renderPlayerInfo(ctrl, data.opponentRight, 'right')
//     ];


//     return (
//       <section className={wrapperClass} config={wrapperConfig}
//                style={wrapperStyle} key={key}>
//         <div className={boardClass} config={boardConfig} />
//       </section>
//     );
// }

},{"../../settings":147,"../../utils/redraw":207,"mithril/hyperscript":113}],181:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(_ref) {
    var attrs = _ref.attrs;


    var title = 'gameApi.title(data)';

    return (0, _hyperscript2.default)('div.main_header_title', {}, [(0, _hyperscript2.default)('h1.header-gameTitle', [(0, _hyperscript2.default)('span', title)])]);
  }
};

},{"mithril/hyperscript":113}],182:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    this.onTap = function (e) {
      var el = helper.getButton(e);
      var i = void 0;
      if (el && (i = el.dataset.index)) {
        attrs.onTabChange(Number(i));
      }
    };
  },
  view: function view(vnode) {
    var _vnode$attrs = vnode.attrs,
        buttons = _vnode$attrs.buttons,
        selectedIndex = _vnode$attrs.selectedIndex,
        noIndicator = _vnode$attrs.noIndicator,
        wrapperClass = _vnode$attrs.wrapperClass;


    var iWidth = 100 / buttons.length;
    var shift = selectedIndex * (iWidth * buttons.length);

    var indicatorStyle = {
      width: iWidth + '%',
      transform: 'translateX(' + shift + '%)'
    };

    var buttonStyle = {
      width: iWidth + '%'
    };

    function renderTab(b, i) {
      var className = ['tab-button', selectedIndex === i ? 'selected' : '', b.className].join(' ');
      return h(
        'button',
        { 'data-index': i, className: className, style: buttonStyle },
        b.label,
        b.chip !== undefined ? h(
          'span',
          { className: 'chip' },
          b.chip
        ) : null
      );
    }
    return h(
      'div',
      { className: 'tabs-navigation' + (wrapperClass ? ' ' + wrapperClass : ''),
        oncreate: helper.ontap(this.onTap) },
      buttons.map(renderTab),
      noIndicator ? null : h('div', { className: 'tabIndicator', style: 'indicatorStyle' })
    );
  }
};

},{"../helper":156,"mithril/hyperscript":113}],183:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _helper = require('../helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oncreate: function oncreate(_ref) {
    var attrs = _ref.attrs,
        dom = _ref.dom;
  },
  view: function view(_ref2) {
    var attrs = _ref2.attrs;

    var curIndex = attrs.selectedIndex;
    var vw = (0, _helper.viewportDim)().vw;
    var width = attrs.content.length * 100;
    var shift = -(curIndex * vw);

    var style = {
      width: width + 'vw',
      transform: 'translateX(' + shift + 'px)'
    };

    return (0, _hyperscript2.default)('div.tabs-view-wrapper', (0, _hyperscript2.default)('div.tabs-view', {
      style: style,
      className: attrs.className
    }, attrs.content.map(function (_, index) {
      return (0, _hyperscript2.default)('div.tab-content', {
        'data-index': index,
        className: curIndex === index ? 'current' : ''
      }, curIndex === index ? (0, _hyperscript2.default)(Tab, _extends({ index: index }, attrs)) : null);
    })));
  }
};


var Tab = {
  onbeforeupdate: function onbeforeupdate(_ref3, _ref4) {
    var attrs = _ref3.attrs;
    var oldattrs = _ref4.attrs;

    return attrs.content[attrs.index] !== oldattrs.content[oldattrs.index];
  },
  view: function view(_ref5) {
    var attrs = _ref5.attrs;

    return attrs.renderer(attrs.content[attrs.index], attrs.index);
  }
};

},{"../helper":156,"mithril/hyperscript":113}],184:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(_, args) {
    var boardClass = ['display_board', args.variant ? args.variant.key : ''].join(' ');

    function boardConf(el, isUpdate, context) {
      var config = makeConfig(args);
      if (context.ground) {
        context.ground.set(config);
      } else {
        // TODO try to avoid that
        if (!config.bounds) {
          // console.log('no board bounds');
          // config.bounds = el.getBoundingClientRect();
        }
        context.ground = (0, _okeygroundMobile2.default)(el, config);
      }
    }
    return h('div', { className: boardClass, config: boardConf });
  }
};


function makeConfig(args) {
  var fen = args.fen,
      orientation = args.orientation,
      bounds = args.bounds;

  var conf = {
    viewOnly: true,
    minimalDom: true,
    fen: fen
  };

  // if (bounds) conf.bounds = bounds;

  return conf;
}

},{"mithril/hyperscript":113,"okeyground-mobile":1}],185:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.menuButton = menuButton;
exports.headerBtns = headerBtns;
exports.dropShadowHeader = dropShadowHeader;
exports.connectingDropShadowHeader = connectingDropShadowHeader;
exports.backButton = backButton;
exports.gamesButton = gamesButton;
exports.header = header;
exports.viewOnlyBoardContent = viewOnlyBoardContent;
exports.empty = empty;
exports.userStatus = userStatus;

var _menu = require('../menu');

var menu = _interopRequireWildcard(_menu);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _gamesMenu = require('../gamesMenu');

var _gamesMenu2 = _interopRequireDefault(_gamesMenu);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _icons = require('./icons');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function menuButton() {
  return h('button.fa.fa-navicon.main_header_button.menu_button', {
    key: 'main-menu',
    oncreate: helper.ontap(menu.mainMenuCtrl.toggle)
  });
}

function headerBtns() {

  if (utils.hasNetwork() && _session2.default.isConnected()) {
    return h('div', { key: 'buttons', className: 'buttons' });
  } else {
    return h('div', { key: 'buttons', className: 'buttons' });
  }
}

function dropShadowHeader(title, leftButton) {

  return [h('nav', [leftButton ? leftButton : menuButton(), title ? h(
    'div',
    { className: 'main_header_title', key: 'title' },
    title
  ) : null, headerBtns()]), h('div.main_header_drop_shadow')];
}

function connectingDropShadowHeader(title) {
  return [h('nav', [menuButton(), h('div.main_header_title.reconnecting', {
    className: title ? 'withTitle' : '',
    key: 'connecting-title'
  }), title ? h('div.main_header_title', { key: 'title' }, title) : null, headerBtns()]), h('div.main_header_drop_shadow')];
}

function backButton(title) {
  return h('div.back_button', { key: 'default-history-backbutton' }, [h('button', { oncreate: helper.ontap(_router2.default.backHistory) }, _icons.backArrow), title !== undefined ? typeof title === 'string' ? h('div.main_header_title', title) : title : null]);
}

// export function menuButton() {
//   return (
//       <button key="main-menu" className="fa fa-navicon main_header_button menu_button" config={helper.ontouch(menu.toggle)}>
//     </button>
//   );
// }

// export function backButton(title) {
//   return (
//       <button key="default-history-backbutton" className="back_button main_header_button" config={helper.ontouch(utils.backHistory)}>
//       <span className="fa fa-arrow-left"/>
//       {title ? <div className="title">{title}</div> : null }
//     </button>
//   );
// }

function gamesButton() {
  var key = void 0,
      action = void 0;

  key = 'games-menu';

  if (_session2.default.nowPlaying().length) {
    key = 'games-menu';
    action = _gamesMenu2.default.open;
  } else {
    key = 'new-game-form';
    action = _newGameForm2.default.open;
  }

  var className = ['main_header_button', 'game_menu_button', !utils.hasNetwork() ? 'invisible' : ''].join(' ');

  var longAction = function longAction() {
    return window.plugins.toast.show(i18n('nbGamesInPlay', _session2.default.nowPlaying().length), 'short', 'top');
  };

  return h('button', { key: key, className: className, config: helper.ontouch(action, longAction) });
}

// export function headerBtns() {
//   return (
//     <div key="buttons" className="buttons">
//       {gamesButton()}
//     </div>
//   );
// }

function header(title, leftButton) {
  return h(
    'nav',
    null,
    leftButton ? leftButton : menuButton(),
    title ? h(
      'h1',
      { key: 'title' },
      title
    ) : null,
    headerBtns()
  );
}

function viewOnlyBoardContent() {
  var isPortrait = false;
  var _vw$vh = { vw: 10, vh: 10 },
      vw = _vw$vh.vw,
      vh = _vw$vh.vh;

  var boardStyle = isPortrait ? { width: vw + 'px', height: vw + 'px' } : {};
  var boardKey = 'viewonlyboard';
  var className = 'board_wrapper';
  var board = h(
    'section',
    { key: boardKey, className: className, style: boardStyle },
    m.component(ViewOnlyBoard)
  );
  return [board];
}

function empty() {
  return [];
}

function userStatus(user) {
  var status = user.online ? 'online' : 'offline';
  return h(
    'div',
    { className: 'user' },
    h('span', { className: 'userStatus ' + status, 'data-icon': 'r' }),
    user.username
  );
}

},{"../../router":144,"../../session":146,"../../utils":205,"../gamesMenu":153,"../helper":156,"../menu":171,"../newGameForm":173,"./icons":187,"mithril/hyperscript":113}],186:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  renderSelect: function renderSelect(label, name, options, settingsProp, isDisabled, onChangeCallback) {
    var prop = settingsProp();
    return [(0, _hyperscript2.default)('label', {
      'for': 'select_' + name
    }, (0, _i18n2.default)(label)), (0, _hyperscript2.default)('select', {
      id: 'select_' + name,
      disabled: isDisabled,
      onchange: function onchange(e) {
        var val = e.target.value;
        settingsProp(val);
        if (onChangeCallback) onChangeCallback(val);
        setTimeout(_redraw2.default, 10);
      }
    }, options.map(function (e) {
      return renderOption(e[0], e[1], prop, e[2], e[3]);
    }))];
  }
};


function renderOption(label, value, prop, labelArg, labelArg2) {
  var l = labelArg && labelArg2 ? (0, _i18n2.default)(label, labelArg, labelArg2) : labelArg ? (0, _i18n2.default)(label, labelArg) : (0, _i18n2.default)(label);
  return (0, _hyperscript2.default)('option', {
    key: value,
    value: value,
    selected: prop === value
  }, l);
}

// import i18n from '../../i18n';
// import m from 'mithril';

// function renderOption(label, value, storedValue, labelArg, labelArg2) {
//   return m('option', {
//     value: value,
//     selected: storedValue === value
//   }, i18n(label, labelArg, labelArg2));
// }

// export default {
//   renderRadio: function(label, name, value, checked, onchange) {
//     var id = name + '_' + value;
//     return [
//       m('input.radio[type=radio]', {
//         name,
//         id,
//         className: value,
//         value,
//         checked,
//         onchange
//       }),
//       m('label', {
//         'for': id
//       }, i18n(label))
//     ];
//   },

//   renderSelect: function(label, name, options, settingsProp, isDisabled, onChangeCallback) {
//     var storedValue = settingsProp();
//     return [
//       m('label', {
//         'for': 'select_' + name
//       }, i18n(label)),
//       m('select', {
//         id: 'select_' + name,
//         disabled: isDisabled,
//         config: function(el, isUpdate, context) {
//           if (!isUpdate) {
//             var onChange = function(e) {
//               settingsProp(e.target.value);
//               if (onChangeCallback) onChangeCallback(e.target.value);
//               setTimeout(function() {
//                 m.redraw();
//               }, 10);
//             };
//             el.addEventListener('change', onChange, false);
//             context.onunload = () => {
//               el.removeEventListener('change', onChange, false);
//             };
//           }
//         }
//       }, options.map(function(e) {
//         return renderOption(e[0], e[1], storedValue, e[2], e[3]);
//       }))
//     ];
//   },
//   renderCheckbox: function(label, name, settingsProp, callback, disabled) {
//     var isOn = settingsProp();
//     return m('div.check_container', {
//       className: disabled ? 'disabled': ''
//     }, [
//       m('label', {
//         'for': name
//       }, label),
//       m('input[type=checkbox]', {
//         name: name,
//         disabled,
//         checked: isOn,
//         onchange: function() {
//           const newVal = !isOn;
//           settingsProp(newVal);
//           if (callback) callback(newVal);
//         }
//       })
//     ]);
//   }
// };

},{"../../i18n":138,"../../utils/redraw":207,"../helper":156,"mithril/hyperscript":113}],187:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require("mithril/hyperscript");

var backArrow = exports.backArrow = h(
  "div",
  { className: "svg_icon" },
  h(
    "div",
    { className: "svg_icon_inner" },
    h(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24" },
      h("path", { d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" })
    )
  )
);

var closeIcon = exports.closeIcon = h(
  "div",
  { className: "svg_icon" },
  h(
    "div",
    { className: "svg_icon_inner" },
    h(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24" },
      h("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" })
    )
  )
);

},{"mithril/hyperscript":113}],188:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit() {},
  view: function view(_ref) {
    var attrs = _ref.attrs,
        children = _ref.children;
    var header = attrs.header;


    return (0, _hyperscript2.default)('main#page', {}, [
    // h('header.main_header.board', header),
    (0, _hyperscript2.default)('div.content_round', children)]);
  }
};

},{"mithril/hyperscript":113}],189:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (key, name, perf, user) {
  var options = { className: 'profilePerf', 'data-icon': (0, _utils.gameIcon)(key) };

  if (variantPerfAvailable(key, perf)) {
    options.className += ' nav';
    options.config = _helper2.default.ontouchY(goToVariantPerf(user, key));
  }

  return (0, _mithril2.default)('div', options, [(0, _mithril2.default)('span.name', name), (0, _mithril2.default)('div.rating', [perf.rating, _helper2.default.progress(perf.prog), (0, _mithril2.default)('span.nb', '/ ' + perf.games)])]);
};

var _utils = require('../../utils');

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function goToVariantPerf(user, key) {
  return function () {
    return _mithril2.default.route('/@/${user.id}/${key}/perf');
  };
}

function variantPerfAvailable(key, perf) {
  return perf.games > 0;
}

},{"../../utils":205,"../helper":156,"mithril":114}],190:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var h = require('mithril/hyperscript');

exports.default = popup;

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function popup(classes, headerF, contentF, isShowing, closef) {

  if (!isShowing) return null;

  var defaultClasses = {
    overlay_popup: true,
    native_scroller: true
  };

  var className = void 0;

  if ((typeof classes === 'undefined' ? 'undefined' : _typeof(classes)) === 'object') {
    className = helper.classSet(Object.assign({}, defaultClasses, classes));
  } else if (typeof classes === 'string') {
    className = helper.classSet(defaultClasses) + ' ' + classes;
  } else {
    throw new Error('First popup argument must be either a string or an object');
  }

  var contentClass = helper.classSet({
    'popup_content': true,
    'noheader': !headerF
  });

  return h(
    'div',
    { key: String(contentF), className: 'overlay_popup_wrapper fade-in',
      onbeforemove: function onbeforemove(vnode) {
        vnode.dom.classList.add('fading_out');
        return new Promise(function (resolve) {
          setTimeout(resolve, 500);
        });
      } },
    h('div', { className: 'popup_overlay_close',
      oncreate: closef ? helper.ontap(closef) : utils.noop }),
    h(
      'div',
      { className: className },
      headerF ? h(
        'header',
        null,
        headerF()
      ) : null,
      h(
        'div',
        { className: contentClass },
        contentF()
      )
    )
  );
}

// function styleConf(el) {
//   const vh = helper.viewportDim().vh;
//   const h = el.getBoundingClientRect().height;
//   const top = (vh - h) / 2;
//   // el.style.top = top + 'px';
// }

// export default function(classes, headerF, contentF, isShowing, closeF) {
//   if (!isShowing) return null;

//   const defaultClasses = {
//     overlay_popup: true,
//     native_scroller: true
//   };

//   let className;

//   if (typeof classes === 'object') {
//     className = helper.classSet(Object.assign({}, defaultClasses, classes));
//   } else if (typeof classes === 'string') {
//     className = helper.classSet(defaultClasses) + ' ' + classes;
//   } else
//     throw new Error('First popup argument must be either string or an object');

//   return (
//     <div className="overlay_popup_wrapper">
//       <div className="popup_overlay_close"
//            config={closeF ? helper.ontouch(helper.fadesOut(closeF, '.overlay_popup_wrapper')) : utils.noop } />
//       <div className={className} config={styleConf}>
//         {headerF ? <header>{headerF()}</header> : null }
//         <div className="popup_content">
//           {contentF()}
//         </div>
//       </div>
//     </div>
//   );
// }

},{"../../utils":205,"../helper":156,"mithril/hyperscript":113}],191:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = OnlineRound;

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _ground = require('./ground');

var _ground2 = _interopRequireDefault(_ground);

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _ClockCtrl = require('./clock/ClockCtrl');

var _ClockCtrl2 = _interopRequireDefault(_ClockCtrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function OnlineRound(id, cfg) {
  var _this = this;

  var setData = function setData(cfg) {
    _this.data = cfg;
  };

  this.id = id;
  setData(cfg);

  this.okeyground = _ground2.default.make(this.data, cfg.game.fen);

  this.clock = this.data.clock ? new _ClockCtrl2.default(this.data, {
    onFlag: this.outoftime
  }) : null;

  if (this.clock) {
    var tickNow = function tickNow() {
      _this.clock && _this.clock.tick();
      if (_game2.default.playable(_this.data)) _this.clockTimeoutId = setTimeout(tickNow, 100);
    };
    this.clockTimeoutId = setTimeout(tickNow, 100);
  }

  this.unload = function () {
    clearTimeout(_this.clockTimeoutId);
  };

  (0, _redraw2.default)();
}

},{"../../../oyunkeyf/game":140,"../../../utils/redraw":207,"./clock/ClockCtrl":192,"./ground":194}],192:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ClockCtrl;

var _game = require('../../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ClockCtrl(d, opts) {
  var _this = this;

  this.setClock = function (d, east, west, south, north) {
    var isClockRunning = _game2.default.playable(d) && (d.game.turns - d.game.startedAtTurn > -1 || d.clock && d.clock.running);

    _this.times = {
      east: east * 1000,
      west: west * 1000,
      north: north * 1000,
      south: south * 1000,
      activeSide: isClockRunning ? d.game.player : undefined,
      lastUpdate: performance.now()
    };
  };

  this.opts = opts;

  var cdata = d.clock;

  this.emergMs = cdata.emerg; // 1000 * Math.min(60, Math.max(10, cdata.emerg * .125));

  this.setClock(d, cdata.sides.east, cdata.sides.west, cdata.sides.south, cdata.sides.north);

  this.elements = {
    east: null,
    west: null,
    south: null,
    north: null
  };

  this.tick = function () {
    var side = _this.times.activeSide;
    if (!side) return;

    var now = performance.now();
    var millis = _this.times[side] - _this.elapsed(now);
    if (millis <= 0) _this.opts.onFlag();else _this.updateElement(side, millis);
  };

  this.updateElement = function (side, millis) {
    var el = _this.elements[side];
    if (el) {
      el.textContent = millis;
      if (millis < _this.emergMs) el.classList.add('emerg');else el.classList.remove('emerg');
    }
  };

  this.elapsed = function () {
    var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
    return Math.max(0, now - _this.times.lastUpdate);
  };

  this.millisOf = function (side) {
    return _this.times.activeSide === side ? Math.max(0, _this.times[side] - _this.elapsed()) : _this.times[side];
  };

  this.isRunning = function () {
    return _this.times.activeSide !== undefined;
  };
}

},{"../../../../oyunkeyf/game":140}],193:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;
    var ctrl = attrs.ctrl,
        side = attrs.side;


    this.clockOnCreate = function (_ref2) {
      var dom = _ref2.dom;

      ctrl.elements[side] = dom;
      ctrl.updateElement(side, ctrl.millisOf(side));
    };
    this.clockOnUpdate = function (_ref3) {
      var dom = _ref3.dom;

      ctrl.elements[side] = dom;
      ctrl.updateElement(side, ctrl.millisOf(side));
    };
  },
  view: function view(_ref4) {
    var attrs = _ref4.attrs;


    return (0, _hyperscript2.default)('div', { className: 'bar' }, [(0, _hyperscript2.default)('span', {
      className: 'bar2',
      oncreate: this.clockOnCreate,
      onupdate: this.clockOnUpdate
    })]);
  }
};

},{"mithril/hyperscript":113}],194:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function makeConfig(data, fen) {
  return {
    fen: fen,
    turnSide: data.game.player
  };
}

function make(data, fen) {
  var config = makeConfig(data, fen);

  return new _okeygroundMobile2.default(config);
}

exports.default = {
  make: make
};

},{"okeyground-mobile":1}],195:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = view;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _layout = require('../../../layout');

var _layout2 = _interopRequireDefault(_layout);

var _socket = require('../../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _player = require('../../../../oyunkeyf/player');

var playerApi = _interopRequireWildcard(_player);

var _Board = require('../../../shared/Board');

var _Board2 = _interopRequireDefault(_Board);

var _GameTitle = require('../../../shared/GameTitle');

var _GameTitle2 = _interopRequireDefault(_GameTitle);

var _clockView = require('../clock/clockView');

var _clockView2 = _interopRequireDefault(_clockView);

var _common = require('../../../shared/common');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function view(ctrl) {

  return _layout2.default.board(renderHeader(ctrl), renderContent(ctrl), overlay(ctrl));
}

function overlay(ctrl) {
  return [];
}

function renderHeader(ctrl) {
  var children = void 0;

  children = [(0, _common.menuButton)(), renderTitle(ctrl)];

  children.push((0, _common.headerBtns)());

  return (0, _hyperscript2.default)('nav', {
    className: _socket2.default.isConnected() ? '' : 'reconnecting'
  }, children);
}

function renderTitle(ctrl) {
  var data = ctrl.data;
  var masa = ctrl.data.masa;

  return (0, _hyperscript2.default)(_GameTitle2.default, {
    key: 'playing-title',
    data: ctrl.data
  });
}

function renderContent(ctrl) {
  var player = renderPlayTable(ctrl, ctrl.data.player, 'player');
  var opponentLeft = renderPlayTable(ctrl, ctrl.data.opponentLeft, 'opponentLeft');
  var opponentRight = renderPlayTable(ctrl, ctrl.data.opponentRight, 'opponentRight');
  var opponentUp = renderPlayTable(ctrl, ctrl.data.opponentUp, 'opponentUp');

  //  const bounds = helper.getBoardBounds(helper.viewportDim());

  var board = (0, _hyperscript2.default)(_Board2.default, {
    variant: ctrl.data.game.variant.key,
    okeyground: ctrl.okeyground
    //    bounds
  });

  return _hyperscript2.default.fragment({}, [renderMenuActionsBar(ctrl), player, opponentLeft, opponentRight, opponentUp, board]);
}

function renderMenuActionsBar(ctrl) {
  return (0, _hyperscript2.default)(
    'section',
    { className: 'menu_actions_bar' },
    (0, _common.backButton)()
  );
}

function renderPlayTable(ctrl, player, position) {

  var classN = 'playTable ' + position;

  return (0, _hyperscript2.default)(
    'section',
    { className: classN },
    renderAntagonistInfo(ctrl, player, position)
  );
}

function renderAntagonistInfo(ctrl, player, position) {
  // const runningSide = ctrl.isClockRunning() ? ctrl.data.game.player : undefined;
  var user = player.user;
  var playerName = playerApi.playerName(player);

  return (0, _hyperscript2.default)(
    'div',
    { className: 'antagonistInfos' },
    (0, _hyperscript2.default)(
      'h2',
      { className: 'antagonistUser' },
      (0, _hyperscript2.default)('span', { className: 'fa fa-circle status ' + (player.onGame ? 'ongame' : 'offgame') }),
      playerName
    ),
    renderClock(ctrl.clock, player.side)
  );
}

function renderClock(ctrl, side, runningSide) {
  return (0, _hyperscript2.default)(_clockView2.default, {
    ctrl: ctrl,
    side: side,
    runningSide: runningSide
  });
}

},{"../../../../i18n":138,"../../../../oyunkeyf/player":141,"../../../../socket":149,"../../../layout":159,"../../../shared/Board":180,"../../../shared/GameTitle":181,"../../../shared/common":185,"../clock/clockView":193,"mithril/hyperscript":113}],196:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SideMenuCtrl;

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _ = require('.');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SideMenuCtrl(side, menuID, backdropID, onOpen, onClose) {
  var _this = this;

  this.isOpen = false;

  this.side = side;
  this.menuID = menuID;
  this.backdropID = backdropID;
  this.onOpen = onOpen;
  this.onClose = onClose;

  this.open = function () {
    _this.isOpen = true;
    _router2.default.backbutton.stack.push(_this.close);
    var el = document.getElementById(_this.menuID);
    var bd = document.getElementById(_this.backdropID);
    if (_this.onOpen) _this.onOpen();
    return Promise.all([(0, _zanimo2.default)(bd, 'visibility', 'visible', 0), (0, _zanimo2.default)(bd, 'opacity', _.BACKDROP_OPACITY, 250, 'linear'), (0, _zanimo2.default)(el, 'visibility', 'visible', 0), (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out')]).then(_redraw2.default).catch(console.log.bind(console));
  };

  this.close = function (fromBB) {
    if (fromBB !== 'backbutton' && _this.isOpen) _router2.default.backbutton.stack.pop();
    _this.isOpen = false;
    var el = document.getElementById(_this.menuID);
    var bd = document.getElementById(_this.backdropID);
    if (_this.onClose) _this.onClose();
    return Promise.all([(0, _zanimo2.default)(bd, 'opacity', 0, 250, 'linear'), (0, _zanimo2.default)(el, 'transform', _this.closeTranslate(), 250, 'ease-out')]).then(function () {
      Promise.all([(0, _zanimo2.default)(el, 'visibility', 'hidden', 0), (0, _zanimo2.default)(bd, 'visibility', 'hidden', 0)]);
    }).catch(console.log.bind(console));
  };

  this.toggle = function () {
    if (_this.isOpen) _this.close();else _this.open();
  };

  this.closeTranslate = function () {
    return _this.side === 'left' ? 'translate3d(-100%,0,0)' : 'translate3d(100%,0,0)';
  };
};

},{".":197,"../../../router":144,"../../../utils/redraw":207,"zanimo":131}],197:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var BACKDROP_OPACITY = exports.BACKDROP_OPACITY = 0.7;

},{}],198:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _socket = require('../socket');

var _socket2 = _interopRequireDefault(_socket);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _loginModal = require('./loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _icons = require('./shared/icons');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;
var loading = false;

var formError = null;

exports.default = {
  open: open,
  close: close,
  view: function view() {
    if (!isOpen) return null;

    return (0, _hyperscript2.default)('div.modal#signupModal', { oncreate: helper.slidesInUp }, [(0, _hyperscript2.default)('header', [(0, _hyperscript2.default)('button.modal_close', {
      oncreate: helper.ontap(helper.slidesOutDown(close, 'signupModal'))
    }, _icons.closeIcon), (0, _hyperscript2.default)('h2', (0, _i18n2.default)('signUp'))]), (0, _hyperscript2.default)('div#signupModalContent.modal_content', {
      className: loading ? 'loading' : ''
    }, renderForm())]);
  }
};


function renderForm() {
  return [(0, _hyperscript2.default)('form.login', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      return submit(e.target);
    }
  }, [(0, _hyperscript2.default)('div.field', [formError && formError.username ? (0, _hyperscript2.default)('div.form-error', formError.username[0]) : null, (0, _hyperscript2.default)('input#pseudo[type=text]', {
    className: formError && formError.username ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('username'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: false,
    required: true,
    onfocus: scrollToTop
  })]), (0, _hyperscript2.default)('div.field', [formError && formError.email ? (0, _hyperscript2.default)('div.form-error', formError.email[0]) : null, (0, _hyperscript2.default)('input#email[type=email]', {
    onfocus: scrollToTop,
    className: formError && formError.email ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('email'),
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: false,
    required: true
  })]), (0, _hyperscript2.default)('div.field', [formError && formError.password ? (0, _hyperscript2.default)('div.form-error', formError.password[0]) : null, (0, _hyperscript2.default)('input#password[type=password]', {
    onfocus: scrollToTop,
    className: formError && formError.password ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('password'),
    required: true
  })]), (0, _hyperscript2.default)('div.submit', [(0, _hyperscript2.default)('button.submitButton[data-icon=F]', (0, _i18n2.default)('signUp'))])])];
}

function scrollToTop(e) {
  setTimeout(function () {
    var el = e.target;
    el.scrollIntoView(true);
  }, 300);
}

function submit(form) {
  var login = form[0].value.trim();
  var email = form[1].value.trim();
  var pass = form[2].value.trim();
  if (!login || !email || !pass) return;
  window.Keyboard.hide();
  loading = true;
  formError = null;
  (0, _redraw2.default)();
  _session2.default.signup(login, email, pass).then(function (d) {
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    _socket2.default.reconnectCurrent();
    (0, _redraw2.default)();
    _loginModal2.default.close();
    close();
  }).catch(function (error) {
    if (isSubmitError(error)) {
      loading = false;
      formError = error.body.error;
      (0, _redraw2.default)();
    } else {
      handleXhrError(error);
    }
  });
}

function isSubmitError(err) {
  return err.body.error !== undefined;
}

function open() {
  _router2.default.backbutton.stack.push(helper.slidesOutDown(close, 'signupModal'));
  formError = null;
  isOpen = true;
}

function close(fromBB) {
  window.Keyboard.hide();
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

// const signupModal = {};

// var isOpen = false;

// function submit(form) {
//   var login = form[0].value.trim();
//   var email = form[1].value.trim();
//   var pass = form[2].value.trim();
//   if (!login || !email || !pass) return false;
//   window.cordova.plugins.Keyboard.close();
//   return session.signup(login, email, pass).then(function() {
//     signupModal.close();
//     loginModal.close();
//     window.plugins.toast.show(i18n('loginSuccessfull'), 'short', 'center');
//   }, function(error) {
//     var data = error.response;
//     if (data.error.username) {
//       window.plugins.toast.show(data.error.username[0], 'short', 'center');
//     } else if (data.error.password) {
//       window.plugins.toast.show(data.error.password[0], 'short', 'center');
//     }
//   });
// }

// signupModal.open = function() {
//   backbutton.stack.push(helper.slidesOutDown(signupModal.close, 'signupModal'));
//   isOpen = true;
// };

// signupModal.close = function(fromBB) {
//   window.cordova.plugins.Keyboard.close();
//   if (fromBB !== 'backbutton' && isOpen) backbutton.stack.pop();
//   isOpen = false;
// };

// signupModal.view = function() {
//   if (!isOpen) return null;

//   return m('div.modal#signupModal', { config: helper.slidesInUp }, [
//     m('header', [
//       m('button.modal_close[data-icon=L]', {
//         config: helper.ontouch(helper.slidesOutDown(signupModal.close, 'signupModal'))
//       }),
//       m('h2', i18n('signUp'))
//     ]),
//     m('div.modal_content', [
//       m('p.signupWarning.withIcon[data-icon=!]', [
//         i18n('computersAreNotAllowedToPlay')
//       ]),
//       m('p.tosWarning', [
//         i18n('byRegisteringYouAgreeToBeBoundByOur'),
//         m('a', {
//         }, i18n('termsOfService')), '.'
//       ]),
//       m('form.login', {
//         onsubmit: function(e) {
//           e.preventDefault();
//           return submit(e.target);
//         }
//       }, [
//         m('input#pseudo[type=text]', {
//           placeholder: i18n('username'),
//           autocomplete: 'off',
//           autocapitalize: 'off',
//           autocorrect: 'off',
//           spellcheck: 'false',
//           required: true
//         }),
//         m('input#email[type=email]', {
//           placeholder: i18n('email'),
//           autocomplete: 'off',
//           autocapitalize: 'off',
//           autocorrect: 'off',
//           spellcheck: 'false',
//           required: true
//         }),
//         m('input#password[type=password]', {
//           placeholder: i18n('password'),
//           required: true
//         }),
//         m('button.fat', i18n('signUp'))
//       ])
//     ])
//   ]);
// };

// export default signupModal;

},{"../backbutton":135,"../i18n":138,"../router":144,"../session":146,"../socket":149,"../utils/redraw":207,"./helper":156,"./loginModal":161,"./shared/icons":187,"mithril/hyperscript":113}],199:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _userCtrl = require('./userCtrl');

var _userCtrl2 = _interopRequireDefault(_userCtrl);

var _userView = require('./userView');

var _userView2 = _interopRequireDefault(_userView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _userCtrl2.default,
  view: _userView2.default
};

},{"./userCtrl":200,"./userView":201}],200:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _userXhr = require('./userXhr');

var xhr = _interopRequireWildcard(_userXhr);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  _socket2.default.createDefault();

  var user = _mithril2.default.prop();

  xhr.user(_mithril2.default.route.param('id')).then(user, function (error) {
    utils.handleXhrError(error);
    _mithril2.default.route('/');
  }).then(_session2.default.refresh);

  return {
    user: user,
    isMe: function isMe() {
      return _session2.default.getUserId() === user().id;
    }
  };
}

},{"../../session":146,"../../socket":149,"../../utils":205,"../helper":156,"./userXhr":202,"mithril":114}],201:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _perf = require('../shared/perf');

var _perf2 = _interopRequireDefault(_perf);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import userPerfs from '../../oyunkeyf/perfs';
function view(ctrl) {
  var user = ctrl.user();

  if (!user) return null;

  function header() {
    var title = user.username;
    return (0, _common.header)(null, (0, _common.backButton)(title));
  }

  function profile() {
    // TODO
    // stats
    // ratings
    // actions
    return h(
      'div',
      { id: 'userProfile', className: 'native_scroller page' },
      renderStatus(user),
      renderProfile(user),
      renderRatings(user),
      renderActions(ctrl)
    );
  }

  return _layout2.default.free(header, profile);
}

function renderStatus(user) {
  var status = user.online ? 'online' : 'offline';
  return h(
    'section',
    { className: 'onlineStatus' },
    h('span', { className: 'userStatus ' + status, 'data-icon': 'r' }),
    (0, _i18n2.default)(status)
  );
}

function renderProfile(user) {
  if (!user.profile) return null;

  var fullName = '';
  if (user.profile.firstName) fullName += user.profile.firstName;
  if (user.profile.lastName) fullName += (user.profile.firstName ? ' ' : '') + user.profile.lastName;
  // const country = countries[user.profile.country];
  var location = user.profile.location;
  var memberSince = (0, _i18n2.default)('memberSince') + ' ' + window.moment(user.createdAt).format('LL');
  var seenAt = user.seenAt ? (0, _i18n2.default)('lastLogin') + ' ' + window.moment(user.seenAt).calendar() : null;

  return h(
    'section',
    { classname: 'profile' },
    fullName ? h(
      'h3',
      { className: 'fullname' },
      fullName
    ) : null,
    user.profile.bio ? h(
      'p',
      { className: 'profileBio' },
      user.profile.bio
    ) : null,
    h(
      'div',
      { className: 'userInfos' },
      user.language ? h(
        'p',
        { className: 'language withIcon' },
        h(
          'span',
          { className: 'fa fa-comment-o' },
          getLanguageNativeName(user.language)
        )
      ) : null,
      h(
        'p',
        { className: 'location' },
        location
      ),
      h(
        'p',
        { className: 'memberSince' },
        memberSince
      ),
      seenAt ? h(
        'p',
        { className: 'lastSeen' },
        seenAt
      ) : null
    )
  );
}

function renderRatings(user) {
  function isShowing(p) {
    return ['yuzbir', 'duzokey'].indexOf(p.key) !== -1 || p.perf.games > 0;
  }

  return h(
    'section',
    { id: 'userProfileRatings', className: 'perfs' },
    '// ',
    userPerfs(user).filter(isShowing).map(function (p) {
      return (0, _perf2.default)(p.key, p.name, p.perf, user);
    })
  );
}

function renderActions(ctrl) {
  var user = ctrl.user();
  return h(
    'section',
    { id: 'userProfileActions', 'class': 'noPadding' },
    h(
      'div',
      { className: 'list_item_nav',
        config: _helper2.default.ontouchY(ctrl.goToGames),
        key: 'view_all_games' },
      (0, _i18n2.default)('viewAllNbGames', user.count.all)
    )
  );
}

},{"../../i18n":138,"../../session":146,"../helper":156,"../layout":159,"../shared/common":185,"../shared/perf":189,"mithril/hyperscript":113}],202:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.user = user;

var _http = require('../../http');

function user(id) {
  var url = '/api/user/' + id;
  return (0, _http.request)(url, {}, true);
}

},{"../../http":137}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForeground = isForeground;
exports.setForeground = setForeground;
exports.setBackground = setBackground;
var foreground = true;

function isForeground() {
  return foreground;
}

function setForeground() {
  foreground = true;
}

function setBackground() {
  foreground = false;
}

},{}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.batchRequestAnimationFrame = batchRequestAnimationFrame;
var callbacks = new Set();
var batching = false;

function batchRequestAnimationFrame(callback) {
  callbacks.add(callback);
  if (!batching) {
    batching = true;
    requestAnimationFrame(function (ts) {
      var batch = callbacks;
      batching = false;
      callbacks = new Set();
      batch.forEach(function (f) {
        return f(ts);
      });
    });
  }
}

},{}],205:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.oyunkeyfSri = undefined;
exports.autoredraw = autoredraw;
exports.noop = noop;
exports.handleXhrError = handleXhrError;
exports.loadLocalJsonFile = loadLocalJsonFile;
exports.currentSri = currentSri;
exports.newSri = newSri;
exports.tellWorker = tellWorker;
exports.askWorker = askWorker;
exports.hasNetwork = hasNetwork;
exports.partialf = partialf;
exports.f = f;
exports.playerName = playerName;
exports.aiName = aiName;
exports.backHistory = backHistory;
exports.setViewSlideDirection = setViewSlideDirection;
exports.getViewSlideDirection = getViewSlideDirection;
exports.getBoardBounds = getBoardBounds;
exports.gameIcon = gameIcon;
exports.formatMasaDuration = formatMasaDuration;
exports.pad = pad;
exports.capitalize = capitalize;
exports.safeStringToNum = safeStringToNum;

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _redraw = require('./redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function autoredraw(action) {
  var res = action();
  (0, _redraw2.default)();
  return res;
}

function noop() {}

function handleXhrError(error) {
  var status = error.status;
  var data = error.body;
  var message = void 0;

  if (!status || status === 0) {
    message = 'oyunkeyfIsUnreachable';
  } else if (status === 401) {
    message = 'unauthorizedError';
  } else if (status === 404) {
    message = 'resourceNotFoundError';
  } else if (status === 503) {
    message = 'oyunkeyfIsUnavailableError';
  } else {
    message = 'Error.';
  }

  message = (0, _i18n2.default)(message);

  if (typeof data === 'string') {
    message += ' ' + data;
  } else if (typeof data.error === 'string') {
    message += ' ' + (0, _i18n2.default)(data.global[0]);
  }
  window.plugins.toast.show(message, 'short', 'center');
}

function loadLocalJsonFile(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.overrideMimeType('application/json');
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 0 || xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject(xhr);
        }
      }
    };
    xhr.send(null);
  });
}

var sri = void 0;

function currentSri() {
  return sri || newSri();
}

function newSri() {
  sri = Math.random().toString(36).substring(2).slice(0, 10);
  return sri;
}

var oyunkeyfSri = exports.oyunkeyfSri = Math.random().toString(36).substring(2);

function tellWorker(worker, topic, payload) {
  if (payload !== undefined) {
    worker.postMessage({ topic: topic, payload: payload });
  } else {
    worker.postMessage({ topic: topic });
  }
}

function askWorker(worker, msg, callback) {
  return new Promise(function (resolve) {
    function listen(e) {
      if (e.data.topic === msg.topic) {
        worker.removeEventListener('message', listen);
        if (callback) {
          callback(e.data.payload);
        } else {
          resolve(e.data.payload);
        }
      }
    }
    worker.addEventListener('message', listen);
    worker.postMessage(msg);
  });
}

function hasNetwork() {
  return window.navigator.connection.type !== Connection.NONE;
}

// export function handleXhrError(error) {
//   var {response: data, status} = error;
//   if (!hasNetwork()) {
//     window.plugins.toast.show(i18n('noInternetConnection'), 'short', 'center');
//   } else {
//     let message;
//     if (!status || status === 0) {
//       message = 'oyunkeyfIsUnreachable';
//     } else if (status === 401) {
//       message = 'unauthorizedError';
//     } else if (status === 404) {
//       message = 'resourceNotFoundError';
//     } else if (status === 503) {
//       message = 'oyunkeyfIsUnavailableError';
//     } else if (status >= 500) {
//       message = 'serverError';
//     } else {
//       message = 'Error.';
//     }

//     message = i18n(message);

//     if (typeof data === 'string') {
//       message += ` ${data}`;
//     } else if (data.global && data.global.constructor === Array) {
//       message += ` ${data.global[0]}`;
//     } else if (typeof data.error === 'string') {
//       message += ` ${data.error}`;
//     }

//     window.plugins.toast.show(message, 'short', 'center');
//   }
// }

function partialApply(fn, args) {
  return fn.bind.apply(fn, [null].concat(args));
}

function partialf() {
  return partialApply(arguments[0], Array.prototype.slice.call(arguments, 1));
}

function f() {
  var args = arguments,
      fn = arguments[0];
  return function () {
    fn.apply(fn, Array.prototype.slice.call(args, 1));
  };
}

function playerName(player, withRating) {
  if (player.username || player.user) {
    var name = player.username || player.user.username;
    return name;
  }
  if (player.ai) {
    return aiName(player.ai);
  }

  if (player.side) {
    return (0, _i18n2.default)(player.side);
  }

  return (0, _i18n2.default)('anonymous');
}

function aiName(level) {
  return (0, _i18n2.default)('aiBot', level);
}

function backHistory() {
  setViewSlideDirection('bwd');
  if (window.navigator.app && window.navigator.app.backHistory) {
    window.navigator.app.backHistory();
  } else window.history.go(-1);
}

// simple way to determine views animation direction
var viewSlideDirection = 'fwd';
function setViewSlideDirection(d) {
  viewSlideDirection = d;
}
function getViewSlideDirection() {
  return viewSlideDirection;
}

function getBoardBounds(viewportDim, isPortrait, isIpadLike, mode) {
  var vh = viewportDim.vh,
      vw = viewportDim.vw;

  var top = 50;

  if (isPortrait) {
    // const contentHeight = vh - 50;
    // const pTop = 50 + (mode === 'game' ? ((contentHeight - vw - 40) / 2) : 0);
    var contentHeight = vh;
    var pTop = 0;
    return {
      top: pTop,
      right: vw,
      bottom: pTop + vw,
      left: 0,
      width: vw,
      height: vw
    };
  } else {
    // const lSide = vh - top;
    var lSide = vh - 5;
    var lWidth = vw - 5; // lSide * (4/3);
    var spaceCenter = vw - lWidth;
    return {
      top: top,
      right: lSide,
      bottom: top + lSide,
      left: spaceCenter / 2,
      width: lWidth,
      height: lSide
    };
  }
}

// export function autoredraw(action) {
//   m.startComputation();
//   try {
//     return action();
//   } finally {
//     m.endComputation();
//   }
// }

var perfIconsMap = {
  yuzbir: 'T',
  duzokey: '+'
};

function gameIcon(perf) {
  return perfIconsMap[perf] || '8';
}

function formatMasaDuration(rounds, scores) {
  return rounds ? rounds + (0, _i18n2.default)('hands') : scores + (0, _i18n2.default)('scores')[0];
}

function pad(num, size) {
  var s = num + '';
  while (s.length < size) {
    s = '0' + s;
  }return s;
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function safeStringToNum(s) {
  var n = Number(s);
  return isNaN(n) ? undefined : n;
}

},{"../i18n":138,"./redraw":207}],206:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.buildQueryString = buildQueryString;
// from https://github.com/Gozala/querystring

function stringifyPrimitive(v) {
  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
}

function buildQueryString(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}

},{}],207:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.redrawSync = undefined;
exports.default = redraw;

var _signals = require('../signals');

var _signals2 = _interopRequireDefault(_signals);

var _batchRAF = require('./batchRAF');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var redrawSync = exports.redrawSync = _signals2.default.redraw.dispatch;

function redraw() {
  // console.trace();
  (0, _batchRAF.batchRequestAnimationFrame)(redrawSync);
}

},{"../signals":148,"./batchRAF":204}],208:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keepAwake = keepAwake;
exports.allowSleepAgain = allowSleepAgain;
var IDLE_TIMER_DELAY = 15 * 60 * 1000;
var SLEEP_DELAY = 60 * 60 * 1000;

var sleepAgainTimeoutId = void 0;
var cancelTimer = void 0;

function keepAwake() {
  window.plugins.insomnia.keepAwake();
  if (cancelTimer !== undefined) {
    cancelTimer();
  }
  cancelTimer = idleTimer(IDLE_TIMER_DELAY, function () {
    sleepAgainTimeoutId = setTimeout(function () {
      window.plugins.insomnia.allowSleepAgain();
    }, SLEEP_DELAY);
  }, function () {
    clearTimeout(sleepAgainTimeoutId);
  });
}

function allowSleepAgain() {
  if (cancelTimer !== undefined) {
    cancelTimer();
    cancelTimer = undefined;
  }
  window.plugins.insomnia.allowSleepAgain();
}

function idleTimer(delay, onIdle, onWakeUp) {
  var events = ['touchstart'];
  var listening = false;
  var active = true;
  var lastSeenActive = Date.now();
  var intervalID = void 0;
  var onActivity = function onActivity() {
    if (!active) {
      // console.log('Wake up')
      onWakeUp();
    }
    active = true;
    lastSeenActive = Date.now();
    stopListening();
  };
  var startListening = function startListening() {
    if (!listening) {
      events.forEach(function (e) {
        document.addEventListener(e, onActivity);
      });
      listening = true;
    }
  };
  var stopListening = function stopListening() {
    if (listening) {
      events.forEach(function (e) {
        document.removeEventListener(e, onActivity);
      });
      listening = false;
    }
  };
  var cancel = function cancel() {
    clearInterval(intervalID);
    stopListening();
  };
  intervalID = setInterval(function () {
    if (active && Date.now() - lastSeenActive > delay) {
      // console.log('Idle mode')
      onIdle();
      active = false;
    }
    startListening();
  }, 30 * 1000);

  return cancel;
}

},{}],209:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tellWorker = tellWorker;
exports.askWorker = askWorker;
function tellWorker(worker, topic, payload) {
  if (payload !== undefined) {
    worker.postMessage({ topic: topic, payload: payload });
  } else {
    worker.postMessage({ topic: topic });
  }
}

function askWorker(worker, msg) {
  return new Promise(function (resolve, reject) {
    function listen(e) {
      if (e.data.topic === msg.topic && (msg.reqid === undefined || e.data.reqid === msg.reqid)) {
        worker.removeEventListener('message', listen);
        resolve(e.data.payload);
      } else if (e.data.topic === 'error' && e.data.payload.callerTopic === msg.topic && (msg.reqid === undefined || e.data.reqid === msg.reqid)) {
        worker.removeEventListener('message', listen);
        reject(e.data.payload.error);
      }
    }
    worker.addEventListener('message', listen);
    worker.postMessage(msg);
  });
}

},{}],210:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.game = game;
exports.seekGame = seekGame;
exports.setServerLang = setServerLang;

var _http = require('./http');

var _utils = require('./utils');

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// export let cachedPools = [];

// export function newGame() {
//   const config = settings.gameSetup.human;

//   const data = {
//     variant: config.variant(),
//     rounds: config.rounds(),
//     mode: session.isConnected() ? config.mode() : '0',
//     membersOnly: session.isConnected() ? config.membersOnly() : false
//   };

//   return request('/masa/new', {
//     method: 'POST',
//     data
//   }, true);
// }

// export function lobby(feedback) {
//   return request('/', null, feedback);
// }

// export function game(id, background) {
//   var url = '/' + id;
//   return request(url, { background }, true);
// }

function game(id) {
  var url = '/' + id;
  return (0, _http.fetchJSON)(url);
}

function seekGame(setup) {
  var rest = _objectWithoutProperties(setup, []);

  var body = void 0;

  body = JSON.stringify(_extends({}, rest));

  return (0, _http.fetchJSON)('/masa/new', {
    method: 'POST',
    body: body
  }, true);
}

function setServerLang(lang) {
  if (_session2.default.isConnected()) {
    // return request('/translation/select', {
    //   method: 'POST',
    //   data: { lang }
    // });
    return Promise.resolve();
  } else {
    return Promise.resolve();
  }
}

},{"./http":137,"./session":146,"./settings":147,"./utils":205}]},{},[139])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9va2V5Z3JvdW5kLW1vYmlsZS9idWlsZC9ub2RlX21vZHVsZXMvb2tleWdyb3VuZC1tb2JpbGUvYnVpbGQvb2tleWdyb3VuZC5taW4uanMiLCJub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLW5hbWUvaW5kZXguanNvbiIsIm5vZGVfbW9kdWxlcy9jb2xvci1zdHJpbmcvY29sb3Itc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yL2NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2lzY3JvbGwvYnVpbGQvaXNjcm9sbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVSYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJvdW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbWVyZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvcmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdGhyb3R0bGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvRmluaXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL2h5cGVyc2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvbWl0aHJpbC5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci9mcmFnbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci9oeXBlcnNjcmlwdC5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvdHJ1c3QuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvdm5vZGUuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9zdHJlYW0vc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3EvcS5qcyIsIm5vZGVfbW9kdWxlcy9xYW5pbWF0aW9uZnJhbWUvc3JjL3FhbmltYXRpb25mcmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9ybGl0ZS1yb3V0ZXIvcmxpdGUuanMiLCJub2RlX21vZHVsZXMvc2lnbmFscy9kaXN0L3NpZ25hbHMuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy92ZW5kb3ItcHJlZml4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3phbmltby9zcmMvWmFuaW1vLmpzIiwibm9kZV9tb2R1bGVzL3phbmltby9zcmMvbm9ybWFsaXplLXRpbWluZy1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy96YW5pbW8vc3JjL25vcm1hbGl6ZS10cmFuc2Zvcm0tdmFsdWUuanMiLCJub2RlX21vZHVsZXMvemFuaW1vL3NyYy90cmFuc2l0aW9uLXNob3J0aGFuZC1wcm9wZXJ0eS5qcyIsInNyYy9iYWNrYnV0dG9uLmpzIiwic3JjL2NvbmZpZy5qcyIsInNyYy9odHRwLmpzIiwic3JjL2kxOG4uanMiLCJzcmMvbWFpbi5qcyIsInNyYy9veXVua2V5Zi9nYW1lLmpzIiwic3JjL295dW5rZXlmL3BsYXllci5qcyIsInNyYy9veXVua2V5Zi9zZXR1cC5qcyIsInNyYy9veXVua2V5Zi9zdGF0dXMuanMiLCJzcmMvcm91dGVyLmpzIiwic3JjL3JvdXRlcy5qcyIsInNyYy9zZXNzaW9uLmpzIiwic3JjL3NldHRpbmdzLmpzIiwic3JjL3NpZ25hbHMuanMiLCJzcmMvc29ja2V0LmpzIiwic3JjL3NwaW5uZXIuanMiLCJzcmMvc3RvcmFnZS5qcyIsInNyYy91aS9nYW1lL2luZGV4LmpzIiwic3JjL3VpL2dhbWVzTWVudS5qcyIsInNyYy91aS9oZWxwZXIvYW5pbWF0b3IuanMiLCJzcmMvdWkvaGVscGVyL2J1dHRvbi5qcyIsInNyYy91aS9oZWxwZXIvaW5kZXguanMiLCJzcmMvdWkvaG9tZS9ob21lVmlldy5qcyIsInNyYy91aS9ob21lL2luZGV4LmpzIiwic3JjL3VpL2xheW91dC5qcyIsInNyYy91aS9sb2JieS5qcyIsInNyYy91aS9sb2dpbk1vZGFsLmpzIiwic3JjL3VpL21hc2EvTWFzYXNMaXN0Q3RybC5qcyIsInNyYy91aS9tYXNhL2RldGFpbC9NYXNhQ3RybC5qcyIsInNyYy91aS9tYXNhL2RldGFpbC9pbmRleC5qcyIsInNyYy91aS9tYXNhL2RldGFpbC9tYXNhVmlldy5qcyIsInNyYy91aS9tYXNhL2RldGFpbC9zb2NrZXRIYW5kbGVyLmpzIiwic3JjL3VpL21hc2EvZmFxLmpzIiwic3JjL3VpL21hc2EvaW5kZXguanMiLCJzcmMvdWkvbWFzYS9tYXNhWGhyLmpzIiwic3JjL3VpL21hc2EvbWFzYXNMaXN0Vmlldy5qcyIsInNyYy91aS9tZW51L2luZGV4LmpzIiwic3JjL3VpL21lbnUvbWVudVZpZXcuanMiLCJzcmMvdWkvbmV3R2FtZUZvcm0uanMiLCJzcmMvdWkvcGxheWVycy9pbmRleC5qcyIsInNyYy91aS9wbGF5ZXJzL3BsYXllclhoci5qcyIsInNyYy91aS9wbGF5ZXJzL3BsYXllcnNDdHJsLmpzIiwic3JjL3VpL3BsYXllcnMvcGxheWVyc1ZpZXcuanMiLCJzcmMvdWkvc2V0dGluZ3MvaW5kZXguanMiLCJzcmMvdWkvc2V0dGluZ3MvbGFuZy5qc3giLCJzcmMvdWkvc2hhcmVkL0JvYXJkLmpzIiwic3JjL3VpL3NoYXJlZC9HYW1lVGl0bGUuanMiLCJzcmMvdWkvc2hhcmVkL1RhYk5hdmlnYXRpb24uanMiLCJzcmMvdWkvc2hhcmVkL1RhYlZpZXcuanMiLCJzcmMvdWkvc2hhcmVkL1ZpZXdPbmx5Qm9hcmQuanMiLCJzcmMvdWkvc2hhcmVkL2NvbW1vbi5qcyIsInNyYy91aS9zaGFyZWQvZm9ybS5qcyIsInNyYy91aS9zaGFyZWQvaWNvbnMuanMiLCJzcmMvdWkvc2hhcmVkL2xheW91dC9NYWluQm9hcmQuanMiLCJzcmMvdWkvc2hhcmVkL3BlcmYuanMiLCJzcmMvdWkvc2hhcmVkL3BvcHVwLmpzIiwic3JjL3VpL3NoYXJlZC9yb3VuZC9PbmxpbmVSb3VuZC5qcyIsInNyYy91aS9zaGFyZWQvcm91bmQvY2xvY2svQ2xvY2tDdHJsLmpzIiwic3JjL3VpL3NoYXJlZC9yb3VuZC9jbG9jay9jbG9ja1ZpZXcuanMiLCJzcmMvdWkvc2hhcmVkL3JvdW5kL2dyb3VuZC5qcyIsInNyYy91aS9zaGFyZWQvcm91bmQvdmlldy9yb3VuZFZpZXcuanMiLCJzcmMvdWkvc2hhcmVkL3NpZGVNZW51L1NpZGVNZW51Q3RybC5qcyIsInNyYy91aS9zaGFyZWQvc2lkZU1lbnUvaW5kZXguanMiLCJzcmMvdWkvc2lnbnVwTW9kYWwuanMiLCJzcmMvdWkvdXNlci9pbmRleC5qcyIsInNyYy91aS91c2VyL3VzZXJDdHJsLmpzIiwic3JjL3VpL3VzZXIvdXNlclZpZXcuanMiLCJzcmMvdWkvdXNlci91c2VyWGhyLmpzIiwic3JjL3V0aWxzL2FwcE1vZGUuanMiLCJzcmMvdXRpbHMvYmF0Y2hSQUYuanMiLCJzcmMvdXRpbHMvaW5kZXguanMiLCJzcmMvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJzcmMvdXRpbHMvcmVkcmF3LmpzIiwic3JjL3V0aWxzL3NsZWVwLmpzIiwic3JjL3V0aWxzL3dvcmtlci5qcyIsInNyYy94aHIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNpRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeHVDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzEvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2o1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFlLEtBQXRCO0FBQ0Q7QUFDRjtBQUNELFdBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsTUFBbkM7QUFDQSxXQUFPLFdBQVAsQ0FBbUIsR0FBbkI7QUFDRCxHQWJNLENBQVA7QUFjRDs7Ozs7Ozs7Ozs7UUNTZSxJLEdBQUEsSTtRQUtBLFEsR0FBQSxRO1FBYUEsYSxHQUFBLGE7O0FBbERoQjs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7OztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsSUFBVCxDQUFjLEVBQWQsRUFBa0I7QUFDdkIsTUFBSSxNQUFNLE1BQU0sRUFBaEI7QUFDQSxTQUFPLHFCQUFVLEdBQVYsQ0FBUDtBQUNEOztBQUVNLFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QjtBQUFBLE1BQ25CLElBRG1CLDRCQUNWLEtBRFU7O0FBRzlCLE1BQUksYUFBSjs7QUFFQSxTQUFPLEtBQUssU0FBTCxjQUFvQixJQUFwQixFQUFQOztBQUVBLFNBQU8scUJBQVUsV0FBVixFQUF1QjtBQUM1QixZQUFRLE1BRG9CO0FBRTVCO0FBRjRCLEdBQXZCLEVBR0osSUFISSxDQUFQO0FBSUQ7O0FBRU0sU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCO0FBQ2xDLE1BQUksa0JBQVEsV0FBUixFQUFKLEVBQTJCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBTyxRQUFRLE9BQVIsRUFBUDtBQUNELEdBTkQsTUFNTztBQUNMLFdBQU8sUUFBUSxPQUFSLEVBQVA7QUFDRDtBQUNGIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgdDt0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyx0Lk9rZXlncm91bmQ9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBhKGksdSl7aWYoIW5baV0pe2lmKCF0W2ldKXt2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCF1JiZsKXJldHVybiBsKGksITApO2lmKG8pcmV0dXJuIG8oaSwhMCk7dmFyIGQ9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBkLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZH12YXIgcz1uW2ldPXtleHBvcnRzOnt9fTt0W2ldWzBdLmNhbGwocy5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbaV1bMV1bZV07cmV0dXJuIGEobnx8ZSl9LHMscy5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciBvPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8ci5sZW5ndGg7aSsrKWEocltpXSk7cmV0dXJuIGF9cmV0dXJuIGV9KCkoezE6W2Z1bmN0aW9uKGUsdCxuKXshZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe2lmKFwib2JqZWN0XCIhPT1hKGUpKXJldHVybiB0O2Zvcih2YXIgciBpbiB0KVwib2JqZWN0XCI9PT1hKGVbcl0pJiZcIm9iamVjdFwiPT09YSh0W3JdKT9lW3JdPW4oZVtyXSx0W3JdKTplW3JdPXRbcl07cmV0dXJuIGV9ZnVuY3Rpb24gcihlLHQscil7dmFyIGk9clswXSx1PXIubGVuZ3RoOyhlfHxcIm9iamVjdFwiIT09YShpKSkmJihpPXt9KTtmb3IodmFyIGw9MDtsPHU7KytsKXt2YXIgZD1yW2xdLHM9YShkKTtpZihcIm9iamVjdFwiPT09cylmb3IodmFyIGMgaW4gZClpZihcIl9fcHJvdG9fX1wiIT09Yyl7dmFyIGY9ZT9vLmNsb25lKGRbY10pOmRbY107dD9pW2NdPW4oaVtjXSxmKTppW2NdPWZ9fXJldHVybiBpfWZ1bmN0aW9uIGEoZSl7cmV0dXJue30udG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKS50b0xvd2VyQ2FzZSgpfXZhciBvPWZ1bmN0aW9uKGUpe3JldHVybiByKGU9PT0hMCwhMSxhcmd1bWVudHMpfSxpPVwibWVyZ2VcIjtvLnJlY3Vyc2l2ZT1mdW5jdGlvbihlKXtyZXR1cm4gcihlPT09ITAsITAsYXJndW1lbnRzKX0sby5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdCxuLHI9ZSxpPWEoZSk7aWYoXCJhcnJheVwiPT09aSlmb3Iocj1bXSxuPWUubGVuZ3RoLHQ9MDt0PG47Kyt0KXJbdF09by5jbG9uZShlW3RdKTtlbHNlIGlmKFwib2JqZWN0XCI9PT1pKXtyPXt9O2Zvcih0IGluIGUpclt0XT1vLmNsb25lKGVbdF0pfXJldHVybiByfSxlP3QuZXhwb3J0cz1vOndpbmRvd1tpXT1vfShcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmXCJvYmplY3RcIj09dHlwZW9mIHQuZXhwb3J0cyYmdC5leHBvcnRzKX0se31dLDI6W2Z1bmN0aW9uKHQsbixyKXshZnVuY3Rpb24odCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT1yKHQpO1widW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cmJmEuZGVwcyh7ZG9jdW1lbnQ6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P2RvY3VtZW50Ont9LGxvY2F0aW9uOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBsb2NhdGlvbj9sb2NhdGlvbjp7fSxjbGVhclRpbWVvdXQ6Y2xlYXJUaW1lb3V0LHNldFRpbWVvdXQ6c2V0VGltZW91dH0pLFwib2JqZWN0XCI9PXR5cGVvZiBuJiZudWxsIT1uJiZuLmV4cG9ydHM/bi5leHBvcnRzPWE6XCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZS5hbWQ/ZShmdW5jdGlvbigpe3JldHVybiBhfSk6dC5tPWF9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnRoaXMsZnVuY3Rpb24gYShlLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZX1mdW5jdGlvbiByKGUpe3JldHVyblwiW29iamVjdCBPYmplY3RdXCI9PT1EZS5jYWxsKGUpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuXCJbb2JqZWN0IFN0cmluZ11cIj09PURlLmNhbGwoZSl9ZnVuY3Rpb24gaSgpe31mdW5jdGlvbiB1KGUpe3hlPWUuZG9jdW1lbnQsU2U9ZS5sb2NhdGlvbixNZT1lLmNhbmNlbEFuaW1hdGlvbkZyYW1lfHxlLmNsZWFyVGltZW91dCxFZT1lLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZS5zZXRUaW1lb3V0fWZ1bmN0aW9uIGwoZSx0KXtmb3IodmFyIG4scj1bXSxhPS8oPzooXnwjfFxcLikoW14jXFwuXFxbXFxdXSspKXwoXFxbKC4rPykoPzpcXHMqPVxccyooXCJ8J3wpKCg/OlxcXFxbXCInXFxdXXwuKSo/KVxcNSk/XFxdKS9nO249YS5leGVjKHQpOylpZihcIlwiPT09blsxXSYmblsyXSllLnRhZz1uWzJdO2Vsc2UgaWYoXCIjXCI9PT1uWzFdKWUuYXR0cnMuaWQ9blsyXTtlbHNlIGlmKFwiLlwiPT09blsxXSlyLnB1c2goblsyXSk7ZWxzZSBpZihcIltcIj09PW5bM10uY2hhckF0KDApKXt2YXIgbz1uWzZdO28mJihvPW8ucmVwbGFjZSgvXFxcXChbXCInXSkvZyxcIiQxXCIpKSxcImNsYXNzXCI9PT1uWzRdP3IucHVzaChvKTplLmF0dHJzW25bNF1dPW98fCEwfXJldHVybiByfWZ1bmN0aW9uIGQoZSx0KXt2YXIgbj10P2Uuc2xpY2UoMSk6ZTtyZXR1cm4gMT09PW4ubGVuZ3RoJiZLZShuWzBdKT9uWzBdOm59ZnVuY3Rpb24gcyhlLHQsbil7dmFyIHI9XCJjbGFzc1wiaW4gdD9cImNsYXNzXCI6XCJjbGFzc05hbWVcIjtmb3IodmFyIGEgaW4gdClDZS5jYWxsKHQsYSkmJihhPT09ciYmbnVsbCE9dFthXSYmXCJcIiE9PXRbYV0/KG4ucHVzaCh0W2FdKSxlW2FdPVwiXCIpOmVbYV09dFthXSk7bi5sZW5ndGgmJihlW3JdPW4uam9pbihcIiBcIikpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIGE9W10saT0xLHU9YXJndW1lbnRzLmxlbmd0aDtpPHU7aSsrKWFbaS0xXT1hcmd1bWVudHNbaV07aWYoZSYmbihlLnZpZXcpKXJldHVybiBhZShlLGEpO2lmKCFvKGUpKXRocm93IG5ldyBFcnJvcihcInNlbGVjdG9yIGluIG0oc2VsZWN0b3IsIGF0dHJzLCBjaGlsZHJlbikgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO3ZhciBjPW51bGwhPXQmJnIodCkmJiEoXCJ0YWdcImluIHR8fFwidmlld1wiaW4gdHx8XCJzdWJ0cmVlXCJpbiB0KSxmPWM/dDp7fSxwPXt0YWc6XCJkaXZcIixhdHRyczp7fSxjaGlsZHJlbjpkKGEsYyl9O3JldHVybiBzKHAuYXR0cnMsZixsKHAsZSkpLHB9ZnVuY3Rpb24gZihlLHQpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGgmJiF0KGVbbl0sbisrKTspO31mdW5jdGlvbiBwKGUsdCl7ZihlLGZ1bmN0aW9uKGUsbil7cmV0dXJuKGU9ZSYmZS5hdHRycykmJm51bGwhPWUua2V5JiZ0KGUsbil9KX1mdW5jdGlvbiB2KGUpe3RyeXtpZihcImJvb2xlYW5cIiE9dHlwZW9mIGUmJm51bGwhPWUmJm51bGwhPWUudG9TdHJpbmcoKSlyZXR1cm4gZX1jYXRjaCh0KXt9cmV0dXJuXCJcIn1mdW5jdGlvbiBtKGUsdCxuLHIpe3RyeXtoKGUsdCxuKSx0Lm5vZGVWYWx1ZT1yfWNhdGNoKGEpe319ZnVuY3Rpb24gZyhlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKylLZShlW3RdKSYmKGU9ZS5jb25jYXQuYXBwbHkoW10sZSksdC0tKTtyZXR1cm4gZX1mdW5jdGlvbiBoKGUsdCxuKXtlLmluc2VydEJlZm9yZSh0LGUuY2hpbGROb2Rlc1tuXXx8bnVsbCl9ZnVuY3Rpb24geShlLHQsbixyKXtwKGUsZnVuY3Rpb24oZSxyKXt0W2U9ZS5rZXldPXRbZV0/e2FjdGlvbjpqZSxpbmRleDpyLGZyb206dFtlXS5pbmRleCxlbGVtZW50Om4ubm9kZXNbdFtlXS5pbmRleF18fHhlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIil9OnthY3Rpb246QmUsaW5kZXg6cn19KTt2YXIgYT1bXTtmb3IodmFyIG8gaW4gdClDZS5jYWxsKHQsbykmJmEucHVzaCh0W29dKTt2YXIgaT1hLnNvcnQoSCksdT1uZXcgQXJyYXkobi5sZW5ndGgpO3JldHVybiB1Lm5vZGVzPW4ubm9kZXMuc2xpY2UoKSxmKGksZnVuY3Rpb24odCl7dmFyIGE9dC5pbmRleDtpZih0LmFjdGlvbj09PVRlJiYoVihuW2FdLm5vZGVzLG5bYV0pLHUuc3BsaWNlKGEsMSkpLHQuYWN0aW9uPT09QmUpe3ZhciBvPXhlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7by5rZXk9ZVthXS5hdHRycy5rZXksaChyLG8sYSksdS5zcGxpY2UoYSwwLHthdHRyczp7a2V5OmVbYV0uYXR0cnMua2V5fSxub2Rlczpbb119KSx1Lm5vZGVzW2FdPW99aWYodC5hY3Rpb249PT1qZSl7dmFyIGk9dC5lbGVtZW50LGw9ci5jaGlsZE5vZGVzW2FdO2whPT1pJiZudWxsIT09aSYmci5pbnNlcnRCZWZvcmUoaSxsfHxudWxsKSx1W2FdPW5bdC5mcm9tXSx1Lm5vZGVzW2FdPWl9fSksdX1mdW5jdGlvbiB3KGUsdCxuLHIpe3ZhciBhPWUubGVuZ3RoIT09dC5sZW5ndGg7cmV0dXJuIGF8fHAoZSxmdW5jdGlvbihlLG4pe3ZhciByPXRbbl07cmV0dXJuIGE9ciYmci5hdHRycyYmci5hdHRycy5rZXkhPT1lLmtleX0pLGE/eShlLG4sdCxyKTp0fWZ1bmN0aW9uIGIoZSx0LG4pe2YoZSxmdW5jdGlvbihlLHIpe251bGwhPXRbcl0mJm4ucHVzaC5hcHBseShuLHRbcl0ubm9kZXMpfSksZih0Lm5vZGVzLGZ1bmN0aW9uKGUscil7bnVsbCE9ZS5wYXJlbnROb2RlJiZuLmluZGV4T2YoZSk8MCYmVihbZV0sW3Rbcl1dKX0pLGUubGVuZ3RoPHQubGVuZ3RoJiYodC5sZW5ndGg9ZS5sZW5ndGgpLHQubm9kZXM9bn1mdW5jdGlvbiBQKGUpe3ZhciB0PTA7cChlLGZ1bmN0aW9uKCl7cmV0dXJuIGYoZSxmdW5jdGlvbihlKXsoZT1lJiZlLmF0dHJzKSYmbnVsbD09ZS5rZXkmJihlLmtleT1cIl9fbWl0aHJpbF9fXCIrdCsrKX0pLDF9KX1mdW5jdGlvbiBrKGUsdCxuKXtyZXR1cm4gZS50YWchPT10LnRhZ3x8KG4uc29ydCgpLmpvaW4oKSE9PU9iamVjdC5rZXlzKHQuYXR0cnMpLnNvcnQoKS5qb2luKCl8fChlLmF0dHJzLmlkIT09dC5hdHRycy5pZHx8KGUuYXR0cnMua2V5IT09dC5hdHRycy5rZXl8fChcImFsbFwiPT09Yy5yZWRyYXcuc3RyYXRlZ3koKT8hdC5jb25maWdDb250ZXh0fHx0LmNvbmZpZ0NvbnRleHQucmV0YWluIT09ITA6XCJkaWZmXCI9PT1jLnJlZHJhdy5zdHJhdGVneSgpJiYodC5jb25maWdDb250ZXh0JiZ0LmNvbmZpZ0NvbnRleHQucmV0YWluPT09ITEpKSkpKX1mdW5jdGlvbiBPKGUsdCxyKXtrKGUsdCxyKSYmKHQubm9kZXMubGVuZ3RoJiZWKHQubm9kZXMpLHQuY29uZmlnQ29udGV4dCYmbih0LmNvbmZpZ0NvbnRleHQub251bmxvYWQpJiZ0LmNvbmZpZ0NvbnRleHQub251bmxvYWQoKSx0LmNvbnRyb2xsZXJzJiZmKHQuY29udHJvbGxlcnMsZnVuY3Rpb24oZSl7ZS5vbnVubG9hZCYmZS5vbnVubG9hZCh7cHJldmVudERlZmF1bHQ6aX0pfSkpfWZ1bmN0aW9uIHgoZSx0KXtyZXR1cm4gZS5hdHRycy54bWxucz9lLmF0dHJzLnhtbG5zOlwic3ZnXCI9PT1lLnRhZz9cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI6XCJtYXRoXCI9PT1lLnRhZz9cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjp0fWZ1bmN0aW9uIFMoZSx0LG4pe24ubGVuZ3RoJiYoZS52aWV3cz10LGUuY29udHJvbGxlcnM9bixmKG4sZnVuY3Rpb24oZSl7aWYoZS5vbnVubG9hZCYmZS5vbnVubG9hZC4kb2xkJiYoZS5vbnVubG9hZD1lLm9udW5sb2FkLiRvbGQpLFJlJiZlLm9udW5sb2FkKXt2YXIgdD1lLm9udW5sb2FkO2Uub251bmxvYWQ9ZnVuY3Rpb24oKXt9LGUub251bmxvYWQuJG9sZD10fX0pKX1mdW5jdGlvbiBFKGUsdCxyLGEsbyl7aWYobih0LmF0dHJzLmNvbmZpZykpe3ZhciBpPW8uY29uZmlnQ29udGV4dD1vLmNvbmZpZ0NvbnRleHR8fHt9O2UucHVzaChmdW5jdGlvbigpe3JldHVybiB0LmF0dHJzLmNvbmZpZy5jYWxsKHQsciwhYSxpLG8pfSl9fWZ1bmN0aW9uIE0oZSxuLHIsYSxvLGksdSxsKXt2YXIgZD1lLm5vZGVzWzBdO3JldHVybiBhJiZKKGQsbi50YWcsbi5hdHRycyxlLmF0dHJzLG8pLGUuY2hpbGRyZW49cShkLG4udGFnLHQsdCxuLmNoaWxkcmVuLGUuY2hpbGRyZW4sITEsMCxuLmF0dHJzLmNvbnRlbnRlZGl0YWJsZT9kOnIsbyx1KSxlLm5vZGVzLmludGFjdD0hMCxsLmxlbmd0aCYmKGUudmlld3M9aSxlLmNvbnRyb2xsZXJzPWwpLGR9ZnVuY3Rpb24gQyhlLHQsbil7dmFyIHI7ZS4kdHJ1c3RlZD9yPWVlKHQsbixlKToocj1beGUuY3JlYXRlVGV4dE5vZGUoZSldLHQubm9kZU5hbWUgaW4gQWV8fGgodCxyWzBdLG4pKTt2YXIgYTtyZXR1cm4gYT1cInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9uZXcgZS5jb25zdHJ1Y3RvcihlKTplLGEubm9kZXM9cixhfWZ1bmN0aW9uIEQoZSx0LG4scixhLG8pe3ZhciBpPXQubm9kZXM7cmV0dXJuIHImJnI9PT14ZS5hY3RpdmVFbGVtZW50JiZlPT09dHx8KGUuJHRydXN0ZWQ/KFYoaSx0KSxpPWVlKG4sYSxlKSk6XCJ0ZXh0YXJlYVwiPT09bz9uLnZhbHVlPWU6cj8oci5pbm5lckhUTUw9ZSxpPVtdLnNsaWNlLmNhbGwoci5jaGlsZE5vZGVzKSk6KCgxPT09aVswXS5ub2RlVHlwZXx8aS5sZW5ndGg+MXx8aVswXS5ub2RlVmFsdWUudHJpbSYmIWlbMF0ubm9kZVZhbHVlLnRyaW0oKSkmJihWKHQubm9kZXMsdCksaT1beGUuY3JlYXRlVGV4dE5vZGUoZSldKSxtKG4saVswXSxhLGUpKSksdD1uZXcgZS5jb25zdHJ1Y3RvcihlKSx0Lm5vZGVzPWksdC4kdHJ1c3RlZD1lLiR0cnVzdGVkLHR9ZnVuY3Rpb24gSyhlLHQsbixyLGEsbyxpKXtyZXR1cm4gZS5ub2Rlcy5sZW5ndGg/ZS52YWx1ZU9mKCkhPT10LnZhbHVlT2YoKXx8YT9EKHQsZSxyLG8sbixpKTooZS5ub2Rlcy5pbnRhY3Q9ITAsZSk6Qyh0LHIsbil9ZnVuY3Rpb24gQShlKXtyZXR1cm4gZS4kdHJ1c3RlZD9lLm5vZGVzLmxlbmd0aDpLZShlKT9lLmxlbmd0aDoxfWZ1bmN0aW9uIFQoZSxuLHIsYSxvLGksdSxsLGQpe2U9ZyhlKTt2YXIgcz1bXSxjPW4ubGVuZ3RoPT09ZS5sZW5ndGgsZj0wLHY9e30sbT0hMTtwKG4sZnVuY3Rpb24oZSx0KXttPSEwLHZbblt0XS5hdHRycy5rZXldPXthY3Rpb246VGUsaW5kZXg6dH19KSxQKGUpLG0mJihuPXcoZSxuLHYscikpO2Zvcih2YXIgaD0wLHk9MCxrPWUubGVuZ3RoO3k8azt5Kyspe3ZhciBPPXEocixvLG4sYSxlW3ldLG5baF0saSxhK2Z8fGYsdSxsLGQpO08hPT10JiYoYz1jJiZPLm5vZGVzLmludGFjdCxmKz1BKE8pLG5baCsrXT1PKX1yZXR1cm4gY3x8YihlLG4scyksbn1mdW5jdGlvbiBCKGUsdCxuLHIsYSl7aWYobnVsbCE9dCl7aWYoRGUuY2FsbCh0KT09PURlLmNhbGwoZSkpcmV0dXJuIHQ7aWYoYSYmYS5ub2Rlcyl7dmFyIG89bi1yLGk9bysoS2UoZSk/ZTp0Lm5vZGVzKS5sZW5ndGg7VihhLm5vZGVzLnNsaWNlKG8saSksYS5zbGljZShvLGkpKX1lbHNlIHQubm9kZXMmJlYodC5ub2Rlcyx0KX1yZXR1cm4gdD1uZXcgZS5jb25zdHJ1Y3Rvcix0LnRhZyYmKHQ9e30pLHQubm9kZXM9W10sdH1mdW5jdGlvbiBqKGUsdCl7cmV0dXJuIGUuYXR0cnMuaXM/bnVsbD09dD94ZS5jcmVhdGVFbGVtZW50KGUudGFnLGUuYXR0cnMuaXMpOnhlLmNyZWF0ZUVsZW1lbnROUyh0LGUudGFnLGUuYXR0cnMuaXMpOm51bGw9PXQ/eGUuY3JlYXRlRWxlbWVudChlLnRhZyk6eGUuY3JlYXRlRWxlbWVudE5TKHQsZS50YWcpfWZ1bmN0aW9uIFIoZSx0LG4scil7cmV0dXJuIHI/Sih0LGUudGFnLGUuYXR0cnMse30sbik6ZS5hdHRyc31mdW5jdGlvbiBOKGUsbixyLGEsbyxpKXtyZXR1cm4gbnVsbCE9ZS5jaGlsZHJlbiYmZS5jaGlsZHJlbi5sZW5ndGg+MD9xKG4sZS50YWcsdCx0LGUuY2hpbGRyZW4sci5jaGlsZHJlbiwhMCwwLGUuYXR0cnMuY29udGVudGVkaXRhYmxlP246YSxvLGkpOmUuY2hpbGRyZW59ZnVuY3Rpb24gRyhlLHQsbixyLGEsbyxpKXt2YXIgdT17dGFnOmUudGFnLGF0dHJzOnQsY2hpbGRyZW46bixub2Rlczpbcl19O3JldHVybiBTKHUsbyxpKSx1LmNoaWxkcmVuJiYhdS5jaGlsZHJlbi5ub2RlcyYmKHUuY2hpbGRyZW4ubm9kZXM9W10pLHV9ZnVuY3Rpb24gRihlLHQscixhKXt2YXIgbztyZXR1cm4gbz1cImRpZmZcIj09PWMucmVkcmF3LnN0cmF0ZWd5KCkmJmU/ZS5pbmRleE9mKHQpOi0xLG8+LTE/cltvXTpuKGEpP25ldyBhOnt9fWZ1bmN0aW9uIF8oZSx0LG4scil7bnVsbCE9ci5vbnVubG9hZCYmR2UubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmhhbmRsZXJ9KS5pbmRleE9mKHIub251bmxvYWQpPDAmJkdlLnB1c2goe2NvbnRyb2xsZXI6cixoYW5kbGVyOnIub251bmxvYWR9KSxlLnB1c2gobiksdC5wdXNoKHIpfWZ1bmN0aW9uIEwoZSx0LG4scixhLG8pe3ZhciBpPUYobi52aWV3cyx0LHIsZS5jb250cm9sbGVyKSx1PWUmJmUuYXR0cnMmJmUuYXR0cnMua2V5O3JldHVybiBlPTA9PT1SZXx8RmV8fHImJnIuaW5kZXhPZihpKT4tMT9lLnZpZXcoaSk6e3RhZzpcInBsYWNlaG9sZGVyXCJ9LFwicmV0YWluXCI9PT1lLnN1YnRyZWU/ZTooZS5hdHRycz1lLmF0dHJzfHx7fSxlLmF0dHJzLmtleT11LF8obyxhLHQsaSksZSl9ZnVuY3Rpb24gSShlLHQsbixyKXtmb3IodmFyIGE9dCYmdC5jb250cm9sbGVycztudWxsIT1lLnZpZXc7KWU9TChlLGUudmlldy4kb3JpZ2luYWx8fGUudmlldyx0LGEscixuKTtyZXR1cm4gZX1mdW5jdGlvbiBVKGUsdCxuLHIsYSxpLHUsbCl7dmFyIGQ9W10scz1bXTtpZihlPUkoZSx0LGQscyksXCJyZXRhaW5cIj09PWUuc3VidHJlZSlyZXR1cm4gdDtpZighZS50YWcmJnMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCB0ZW1wbGF0ZSBtdXN0IHJldHVybiBhIHZpcnR1YWwgZWxlbWVudCwgbm90IGFuIGFycmF5LCBzdHJpbmcsIGV0Yy5cIik7ZS5hdHRycz1lLmF0dHJzfHx7fSx0LmF0dHJzPXQuYXR0cnN8fHt9O3ZhciBjPU9iamVjdC5rZXlzKGUuYXR0cnMpLGY9Yy5sZW5ndGg+KFwia2V5XCJpbiBlLmF0dHJzPzE6MCk7aWYoTyhlLHQsYyksbyhlLnRhZykpe3ZhciBwPTA9PT10Lm5vZGVzLmxlbmd0aDt1PXgoZSx1KTt2YXIgdjtpZihwKXt2PWooZSx1KTt2YXIgbT1SKGUsdix1LGYpO2gocix2LGEpO3ZhciBnPU4oZSx2LHQsbix1LGwpO3Q9RyhlLG0sZyx2LHUsZCxzKX1lbHNlIHY9TSh0LGUsbixmLHUsZCxsLHMpO3JldHVyblwic2VsZWN0XCI9PT1lLnRhZyYmXCJ2YWx1ZVwiaW4gZS5hdHRycyYmSih2LGUudGFnLHt2YWx1ZTplLmF0dHJzLnZhbHVlfSx7fSx1KSxwfHxpIT09ITB8fG51bGw9PXZ8fGgocix2LGEpLEUobCxlLHYscCx0KSx0fX1mdW5jdGlvbiBxKGUsdCxhLG8saSx1LGwsZCxzLGMsZil7cmV0dXJuIGk9dihpKSxcInJldGFpblwiPT09aS5zdWJ0cmVlP3U6KHU9QihpLHUsZCxvLGEpLEtlKGkpP1QoaSx1LGUsZCx0LGwscyxjLGYpOm51bGwhPWkmJnIoaSk/VShpLHUscyxlLGQsbCxjLGYpOm4oaSk/dTpLKHUsaSxkLGUsbCxzLHQpKX1mdW5jdGlvbiBIKGUsdCl7cmV0dXJuIGUuYWN0aW9uLXQuYWN0aW9ufHxlLmluZGV4LXQuaW5kZXh9ZnVuY3Rpb24gWChlLHQsbil7bj09PXQmJihlLnN0eWxlPVwiXCIsbj17fSk7Zm9yKHZhciByIGluIHQpQ2UuY2FsbCh0LHIpJiYobnVsbCE9biYmbltyXT09PXRbcl18fChlLnN0eWxlW3JdPXRbcl0pKTtmb3IociBpbiBuKUNlLmNhbGwobixyKSYmKENlLmNhbGwodCxyKXx8KGUuc3R5bGVbcl09XCJcIikpfWZ1bmN0aW9uIHooZSx0LGEsbyxpLHUpe2lmKFwiY29uZmlnXCI9PT10fHxcImtleVwiPT09dClyZXR1cm4hMDtpZihuKGEpJiZcIm9uXCI9PT10LnNsaWNlKDAsMikpZVt0XT10ZShhLGUpO2Vsc2UgaWYoXCJzdHlsZVwiPT09dCYmbnVsbCE9YSYmcihhKSlYKGUsYSxvKTtlbHNlIGlmKG51bGwhPXUpXCJocmVmXCI9PT10P2Uuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXCJocmVmXCIsYSk6ZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIj09PXQ/XCJjbGFzc1wiOnQsYSk7ZWxzZSBpZih0IGluIGUmJiFfZVt0XSl0cnl7KFwiaW5wdXRcIiE9PWkmJiFlLmlzQ29udGVudEVkaXRhYmxlfHxlW3RdIT1hKSYmKGVbdF09YSl9Y2F0Y2gobCl7ZS5zZXRBdHRyaWJ1dGUodCxhKX1lbHNlIHRyeXtlLnNldEF0dHJpYnV0ZSh0LGEpfWNhdGNoKGwpe319ZnVuY3Rpb24gJChlLHQsbixyLGEsbyxpKXtpZih0IGluIGEmJnI9PT1uJiZcIm9iamVjdFwiIT10eXBlb2YgbiYmeGUuYWN0aXZlRWxlbWVudCE9PWUpXCJ2YWx1ZVwiPT09dCYmXCJpbnB1dFwiPT09byYmZS52YWx1ZSE9biYmKGUudmFsdWU9bik7ZWxzZXthW3RdPW47dHJ5e3JldHVybiB6KGUsdCxuLHIsbyxpKX1jYXRjaCh1KXtpZih1Lm1lc3NhZ2UuaW5kZXhPZihcIkludmFsaWQgYXJndW1lbnRcIik8MCl0aHJvdyB1fX19ZnVuY3Rpb24gSihlLHQsbixyLGEpe2Zvcih2YXIgbyBpbiBuKSFDZS5jYWxsKG4sbyl8fCEkKGUsbyxuW29dLHJbb10scix0LGEpO3JldHVybiByfWZ1bmN0aW9uIFYoZSx0KXtmb3IodmFyIG49ZS5sZW5ndGgtMTtuPi0xO24tLSlpZihlW25dJiZlW25dLnBhcmVudE5vZGUpe3RyeXtlW25dLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZVtuXSl9Y2F0Y2gocil7fXQ9W10uY29uY2F0KHQpLHRbbl0mJlkodFtuXSl9ZS5sZW5ndGgmJihlLmxlbmd0aD0wKX1mdW5jdGlvbiBZKGUpe2UuY29uZmlnQ29udGV4dCYmbihlLmNvbmZpZ0NvbnRleHQub251bmxvYWQpJiYoZS5jb25maWdDb250ZXh0Lm9udW5sb2FkKCksZS5jb25maWdDb250ZXh0Lm9udW5sb2FkPW51bGwpLGUuY29udHJvbGxlcnMmJmYoZS5jb250cm9sbGVycyxmdW5jdGlvbihlKXtuKGUub251bmxvYWQpJiZlLm9udW5sb2FkKHtwcmV2ZW50RGVmYXVsdDppfSl9KSxlLmNoaWxkcmVuJiYoS2UoZS5jaGlsZHJlbik/ZihlLmNoaWxkcmVuLFkpOmUuY2hpbGRyZW4udGFnJiZZKGUuY2hpbGRyZW4pKX1mdW5jdGlvbiBRKGUsdCl7dHJ5e2UuYXBwZW5kQ2hpbGQoeGUuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQodCkpfWNhdGNoKG4pe2UuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsdCksVyhlKX19ZnVuY3Rpb24gVyhlKXtpZihcIlNDUklQVFwiPT09ZS50YWdOYW1lKWUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoWihlKSxlKTtlbHNle3ZhciB0PWUuY2hpbGROb2RlcztpZih0JiZ0Lmxlbmd0aClmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylXKHRbbl0pfXJldHVybiBlfWZ1bmN0aW9uIFooZSl7Zm9yKHZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksbj1lLmF0dHJpYnV0ZXMscj0wO3I8bi5sZW5ndGg7cisrKXQuc2V0QXR0cmlidXRlKG5bcl0ubmFtZSxuW3JdLnZhbHVlKTtyZXR1cm4gdC50ZXh0PWUuaW5uZXJIVE1MLHR9ZnVuY3Rpb24gZWUoZSx0LG4pe3ZhciByPWUuY2hpbGROb2Rlc1t0XTtpZihyKXt2YXIgYT0xIT09ci5ub2RlVHlwZSxvPXhlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO2E/KGUuaW5zZXJ0QmVmb3JlKG8scnx8bnVsbCksby5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLG4pLGUucmVtb3ZlQ2hpbGQobykpOnIuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIixuKX1lbHNlIFEoZSxuKTtmb3IodmFyIGk9W107ZS5jaGlsZE5vZGVzW3RdIT09cjspaS5wdXNoKGUuY2hpbGROb2Rlc1t0XSksdCsrO3JldHVybiBpfWZ1bmN0aW9uIHRlKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4pe249bnx8ZXZlbnQsYy5yZWRyYXcuc3RyYXRlZ3koXCJkaWZmXCIpLGMuc3RhcnRDb21wdXRhdGlvbigpO3RyeXtyZXR1cm4gZS5jYWxsKHQsbil9ZmluYWxseXtsZSgpfX19ZnVuY3Rpb24gbmUoZSl7dmFyIHQ9SWUuaW5kZXhPZihlKTtyZXR1cm4gdDwwP0llLnB1c2goZSktMTp0fWZ1bmN0aW9uIHJlKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCYmKGU9YXJndW1lbnRzWzBdKSxlfXJldHVybiB0LnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiBlJiZuKGUudG9KU09OKT9lLnRvSlNPTigpOmV9LHR9ZnVuY3Rpb24gYWUoZSx0KXtmdW5jdGlvbiBuKCl7cmV0dXJuKGUuY29udHJvbGxlcnx8aSkuYXBwbHkodGhpcyx0KXx8dGhpc31mdW5jdGlvbiByKG4pe2Zvcih2YXIgcj1bbl0uY29uY2F0KHQpLGE9MTthPGFyZ3VtZW50cy5sZW5ndGg7YSsrKXIucHVzaChhcmd1bWVudHNbYV0pO3JldHVybiBlLnZpZXcuYXBwbHkoZSxyKX1lLmNvbnRyb2xsZXImJihuLnByb3RvdHlwZT1lLmNvbnRyb2xsZXIucHJvdG90eXBlKSxyLiRvcmlnaW5hbD1lLnZpZXc7dmFyIGE9e2NvbnRyb2xsZXI6bix2aWV3OnJ9O3JldHVybiB0WzBdJiZudWxsIT10WzBdLmtleSYmKGEuYXR0cnM9e2tleTp0WzBdLmtleX0pLGF9ZnVuY3Rpb24gb2UoZSx0LG4scil7aWYoIXIpe2MucmVkcmF3LnN0cmF0ZWd5KFwiYWxsXCIpLGMuc3RhcnRDb21wdXRhdGlvbigpLEhlW25dPXQ7dmFyIGE7YT1xZT1lP2U6ZT17Y29udHJvbGxlcjppfTt2YXIgbz1uZXcoZS5jb250cm9sbGVyfHxpKTtyZXR1cm4gYT09PXFlJiYoemVbbl09byxYZVtuXT1lKSxsZSgpLG51bGw9PT1lJiZpZSh0LG4pLHplW25dfW51bGw9PWUmJmllKHQsbiksWmUmJihXZT1aZSl9ZnVuY3Rpb24gaWUoZSx0KXtIZS5zcGxpY2UodCwxKSx6ZS5zcGxpY2UodCwxKSxYZS5zcGxpY2UodCwxKSxtZShlKSxJZS5zcGxpY2UobmUoZSksMSksR2U9W119ZnVuY3Rpb24gdWUoKXtWZSYmKFZlKCksVmU9bnVsbCksZihIZSxmdW5jdGlvbihlLHQpe3ZhciBuPVhlW3RdO2lmKHplW3RdKXt2YXIgcj1bemVbdF1dO2MucmVuZGVyKGUsbi52aWV3P24udmlldyh6ZVt0XSxyKTpcIlwiKX19KSxZZSYmKFllKCksWWU9bnVsbCksJGU9bnVsbCxKZT1uZXcgRGF0ZSxjLnJlZHJhdy5zdHJhdGVneShcImRpZmZcIil9ZnVuY3Rpb24gbGUoKXtcIm5vbmVcIj09PWMucmVkcmF3LnN0cmF0ZWd5KCk/KFJlLS0sYy5yZWRyYXcuc3RyYXRlZ3koXCJkaWZmXCIpKTpjLmVuZENvbXB1dGF0aW9uKCl9ZnVuY3Rpb24gZGUoZSl7cmV0dXJuIGUuc2xpY2UobnRbYy5yb3V0ZS5tb2RlXS5sZW5ndGgpfWZ1bmN0aW9uIHNlKGUsdCxuKXt0dD17fTt2YXIgcj1uLmluZGV4T2YoXCI/XCIpO3IhPT0tMSYmKHR0PXZlKG4uc3Vic3RyKHIrMSxuLmxlbmd0aCkpLG49bi5zdWJzdHIoMCxyKSk7dmFyIGE9T2JqZWN0LmtleXModCksbz1hLmluZGV4T2Yobik7aWYobyE9PS0xKXJldHVybiBjLm1vdW50KGUsdFthW29dXSksITA7Zm9yKHZhciBpIGluIHQpaWYoQ2UuY2FsbCh0LGkpKXtpZihpPT09bilyZXR1cm4gYy5tb3VudChlLHRbaV0pLCEwO3ZhciB1PW5ldyBSZWdFeHAoXCJeXCIraS5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZyxcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csXCIoW15cXFxcL10rKVwiKStcIi8/JFwiKTtpZih1LnRlc3QobikpcmV0dXJuIG4ucmVwbGFjZSh1LGZ1bmN0aW9uKCl7dmFyIG49aS5tYXRjaCgvOlteXFwvXSsvZyl8fFtdLHI9W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSwtMik7ZihuLGZ1bmN0aW9uKGUsdCl7dHRbZS5yZXBsYWNlKC86fFxcLi9nLFwiXCIpXT1kZWNvZGVVUklDb21wb25lbnQoclt0XSl9KSxjLm1vdW50KGUsdFtpXSl9KSwhMH19ZnVuY3Rpb24gY2UoZSl7aWYoZT1lfHxldmVudCwhKGUuY3RybEtleXx8ZS5tZXRhS2V5fHxlLnNoaWZ0S2V5fHwyPT09ZS53aGljaCkpe2UucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOmUucmV0dXJuVmFsdWU9ITE7dmFyIHQsbj1lLmN1cnJlbnRUYXJnZXR8fGUuc3JjRWxlbWVudDtmb3IodD1cInBhdGhuYW1lXCI9PT1jLnJvdXRlLm1vZGUmJm4uc2VhcmNoP3ZlKG4uc2VhcmNoLnNsaWNlKDEpKTp7fTtuJiYhL2EvaS50ZXN0KG4ubm9kZU5hbWUpOyluPW4ucGFyZW50Tm9kZTtSZT0wLGMucm91dGUobltjLnJvdXRlLm1vZGVdLnNsaWNlKG50W2Mucm91dGUubW9kZV0ubGVuZ3RoKSx0KX19ZnVuY3Rpb24gZmUoKXtcImhhc2hcIiE9PWMucm91dGUubW9kZSYmU2UuaGFzaD9TZS5oYXNoPVNlLmhhc2g6ZS5zY3JvbGxUbygwLDApfWZ1bmN0aW9uIHBlKGUsbil7dmFyIGE9e30sbz1bXTtmb3IodmFyIGkgaW4gZSlpZihDZS5jYWxsKGUsaSkpe3ZhciB1PW4/bitcIltcIitpK1wiXVwiOmksbD1lW2ldO2lmKG51bGw9PT1sKW8ucHVzaChlbmNvZGVVUklDb21wb25lbnQodSkpO2Vsc2UgaWYocihsKSlvLnB1c2gocGUobCx1KSk7ZWxzZSBpZihLZShsKSl7dmFyIGQ9W107YVt1XT1hW3VdfHx7fSxmKGwsZnVuY3Rpb24oZSl7YVt1XVtlXXx8KGFbdV1bZV09ITAsZC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1KStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZSkpKX0pLG8ucHVzaChkLmpvaW4oXCImXCIpKX1lbHNlIGwhPT10JiZvLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHUpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChsKSl9cmV0dXJuIG8uam9pbihcIiZcIil9ZnVuY3Rpb24gdmUoZSl7aWYoXCJcIj09PWV8fG51bGw9PWUpcmV0dXJue307XCI/XCI9PT1lLmNoYXJBdCgwKSYmKGU9ZS5zbGljZSgxKSk7dmFyIHQ9ZS5zcGxpdChcIiZcIiksbj17fTtyZXR1cm4gZih0LGZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCI9XCIpLHI9ZGVjb2RlVVJJQ29tcG9uZW50KHRbMF0pLGE9Mj09PXQubGVuZ3RoP2RlY29kZVVSSUNvbXBvbmVudCh0WzFdKTpudWxsO251bGwhPW5bcl0/KEtlKG5bcl0pfHwobltyXT1bbltyXV0pLG5bcl0ucHVzaChhKSk6bltyXT1hfSksbn1mdW5jdGlvbiBtZShlKXt2YXIgbj1uZShlKTtWKGUuY2hpbGROb2RlcyxVZVtuXSksVWVbbl09dH1mdW5jdGlvbiBnZShlLHQpe3ZhciBuPWMucHJvcCh0KTtyZXR1cm4gZS50aGVuKG4pLG4udGhlbj1mdW5jdGlvbihuLHIpe3JldHVybiBnZShlLnRoZW4obixyKSx0KX0sbltcImNhdGNoXCJdPW4udGhlbi5iaW5kKG51bGwsbnVsbCksbn1mdW5jdGlvbiBoZShlLHQpe2Z1bmN0aW9uIGEoZSl7bD1lfHxsdCxzLm1hcChmdW5jdGlvbihlKXtsPT09dXQ/ZS5yZXNvbHZlKGQpOmUucmVqZWN0KGQpfSl9ZnVuY3Rpb24gbyhlLHQsYSxvKXtpZigobnVsbCE9ZCYmcihkKXx8bihkKSkmJm4oZSkpdHJ5e3ZhciBpPTA7ZS5jYWxsKGQsZnVuY3Rpb24oZSl7aSsrfHwoZD1lLHQoKSl9LGZ1bmN0aW9uKGUpe2krK3x8KGQ9ZSxhKCkpfSl9Y2F0Y2godSl7Yy5kZWZlcnJlZC5vbmVycm9yKHUpLGQ9dSxhKCl9ZWxzZSBvKCl9ZnVuY3Rpb24gaSgpe3ZhciByO3RyeXtyPWQmJmQudGhlbn1jYXRjaChzKXtyZXR1cm4gYy5kZWZlcnJlZC5vbmVycm9yKHMpLGQ9cyxsPWl0LGkoKX1sPT09aXQmJmMuZGVmZXJyZWQub25lcnJvcihkKSxvKHIsZnVuY3Rpb24oKXtsPW90LGkoKX0sZnVuY3Rpb24oKXtsPWl0LGkoKX0sZnVuY3Rpb24oKXt0cnl7bD09PW90JiZuKGUpP2Q9ZShkKTpsPT09aXQmJm4odCkmJihkPXQoZCksbD1vdCl9Y2F0Y2goaSl7cmV0dXJuIGMuZGVmZXJyZWQub25lcnJvcihpKSxkPWksYSgpfWQ9PT11PyhkPVR5cGVFcnJvcigpLGEoKSk6byhyLGZ1bmN0aW9uKCl7YSh1dCl9LGEsZnVuY3Rpb24oKXthKGw9PT1vdCYmdXQpfSl9KX12YXIgdT10aGlzLGw9MCxkPTAscz1bXTt1LnByb21pc2U9e30sdS5yZXNvbHZlPWZ1bmN0aW9uKGUpe3JldHVybiBsfHwoZD1lLGw9b3QsaSgpKSx1fSx1LnJlamVjdD1mdW5jdGlvbihlKXtyZXR1cm4gbHx8KGQ9ZSxsPWl0LGkoKSksdX0sdS5wcm9taXNlLnRoZW49ZnVuY3Rpb24oZSx0KXt2YXIgbj1uZXcgaGUoZSx0KTtyZXR1cm4gbD09PXV0P24ucmVzb2x2ZShkKTpsPT09bHQ/bi5yZWplY3QoZCk6cy5wdXNoKG4pLG4ucHJvbWlzZX19ZnVuY3Rpb24geWUoZSl7cmV0dXJuIGV9ZnVuY3Rpb24gd2Uobil7dmFyIHI9bi5jYWxsYmFja05hbWV8fFwibWl0aHJpbF9jYWxsYmFja19cIisobmV3IERhdGUpLmdldFRpbWUoKStcIl9cIitNYXRoLnJvdW5kKDFlMTYqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpLGE9eGUuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtlW3JdPWZ1bmN0aW9uKG8pe2EucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSxuLm9ubG9hZCh7dHlwZTpcImxvYWRcIix0YXJnZXQ6e3Jlc3BvbnNlVGV4dDpvfX0pLGVbcl09dH0sYS5vbmVycm9yPWZ1bmN0aW9uKCl7cmV0dXJuIGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSxuLm9uZXJyb3Ioe3R5cGU6XCJlcnJvclwiLHRhcmdldDp7c3RhdHVzOjUwMCxyZXNwb25zZVRleHQ6SlNPTi5zdHJpbmdpZnkoe2Vycm9yOlwiRXJyb3IgbWFraW5nIGpzb25wIHJlcXVlc3RcIn0pfX0pLGVbcl09dCwhMX0sYS5vbmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sYS5zcmM9bi51cmwrKG4udXJsLmluZGV4T2YoXCI/XCIpPjA/XCImXCI6XCI/XCIpKyhuLmNhbGxiYWNrS2V5P24uY2FsbGJhY2tLZXk6XCJjYWxsYmFja1wiKStcIj1cIityK1wiJlwiK3BlKG4uZGF0YXx8e30pLHhlLmJvZHkuYXBwZW5kQ2hpbGQoYSl9ZnVuY3Rpb24gYmUodCl7dmFyIGE9bmV3IGUuWE1MSHR0cFJlcXVlc3Q7aWYoYS5vcGVuKHQubWV0aG9kLHQudXJsLCEwLHQudXNlcix0LnBhc3N3b3JkKSxhLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpezQ9PT1hLnJlYWR5U3RhdGUmJihhLnN0YXR1cz49MjAwJiZhLnN0YXR1czwzMDA/dC5vbmxvYWQoe3R5cGU6XCJsb2FkXCIsdGFyZ2V0OmF9KTp0Lm9uZXJyb3Ioe3R5cGU6XCJlcnJvclwiLHRhcmdldDphfSkpfSx0LnNlcmlhbGl6ZT09PUpTT04uc3RyaW5naWZ5JiZ0LmRhdGEmJlwiR0VUXCIhPT10Lm1ldGhvZCYmYS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpLHQuZGVzZXJpYWxpemU9PT1KU09OLnBhcnNlJiZhLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIixcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKSxyKHQuaGVhZGVycykpZm9yKHZhciBpIGluIHQuaGVhZGVycylDZS5jYWxsKHQuaGVhZGVycyxpKSYmYS5zZXRSZXF1ZXN0SGVhZGVyKGksdC5oZWFkZXJzW2ldKTtpZihuKHQuY29uZmlnKSl7dmFyIHU9dC5jb25maWcoYSx0KTtudWxsIT11JiYoYT11KX12YXIgbD1cIkdFVFwiIT09dC5tZXRob2QmJnQuZGF0YT90LmRhdGE6XCJcIjtpZihsJiYhbyhsKSYmbC5jb25zdHJ1Y3RvciE9PWUuRm9ybURhdGEpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBkYXRhIHNob3VsZCBiZSBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgRm9ybURhdGEuIENoZWNrIHRoZSBgc2VyaWFsaXplYCBvcHRpb24gaW4gYG0ucmVxdWVzdGBcIik7cmV0dXJuIGEuc2VuZChsKSxhfWZ1bmN0aW9uIFBlKGUpe3JldHVybiBlLmRhdGFUeXBlJiZcImpzb25wXCI9PT1lLmRhdGFUeXBlLnRvTG93ZXJDYXNlKCk/d2UoZSk6YmUoZSl9ZnVuY3Rpb24ga2UoZSx0LG4pe2lmKFwiR0VUXCI9PT1lLm1ldGhvZCYmXCJqc29ucFwiIT09ZS5kYXRhVHlwZSl7dmFyIHI9ZS51cmwuaW5kZXhPZihcIj9cIik8MD9cIj9cIjpcIiZcIixhPXBlKHQpO2UudXJsKz1hP3IrYTpcIlwifWVsc2UgZS5kYXRhPW4odCl9ZnVuY3Rpb24gT2UoZSx0KXtyZXR1cm4gdCYmKGU9ZS5yZXBsYWNlKC86W2Etel1cXHcrL2dpLGZ1bmN0aW9uKGUpe3ZhciBuPWUuc2xpY2UoMSkscj10W25dfHxlO3JldHVybiBkZWxldGUgdFtuXSxyfSkpLGV9Yy52ZXJzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuXCJ2MC4yLjhcIn07dmFyIHhlLFNlLEVlLE1lLENlPXt9Lmhhc093blByb3BlcnR5LERlPXt9LnRvU3RyaW5nLEtlPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PURlLmNhbGwoZSl9LEFlPXtBUkVBOjEsQkFTRToxLEJSOjEsQ09MOjEsQ09NTUFORDoxLEVNQkVEOjEsSFI6MSxJTUc6MSxJTlBVVDoxLEtFWUdFTjoxLExJTks6MSxNRVRBOjEsUEFSQU06MSxTT1VSQ0U6MSxUUkFDSzoxLFdCUjoxfTtjLmRlcHM9ZnVuY3Rpb24odCl7cmV0dXJuIHUoZT10fHx3aW5kb3cpLGV9LGMuZGVwcy5mYWN0b3J5PWMuZmFjdG9yeT1hLGMuZGVwcyhlKTt2YXIgVGU9MSxCZT0yLGplPTMsUmU9MDtjLnN0YXJ0Q29tcHV0YXRpb249ZnVuY3Rpb24oKXtSZSsrfSxjLmVuZENvbXB1dGF0aW9uPWZ1bmN0aW9uKCl7UmU+MT9SZS0tOihSZT0wLGMucmVkcmF3KCkpfTt2YXIgTmUsR2U9W10sRmU9ITEsX2U9e2xpc3Q6MSxzdHlsZToxLGZvcm06MSx0eXBlOjEsd2lkdGg6MSxoZWlnaHQ6MX0sTGU9e2FwcGVuZENoaWxkOmZ1bmN0aW9uKGUpe05lPT09dCYmKE5lPXhlLmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpKSx4ZS5kb2N1bWVudEVsZW1lbnQmJnhlLmRvY3VtZW50RWxlbWVudCE9PWU/eGUucmVwbGFjZUNoaWxkKGUseGUuZG9jdW1lbnRFbGVtZW50KTp4ZS5hcHBlbmRDaGlsZChlKSx0aGlzLmNoaWxkTm9kZXM9eGUuY2hpbGROb2Rlc30saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGUpe3RoaXMuYXBwZW5kQ2hpbGQoZSl9LGNoaWxkTm9kZXM6W119LEllPVtdLFVlPXt9O2MucmVuZGVyPWZ1bmN0aW9uKGUsbixyKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIik7dmFyIGEsbz1bXSxpPW5lKGUpLHU9ZT09PXhlO2E9dXx8ZT09PXhlLmRvY3VtZW50RWxlbWVudD9MZTplLHUmJlwiaHRtbFwiIT09bi50YWcmJihuPXt0YWc6XCJodG1sXCIsYXR0cnM6e30sY2hpbGRyZW46bn0pLFVlW2ldPT09dCYmVihhLmNoaWxkTm9kZXMpLHI9PT0hMCYmbWUoZSksVWVbaV09cShhLG51bGwsdCx0LG4sVWVbaV0sITEsMCxudWxsLHQsbyksZihvLGZ1bmN0aW9uKGUpe2UoKX0pfSxjLnRydXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlPW5ldyBTdHJpbmcoZSksZS4kdHJ1c3RlZD0hMCxlfSxjLnByb3A9ZnVuY3Rpb24oZSl7cmV0dXJuKG51bGwhPWUmJihyKGUpfHxuKGUpKXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJmUgaW5zdGFuY2VvZiBQcm9taXNlKSYmbihlLnRoZW4pP2dlKGUpOnJlKGUpfTt2YXIgcWUsSGU9W10sWGU9W10semU9W10sJGU9bnVsbCxKZT0wLFZlPW51bGwsWWU9bnVsbCxRZT0xNjtjLmNvbXBvbmVudD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuLTFdPWFyZ3VtZW50c1tuXTtyZXR1cm4gYWUoZSx0KX07dmFyIFdlLFplO2MubW91bnQ9Yy5tb2R1bGU9ZnVuY3Rpb24oZSx0KXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIik7dmFyIHI9SGUuaW5kZXhPZihlKTtyPDAmJihyPUhlLmxlbmd0aCk7dmFyIGE9ITEsbz17cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXthPSEwLFZlPVllPW51bGx9fTtyZXR1cm4gZihHZSxmdW5jdGlvbihlKXtlLmhhbmRsZXIuY2FsbChlLmNvbnRyb2xsZXIsbyksZS5jb250cm9sbGVyLm9udW5sb2FkPW51bGx9KSxhP2YoR2UsZnVuY3Rpb24oZSl7ZS5jb250cm9sbGVyLm9udW5sb2FkPWUuaGFuZGxlcn0pOkdlPVtdLHplW3JdJiZuKHplW3JdLm9udW5sb2FkKSYmemVbcl0ub251bmxvYWQobyksb2UodCxlLHIsYSl9O3ZhciBldD0hMTtjLnJlZHJhdz1mdW5jdGlvbih0KXtpZighZXQpe2V0PSEwLHQmJihGZT0hMCk7dHJ5eyRlJiYhdD8oRWU9PT1lLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8bmV3IERhdGUtSmU+UWUpJiYoJGU+MCYmTWUoJGUpLCRlPUVlKHVlLFFlKSk6KHVlKCksJGU9RWUoZnVuY3Rpb24oKXskZT1udWxsfSxRZSkpfWZpbmFsbHl7ZXQ9RmU9ITF9fX0sYy5yZWRyYXcuc3RyYXRlZ3k9Yy5wcm9wKCksYy53aXRoQXR0cj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGZ1bmN0aW9uKHIpe3I9cnx8d2luZG93LmV2ZW50O3ZhciBhPXIuY3VycmVudFRhcmdldHx8dGhpcyxvPW58fHRoaXMsaT1lIGluIGE/YVtlXTphLmdldEF0dHJpYnV0ZShlKTt0LmNhbGwobyxpKX19O3ZhciB0dCxudD17cGF0aG5hbWU6XCJcIixoYXNoOlwiI1wiLHNlYXJjaDpcIj9cIn0scnQ9aSxhdD0hMTtjLnJvdXRlPWZ1bmN0aW9uKHQsbixyLGEpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBXZTtpZigzPT09YXJndW1lbnRzLmxlbmd0aCYmbyhuKSl7cnQ9ZnVuY3Rpb24oZSl7dmFyIGE9V2U9ZGUoZSk7aWYoIXNlKHQscixhKSl7aWYoYXQpdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBkZWZhdWx0IHJvdXRlIG1hdGNoZXMgb25lIG9mIHRoZSByb3V0ZXMgZGVmaW5lZCBpbiBtLnJvdXRlXCIpO2F0PSEwLGMucm91dGUobiwhMCksYXQ9ITF9fTt2YXIgaT1cImhhc2hcIj09PWMucm91dGUubW9kZT9cIm9uaGFzaGNoYW5nZVwiOlwib25wb3BzdGF0ZVwiO3JldHVybiBlW2ldPWZ1bmN0aW9uKCl7dmFyIGU9U2VbYy5yb3V0ZS5tb2RlXTtcInBhdGhuYW1lXCI9PT1jLnJvdXRlLm1vZGUmJihlKz1TZS5zZWFyY2gpLFdlIT09ZGUoZSkmJnJ0KGUpfSxWZT1mZSx2b2lkIGVbaV0oKX1pZih0LmFkZEV2ZW50TGlzdGVuZXJ8fHQuYXR0YWNoRXZlbnQpe3ZhciB1PVwicGF0aG5hbWVcIiE9PWMucm91dGUubW9kZT9TZS5wYXRobmFtZTpcIlwiO3JldHVybiB0LmhyZWY9dStudFtjLnJvdXRlLm1vZGVdK2EuYXR0cnMuaHJlZix2b2lkKHQuYWRkRXZlbnRMaXN0ZW5lcj8odC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIixjZSksdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixjZSkpOih0LmRldGFjaEV2ZW50KFwib25jbGlja1wiLGNlKSx0LmF0dGFjaEV2ZW50KFwib25jbGlja1wiLGNlKSkpfWlmKG8odCkpe1plPVdlLFdlPXQ7dmFyIGwsZD1ufHx7fSxzPVdlLmluZGV4T2YoXCI/XCIpO2w9cz4tMT92ZShXZS5zbGljZShzKzEpKTp7fTtmb3IodmFyIGYgaW4gZClDZS5jYWxsKGQsZikmJihsW2ZdPWRbZl0pO3ZhciBwLHY9cGUobCk7cD1zPi0xP1dlLnNsaWNlKDAscyk6V2UsdiYmKFdlPXArKHAuaW5kZXhPZihcIj9cIik9PT0tMT9cIj9cIjpcIiZcIikrdik7dmFyIG09KDM9PT1hcmd1bWVudHMubGVuZ3RoP3I6bik9PT0hMHx8WmU9PT1XZTtpZihlLmhpc3RvcnkucHVzaFN0YXRlKXt2YXIgZz1tP1wicmVwbGFjZVN0YXRlXCI6XCJwdXNoU3RhdGVcIjtWZT1mZSxZZT1mdW5jdGlvbigpe3RyeXtlLmhpc3RvcnlbZ10obnVsbCx4ZS50aXRsZSxudFtjLnJvdXRlLm1vZGVdK1dlKX1jYXRjaCh0KXtTZVtjLnJvdXRlLm1vZGVdPVdlfX0scnQobnRbYy5yb3V0ZS5tb2RlXStXZSl9ZWxzZSBTZVtjLnJvdXRlLm1vZGVdPVdlLHJ0KG50W2Mucm91dGUubW9kZV0rV2UpO1plPW51bGx9fSxjLnJvdXRlLnBhcmFtPWZ1bmN0aW9uKGUpe2lmKCF0dCl0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBjYWxsIG0ucm91dGUoZWxlbWVudCwgZGVmYXVsdFJvdXRlLCByb3V0ZXMpIGJlZm9yZSBjYWxsaW5nIG0ucm91dGUucGFyYW0oKVwiKTtyZXR1cm4gZT90dFtlXTp0dH0sYy5yb3V0ZS5tb2RlPVwic2VhcmNoXCIsYy5yb3V0ZS5idWlsZFF1ZXJ5U3RyaW5nPXBlLGMucm91dGUucGFyc2VRdWVyeVN0cmluZz12ZSxjLmRlZmVycmVkPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IGhlO3JldHVybiBlLnByb21pc2U9Z2UoZS5wcm9taXNlKSxlfTt2YXIgb3Q9MSxpdD0yLHV0PTMsbHQ9NDtyZXR1cm4gYy5kZWZlcnJlZC5vbmVycm9yPWZ1bmN0aW9uKGUpe2lmKFwiW29iamVjdCBFcnJvcl1cIj09PURlLmNhbGwoZSkmJiEvIEVycm9yLy50ZXN0KGUuY29uc3RydWN0b3IudG9TdHJpbmcoKSkpdGhyb3cgUmU9MCxlfSxjLnN5bmM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHQpe3JldHVybiBmdW5jdGlvbihpKXtyZXR1cm4gYVtlXT1pLHR8fChvPVwicmVqZWN0XCIpLDA9PT0tLXImJihuLnByb21pc2UoYSksbltvXShhKSksaX19dmFyIG49Yy5kZWZlcnJlZCgpLHI9ZS5sZW5ndGgsYT1bXSxvPVwicmVzb2x2ZVwiO3JldHVybiBlLmxlbmd0aD4wP2YoZSxmdW5jdGlvbihlLG4pe2UudGhlbih0KG4sITApLHQobiwhMSkpfSk6bi5yZXNvbHZlKFtdKSxuLnByb21pc2V9LGMucmVxdWVzdD1mdW5jdGlvbihlKXtlLmJhY2tncm91bmQhPT0hMCYmYy5zdGFydENvbXB1dGF0aW9uKCk7dmFyIHQsbixyLGE9bmV3IGhlLG89ZS5kYXRhVHlwZSYmXCJqc29ucFwiPT09ZS5kYXRhVHlwZS50b0xvd2VyQ2FzZSgpO3JldHVybiBvPyh0PWUuc2VyaWFsaXplPW49ZS5kZXNlcmlhbGl6ZT15ZSxyPWZ1bmN0aW9uKGUpe3JldHVybiBlLnJlc3BvbnNlVGV4dH0pOih0PWUuc2VyaWFsaXplPWUuc2VyaWFsaXplfHxKU09OLnN0cmluZ2lmeSxuPWUuZGVzZXJpYWxpemU9ZS5kZXNlcmlhbGl6ZXx8SlNPTi5wYXJzZSxyPWUuZXh0cmFjdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVzcG9uc2VUZXh0Lmxlbmd0aHx8biE9PUpTT04ucGFyc2U/ZS5yZXNwb25zZVRleHQ6bnVsbH0pLGUubWV0aG9kPShlLm1ldGhvZHx8XCJHRVRcIikudG9VcHBlckNhc2UoKSxlLnVybD1PZShlLnVybCxlLmRhdGEpLGtlKGUsZS5kYXRhLHQpLGUub25sb2FkPWUub25lcnJvcj1mdW5jdGlvbih0KXt0cnl7dD10fHxldmVudDt2YXIgbz1uKHIodC50YXJnZXQsZSkpO1wibG9hZFwiPT09dC50eXBlPyhlLnVud3JhcFN1Y2Nlc3MmJihvPWUudW53cmFwU3VjY2VzcyhvLHQudGFyZ2V0KSksS2UobykmJmUudHlwZT9mKG8sZnVuY3Rpb24odCxuKXtvW25dPW5ldyBlLnR5cGUodCl9KTplLnR5cGUmJihvPW5ldyBlLnR5cGUobykpLGEucmVzb2x2ZShvKSk6KGUudW53cmFwRXJyb3ImJihvPWUudW53cmFwRXJyb3Iobyx0LnRhcmdldCkpLGEucmVqZWN0KG8pKX1jYXRjaChpKXthLnJlamVjdChpKSxjLmRlZmVycmVkLm9uZXJyb3IoaSl9ZmluYWxseXtlLmJhY2tncm91bmQhPT0hMCYmYy5lbmRDb21wdXRhdGlvbigpfX0sUGUoZSksYS5wcm9taXNlPWdlKGEucHJvbWlzZSxlLmluaXRpYWxWYWx1ZSksYS5wcm9taXNlfSxjfSl9LHt9XSwzOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0KXt2YXIgbixyLGEsbz10LmFuaW1hdGlvbi5jdXJyZW50LGk9ZFtcImRlZmF1bHRcIl0uZmluZFBvdih0LnBvdlNpZGUsdC50dXJuU2lkZSksdT1kW1wiZGVmYXVsdFwiXS52ZWN0b3JCeVBvdihpKSxsPXQuYm91bmRzKCkscz00LzMsZj0xKmwud2lkdGgscD0obC5oZWlnaHQqKHMvMjQuMzIpLDYwOC8zNTApLHY9ZixtPWwuaGVpZ2h0KihzL3ApLGc9LjA2MjUqdixoPS4xNCptLHk9e30sdz1bXTtpZihvLmhpbnQ9PT1jW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlKXtuPVsxMipnLG1dLHI9W3YqdVswXSxtKnVbMV1dO3ZhciBhPVtyWzBdLW5bMF0sclsxXS1uWzFdXTt5W2RbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50XT1bYSxhLCEwXX1lbHNlIGlmKG8uaGludD09PWNbXCJkZWZhdWx0XCJdLmRpc2NhcmQpe3ZhciBiPWRbXCJkZWZhdWx0XCJdLmRpc2NhcmRCeVBvdihpKSxQPWRbXCJkZWZhdWx0XCJdLnRvcEtleTJwb3MoYik7bj1bZypQWzBdLGgqUFsxXV0scj1bdip1WzBdLG0qdVsxXV0sYT1bclswXS1uWzBdLHJbMV0tblsxXV0seVtiXT1bYSxhXX1yZXR1cm57YW5pbXM6eSxmYWRpbmdzOnd9fWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4gTWF0aC5yb3VuZChlKnQpL3R9ZnVuY3Rpb24gaShlKXtpZihlLmFuaW1hdGlvbi5jdXJyZW50LnN0YXJ0KXt2YXIgdD0xLSgobmV3IERhdGUpLmdldFRpbWUoKS1lLmFuaW1hdGlvbi5jdXJyZW50LnN0YXJ0KS9lLmFuaW1hdGlvbi5jdXJyZW50LmR1cmF0aW9uO2lmKHQ8PTApZS5hbmltYXRpb24uY3VycmVudD17fSxlLnJlbmRlcigpO2Vsc2V7dmFyIG49Zi5lYXNlSW5PdXRDdWJpYyh0KTtmb3IodmFyIHIgaW4gZS5hbmltYXRpb24uY3VycmVudC5hbmltcyl7dmFyIGE9ZS5hbmltYXRpb24uY3VycmVudC5hbmltc1tyXTthWzFdPVtvKGFbMF1bMF0qbiwxMCksbyhhWzBdWzFdKm4sMTApXSxhWzJdJiYoYVsxXT1bYVswXVswXS1hWzFdWzBdLGFbMF1bMV0tYVsxXVsxXV0pfWZvcih2YXIgdSBpbiBlLmFuaW1hdGlvbi5jdXJyZW50LmZhZGluZ3MpZS5hbmltYXRpb25zLmN1cnJlbnQuZmFkaW5nc1t1XS5vcGFjaXR5PW8obiwxMDApO2UucmVuZGVyKCksZFtcImRlZmF1bHRcIl0ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7aShlKX0pfX19ZnVuY3Rpb24gdShlLHQpe3ZhciBuPXtwaWVjZXM6e30sb3BlbnM6e30sbWlkZGxlczp7fX07Zm9yKHZhciByIGluIHQucGllY2VzKXQucGllY2VzW3JdJiYobi5waWVjZXNbcl09e2NvbG9yOnQucGllY2VzW3JdLmNvbG9yLG51bWJlcjp0LnBpZWNlc1tyXS5udW1iZXJ9KTt2YXIgbz1lKCksdT1hKG4sdCk7aWYoT2JqZWN0LmtleXModS5hbmltcykubGVuZ3RoPjB8fHUuZmFkaW5ncy5sZW5ndGg+MCl7dmFyIGw9dC5hbmltYXRpb24uY3VycmVudC5zdGFydDt0LmFuaW1hdGlvbi5jdXJyZW50PXtzdGFydDoobmV3IERhdGUpLmdldFRpbWUoKSxkdXJhdGlvbjp0LmFuaW1hdGlvbi5kdXJhdGlvbixhbmltczp1LmFuaW1zLGZhZGluZ3M6dS5mYWRpbmdzfSxsfHxpKHQpfWVsc2UgdC5yZW5kZXJSQUYoKTtyZXR1cm4gb312YXIgbD1lKFwiLi91dGlsXCIpLGQ9cihsKSxzPWUoXCIuL21vdmVcIiksYz1yKHMpLGY9e2Vhc2VJbk91dEN1YmljOmZ1bmN0aW9uKGUpe3JldHVybiBlPC41PzQqZSplKmU6KGUtMSkqKDIqZS0yKSooMiplLTIpKzF9fTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj1bdF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7aWYodC5hbmltYXRpb24uZW5hYmxlZClyZXR1cm4gdShkW1wiZGVmYXVsdFwiXS5wYXJ0aWFsQXBwbHkoZSxuKSx0KTt2YXIgcj1lLmFwcGx5KG51bGwsbik7cmV0dXJuIHQucmVuZGVyUkFGKCkscn19fSx7XCIuL21vdmVcIjoxMSxcIi4vdXRpbFwiOjE1fV0sNDpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX12YXIgYT1lKFwibWl0aHJpbFwiKSxvPXIoYSksaT1lKFwiLi92aWV3XCIpLHU9cihpKSxsPWUoXCIuL2JvYXJkXCIpLGQ9cihsKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJue2F0dGFjaDpmdW5jdGlvbih0KXtvW1wiZGVmYXVsdFwiXS5yZW5kZXIodCwoMCx1W1wiZGVmYXVsdFwiXSkoZSkpfSxkZXRhY2g6ZnVuY3Rpb24oKXt9LHNldDplLnNldCxnZXRQaWVjZUdyb3VwczpmdW5jdGlvbigpe3JldHVybiBkW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwcyhlLmRhdGEpfSxhcGlNb3ZlOmUuYXBpTW92ZSxhcGlEcmF3TWlkZGxlRW5kOmUuYXBpRHJhd01pZGRsZUVuZCxwbGF5T3BlblNlcmllczplLnBsYXlPcGVuU2VyaWVzLHBsYXlPcGVuUGFpcnM6ZS5wbGF5T3BlblBhaXJzLHN0b3A6ZS5zdG9wLGdldFBpZWNlR3JvdXBTZXJpZXM6ZS5nZXRQaWVjZUdyb3VwU2VyaWVzLGdldFBpZWNlR3JvdXBQYWlyczplLmdldFBpZWNlR3JvdXBQYWlycyxnZXRGZW46ZS5nZXRGZW59fX0se1wiLi9ib2FyZFwiOjUsXCIuL3ZpZXdcIjoxNixtaXRocmlsOjJ9XSw1OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIG8oZSl7aWYoSyhlKSl7dmFyIHQ9ZS5taWRkbGVzW0pbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxuPUgoZSk7aWYobj1uLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4gZWVbXCJkZWZhdWx0XCJdLnNlcmllcyhuLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KSx0KX0pLG4ubGVuZ3RoPjApe3ZhciByPUwobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnBpZWNlc1t0XX0pfSkpO3JldHVybiBzKGUsbiksbmUoSltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLFlbXCJkZWZhdWx0XCJdLm9wZW5TZXJpZXMsdGUocikpKSwhMH19cmV0dXJuITF9ZnVuY3Rpb24gaShlKXtpZihBKGUpKXt2YXIgdD1lLm1pZGRsZXNbSltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdLG49SChlKTtpZihuPW4uZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiBlZVtcImRlZmF1bHRcIl0ucGFpcnMobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSksdCl9KSxuLmxlbmd0aD4wKXt2YXIgcj1MKG4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pKTtyZXR1cm4gZChlLG4pLG5lKEpbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixZW1wiZGVmYXVsdFwiXS5vcGVuUGFpcnMsdGUocikpKSwhMH19cmV0dXJuITF9ZnVuY3Rpb24gdShlLHQpe3ZhciBuPUpbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50O3YoZSxuKSxwKGUsbiksbChlLHQpfWZ1bmN0aW9uIGwoZSx0KXtcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9V1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHQpLnBpZWNlKSxlLm1pZGRsZUhvbGRlci5waWVjZT10LGMoZSl9ZnVuY3Rpb24gZChlLHQpe3ZhciBuPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pLHI9TChuKTtuZShKW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsWVtcImRlZmF1bHRcIl0ub3BlblBhaXJzLHRlKHIpKSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIGUucGllY2VzW3RdfSl9KTt2YXIgYT1lLm9wZW5zLnBhaXJzLmNvbmNhdChuKTtlLm9wZW5zLnBhaXJzPWEsZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBzKGUsdCl7dmFyIG49dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnBpZWNlc1t0XX0pfSkscj1MKG4pO25lKEpbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxZW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzLHRlKHIpKSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIGUucGllY2VzW3RdfSl9KTt2YXIgYT1lLm9wZW5zLnNlcmllcy5jb25jYXQobik7ZS5vcGVucy5zZXJpZXM9YSxlLm9wZW5zLnJlbGF5b3V0KGUpfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9ZS5taWRkbGVIb2xkZXIua2V5LG49ZS5taWRkbGVIb2xkZXIucGllY2U7dCYmbiYmKGUucGllY2VzW3RdPW4sZS5sYXN0TW92ZT1bSltcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdLGUubWlkZGxlSG9sZGVyLmN1cnJlbnQ9ITEsZS5taWRkbGVIb2xkZXIua2V5PW51bGwsZS5taWRkbGVIb2xkZXIucGllY2U9bnVsbCl9ZnVuY3Rpb24gZihlLHQsbil7aWYodD09PW58fCFlLnBpZWNlc1t0XSlyZXR1cm4hMTt2YXIgcj1lLnBpZWNlc1tuXTtyZXR1cm4gZS5waWVjZXNbbl09ZS5waWVjZXNbdF0sZS5waWVjZXNbdF09ciwhMH1mdW5jdGlvbiBwKGUsdCxuKXtpZighbnx8ZS5waWVjZXNbbl0pe3ZhciByPUcoZSk7bj1yfXJldHVybiBuZShKW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsWVtcImRlZmF1bHRcIl0uZHJhd01pZGRsZUVuZCkpLGUubWlkZGxlSG9sZGVyLmtleT1uLGMoZSksITB9ZnVuY3Rpb24gdihlLHQpe3JldHVybiBuZShKW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsWVtcImRlZmF1bHRcIl0uZHJhd01pZGRsZSkpLGUubWlkZGxlc1tKW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0tLSxlLm1pZGRsZUhvbGRlci5jdXJyZW50PSEwLCEwfWZ1bmN0aW9uIG0oZSx0LG4pe3JldHVybiFlLnBpZWNlc1tuXSYmKG5lKEpbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxZW1wiZGVmYXVsdFwiXS5kcmF3TGVmdCkpLGUucGllY2VzW25dPWUuZGlzY2FyZHNbSltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMV1dWzBdLGUuZGlzY2FyZHNbSltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMV1dLnNoaWZ0KCksITApfWZ1bmN0aW9uIGcoZSx0LG4pe2lmKG4mJkpbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodCkmJkpbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkobikmJlMoZSx0LG4pJiZmKGUsdCxuKSlyZXR1cm4hMH1mdW5jdGlvbiBoKGUsdCl7aWYoSltcImRlZmF1bHRcIl0uaXNNaWRkbGVLZXkodCkmJk0oZSx0KSlyZXR1cm4gdihlLHQpLCEwfWZ1bmN0aW9uIHkoZSx0LG4pe2lmKEpbXCJkZWZhdWx0XCJdLmlzTWlkZGxlS2V5KHQpJiZDKGUsdCkpcmV0dXJuIHAoZSx0LG4pLCEwfWZ1bmN0aW9uIHcoZSx0LG4pe2lmKG4mJkpbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkobikmJkpbXCJkZWZhdWx0XCJdLmlzRHJhd0xlZnRLZXkodCkmJkQoZSx0LG4pJiZtKGUsdCxuKSlyZXR1cm4gbmUoSltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLFlbXCJkZWZhdWx0XCJdLmRyYXdMZWZ0KSksITB9ZnVuY3Rpb24gYihlLHQsbil7bnx8KEpbXCJkZWZhdWx0XCJdLmlzTWlkZGxlS2V5KHQpP2goZSx0KSYmayhlLHQpOkpbXCJkZWZhdWx0XCJdLmlzRHJhd0xlZnRLZXkodCkmJkQoZSkmJmsoZSx0KSl9ZnVuY3Rpb24gUChlLHQpe2Uuc2VsZWN0ZWQ/KHQ/ZS5zZWxlY3RlZCE9PXQmJihnKGUsZS5zZWxlY3RlZCx0KXx8dyhlLGUuc2VsZWN0ZWQsdCl8fHkoZSxlLnNlbGVjdGVkLHQpKTp5KGUsZS5zZWxlY3RlZCx0KSxrKGUsbnVsbCkpOngoZSx0KSYmayhlLHQpfWZ1bmN0aW9uIGsoZSx0KXtpZihlLnNlbGVjdGVkPXQsdCYmSltcImRlZmF1bHRcIl0uaXNCb2FyZEtleSh0KSlpZihOKGUsdCkpe3ZhciBuPWUubWlkZGxlc1tKW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV07ZS5vcGVuYWJsZS5kZXN0cz1lZVtcImRlZmF1bHRcIl0uY29tcHV0ZShlLm9wZW5zLGUucGllY2VzW3RdLG4pfWVsc2UgZS5vcGVuYWJsZS5kZXN0cz1bXTtlbHNlIGUub3BlbmFibGUuZGVzdHM9W119ZnVuY3Rpb24gTyhlKXtyZXR1cm4gZS5wb3ZTaWRlPT09ZS50dXJuU2lkZX1mdW5jdGlvbiB4KGUsdCl7dmFyIG49ZS5waWVjZXNbdF07cmV0dXJuIG4mJmUubW92YWJsZS5ib2FyZH1mdW5jdGlvbiBTKGUsdCxuKXtyZXR1cm4gdCE9biYmeChlLHQpfWZ1bmN0aW9uIEUoZSl7cmV0dXJuIE8oZSl9ZnVuY3Rpb24gTShlLHQpe3JldHVybiBFKGUpJiYhZS5taWRkbGVIb2xkZXIuY3VycmVudCYmSltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxZW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlKX1mdW5jdGlvbiBDKGUpe3JldHVybiBlLm1pZGRsZUhvbGRlci5jdXJyZW50fWZ1bmN0aW9uIEQoZSx0LG4pe3JldHVybiBFKGUpJiYhQyhlKSYmSltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxZW1wiZGVmYXVsdFwiXS5kcmF3TGVmdCl9ZnVuY3Rpb24gSyhlKXtyZXR1cm4gTyhlKSYmSltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxZW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzKX1mdW5jdGlvbiBBKGUpe3JldHVybiBPKGUpJiZKW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLFlbXCJkZWZhdWx0XCJdLm9wZW5QYWlycyl9ZnVuY3Rpb24gVChlKXtyZXR1cm4gTyhlKSYmSltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxZW1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuKX1mdW5jdGlvbiBCKGUpe3JldHVybiBPKGUpJiZKW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLFlbXCJkZWZhdWx0XCJdLmNvbGxlY3RPcGVuKX1mdW5jdGlvbiBqKGUpe1AoZSxudWxsKX1mdW5jdGlvbiBSKGUpe2UubW92YWJsZS5zaWRlPW51bGwsZS5tb3ZhYmxlLmRlc3RzPVtdLGUub3BlbmFibGUuZGVzdHM9W10sZS5tb3ZhYmxlLmJvYXJkPSExLGooZSl9ZnVuY3Rpb24gTihlLHQpe3ZhciBuPWUucGllY2VzW3RdO3JldHVybiEoIW58fGUucG92U2lkZSE9PWUudHVyblNpZGUpfWZ1bmN0aW9uIEcoZSl7dmFyIHQ9SltcImRlZmF1bHRcIl0uYWxsQWxsb3dlZEJvYXJkS2V5cy5zbGljZSgxKSxuPUpbXCJkZWZhdWx0XCJdLmFsbEFsbG93ZWRCb2FyZEtleXMuc2xpY2UoMikscj1KW1wiZGVmYXVsdFwiXS5hbGxBbGxvd2VkQm9hcmRLZXlzLm1hcChmdW5jdGlvbihlLHIpe3JldHVybltlLHRbcl0sbltyXV19KS5maWx0ZXIoZnVuY3Rpb24odCl7dmFyIG49eih0LDMpLHI9blswXSxhPW5bMV0sbz1uWzJdO3JldHVybiByJiZhJiZvJiYhZS5waWVjZXNbcl0mJiFlLnBpZWNlc1thXSYmIWUucGllY2VzW29dfSk7cmV0dXJuIHJbci5sZW5ndGgtMV1bMV19ZnVuY3Rpb24gRihlLHQsbixyKXt2YXIgYT1fKGUsdCxuKTtpZighYSlyZXR1cm4gYTt2YXIgbz1KW1wiZGVmYXVsdFwiXS5kZWNCb2FyZEtleShhKTtyZXR1cm4gbyE9PXImJmUucGllY2VzW29dJiYoYT1vKSxKW1wiZGVmYXVsdFwiXS5ub3RBbGxvd2VkQm9hcmRLZXlzLmluZGV4T2YoYSkhPT0tMT9udWxsOmF9ZnVuY3Rpb24gXyhlLHQsbil7aWYobnx8ZS5ib3VuZHMpe249bnx8ZS5ib3VuZHMoKTt2YXIgcj1NYXRoLmZsb29yKEpbXCJkZWZhdWx0XCJdLmNvbHVtbnMqKCh0WzBdLW4ubGVmdCkvbi53aWR0aCkpLGE9TWF0aC5mbG9vcihKW1wiZGVmYXVsdFwiXS5yb3dzKigodFsxXS1uLnRvcCkvbi5oZWlnaHQpKTtyZXR1cm4gYT49MCYmYTxKW1wiZGVmYXVsdFwiXS5yb3dzJiZyPj0wJiZyPEpbXCJkZWZhdWx0XCJdLmNvbHVtbnM/SltcImRlZmF1bHRcIl0ucG9zMmtleShbcixhXSk6dm9pZCAwfX1mdW5jdGlvbiBMKGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUua2V5fSkuam9pbihcIlwiKX0pLmpvaW4oXCIgXCIpfWZ1bmN0aW9uIEkoZSl7dmFyIHQ9ZS5taWRkbGVzW0pbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxuPWUud2l0aFRvcmUscj1xKGUpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZWVbXCJkZWZhdWx0XCJdLnNlcmllcyhlLHQsbil9KTtyZXR1cm4gTChyKX1mdW5jdGlvbiBVKGUpe3ZhciB0PWUubWlkZGxlc1tKW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0sbj1xKGUpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZWVbXCJkZWZhdWx0XCJdLnBhaXJzKGUsdCl9KTtyZXR1cm4gTChuKX1mdW5jdGlvbiBxKGUpe3JldHVybiBIKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSl9KX1mdW5jdGlvbiBIKGUpe3ZhciB0PUpbXCJkZWZhdWx0XCJdLnBvczJrZXkoW0pbXCJkZWZhdWx0XCJdLmNvbHVtbnMtMSwwXSksbj1KW1wiZGVmYXVsdFwiXS5hbGxLZXlzLnNsaWNlKDEpLHI9SltcImRlZmF1bHRcIl0uYWxsS2V5cy5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm5bZSxuW3RdXX0pLnJlZHVjZShmdW5jdGlvbihuLHIpe3ZhciBhPXoobiwyKSxvPWFbMF0saT1hWzFdLHU9eihyLDIpLGw9dVswXSxkPXVbMV07cmV0dXJuIGUucGllY2VzW2xdJiZvLnB1c2gobCksKGwmJiFlLnBpZWNlc1tsXSYmZCYmIWUucGllY2VzW2RdfHxsPT09dCkmJjAhPT1vLmxlbmd0aCYmKGkucHVzaChvKSxvPVtdKSxbbyxpXX0sW1tdLFtdXSksYT16KHIsMiksbz1hWzBdLGk9YVsxXTtyZXR1cm4gMCE9PW8ubGVuZ3RoJiZpLnB1c2gobyksaX12YXIgWCx6PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZhciBuPVtdLHI9ITAsYT0hMSxvPXZvaWQgMDt0cnl7Zm9yKHZhciBpLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShpPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChpLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtyPSEwKTt9Y2F0Y2gobCl7YT0hMCxvPWx9ZmluYWxseXt0cnl7IXImJnVbXCJyZXR1cm5cIl0mJnVbXCJyZXR1cm5cIl0oKX1maW5hbGx5e2lmKGEpdGhyb3cgb319cmV0dXJuIG59cmV0dXJuIGZ1bmN0aW9uKHQsbil7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdDtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpKXJldHVybiBlKHQsbik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9fSgpLCQ9ZShcIi4vdXRpbFwiKSxKPXIoJCksVj1lKFwiLi9tb3ZlXCIpLFk9cihWKSxRPWUoXCIuL3BpZWNlc1wiKSxXPXIoUSksWj1lKFwiLi9vcGVuXCIpLGVlPXIoWiksdGU9SltcImRlZmF1bHRcIl0ud3JhcEdyb3VwLG5lPUpbXCJkZWZhdWx0XCJdLmNhbGxVc2VyRnVuY3Rpb247dC5leHBvcnRzPShYPXtwbGF5T3BlblNlcmllczpvLHBsYXlPcGVuUGFpcnM6aSxhcGlEcmF3TWlkZGxlRW5kOmx9LGEoWCxcImFwaURyYXdNaWRkbGVFbmRcIixsKSxhKFgsXCJhcGlGb3JjZURyYXdNaWRkbGVFbmRcIix1KSxhKFgsXCJhcGlGb3JjZURyYXdNaWRkbGVFbmRcIix1KSxhKFgsXCJ1c2VyTW92ZVwiLGcpLGEoWCxcInVzZXJEcmF3TGVmdFwiLHcpLGEoWCxcInVzZXJCZWdpbkRyYXdNaWRkbGVcIixoKSxhKFgsXCJ1c2VyRW5kRHJhd01pZGRsZVwiLHkpLGEoWCxcInNlbGVjdFNxdWFyZVwiLFApLFxuYShYLFwic2VsZWN0VG9wXCIsYiksYShYLFwic2V0U2VsZWN0ZWRcIixrKSxhKFgsXCJjYW5PcGVuU2VyaWVzXCIsSyksYShYLFwiY2FuT3BlblBhaXJzXCIsQSksYShYLFwiY2FuTGVhdmVUYWtlblwiLFQpLGEoWCxcImNhbkNvbGxlY3RPcGVuXCIsQiksYShYLFwic3RvcFwiLFIpLGEoWCxcImlzRHJvcHBhYmxlT3BlbnNcIixOKSxhKFgsXCJnZXRLZXlBdERvbVBvc1wiLF8pLGEoWCxcImdldEtleUF0RG9tUG9zT25QaWVjZVwiLEYpLGEoWCxcImdldFBpZWNlR3JvdXBzXCIscSksYShYLFwiZ2V0UGllY2VHcm91cFNlcmllc1wiLEkpLGEoWCxcImdldFBpZWNlR3JvdXBQYWlyc1wiLFUpLFgpfSx7XCIuL21vdmVcIjoxMSxcIi4vb3BlblwiOjEyLFwiLi9waWVjZXNcIjoxMyxcIi4vdXRpbFwiOjE1fV0sNjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX12YXIgYT1lKFwibWVyZ2VcIiksbz1yKGEpLGk9ZShcIi4vcGllY2VzXCIpLHU9cihpKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZih0JiYob1tcImRlZmF1bHRcIl0ucmVjdXJzaXZlKGUsdCksZS5mZW4pKXt2YXIgbj11W1wiZGVmYXVsdFwiXS5yZWFkKGUuZmVuKTtlLnBpZWNlcz1uLnBpZWNlcyxlLmRpc2NhcmRzPW4uZGlzY2FyZHMsZS5vcGVucz1uLm9wZW5zLGUubWlkZGxlcz1uLm1pZGRsZXMsZGVsZXRlIGUuZmVufX19LHtcIi4vcGllY2VzXCI6MTMsbWVyZ2U6MX1dLDc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19dmFyIGE9ZShcIi4vdGFibGVcIiksbz1yKGEpLGk9ZShcIi4vYm9hcmRcIiksdT1yKGkpLGw9ZShcIi4vZGF0YVwiKSxkPXIobCkscz1lKFwiLi9jb25maWd1cmVcIiksYz1yKHMpLGY9ZShcIi4vdXRpbFwiKSxwPXIoZiksdj1lKFwiLi9hbmltXCIpLG09cih2KSxnPWUoXCIuL2RyYWdcIiksaD1yKGcpLHk9ZShcIi4vcGllY2VzXCIpLHc9cih5KTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLmRhdGE9KDAsZFtcImRlZmF1bHRcIl0pKGUpLHRoaXMuZ2V0RmVuPWZ1bmN0aW9uKCl7cmV0dXJuIHdbXCJkZWZhdWx0XCJdLndyaXRlKHQuZGF0YS5waWVjZXMpfSx0aGlzLmdldFBpZWNlR3JvdXBTZXJpZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdVtcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFNlcmllcyh0LmRhdGEpfSx0aGlzLmdldFBpZWNlR3JvdXBQYWlycz1mdW5jdGlvbigpe3JldHVybiB1W1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwUGFpcnModC5kYXRhKX0sdGhpcy5zZXQ9KDAsbVtcImRlZmF1bHRcIl0pKGNbXCJkZWZhdWx0XCJdLHRoaXMuZGF0YSksdGhpcy5hcGlNb3ZlPSgwLG1bXCJkZWZhdWx0XCJdKShvW1wiZGVmYXVsdFwiXS5hcGlNb3ZlLHRoaXMuZGF0YSksdGhpcy5hcGlEcmF3TWlkZGxlRW5kPSgwLG1bXCJkZWZhdWx0XCJdKSh1W1wiZGVmYXVsdFwiXS5hcGlEcmF3TWlkZGxlRW5kLHRoaXMuZGF0YSksdGhpcy5wbGF5T3BlblNlcmllcz0oMCxtW1wiZGVmYXVsdFwiXSkodVtcImRlZmF1bHRcIl0ucGxheU9wZW5TZXJpZXMsdGhpcy5kYXRhKSx0aGlzLnBsYXlPcGVuUGFpcnM9KDAsbVtcImRlZmF1bHRcIl0pKHVbXCJkZWZhdWx0XCJdLnBsYXlPcGVuUGFpcnMsdGhpcy5kYXRhKSx0aGlzLmNhbkxlYXZlVGFrZW49cFtcImRlZmF1bHRcIl0ucGFydGlhbCh1W1wiZGVmYXVsdFwiXS5jYW5MZWF2ZVRha2VuLHRoaXMuZGF0YSksdGhpcy5jYW5Db2xsZWN0T3Blbj1wW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKHVbXCJkZWZhdWx0XCJdLmNhbkNvbGxlY3RPcGVuLHRoaXMuZGF0YSksdGhpcy5jYW5PcGVuU2VyaWVzPXBbXCJkZWZhdWx0XCJdLnBhcnRpYWwodVtcImRlZmF1bHRcIl0uY2FuT3BlblNlcmllcyx0aGlzLmRhdGEpLHRoaXMuY2FuT3BlblBhaXJzPXBbXCJkZWZhdWx0XCJdLnBhcnRpYWwodVtcImRlZmF1bHRcIl0uY2FuT3BlblBhaXJzLHRoaXMuZGF0YSksdGhpcy5zdG9wPSgwLG1bXCJkZWZhdWx0XCJdKShmdW5jdGlvbihlKXt1W1wiZGVmYXVsdFwiXS5zdG9wKGUpLGhbXCJkZWZhdWx0XCJdLmNhbmNlbChlKX0sdGhpcy5kYXRhKX19LHtcIi4vYW5pbVwiOjMsXCIuL2JvYXJkXCI6NSxcIi4vY29uZmlndXJlXCI6NixcIi4vZGF0YVwiOjgsXCIuL2RyYWdcIjo5LFwiLi9waWVjZXNcIjoxMyxcIi4vdGFibGVcIjoxNCxcIi4vdXRpbFwiOjE1fV0sODpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX12YXIgYT1lKFwibWVyZ2VcIiksbz0ocihhKSxlKFwiLi9waWVjZXNcIikpLGk9cihvKSx1PWUoXCIuL2NvbmZpZ3VyZVwiKSxsPXIodSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PXtwb3ZTaWRlOlwiZWFzdFwiLHR1cm5TaWRlOlwiZWFzdFwiLGxhc3RNb3ZlOm51bGwsd2l0aFRvcmU6ITEscGllY2VzOmlbXCJkZWZhdWx0XCJdLnJlYWRCb2FyZChpW1wiZGVmYXVsdFwiXS5taXhlZCksZGlzY2FyZHM6aVtcImRlZmF1bHRcIl0ucmVhZERpc2NhcmRzKGlbXCJkZWZhdWx0XCJdLmluaXRpYWxEaXNjYXJkcyxcImVhc3RcIiksb3BlbnM6aVtcImRlZmF1bHRcIl0ucmVhZE9wZW5Hcm91cHMoaVtcImRlZmF1bHRcIl0uaW5pdGlhbE9wZW5Hcm91cHMpLG1pZGRsZXM6aVtcImRlZmF1bHRcIl0ucmVhZE1pZGRsZXMoaVtcImRlZmF1bHRcIl0uaW5pdGlhbE1pZGRsZXMpLHNlbGVjdGVkOm51bGwsbWlkZGxlSG9sZGVyOntjdXJyZW50OiExLGtleTpudWxsLHBpZWNlOm51bGx9LGFuaW1hdGlvbjp7ZW5hYmxlZDohMCxkdXJhdGlvbjo1MDAsY3VycmVudDp7fX0sZHJhZ2dhYmxlOntlbmFibGVkOiEwLGRpc3RhbmNlOjMsY3VycmVudDp7fX0sbW92YWJsZTp7Ym9hcmQ6ITAsZnJlZTohMCxldmVudHM6e2FmdGVyOmZ1bmN0aW9uKGUsdCl7fX19LG9wZW5hYmxlOntkZXN0czpbXX0sZXZlbnRzOnttb3ZlOmZ1bmN0aW9uKGUsdCl7fX19O3JldHVybigwLGxbXCJkZWZhdWx0XCJdKSh0LGV8fHt9KSx0fX0se1wiLi9jb25maWd1cmVcIjo2LFwiLi9waWVjZXNcIjoxMyxtZXJnZToxfV0sOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUsdCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106Z1tcImRlZmF1bHRcIl0ucm93cyxhPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTpnW1wiZGVmYXVsdFwiXS5jb2x1bW5zO3JldHVybntsZWZ0OnQubGVmdCt0LndpZHRoKm5bMF0vYSx0b3A6dC50b3ArdC5oZWlnaHQqblsxXS9yLHdpZHRoOnQud2lkdGgvYSxoZWlnaHQ6dC5oZWlnaHQvcn19ZnVuY3Rpb24gbyhlLHQpe2lmKHZvaWQgMD09PXQuYnV0dG9ufHwwPT09dC5idXR0b24pe3Quc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLHM9dC50YXJnZXQ7dmFyIG49ZS5zZWxlY3RlZCxyPWdbXCJkZWZhdWx0XCJdLmV2ZW50UG9zaXRpb24odCksbz1lLmJvYXJkQm91bmRzKCksdT1lLm9wZW5zQm91bmRzKCksbD1lLnRvcEJvdW5kcygpLGQ9ZltcImRlZmF1bHRcIl0uZ2V0S2V5QXREb21Qb3NPblBpZWNlKGUscixvKTtmW1wiZGVmYXVsdFwiXS5zZWxlY3RTcXVhcmUoZSxkKSxkfHwoZD12W1wiZGVmYXVsdFwiXS5nZXREcmF3S2V5QXREb21Qb3MoZSxyLGwpKSYmZltcImRlZmF1bHRcIl0uc2VsZWN0VG9wKGUsZCxuKSwhZCYmbiYmKChkPXZbXCJkZWZhdWx0XCJdLmdldE9wZW5zS2V5QXREb21Qb3MoZSxyLHUpKT92W1wiZGVmYXVsdFwiXS5kcm9wT3BlbnMoZSxuLGQpOihkPXZbXCJkZWZhdWx0XCJdLmdldERpc2NhcmRLZXlBdERvbVBvcyhlLHIsbCkpJiZ2W1wiZGVmYXVsdFwiXS5kcm9wVG9wKGUsbixkKSk7dmFyIGM9ZS5zZWxlY3RlZD09PWQ7aWYoYyYmdltcImRlZmF1bHRcIl0uaXNEcmFnZ2FibGUoZSxkKSl7dmFyIHA9Z1tcImRlZmF1bHRcIl0uaXNCb2FyZEtleShkKT9hKGUsbyxnW1wiZGVmYXVsdFwiXS5rZXkycG9zKGQpKTphKGUsbCxnW1wiZGVmYXVsdFwiXS50b3BLZXkycG9zKGQpLGdbXCJkZWZhdWx0XCJdLnRvcFJvd3MsZ1tcImRlZmF1bHRcIl0udG9wQ29sdW1ucyk7ZS5kcmFnZ2FibGUuY3VycmVudD17b3JpZzpkLHJlbDpyLGVwb3M6cixwb3M6WzAsMF0sZGVjOltyWzBdLShwLmxlZnQrcC53aWR0aC8yKSxyWzFdLShwLnRvcCtwLmhlaWdodC8yKV0sYm9hcmRCb3VuZHM6byxvcGVuc0JvdW5kczp1LHRvcEJvdW5kczpsLHN0YXJ0ZWQ6ITF9fWkoZSl9fWZ1bmN0aW9uIGkoZSl7Z1tcImRlZmF1bHRcIl0ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5kcmFnZ2FibGUuY3VycmVudDt0Lm9yaWcmJighdC5zdGFydGVkJiZnW1wiZGVmYXVsdFwiXS5kaXN0YW5jZSh0LmVwb3MsdC5yZWwpPj1lLmRyYWdnYWJsZS5kaXN0YW5jZSYmKHQuc3RhcnRlZD0hMCksdC5zdGFydGVkJiYodC5wb3M9W3QuZXBvc1swXS10LnJlbFswXSx0LmVwb3NbMV0tdC5yZWxbMV1dLHQub3Zlcj1mW1wiZGVmYXVsdFwiXS5nZXRLZXlBdERvbVBvc09uUGllY2UoZSx0LmVwb3MsdC5ib2FyZEJvdW5kcyx0Lm9yaWcpLCF0Lm92ZXImJmdbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodC5vcmlnKSYmKHQub3Zlcj12W1wiZGVmYXVsdFwiXS5nZXRPcGVuc0tleUF0RG9tUG9zKGUsdC5lcG9zLHQub3BlbnNCb3VuZHMpfHx2W1wiZGVmYXVsdFwiXS5nZXREaXNjYXJkS2V5QXREb21Qb3MoZSx0LmVwb3MsdC50b3BCb3VuZHMpKSkpLGUucmVuZGVyKCksdC5vcmlnJiZpKGUpfSl9ZnVuY3Rpb24gdShlLHQpe2UuZHJhZ2dhYmxlLmN1cnJlbnQub3JpZyYmKGUuZHJhZ2dhYmxlLmN1cnJlbnQuZXBvcz1nW1wiZGVmYXVsdFwiXS5ldmVudFBvc2l0aW9uKHQpKX1mdW5jdGlvbiBsKGUsdCl7dmFyIG49ZS5kcmFnZ2FibGUscj1uLmN1cnJlbnQ/bi5jdXJyZW50Lm9yaWc6bnVsbDtpZihyKXt2YXIgYT1uLmN1cnJlbnQub3ZlcjtuLmN1cnJlbnQuc3RhcnRlZCYmKGZbXCJkZWZhdWx0XCJdLnNldFNlbGVjdGVkKGUsbnVsbCksZltcImRlZmF1bHRcIl0udXNlck1vdmUoZSxyLGEpfHx2W1wiZGVmYXVsdFwiXS5kcm9wT3BlbnMoZSxyLGEpfHx2W1wiZGVmYXVsdFwiXS5kcm9wVG9wKGUscixhKXx8ZltcImRlZmF1bHRcIl0udXNlckRyYXdMZWZ0KGUscixhKXx8ZltcImRlZmF1bHRcIl0udXNlckVuZERyYXdNaWRkbGUoZSxyLGEpKSxuLmN1cnJlbnQ9e319fWZ1bmN0aW9uIGQoZSl7ZS5kcmFnZ2FibGUuY3VycmVudC5vcmlnJiYoZS5kcmFnZ2FibGUuY3VycmVudD17fSxmW1wiZGVmYXVsdFwiXS5zZWxlY3RTcXVhcmUoZSxudWxsKSl9dmFyIHMsYz1lKFwiLi9ib2FyZFwiKSxmPXIoYykscD1lKFwiLi90YWJsZVwiKSx2PXIocCksbT1lKFwiLi91dGlsXCIpLGc9cihtKTt0LmV4cG9ydHM9e3N0YXJ0Om8sbW92ZTp1LGVuZDpsLGNhbmNlbDpkfX0se1wiLi9ib2FyZFwiOjUsXCIuL3RhYmxlXCI6MTQsXCIuL3V0aWxcIjoxNX1dLDEwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSl7dmFyIHQ9bmV3IGlbXCJkZWZhdWx0XCJdKGUpO3JldHVybigwLGZbXCJkZWZhdWx0XCJdKSh0KX12YXIgbz1lKFwiLi9jdHJsXCIpLGk9cihvKSx1PWUoXCIuL3V0aWxcIiksbD1yKHUpLGQ9ZShcIi4vbW92ZVwiKSxzPXIoZCksYz1lKFwiLi9hcGlcIiksZj1yKGMpO3QuZXhwb3J0cz1hLHQuZXhwb3J0cy5jb250cm9sbGVyPWlbXCJkZWZhdWx0XCJdLHQuZXhwb3J0cy51dGlsPWxbXCJkZWZhdWx0XCJdLHQuZXhwb3J0cy5tb3ZlPXNbXCJkZWZhdWx0XCJdfSx7XCIuL2FwaVwiOjQsXCIuL2N0cmxcIjo3LFwiLi9tb3ZlXCI6MTEsXCIuL3V0aWxcIjoxNX1dLDExOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9XCJkbVwiLGE9XCJkbFwiLG89XCJkZFwiLGk9XCJsdFwiLHU9XCJzc1wiLGw9XCJvc1wiLGQ9XCJvcFwiLHM9XCJjb1wiLGM9XCJkb3NcIixmPVwiZG9wXCIscD1cImRkc1wiLHY9XCJkZHBcIixtPVwibFwiLGc9XCJyXCIsaD1cInBcIjt0LmV4cG9ydHM9e2RyYXdNaWRkbGU6cixkcmF3TGVmdDphLGRpc2NhcmQ6byxsZWF2ZVRha2VuOmksc2lnbjp1LG9wZW5TZXJpZXM6bCxvcGVuUGFpcnM6ZCxjb2xsZWN0T3BlbjpzLGRyb3BPcGVuU2VyaWVzOmMsZHJvcE9wZW5QYWlyczpmLGRyb3BMZWZ0Om0sZHJvcFJpZ2h0OmcsZHJvcFJlcGxhY2U6aCxkaXNjYXJkRW5kU2VyaWVzOnAsZGlzY2FyZEVuZFBhaXJzOnZ9fSx7fV0sMTI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlLHQpe3JldHVybiBlLmxlbmd0aD09PXQubGVuZ3RoJiZlLmV2ZXJ5KGZ1bmN0aW9uKGUsbil7cmV0dXJuIGU9PT10W25dfSl9ZnVuY3Rpb24gbyhlLHQpe3JldHVybiB0LmV2ZXJ5KGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQuY29sb3I9PT1lW25dfSl9ZnVuY3Rpb24gaShlLHQpe2lmKGUubGVuZ3RoPDMpcmV0dXJuITE7dmFyIG49ZS5sZW5ndGgscj1lWzBdLmNvbG9yLG89ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUua2V5fSksaT1vLnNsaWNlKDApLnJldmVyc2UoKSx1PWhbXCJkZWZhdWx0XCJdLnNlcmllc0J5Q29sb3Iocik7dCYmKHU9dS5zbGljZSgwKSx1LnB1c2godVswXSkpO2Zvcih2YXIgbD0wO2w8PXUubGVuZ3RoLW47bCsrKXt2YXIgZD11LnNsaWNlKGwsbCtuKTtpZihhKGQsbyl8YShkLGkpKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHUoZSl7dmFyIHQ9ZS5sZW5ndGgsbj1lWzBdLm51bWJlcjtyZXR1cm4hISgzPT09dHw0PT09dCkmJighIWUuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIGUubnVtYmVyPT09bn0pJiZ5LnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIG8odC5zbGljZSgwLGUubGVuZ3RoKSxlKX0pKX1mdW5jdGlvbiBsKGUsdCl7dmFyIG49aFtcImRlZmF1bHRcIl0ubWFrZVBpZWNlKHQuYyx0Lm4pO3JldHVybiBuLmlzRmFrZT0hMCxoW1wiZGVmYXVsdFwiXS5waWVjZUZha2UoZSk/bjplfWZ1bmN0aW9uIGQoZSx0KXtyZXR1cm4hZS5pc0Zha2UmJmUua2V5PT09dC5rZXl9ZnVuY3Rpb24gcyhlLHQpe2Z1bmN0aW9uIG4oZSx0KXtyZXR1cm4gZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaW5kZXhPZihlKTwwfSl9ZnVuY3Rpb24gcihlLHQpe3JldHVybiBlLmtleT09PXQua2V5fWZ1bmN0aW9uIGEoZSx0KXt2YXIgcj1bXCJyXCIsXCJnXCIsXCJiXCIsXCJsXCJdLGE9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIWQoZSx0KX0pLG89bihyLGEubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmN9KSk7aWYoby5sZW5ndGg8MSlyZXR1cm4gZTtpZihhLmxlbmd0aDwxKXJldHVybiBlO2lmKCEoYS5sZW5ndGg8ZS5sZW5ndGgpKXJldHVybiBlO3ZhciBpPW9bMF0sdT1hWzBdLm4sbD1oW1wiZGVmYXVsdFwiXS5tYWtlUGllY2UoaSx1KTtyZXR1cm4gYS5wdXNoKGwpLGF9ZnVuY3Rpb24gbyhlLHQpe3ZhciBuO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gZTtpZihlLmxlbmd0aDwzKXJldHVybiBlO3ZhciBhPW0oZSwzKSxpPWFbMF0sdT1hWzFdLGw9YVsyXSxzPVtpLHUsbF07aWYobj1lLnNsaWNlKDMsZS5sZW5ndGgpLGQoaSx0KSlyKGhbXCJkZWZhdWx0XCJdLnBpZWNlVXAodSksbCk/cz1baFtcImRlZmF1bHRcIl0ucGllY2VEb3duKHUpLHUsbF06cihoW1wiZGVmYXVsdFwiXS5waWVjZURvd24odSksbCkmJihzPVtoW1wiZGVmYXVsdFwiXS5waWVjZVVwKHUpLHUsbF0pO2Vsc2UgaWYoZCh1LHQpKXIoaFtcImRlZmF1bHRcIl0ucGllY2VVcChoW1wiZGVmYXVsdFwiXS5waWVjZVVwKGkpKSxsKT9zPVtpLGhbXCJkZWZhdWx0XCJdLnBpZWNlVXAoaSksbF06cihoW1wiZGVmYXVsdFwiXS5waWVjZURvd24oaFtcImRlZmF1bHRcIl0ucGllY2VEb3duKGkpKSxsKSYmKHM9W2ksaFtcImRlZmF1bHRcIl0ucGllY2VEb3duKGkpLGxdKTtlbHNle2lmKCFkKGwsdCkpcmV0dXJuIG49byhlLnNsaWNlKDEsZS5sZW5ndGgpLHQpLG4udW5zaGlmdChlWzBdKSxuO3IoaFtcImRlZmF1bHRcIl0ucGllY2VVcChpKSx1KT9zPVtpLHUsaFtcImRlZmF1bHRcIl0ucGllY2VVcCh1KV06cihoW1wiZGVmYXVsdFwiXS5waWVjZURvd24oaSksdSkmJihzPVtpLHUsaFtcImRlZmF1bHRcIl0ucGllY2VEb3duKHUpXSl9cmV0dXJuIHMuY29uY2F0KG4pfWZ1bmN0aW9uIGkoZSx0KXtpZigyIT1lLmxlbmd0aClyZXR1cm4gZTt2YXIgbj1tKGUsMikscj1uWzBdLGE9blsxXTtyZXR1cm4gZChyLHQpP1thLGFdOmQoYSx0KT9bcixyXTplfWlmKGUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBkKGUsdCl9KS5sZW5ndGg+MSlyZXR1cm4gZTtpZihlLmxlbmd0aDwzKXJldHVybiBpKGUsdCk7dmFyIHU9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIWQoZSx0KX0pO3JldHVybiB1LmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlLm49PT11WzBdLm59KT9hKGUsdCk6dS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZS5jPT09dVswXS5jfSk/byhlLHQpOmV9ZnVuY3Rpb24gYyhlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0scj1oW1wiZGVmYXVsdFwiXS5waWVjZVVwKHQpLGE9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGwoZSxyKX0pLG89cyhhLHIpO3JldHVybiBpKG8sbil8dShvKX1mdW5jdGlvbiBmKGUsdCl7aWYoMiE9PWUubGVuZ3RoKXJldHVybiExO3ZhciBuPWhbXCJkZWZhdWx0XCJdLnBpZWNlVXAodCkscj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbChlLG4pfSksYT1zKHIsbiksbz1tKGEsMiksaT1vWzBdLHU9b1sxXTtyZXR1cm4gaS5rZXk9PT11LmtleX1mdW5jdGlvbiBwKGUsdCxuKXt2YXIgcj1bXSxhPWhbXCJkZWZhdWx0XCJdLnBpZWNlVXAobik7cmV0dXJuIHQ9bCh0LGEpLGUuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24obyxpKXt2YXIgdT1vLnNsaWNlKDApLGw9by5zbGljZSgwKTt1LnNwbGljZSgwLDAsdCksbC5zcGxpY2Uoby5sZW5ndGgsMCx0KSxjKHUsbikmJnIucHVzaChoW1wiZGVmYXVsdFwiXS5nZXRPcGVuU2VyaWVLZXlGcm9tR3JvdXBJbmRleChlLGksMCkpLGMobCxuKSYmci5wdXNoKGhbXCJkZWZhdWx0XCJdLmdldE9wZW5TZXJpZUtleUZyb21Hcm91cEluZGV4KGUsaSxvLmxlbmd0aCsxKSk7dmFyIHM9by5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGQoZSxhKT90OmV9KTtpZihjKHMsbikpe3ZhciBmO28uZm9yRWFjaChmdW5jdGlvbihlLHQpe2QoZSxhKSYmKGY9dCl9KSxyLnB1c2goaFtcImRlZmF1bHRcIl0uZ2V0T3BlblNlcmllS2V5RnJvbUdyb3VwSW5kZXgoZSxpLGYrMSkpfX0pLGUucGFpcnMuZm9yRWFjaChmdW5jdGlvbihvLGkpe3ZhciB1PW8ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBkKGUsYSk/dDplfSk7aWYoZih1LG4pKXt2YXIgbD12KG8sYSk7ci5wdXNoKGhbXCJkZWZhdWx0XCJdLmdldE9wZW5QYWlyS2V5RnJvbUdyb3VwSW5kZXgoZSxpLGwpKX19KSxyfWZ1bmN0aW9uIHYoZSx0KXt2YXIgbjtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUscil7ZChlLHQpJiYobj1yKX0pLG59T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49W10scj0hMCxhPSExLG89dm9pZCAwO3RyeXtmb3IodmFyIGksdT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGk9dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGkudmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaChsKXthPSEwLG89bH1maW5hbGx5e3RyeXshciYmdVtcInJldHVyblwiXSYmdVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYoYSl0aHJvdyBvfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24odCxuKXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0O2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCkpcmV0dXJuIGUodCxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksZz1lKFwiLi9waWVjZXNcIiksaD1yKGcpLHk9ZnVuY3Rpb24oKXt2YXIgZT1oW1wiZGVmYXVsdFwiXS5jb2xvcnMsdD1bXTtmb3IodmFyIG4gaW4gZSlmb3IodmFyIHIgaW4gZSlmb3IodmFyIGEgaW4gZSlmb3IodmFyIG8gaW4gZSluIT09ciYmbiE9PWEmJm4hPT1vJiZyIT09YSYmciE9PW8mJmEhPT1vJiZ0LnB1c2goW2Vbbl0sZVtyXSxlW2FdLGVbb11dKTtyZXR1cm4gdH0oKTtuW1wiZGVmYXVsdFwiXT17Y29tcHV0ZTpwLHNlcmllczpjLHBhaXJzOmYsZmluZE9rZXlJbmRleDp2fSx0LmV4cG9ydHM9bltcImRlZmF1bHRcIl19LHtcIi4vcGllY2VzXCI6MTN9XSwxMzpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBBKXQucHVzaChrKGUsbikua2V5KTtyZXR1cm4gdH1mdW5jdGlvbiBvKGUpe3ZhciB0PXswOjAsMToxLDI6MiwzOjMsNDo0LDU6NSw2OjYsNzo3LDg6OCw5Ojl9LG49dFtlWzBdXSxyPXRbZVsxXV07cmV0dXJuIHZvaWQgMD09PXI/dm9pZCAwPT09bj97bGVmdDplLnNsaWNlKDEpfTp7bnVtYmVyOm4sbGVmdDplLnNsaWNlKDEpfTp7bnVtYmVyOjEwKm4rcixsZWZ0OmUuc2xpY2UoMil9fWZ1bmN0aW9uIGkoZSl7dmFyIHQ9LyhbbHxyfHBdKShcXGRcXGQ/KS8sbj1lLm1hdGNoKHQpLHI9blsxXSxhPXBhcnNlSW50KG5bMl0pO3JldHVybnt0eXBlOnIsZ3JvdXBJbmRleDphfX1mdW5jdGlvbiB1KGUpe3ZhciB0PWVbMF0sbj1lWzFdLHI9ZVsyXSxhPTI7cmV0dXJuIEtbdF0/KEFbbityXSYmKG4rPXIsYT0zKSx7cGllY2U6ayh0LG4pLGxlZnQ6ZS5zbGljZShhKX0pOntsZWZ0OmUuc2xpY2UoMSl9fWZ1bmN0aW9uIGwoZSl7dmFyIHQ9W10sbj1bXTtmb3IoZSs9XCJcXG5cIjtlLmxlbmd0aD4wOyl7dmFyIHI9dShlKTtyLnBpZWNlP24ucHVzaChyLnBpZWNlKToobi5sZW5ndGg+MCYmdC5wdXNoKG4pLG49W10pLGU9ci5sZWZ0fXJldHVybiB0fWZ1bmN0aW9uIGQoZSl7Zm9yKHZhciB0PVtdLG49MDtlLmxlbmd0aD4wOyl7dmFyIHI9dShlKTtyLnBpZWNlJiYodFtuXT1yLnBpZWNlKSxuKyssZT1yLmxlZnR9cmV0dXJuIHR9ZnVuY3Rpb24gcyhlKXt2YXIgdD17fTtlPWQoZSk7Zm9yKHZhciBuPTAscj0wO3I8ZS5sZW5ndGg7cisrKXtpZihlW3JdKXtmb3IoO248MTAwJiYhRFtcImRlZmF1bHRcIl0uaXNBbGxvd2VkQm9hcmRLZXkoRFtcImRlZmF1bHRcIl0uZW5jb2RlS2V5KG4sXCJiXCIpKTspbisrO3RbRFtcImRlZmF1bHRcIl0uZW5jb2RlS2V5KG4sXCJiXCIpXT1lW3JdLG4rK31uKyt9cmV0dXJuIHR9ZnVuY3Rpb24gYyhlLHQpe2U9ZS5zcGxpdChcIiBcIik7dmFyIG49e307cmV0dXJuIERbXCJkZWZhdWx0XCJdLmFsbFNpZGVzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gRFtcImRlZmF1bHRcIl0uZmluZFBvdih0LGUpfSkuZm9yRWFjaChmdW5jdGlvbih0LHIpe3ZhciBhPWQoZVtyXXx8XCJcIik7bltEW1wiZGVmYXVsdFwiXS5kaXNjYXJkQnlQb3YodCldPWF9KSxufWZ1bmN0aW9uIGYoZSl7dmFyIHQ9ZS5zcGxpdChcIi9cIiksbj1NKHQsMikscj1uWzBdLGE9blsxXTtyPWwociksYT1sKGEpO3ZhciBvPXAocixhKTtyZXR1cm57c2VyaWVzOnIscGFpcnM6YSxsYXlvdXQ6byxyZWxheW91dDpmdW5jdGlvbihlKXtlLm9wZW5zLmxheW91dD1wKGUub3BlbnMuc2VyaWVzLGUub3BlbnMucGFpcnMpfX19ZnVuY3Rpb24gcChlLHQpe3ZhciBuLHIsYSxvLGksdT17fSxsPXtzZXJpZXM6e30scGFpcnM6e319LGQ9W10scz0wO2ZvcihuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBjPWVbbl07bz0oZFtzXXx8MSktMSxpPXMsbC5zZXJpZXNbRFtcImRlZmF1bHRcIl0ubWluaVBvczJrZXkoW28saV0pXT1uO2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKWE9ZFtzXXx8MSxyPURbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFthLHNdKSx1W3JdPWNbZl0sZFtzXT1hKzE7ZFtzXSs9MixzKysscz49RFtcImRlZmF1bHRcIl0ubWluaVJvd3MmJihzPTApfWZvcihkPVtdLG49MCxmPTAscj0wLGE9MCxzPTAsbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcD10W25dO2ZvcihvPShkW3NdfHxEW1wiZGVmYXVsdFwiXS5taW5pQ29sdW1ucy0xKS0xLGk9cyxsLnBhaXJzW0RbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFtvLGldKV09bixmPXAubGVuZ3RoLTE7Zj49MDtmLS0pYT1kW3NdfHxEW1wiZGVmYXVsdFwiXS5taW5pQ29sdW1ucy0xLHI9RFtcImRlZmF1bHRcIl0ubWluaVBvczJrZXkoW2Esc10pLHVbcl09cFtmXSxkW3NdPWEtMTtkW3NdLT0xLHMrKyxzPj1EW1wiZGVmYXVsdFwiXS5taW5pUm93cyYmKHM9MCl9cmV0dXJue2xheW91dDp1LGdyb3VwTWFwOmx9fWZ1bmN0aW9uIHYoZSx0LG4pe2Zvcih2YXIgciBpbiBlKWlmKGVbcl09PT10KXt2YXIgYT1EW1wiZGVmYXVsdFwiXS5taW5pS2V5MnBvcyhyKSxvPU0oYSwyKSxpPW9bMF0sdT1vWzFdLGw9W2krbix1XTtyZXR1cm4gRFtcImRlZmF1bHRcIl0ubWluaVBvczJrZXkobCl9fWZ1bmN0aW9uIG0oZSx0LG4pe3ZhciByPWUubGF5b3V0Lmdyb3VwTWFwLnBhaXJzO3JldHVybiB2KHIsdCxuKX1mdW5jdGlvbiBnKGUsdCxuKXt2YXIgcj1lLmxheW91dC5ncm91cE1hcC5zZXJpZXM7cmV0dXJuIHYocix0LG4pfWZ1bmN0aW9uIGgoZSx0KXt2YXIgbj1lLm9wZW5zLHI9bi5zZXJpZXMsYT1uLmxheW91dC5ncm91cE1hcCxvPU0odCwyKSxpPW9bMF0sdT1vWzFdO2Zvcih2YXIgbCBpbiBhLnNlcmllcyl7dmFyIGQ9YS5zZXJpZXNbbF0scz1yW2RdLGM9RFtcImRlZmF1bHRcIl0ubWluaUtleTJwb3MobCksZj1NKGMsMikscD1mWzBdLHY9ZlsxXSxtPWktcDtpZighKG08MHx8bT5zLmxlbmd0aCsxfHx1IT12KSlyZXR1cm5bZCxtXX19ZnVuY3Rpb24geShlLHQpe3ZhciBuPWUub3BlbnMscj1uLnBhaXJzLGE9bi5sYXlvdXQuZ3JvdXBNYXAsbz1NKHQsMiksaT1vWzBdLHU9b1sxXTtmb3IodmFyIGwgaW4gYS5wYWlycyl7dmFyIGQ9YS5wYWlyc1tsXSxzPShyW2RdLERbXCJkZWZhdWx0XCJdLm1pbmlLZXkycG9zKGwpKSxjPU0ocywyKSxmPWNbMF0scD1jWzFdLHY9aS1mO2lmKCEodjwwfHx2PjF8fHUhPXApKXJldHVybltkLHZdfX1mdW5jdGlvbiB3KGUpe3ZhciB0PXt9LG49byhlKTtyZXR1cm4gdFtEW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF09bi5udW1iZXIsbj11KG4ubGVmdCksdFtEW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV09bi5waWVjZSx0fWZ1bmN0aW9uIGIoZSl7ZT1lLnNwbGl0KFwiL1wiKTt2YXIgdD0yLG49MyxyPTQsYT0xLG89MCxpPXtlOlwiZWFzdFwiLHc6XCJ3ZXN0XCIsbjpcIm5vcnRoXCIsczpcInNvdXRoXCJ9W2Vbb11dO3JldHVybntwaWVjZXM6cyhlW3RdKSxkaXNjYXJkczpjKGVbbl0saSksb3BlbnM6ZihbZVtyXSxlW3IrMV1dLmpvaW4oXCIvXCIpKSxtaWRkbGVzOncoZVthXSl9fWZ1bmN0aW9uIFAoZSl7dmFyIHQ9RFtcImRlZmF1bHRcIl0uYWxsS2V5cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUua2V5fHxcIiBcIn0pLmpvaW4oXCJcIik7cmV0dXJuIHQucmVwbGFjZSgvKFteXFxzXSlcXHMvZyxcIiQxXCIpfWZ1bmN0aW9uIGsoZSx0KXtyZXR1cm57Y29sb3I6S1tlXSxudW1iZXI6QVt0XSxjOmUsbjpwYXJzZUludCh0KSxrZXk6ZSt0fX1mdW5jdGlvbiBPKGUpe3ZhciB0PWUuYyxuPWUubiUxMysxO3JldHVybiBrKHQsbil9ZnVuY3Rpb24geChlKXt2YXIgdD1lLmMsbj0oZS5uKzExKSUxMysxO3JldHVybiBrKHQsbil9ZnVuY3Rpb24gUyhlKXtyZXR1cm5cImZha2VcIj09PWUuY29sb3J9ZnVuY3Rpb24gRShlKXtyZXR1cm4gZS5sZW5ndGg+MCYmMTQ9PT1lLm1hdGNoKFQpLmxlbmd0aH12YXIgTT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt2YXIgbj1bXSxyPSEwLGE9ITEsbz12b2lkIDA7dHJ5e2Zvcih2YXIgaSx1PWVbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oaT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goaS52YWx1ZSksIXR8fG4ubGVuZ3RoIT09dCk7cj0hMCk7fWNhdGNoKGwpe2E9ITAsbz1sfWZpbmFsbHl7dHJ5eyFyJiZ1W1wicmV0dXJuXCJdJiZ1W1wicmV0dXJuXCJdKCl9ZmluYWxseXtpZihhKXRocm93IG99fXJldHVybiBufXJldHVybiBmdW5jdGlvbih0LG4pe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQ7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KSlyZXR1cm4gZSh0LG4pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0oKSxDPWUoXCIuL3V0aWxcIiksRD1yKEMpLEs9e2I6XCJibHVlXCIscjpcInJlZFwiLGc6XCJncmVlblwiLGw6XCJibGFja1wiLGY6XCJmYWtlXCJ9LEE9ezE6XCJvbmVcIiwyOlwidHdvXCIsMzpcInRocmVlXCIsNDpcImZvdXJcIiw1OlwiZml2ZVwiLDY6XCJzaXhcIiw3Olwic2V2ZW5cIiw4OlwiZWlnaHRcIiw5OlwibmluZVwiLDEwOlwidGVuXCIsMTE6XCJlbGV2ZW5cIiwxMjpcInR3ZWx2ZVwiLDEzOlwidGhpcnRlZW5cIn0sVD0vW2Z8cnxsfGJ8Z11cXGRcXGQ/L2csQj1mdW5jdGlvbigpe3ZhciBlPXt9O2Zvcih2YXIgdCBpbiBLKWVbS1t0XV09YSh0KTtyZXR1cm4gZX0oKSxqPWZ1bmN0aW9uKGUpe3JldHVybiBCW2VdfSxSPVwiZzdyN2I3bDcgZzhyOGI4bDggZzEzcjEzYjEzbDEzIGwxMiByNnI1cjRyMTJyMTMgZzlnOGcxMyBnNiBsOGw3bDEyXCIsTj1cInIxZzFsMWIxIHIyZzJsMmIyIHIzZzNsM2IzIHI0ZzRsNGI0IHIxM2cxM2wxM2IxMyByMWcxbDFiMVwiLEc9XCJyMXIyIHIzcjRyNXI2cjdyOHI5cjEwcjExcjEycjEzbDFsMmwzbDRsNWw2bDcgICBnMWcyICBsM1wiLEY9XCIyMGwzXCIsXz1cImIxICByMXIyIGcxXCIsTD1cInI4bDhiOFxcbmIxYjJiM1xcbmI5YjEwYjExYjEyXFxubDEzcjEzYjEzXFxucjEyYjEyZzEyXFxucjdyOHI5cjEwXFxuZzEwZzExZzEyXFxubDZiNnI2XFxubDlsMTBsMTFcXG5iN2w3cjdnN1xcbnIxM2wxM2IxM2cxM1xcbmwxMHIxMGIxMGcxMFxcbmw2cjZnNlxcbmwxYjFnMVxcbi9yMXIxXFxuZzFnMVxcbmcyZzJcXG5nM2czXFxuZzRnNFxcbmc1ZzVcXG5nNmc2XFxuZzdnN1xcbmc4ZzhcXG5nOWc5XFxuZzEwZzEwXFxuZzExZzExXFxuZzEyZzEyXFxuXFxuXCI7dC5leHBvcnRzPXt2YWxpZER1ek9rZXlHcm91cEZlbjpFLGluaXRpYWw6RyxyYWluYm93Ok4sbWl4ZWQ6Uix3cml0ZTpQLHJlYWQ6YixyZWFkRHJvcFBvczppLHJlYWRQaWVjZTp1LHJlYWRCb2FyZDpzLGluaXRpYWxNaWRkbGVzOkYsaW5pdGlhbERpc2NhcmRzOl8saW5pdGlhbE9wZW5Hcm91cHM6TCxyZWFkTWlkZGxlczp3LHJlYWREaXNjYXJkczpjLHJlYWRQaWVjZUdyb3VwOmwscmVhZE9wZW5Hcm91cHM6ZixsYXlvdXRPcGVuczpwLHNlcmllc0J5Q29sb3I6aixtYWtlUGllY2U6ayxwaWVjZVVwOk8scGllY2VEb3duOngscGllY2VGYWtlOlMsY29sb3JzOkssZ2V0T3BlblNlcmllS2V5RnJvbUdyb3VwSW5kZXg6ZyxnZXRPcGVuUGFpcktleUZyb21Hcm91cEluZGV4Om0sZ2V0T3BlblNlcmllRnJvbVBvczpoLGdldE9wZW5QYWlyRnJvbVBvczp5fX0se1wiLi91dGlsXCI6MTV9XSwxNDpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9LHI9bi5waWVjZSxhPW4uZ3JvdXAscD1uLnBvcztpZihlLnR1cm5TaWRlPT09ZS5wb3ZTaWRlKXN3aXRjaCh0KXtjYXNlIFJbXCJkZWZhdWx0XCJdLmRpc2NhcmQ6cj1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UocikucGllY2UsbShlLHIsQltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMl0pO2JyZWFrO2Nhc2UgUltcImRlZmF1bHRcIl0uZHJhd01pZGRsZTpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxlLm1pZGRsZUhvbGRlci5jdXJyZW50P0lbXCJkZWZhdWx0XCJdLmFwaURyYXdNaWRkbGVFbmQoZSxyKTpJW1wiZGVmYXVsdFwiXS5hcGlGb3JjZURyYXdNaWRkbGVFbmQoZSxyKX1lbHNle3ZhciB2PUJbXCJkZWZhdWx0XCJdLmZpbmRQb3YoZS5wb3ZTaWRlLGUudHVyblNpZGUpO3N3aXRjaCh0KXtjYXNlIFJbXCJkZWZhdWx0XCJdLmRyYXdNaWRkbGU6cyhlKSxlLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9UltcImRlZmF1bHRcIl0uZHJhd01pZGRsZTticmVhaztjYXNlIFJbXCJkZWZhdWx0XCJdLmRyYXdMZWZ0OmMoZSxCW1wiZGVmYXVsdFwiXS5kcmF3QnlQb3YodikpO2JyZWFrO2Nhc2UgUltcImRlZmF1bHRcIl0uZGlzY2FyZDpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxkKGUsQltcImRlZmF1bHRcIl0uZGlzY2FyZEJ5UG92KHYpLHIpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1SW1wiZGVmYXVsdFwiXS5kaXNjYXJkO2JyZWFrO2Nhc2UgUltcImRlZmF1bHRcIl0ubGVhdmVUYWtlbjpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxmKGUsQltcImRlZmF1bHRcIl0uZHJhd0J5UG92KHYpLHIpO2JyZWFrO2Nhc2UgUltcImRlZmF1bHRcIl0ub3BlblNlcmllczphPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZUdyb3VwKGEpLHUoZSxhKTticmVhaztjYXNlIFJbXCJkZWZhdWx0XCJdLm9wZW5QYWlyczphPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZUdyb3VwKGEpLGwoZSxhKTticmVhaztjYXNlIFJbXCJkZWZhdWx0XCJdLmRyb3BPcGVuU2VyaWVzOnI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLHA9R1tcImRlZmF1bHRcIl0ucmVhZERyb3BQb3MocCksbyhlLHIscCk7YnJlYWs7Y2FzZSBSW1wiZGVmYXVsdFwiXS5kcm9wT3BlblBhaXJzOnI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLHA9R1tcImRlZmF1bHRcIl0ucmVhZERyb3BQb3MocCksaShlLHIscCk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKFwidW5rbm93biBtb3ZlXCIpfX19ZnVuY3Rpb24gbyhlLHQsbil7dmFyIHI9bi50eXBlLGE9bi5ncm91cEluZGV4LG89ZS5vcGVucy5zZXJpZXNbYV0saT1yIT09UltcImRlZmF1bHRcIl0uZHJvcFJlcGxhY2U/MDoxLHU9MDtpZihyPT09UltcImRlZmF1bHRcIl0uZHJvcExlZnQpdT0wO2Vsc2UgaWYocj09PVJbXCJkZWZhdWx0XCJdLmRyb3BSaWdodCl1PW8ubGVuZ3RoKzE7ZWxzZXt2YXIgbD1HW1wiZGVmYXVsdFwiXS5waWVjZVVwKGUubWlkZGxlc1tCW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0pO3U9X1tcImRlZmF1bHRcIl0uZmluZE9rZXlJbmRleChvLGwpKzF9by5zcGxpY2UodS1pLGksdCksZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBpKGUsdCxuKXt2YXIgcj1uLmdyb3VwSW5kZXgsYT1lLm9wZW5zLnBhaXJzW3JdLG89R1tcImRlZmF1bHRcIl0ucGllY2VVcChlLm1pZGRsZXNbQltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdKSxpPV9bXCJkZWZhdWx0XCJdLmZpbmRPa2V5SW5kZXgoYSxvKTthLnNwbGljZShpLDEsdCksZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiB1KGUsdCl7dmFyIG49dCxyPWUub3BlbnMuc2VyaWVzLmNvbmNhdChuKTtlLm9wZW5zLnNlcmllcz1yLGUub3BlbnMucmVsYXlvdXQoZSl9ZnVuY3Rpb24gbChlLHQpe3ZhciBuPXQscj1lLm9wZW5zLnBhaXJzLmNvbmNhdChuKTtlLm9wZW5zLnBhaXJzPXIsZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBkKGUsdCxuKXtyZXR1cm4gZS5kaXNjYXJkc1t0XS51bnNoaWZ0KG4pLGUubGFzdE1vdmU9W3RdLCEwfWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGUubWlkZGxlc1tCW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0tLSxlLmxhc3RNb3ZlPVtCW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0sITB9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiBlLmRpc2NhcmRzW3RdLnNoaWZ0KCksITB9ZnVuY3Rpb24gZihlLHQsbil7cmV0dXJuIGUuZGlzY2FyZHNbdF0udW5zaGlmdChuKSwhMH1mdW5jdGlvbiBwKGUsdCxuLHIpe2lmKCFlLnBpZWNlc1t0XXx8IXIpcmV0dXJuITE7dmFyIGE9ZS5waWVjZXNbdF07WChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsUltcImRlZmF1bHRcIl0uZHJvcE9wZW5TZXJpZXMscShhLmtleSkpKTt2YXIgbz1BKHIsMiksaT1vWzBdLHU9b1sxXSxsPWUub3BlbnMuc2VyaWVzW2ldLGQ9dyhsLHUpLHM9ZCE9PVJbXCJkZWZhdWx0XCJdLmRyb3BSZXBsYWNlPzA6MTtpZihsLnNwbGljZSh1LXMscyxhKSxlLm9wZW5zLnJlbGF5b3V0KGUpLGRlbGV0ZSBlLnBpZWNlc1t0XSxkPT09UltcImRlZmF1bHRcIl0uZHJvcFJlcGxhY2Upe3ZhciBjPUdbXCJkZWZhdWx0XCJdLnBpZWNlVXAoZS5taWRkbGVzW0JbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSk7ZS5waWVjZXNbdF09Y31yZXR1cm4hMH1mdW5jdGlvbiB2KGUsdCxuLHIpe2lmKCFlLnBpZWNlc1t0XXx8IXIpcmV0dXJuITE7dmFyIGE9ZS5waWVjZXNbdF07WChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsUltcImRlZmF1bHRcIl0uZHJvcE9wZW5QYWlycyxxKGEua2V5KSkpO3ZhciBvPUEociwyKSxpPW9bMF0sdT1vWzFdLGw9ZS5vcGVucy5wYWlyc1tpXTtsLnNwbGljZSh1LDEsYSksZS5vcGVucy5yZWxheW91dChlKSxkZWxldGUgZS5waWVjZXNbdF07dmFyIGQ9R1tcImRlZmF1bHRcIl0ucGllY2VVcChlLm1pZGRsZXNbQltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdKTtyZXR1cm4gZS5waWVjZXNbdF09ZCwhMH1mdW5jdGlvbiBtKGUsdCxuKXtmb3IodmFyIHIgaW4gZS5waWVjZXMpe3ZhciBhPWUucGllY2VzW3JdO2lmKGEmJkJbXCJkZWZhdWx0XCJdLnBpZWNlRXF1YWwodCxhKSlyZXR1cm4gZyhlLHIsbiksITB9cmV0dXJuITF9ZnVuY3Rpb24gZyhlLHQsbil7dmFyIHI9ZS5waWVjZXNbdF07cmV0dXJuISFyJiYoWChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsUltcImRlZmF1bHRcIl0uZGlzY2FyZCxxKHIua2V5KSkpLGUuZGlzY2FyZHNbbl0udW5zaGlmdChlLnBpZWNlc1t0XSksZGVsZXRlIGUucGllY2VzW3RdLGUubGFzdE1vdmU9W25dLCEwKX1mdW5jdGlvbiBoKGUsdCl7dmFyIG49ZS5waWVjZXNbdF07cmV0dXJuISFuJiYoISFCW1wiZGVmYXVsdFwiXS5waWVjZUVxdWFsKG4sZS5taWRkbGVzW0JbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSkmJihYKEJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxSW1wiZGVmYXVsdFwiXS5zaWduLHEobi5rZXkpKSksITApKX1mdW5jdGlvbiB5KGUsdCl7dmFyIG49ZS5waWVjZXNbdF07aWYoIW4pcmV0dXJuITE7ZGVsZXRlIGUucGllY2VzW3RdO3ZhciByPShHW1wiZGVmYXVsdFwiXS53cml0ZShlLnBpZWNlcyksSVtcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFNlcmllcyhlKSksYT1JW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwUGFpcnMoZSk7aWYoR1tcImRlZmF1bHRcIl0udmFsaWREdXpPa2V5R3JvdXBGZW4ocikpWChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsUltcImRlZmF1bHRcIl0uZGlzY2FyZEVuZFNlcmllcyxIKHIpKSk7ZWxzZXtpZighR1tcImRlZmF1bHRcIl0udmFsaWREdXpPa2V5R3JvdXBGZW4oYSkpcmV0dXJuIGUucGllY2VzW3RdPW4sITE7WChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsUltcImRlZmF1bHRcIl0uZGlzY2FyZEVuZFBhaXJzLEgoYSkpKX1yZXR1cm4hMH1mdW5jdGlvbiB3KGUsdCl7cmV0dXJuIDA9PT10P1JbXCJkZWZhdWx0XCJdLmRyb3BMZWZ0OnQ9PT1lLmxlbmd0aCsxP1JbXCJkZWZhdWx0XCJdLmRyb3BSaWdodDpSW1wiZGVmYXVsdFwiXS5kcm9wUmVwbGFjZX1mdW5jdGlvbiBiKGUsdCxuKXtpZihuJiZCW1wiZGVmYXVsdFwiXS5pc09wZW5zS2V5KG4pJiZFKGUsdCxuKSl7dmFyIHIsYSxvLGksdSxsPWUucGllY2VzW3RdLGQ9R1tcImRlZmF1bHRcIl0uZ2V0T3BlblNlcmllRnJvbVBvcyhlLEJbXCJkZWZhdWx0XCJdLm1pbmlLZXkycG9zKG4pKTtpZihkKXt2YXIgcz1BKGQsMik7cj1zWzBdLGE9c1sxXSxvPWUub3BlbnMuc2VyaWVzW3JdLGk9dyhvLGEpLHU9aStyfWlmKHAoZSx0LG4sZCkpcmV0dXJuIFgoQltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLFJbXCJkZWZhdWx0XCJdLmRyb3BPcGVuU2VyaWVzLFUobC5rZXksdSkpKSwhMDt2YXIgYz1HW1wiZGVmYXVsdFwiXS5nZXRPcGVuUGFpckZyb21Qb3MoZSxCW1wiZGVmYXVsdFwiXS5taW5pS2V5MnBvcyhuKSk7aWYoYyl7dmFyIGY9QShjLDIpO3I9ZlswXSxhPWZbMV0sbz1lLm9wZW5zLnBhaXJzW3JdLGk9dyhvLGEpLHU9aStyfWlmKHYoZSx0LG4sYykpcmV0dXJuIFgoQltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLFJbXCJkZWZhdWx0XCJdLmRyb3BPcGVuUGFpcnMsVShsLmtleSx1KSkpLCEwfXJldHVybiExfWZ1bmN0aW9uIFAoZSx0LG4pe3ZhciByPWUucGllY2VzW3RdO2lmKG4mJm49PT1CW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1syXSl7aWYoTShlLHQsbikmJmcoZSx0LG4pKXJldHVybiBYKEJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixSW1wiZGVmYXVsdFwiXS5kaXNjYXJkLHEoci5rZXkpKSksITB9ZWxzZSBpZihuPT09QltcImRlZmF1bHRcIl0uZ29zdGVyZ2Upe2lmKEQoZSx0KSYmaChlLHQpKXJldHVybiBYKEJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixSW1wiZGVmYXVsdFwiXS5zaWduLHEoci5rZXkpKSksITA7aWYoQyhlLHQpJiZ5KGUsdCkpe3ZhciBhPShHW1wiZGVmYXVsdFwiXS53cml0ZShlLnBpZWNlcyksSVtcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFNlcmllcyhlKSksbz1JW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwUGFpcnMoZSk7cmV0dXJuIEdbXCJkZWZhdWx0XCJdLnZhbGlkRHV6T2tleUdyb3VwRmVuKGEpP1goQltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLFJbXCJkZWZhdWx0XCJdLmRpc2NhcmRFbmRTZXJpZXMsSChhKSkpOkdbXCJkZWZhdWx0XCJdLnZhbGlkRHV6T2tleUdyb3VwRmVuKG8pJiZYKEJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixSW1wiZGVmYXVsdFwiXS5kaXNjYXJkRW5kUGFpcnMsSChvKSkpLCEwfX1yZXR1cm4hMX1mdW5jdGlvbiBrKGUsdCl7TyhlLHQpfWZ1bmN0aW9uIE8oZSx0KXtlLnNlbGVjdGVkPXR9ZnVuY3Rpb24geChlLHQpe3JldHVybiBCW1wiZGVmYXVsdFwiXS5pc01pZGRsZUtleSh0KXx8QltcImRlZmF1bHRcIl0uaXNEcmF3TGVmdEtleSh0KT9lLnBvdlNpZGU9PT1lLnR1cm5TaWRlOkJbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodCl9ZnVuY3Rpb24gUyhlKXtyZXR1cm4gZS5wb3ZTaWRlPT09ZS50dXJuU2lkZX1mdW5jdGlvbiBFKGUsdCxuKXt2YXIgcj1lLm1pZGRsZXNbQltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdO3JldHVybiBJW1wiZGVmYXVsdFwiXS5pc0Ryb3BwYWJsZU9wZW5zKGUsdCkmJkJbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodCkmJkJbXCJkZWZhdWx0XCJdLmlzT3BlbnNLZXkobikmJkJbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMsUltcImRlZmF1bHRcIl0uZHJvcE9wZW5TZXJpZXMpJiZCW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLFJbXCJkZWZhdWx0XCJdLmRyb3BPcGVuUGFpcnMpJiZCW1wiZGVmYXVsdFwiXS5jb250YWluc1goX1tcImRlZmF1bHRcIl0uY29tcHV0ZShlLm9wZW5zLGUucGllY2VzW3RdLHIpLG4pfWZ1bmN0aW9uIE0oZSx0LG4pe3JldHVybiBTKGUpJiZCW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLFJbXCJkZWZhdWx0XCJdLmRpc2NhcmQpfWZ1bmN0aW9uIEMoZSx0KXtyZXR1cm4gUyhlKSYmQltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxSW1wiZGVmYXVsdFwiXS5kaXNjYXJkRW5kU2VyaWVzKX1mdW5jdGlvbiBEKGUsdCl7cmV0dXJuIFMoZSkmJkJbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMsUltcImRlZmF1bHRcIl0uc2hvd1NpZ24pfWZ1bmN0aW9uIEsoZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOkJbXCJkZWZhdWx0XCJdLnRvcENvbHVtbnMsbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06QltcImRlZmF1bHRcIl0udG9wUm93cztyZXR1cm4gZnVuY3Rpb24ocixhLG8pe2lmKG98fHIuYm91bmRzKXtvPW98fHIuYm91bmRzKCk7dmFyIGk9TWF0aC5mbG9vcih0KigoYVswXS1vLmxlZnQpL28ud2lkdGgpKSx1PU1hdGguZmxvb3IobiooKGFbMV0tby50b3ApL28uaGVpZ2h0KSk7cmV0dXJuIHU+PTAmJnU8biYmaT49MCYmaTx0P2UodSxpKTp2b2lkIDB9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgQT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt2YXIgbj1bXSxyPSEwLGE9ITEsbz12b2lkIDA7dHJ5e2Zvcih2YXIgaSx1PWVbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0oaT11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goaS52YWx1ZSksIXR8fG4ubGVuZ3RoIT09dCk7cj0hMCk7fWNhdGNoKGwpe2E9ITAsbz1sfWZpbmFsbHl7dHJ5eyFyJiZ1W1wicmV0dXJuXCJdJiZ1W1wicmV0dXJuXCJdKCl9ZmluYWxseXtpZihhKXRocm93IG99fXJldHVybiBufXJldHVybiBmdW5jdGlvbih0LG4pe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQ7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KSlyZXR1cm4gZSh0LG4pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0oKSxUPWUoXCIuL3V0aWxcIiksQj1yKFQpLGo9ZShcIi4vbW92ZVwiKSxSPXIoaiksTj1lKFwiLi9waWVjZXNcIiksRz1yKE4pLEY9ZShcIi4vb3BlblwiKSxfPXIoRiksTD1lKFwiLi9ib2FyZFwiKSxJPXIoTCksVT1CW1wiZGVmYXVsdFwiXS53cmFwRHJvcCxxPUJbXCJkZWZhdWx0XCJdLndyYXBQaWVjZSxIPUJbXCJkZWZhdWx0XCJdLndyYXBHcm91cCxYPUJbXCJkZWZhdWx0XCJdLmNhbGxVc2VyRnVuY3Rpb24sej1LKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIEJbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFt0LGVdKX0sQltcImRlZmF1bHRcIl0ubWluaUNvbHVtbnMsQltcImRlZmF1bHRcIl0ubWluaVJvd3MpLCQ9SyhmdW5jdGlvbihlLHQpe2lmKGU9PT1CW1wiZGVmYXVsdFwiXS50b3BSb3dzLTEpe2lmKDA9PT10KXJldHVybiBCW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1sxXTtpZih0PT09QltcImRlZmF1bHRcIl0udG9wQ29sdW1ucy00KXJldHVybiBCW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudH19KSxKPUsoZnVuY3Rpb24oZSx0KXtpZihlPT09QltcImRlZmF1bHRcIl0udG9wUm93cy0xKXtpZih0PT09QltcImRlZmF1bHRcIl0udG9wQ29sdW1ucy0xKXJldHVybiBCW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1syXTtpZih0PT09QltcImRlZmF1bHRcIl0udG9wQ29sdW1ucy0zKXJldHVybiBCW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZX19KTtuW1wiZGVmYXVsdFwiXT17YXBpTW92ZTphLHNlbGVjdFRvcDprLGRyb3BUb3A6UCxkcm9wT3BlbnM6Yixpc0RyYWdnYWJsZTp4LGdldERyYXdLZXlBdERvbVBvczokLGdldERpc2NhcmRLZXlBdERvbVBvczpKLGdldE9wZW5zS2V5QXREb21Qb3M6en0sdC5leHBvcnRzPW5bXCJkZWZhdWx0XCJdfSx7XCIuL2JvYXJkXCI6NSxcIi4vbW92ZVwiOjExLFwiLi9vcGVuXCI6MTIsXCIuL3BpZWNlc1wiOjEzLFwiLi91dGlsXCI6MTV9XSwxNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSx0KXtyZXR1cm4gR1tlXVt0XX1mdW5jdGlvbiBhKGUsdCl7cmV0dXJuIGUuY29sb3I9PT10LmNvbG9yJiZlLm51bWJlcj09PXQubnVtYmVyfWZ1bmN0aW9uIG8oZSx0KXtmb3IodmFyIG49W10scj0wO3I8ZTtyKyspZm9yKHZhciBhPTA7YTx0O2ErKyluLnB1c2goW2Escl0pO3JldHVybiBufWZ1bmN0aW9uIGkoZSx0KXtyZXR1cm4gdCtlfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4gcGFyc2VJbnQoZS5zbGljZSgxKSl9ZnVuY3Rpb24gbChlKXtyZXR1cm4gaSh1KGUpLTEsVil9ZnVuY3Rpb24gZChlKXtyZXR1cm4gZVswXT09PVZ9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZVswXT09PVl9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gZT09PVh9ZnVuY3Rpb24gZihlKXtyZXR1cm4gZT09PUhbMV19ZnVuY3Rpb24gcChlKXt2YXIgdD1lWzFdKksrZVswXTtyZXR1cm4gaSh0LFYpfWZ1bmN0aW9uIHYoZSl7cmV0dXJuIGU9dShlKSxbZSVLLE1hdGguZmxvb3IoZS9LKV19ZnVuY3Rpb24gbShlKXtyZXR1cm4gJFtlXX1mdW5jdGlvbiBnKGUpe3ZhciB0PWVbMV0qaitlWzBdO3JldHVybiBpKHQsWSl9ZnVuY3Rpb24gaChlKXtyZXR1cm4gZT11KGUpLFtlJWosTWF0aC5mbG9vcihlL2opXX1mdW5jdGlvbiB5KGUpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBlKWVbbl0mJnQucHVzaChuKTtyZXR1cm4gdC5qb2luKFwiIFwiKX1mdW5jdGlvbiB3KGUsdCl7cmV0dXJuIGUmJmUuaW5kZXhPZih0KSE9PS0xfWZ1bmN0aW9uIGIoZSl7cmV0dXJuIGUudG91Y2hlcz9bZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFgsZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFldOltlLmNsaWVudFgsZS5jbGllbnRZXX1mdW5jdGlvbiBQKGUsdCl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlWzBdLXRbMF0sMikrTWF0aC5wb3coZVsxXS10WzFdLDIpKX1mdW5jdGlvbiBrKCl7cmV0dXJuXCJ0cmFuc2Zvcm1cImluIGRvY3VtZW50LmJvZHkuc3R5bGU/XCJ0cmFuc2Zvcm1cIjpcIndlYmtpdFRyYW5zZm9ybVwiaW4gZG9jdW1lbnQuYm9keS5zdHlsZT9cIndlYmtpdFRyYW5zZm9ybVwiOlwibW96VHJhbnNmb3JtXCJpbiBkb2N1bWVudC5ib2R5LnN0eWxlP1wibW96VHJhbnNmb3JtXCI6XCJvVHJhbnNmb3JtXCJpbiBkb2N1bWVudC5ib2R5LnN0eWxlP1wib1RyYW5zZm9ybVwiOlwibXNUcmFuc2Zvcm1cIn1mdW5jdGlvbiBPKCl7cmV0dXJuIER8fChEPWsoKSksRH1mdW5jdGlvbiB4KGUpe3JldHVyblwidHJhbnNsYXRlKFwiK2VbMF0rXCJweCxcIitlWzFdK1wicHgpXCJ9ZnVuY3Rpb24gUyhlLHQpe3JldHVybiBlLmJpbmQuYXBwbHkoZSxbbnVsbF0uY29uY2F0KHQpKX1mdW5jdGlvbiBFKCl7cmV0dXJuIFMoYXJndW1lbnRzWzBdLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSl9ZnVuY3Rpb24gTShlKXt2YXIgdCxuPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PWUoKSksdH07cmV0dXJuIG4uY2xlYXI9ZnVuY3Rpb24oKXt0PXZvaWQgMH0sbn1mdW5jdGlvbiBDKGUpe3NldFRpbWVvdXQoZSwxKX12YXIgRCxLPTMyLEE9MixUPTE2LEI9NyxqPTIwLFI9OCxOPVtcImVhc3RcIixcIndlc3RcIixcIm5vcnRoXCIsXCJzb3V0aFwiXSxHPXtlYXN0OntlYXN0OlwiZG93blwiLHdlc3Q6XCJ1cFwiLG5vcnRoOlwicmlnaHRcIixzb3V0aDpcImxlZnRcIn0sd2VzdDp7ZWFzdDpcInVwXCIsd2VzdDpcImRvd25cIixub3J0aDpcImxlZnRcIixzb3V0aDpcInJpZ2h0XCJ9LG5vcnRoOntlYXN0OlwibGVmdFwiLHdlc3Q6XCJyaWdodFwiLG5vcnRoOlwiZG93blwiLHNvdXRoOlwidXBcIn0sc291dGg6e2Vhc3Q6XCJyaWdodFwiLHdlc3Q6XCJsZWZ0XCIsbm9ydGg6XCJ1cFwiLHNvdXRoOlwiZG93blwifX0sRj17dXA6MCxsZWZ0OjEsZG93bjoyLHJpZ2h0OjN9LF89e3VwOjMsbGVmdDowLGRvd246MSxyaWdodDoyfSxMPXt1cDpbLjUsMF0sbGVmdDpbMCwuNV0scmlnaHQ6WzEsLjVdLGRvd246Wy41LDFdfSxJPWZ1bmN0aW9uKGUpe3JldHVybiBMW2VdfSxVPWZ1bmN0aW9uKGUpe3JldHVybiBIW0ZbZV1dfSxxPWZ1bmN0aW9uKGUpe3JldHVybiBIW19bZV1dfSxIPVtcImR1cFwiLFwiZGxlZnRcIixcImRkb3duXCIsXCJkcmlnaHRcIl0sWD1cIm1taWRkbGVDb3VudFwiLHo9XCJtZ29zdGVyZ2VcIiwkPXtkdXA6WzAsMF0sZGxlZnQ6WzAsQi0xXSxkZG93bjpbVC0xLEItMV0sZHJpZ2h0OltULTEsMF0sbW1pZGRsZUNvdW50OltULTQsQi0xXSxtZ29zdGVyZ2U6W1QtMyxCLTFdfSxKPXtjb2xvcjpcImVtcHR5XCIsbnVtYmVyOjF9LFY9XCJiXCIsWT1cIm9cIixRPW8oQSxLKSxXPW8oUixqKSxaPVtbMCwwXSxbMzAsMF0sWzMxLDBdLFszMiwwXSxbNjIsMF0sWzYzLDBdXS5tYXAocCksZWU9ZnVuY3Rpb24oZSl7cmV0dXJuIFouaW5kZXhPZihlKT09PS0xfSx0ZT1RLm1hcChwKSxuZT10ZS5maWx0ZXIoZWUpLHJlPWZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm4gdC5waWVjZT1lLHR9LGFlPWZ1bmN0aW9uKGUpe3JldHVybntncm91cDplfX0sb2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57cGllY2U6ZSxwb3M6dH19O3QuZXhwb3J0cz17dG9wQ29sdW1uczpULHRvcFJvd3M6Qixjb2x1bW5zOksscm93czpBLGVtcHR5UGllY2U6SixwaWVjZUVxdWFsOmEsYWxsU2lkZXM6TixhbGxQb3M6USxhbGxLZXlzOnRlLHRvcEtleTJwb3M6bSxwb3Mya2V5OnAsa2V5MnBvczp2LG1pbmlDb2x1bW5zOmosbWluaVJvd3M6UixtaW5pQWxsUG9zOlcsbWluaVBvczJrZXk6ZyxtaW5pS2V5MnBvczpoLGVuY29kZUtleTppLGRlY0JvYXJkS2V5Omwsbm90QWxsb3dlZEJvYXJkS2V5czpaLGlzQWxsb3dlZEJvYXJkS2V5OmVlLGFsbEFsbG93ZWRCb2FyZEtleXM6bmUsaXNCb2FyZEtleTpkLGlzT3BlbnNLZXk6cyxpc01pZGRsZUtleTpjLGlzRHJhd0xlZnRLZXk6ZixmaW5kUG92OnIsdmVjdG9yQnlQb3Y6SSxkcmF3QnlQb3Y6cSxkaXNjYXJkQnlQb3Y6VSxkaXNjYXJkczpILG1pZGRsZUNvdW50OlgsZ29zdGVyZ2U6eixjbGFzc1NldDp5LGNvbnRhaW5zWDp3LGV2ZW50UG9zaXRpb246YixkaXN0YW5jZTpQLHRyYW5zZm9ybVByb3A6Tyx0cmFuc2xhdGU6eCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6KHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5zZXRUaW1lb3V0KS5iaW5kKHdpbmRvdykscGFydGlhbEFwcGx5OlMscGFydGlhbDpFLG1lbW86TSx3cmFwUGllY2U6cmUsd3JhcEdyb3VwOmFlLHdyYXBEcm9wOm9lLGNhbGxVc2VyRnVuY3Rpb246Q319LHt9XSwxNjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUpe3JldHVybiBlLmNvbG9yK1wiIFwiK2UubnVtYmVyfWZ1bmN0aW9uIG8oZSl7cmV0dXJue2xlZnQ6ZVswXSooMTAwL0tbXCJkZWZhdWx0XCJdLmNvbHVtbnMpK1wiJVwiLHRvcDplWzFdKigxMDAvS1tcImRlZmF1bHRcIl0ucm93cykrXCIlXCJ9fWZ1bmN0aW9uIGkoZSl7cmV0dXJue2xlZnQ6ZVswXSooMTAwL0tbXCJkZWZhdWx0XCJdLm1pbmlDb2x1bW5zKStcIiVcIix0b3A6ZVsxXSooMTAwL0tbXCJkZWZhdWx0XCJdLm1pbmlSb3dzKStcIiVcIn19ZnVuY3Rpb24gdShlLHQsbixyKXt2YXIgbz0oZS5kYXRhLHtrZXk6bixzdHlsZTppKHQpLFwiY2xhc3NcIjphKHIpK1wiIG1pbmlcIn0pO3JldHVybnt0YWc6XCJwaWVjZVwiLGF0dHJzOm99fWZ1bmN0aW9uIGwoZSx0LG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdJiZhcmd1bWVudHNbM10sbz1lLmRhdGEsaT1LW1wiZGVmYXVsdFwiXS5jbGFzc1NldCh7c2VsZWN0ZWQ6by5zZWxlY3RlZD09PXQsXCJsYXN0LW1vdmVcIjpvLmxhc3RNb3ZlJiZLW1wiZGVmYXVsdFwiXS5jb250YWluc1goby5sYXN0TW92ZSx0KX0pLHU9e3N0eWxlOnt9LFwiY2xhc3NcIjpbYShuKSx0LGldLmpvaW4oXCIgXCIpLFwiZGF0YS1taWRkbGUtY291bnRcIjplLmRhdGEubWlkZGxlc1t0XX0sbD1lLmRhdGEuZHJhZ2dhYmxlLmN1cnJlbnQ7aWYociYmbC5vcmlnPT09dCl1LnN0eWxlW0tbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV09S1tcImRlZmF1bHRcIl0udHJhbnNsYXRlKFtsLnBvc1swXStsLmRlY1swXSxsLnBvc1sxXStsLmRlY1sxXV0pLHVbXCJjbGFzc1wiXSs9XCIgZHJhZ2dpbmdcIjtlbHNlIGlmKCFyJiZlLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXMpe3ZhciBkPWUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltc1t0XTtkJiYodS5zdHlsZVtLW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldPUtbXCJkZWZhdWx0XCJdLnRyYW5zbGF0ZShkWzFdKSl9cmV0dXJue3RhZzpcInBpZWNlXCIsYXR0cnM6dX19ZnVuY3Rpb24gZChlLHQsbixyKXt2YXIgbz0hKGFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdKXx8YXJndW1lbnRzWzRdLGk9ZS5kYXRhLHU9S1tcImRlZmF1bHRcIl0uY2xhc3NTZXQoe3NlbGVjdGVkOmkuc2VsZWN0ZWQ9PT10fSksbD17a2V5OnQrKG8/XCJcIjpcImRcIiksc3R5bGU6e30sXCJjbGFzc1wiOlthKG4pLHQsdV0uam9pbihcIiBcIil9O3ImJihsW1wiY2xhc3NcIl0rPVwiIFwiK3IpO3ZhciBkPWUuZGF0YS5kcmFnZ2FibGUuY3VycmVudDtpZihvJiZkLm9yaWc9PT10KWwuc3R5bGVbS1tcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1LW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoW2QucG9zWzBdK2QuZGVjWzBdLGQucG9zWzFdK2QuZGVjWzFdXSksbFtcImNsYXNzXCJdKz1cIiBkcmFnZ2luZ1wiO2Vsc2UgaWYobyYmZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zKXt2YXIgcz1lLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXNbdF07cyYmKGwuc3R5bGVbS1tcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1LW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoc1sxXSkpfXJldHVybnt0YWc6XCJwaWVjZVwiLGF0dHJzOmx9fWZ1bmN0aW9uIHMoZSx0LG4pe3ZhciByPShlLmRhdGEsS1tcImRlZmF1bHRcIl0uY2xhc3NTZXQoe1wicGllY2UtaG9sZGVyXCI6ITB9KSksYT17a2V5OnQsc3R5bGU6e30sXCJjbGFzc1wiOlt0LHIsbl0uam9pbihcIiBcIil9O3JldHVybnt0YWc6XCJkaXZcIixhdHRyczphfX1mdW5jdGlvbiBjKGUsdCxuLHIsaSl7dmFyIHU9ZS5kYXRhLGw9S1tcImRlZmF1bHRcIl0uY2xhc3NTZXQoe3NlbGVjdGVkOnUuc2VsZWN0ZWQ9PT1ufSksZD17a2V5Om4sc3R5bGU6byh0KSxcImNsYXNzXCI6W2EociksbF0uam9pbihcIiBcIil9O2kmJihkW1wiY2xhc3NcIl0rPVwiIFwiK2kpO3ZhciBzPWUuZGF0YS5kcmFnZ2FibGUuY3VycmVudDtyZXR1cm4gcy5vcmlnPT09biYmKHMub3ZlciYmS1tcImRlZmF1bHRcIl0uaXNPcGVuc0tleShzLm92ZXIpJiYoZC5zdHlsZS53aWR0aD1zLm9wZW5zQm91bmRzLndpZHRoL0tbXCJkZWZhdWx0XCJdLm1pbmlDb2x1bW5zK1wicHhcIixkLnN0eWxlLmhlaWdodD1zLm9wZW5zQm91bmRzLmhlaWdodC9LW1wiZGVmYXVsdFwiXS5taW5pUm93cytcInB4XCIpLGQuc3R5bGVbS1tcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1LW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoW3MucG9zWzBdK3MuZGVjWzBdLHMucG9zWzFdK3MuZGVjWzFdXSksZFtcImNsYXNzXCJdKz1cIiBkcmFnZ2luZ1wiKSx7dGFnOlwicGllY2VcIixhdHRyczpkfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e1wiY2xhc3NcIjplK1wiIG9jIFwiK259fX1mdW5jdGlvbiBwKGUsdCxuKXtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e3N0eWxlOmkobiksXCJjbGFzc1wiOmUrXCIgb2NcIn19fWZ1bmN0aW9uIHYoZSx0LG4pe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7c3R5bGU6byhuKSxcImNsYXNzXCI6ZX19fWZ1bmN0aW9uIG0oZSl7ZnVuY3Rpb24gdChlKXtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e1wiY2xhc3NcIjpcIndvb2QgXCIrZX19fXZhciBuLHI9ZS5kYXRhLGE9S1tcImRlZmF1bHRcIl0uYWxsUG9zLG89W107by5wdXNoKHQoXCJsZWZ0XCIpLHQoXCJyaWdodFwiKSk7Zm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspe3ZhciB1PUtbXCJkZWZhdWx0XCJdLnBvczJrZXkoYVtpXSksbD1yLnBpZWNlc1t1XTtsJiZvLnB1c2goYyhlLGFbaV0sdSxsKSksci5kcmFnZ2FibGUuY3VycmVudC5vdmVyPT09dSYmKG49dihcImRyYWctb3ZlclwiLGUsYVtpXSkpfXJldHVybiByLm1pZGRsZUhvbGRlci5rZXkmJm8ucHVzaChjKGUsS1tcImRlZmF1bHRcIl0ua2V5MnBvcyhyLm1pZGRsZUhvbGRlci5rZXkpLHIubWlkZGxlSG9sZGVyLmtleSxLW1wiZGVmYXVsdFwiXS5lbXB0eVBpZWNlLFwibG9hZGluZ1wiKSksbiYmby5wdXNoKG4pLHt0YWc6XCJkaXZcIixhdHRyczp7Y29uZmlnOmZ1bmN0aW9uKHQsbixyKXtufHwoZS5kYXRhLmJvYXJkQm91bmRzPUtbXCJkZWZhdWx0XCJdLm1lbW8odC5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZCh0KSkpfSxcImNsYXNzXCI6XCJvZy1ib2FyZFwifSxjaGlsZHJlbjpvfX1mdW5jdGlvbiBnKGUsdCl7Zm9yKHZhciBuPWUuZGF0YSxyPUtbXCJkZWZhdWx0XCJdLm1pbmlBbGxQb3MsYT1bXSxvPVtdLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIGw9S1tcImRlZmF1bHRcIl0ubWluaVBvczJrZXkocltpXSksZD10W2xdO2QmJmEucHVzaCh1KGUscltpXSxsLGQpKTt2YXIgcz1LW1wiZGVmYXVsdFwiXS5jbGFzc1NldCh7XCJkcmFnLW92ZXJcIjpuLmRyYWdnYWJsZS5jdXJyZW50Lm92ZXI9PT1sLFwibW92ZS1kZXN0XCI6S1tcImRlZmF1bHRcIl0uY29udGFpbnNYKG4ub3BlbmFibGUuZGVzdHMsbCl9KTtcIlwiIT09cyYmby5wdXNoKHAocyxlLHJbaV0pKX1yZXR1cm4gYS5wdXNoKG8pLGF9ZnVuY3Rpb24gaChlKXt2YXIgdD1lLmRhdGEsbj1nKGUsdC5vcGVucy5sYXlvdXQubGF5b3V0KTtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e2NvbmZpZzpmdW5jdGlvbih0LG4scil7bnx8KGUuZGF0YS5vcGVuc0JvdW5kcz1LW1wiZGVmYXVsdFwiXS5tZW1vKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQodCkpKX0sXCJjbGFzc1wiOlwib2ctb3BlbnNcIn0sY2hpbGRyZW46bn19ZnVuY3Rpb24geShlKXt2YXIgdD1lLmRhdGEsbj1bXSxyPVtdO2Zvcih2YXIgYSBpbiB0LmRpc2NhcmRzKXt2YXIgbz10LmRpc2NhcmRzW2FdWzBdLGk9S1tcImRlZmF1bHRcIl0uY2xhc3NTZXQoe1wiZHJhZy1vdmVyXCI6dC5kcmFnZ2FibGUuY3VycmVudC5vdmVyPT09YSxcIm1vdmUtZGVzdFwiOlwiZGRvd25cIj09PWEmJnQuc2VsZWN0ZWQmJktbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodC5zZWxlY3RlZCkmJktbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWCh0Lm1vdmFibGUuZGVzdHMsVFtcImRlZmF1bHRcIl0uZGlzY2FyZCksXCJsYXN0LW1vdmVcIjp0Lmxhc3RNb3ZlJiZLW1wiZGVmYXVsdFwiXS5jb250YWluc1godC5sYXN0TW92ZSxhKX0pO28/KHQuZGlzY2FyZHNbYV1bMV0mJnIucHVzaChkKGUsYSx0LmRpc2NhcmRzW2FdWzFdLFwiZmFrZVwiLCExKSksci5wdXNoKGQoZSxhLG8saSkpKTpuLnB1c2gocyhlLGEsaSkpfXJldHVybiBuLnB1c2gociksbn1mdW5jdGlvbiB3KGUpe3ZhciB0PWUuZGF0YSxuPVtdLHI9dC5taWRkbGVIb2xkZXIucGllY2V8fEtbXCJkZWZhdWx0XCJdLmVtcHR5UGllY2U7cmV0dXJuIG4ucHVzaChkKGUsS1tcImRlZmF1bHRcIl0uZ29zdGVyZ2UsdC5taWRkbGVzW0tbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSkpLG4ucHVzaChsKGUsS1tcImRlZmF1bHRcIl0ubWlkZGxlQ291bnQsS1tcImRlZmF1bHRcIl0uZW1wdHlQaWVjZSkpLChLW1wiZGVmYXVsdFwiXS5pc01pZGRsZUtleSh0LmRyYWdnYWJsZS5jdXJyZW50Lm9yaWcpfHx0LmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zJiZ0LmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW0tbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50XSkmJm4ucHVzaChsKGUsS1tcImRlZmF1bHRcIl0ubWlkZGxlQ291bnQsciwhMCkpLHQuZHJhZ2dhYmxlLmN1cnJlbnQub3Zlcj09PUtbXCJkZWZhdWx0XCJdLmdvc3RlcmdlJiZuLnB1c2goZihcImRyYWctb3ZlclwiLGUsS1tcImRlZmF1bHRcIl0uZ29zdGVyZ2UpKSxufWZ1bmN0aW9uIGIoZSl7dmFyIHQ9W3coZSkseShlKSxoKGUpXTtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e2NvbmZpZzpmdW5jdGlvbih0LG4scil7bnx8KGUuZGF0YS50b3BCb3VuZHM9S1tcImRlZmF1bHRcIl0ubWVtbyh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdC5iaW5kKHQpKSl9LFwiY2xhc3NcIjpcIm9nLXRvcFwifSxjaGlsZHJlbjp0fX1mdW5jdGlvbiBQKGUpe3JldHVybltiKGUpLG0oZSldfWZ1bmN0aW9uIGsoZSx0KXtyZXR1cm4gZnVuY3Rpb24obil7dChlLG4pfX1mdW5jdGlvbiBPKGUsdCxuKXt2YXIgcj1lLmRhdGEsYT1rKHIsQ1tcImRlZmF1bHRcIl0uc3RhcnQpLG89ayhyLENbXCJkZWZhdWx0XCJdLm1vdmUpLGk9ayhyLENbXCJkZWZhdWx0XCJdLmVuZCksdT1bXCJ0b3VjaHN0YXJ0XCIsXCJtb3VzZWRvd25cIl0sbD1bXCJ0b3VjaG1vdmVcIixcIm1vdXNlbW92ZVwiXSxkPVtcInRvdWNoZW5kXCIsXCJtb3VzZXVwXCJdO3UuZm9yRWFjaChmdW5jdGlvbihlKXt0LmFkZEV2ZW50TGlzdGVuZXIoZSxhKX0pLGwuZm9yRWFjaChmdW5jdGlvbihlKXtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGUsbyl9KSxkLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlLGkpfSksbi5vbnVubG9hZD1mdW5jdGlvbigpe3UuZm9yRWFjaChmdW5jdGlvbihlKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxhKX0pLGwuZm9yRWFjaChmdW5jdGlvbihlKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGUsbyl9KSxkLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLGkpO1xufSl9fWZ1bmN0aW9uIHgoZSl7cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntcImNsYXNzXCI6XCJvZy10YWJsZVwiLGNvbmZpZzpmdW5jdGlvbih0LG4scil7bnx8KE8oZSx0LHIpLGUuZGF0YS5yZW5kZXI9ZnVuY3Rpb24oKXtFW1wiZGVmYXVsdFwiXS5yZW5kZXIodCxQKGUpKX0sZS5kYXRhLnJlbmRlclJBRj1mdW5jdGlvbigpe0tbXCJkZWZhdWx0XCJdLnJlcXVlc3RBbmltYXRpb25GcmFtZShlLmRhdGEucmVuZGVyKX0sZS5kYXRhLmJvdW5kcz1LW1wiZGVmYXVsdFwiXS5tZW1vKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQodCkpLGUuZGF0YS5lbGVtZW50PXQsZS5kYXRhLnJlbmRlcigpKX19LGNoaWxkcmVuOltdfX12YXIgUz1lKFwibWl0aHJpbFwiKSxFPXIoUyksTT1lKFwiLi9kcmFnXCIpLEM9cihNKSxEPWUoXCIuL3V0aWxcIiksSz1yKEQpLEE9ZShcIi4vbW92ZVwiKSxUPXIoQSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7Y29uZmlnOmZ1bmN0aW9uKHQsbil7bnx8W1wib25zY3JvbGxcIixcIm9ucmVzaXplXCJdLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49d2luZG93W3RdO3dpbmRvd1t0XT1mdW5jdGlvbigpe24mJm4oKSxlLmRhdGEuYm91bmRzLmNsZWFyKCksZS5kYXRhLmJvYXJkQm91bmRzLmNsZWFyKCksZS5kYXRhLm9wZW5zQm91bmRzLmNsZWFyKCksZS5kYXRhLnRvcEJvdW5kcy5jbGVhcigpfX0pfSxcImNsYXNzXCI6W1wib2ctdGFibGUtd3JhcFwiXS5qb2luKFwiIFwiKX0sY2hpbGRyZW46W3goZSldfX19LHtcIi4vZHJhZ1wiOjksXCIuL21vdmVcIjoxMSxcIi4vdXRpbFwiOjE1LG1pdGhyaWw6Mn1dfSx7fSxbMTBdKSgxMCl9KTsiLCIvKiBNSVQgbGljZW5zZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmdiMmhzbDogcmdiMmhzbCxcbiAgcmdiMmhzdjogcmdiMmhzdixcbiAgcmdiMmh3YjogcmdiMmh3YixcbiAgcmdiMmNteWs6IHJnYjJjbXlrLFxuICByZ2Iya2V5d29yZDogcmdiMmtleXdvcmQsXG4gIHJnYjJ4eXo6IHJnYjJ4eXosXG4gIHJnYjJsYWI6IHJnYjJsYWIsXG4gIHJnYjJsY2g6IHJnYjJsY2gsXG5cbiAgaHNsMnJnYjogaHNsMnJnYixcbiAgaHNsMmhzdjogaHNsMmhzdixcbiAgaHNsMmh3YjogaHNsMmh3YixcbiAgaHNsMmNteWs6IGhzbDJjbXlrLFxuICBoc2wya2V5d29yZDogaHNsMmtleXdvcmQsXG5cbiAgaHN2MnJnYjogaHN2MnJnYixcbiAgaHN2MmhzbDogaHN2MmhzbCxcbiAgaHN2Mmh3YjogaHN2Mmh3YixcbiAgaHN2MmNteWs6IGhzdjJjbXlrLFxuICBoc3Yya2V5d29yZDogaHN2MmtleXdvcmQsXG5cbiAgaHdiMnJnYjogaHdiMnJnYixcbiAgaHdiMmhzbDogaHdiMmhzbCxcbiAgaHdiMmhzdjogaHdiMmhzdixcbiAgaHdiMmNteWs6IGh3YjJjbXlrLFxuICBod2Iya2V5d29yZDogaHdiMmtleXdvcmQsXG5cbiAgY215azJyZ2I6IGNteWsycmdiLFxuICBjbXlrMmhzbDogY215azJoc2wsXG4gIGNteWsyaHN2OiBjbXlrMmhzdixcbiAgY215azJod2I6IGNteWsyaHdiLFxuICBjbXlrMmtleXdvcmQ6IGNteWsya2V5d29yZCxcblxuICBrZXl3b3JkMnJnYjoga2V5d29yZDJyZ2IsXG4gIGtleXdvcmQyaHNsOiBrZXl3b3JkMmhzbCxcbiAga2V5d29yZDJoc3Y6IGtleXdvcmQyaHN2LFxuICBrZXl3b3JkMmh3Yjoga2V5d29yZDJod2IsXG4gIGtleXdvcmQyY215azoga2V5d29yZDJjbXlrLFxuICBrZXl3b3JkMmxhYjoga2V5d29yZDJsYWIsXG4gIGtleXdvcmQyeHl6OiBrZXl3b3JkMnh5eixcblxuICB4eXoycmdiOiB4eXoycmdiLFxuICB4eXoybGFiOiB4eXoybGFiLFxuICB4eXoybGNoOiB4eXoybGNoLFxuXG4gIGxhYjJ4eXo6IGxhYjJ4eXosXG4gIGxhYjJyZ2I6IGxhYjJyZ2IsXG4gIGxhYjJsY2g6IGxhYjJsY2gsXG5cbiAgbGNoMmxhYjogbGNoMmxhYixcbiAgbGNoMnh5ejogbGNoMnh5eixcbiAgbGNoMnJnYjogbGNoMnJnYlxufVxuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG4iLCJ2YXIgY29udmVyc2lvbnMgPSByZXF1aXJlKFwiLi9jb252ZXJzaW9uc1wiKTtcblxudmFyIGNvbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgQ29udmVydGVyKCk7XG59XG5cbmZvciAodmFyIGZ1bmMgaW4gY29udmVyc2lvbnMpIHtcbiAgLy8gZXhwb3J0IFJhdyB2ZXJzaW9uc1xuICBjb252ZXJ0W2Z1bmMgKyBcIlJhd1wiXSA9ICAoZnVuY3Rpb24oZnVuYykge1xuICAgIC8vIGFjY2VwdCBhcnJheSBvciBwbGFpbiBhcmdzXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgIH1cbiAgfSkoZnVuYyk7XG5cbiAgdmFyIHBhaXIgPSAvKFxcdyspMihcXHcrKS8uZXhlYyhmdW5jKSxcbiAgICAgIGZyb20gPSBwYWlyWzFdLFxuICAgICAgdG8gPSBwYWlyWzJdO1xuXG4gIC8vIGV4cG9ydCByZ2IyaHNsIGFuZCBbXCJyZ2JcIl1bXCJoc2xcIl1cbiAgY29udmVydFtmcm9tXSA9IGNvbnZlcnRbZnJvbV0gfHwge307XG5cbiAgY29udmVydFtmcm9tXVt0b10gPSBjb252ZXJ0W2Z1bmNdID0gKGZ1bmN0aW9uKGZ1bmMpIHsgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIFxuICAgICAgdmFyIHZhbCA9IGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiIHx8IHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdmFsOyAvLyBrZXl3b3JkXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKVxuICAgICAgICB2YWxbaV0gPSBNYXRoLnJvdW5kKHZhbFtpXSk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSkoZnVuYyk7XG59XG5cblxuLyogQ29udmVydGVyIGRvZXMgbGF6eSBjb252ZXJzaW9uIGFuZCBjYWNoaW5nICovXG52YXIgQ29udmVydGVyID0gZnVuY3Rpb24oKSB7XG4gICB0aGlzLmNvbnZzID0ge307XG59O1xuXG4vKiBFaXRoZXIgZ2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2Ugb3JcbiAgc2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGRlcGVuZGluZyBvbiBhcmdzICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnJvdXRlU3BhY2UgPSBmdW5jdGlvbihzcGFjZSwgYXJncykge1xuICAgdmFyIHZhbHVlcyA9IGFyZ3NbMF07XG4gICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJnYigpXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuICAgfVxuICAgLy8gY29sb3IucmdiKDEwLCAxMCwgMTApXG4gICBpZiAodHlwZW9mIHZhbHVlcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTsgICAgICAgIFxuICAgfVxuXG4gICByZXR1cm4gdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHVlcyk7XG59O1xuICBcbi8qIFNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBpbnZhbGlkYXRpbmcgY2FjaGUgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UsIHZhbHVlcykge1xuICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgdGhpcy5jb252cyA9IHt9O1xuICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWx1ZXM7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qIEdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLiBJZiB0aGVyZSdzIGFscmVhZHlcbiAgYSBjb252ZXJzaW9uIGZvciB0aGUgc3BhY2UsIGZldGNoIGl0LCBvdGhlcndpc2VcbiAgY29tcHV0ZSBpdCAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSkge1xuICAgdmFyIHZhbHMgPSB0aGlzLmNvbnZzW3NwYWNlXTtcbiAgIGlmICghdmFscykge1xuICAgICAgdmFyIGZzcGFjZSA9IHRoaXMuc3BhY2UsXG4gICAgICAgICAgZnJvbSA9IHRoaXMuY29udnNbZnNwYWNlXTtcbiAgICAgIHZhbHMgPSBjb252ZXJ0W2ZzcGFjZV1bc3BhY2VdKGZyb20pO1xuXG4gICAgICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHM7XG4gICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuW1wicmdiXCIsIFwiaHNsXCIsIFwiaHN2XCIsIFwiY215a1wiLCBcImtleXdvcmRcIl0uZm9yRWFjaChmdW5jdGlvbihzcGFjZSkge1xuICAgQ29udmVydGVyLnByb3RvdHlwZVtzcGFjZV0gPSBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3V0ZVNwYWNlKHNwYWNlLCBhcmd1bWVudHMpO1xuICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDsiLCJtb2R1bGUuZXhwb3J0cz17XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59IiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb2xvck5hbWVzID0gcmVxdWlyZSgnY29sb3ItbmFtZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgIGdldFJnYmE6IGdldFJnYmEsXG4gICBnZXRIc2xhOiBnZXRIc2xhLFxuICAgZ2V0UmdiOiBnZXRSZ2IsXG4gICBnZXRIc2w6IGdldEhzbCxcbiAgIGdldEh3YjogZ2V0SHdiLFxuICAgZ2V0QWxwaGE6IGdldEFscGhhLFxuXG4gICBoZXhTdHJpbmc6IGhleFN0cmluZyxcbiAgIHJnYlN0cmluZzogcmdiU3RyaW5nLFxuICAgcmdiYVN0cmluZzogcmdiYVN0cmluZyxcbiAgIHBlcmNlbnRTdHJpbmc6IHBlcmNlbnRTdHJpbmcsXG4gICBwZXJjZW50YVN0cmluZzogcGVyY2VudGFTdHJpbmcsXG4gICBoc2xTdHJpbmc6IGhzbFN0cmluZyxcbiAgIGhzbGFTdHJpbmc6IGhzbGFTdHJpbmcsXG4gICBod2JTdHJpbmc6IGh3YlN0cmluZyxcbiAgIGtleXdvcmQ6IGtleXdvcmRcbn1cblxuZnVuY3Rpb24gZ2V0UmdiYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgYWJiciA9ICAvXiMoW2EtZkEtRjAtOV17M30pJC8sXG4gICAgICAgaGV4ID0gIC9eIyhbYS1mQS1GMC05XXs2fSkkLyxcbiAgICAgICByZ2JhID0gL15yZ2JhP1xcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooW1xcZFxcLl0rKVxccyopP1xcKSQvLFxuICAgICAgIHBlciA9IC9ecmdiYT9cXChcXHMqKFtcXGRcXC5dKylcXCVcXHMqLFxccyooW1xcZFxcLl0rKVxcJVxccyosXFxzKihbXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFtcXGRcXC5dKylcXHMqKT9cXCkkLyxcbiAgICAgICBrZXl3b3JkID0gLyhcXEQrKS87XG5cbiAgIHZhciByZ2IgPSBbMCwgMCwgMF0sXG4gICAgICAgYSA9IDEsXG4gICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJicik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgICAgaWYgKG1hdGNoWzFdID09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJnYiA9IGNvbG9yTmFtZXNbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooXFxkKykoPzpkZWcpP1xccyosXFxzKihbXFxkXFwuXSspJVxccyosXFxzKihbXFxkXFwuXSspJVxccyooPzosXFxzKihbXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICBzID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgbCA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzRdKSB8fCAxLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFxcZCspKD86ZGVnKT9cXHMqLFxccyooW1xcZFxcLl0rKSVcXHMqLFxccyooW1xcZFxcLl0rKSVcXHMqKD86LFxccyooW1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgdyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGIgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFs0XSkgfHwgMSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZ2Ioc3RyaW5nKSB7XG4gICB2YXIgcmdiYSA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIHJldHVybiByZ2JhICYmIHJnYmEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEhzbChzdHJpbmcpIHtcbiAgdmFyIGhzbGEgPSBnZXRIc2xhKHN0cmluZyk7XG4gIHJldHVybiBoc2xhICYmIGhzbGEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEFscGhhKHN0cmluZykge1xuICAgdmFyIHZhbHMgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICBpZiAodmFscykge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHNsYShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRId2Ioc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG59XG5cbi8vIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIGhleFN0cmluZyhyZ2IpIHtcbiAgIHJldHVybiBcIiNcIiArIGhleERvdWJsZShyZ2JbMF0pICsgaGV4RG91YmxlKHJnYlsxXSlcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiWzJdKTtcbn1cblxuZnVuY3Rpb24gcmdiU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChyZ2JhWzNdICE9PSB1bmRlZmluZWQgPyByZ2JhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdXG4gICAgICAgICAgICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudFN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG5cbiAgIHJldHVybiBcInJnYihcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlLCBcIiArIChhbHBoYSB8fCByZ2JhWzNdIHx8IDEpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbFN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAoaHNsYVszXSAmJiBoc2xhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbChcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChoc2xhWzNdICE9PSB1bmRlZmluZWQgPyBoc2xhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2xhKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSwgXCJcbiAgICAgICAgICAgKyBhbHBoYSArIFwiKVwiO1xufVxuXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxuLy8gKGh3YiBoYXZlIGFscGhhIG9wdGlvbmFsICYgMSBpcyBkZWZhdWx0IHZhbHVlKVxuZnVuY3Rpb24gaHdiU3RyaW5nKGh3YiwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChod2JbM10gIT09IHVuZGVmaW5lZCA/IGh3YlszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHdiKFwiICsgaHdiWzBdICsgXCIsIFwiICsgaHdiWzFdICsgXCIlLCBcIiArIGh3YlsyXSArIFwiJVwiXG4gICAgICAgICAgICsgKGFscGhhICE9PSB1bmRlZmluZWQgJiYgYWxwaGEgIT09IDEgPyBcIiwgXCIgKyBhbHBoYSA6IFwiXCIpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn1cblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gc2NhbGUobnVtLCBtaW4sIG1heCkge1xuICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxuXG5cbi8vY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG52YXIgcmV2ZXJzZU5hbWVzID0ge307XG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZXMpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWVzW25hbWVdXSA9IG5hbWU7XG59IiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb252ZXJ0ID0gcmVxdWlyZShcImNvbG9yLWNvbnZlcnRcIiksXG4gICAgc3RyaW5nID0gcmVxdWlyZShcImNvbG9yLXN0cmluZ1wiKTtcblxudmFyIENvbG9yID0gZnVuY3Rpb24oY3NzU3RyaW5nKSB7XG4gIGlmIChjc3NTdHJpbmcgaW5zdGFuY2VvZiBDb2xvcikgcmV0dXJuIGNzc1N0cmluZztcbiAgaWYgKCEgKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHJldHVybiBuZXcgQ29sb3IoY3NzU3RyaW5nKTtcblxuICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICByZ2I6IFswLCAwLCAwXSxcbiAgICAgIGhzbDogWzAsIDAsIDBdLFxuICAgICAgaHN2OiBbMCwgMCwgMF0sXG4gICAgICBod2I6IFswLCAwLCAwXSxcbiAgICAgIGNteWs6IFswLCAwLCAwLCAwXSxcbiAgICAgIGFscGhhOiAxXG4gICB9XG5cbiAgIC8vIHBhcnNlIENvbG9yKCkgYXJndW1lbnRcbiAgIGlmICh0eXBlb2YgY3NzU3RyaW5nID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciB2YWxzID0gc3RyaW5nLmdldFJnYmEoY3NzU3RyaW5nKTtcbiAgICAgIGlmICh2YWxzKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCB2YWxzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFscyA9IHN0cmluZy5nZXRIc2xhKGNzc1N0cmluZykpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHNsXCIsIHZhbHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih2YWxzID0gc3RyaW5nLmdldEh3Yihjc3NTdHJpbmcpKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcImh3YlwiLCB2YWxzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBzdHJpbmcgXFxcIlwiICsgY3NzU3RyaW5nICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAodHlwZW9mIGNzc1N0cmluZyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YXIgdmFscyA9IGNzc1N0cmluZztcbiAgICAgIGlmKHZhbHNbXCJyXCJdICE9PSB1bmRlZmluZWQgfHwgdmFsc1tcInJlZFwiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCB2YWxzKVxuICAgICAgfVxuICAgICAgZWxzZSBpZih2YWxzW1wibFwiXSAhPT0gdW5kZWZpbmVkIHx8IHZhbHNbXCJsaWdodG5lc3NcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdmFscylcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFsc1tcInZcIl0gIT09IHVuZGVmaW5lZCB8fCB2YWxzW1widmFsdWVcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc3ZcIiwgdmFscylcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFsc1tcIndcIl0gIT09IHVuZGVmaW5lZCB8fCB2YWxzW1wid2hpdGVuZXNzXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHdiXCIsIHZhbHMpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKHZhbHNbXCJjXCJdICE9PSB1bmRlZmluZWQgfHwgdmFsc1tcImN5YW5cIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJjbXlrXCIsIHZhbHMpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gb2JqZWN0IFwiICsgSlNPTi5zdHJpbmdpZnkoY3NzU3RyaW5nKSk7XG4gICAgICB9XG4gICB9XG59XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcbiAgIHJnYjogZnVuY3Rpb24gKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNwYWNlKFwicmdiXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuICAgaHNsOiBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTcGFjZShcImhzbFwiLCBhcmd1bWVudHMpO1xuICAgfSxcbiAgIGhzdjogZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3BhY2UoXCJoc3ZcIiwgYXJndW1lbnRzKTtcbiAgIH0sXG4gICBod2I6IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNwYWNlKFwiaHdiXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuICAgY215azogZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3BhY2UoXCJjbXlrXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuXG4gICByZ2JBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMucmdiO1xuICAgfSxcbiAgIGhzbEFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5oc2w7XG4gICB9LFxuICAgaHN2QXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmhzdjtcbiAgIH0sXG4gICBod2JBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZXMuYWxwaGEgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmh3Yi5jb25jYXQoW3RoaXMudmFsdWVzLmFscGhhXSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5od2I7XG4gICB9LFxuICAgY215a0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5jbXlrO1xuICAgfSxcbiAgIHJnYmFBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuICAgICAgcmV0dXJuIHJnYi5jb25jYXQoW3RoaXMudmFsdWVzLmFscGhhXSk7XG4gICB9LFxuICAgaHNsYUFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG4gICAgICByZXR1cm4gaHNsLmNvbmNhdChbdGhpcy52YWx1ZXMuYWxwaGFdKTtcbiAgIH0sXG4gICBhbHBoYTogZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5hbHBoYTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiYWxwaGFcIiwgdmFsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgcmVkOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJyZ2JcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBncmVlbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwicmdiXCIsIDEsIHZhbCk7XG4gICB9LFxuICAgYmx1ZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwicmdiXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgaHVlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc2xcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBzYXR1cmF0aW9uOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc2xcIiwgMSwgdmFsKTtcbiAgIH0sXG4gICBsaWdodG5lc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImhzbFwiLCAyLCB2YWwpO1xuICAgfSxcbiAgIHNhdHVyYXRpb252OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc3ZcIiwgMSwgdmFsKTtcbiAgIH0sXG4gICB3aGl0ZW5lc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImh3YlwiLCAxLCB2YWwpO1xuICAgfSxcbiAgIGJsYWNrbmVzczogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwiaHdiXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgdmFsdWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImhzdlwiLCAyLCB2YWwpO1xuICAgfSxcbiAgIGN5YW46IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImNteWtcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBtYWdlbnRhOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJjbXlrXCIsIDEsIHZhbCk7XG4gICB9LFxuICAgeWVsbG93OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJjbXlrXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgYmxhY2s6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImNteWtcIiwgMywgdmFsKTtcbiAgIH0sXG5cbiAgIGhleFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmhleFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IpO1xuICAgfSxcbiAgIHJnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJnYlN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICByZ2JhU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICBwZXJjZW50U3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucGVyY2VudFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICBoc2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5oc2xTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgaHNsYVN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgaHdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcuaHdiU3RyaW5nKHRoaXMudmFsdWVzLmh3YiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuICAgfSxcbiAgIGtleXdvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5rZXl3b3JkKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuICAgfSxcblxuICAgcmdiTnVtYmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZXMucmdiWzBdIDw8IDE2KSB8ICh0aGlzLnZhbHVlcy5yZ2JbMV0gPDwgOCkgfCB0aGlzLnZhbHVlcy5yZ2JbMl07XG4gICB9LFxuXG4gICBsdW1pbm9zaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgIHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG4gICAgICB2YXIgbHVtID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG4gICAgICAgICBsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MlxuICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygoKGNoYW4gKyAwLjA1NSkgLyAxLjA1NSksIDIuNClcbiAgICAgIH1cbiAgICAgIHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG4gICB9LFxuXG4gICBjb250cmFzdDogZnVuY3Rpb24oY29sb3IyKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG4gICAgICB2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuICAgICAgdmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuICAgICAgaWYgKGx1bTEgPiBsdW0yKSB7XG4gICAgICAgICByZXR1cm4gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG4gICB9LFxuXG4gICBsZXZlbDogZnVuY3Rpb24oY29sb3IyKSB7XG4gICAgIHZhciBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuICAgICByZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNy4xKVxuICAgICAgID8gJ0FBQSdcbiAgICAgICA6IChjb250cmFzdFJhdGlvID49IDQuNSlcbiAgICAgICAgPyAnQUEnXG4gICAgICAgIDogJyc7XG4gICB9LFxuXG4gICBkYXJrOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3RcbiAgICAgIHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2IsXG4gICAgICAgICAgeWlxID0gKHJnYlswXSAqIDI5OSArIHJnYlsxXSAqIDU4NyArIHJnYlsyXSAqIDExNCkgLyAxMDAwO1xuICAgXHRyZXR1cm4geWlxIDwgMTI4O1xuICAgfSxcblxuICAgbGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmRhcmsoKTtcbiAgIH0sXG5cbiAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gW11cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG4gICAgICB9XG4gICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCByZ2IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICBsaWdodGVuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzJdICs9IHRoaXMudmFsdWVzLmhzbFsyXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgZGFya2VuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzJdIC09IHRoaXMudmFsdWVzLmhzbFsyXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgc2F0dXJhdGU6IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICB0aGlzLnZhbHVlcy5oc2xbMV0gKz0gdGhpcy52YWx1ZXMuaHNsWzFdICogcmF0aW87XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImhzbFwiLCB0aGlzLnZhbHVlcy5oc2wpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICBkZXNhdHVyYXRlOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzFdIC09IHRoaXMudmFsdWVzLmhzbFsxXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgd2hpdGVuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHdiWzFdICs9IHRoaXMudmFsdWVzLmh3YlsxXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJod2JcIiwgdGhpcy52YWx1ZXMuaHdiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgYmxhY2tlbjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMudmFsdWVzLmh3YlsyXSArPSB0aGlzLnZhbHVlcy5od2JbMl0gKiByYXRpbztcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHdiXCIsIHRoaXMudmFsdWVzLmh3Yik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIGdyZXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmF5c2NhbGUjQ29udmVydGluZ19jb2xvcl90b19ncmF5c2NhbGVcbiAgICAgIHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwicmdiXCIsIFt2YWwsIHZhbCwgdmFsXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIGNsZWFyZXI6IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImFscGhhXCIsIHRoaXMudmFsdWVzLmFscGhhIC0gKHRoaXMudmFsdWVzLmFscGhhICogcmF0aW8pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgb3BhcXVlcjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiYWxwaGFcIiwgdGhpcy52YWx1ZXMuYWxwaGEgKyAodGhpcy52YWx1ZXMuYWxwaGEgKiByYXRpbykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICByb3RhdGU6IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICAgIHZhciBodWUgPSB0aGlzLnZhbHVlcy5oc2xbMF07XG4gICAgICBodWUgPSAoaHVlICsgZGVncmVlcykgJSAzNjA7XG4gICAgICBodWUgPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzBdID0gaHVlO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgbWl4OiBmdW5jdGlvbihjb2xvcjIsIHdlaWdodCkge1xuICAgICAgd2VpZ2h0ID0gMSAtICh3ZWlnaHQgPT0gbnVsbCA/IDAuNSA6IHdlaWdodCk7XG5cbiAgICAgIC8vIGFsZ29yaXRobSBmcm9tIFNhc3MncyBtaXgoKS4gUmF0aW8gb2YgZmlyc3QgY29sb3IgaW4gbWl4IGlzXG4gICAgICAvLyBkZXRlcm1pbmVkIGJ5IHRoZSBhbHBoYXMgb2YgYm90aCBjb2xvcnMgYW5kIHRoZSB3ZWlnaHRcbiAgICAgIHZhciB0MSA9IHdlaWdodCAqIDIgLSAxLFxuICAgICAgICAgIGQgPSB0aGlzLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuICAgICAgdmFyIHdlaWdodDEgPSAoKCh0MSAqIGQgPT0gLTEpID8gdDEgOiAodDEgKyBkKSAvICgxICsgdDEgKiBkKSkgKyAxKSAvIDI7XG4gICAgICB2YXIgd2VpZ2h0MiA9IDEgLSB3ZWlnaHQxO1xuXG4gICAgICB2YXIgcmdiID0gdGhpcy5yZ2JBcnJheSgpO1xuICAgICAgdmFyIHJnYjIgPSBjb2xvcjIucmdiQXJyYXkoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHJnYltpXSAqIHdlaWdodDEgKyByZ2IyW2ldICogd2VpZ2h0MjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwicmdiXCIsIHJnYik7XG5cbiAgICAgIHZhciBhbHBoYSA9IHRoaXMuYWxwaGEoKSAqIHdlaWdodCArIGNvbG9yMi5hbHBoYSgpICogKDEgLSB3ZWlnaHQpO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJhbHBoYVwiLCBhbHBoYSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgcmV0dXJuIHRoaXMucmdiKCk7XG4gICB9LFxuXG4gICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IoKSk7XG4gICB9XG59XG5cblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHt9O1xuICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsc1tzcGFjZVtpXV0gPSB0aGlzLnZhbHVlc1tzcGFjZV1baV07XG4gICB9XG4gICBpZiAodGhpcy52YWx1ZXMuYWxwaGEgIT0gMSkge1xuICAgICAgdmFsc1tcImFcIl0gPSB0aGlzLnZhbHVlcy5hbHBoYTtcbiAgIH1cbiAgIC8vIHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAwLjR9XG4gICByZXR1cm4gdmFscztcbn1cblxuQ29sb3IucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlLCB2YWxzKSB7XG4gICB2YXIgc3BhY2VzID0ge1xuICAgICAgXCJyZ2JcIjogW1wicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCJdLFxuICAgICAgXCJoc2xcIjogW1wiaHVlXCIsIFwic2F0dXJhdGlvblwiLCBcImxpZ2h0bmVzc1wiXSxcbiAgICAgIFwiaHN2XCI6IFtcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJ2YWx1ZVwiXSxcbiAgICAgIFwiaHdiXCI6IFtcImh1ZVwiLCBcIndoaXRlbmVzc1wiLCBcImJsYWNrbmVzc1wiXSxcbiAgICAgIFwiY215a1wiOiBbXCJjeWFuXCIsIFwibWFnZW50YVwiLCBcInllbGxvd1wiLCBcImJsYWNrXCJdXG4gICB9O1xuXG4gICB2YXIgbWF4ZXMgPSB7XG4gICAgICBcInJnYlwiOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICBcImhzbFwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImhzdlwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImh3YlwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImNteWtcIjogWzEwMCwgMTAwLCAxMDAsIDEwMF1cbiAgIH07XG5cbiAgIHZhciBhbHBoYSA9IDE7XG4gICBpZiAoc3BhY2UgPT0gXCJhbHBoYVwiKSB7XG4gICAgICBhbHBoYSA9IHZhbHM7XG4gICB9XG4gICBlbHNlIGlmICh2YWxzLmxlbmd0aCkge1xuICAgICAgLy8gWzEwLCAxMCwgMTBdXG4gICAgICB0aGlzLnZhbHVlc1tzcGFjZV0gPSB2YWxzLnNsaWNlKDAsIHNwYWNlLmxlbmd0aCk7XG4gICAgICBhbHBoYSA9IHZhbHNbc3BhY2UubGVuZ3RoXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHNbc3BhY2VbMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHtyOiAxMCwgZzogMTAsIGI6IDEwfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW3NwYWNlW2ldXTtcbiAgICAgIH1cbiAgICAgIGFscGhhID0gdmFscy5hO1xuICAgfVxuICAgZWxzZSBpZiAodmFsc1tzcGFjZXNbc3BhY2VdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB7cmVkOiAxMCwgZ3JlZW46IDEwLCBibHVlOiAxMH1cbiAgICAgIHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbY2hhbnNbaV1dO1xuICAgICAgfVxuICAgICAgYWxwaGEgPSB2YWxzLmFscGhhO1xuICAgfVxuICAgdGhpcy52YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogdGhpcy52YWx1ZXMuYWxwaGEpICkpO1xuICAgaWYgKHNwYWNlID09IFwiYWxwaGFcIikge1xuICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICAvLyBjYXAgdmFsdWVzIG9mIHRoZSBzcGFjZSBwcmlvciBjb252ZXJ0aW5nIGFsbCB2YWx1ZXNcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYXBwZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhlc1tzcGFjZV1baV0sIHRoaXMudmFsdWVzW3NwYWNlXVtpXSkpO1xuICAgICAgdGhpcy52YWx1ZXNbc3BhY2VdW2ldID0gTWF0aC5yb3VuZChjYXBwZWQpO1xuICAgfVxuXG4gICAvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG4gICBmb3IgKHZhciBzbmFtZSBpbiBzcGFjZXMpIHtcbiAgICAgIGlmIChzbmFtZSAhPSBzcGFjZSkge1xuICAgICAgICAgdGhpcy52YWx1ZXNbc25hbWVdID0gY29udmVydFtzcGFjZV1bc25hbWVdKHRoaXMudmFsdWVzW3NwYWNlXSlcbiAgICAgIH1cblxuICAgICAgLy8gY2FwIHZhbHVlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NuYW1lXVtpXSwgdGhpcy52YWx1ZXNbc25hbWVdW2ldKSk7XG4gICAgICAgICB0aGlzLnZhbHVlc1tzbmFtZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG4gICAgICB9XG4gICB9XG4gICByZXR1cm4gdHJ1ZTtcbn1cblxuQ29sb3IucHJvdG90eXBlLnNldFNwYWNlID0gZnVuY3Rpb24oc3BhY2UsIGFyZ3MpIHtcbiAgIHZhciB2YWxzID0gYXJnc1swXTtcbiAgIGlmICh2YWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJnYigpXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuICAgfVxuICAgLy8gY29sb3IucmdiKDEwLCAxMCwgMTApXG4gICBpZiAodHlwZW9mIHZhbHMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgfVxuICAgdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuICAgcmV0dXJuIHRoaXM7XG59XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24oc3BhY2UsIGluZGV4LCB2YWwpIHtcbiAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmVkKClcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tzcGFjZV1baW5kZXhdO1xuICAgfVxuICAgLy8gY29sb3IucmVkKDEwMClcbiAgIHRoaXMudmFsdWVzW3NwYWNlXVtpbmRleF0gPSB2YWw7XG4gICB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdGhpcy52YWx1ZXNbc3BhY2VdKTtcbiAgIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiLyohIGlTY3JvbGwgdjUuMi4wIH4gKGMpIDIwMDgtMjAxNiBNYXR0ZW8gU3BpbmVsbGkgfiBodHRwOi8vY3ViaXEub3JnL2xpY2Vuc2UgKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgTWF0aCkge1xudmFyIHJBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdGZ1bmN0aW9uIChjYWxsYmFjaykgeyB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTsgfTtcblxudmFyIHV0aWxzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG1lID0ge307XG5cblx0dmFyIF9lbGVtZW50U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblx0dmFyIF92ZW5kb3IgPSAoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ZW5kb3JzID0gWyd0JywgJ3dlYmtpdFQnLCAnTW96VCcsICdtc1QnLCAnT1QnXSxcblx0XHRcdHRyYW5zZm9ybSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHZlbmRvcnMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dHJhbnNmb3JtID0gdmVuZG9yc1tpXSArICdyYW5zZm9ybSc7XG5cdFx0XHRpZiAoIHRyYW5zZm9ybSBpbiBfZWxlbWVudFN0eWxlICkgcmV0dXJuIHZlbmRvcnNbaV0uc3Vic3RyKDAsIHZlbmRvcnNbaV0ubGVuZ3RoLTEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBfcHJlZml4U3R5bGUgKHN0eWxlKSB7XG5cdFx0aWYgKCBfdmVuZG9yID09PSBmYWxzZSApIHJldHVybiBmYWxzZTtcblx0XHRpZiAoIF92ZW5kb3IgPT09ICcnICkgcmV0dXJuIHN0eWxlO1xuXHRcdHJldHVybiBfdmVuZG9yICsgc3R5bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHlsZS5zdWJzdHIoMSk7XG5cdH1cblxuXHRtZS5nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gZ2V0VGltZSAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuXHRtZS5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYmopIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBvYmogKSB7XG5cdFx0XHR0YXJnZXRbaV0gPSBvYmpbaV07XG5cdFx0fVxuXHR9O1xuXG5cdG1lLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuXHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sICEhY2FwdHVyZSk7XG5cdH07XG5cblx0bWUucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKSB7XG5cdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgISFjYXB0dXJlKTtcblx0fTtcblxuXHRtZS5wcmVmaXhQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAocG9pbnRlckV2ZW50KSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5NU1BvaW50ZXJFdmVudCA/XG5cdFx0XHQnTVNQb2ludGVyJyArIHBvaW50ZXJFdmVudC5jaGFyQXQoNykudG9VcHBlckNhc2UoKSArIHBvaW50ZXJFdmVudC5zdWJzdHIoOCk6XG5cdFx0XHRwb2ludGVyRXZlbnQ7XG5cdH07XG5cblx0bWUubW9tZW50dW0gPSBmdW5jdGlvbiAoY3VycmVudCwgc3RhcnQsIHRpbWUsIGxvd2VyTWFyZ2luLCB3cmFwcGVyU2l6ZSwgZGVjZWxlcmF0aW9uKSB7XG5cdFx0dmFyIGRpc3RhbmNlID0gY3VycmVudCAtIHN0YXJ0LFxuXHRcdFx0c3BlZWQgPSBNYXRoLmFicyhkaXN0YW5jZSkgLyB0aW1lLFxuXHRcdFx0ZGVzdGluYXRpb24sXG5cdFx0XHRkdXJhdGlvbjtcblxuXHRcdGRlY2VsZXJhdGlvbiA9IGRlY2VsZXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gMC4wMDA2IDogZGVjZWxlcmF0aW9uO1xuXG5cdFx0ZGVzdGluYXRpb24gPSBjdXJyZW50ICsgKCBzcGVlZCAqIHNwZWVkICkgLyAoIDIgKiBkZWNlbGVyYXRpb24gKSAqICggZGlzdGFuY2UgPCAwID8gLTEgOiAxICk7XG5cdFx0ZHVyYXRpb24gPSBzcGVlZCAvIGRlY2VsZXJhdGlvbjtcblxuXHRcdGlmICggZGVzdGluYXRpb24gPCBsb3dlck1hcmdpbiApIHtcblx0XHRcdGRlc3RpbmF0aW9uID0gd3JhcHBlclNpemUgPyBsb3dlck1hcmdpbiAtICggd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApICkgOiBsb3dlck1hcmdpbjtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoZGVzdGluYXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9IGVsc2UgaWYgKCBkZXN0aW5hdGlvbiA+IDAgKSB7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IHdyYXBwZXJTaXplID8gd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApIDogMDtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoY3VycmVudCkgKyBkZXN0aW5hdGlvbjtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVzdGluYXRpb246IE1hdGgucm91bmQoZGVzdGluYXRpb24pLFxuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0fTtcblx0fTtcblxuXHR2YXIgX3RyYW5zZm9ybSA9IF9wcmVmaXhTdHlsZSgndHJhbnNmb3JtJyk7XG5cblx0bWUuZXh0ZW5kKG1lLCB7XG5cdFx0aGFzVHJhbnNmb3JtOiBfdHJhbnNmb3JtICE9PSBmYWxzZSxcblx0XHRoYXNQZXJzcGVjdGl2ZTogX3ByZWZpeFN0eWxlKCdwZXJzcGVjdGl2ZScpIGluIF9lbGVtZW50U3R5bGUsXG5cdFx0aGFzVG91Y2g6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyxcblx0XHRoYXNQb2ludGVyOiAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudCksIC8vIElFMTAgaXMgcHJlZml4ZWRcblx0XHRoYXNUcmFuc2l0aW9uOiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb24nKSBpbiBfZWxlbWVudFN0eWxlXG5cdH0pO1xuXG5cdC8qXG5cdFRoaXMgc2hvdWxkIGZpbmQgYWxsIEFuZHJvaWQgYnJvd3NlcnMgbG93ZXIgdGhhbiBidWlsZCA1MzUuMTkgKGJvdGggc3RvY2sgYnJvd3NlciBhbmQgd2Vidmlldylcblx0LSBnYWxheHkgUzIgaXMgb2tcbiAgICAtIDIuMy42IDogYEFwcGxlV2ViS2l0LzUzMy4xIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzMuMWBcbiAgICAtIDQuMC40IDogYEFwcGxlV2ViS2l0LzUzNC4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM0LjMwYFxuICAgLSBnYWxheHkgUzMgaXMgYmFkQW5kcm9pZCAoc3RvY2sgYnJvd2VyLCB3ZWJ2aWV3KVxuICAgICBgQXBwbGVXZWJLaXQvNTM0LjMwIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzQuMzBgXG4gICAtIGdhbGF4eSBTNCBpcyBiYWRBbmRyb2lkIChzdG9jayBicm93ZXIsIHdlYnZpZXcpXG4gICAgIGBBcHBsZVdlYktpdC81MzQuMzAgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBNb2JpbGUgU2FmYXJpLzUzNC4zMGBcbiAgIC0gZ2FsYXh5IFM1IGlzIE9LXG4gICAgIGBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiAoQ2hyb21lLylgXG4gICAtIGdhbGF4eSBTNiBpcyBPS1xuICAgICBgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYgKENocm9tZS8pYFxuICAqL1xuXHRtZS5pc0JhZEFuZHJvaWQgPSAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFwcFZlcnNpb24gPSB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb247XG5cdFx0Ly8gQW5kcm9pZCBicm93c2VyIGlzIG5vdCBhIGNocm9tZSBicm93c2VyLlxuXHRcdGlmICgvQW5kcm9pZC8udGVzdChhcHBWZXJzaW9uKSAmJiAhKC9DaHJvbWVcXC9cXGQvLnRlc3QoYXBwVmVyc2lvbikpKSB7XG5cdFx0XHR2YXIgc2FmYXJpVmVyc2lvbiA9IGFwcFZlcnNpb24ubWF0Y2goL1NhZmFyaVxcLyhcXGQrLlxcZCkvKTtcblx0XHRcdGlmKHNhZmFyaVZlcnNpb24gJiYgdHlwZW9mIHNhZmFyaVZlcnNpb24gPT09IFwib2JqZWN0XCIgJiYgc2FmYXJpVmVyc2lvbi5sZW5ndGggPj0gMikge1xuXHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdChzYWZhcmlWZXJzaW9uWzFdKSA8IDUzNS4xOTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KSgpO1xuXG5cdG1lLmV4dGVuZChtZS5zdHlsZSA9IHt9LCB7XG5cdFx0dHJhbnNmb3JtOiBfdHJhbnNmb3JtLFxuXHRcdHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nKSxcblx0XHR0cmFuc2l0aW9uRHVyYXRpb246IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvbkR1cmF0aW9uJyksXG5cdFx0dHJhbnNpdGlvbkRlbGF5OiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25EZWxheScpLFxuXHRcdHRyYW5zZm9ybU9yaWdpbjogX3ByZWZpeFN0eWxlKCd0cmFuc2Zvcm1PcmlnaW4nKVxuXHR9KTtcblxuXHRtZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChlLCBjKSB7XG5cdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgYyArIFwiKFxcXFxzfCQpXCIpO1xuXHRcdHJldHVybiByZS50ZXN0KGUuY2xhc3NOYW1lKTtcblx0fTtcblxuXHRtZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlLCBjKSB7XG5cdFx0aWYgKCBtZS5oYXNDbGFzcyhlLCBjKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbmV3Y2xhc3MgPSBlLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXHRcdG5ld2NsYXNzLnB1c2goYyk7XG5cdFx0ZS5jbGFzc05hbWUgPSBuZXdjbGFzcy5qb2luKCcgJyk7XG5cdH07XG5cblx0bWUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdGlmICggIW1lLmhhc0NsYXNzKGUsIGMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGMgKyBcIihcXFxcc3wkKVwiLCAnZycpO1xuXHRcdGUuY2xhc3NOYW1lID0gZS5jbGFzc05hbWUucmVwbGFjZShyZSwgJyAnKTtcblx0fTtcblxuXHRtZS5vZmZzZXQgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHR2YXIgbGVmdCA9IC1lbC5vZmZzZXRMZWZ0LFxuXHRcdFx0dG9wID0gLWVsLm9mZnNldFRvcDtcblxuXHRcdC8vIGpzaGludCAtVzA4NFxuXHRcdHdoaWxlIChlbCA9IGVsLm9mZnNldFBhcmVudCkge1xuXHRcdFx0bGVmdCAtPSBlbC5vZmZzZXRMZWZ0O1xuXHRcdFx0dG9wIC09IGVsLm9mZnNldFRvcDtcblx0XHR9XG5cdFx0Ly8ganNoaW50ICtXMDg0XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogbGVmdCxcblx0XHRcdHRvcDogdG9wXG5cdFx0fTtcblx0fTtcblxuXHRtZS5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChlbCwgZXhjZXB0aW9ucykge1xuXHRcdGZvciAoIHZhciBpIGluIGV4Y2VwdGlvbnMgKSB7XG5cdFx0XHRpZiAoIGV4Y2VwdGlvbnNbaV0udGVzdChlbFtpXSkgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRtZS5leHRlbmQobWUuZXZlbnRUeXBlID0ge30sIHtcblx0XHR0b3VjaHN0YXJ0OiAxLFxuXHRcdHRvdWNobW92ZTogMSxcblx0XHR0b3VjaGVuZDogMSxcblxuXHRcdG1vdXNlZG93bjogMixcblx0XHRtb3VzZW1vdmU6IDIsXG5cdFx0bW91c2V1cDogMixcblxuXHRcdHBvaW50ZXJkb3duOiAzLFxuXHRcdHBvaW50ZXJtb3ZlOiAzLFxuXHRcdHBvaW50ZXJ1cDogMyxcblxuXHRcdE1TUG9pbnRlckRvd246IDMsXG5cdFx0TVNQb2ludGVyTW92ZTogMyxcblx0XHRNU1BvaW50ZXJVcDogM1xuXHR9KTtcblxuXHRtZS5leHRlbmQobWUuZWFzZSA9IHt9LCB7XG5cdFx0cXVhZHJhdGljOiB7XG5cdFx0XHRzdHlsZTogJ2N1YmljLWJlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KScsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0cmV0dXJuIGsgKiAoIDIgLSBrICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjaXJjdWxhcjoge1xuXHRcdFx0c3R5bGU6ICdjdWJpYy1iZXppZXIoMC4xLCAwLjU3LCAwLjEsIDEpJyxcdC8vIE5vdCBwcm9wZXJseSBcImNpcmN1bGFyXCIgYnV0IHRoaXMgbG9va3MgYmV0dGVyLCBpdCBzaG91bGQgYmUgKDAuMDc1LCAwLjgyLCAwLjE2NSwgMSlcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCAxIC0gKCAtLWsgKiBrICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGJhY2s6IHtcblx0XHRcdHN0eWxlOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMiwgMS4yNzUpJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHR2YXIgYiA9IDQ7XG5cdFx0XHRcdHJldHVybiAoIGsgPSBrIC0gMSApICogayAqICggKCBiICsgMSApICogayArIGIgKSArIDE7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRib3VuY2U6IHtcblx0XHRcdHN0eWxlOiAnJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRpZiAoICggayAvPSAxICkgPCAoIDEgLyAyLjc1ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyIC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAxLjUgLyAyLjc1ICkgKSAqIGsgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyLjUgLyAyLjc1ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuMjUgLyAyLjc1ICkgKSAqIGsgKyAwLjkzNzU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuNjI1IC8gMi43NSApICkgKiBrICsgMC45ODQzNzU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGVsYXN0aWM6IHtcblx0XHRcdHN0eWxlOiAnJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHR2YXIgZiA9IDAuMjIsXG5cdFx0XHRcdFx0ZSA9IDAuNDtcblxuXHRcdFx0XHRpZiAoIGsgPT09IDAgKSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdGlmICggayA9PSAxICkgeyByZXR1cm4gMTsgfVxuXG5cdFx0XHRcdHJldHVybiAoIGUgKiBNYXRoLnBvdyggMiwgLSAxMCAqIGsgKSAqIE1hdGguc2luKCAoIGsgLSBmIC8gNCApICogKCAyICogTWF0aC5QSSApIC8gZiApICsgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0bWUudGFwID0gZnVuY3Rpb24gKGUsIGV2ZW50TmFtZSkge1xuXHRcdHZhciBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuXHRcdGV2LmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIHRydWUpO1xuXHRcdGV2LnBhZ2VYID0gZS5wYWdlWDtcblx0XHRldi5wYWdlWSA9IGUucGFnZVk7XG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG5cdH07XG5cblx0bWUuY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldCxcblx0XHRcdGV2O1xuXG5cdFx0aWYgKCAhKC8oU0VMRUNUfElOUFVUfFRFWFRBUkVBKS9pKS50ZXN0KHRhcmdldC50YWdOYW1lKSApIHtcblx0XHRcdGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cdFx0XHRldi5pbml0TW91c2VFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlLCBlLnZpZXcsIDEsXG5cdFx0XHRcdHRhcmdldC5zY3JlZW5YLCB0YXJnZXQuc2NyZWVuWSwgdGFyZ2V0LmNsaWVudFgsIHRhcmdldC5jbGllbnRZLFxuXHRcdFx0XHRlLmN0cmxLZXksIGUuYWx0S2V5LCBlLnNoaWZ0S2V5LCBlLm1ldGFLZXksXG5cdFx0XHRcdDAsIG51bGwpO1xuXG5cdFx0XHRldi5fY29uc3RydWN0ZWQgPSB0cnVlO1xuXHRcdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gbWU7XG59KSgpO1xuZnVuY3Rpb24gSVNjcm9sbCAoZWwsIG9wdGlvbnMpIHtcblx0dGhpcy53cmFwcGVyID0gdHlwZW9mIGVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcblx0dGhpcy5zY3JvbGxlciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5zY3JvbGxlclN0eWxlID0gdGhpcy5zY3JvbGxlci5zdHlsZTtcdFx0Ly8gY2FjaGUgc3R5bGUgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXG5cdHRoaXMub3B0aW9ucyA9IHtcblxuXHRcdHJlc2l6ZVNjcm9sbGJhcnM6IHRydWUsXG5cblx0XHRtb3VzZVdoZWVsU3BlZWQ6IDIwLFxuXG5cdFx0c25hcFRocmVzaG9sZDogMC4zMzQsXG5cbi8vIElOU0VSVCBQT0lOVDogT1BUSU9OU1xuXHRcdGRpc2FibGVQb2ludGVyIDogIXV0aWxzLmhhc1BvaW50ZXIsXG5cdFx0ZGlzYWJsZVRvdWNoIDogdXRpbHMuaGFzUG9pbnRlciB8fCAhdXRpbHMuaGFzVG91Y2gsXG5cdFx0ZGlzYWJsZU1vdXNlIDogdXRpbHMuaGFzUG9pbnRlciB8fCB1dGlscy5oYXNUb3VjaCxcblx0XHRzdGFydFg6IDAsXG5cdFx0c3RhcnRZOiAwLFxuXHRcdHNjcm9sbFk6IHRydWUsXG5cdFx0ZGlyZWN0aW9uTG9ja1RocmVzaG9sZDogNSxcblx0XHRtb21lbnR1bTogdHJ1ZSxcblxuXHRcdGJvdW5jZTogdHJ1ZSxcblx0XHRib3VuY2VUaW1lOiA2MDAsXG5cdFx0Ym91bmNlRWFzaW5nOiAnJyxcblxuXHRcdHByZXZlbnREZWZhdWx0OiB0cnVlLFxuXHRcdHByZXZlbnREZWZhdWx0RXhjZXB0aW9uOiB7IHRhZ05hbWU6IC9eKElOUFVUfFRFWFRBUkVBfEJVVFRPTnxTRUxFQ1QpJC8gfSxcblxuXHRcdEhXQ29tcG9zaXRpbmc6IHRydWUsXG5cdFx0dXNlVHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1c2VUcmFuc2Zvcm06IHRydWUsXG5cdFx0YmluZFRvV3JhcHBlcjogdHlwZW9mIHdpbmRvdy5vbm1vdXNlZG93biA9PT0gXCJ1bmRlZmluZWRcIlxuXHR9O1xuXG5cdGZvciAoIHZhciBpIGluIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHRpb25zXG5cdHRoaXMudHJhbnNsYXRlWiA9IHRoaXMub3B0aW9ucy5IV0NvbXBvc2l0aW5nICYmIHV0aWxzLmhhc1BlcnNwZWN0aXZlID8gJyB0cmFuc2xhdGVaKDApJyA6ICcnO1xuXG5cdHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uID0gdXRpbHMuaGFzVHJhbnNpdGlvbiAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbjtcblx0dGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSA9IHV0aWxzLmhhc1RyYW5zZm9ybSAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtO1xuXG5cdHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT09IHRydWUgPyAndmVydGljYWwnIDogdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9ICF0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCAmJiB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ7XG5cblx0Ly8gSWYgeW91IHdhbnQgZXZlbnRQYXNzdGhyb3VnaCBJIGhhdmUgdG8gbG9jayBvbmUgb2YgdGhlIGF4ZXNcblx0dGhpcy5vcHRpb25zLnNjcm9sbFkgPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2Nyb2xsWTtcblx0dGhpcy5vcHRpb25zLnNjcm9sbFggPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgPyBmYWxzZSA6IHRoaXMub3B0aW9ucy5zY3JvbGxYO1xuXG5cdC8vIFdpdGggZXZlbnRQYXNzdGhyb3VnaCB3ZSBhbHNvIG5lZWQgbG9ja0RpcmVjdGlvbiBtZWNoYW5pc21cblx0dGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgPSB0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCAmJiAhdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPyAwIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQ7XG5cblx0dGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nID09ICdzdHJpbmcnID8gdXRpbHMuZWFzZVt0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nXSB8fCB1dGlscy5lYXNlLmNpcmN1bGFyIDogdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblxuXHR0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyA9IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nID09PSB1bmRlZmluZWQgPyA2MCA6IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nO1xuXG5cdGlmICggdGhpcy5vcHRpb25zLnRhcCA9PT0gdHJ1ZSApIHtcblx0XHR0aGlzLm9wdGlvbnMudGFwID0gJ3RhcCc7XG5cdH1cblxuXHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzID09ICdzY2FsZScgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gPSBmYWxzZTtcblx0fVxuXG5cdHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA/IC0xIDogMTtcblxuLy8gSU5TRVJUIFBPSU5UOiBOT1JNQUxJWkFUSU9OXG5cblx0Ly8gU29tZSBkZWZhdWx0c1xuXHR0aGlzLnggPSAwO1xuXHR0aGlzLnkgPSAwO1xuXHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXHR0aGlzLl9ldmVudHMgPSB7fTtcblxuLy8gSU5TRVJUIFBPSU5UOiBERUZBVUxUU1xuXG5cdHRoaXMuX2luaXQoKTtcblx0dGhpcy5yZWZyZXNoKCk7XG5cblx0dGhpcy5zY3JvbGxUbyh0aGlzLm9wdGlvbnMuc3RhcnRYLCB0aGlzLm9wdGlvbnMuc3RhcnRZKTtcblx0dGhpcy5lbmFibGUoKTtcbn1cblxuSVNjcm9sbC5wcm90b3R5cGUgPSB7XG5cdHZlcnNpb246ICc1LjIuMCcsXG5cblx0X2luaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzIHx8IHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzICkge1xuXHRcdFx0dGhpcy5faW5pdEluZGljYXRvcnMoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsICkge1xuXHRcdFx0dGhpcy5faW5pdFdoZWVsKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHRoaXMuX2luaXRTbmFwKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgKSB7XG5cdFx0XHR0aGlzLl9pbml0S2V5cygpO1xuXHRcdH1cblxuLy8gSU5TRVJUIFBPSU5UOiBfaW5pdFxuXG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gXHRcdHRoaXMucmVzaXplVGltZW91dCA9IG51bGw7XG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdkZXN0cm95Jyk7XG5cdH0sXG5cblx0X3RyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCBlLnRhcmdldCAhPSB0aGlzLnNjcm9sbGVyIHx8ICF0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKCk7XG5cdFx0aWYgKCAhdGhpcy5yZXNldFBvc2l0aW9uKHRoaXMub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBSZWFjdCB0byBsZWZ0IG1vdXNlIGJ1dHRvbiBvbmx5XG5cdFx0aWYgKCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPSAxICkge1xuXHRcdCAgLy8gZm9yIGJ1dHRvbiBwcm9wZXJ0eVxuXHRcdCAgLy8gaHR0cDovL3VuaXhwYXBhLmNvbS9qcy9tb3VzZS5odG1sXG5cdFx0ICB2YXIgYnV0dG9uO1xuXHQgICAgaWYgKCFlLndoaWNoKSB7XG5cdCAgICAgIC8qIElFIGNhc2UgKi9cblx0ICAgICAgYnV0dG9uID0gKGUuYnV0dG9uIDwgMikgPyAwIDpcblx0ICAgICAgICAgICAgICAgKChlLmJ1dHRvbiA9PSA0KSA/IDEgOiAyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8qIEFsbCBvdGhlcnMgKi9cblx0ICAgICAgYnV0dG9uID0gZS5idXR0b247XG5cdCAgICB9XG5cdFx0XHRpZiAoIGJ1dHRvbiAhPT0gMCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCAodGhpcy5pbml0aWF0ZWQgJiYgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAmJiAhdXRpbHMuaXNCYWRBbmRyb2lkICYmICF1dGlscy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbihlLnRhcmdldCwgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0cG9zO1xuXG5cdFx0dGhpcy5pbml0aWF0ZWRcdD0gdXRpbHMuZXZlbnRUeXBlW2UudHlwZV07XG5cdFx0dGhpcy5tb3ZlZFx0XHQ9IGZhbHNlO1xuXHRcdHRoaXMuZGlzdFhcdFx0PSAwO1xuXHRcdHRoaXMuZGlzdFlcdFx0PSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9IDA7XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKCk7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0XHRwb3MgPSB0aGlzLmdldENvbXB1dGVkUG9zaXRpb24oKTtcblx0XHRcdHRoaXMuX3RyYW5zbGF0ZShNYXRoLnJvdW5kKHBvcy54KSwgTWF0aC5yb3VuZChwb3MueSkpO1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHR9IGVsc2UgaWYgKCAhdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0FuaW1hdGluZyApIHtcblx0XHRcdHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdGFydFggICAgPSB0aGlzLng7XG5cdFx0dGhpcy5zdGFydFkgICAgPSB0aGlzLnk7XG5cdFx0dGhpcy5hYnNTdGFydFggPSB0aGlzLng7XG5cdFx0dGhpcy5hYnNTdGFydFkgPSB0aGlzLnk7XG5cdFx0dGhpcy5wb2ludFggICAgPSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLnBvaW50WSAgICA9IHBvaW50LnBhZ2VZO1xuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdiZWZvcmVTY3JvbGxTdGFydCcpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPT0gdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgKSB7XHQvLyBpbmNyZWFzZXMgcGVyZm9ybWFuY2Ugb24gQW5kcm9pZD8gVE9ETzogY2hlY2shXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvaW50XHRcdD0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcblx0XHRcdGRlbHRhWFx0XHQ9IHBvaW50LnBhZ2VYIC0gdGhpcy5wb2ludFgsXG5cdFx0XHRkZWx0YVlcdFx0PSBwb2ludC5wYWdlWSAtIHRoaXMucG9pbnRZLFxuXHRcdFx0dGltZXN0YW1wXHQ9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHRhYnNEaXN0WCwgYWJzRGlzdFk7XG5cblx0XHR0aGlzLnBvaW50WFx0XHQ9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMucG9pbnRZXHRcdD0gcG9pbnQucGFnZVk7XG5cblx0XHR0aGlzLmRpc3RYXHRcdCs9IGRlbHRhWDtcblx0XHR0aGlzLmRpc3RZXHRcdCs9IGRlbHRhWTtcblx0XHRhYnNEaXN0WFx0XHQ9IE1hdGguYWJzKHRoaXMuZGlzdFgpO1xuXHRcdGFic0Rpc3RZXHRcdD0gTWF0aC5hYnModGhpcy5kaXN0WSk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIG1vdmUgYXQgbGVhc3QgMTAgcGl4ZWxzIGZvciB0aGUgc2Nyb2xsaW5nIHRvIGluaXRpYXRlXG5cdFx0aWYgKCB0aW1lc3RhbXAgLSB0aGlzLmVuZFRpbWUgPiAzMDAgJiYgKGFic0Rpc3RYIDwgMTAgJiYgYWJzRGlzdFkgPCAxMCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgeW91IGFyZSBzY3JvbGxpbmcgaW4gb25lIGRpcmVjdGlvbiBsb2NrIHRoZSBvdGhlclxuXHRcdGlmICggIXRoaXMuZGlyZWN0aW9uTG9ja2VkICYmICF0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCApIHtcblx0XHRcdGlmICggYWJzRGlzdFggPiBhYnNEaXN0WSArIHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkICkge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICdoJztcdFx0Ly8gbG9jayBob3Jpem9udGFsbHlcblx0XHRcdH0gZWxzZSBpZiAoIGFic0Rpc3RZID49IGFic0Rpc3RYICsgdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQgKSB7XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uTG9ja2VkID0gJ3YnO1x0XHQvLyBsb2NrIHZlcnRpY2FsbHlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uTG9ja2VkID0gJ24nO1x0XHQvLyBubyBsb2NrXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmRpcmVjdGlvbkxvY2tlZCA9PSAnaCcgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICd2ZXJ0aWNhbCcgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICdob3Jpem9udGFsJyApIHtcblx0XHRcdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YVkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuZGlyZWN0aW9uTG9ja2VkID09ICd2JyApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ2hvcml6b250YWwnICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnICkge1xuXHRcdFx0XHR0aGlzLmluaXRpYXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhWCA9IDA7XG5cdFx0fVxuXG5cdFx0ZGVsdGFYID0gdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsID8gZGVsdGFYIDogMDtcblx0XHRkZWx0YVkgPSB0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsID8gZGVsdGFZIDogMDtcblxuXHRcdG5ld1ggPSB0aGlzLnggKyBkZWx0YVg7XG5cdFx0bmV3WSA9IHRoaXMueSArIGRlbHRhWTtcblxuXHRcdC8vIFNsb3cgZG93biBpZiBvdXRzaWRlIG9mIHRoZSBib3VuZGFyaWVzXG5cdFx0aWYgKCBuZXdYID4gMCB8fCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0bmV3WCA9IHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLnggKyBkZWx0YVggLyAzIDogbmV3WCA+IDAgPyAwIDogdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblx0XHRpZiAoIG5ld1kgPiAwIHx8IG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRuZXdZID0gdGhpcy5vcHRpb25zLmJvdW5jZSA/IHRoaXMueSArIGRlbHRhWSAvIDMgOiBuZXdZID4gMCA/IDAgOiB0aGlzLm1heFNjcm9sbFk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gZGVsdGFYID4gMCA/IC0xIDogZGVsdGFYIDwgMCA/IDEgOiAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWSA9IGRlbHRhWSA+IDAgPyAtMSA6IGRlbHRhWSA8IDAgPyAxIDogMDtcblxuXHRcdGlmICggIXRoaXMubW92ZWQgKSB7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbFN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb3ZlZCA9IHRydWU7XG5cblx0XHR0aGlzLl90cmFuc2xhdGUobmV3WCwgbmV3WSk7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IF9tb3ZlICovXG5cblx0XHRpZiAoIHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gMzAwICkge1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSB0aW1lc3RhbXA7XG5cdFx0XHR0aGlzLnN0YXJ0WCA9IHRoaXMueDtcblx0XHRcdHRoaXMuc3RhcnRZID0gdGhpcy55O1xuXHRcdH1cblxuLyogUkVQTEFDRSBFTkQ6IF9tb3ZlICovXG5cblx0fSxcblxuXHRfZW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPT0gdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgJiYgIXV0aWxzLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKGUudGFyZ2V0LCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHRFeGNlcHRpb24pICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHZhciBwb2ludCA9IGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZSxcblx0XHRcdG1vbWVudHVtWCxcblx0XHRcdG1vbWVudHVtWSxcblx0XHRcdGR1cmF0aW9uID0gdXRpbHMuZ2V0VGltZSgpIC0gdGhpcy5zdGFydFRpbWUsXG5cdFx0XHRuZXdYID0gTWF0aC5yb3VuZCh0aGlzLngpLFxuXHRcdFx0bmV3WSA9IE1hdGgucm91bmQodGhpcy55KSxcblx0XHRcdGRpc3RhbmNlWCA9IE1hdGguYWJzKG5ld1ggLSB0aGlzLnN0YXJ0WCksXG5cdFx0XHRkaXN0YW5jZVkgPSBNYXRoLmFicyhuZXdZIC0gdGhpcy5zdGFydFkpLFxuXHRcdFx0dGltZSA9IDAsXG5cdFx0XHRlYXNpbmcgPSAnJztcblxuXHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSAwO1xuXHRcdHRoaXMuaW5pdGlhdGVkID0gMDtcblx0XHR0aGlzLmVuZFRpbWUgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHQvLyByZXNldCBpZiB3ZSBhcmUgb3V0c2lkZSBvZiB0aGUgYm91bmRhcmllc1xuXHRcdGlmICggdGhpcy5yZXNldFBvc2l0aW9uKHRoaXMub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1kpO1x0Ly8gZW5zdXJlcyB0aGF0IHRoZSBsYXN0IHBvc2l0aW9uIGlzIHJvdW5kZWRcblxuXHRcdC8vIHdlIHNjcm9sbGVkIGxlc3MgdGhhbiAxMCBwaXhlbHNcblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudGFwICkge1xuXHRcdFx0XHR1dGlscy50YXAoZSwgdGhpcy5vcHRpb25zLnRhcCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNrICkge1xuXHRcdFx0XHR1dGlscy5jbGljayhlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxDYW5jZWwnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2V2ZW50cy5mbGljayAmJiBkdXJhdGlvbiA8IDIwMCAmJiBkaXN0YW5jZVggPCAxMDAgJiYgZGlzdGFuY2VZIDwgMTAwICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdmbGljaycpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHN0YXJ0IG1vbWVudHVtIGFuaW1hdGlvbiBpZiBuZWVkZWRcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb21lbnR1bSAmJiBkdXJhdGlvbiA8IDMwMCApIHtcblx0XHRcdG1vbWVudHVtWCA9IHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IHV0aWxzLm1vbWVudHVtKHRoaXMueCwgdGhpcy5zdGFydFgsIGR1cmF0aW9uLCB0aGlzLm1heFNjcm9sbFgsIHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLndyYXBwZXJXaWR0aCA6IDAsIHRoaXMub3B0aW9ucy5kZWNlbGVyYXRpb24pIDogeyBkZXN0aW5hdGlvbjogbmV3WCwgZHVyYXRpb246IDAgfTtcblx0XHRcdG1vbWVudHVtWSA9IHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB1dGlscy5tb21lbnR1bSh0aGlzLnksIHRoaXMuc3RhcnRZLCBkdXJhdGlvbiwgdGhpcy5tYXhTY3JvbGxZLCB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy53cmFwcGVySGVpZ2h0IDogMCwgdGhpcy5vcHRpb25zLmRlY2VsZXJhdGlvbikgOiB7IGRlc3RpbmF0aW9uOiBuZXdZLCBkdXJhdGlvbjogMCB9O1xuXHRcdFx0bmV3WCA9IG1vbWVudHVtWC5kZXN0aW5hdGlvbjtcblx0XHRcdG5ld1kgPSBtb21lbnR1bVkuZGVzdGluYXRpb247XG5cdFx0XHR0aW1lID0gTWF0aC5tYXgobW9tZW50dW1YLmR1cmF0aW9uLCBtb21lbnR1bVkuZHVyYXRpb24pO1xuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IDE7XG5cdFx0fVxuXG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dmFyIHNuYXAgPSB0aGlzLl9uZWFyZXN0U25hcChuZXdYLCBuZXdZKTtcblx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0dGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdYIC0gc25hcC54KSwgMTAwMCksXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdZIC0gc25hcC55KSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXHRcdFx0bmV3WCA9IHNuYXAueDtcblx0XHRcdG5ld1kgPSBzbmFwLnk7XG5cblx0XHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXHRcdFx0ZWFzaW5nID0gdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX2VuZFxuXG5cdFx0aWYgKCBuZXdYICE9IHRoaXMueCB8fCBuZXdZICE9IHRoaXMueSApIHtcblx0XHRcdC8vIGNoYW5nZSBlYXNpbmcgZnVuY3Rpb24gd2hlbiBzY3JvbGxlciBnb2VzIG91dCBvZiB0aGUgYm91bmRhcmllc1xuXHRcdFx0aWYgKCBuZXdYID4gMCB8fCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYIHx8IG5ld1kgPiAwIHx8IG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRcdGVhc2luZyA9IHV0aWxzLmVhc2UucXVhZHJhdGljO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIHRpbWUsIGVhc2luZyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG5cblx0XHR0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQucmVmcmVzaCgpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nKTtcblx0fSxcblxuXHRyZXNldFBvc2l0aW9uOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHZhciB4ID0gdGhpcy54LFxuXHRcdFx0eSA9IHRoaXMueTtcblxuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgfHwgdGhpcy54ID4gMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCB8fCB0aGlzLnkgPiAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy55IDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHRpZiAoIHggPT0gdGhpcy54ICYmIHkgPT0gdGhpcy55ICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJmID0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodDtcdFx0Ly8gRm9yY2UgcmVmbG93XG5cblx0XHR0aGlzLndyYXBwZXJXaWR0aFx0PSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cdFx0dGhpcy53cmFwcGVySGVpZ2h0XHQ9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IHJlZnJlc2ggKi9cblxuXHRcdHRoaXMuc2Nyb2xsZXJXaWR0aFx0PSB0aGlzLnNjcm9sbGVyLm9mZnNldFdpZHRoO1xuXHRcdHRoaXMuc2Nyb2xsZXJIZWlnaHRcdD0gdGhpcy5zY3JvbGxlci5vZmZzZXRIZWlnaHQ7XG5cblx0XHR0aGlzLm1heFNjcm9sbFhcdFx0PSB0aGlzLndyYXBwZXJXaWR0aCAtIHRoaXMuc2Nyb2xsZXJXaWR0aDtcblx0XHR0aGlzLm1heFNjcm9sbFlcdFx0PSB0aGlzLndyYXBwZXJIZWlnaHQgLSB0aGlzLnNjcm9sbGVySGVpZ2h0O1xuXG4vKiBSRVBMQUNFIEVORDogcmVmcmVzaCAqL1xuXG5cdFx0dGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsXHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxYICYmIHRoaXMubWF4U2Nyb2xsWCA8IDA7XG5cdFx0dGhpcy5oYXNWZXJ0aWNhbFNjcm9sbFx0XHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxZICYmIHRoaXMubWF4U2Nyb2xsWSA8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgKSB7XG5cdFx0XHR0aGlzLm1heFNjcm9sbFggPSAwO1xuXHRcdFx0dGhpcy5zY3JvbGxlcldpZHRoID0gdGhpcy53cmFwcGVyV2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHRoaXMubWF4U2Nyb2xsWSA9IDA7XG5cdFx0XHR0aGlzLnNjcm9sbGVySGVpZ2h0ID0gdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdH1cblxuXHRcdHRoaXMuZW5kVGltZSA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXG5cdFx0dGhpcy53cmFwcGVyT2Zmc2V0ID0gdXRpbHMub2Zmc2V0KHRoaXMud3JhcHBlcik7XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ3JlZnJlc2gnKTtcblxuXHRcdHRoaXMucmVzZXRQb3NpdGlvbigpO1xuXG4vLyBJTlNFUlQgUE9JTlQ6IF9yZWZyZXNoXG5cblx0fSxcblxuXHRvbjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2goZm4pO1xuXHR9LFxuXG5cdG9mZjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5pbmRleE9mKGZuKTtcblxuXHRcdGlmICggaW5kZXggPiAtMSApIHtcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSxcblxuXHRfZXhlY0V2ZW50OiBmdW5jdGlvbiAodHlwZSkge1xuXHRcdGlmICggIXRoaXMuX2V2ZW50c1t0eXBlXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsID0gdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcblxuXHRcdGlmICggIWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdW2ldLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0eCA9IHRoaXMueCArIHg7XG5cdFx0eSA9IHRoaXMueSArIHk7XG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRzY3JvbGxUbzogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB1dGlscy5lYXNlLmNpcmN1bGFyO1xuXG5cdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRpbWUgPiAwO1xuXHRcdHZhciB0cmFuc2l0aW9uVHlwZSA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIGVhc2luZy5zdHlsZTtcblx0XHRpZiAoICF0aW1lIHx8IHRyYW5zaXRpb25UeXBlICkge1xuXHRcdFx0XHRpZih0cmFuc2l0aW9uVHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbihlYXNpbmcuc3R5bGUpO1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKHRpbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FuaW1hdGUoeCwgeSwgdGltZSwgZWFzaW5nLmZuKTtcblx0XHR9XG5cdH0sXG5cblx0c2Nyb2xsVG9FbGVtZW50OiBmdW5jdGlvbiAoZWwsIHRpbWUsIG9mZnNldFgsIG9mZnNldFksIGVhc2luZykge1xuXHRcdGVsID0gZWwubm9kZVR5cGUgPyBlbCA6IHRoaXMuc2Nyb2xsZXIucXVlcnlTZWxlY3RvcihlbCk7XG5cblx0XHRpZiAoICFlbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcG9zID0gdXRpbHMub2Zmc2V0KGVsKTtcblxuXHRcdHBvcy5sZWZ0IC09IHRoaXMud3JhcHBlck9mZnNldC5sZWZ0O1xuXHRcdHBvcy50b3AgIC09IHRoaXMud3JhcHBlck9mZnNldC50b3A7XG5cblx0XHQvLyBpZiBvZmZzZXRYL1kgYXJlIHRydWUgd2UgY2VudGVyIHRoZSBlbGVtZW50IHRvIHRoZSBzY3JlZW5cblx0XHRpZiAoIG9mZnNldFggPT09IHRydWUgKSB7XG5cdFx0XHRvZmZzZXRYID0gTWF0aC5yb3VuZChlbC5vZmZzZXRXaWR0aCAvIDIgLSB0aGlzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyKTtcblx0XHR9XG5cdFx0aWYgKCBvZmZzZXRZID09PSB0cnVlICkge1xuXHRcdFx0b2Zmc2V0WSA9IE1hdGgucm91bmQoZWwub2Zmc2V0SGVpZ2h0IC8gMiAtIHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRwb3MubGVmdCAtPSBvZmZzZXRYIHx8IDA7XG5cdFx0cG9zLnRvcCAgLT0gb2Zmc2V0WSB8fCAwO1xuXG5cdFx0cG9zLmxlZnQgPSBwb3MubGVmdCA+IDAgPyAwIDogcG9zLmxlZnQgPCB0aGlzLm1heFNjcm9sbFggPyB0aGlzLm1heFNjcm9sbFggOiBwb3MubGVmdDtcblx0XHRwb3MudG9wICA9IHBvcy50b3AgID4gMCA/IDAgOiBwb3MudG9wICA8IHRoaXMubWF4U2Nyb2xsWSA/IHRoaXMubWF4U2Nyb2xsWSA6IHBvcy50b3A7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkIHx8IHRpbWUgPT09IG51bGwgfHwgdGltZSA9PT0gJ2F1dG8nID8gTWF0aC5tYXgoTWF0aC5hYnModGhpcy54LXBvcy5sZWZ0KSwgTWF0aC5hYnModGhpcy55LXBvcy50b3ApKSA6IHRpbWU7XG5cblx0XHR0aGlzLnNjcm9sbFRvKHBvcy5sZWZ0LCBwb3MudG9wLCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXG5cdFx0dmFyIGR1cmF0aW9uUHJvcCA9IHV0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbjtcblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9IHRpbWUgKyAnbXMnO1xuXG5cdFx0aWYgKCAhdGltZSAmJiB1dGlscy5pc0JhZEFuZHJvaWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwLjAwMDFtcyc7XG5cdFx0XHQvLyByZW1vdmUgMC4wMDAxbXNcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHJBRihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5zY3JvbGxlclN0eWxlW2R1cmF0aW9uUHJvcF0gPT09ICcwLjAwMDFtcycpIHtcblx0XHRcdFx0XHRzZWxmLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwcyc7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltZSh0aW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWVcblxuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uIChlYXNpbmcpIHtcblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZztcblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24oZWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXG5cblx0fSxcblxuXHRfdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblxuLyogUkVQTEFDRSBTVEFSVDogX3RyYW5zbGF0ZSAqL1xuXG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyArIHRoaXMudHJhbnNsYXRlWjtcblxuLyogUkVQTEFDRSBFTkQ6IF90cmFuc2xhdGUgKi9cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gTWF0aC5yb3VuZCh4KTtcblx0XHRcdHkgPSBNYXRoLnJvdW5kKHkpO1xuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuc2Nyb2xsZXJTdHlsZS50b3AgPSB5ICsgJ3B4Jztcblx0XHR9XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblxuXHRpZiAoIHRoaXMuaW5kaWNhdG9ycyApIHtcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udXBkYXRlUG9zaXRpb24oKTtcblx0XHR9XG5cdH1cblxuXG4vLyBJTlNFUlQgUE9JTlQ6IF90cmFuc2xhdGVcblxuXHR9LFxuXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0dmFyIGV2ZW50VHlwZSA9IHJlbW92ZSA/IHV0aWxzLnJlbW92ZUV2ZW50IDogdXRpbHMuYWRkRXZlbnQsXG5cdFx0XHR0YXJnZXQgPSB0aGlzLm9wdGlvbnMuYmluZFRvV3JhcHBlciA/IHRoaXMud3JhcHBlciA6IHdpbmRvdztcblxuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdyZXNpemUnLCB0aGlzKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNrICkge1xuXHRcdFx0ZXZlbnRUeXBlKHRoaXMud3JhcHBlciwgJ2NsaWNrJywgdGhpcywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVNb3VzZSApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICdtb3VzZWRvd24nLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZW1vdmUnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZWNhbmNlbCcsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoIHV0aWxzLmhhc1BvaW50ZXIgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlUG9pbnRlciApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyY2FuY2VsJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCB1dGlscy5oYXNUb3VjaCAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVUb3VjaCApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2hjYW5jZWwnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ01TVHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHR9LFxuXG5cdGdldENvbXB1dGVkUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWF0cml4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxlciwgbnVsbCksXG5cdFx0XHR4LCB5O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4W3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0uc3BsaXQoJyknKVswXS5zcGxpdCgnLCAnKTtcblx0XHRcdHggPSArKG1hdHJpeFsxMl0gfHwgbWF0cml4WzRdKTtcblx0XHRcdHkgPSArKG1hdHJpeFsxM10gfHwgbWF0cml4WzVdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9ICttYXRyaXgubGVmdC5yZXBsYWNlKC9bXi1cXGQuXS9nLCAnJyk7XG5cdFx0XHR5ID0gK21hdHJpeC50b3AucmVwbGFjZSgvW14tXFxkLl0vZywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblx0fSxcblx0X2luaXRJbmRpY2F0b3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGludGVyYWN0aXZlID0gdGhpcy5vcHRpb25zLmludGVyYWN0aXZlU2Nyb2xsYmFycyxcblx0XHRcdGN1c3RvbVN0eWxlID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICE9ICdzdHJpbmcnLFxuXHRcdFx0aW5kaWNhdG9ycyA9IFtdLFxuXHRcdFx0aW5kaWNhdG9yO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5pbmRpY2F0b3JzID0gW107XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICkge1xuXHRcdFx0Ly8gVmVydGljYWwgc2Nyb2xsYmFyXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxZICkge1xuXHRcdFx0XHRpbmRpY2F0b3IgPSB7XG5cdFx0XHRcdFx0ZWw6IGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIoJ3YnLCBpbnRlcmFjdGl2ZSwgdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMpLFxuXHRcdFx0XHRcdGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZSxcblx0XHRcdFx0XHRkZWZhdWx0U2Nyb2xsYmFyczogdHJ1ZSxcblx0XHRcdFx0XHRjdXN0b21TdHlsZTogY3VzdG9tU3R5bGUsXG5cdFx0XHRcdFx0cmVzaXplOiB0aGlzLm9wdGlvbnMucmVzaXplU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRzaHJpbms6IHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGZhZGU6IHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRsaXN0ZW5YOiBmYWxzZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IuZWwpO1xuXHRcdFx0XHRpbmRpY2F0b3JzLnB1c2goaW5kaWNhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9yaXpvbnRhbCBzY3JvbGxiYXJcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbFggKSB7XG5cdFx0XHRcdGluZGljYXRvciA9IHtcblx0XHRcdFx0XHRlbDogY3JlYXRlRGVmYXVsdFNjcm9sbGJhcignaCcsIGludGVyYWN0aXZlLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyksXG5cdFx0XHRcdFx0aW50ZXJhY3RpdmU6IGludGVyYWN0aXZlLFxuXHRcdFx0XHRcdGRlZmF1bHRTY3JvbGxiYXJzOiB0cnVlLFxuXHRcdFx0XHRcdGN1c3RvbVN0eWxlOiBjdXN0b21TdHlsZSxcblx0XHRcdFx0XHRyZXNpemU6IHRoaXMub3B0aW9ucy5yZXNpemVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdHNocmluazogdGhpcy5vcHRpb25zLnNocmlua1Njcm9sbGJhcnMsXG5cdFx0XHRcdFx0ZmFkZTogdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGxpc3Rlblk6IGZhbHNlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvci5lbCk7XG5cdFx0XHRcdGluZGljYXRvcnMucHVzaChpbmRpY2F0b3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmluZGljYXRvcnMgKSB7XG5cdFx0XHQvLyBUT0RPOiBjaGVjayBjb25jYXQgY29tcGF0aWJpbGl0eVxuXHRcdFx0aW5kaWNhdG9ycyA9IGluZGljYXRvcnMuY29uY2F0KHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzKTtcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IGluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JzLnB1c2goIG5ldyBJbmRpY2F0b3IodGhpcywgaW5kaWNhdG9yc1tpXSkgKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBjaGVjayBpZiB3ZSBjYW4gdXNlIGFycmF5Lm1hcCAod2lkZSBjb21wYXRpYmlsaXR5IGFuZCBwZXJmb3JtYW5jZSBpc3N1ZXMpXG5cdFx0ZnVuY3Rpb24gX2luZGljYXRvcnNNYXAgKGZuKSB7XG5cdFx0XHRpZiAodGhhdC5pbmRpY2F0b3JzKSB7XG5cdFx0XHRcdGZvciAoIHZhciBpID0gdGhhdC5pbmRpY2F0b3JzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoYXQuaW5kaWNhdG9yc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyApIHtcblx0XHRcdHRoaXMub24oJ3Njcm9sbEVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLm9uKCdzY3JvbGxDYW5jZWwnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbignc2Nyb2xsU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMub24oJ2JlZm9yZVNjcm9sbFN0YXJ0JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKDEsIHRydWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGRlbGV0ZSB0aGlzLmluZGljYXRvcnM7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRXaGVlbDogZnVuY3Rpb24gKCkge1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ3doZWVsJywgdGhpcyk7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnbW91c2V3aGVlbCcsIHRoaXMpO1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2hlZWxUaW1lb3V0KTtcblx0XHRcdHRoaXMud2hlZWxUaW1lb3V0ID0gbnVsbDtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMud3JhcHBlciwgJ3doZWVsJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICdtb3VzZXdoZWVsJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICdET01Nb3VzZVNjcm9sbCcsIHRoaXMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF93aGVlbDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dmFyIHdoZWVsRGVsdGFYLCB3aGVlbERlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGlmICggdGhpcy53aGVlbFRpbWVvdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBFeGVjdXRlIHRoZSBzY3JvbGxFbmQgZXZlbnQgYWZ0ZXIgNDAwbXMgdGhlIHdoZWVsIHN0b3BwZWQgc2Nyb2xsaW5nXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2hlZWxUaW1lb3V0KTtcblx0XHR0aGlzLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYoIXRoYXQub3B0aW9ucy5zbmFwKSB7XG5cdFx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGF0LndoZWVsVGltZW91dCA9IHVuZGVmaW5lZDtcblx0XHR9LCA0MDApO1xuXG5cdFx0aWYgKCAnZGVsdGFYJyBpbiBlICkge1xuXHRcdFx0aWYgKGUuZGVsdGFNb2RlID09PSAxKSB7XG5cdFx0XHRcdHdoZWVsRGVsdGFYID0gLWUuZGVsdGFYICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHRcdFx0d2hlZWxEZWx0YVkgPSAtZS5kZWx0YVkgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hlZWxEZWx0YVggPSAtZS5kZWx0YVg7XG5cdFx0XHRcdHdoZWVsRGVsdGFZID0gLWUuZGVsdGFZO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhWCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gZS53aGVlbERlbHRhWCAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0XHR3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YVkgLyAxMjAgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YSAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0fSBlbHNlIGlmICggJ2RldGFpbCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gd2hlZWxEZWx0YVkgPSAtZS5kZXRhaWwgLyAzICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHdoZWVsRGVsdGFYICo9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbjtcblx0XHR3aGVlbERlbHRhWSAqPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb247XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWTtcblx0XHRcdHdoZWVsRGVsdGFZID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0bmV3WCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVg7XG5cdFx0XHRuZXdZID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdFx0aWYgKCB3aGVlbERlbHRhWCA+IDAgKSB7XG5cdFx0XHRcdG5ld1gtLTtcblx0XHRcdH0gZWxzZSBpZiAoIHdoZWVsRGVsdGFYIDwgMCApIHtcblx0XHRcdFx0bmV3WCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdoZWVsRGVsdGFZID4gMCApIHtcblx0XHRcdFx0bmV3WS0tO1xuXHRcdFx0fSBlbHNlIGlmICggd2hlZWxEZWx0YVkgPCAwICkge1xuXHRcdFx0XHRuZXdZKys7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRuZXdYID0gdGhpcy54ICsgTWF0aC5yb3VuZCh0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgPyB3aGVlbERlbHRhWCA6IDApO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBNYXRoLnJvdW5kKHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB3aGVlbERlbHRhWSA6IDApO1xuXG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gd2hlZWxEZWx0YVggPiAwID8gLTEgOiB3aGVlbERlbHRhWCA8IDAgPyAxIDogMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSB3aGVlbERlbHRhWSA+IDAgPyAtMSA6IHdoZWVsRGVsdGFZIDwgMCA/IDEgOiAwO1xuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG4vLyBJTlNFUlQgUE9JTlQ6IF93aGVlbFxuXHR9LFxuXG5cdF9pbml0U25hcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY3VycmVudFBhZ2UgPSB7fTtcblxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5zbmFwID09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnNuYXAgPSB0aGlzLnNjcm9sbGVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNuYXApO1xuXHRcdH1cblxuXHRcdHRoaXMub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSA9IDAsIGwsXG5cdFx0XHRcdG0gPSAwLCBuLFxuXHRcdFx0XHRjeCwgY3ksXG5cdFx0XHRcdHggPSAwLCB5LFxuXHRcdFx0XHRzdGVwWCA9IHRoaXMub3B0aW9ucy5zbmFwU3RlcFggfHwgdGhpcy53cmFwcGVyV2lkdGgsXG5cdFx0XHRcdHN0ZXBZID0gdGhpcy5vcHRpb25zLnNuYXBTdGVwWSB8fCB0aGlzLndyYXBwZXJIZWlnaHQsXG5cdFx0XHRcdGVsO1xuXG5cdFx0XHR0aGlzLnBhZ2VzID0gW107XG5cblx0XHRcdGlmICggIXRoaXMud3JhcHBlcldpZHRoIHx8ICF0aGlzLndyYXBwZXJIZWlnaHQgfHwgIXRoaXMuc2Nyb2xsZXJXaWR0aCB8fCAhdGhpcy5zY3JvbGxlckhlaWdodCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwID09PSB0cnVlICkge1xuXHRcdFx0XHRjeCA9IE1hdGgucm91bmQoIHN0ZXBYIC8gMiApO1xuXHRcdFx0XHRjeSA9IE1hdGgucm91bmQoIHN0ZXBZIC8gMiApO1xuXG5cdFx0XHRcdHdoaWxlICggeCA+IC10aGlzLnNjcm9sbGVyV2lkdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5wYWdlc1tpXSA9IFtdO1xuXHRcdFx0XHRcdGwgPSAwO1xuXHRcdFx0XHRcdHkgPSAwO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCB5ID4gLXRoaXMuc2Nyb2xsZXJIZWlnaHQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBhZ2VzW2ldW2xdID0ge1xuXHRcdFx0XHRcdFx0XHR4OiBNYXRoLm1heCh4LCB0aGlzLm1heFNjcm9sbFgpLFxuXHRcdFx0XHRcdFx0XHR5OiBNYXRoLm1heCh5LCB0aGlzLm1heFNjcm9sbFkpLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogc3RlcFgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogc3RlcFksXG5cdFx0XHRcdFx0XHRcdGN4OiB4IC0gY3gsXG5cdFx0XHRcdFx0XHRcdGN5OiB5IC0gY3lcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHkgLT0gc3RlcFk7XG5cdFx0XHRcdFx0XHRsKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eCAtPSBzdGVwWDtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsID0gdGhpcy5vcHRpb25zLnNuYXA7XG5cdFx0XHRcdGwgPSBlbC5sZW5ndGg7XG5cdFx0XHRcdG4gPSAtMTtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBpID09PSAwIHx8IGVsW2ldLm9mZnNldExlZnQgPD0gZWxbaS0xXS5vZmZzZXRMZWZ0ICkge1xuXHRcdFx0XHRcdFx0bSA9IDA7XG5cdFx0XHRcdFx0XHRuKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5wYWdlc1ttXSApIHtcblx0XHRcdFx0XHRcdHRoaXMucGFnZXNbbV0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR4ID0gTWF0aC5tYXgoLWVsW2ldLm9mZnNldExlZnQsIHRoaXMubWF4U2Nyb2xsWCk7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWF4KC1lbFtpXS5vZmZzZXRUb3AsIHRoaXMubWF4U2Nyb2xsWSk7XG5cdFx0XHRcdFx0Y3ggPSB4IC0gTWF0aC5yb3VuZChlbFtpXS5vZmZzZXRXaWR0aCAvIDIpO1xuXHRcdFx0XHRcdGN5ID0geSAtIE1hdGgucm91bmQoZWxbaV0ub2Zmc2V0SGVpZ2h0IC8gMik7XG5cblx0XHRcdFx0XHR0aGlzLnBhZ2VzW21dW25dID0ge1xuXHRcdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0XHR3aWR0aDogZWxbaV0ub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGVsW2ldLm9mZnNldEhlaWdodCxcblx0XHRcdFx0XHRcdGN4OiBjeCxcblx0XHRcdFx0XHRcdGN5OiBjeVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIHggPiB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRcdFx0XHRtKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UodGhpcy5jdXJyZW50UGFnZS5wYWdlWCB8fCAwLCB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZIHx8IDAsIDApO1xuXG5cdFx0XHQvLyBVcGRhdGUgc25hcCB0aHJlc2hvbGQgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkICUgMSA9PT0gMCApIHtcblx0XHRcdFx0dGhpcy5zbmFwVGhyZXNob2xkWCA9IHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRYID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLndpZHRoICogdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQpO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLmhlaWdodCAqIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2ZsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy54IC0gdGhpcy5zdGFydFgpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMueSAtIHRoaXMuc3RhcnRZKSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXG5cdFx0XHR0aGlzLmdvVG9QYWdlKFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYICsgdGhpcy5kaXJlY3Rpb25YLFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICsgdGhpcy5kaXJlY3Rpb25ZLFxuXHRcdFx0XHR0aW1lXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9uZWFyZXN0U25hcDogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAoICF0aGlzLnBhZ2VzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHg6IDAsIHk6IDAsIHBhZ2VYOiAwLCBwYWdlWTogMCB9O1xuXHRcdH1cblxuXHRcdHZhciBpID0gMCxcblx0XHRcdGwgPSB0aGlzLnBhZ2VzLmxlbmd0aCxcblx0XHRcdG0gPSAwO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZXhjZWVkZWQgdGhlIHNuYXAgdGhyZXNob2xkXG5cdFx0aWYgKCBNYXRoLmFicyh4IC0gdGhpcy5hYnNTdGFydFgpIDwgdGhpcy5zbmFwVGhyZXNob2xkWCAmJlxuXHRcdFx0TWF0aC5hYnMoeSAtIHRoaXMuYWJzU3RhcnRZKSA8IHRoaXMuc25hcFRocmVzaG9sZFkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50UGFnZTtcblx0XHR9XG5cblx0XHRpZiAoIHggPiAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fSBlbHNlIGlmICggeCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCB5ID4gMCApIHtcblx0XHRcdHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHkgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHR5ID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggeCA+PSB0aGlzLnBhZ2VzW2ldWzBdLmN4ICkge1xuXHRcdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsID0gdGhpcy5wYWdlc1tpXS5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IG0gPCBsOyBtKysgKSB7XG5cdFx0XHRpZiAoIHkgPj0gdGhpcy5wYWdlc1swXVttXS5jeSApIHtcblx0XHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpID09IHRoaXMuY3VycmVudFBhZ2UucGFnZVggKSB7XG5cdFx0XHRpICs9IHRoaXMuZGlyZWN0aW9uWDtcblxuXHRcdFx0aWYgKCBpIDwgMCApIHtcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCBpID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0XHRpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXG5cdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdH1cblxuXHRcdGlmICggbSA9PSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICkge1xuXHRcdFx0bSArPSB0aGlzLmRpcmVjdGlvblk7XG5cblx0XHRcdGlmICggbSA8IDAgKSB7XG5cdFx0XHRcdG0gPSAwO1xuXHRcdFx0fSBlbHNlIGlmICggbSA+PSB0aGlzLnBhZ2VzWzBdLmxlbmd0aCApIHtcblx0XHRcdFx0bSA9IHRoaXMucGFnZXNbMF0ubGVuZ3RoIC0gMTtcblx0XHRcdH1cblxuXHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHksXG5cdFx0XHRwYWdlWDogaSxcblx0XHRcdHBhZ2VZOiBtXG5cdFx0fTtcblx0fSxcblxuXHRnb1RvUGFnZTogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nO1xuXG5cdFx0aWYgKCB4ID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0eCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblxuXHRcdGlmICggeSA+PSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCApIHtcblx0XHRcdHkgPSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9XG5cblx0XHR2YXIgcG9zWCA9IHRoaXMucGFnZXNbeF1beV0ueCxcblx0XHRcdHBvc1kgPSB0aGlzLnBhZ2VzW3hdW3ldLnk7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhwb3NYIC0gdGhpcy54KSwgMTAwMCksXG5cdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHBvc1kgLSB0aGlzLnkpLCAxMDAwKVxuXHRcdFx0KSwgMzAwKSA6IHRpbWU7XG5cblx0XHR0aGlzLmN1cnJlbnRQYWdlID0ge1xuXHRcdFx0eDogcG9zWCxcblx0XHRcdHk6IHBvc1ksXG5cdFx0XHRwYWdlWDogeCxcblx0XHRcdHBhZ2VZOiB5XG5cdFx0fTtcblxuXHRcdHRoaXMuc2Nyb2xsVG8ocG9zWCwgcG9zWSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRuZXh0OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4Kys7XG5cblx0XHRpZiAoIHggPj0gdGhpcy5wYWdlcy5sZW5ndGggJiYgdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eSsrO1xuXHRcdH1cblxuXHRcdHRoaXMuZ29Ub1BhZ2UoeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRwcmV2OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4LS07XG5cblx0XHRpZiAoIHggPCAwICYmIHRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHRcdHktLTtcblx0XHR9XG5cblx0XHR0aGlzLmdvVG9QYWdlKHgsIHksIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0X2luaXRLZXlzOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRlZmF1bHQga2V5IGJpbmRpbmdzXG5cdFx0dmFyIGtleXMgPSB7XG5cdFx0XHRwYWdlVXA6IDMzLFxuXHRcdFx0cGFnZURvd246IDM0LFxuXHRcdFx0ZW5kOiAzNSxcblx0XHRcdGhvbWU6IDM2LFxuXHRcdFx0bGVmdDogMzcsXG5cdFx0XHR1cDogMzgsXG5cdFx0XHRyaWdodDogMzksXG5cdFx0XHRkb3duOiA0MFxuXHRcdH07XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBpZiB5b3UgZ2l2ZSBtZSBjaGFyYWN0ZXJzIEkgZ2l2ZSB5b3Uga2V5Y29kZVxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyA9PSAnb2JqZWN0JyApIHtcblx0XHRcdGZvciAoIGkgaW4gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldID0gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgPSB7fTtcblx0XHR9XG5cblx0XHRmb3IgKCBpIGluIGtleXMgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gfHwga2V5c1tpXTtcblx0XHR9XG5cblx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICdrZXlkb3duJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAna2V5ZG93bicsIHRoaXMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9rZXk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAsXHQvLyB3ZSBhcmUgdXNpbmcgdGhpcyBhbG90LCBiZXR0ZXIgdG8gY2FjaGUgaXRcblx0XHRcdG5ld1ggPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCA6IHRoaXMueCxcblx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWSA6IHRoaXMueSxcblx0XHRcdG5vdyA9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdHByZXZUaW1lID0gdGhpcy5rZXlUaW1lIHx8IDAsXG5cdFx0XHRhY2NlbGVyYXRpb24gPSAwLjI1MCxcblx0XHRcdHBvcztcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHBvcyA9IHRoaXMuZ2V0Q29tcHV0ZWRQb3NpdGlvbigpO1xuXG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoTWF0aC5yb3VuZChwb3MueCksIE1hdGgucm91bmQocG9zLnkpKTtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IG5vdyAtIHByZXZUaW1lIDwgMjAwID8gTWF0aC5taW4odGhpcy5rZXlBY2NlbGVyYXRpb24gKyBhY2NlbGVyYXRpb24sIDUwKSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBlLmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5wYWdlVXA6XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggKz0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZICs9IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucGFnZURvd246XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggLT0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZIC09IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MuZW5kOlxuXHRcdFx0XHRuZXdYID0gc25hcCA/IHRoaXMucGFnZXMubGVuZ3RoLTEgOiB0aGlzLm1heFNjcm9sbFg7XG5cdFx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5wYWdlc1swXS5sZW5ndGgtMSA6IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5ob21lOlxuXHRcdFx0XHRuZXdYID0gMDtcblx0XHRcdFx0bmV3WSA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MubGVmdDpcblx0XHRcdFx0bmV3WCArPSBzbmFwID8gLTEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MudXA6XG5cdFx0XHRcdG5ld1kgKz0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucmlnaHQ6XG5cdFx0XHRcdG5ld1ggLT0gc25hcCA/IC0xIDogNSArIHRoaXMua2V5QWNjZWxlcmF0aW9uPj4wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmRvd246XG5cdFx0XHRcdG5ld1kgLT0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggc25hcCApIHtcblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG5cdFx0dGhpcy5rZXlUaW1lID0gbm93O1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoZGVzdFgsIGRlc3RZLCBkdXJhdGlvbiwgZWFzaW5nRm4pIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdGFydFggPSB0aGlzLngsXG5cdFx0XHRzdGFydFkgPSB0aGlzLnksXG5cdFx0XHRzdGFydFRpbWUgPSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRkZXN0VGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuXG5cdFx0ZnVuY3Rpb24gc3RlcCAoKSB7XG5cdFx0XHR2YXIgbm93ID0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0XHRlYXNpbmc7XG5cblx0XHRcdGlmICggbm93ID49IGRlc3RUaW1lICkge1xuXHRcdFx0XHR0aGF0LmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQuX3RyYW5zbGF0ZShkZXN0WCwgZGVzdFkpO1xuXG5cdFx0XHRcdGlmICggIXRoYXQucmVzZXRQb3NpdGlvbih0aGF0Lm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHRcdFx0dGhhdC5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bm93ID0gKCBub3cgLSBzdGFydFRpbWUgKSAvIGR1cmF0aW9uO1xuXHRcdFx0ZWFzaW5nID0gZWFzaW5nRm4obm93KTtcblx0XHRcdG5ld1ggPSAoIGRlc3RYIC0gc3RhcnRYICkgKiBlYXNpbmcgKyBzdGFydFg7XG5cdFx0XHRuZXdZID0gKCBkZXN0WSAtIHN0YXJ0WSApICogZWFzaW5nICsgc3RhcnRZO1xuXHRcdFx0dGhhdC5fdHJhbnNsYXRlKG5ld1gsIG5ld1kpO1xuXG5cdFx0XHRpZiAoIHRoYXQuaXNBbmltYXRpbmcgKSB7XG5cdFx0XHRcdHJBRihzdGVwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRzdGVwKCk7XG5cdH0sXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHN3aXRjaCAoIGUudHlwZSApIHtcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmRvd24nOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyRG93bic6XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHR0aGlzLl9zdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcm1vdmUnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyTW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJ1cCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJVcCc6XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGNhc2UgJ3RvdWNoY2FuY2VsJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyQ2FuY2VsJzpcblx0XHRcdGNhc2UgJ21vdXNlY2FuY2VsJzpcblx0XHRcdFx0dGhpcy5fZW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ29yaWVudGF0aW9uY2hhbmdlJzpcblx0XHRcdGNhc2UgJ3Jlc2l6ZSc6XG5cdFx0XHRcdHRoaXMuX3Jlc2l6ZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RyYW5zaXRpb25lbmQnOlxuXHRcdFx0Y2FzZSAnd2Via2l0VHJhbnNpdGlvbkVuZCc6XG5cdFx0XHRjYXNlICdvVHJhbnNpdGlvbkVuZCc6XG5cdFx0XHRjYXNlICdNU1RyYW5zaXRpb25FbmQnOlxuXHRcdFx0XHR0aGlzLl90cmFuc2l0aW9uRW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3doZWVsJzpcblx0XHRcdGNhc2UgJ0RPTU1vdXNlU2Nyb2xsJzpcblx0XHRcdGNhc2UgJ21vdXNld2hlZWwnOlxuXHRcdFx0XHR0aGlzLl93aGVlbChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdrZXlkb3duJzpcblx0XHRcdFx0dGhpcy5fa2V5KGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2NsaWNrJzpcblx0XHRcdFx0aWYgKCB0aGlzLmVuYWJsZWQgJiYgIWUuX2NvbnN0cnVjdGVkICkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxufTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIgKGRpcmVjdGlvbiwgaW50ZXJhY3RpdmUsIHR5cGUpIHtcblx0dmFyIHNjcm9sbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5cdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTknO1xuXHRcdGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gJy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMC41KTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC45KTtib3JkZXItcmFkaXVzOjNweCc7XG5cdH1cblxuXHRpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2lTY3JvbGxJbmRpY2F0b3InO1xuXG5cdGlmICggZGlyZWN0aW9uID09ICdoJyApIHtcblx0XHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO2hlaWdodDo3cHg7bGVmdDoycHg7cmlnaHQ6MnB4O2JvdHRvbTowJztcblx0XHRcdGluZGljYXRvci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdFx0fVxuXHRcdHNjcm9sbGJhci5jbGFzc05hbWUgPSAnaVNjcm9sbEhvcml6b250YWxTY3JvbGxiYXInO1xuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRcdHNjcm9sbGJhci5zdHlsZS5jc3NUZXh0ICs9ICc7d2lkdGg6N3B4O2JvdHRvbToycHg7dG9wOjJweDtyaWdodDoxcHgnO1xuXHRcdFx0aW5kaWNhdG9yLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XHRzY3JvbGxiYXIuY2xhc3NOYW1lID0gJ2lTY3JvbGxWZXJ0aWNhbFNjcm9sbGJhcic7XG5cdH1cblxuXHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO292ZXJmbG93OmhpZGRlbic7XG5cblx0aWYgKCAhaW50ZXJhY3RpdmUgKSB7XG5cdFx0c2Nyb2xsYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cdH1cblxuXHRzY3JvbGxiYXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcblxuXHRyZXR1cm4gc2Nyb2xsYmFyO1xufVxuXG5mdW5jdGlvbiBJbmRpY2F0b3IgKHNjcm9sbGVyLCBvcHRpb25zKSB7XG5cdHRoaXMud3JhcHBlciA9IHR5cGVvZiBvcHRpb25zLmVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmVsKSA6IG9wdGlvbnMuZWw7XG5cdHRoaXMud3JhcHBlclN0eWxlID0gdGhpcy53cmFwcGVyLnN0eWxlO1xuXHR0aGlzLmluZGljYXRvciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5pbmRpY2F0b3JTdHlsZSA9IHRoaXMuaW5kaWNhdG9yLnN0eWxlO1xuXHR0aGlzLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG5cblx0dGhpcy5vcHRpb25zID0ge1xuXHRcdGxpc3Rlblg6IHRydWUsXG5cdFx0bGlzdGVuWTogdHJ1ZSxcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cdFx0cmVzaXplOiB0cnVlLFxuXHRcdGRlZmF1bHRTY3JvbGxiYXJzOiBmYWxzZSxcblx0XHRzaHJpbms6IGZhbHNlLFxuXHRcdGZhZGU6IGZhbHNlLFxuXHRcdHNwZWVkUmF0aW9YOiAwLFxuXHRcdHNwZWVkUmF0aW9ZOiAwXG5cdH07XG5cblx0Zm9yICggdmFyIGkgaW4gb3B0aW9ucyApIHtcblx0XHR0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xuXHR9XG5cblx0dGhpcy5zaXplUmF0aW9YID0gMTtcblx0dGhpcy5zaXplUmF0aW9ZID0gMTtcblx0dGhpcy5tYXhQb3NYID0gMDtcblx0dGhpcy5tYXhQb3NZID0gMDtcblxuXHRpZiAoIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSApIHtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVRvdWNoICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBvaW50ZXIgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlTW91c2UgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgJ21vdXNlZG93bicsIHRoaXMpO1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGlmICggdGhpcy5vcHRpb25zLmZhZGUgKSB7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9IHRoaXMuc2Nyb2xsZXIudHJhbnNsYXRlWjtcblx0XHR2YXIgZHVyYXRpb25Qcm9wID0gdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uO1xuXHRcdHRoaXMud3JhcHBlclN0eWxlW2R1cmF0aW9uUHJvcF0gPSB1dGlscy5pc0JhZEFuZHJvaWQgPyAnMC4wMDAxbXMnIDogJzBtcyc7XG5cdFx0Ly8gcmVtb3ZlIDAuMDAwMW1zXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKHV0aWxzLmlzQmFkQW5kcm9pZCkge1xuXHRcdFx0ckFGKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihzZWxmLndyYXBwZXJTdHlsZVtkdXJhdGlvblByb3BdID09PSAnMC4wMDAxbXMnKSB7XG5cdFx0XHRcdFx0c2VsZi53cmFwcGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwcyc7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gJzAnO1xuXHR9XG59XG5cbkluZGljYXRvci5wcm90b3R5cGUgPSB7XG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHN3aXRjaCAoIGUudHlwZSApIHtcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmRvd24nOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyRG93bic6XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHR0aGlzLl9zdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcm1vdmUnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyTW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJ1cCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJVcCc6XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGNhc2UgJ3RvdWNoY2FuY2VsJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyQ2FuY2VsJzpcblx0XHRcdGNhc2UgJ21vdXNlY2FuY2VsJzpcblx0XHRcdFx0dGhpcy5fZW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZmFkZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5mYWRlVGltZW91dCA9IG51bGw7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5vcHRpb25zLmludGVyYWN0aXZlICkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMuaW5kaWNhdG9yLCAnbW91c2Vkb3duJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNoZW5kJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICkge1xuXHRcdFx0dGhpcy53cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHRoaXMudHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdHRoaXMuaW5pdGlhdGVkID0gdHJ1ZTtcblx0XHR0aGlzLm1vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5sYXN0UG9pbnRYXHQ9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMubGFzdFBvaW50WVx0PSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuc3RhcnRUaW1lXHQ9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlVG91Y2ggKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVQb2ludGVyICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZU1vdXNlICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdiZWZvcmVTY3JvbGxTdGFydCcpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG5cdFx0XHRkZWx0YVgsIGRlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aW1lc3RhbXAgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdzY3JvbGxTdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubW92ZWQgPSB0cnVlO1xuXG5cdFx0ZGVsdGFYID0gcG9pbnQucGFnZVggLSB0aGlzLmxhc3RQb2ludFg7XG5cdFx0dGhpcy5sYXN0UG9pbnRYID0gcG9pbnQucGFnZVg7XG5cblx0XHRkZWx0YVkgPSBwb2ludC5wYWdlWSAtIHRoaXMubGFzdFBvaW50WTtcblx0XHR0aGlzLmxhc3RQb2ludFkgPSBwb2ludC5wYWdlWTtcblxuXHRcdG5ld1ggPSB0aGlzLnggKyBkZWx0YVg7XG5cdFx0bmV3WSA9IHRoaXMueSArIGRlbHRhWTtcblxuXHRcdHRoaXMuX3BvcyhuZXdYLCBuZXdZKTtcblxuLy8gSU5TRVJUIFBPSU5UOiBpbmRpY2F0b3IuX21vdmVcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdF9lbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHZhciBzbmFwID0gdGhpcy5zY3JvbGxlci5fbmVhcmVzdFNuYXAodGhpcy5zY3JvbGxlci54LCB0aGlzLnNjcm9sbGVyLnkpO1xuXG5cdFx0XHR2YXIgdGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnNjcm9sbGVyLnggLSBzbmFwLngpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMuc2Nyb2xsZXIueSAtIHNuYXAueSksIDEwMDApXG5cdFx0XHRcdFx0KSwgMzAwKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNjcm9sbGVyLnggIT0gc25hcC54IHx8IHRoaXMuc2Nyb2xsZXIueSAhPSBzbmFwLnkgKSB7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWSA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHNuYXAueCwgc25hcC55LCB0aW1lLCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuYm91bmNlRWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubW92ZWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblx0fSxcblxuXHR0cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXHRcdHZhciBkdXJhdGlvblByb3AgPSB1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb247XG5cdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID0gdGltZSArICdtcyc7XG5cblx0XHRpZiAoICF0aW1lICYmIHV0aWxzLmlzQmFkQW5kcm9pZCApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwLjAwMDFtcyc7XG5cdFx0XHQvLyByZW1vdmUgMC4wMDAxbXNcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHJBRihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID09PSAnMC4wMDAxbXMnKSB7XG5cdFx0XHRcdFx0c2VsZi5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID0gJzBzJztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogZnVuY3Rpb24gKGVhc2luZykge1xuXHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZztcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy50cmFuc2l0aW9uVGltZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCAmJiAhdGhpcy5vcHRpb25zLmxpc3RlblkgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5ZICYmICF0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuZGlzcGxheSA9IHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgfHwgdGhpcy5zY3JvbGxlci5oYXNWZXJ0aWNhbFNjcm9sbCA/ICdibG9jaycgOiAnbm9uZSc7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgJiYgdGhpcy5zY3JvbGxlci5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHV0aWxzLmFkZENsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxCb3RoU2Nyb2xsYmFycycpO1xuXHRcdFx0dXRpbHMucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbExvbmVTY3JvbGxiYXInKTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjcm9sbGJhcnMgJiYgdGhpcy5vcHRpb25zLmN1c3RvbVN0eWxlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5yaWdodCA9ICc4cHgnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5ib3R0b20gPSAnOHB4Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlscy5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsQm90aFNjcm9sbGJhcnMnKTtcblx0XHRcdHV0aWxzLmFkZENsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxMb25lU2Nyb2xsYmFyJyk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICYmIHRoaXMub3B0aW9ucy5jdXN0b21TdHlsZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUucmlnaHQgPSAnMnB4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUuYm90dG9tID0gJzJweCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgciA9IHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQ7XHQvLyBmb3JjZSByZWZyZXNoXG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0dGhpcy53cmFwcGVyV2lkdGggPSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yV2lkdGggPSBNYXRoLm1heChNYXRoLnJvdW5kKHRoaXMud3JhcHBlcldpZHRoICogdGhpcy53cmFwcGVyV2lkdGggLyAodGhpcy5zY3JvbGxlci5zY3JvbGxlcldpZHRoIHx8IHRoaXMud3JhcHBlcldpZHRoIHx8IDEpKSwgOCk7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLmluZGljYXRvcldpZHRoICsgJ3B4Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yV2lkdGggPSB0aGlzLmluZGljYXRvci5jbGllbnRXaWR0aDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NYID0gdGhpcy53cmFwcGVyV2lkdGggLSB0aGlzLmluZGljYXRvcldpZHRoO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ2NsaXAnICkge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WCA9IC10aGlzLmluZGljYXRvcldpZHRoICsgODtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVggPSB0aGlzLndyYXBwZXJXaWR0aCAtIDg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WCA9IDA7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlYID0gdGhpcy5tYXhQb3NYO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNpemVSYXRpb1ggPSB0aGlzLm9wdGlvbnMuc3BlZWRSYXRpb1ggfHwgKHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWCAmJiAodGhpcy5tYXhQb3NYIC8gdGhpcy5zY3JvbGxlci5tYXhTY3JvbGxYKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWSApIHtcblx0XHRcdHRoaXMud3JhcHBlckhlaWdodCA9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9ySGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5yb3VuZCh0aGlzLndyYXBwZXJIZWlnaHQgKiB0aGlzLndyYXBwZXJIZWlnaHQgLyAodGhpcy5zY3JvbGxlci5zY3JvbGxlckhlaWdodCB8fCB0aGlzLndyYXBwZXJIZWlnaHQgfHwgMSkpLCA4KTtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodCArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvckhlaWdodCA9IHRoaXMuaW5kaWNhdG9yLmNsaWVudEhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnY2xpcCcgKSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlZID0gLXRoaXMuaW5kaWNhdG9ySGVpZ2h0ICsgODtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVkgPSB0aGlzLndyYXBwZXJIZWlnaHQgLSA4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVkgPSAwO1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WSA9IHRoaXMubWF4UG9zWTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cdFx0XHR0aGlzLnNpemVSYXRpb1kgPSB0aGlzLm9wdGlvbnMuc3BlZWRSYXRpb1kgfHwgKHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWSAmJiAodGhpcy5tYXhQb3NZIC8gdGhpcy5zY3JvbGxlci5tYXhTY3JvbGxZKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHR9LFxuXG5cdHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHggPSB0aGlzLm9wdGlvbnMubGlzdGVuWCAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWCAqIHRoaXMuc2Nyb2xsZXIueCkgfHwgMCxcblx0XHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWSAqIHRoaXMuc2Nyb2xsZXIueSkgfHwgMDtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5pZ25vcmVCb3VuZGFyaWVzICkge1xuXHRcdFx0aWYgKCB4IDwgdGhpcy5taW5Cb3VuZGFyeVggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLmluZGljYXRvcldpZHRoICsgeCwgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHggPSB0aGlzLm1pbkJvdW5kYXJ5WDtcblx0XHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heEJvdW5kYXJ5WCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMuaW5kaWNhdG9yV2lkdGggLSAoeCAtIHRoaXMubWF4UG9zWCksIDgpO1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHR4ID0gdGhpcy5tYXhQb3NYICsgdGhpcy5pbmRpY2F0b3JXaWR0aCAtIHRoaXMud2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHRoaXMubWF4Qm91bmRhcnlYO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgJiYgdGhpcy53aWR0aCAhPSB0aGlzLmluZGljYXRvcldpZHRoICkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5pbmRpY2F0b3JXaWR0aDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHkgPCB0aGlzLm1pbkJvdW5kYXJ5WSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmluZGljYXRvckhlaWdodCArIHkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR5ID0gdGhpcy5taW5Cb3VuZGFyeVk7XG5cdFx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhCb3VuZGFyeVkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JIZWlnaHQgLSAoeSAtIHRoaXMubWF4UG9zWSkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhQb3NZICsgdGhpcy5pbmRpY2F0b3JIZWlnaHQgLSB0aGlzLmhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhCb3VuZGFyeVk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyAmJiB0aGlzLmhlaWdodCAhPSB0aGlzLmluZGljYXRvckhlaWdodCApIHtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2Zvcm1dID0gJ3RyYW5zbGF0ZSgnICsgeCArICdweCwnICsgeSArICdweCknICsgdGhpcy5zY3JvbGxlci50cmFuc2xhdGVaO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUudG9wID0geSArICdweCc7XG5cdFx0fVxuXHR9LFxuXG5cdF9wb3M6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0aWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heFBvc1ggKSB7XG5cdFx0XHR4ID0gdGhpcy5tYXhQb3NYO1xuXHRcdH1cblxuXHRcdGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhQb3NZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4UG9zWTtcblx0XHR9XG5cblx0XHR4ID0gdGhpcy5vcHRpb25zLmxpc3RlblggPyBNYXRoLnJvdW5kKHggLyB0aGlzLnNpemVSYXRpb1gpIDogdGhpcy5zY3JvbGxlci54O1xuXHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSA/IE1hdGgucm91bmQoeSAvIHRoaXMuc2l6ZVJhdGlvWSkgOiB0aGlzLnNjcm9sbGVyLnk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHgsIHkpO1xuXHR9LFxuXG5cdGZhZGU6IGZ1bmN0aW9uICh2YWwsIGhvbGQpIHtcblx0XHRpZiAoIGhvbGQgJiYgIXRoaXMudmlzaWJsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5mYWRlVGltZW91dCk7XG5cdFx0dGhpcy5mYWRlVGltZW91dCA9IG51bGw7XG5cblx0XHR2YXIgdGltZSA9IHZhbCA/IDI1MCA6IDUwMCxcblx0XHRcdGRlbGF5ID0gdmFsID8gMCA6IDMwMDtcblxuXHRcdHZhbCA9IHZhbCA/ICcxJyA6ICcwJztcblxuXHRcdHRoaXMud3JhcHBlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSB0aW1lICsgJ21zJztcblxuXHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gdmFsO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gK3ZhbDtcblx0XHR9KS5iaW5kKHRoaXMsIHZhbCksIGRlbGF5KTtcblx0fVxufTtcblxuSVNjcm9sbC51dGlscyA9IHV0aWxzO1xuXG5pZiAoIHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gSVNjcm9sbDtcbn0gZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgICAgICBkZWZpbmUoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElTY3JvbGw7IH0gKTtcbn0gZWxzZSB7XG5cdHdpbmRvdy5JU2Nyb2xsID0gSVNjcm9sbDtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgTWF0aCk7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSYW5nZTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYmFzZVJhbmdlID0gcmVxdWlyZSgnLi9fYmFzZVJhbmdlJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpLFxuICAgIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmFuZ2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iLCJ2YXIgY3JlYXRlUmFuZ2UgPSByZXF1aXJlKCcuL19jcmVhdGVSYW5nZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gKlxuICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yYW5nZSg0KTtcbiAqIC8vID0+IFswLCAxLCAyLCAzXVxuICpcbiAqIF8ucmFuZ2UoLTQpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA1KTtcbiAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICpcbiAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAqXG4gKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAqXG4gKiBfLnJhbmdlKDEsIDQsIDApO1xuICogLy8gPT4gWzEsIDEsIDFdXG4gKlxuICogXy5yYW5nZSgwKTtcbiAqIC8vID0+IFtdXG4gKi9cbnZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZ2U7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi9kZWJvdW5jZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgaHlwZXJzY3JpcHQgPSByZXF1aXJlKFwiLi9yZW5kZXIvaHlwZXJzY3JpcHRcIilcblxuaHlwZXJzY3JpcHQudHJ1c3QgPSByZXF1aXJlKFwiLi9yZW5kZXIvdHJ1c3RcIilcbmh5cGVyc2NyaXB0LmZyYWdtZW50ID0gcmVxdWlyZShcIi4vcmVuZGVyL2ZyYWdtZW50XCIpXG5cbm1vZHVsZS5leHBvcnRzID0gaHlwZXJzY3JpcHRcbiIsIjsoZnVuY3Rpb24oKSB7XG5cInVzZSBzdHJpY3RcIlxuZnVuY3Rpb24gVm5vZGUodGFnLCBrZXksIGF0dHJzMCwgY2hpbGRyZW4sIHRleHQsIGRvbSkge1xuXHRyZXR1cm4ge3RhZzogdGFnLCBrZXk6IGtleSwgYXR0cnM6IGF0dHJzMCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0OiB0ZXh0LCBkb206IGRvbSwgZG9tU2l6ZTogdW5kZWZpbmVkLCBzdGF0ZTogdW5kZWZpbmVkLCBfc3RhdGU6IHVuZGVmaW5lZCwgZXZlbnRzOiB1bmRlZmluZWQsIGluc3RhbmNlOiB1bmRlZmluZWQsIHNraXA6IGZhbHNlfVxufVxuVm5vZGUubm9ybWFsaXplID0gZnVuY3Rpb24obm9kZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShub2RlKSkgcmV0dXJuIFZub2RlKFwiW1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4obm9kZSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRpZiAobm9kZSAhPSBudWxsICYmIHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBub2RlID09PSBmYWxzZSA/IFwiXCIgOiBub2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0cmV0dXJuIG5vZGVcbn1cblZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNoaWxkcmVuW2ldID0gVm5vZGUubm9ybWFsaXplKGNoaWxkcmVuW2ldKVxuXHR9XG5cdHJldHVybiBjaGlsZHJlblxufVxudmFyIHNlbGVjdG9yUGFyc2VyID0gLyg/OihefCN8XFwuKShbXiNcXC5cXFtcXF1dKykpfChcXFsoLis/KSg/Olxccyo9XFxzKihcInwnfCkoKD86XFxcXFtcIidcXF1dfC4pKj8pXFw1KT9cXF0pL2dcbnZhciBzZWxlY3RvckNhY2hlID0ge31cbnZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuZnVuY3Rpb24gaXNFbXB0eShvYmplY3QpIHtcblx0Zm9yICh2YXIga2V5IGluIG9iamVjdCkgaWYgKGhhc093bi5jYWxsKG9iamVjdCwga2V5KSkgcmV0dXJuIGZhbHNlXG5cdHJldHVybiB0cnVlXG59XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGlmICghaXNFbXB0eShzdGF0ZS5hdHRycykgJiYgIWlzRW1wdHkoYXR0cnMpKSB7XG5cdFx0dmFyIG5ld0F0dHJzID0ge31cblx0XHRmb3IodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpKSB7XG5cdFx0XHRcdG5ld0F0dHJzW2tleV0gPSBhdHRyc1trZXldXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGF0dHJzID0gbmV3QXR0cnNcblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gc3RhdGUuYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoc3RhdGUuYXR0cnMsIGtleSkpIHtcblx0XHRcdGF0dHJzW2tleV0gPSBzdGF0ZS5hdHRyc1trZXldXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChhdHRycy5jbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhdHRycy5jbGFzcyA9IHVuZGVmaW5lZFxuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG5cdFx0fVxuXHRcdGlmIChzdGF0ZS5hdHRycy5jbGFzc05hbWUgIT0gbnVsbCkge1xuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gc3RhdGUuYXR0cnMuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWVcblx0XHR9XG5cdH1cblx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpICYmIGtleSAhPT0gXCJrZXlcIikge1xuXHRcdFx0aGFzQXR0cnMgPSB0cnVlXG5cdFx0XHRicmVha1xuXHRcdH1cblx0fVxuXHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdICE9IG51bGwgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIiNcIikge1xuXHRcdHRleHQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkTGlzdCA9IGNoaWxkcmVuXG5cdH1cblx0cmV0dXJuIFZub2RlKHN0YXRlLnRhZywgYXR0cnMua2V5LCBoYXNBdHRycyA/IGF0dHJzIDogdW5kZWZpbmVkLCBjaGlsZExpc3QsIHRleHQpXG59XG5mdW5jdGlvbiBoeXBlcnNjcmlwdChzZWxlY3Rvcikge1xuXHQvLyBCZWNhdXNlIHNsb3BweSBtb2RlIHN1Y2tzXG5cdHZhciBhdHRycyA9IGFyZ3VtZW50c1sxXSwgc3RhcnQgPSAyLCBjaGlsZHJlblxuXHRpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNlbGVjdG9yLnZpZXcgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHRocm93IEVycm9yKFwiVGhlIHNlbGVjdG9yIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgY29tcG9uZW50LlwiKTtcblx0fVxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dmFyIGNhY2hlZCA9IHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdIHx8IGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcilcblx0fVxuXHRpZiAoYXR0cnMgPT0gbnVsbCkge1xuXHRcdGF0dHJzID0ge31cblx0fSBlbHNlIGlmICh0eXBlb2YgYXR0cnMgIT09IFwib2JqZWN0XCIgfHwgYXR0cnMudGFnICE9IG51bGwgfHwgQXJyYXkuaXNBcnJheShhdHRycykpIHtcblx0XHRhdHRycyA9IHt9XG5cdFx0c3RhcnQgPSAxXG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IHN0YXJ0ICsgMSkge1xuXHRcdGNoaWxkcmVuID0gYXJndW1lbnRzW3N0YXJ0XVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIGNoaWxkcmVuID0gW2NoaWxkcmVuXVxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkcmVuID0gW11cblx0XHR3aGlsZSAoc3RhcnQgPCBhcmd1bWVudHMubGVuZ3RoKSBjaGlsZHJlbi5wdXNoKGFyZ3VtZW50c1tzdGFydCsrXSlcblx0fVxuXHR2YXIgbm9ybWFsaXplZCA9IFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKVxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIGV4ZWNTZWxlY3RvcihjYWNoZWQsIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBWbm9kZShzZWxlY3RvciwgYXR0cnMua2V5LCBhdHRycywgbm9ybWFsaXplZClcblx0fVxufVxuaHlwZXJzY3JpcHQudHJ1c3QgPSBmdW5jdGlvbihodG1sKSB7XG5cdGlmIChodG1sID09IG51bGwpIGh0bWwgPSBcIlwiXG5cdHJldHVybiBWbm9kZShcIjxcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGh0bWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxuaHlwZXJzY3JpcHQuZnJhZ21lbnQgPSBmdW5jdGlvbihhdHRyczEsIGNoaWxkcmVuKSB7XG5cdHJldHVybiBWbm9kZShcIltcIiwgYXR0cnMxLmtleSwgYXR0cnMxLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxudmFyIG0gPSBoeXBlcnNjcmlwdFxuLyoqIEBjb25zdHJ1Y3RvciAqL1xudmFyIFByb21pc2VQb2x5ZmlsbCA9IGZ1bmN0aW9uKGV4ZWN1dG9yKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlUG9seWZpbGwpKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIG11c3QgYmUgY2FsbGVkIHdpdGggYG5ld2BcIilcblx0aWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpXG5cdHZhciBzZWxmID0gdGhpcywgcmVzb2x2ZXJzID0gW10sIHJlamVjdG9ycyA9IFtdLCByZXNvbHZlQ3VycmVudCA9IGhhbmRsZXIocmVzb2x2ZXJzLCB0cnVlKSwgcmVqZWN0Q3VycmVudCA9IGhhbmRsZXIocmVqZWN0b3JzLCBmYWxzZSlcblx0dmFyIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2UgPSB7cmVzb2x2ZXJzOiByZXNvbHZlcnMsIHJlamVjdG9yczogcmVqZWN0b3JzfVxuXHR2YXIgY2FsbEFzeW5jID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBoYW5kbGVyKGxpc3QsIHNob3VsZEFic29yYikge1xuXHRcdHJldHVybiBmdW5jdGlvbiBleGVjdXRlKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGhlblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHNob3VsZEFic29yYiAmJiB2YWx1ZSAhPSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiAodGhlbiA9IHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIHcvIGl0c2VsZlwiKVxuXHRcdFx0XHRcdGV4ZWN1dGVPbmNlKHRoZW4uYmluZCh2YWx1ZSkpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2FsbEFzeW5jKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCFzaG91bGRBYnNvcmIgJiYgbGlzdC5sZW5ndGggPT09IDApIGNvbnNvbGUuZXJyb3IoXCJQb3NzaWJsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246XCIsIHZhbHVlKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSBsaXN0W2ldKHZhbHVlKVxuXHRcdFx0XHRcdFx0cmVzb2x2ZXJzLmxlbmd0aCA9IDAsIHJlamVjdG9ycy5sZW5ndGggPSAwXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5zdGF0ZSA9IHNob3VsZEFic29yYlxuXHRcdFx0XHRcdFx0aW5zdGFuY2UucmV0cnkgPSBmdW5jdGlvbigpIHtleGVjdXRlKHZhbHVlKX1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWplY3RDdXJyZW50KGUpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGV4ZWN1dGVPbmNlKHRoZW4pIHtcblx0XHR2YXIgcnVucyA9IDBcblx0XHRmdW5jdGlvbiBydW4oZm4pIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAocnVucysrID4gMCkgcmV0dXJuXG5cdFx0XHRcdGZuKHZhbHVlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgb25lcnJvciA9IHJ1bihyZWplY3RDdXJyZW50KVxuXHRcdHRyeSB7dGhlbihydW4ocmVzb2x2ZUN1cnJlbnQpLCBvbmVycm9yKX0gY2F0Y2ggKGUpIHtvbmVycm9yKGUpfVxuXHR9XG5cdGV4ZWN1dGVPbmNlKGV4ZWN1dG9yKVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0aW9uKSB7XG5cdHZhciBzZWxmID0gdGhpcywgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZVxuXHRmdW5jdGlvbiBoYW5kbGUoY2FsbGJhY2ssIGxpc3QsIG5leHQsIHN0YXRlKSB7XG5cdFx0bGlzdC5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIG5leHQodmFsdWUpXG5cdFx0XHRlbHNlIHRyeSB7cmVzb2x2ZU5leHQoY2FsbGJhY2sodmFsdWUpKX0gY2F0Y2ggKGUpIHtpZiAocmVqZWN0TmV4dCkgcmVqZWN0TmV4dChlKX1cblx0XHR9KVxuXHRcdGlmICh0eXBlb2YgaW5zdGFuY2UucmV0cnkgPT09IFwiZnVuY3Rpb25cIiAmJiBzdGF0ZSA9PT0gaW5zdGFuY2Uuc3RhdGUpIGluc3RhbmNlLnJldHJ5KClcblx0fVxuXHR2YXIgcmVzb2x2ZU5leHQsIHJlamVjdE5leHRcblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge3Jlc29sdmVOZXh0ID0gcmVzb2x2ZSwgcmVqZWN0TmV4dCA9IHJlamVjdH0pXG5cdGhhbmRsZShvbkZ1bGZpbGxlZCwgaW5zdGFuY2UucmVzb2x2ZXJzLCByZXNvbHZlTmV4dCwgdHJ1ZSksIGhhbmRsZShvblJlamVjdGlvbiwgaW5zdGFuY2UucmVqZWN0b3JzLCByZWplY3ROZXh0LCBmYWxzZSlcblx0cmV0dXJuIHByb21pc2Vcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihvblJlamVjdGlvbikge1xuXHRyZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKVxufVxuUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlUG9seWZpbGwpIHJldHVybiB2YWx1ZVxuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlKSB7cmVzb2x2ZSh2YWx1ZSl9KVxufVxuUHJvbWlzZVBvbHlmaWxsLnJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge3JlamVjdCh2YWx1ZSl9KVxufVxuUHJvbWlzZVBvbHlmaWxsLmFsbCA9IGZ1bmN0aW9uKGxpc3QpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0dmFyIHRvdGFsID0gbGlzdC5sZW5ndGgsIGNvdW50ID0gMCwgdmFsdWVzID0gW11cblx0XHRpZiAobGlzdC5sZW5ndGggPT09IDApIHJlc29sdmUoW10pXG5cdFx0ZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGZ1bmN0aW9uIGNvbnN1bWUodmFsdWUpIHtcblx0XHRcdFx0XHRjb3VudCsrXG5cdFx0XHRcdFx0dmFsdWVzW2ldID0gdmFsdWVcblx0XHRcdFx0XHRpZiAoY291bnQgPT09IHRvdGFsKSByZXNvbHZlKHZhbHVlcylcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGlzdFtpXSAhPSBudWxsICYmICh0eXBlb2YgbGlzdFtpXSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbGlzdFtpXSA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgbGlzdFtpXS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRsaXN0W2ldLnRoZW4oY29uc3VtZSwgcmVqZWN0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgY29uc3VtZShsaXN0W2ldKVxuXHRcdFx0fSkoaSlcblx0XHR9XG5cdH0pXG59XG5Qcm9taXNlUG9seWZpbGwucmFjZSA9IGZ1bmN0aW9uKGxpc3QpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsaXN0W2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuXHRcdH1cblx0fSlcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdGlmICh0eXBlb2Ygd2luZG93LlByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHdpbmRvdy5Qcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG5cdHZhciBQcm9taXNlUG9seWZpbGwgPSB3aW5kb3cuUHJvbWlzZVxufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsLlByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIGdsb2JhbC5Qcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG5cdHZhciBQcm9taXNlUG9seWZpbGwgPSBnbG9iYWwuUHJvbWlzZVxufSBlbHNlIHtcbn1cbnZhciBidWlsZFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikgcmV0dXJuIFwiXCJcblx0dmFyIGFyZ3MgPSBbXVxuXHRmb3IgKHZhciBrZXkwIGluIG9iamVjdCkge1xuXHRcdGRlc3RydWN0dXJlKGtleTAsIG9iamVjdFtrZXkwXSlcblx0fVxuXHRyZXR1cm4gYXJncy5qb2luKFwiJlwiKVxuXHRmdW5jdGlvbiBkZXN0cnVjdHVyZShrZXkwLCB2YWx1ZSkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkZXN0cnVjdHVyZShrZXkwICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHZhbHVlKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgYXJncy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkwKSArICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBcIlwiID8gXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpIDogXCJcIikpXG5cdH1cbn1cbnZhciBGSUxFX1BST1RPQ09MX1JFR0VYID0gbmV3IFJlZ0V4cChcIl5maWxlOi8vXCIsIFwiaVwiKVxudmFyIF84ID0gZnVuY3Rpb24oJHdpbmRvdywgUHJvbWlzZSkge1xuXHR2YXIgY2FsbGJhY2tDb3VudCA9IDBcblx0dmFyIG9uY29tcGxldGlvblxuXHRmdW5jdGlvbiBzZXRDb21wbGV0aW9uQ2FsbGJhY2soY2FsbGJhY2spIHtvbmNvbXBsZXRpb24gPSBjYWxsYmFja31cblx0ZnVuY3Rpb24gZmluYWxpemVyKCkge1xuXHRcdHZhciBjb3VudCA9IDBcblx0XHRmdW5jdGlvbiBjb21wbGV0ZSgpIHtpZiAoLS1jb3VudCA9PT0gMCAmJiB0eXBlb2Ygb25jb21wbGV0aW9uID09PSBcImZ1bmN0aW9uXCIpIG9uY29tcGxldGlvbigpfVxuXHRcdHJldHVybiBmdW5jdGlvbiBmaW5hbGl6ZShwcm9taXNlMCkge1xuXHRcdFx0dmFyIHRoZW4wID0gcHJvbWlzZTAudGhlblxuXHRcdFx0cHJvbWlzZTAudGhlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb3VudCsrXG5cdFx0XHRcdHZhciBuZXh0ID0gdGhlbjAuYXBwbHkocHJvbWlzZTAsIGFyZ3VtZW50cylcblx0XHRcdFx0bmV4dC50aGVuKGNvbXBsZXRlLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0Y29tcGxldGUoKVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gMCkgdGhyb3cgZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRyZXR1cm4gZmluYWxpemUobmV4dClcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlMFxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBub3JtYWxpemUoYXJncywgZXh0cmEpIHtcblx0XHRpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciB1cmwgPSBhcmdzXG5cdFx0XHRhcmdzID0gZXh0cmEgfHwge31cblx0XHRcdGlmIChhcmdzLnVybCA9PSBudWxsKSBhcmdzLnVybCA9IHVybFxuXHRcdH1cblx0XHRyZXR1cm4gYXJnc1xuXHR9XG5cdGZ1bmN0aW9uIHJlcXVlc3QoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRpZiAoYXJncy5tZXRob2QgPT0gbnVsbCkgYXJncy5tZXRob2QgPSBcIkdFVFwiXG5cdFx0XHRhcmdzLm1ldGhvZCA9IGFyZ3MubWV0aG9kLnRvVXBwZXJDYXNlKClcblx0XHRcdHZhciB1c2VCb2R5ID0gKGFyZ3MubWV0aG9kID09PSBcIkdFVFwiIHx8IGFyZ3MubWV0aG9kID09PSBcIlRSQUNFXCIpID8gZmFsc2UgOiAodHlwZW9mIGFyZ3MudXNlQm9keSA9PT0gXCJib29sZWFuXCIgPyBhcmdzLnVzZUJvZHkgOiB0cnVlKVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLnNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLnNlcmlhbGl6ZSA9IHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcmdzLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSA/IGZ1bmN0aW9uKHZhbHVlKSB7cmV0dXJuIHZhbHVlfSA6IEpTT04uc3RyaW5naWZ5XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuZGVzZXJpYWxpemUgIT09IFwiZnVuY3Rpb25cIikgYXJncy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuZXh0cmFjdCAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmV4dHJhY3QgPSBleHRyYWN0XG5cdFx0XHRhcmdzLnVybCA9IGludGVycG9sYXRlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHRpZiAodXNlQm9keSkgYXJncy5kYXRhID0gYXJncy5zZXJpYWxpemUoYXJncy5kYXRhKVxuXHRcdFx0ZWxzZSBhcmdzLnVybCA9IGFzc2VtYmxlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHR2YXIgeGhyID0gbmV3ICR3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSxcblx0XHRcdFx0YWJvcnRlZCA9IGZhbHNlLFxuXHRcdFx0XHRfYWJvcnQgPSB4aHIuYWJvcnRcblx0XHRcdHhoci5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuXHRcdFx0XHRhYm9ydGVkID0gdHJ1ZVxuXHRcdFx0XHRfYWJvcnQuY2FsbCh4aHIpXG5cdFx0XHR9XG5cdFx0XHR4aHIub3BlbihhcmdzLm1ldGhvZCwgYXJncy51cmwsIHR5cGVvZiBhcmdzLmFzeW5jID09PSBcImJvb2xlYW5cIiA/IGFyZ3MuYXN5bmMgOiB0cnVlLCB0eXBlb2YgYXJncy51c2VyID09PSBcInN0cmluZ1wiID8gYXJncy51c2VyIDogdW5kZWZpbmVkLCB0eXBlb2YgYXJncy5wYXNzd29yZCA9PT0gXCJzdHJpbmdcIiA/IGFyZ3MucGFzc3dvcmQgOiB1bmRlZmluZWQpXG5cdFx0XHRpZiAoYXJncy5zZXJpYWxpemUgPT09IEpTT04uc3RyaW5naWZ5ICYmIHVzZUJvZHkgJiYgIShhcmdzLmhlYWRlcnMgJiYgYXJncy5oZWFkZXJzLmhhc093blByb3BlcnR5KFwiQ29udGVudC1UeXBlXCIpKSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSAmJiAhKGFyZ3MuaGVhZGVycyAmJiBhcmdzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoXCJBY2NlcHRcIikpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC8qXCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy53aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSBhcmdzLndpdGhDcmVkZW50aWFsc1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZ3MuaGVhZGVycykgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXJncy5oZWFkZXJzLCBrZXkpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgYXJncy5oZWFkZXJzW2tleV0pXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuY29uZmlnID09PSBcImZ1bmN0aW9uXCIpIHhociA9IGFyZ3MuY29uZmlnKHhociwgYXJncykgfHwgeGhyXG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIERvbid0IHRocm93IGVycm9ycyBvbiB4aHIuYWJvcnQoKS5cblx0XHRcdFx0aWYoYWJvcnRlZCkgcmV0dXJuXG5cdFx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzcG9uc2UgPSAoYXJncy5leHRyYWN0ICE9PSBleHRyYWN0KSA/IGFyZ3MuZXh0cmFjdCh4aHIsIGFyZ3MpIDogYXJncy5kZXNlcmlhbGl6ZShhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSlcblx0XHRcdFx0XHRcdGlmICgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0IHx8IEZJTEVfUFJPVE9DT0xfUkVHRVgudGVzdChhcmdzLnVybCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShjYXN0KGFyZ3MudHlwZSwgcmVzcG9uc2UpKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcih4aHIucmVzcG9uc2VUZXh0KVxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UpIGVycm9yW2tleV0gPSByZXNwb25zZVtrZXldXG5cdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUJvZHkgJiYgKGFyZ3MuZGF0YSAhPSBudWxsKSkgeGhyLnNlbmQoYXJncy5kYXRhKVxuXHRcdFx0ZWxzZSB4aHIuc2VuZCgpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlID8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBqc29ucChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHZhciBjYWxsYmFja05hbWUgPSBhcmdzLmNhbGxiYWNrTmFtZSB8fCBcIl9taXRocmlsX1wiICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxNikgKyBcIl9cIiArIGNhbGxiYWNrQ291bnQrK1xuXHRcdFx0dmFyIHNjcmlwdCA9ICR3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKVxuXHRcdFx0JHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIGRhdGEpKVxuXHRcdFx0XHRkZWxldGUgJHdpbmRvd1tjYWxsYmFja05hbWVdXG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJKU09OUCByZXF1ZXN0IGZhaWxlZFwiKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGF0YSA9PSBudWxsKSBhcmdzLmRhdGEgPSB7fVxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0YXJncy5kYXRhW2FyZ3MuY2FsbGJhY2tLZXkgfHwgXCJjYWxsYmFja1wiXSA9IGNhbGxiYWNrTmFtZVxuXHRcdFx0c2NyaXB0LnNyYyA9IGFzc2VtYmxlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHQkd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlPyBwcm9taXNlMCA6IGZpbmFsaXplKHByb21pc2UwKVxuXHR9XG5cdGZ1bmN0aW9uIGludGVycG9sYXRlKHVybCwgZGF0YSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHJldHVybiB1cmxcblx0XHR2YXIgdG9rZW5zID0gdXJsLm1hdGNoKC86W15cXC9dKy9naSkgfHwgW11cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IHRva2Vuc1tpXS5zbGljZSgxKVxuXHRcdFx0aWYgKGRhdGFba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHRva2Vuc1tpXSwgZGF0YVtrZXldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXJsXG5cdH1cblx0ZnVuY3Rpb24gYXNzZW1ibGUodXJsLCBkYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5c3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZyhkYXRhKVxuXHRcdGlmIChxdWVyeXN0cmluZyAhPT0gXCJcIikge1xuXHRcdFx0dmFyIHByZWZpeCA9IHVybC5pbmRleE9mKFwiP1wiKSA8IDAgPyBcIj9cIiA6IFwiJlwiXG5cdFx0XHR1cmwgKz0gcHJlZml4ICsgcXVlcnlzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGRlc2VyaWFsaXplKGRhdGEpIHtcblx0XHR0cnkge3JldHVybiBkYXRhICE9PSBcIlwiID8gSlNPTi5wYXJzZShkYXRhKSA6IG51bGx9XG5cdFx0Y2F0Y2ggKGUpIHt0aHJvdyBuZXcgRXJyb3IoZGF0YSl9XG5cdH1cblx0ZnVuY3Rpb24gZXh0cmFjdCh4aHIpIHtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH1cblx0ZnVuY3Rpb24gY2FzdCh0eXBlMCwgZGF0YSkge1xuXHRcdGlmICh0eXBlb2YgdHlwZTAgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YVtpXSA9IG5ldyB0eXBlMChkYXRhW2ldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHJldHVybiBuZXcgdHlwZTAoZGF0YSlcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHRyZXR1cm4ge3JlcXVlc3Q6IHJlcXVlc3QsIGpzb25wOiBqc29ucCwgc2V0Q29tcGxldGlvbkNhbGxiYWNrOiBzZXRDb21wbGV0aW9uQ2FsbGJhY2t9XG59XG52YXIgcmVxdWVzdFNlcnZpY2UgPSBfOCh3aW5kb3csIFByb21pc2VQb2x5ZmlsbClcbnZhciBjb3JlUmVuZGVyZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciAkZG9jID0gJHdpbmRvdy5kb2N1bWVudFxuXHR2YXIgJGVtcHR5RnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHR2YXIgbmFtZVNwYWNlID0ge1xuXHRcdHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuXHRcdG1hdGg6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiXG5cdH1cblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdGZ1bmN0aW9uIGdldE5hbWVTcGFjZSh2bm9kZSkge1xuXHRcdHJldHVybiB2bm9kZS5hdHRycyAmJiB2bm9kZS5hdHRycy54bWxucyB8fCBuYW1lU3BhY2Vbdm5vZGUudGFnXVxuXHR9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHR2YXIgYXR0cnMyID0gdm5vZGUuYXR0cnNcblx0XHR2YXIgaXMgPSBhdHRyczIgJiYgYXR0cnMyLmlzXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cdFx0dmFyIGVsZW1lbnQgPSBucyA/XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpIDpcblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50KHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50KHRhZylcblx0XHR2bm9kZS5kb20gPSBlbGVtZW50XG5cdFx0aWYgKGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucylcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUudGV4dCAhPT0gXCJcIikgZWxlbWVudC50ZXh0Q29udGVudCA9IHZub2RlLnRleHRcblx0XHRcdFx0ZWxzZSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdH1cblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRcdGNyZWF0ZU5vZGVzKGVsZW1lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHRcdFx0c2V0TGF0ZUF0dHJzKHZub2RlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKSB7XG5cdFx0dmFyIHNlbnRpbmVsXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcudmlldyA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IE9iamVjdC5jcmVhdGUodm5vZGUudGFnKVxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS5zdGF0ZS52aWV3XG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB2b2lkIDBcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUudGFnXG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHRcdHZub2RlLnN0YXRlID0gKHZub2RlLnRhZy5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUudGFnLnByb3RvdHlwZS52aWV3ID09PSBcImZ1bmN0aW9uXCIpID8gbmV3IHZub2RlLnRhZyh2bm9kZSkgOiB2bm9kZS50YWcodm5vZGUpXG5cdFx0fVxuXHRcdHZub2RlLl9zdGF0ZSA9IHZub2RlLnN0YXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuZG9tICE9IG51bGwgPyB2bm9kZS5pbnN0YW5jZS5kb21TaXplIDogMFxuXHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXHRcdFx0cmV0dXJuIGVsZW1lbnRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdFx0cmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0fVxuXHR9XG5cdC8vdXBkYXRlXG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLCB2bm9kZXMsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGlmIChvbGQgPT09IHZub2RlcyB8fCBvbGQgPT0gbnVsbCAmJiB2bm9kZXMgPT0gbnVsbCkgcmV0dXJuXG5cdFx0ZWxzZSBpZiAob2xkID09IG51bGwpIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCAwLCB2bm9kZXMubGVuZ3RoLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0bmV4dFNpYmxpbmcgPSBkb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZW5kIDwgc3RhcnQpIGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCArIDEsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRyZW1vdmVOb2RlcyhvbGQsIG9sZFN0YXJ0LCBvbGRFbmQgKyAxLCB2bm9kZXMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHR2YXIgb2xkVGFnID0gb2xkLnRhZywgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKG9sZFRhZyA9PT0gdGFnKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IG9sZC5zdGF0ZVxuXHRcdFx0dm5vZGUuX3N0YXRlID0gb2xkLl9zdGF0ZVxuXHRcdFx0dm5vZGUuZXZlbnRzID0gb2xkLmV2ZW50c1xuXHRcdFx0aWYgKCFyZWN5Y2xpbmcgJiYgc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpKSByZXR1cm5cblx0XHRcdGlmICh0eXBlb2Ygb2xkVGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0XHRcdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAob2xkVGFnKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIiNcIjogdXBkYXRlVGV4dChvbGQsIHZub2RlKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiPFwiOiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCJbXCI6IHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKTsgYnJlYWtcblx0XHRcdFx0XHRkZWZhdWx0OiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZCwgbnVsbClcblx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlVGV4dChvbGQsIHZub2RlKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbi50b1N0cmluZygpICE9PSB2bm9kZS5jaGlsZHJlbi50b1N0cmluZygpKSB7XG5cdFx0XHRvbGQuZG9tLm5vZGVWYWx1ZSA9IHZub2RlLmNoaWxkcmVuXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuICE9PSB2bm9kZS5jaGlsZHJlbikge1xuXHRcdFx0dG9GcmFnbWVudChvbGQpXG5cdFx0XHRjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0XHRlbHNlIHZub2RlLmRvbSA9IG9sZC5kb20sIHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0dXBkYXRlTm9kZXMocGFyZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0dmFyIGRvbVNpemUgPSAwLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gbnVsbFxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLmRvbSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHZub2RlLmRvbSA9PSBudWxsKSB2bm9kZS5kb20gPSBjaGlsZC5kb21cblx0XHRcdFx0XHRkb21TaXplICs9IGNoaWxkLmRvbVNpemUgfHwgMVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9tU2l6ZSAhPT0gMSkgdm5vZGUuZG9tU2l6ZSA9IGRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS5fc3RhdGUub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuX3N0YXRlLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0aWYgKGtleTIgPT09IFwidmFsdWVcIikge1xuXHRcdFx0XHR2YXIgbm9ybWFsaXplZDAgPSBcIlwiICsgdmFsdWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvblxuXHRcdFx0XHQvL3NldHRpbmcgaW5wdXRbdmFsdWVdIHRvIHNhbWUgdmFsdWUgYnkgdHlwaW5nIG9uIGZvY3VzZWQgZWxlbWVudCBtb3ZlcyBjdXJzb3IgdG8gZW5kIGluIENocm9tZVxuXHRcdFx0XHRpZiAoKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiIHx8IHZub2RlLnRhZyA9PT0gXCJ0ZXh0YXJlYVwiKSAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQwICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0Ly9zZXR0aW5nIHNlbGVjdFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlLmRvbS5zZWxlY3RlZEluZGV4ID09PSAtMSAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvbGQgIT09IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vc2V0dGluZyBvcHRpb25bdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYgb2xkICE9IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCkgcmV0dXJuXG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCBcIlwiKVxuXHRcdFx0XHRlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkyLCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0TGF0ZUF0dHJzKHZub2RlKSB7XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwidmFsdWVcIiwgbnVsbCwgYXR0cnMyLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMyLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMyLCBucykge1xuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5Miwgb2xkICYmIG9sZFtrZXkyXSwgYXR0cnMyW2tleTJdLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRpZiAoYXR0cnMyID09IG51bGwgfHwgIShrZXkyIGluIGF0dHJzMikpIHtcblx0XHRcdFx0XHRpZiAoa2V5MiA9PT0gXCJjbGFzc05hbWVcIikga2V5MiA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5MiAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXHQvL3N0eWxlXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgc3R5bGUpIHtcblx0XHRpZiAob2xkID09PSBzdHlsZSkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIiwgb2xkID0gbnVsbFxuXHRcdGlmIChzdHlsZSA9PSBudWxsKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdGZvciAodmFyIGtleTIgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXkyXSA9IHN0eWxlW2tleTJdXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkICE9IG51bGwgJiYgdHlwZW9mIG9sZCAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleTIgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleTJdID0gXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkyIGluIGVsZW1lbnQpIGVsZW1lbnRba2V5Ml0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleTIuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gPT09IGNhbGxiYWNrKSByZXR1cm5cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5Ml0gPSBjYWxsYmFja1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKGRvbSwgdm5vZGVzKSB7XG5cdFx0aWYgKCFkb20pIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKVxuXHRcdHZhciBob29rcyA9IFtdXG5cdFx0dmFyIGFjdGl2ZSA9ICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdHZhciBuYW1lc3BhY2UgPSBkb20ubmFtZXNwYWNlVVJJXG5cdFx0Ly8gRmlyc3QgdGltZTAgcmVuZGVyaW5nIGludG8gYSBub2RlIGNsZWFycyBpdCBvdXRcblx0XHRpZiAoZG9tLnZub2RlcyA9PSBudWxsKSBkb20udGV4dENvbnRlbnQgPSBcIlwiXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHZub2RlcykpIHZub2RlcyA9IFt2bm9kZXNdXG5cdFx0dXBkYXRlTm9kZXMoZG9tLCBkb20udm5vZGVzLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbih2bm9kZXMpLCBmYWxzZSwgaG9va3MsIG51bGwsIG5hbWVzcGFjZSA9PT0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIgPyB1bmRlZmluZWQgOiBuYW1lc3BhY2UpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHJldHVybiBudWxsIGluIElFIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9hY3RpdmVFbGVtZW50XG5cdFx0aWYgKGFjdGl2ZSAhPSBudWxsICYmICRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0fVxuXHRyZXR1cm4ge3JlbmRlcjogcmVuZGVyLCBzZXRFdmVudENhbGxiYWNrOiBzZXRFdmVudENhbGxiYWNrfVxufVxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2spIHtcblx0Ly82MGZwcyB0cmFuc2xhdGVzIHRvIDE2LjZtcywgcm91bmQgaXQgZG93biBzaW5jZSBzZXRUaW1lb3V0IHJlcXVpcmVzIGludFxuXHR2YXIgdGltZSA9IDE2XG5cdHZhciBsYXN0ID0gMCwgcGVuZGluZyA9IG51bGxcblx0dmFyIHRpbWVvdXQgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKVxuXHRcdGlmIChsYXN0ID09PSAwIHx8IG5vdyAtIGxhc3QgPj0gdGltZSkge1xuXHRcdFx0bGFzdCA9IG5vd1xuXHRcdFx0Y2FsbGJhY2soKVxuXHRcdH1cblx0XHRlbHNlIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG5cdFx0XHRwZW5kaW5nID0gdGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0cGVuZGluZyA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2soKVxuXHRcdFx0XHRsYXN0ID0gRGF0ZS5ub3coKVxuXHRcdFx0fSwgdGltZSAtIChub3cgLSBsYXN0KSlcblx0XHR9XG5cdH1cbn1cbnZhciBfMTEgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciByZW5kZXJTZXJ2aWNlID0gY29yZVJlbmRlcmVyKCR3aW5kb3cpXG5cdHJlbmRlclNlcnZpY2Uuc2V0RXZlbnRDYWxsYmFjayhmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUucmVkcmF3ID09PSBmYWxzZSkgZS5yZWRyYXcgPSB1bmRlZmluZWRcblx0XHRlbHNlIHJlZHJhdygpXG5cdH0pXG5cdHZhciBjYWxsYmFja3MgPSBbXVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5MSwgY2FsbGJhY2spIHtcblx0XHR1bnN1YnNjcmliZShrZXkxKVxuXHRcdGNhbGxiYWNrcy5wdXNoKGtleTEsIHRocm90dGxlKGNhbGxiYWNrKSlcblx0fVxuXHRmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkxKSB7XG5cdFx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2Yoa2V5MSlcblx0XHRpZiAoaW5kZXggPiAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMilcblx0fVxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdGNhbGxiYWNrc1tpXSgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiB7c3Vic2NyaWJlOiBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSwgcmVkcmF3OiByZWRyYXcsIHJlbmRlcjogcmVuZGVyU2VydmljZS5yZW5kZXJ9XG59XG52YXIgcmVkcmF3U2VydmljZSA9IF8xMSh3aW5kb3cpXG5yZXF1ZXN0U2VydmljZS5zZXRDb21wbGV0aW9uQ2FsbGJhY2socmVkcmF3U2VydmljZS5yZWRyYXcpXG52YXIgXzE2ID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZTApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBbXSlcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvbXBvbmVudC52aWV3ID09IG51bGwgJiYgdHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJtLm1vdW50KGVsZW1lbnQsIGNvbXBvbmVudCkgZXhwZWN0cyBhIGNvbXBvbmVudCwgbm90IGEgdm5vZGVcIilcblx0XHRcblx0XHR2YXIgcnVuMCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFZub2RlKGNvbXBvbmVudCkpXG5cdFx0fVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4wKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnJlZHJhdygpXG5cdH1cbn1cbm0ubW91bnQgPSBfMTYocmVkcmF3U2VydmljZSlcbnZhciBQcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblx0dmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCImXCIpLCBkYXRhMCA9IHt9LCBjb3VudGVycyA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleTUgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblx0XHRpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWVcblx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlXG5cdFx0dmFyIGxldmVscyA9IGtleTUuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YTBcblx0XHRpZiAoa2V5NS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleTUgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXk1XSA9PSBudWxsKSBjb3VudGVyc1trZXk1XSA9IDBcblx0XHRcdFx0bGV2ZWwgPSBjb3VudGVyc1trZXk1XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnNvcltsZXZlbF0gPSBpc1ZhbHVlID8gdmFsdWUgOiBpc051bWJlciA/IFtdIDoge31cblx0XHRcdH1cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGEwXG59XG52YXIgY29yZVJvdXRlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgY2FsbEFzeW5jMCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gbm9ybWFsaXplMShmcmFnbWVudDApIHtcblx0XHR2YXIgZGF0YSA9ICR3aW5kb3cubG9jYXRpb25bZnJhZ21lbnQwXS5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0aWYgKGZyYWdtZW50MCA9PT0gXCJwYXRobmFtZVwiICYmIGRhdGFbMF0gIT09IFwiL1wiKSBkYXRhID0gXCIvXCIgKyBkYXRhXG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHR2YXIgYXN5bmNJZFxuXHRmdW5jdGlvbiBkZWJvdW5jZUFzeW5jKGNhbGxiYWNrMCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhc3luY0lkICE9IG51bGwpIHJldHVyblxuXHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYzAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrMCgpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSkge1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKVxuXHRcdHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpXG5cdFx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRcdHZhciBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBxdWVyeVBhcmFtcykgcXVlcnlEYXRhW2tleTRdID0gcXVlcnlQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0aWYgKGhhc2hJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgaGFzaFBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShoYXNoSW5kZXggKyAxKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gaGFzaFBhcmFtcykgaGFzaERhdGFba2V5NF0gPSBoYXNoUGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhFbmQpXG5cdH1cblx0dmFyIHJvdXRlciA9IHtwcmVmaXg6IFwiIyFcIn1cblx0cm91dGVyLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZTIgPSByb3V0ZXIucHJlZml4LmNoYXJBdCgwKVxuXHRcdHN3aXRjaCAodHlwZTIpIHtcblx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBub3JtYWxpemUxKFwiaGFzaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aClcblx0XHRcdGNhc2UgXCI/XCI6IHJldHVybiBub3JtYWxpemUxKFwic2VhcmNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gbm9ybWFsaXplMShcInBhdGhuYW1lXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdH1cblx0fVxuXHRyb3V0ZXIuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHR2YXIgcXVlcnlEYXRhID0ge30sIGhhc2hEYXRhID0ge31cblx0XHRwYXRoID0gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpXG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBkYXRhKSBxdWVyeURhdGFba2V5NF0gPSBkYXRhW2tleTRdXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uKG1hdGNoMiwgdG9rZW4pIHtcblx0XHRcdFx0ZGVsZXRlIHF1ZXJ5RGF0YVt0b2tlbl1cblx0XHRcdFx0cmV0dXJuIGRhdGFbdG9rZW5dXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHF1ZXJ5RGF0YSlcblx0XHRpZiAocXVlcnkpIHBhdGggKz0gXCI/XCIgKyBxdWVyeVxuXHRcdHZhciBoYXNoID0gYnVpbGRRdWVyeVN0cmluZyhoYXNoRGF0YSlcblx0XHRpZiAoaGFzaCkgcGF0aCArPSBcIiNcIiArIGhhc2hcblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0dmFyIHRpdGxlID0gb3B0aW9ucyA/IG9wdGlvbnMudGl0bGUgOiBudWxsXG5cdFx0XHQkd2luZG93Lm9ucG9wc3RhdGUoKVxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHR9XG5cdFx0ZWxzZSAkd2luZG93LmxvY2F0aW9uLmhyZWYgPSByb3V0ZXIucHJlZml4ICsgcGF0aFxuXHR9XG5cdHJvdXRlci5kZWZpbmVSb3V0ZXMgPSBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdHZhciBwYXRoID0gcm91dGVyLmdldFBhdGgoKVxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9XG5cdFx0XHR2YXIgcGF0aG5hbWUgPSBwYXJzZVBhdGgocGF0aCwgcGFyYW1zLCBwYXJhbXMpXG5cdFx0XHR2YXIgc3RhdGUgPSAkd2luZG93Lmhpc3Rvcnkuc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGsgaW4gc3RhdGUpIHBhcmFtc1trXSA9IHN0YXRlW2tdXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciByb3V0ZTAgaW4gcm91dGVzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIl5cIiArIHJvdXRlMC5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZywgXCIoLio/KVwiKS5yZXBsYWNlKC86W15cXC9dKy9nLCBcIihbXlxcXFwvXSspXCIpICsgXCJcXC8/JFwiKVxuXHRcdFx0XHRpZiAobWF0Y2hlci50ZXN0KHBhdGhuYW1lKSkge1xuXHRcdFx0XHRcdHBhdGhuYW1lLnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IHJvdXRlMC5tYXRjaCgvOlteXFwvXSsvZykgfHwgW11cblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTIpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW2tleXNbaV0ucmVwbGFjZSgvOnxcXC4vZywgXCJcIildID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUocm91dGVzW3JvdXRlMF0sIHBhcmFtcywgcGF0aCwgcm91dGUwKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChwYXRoLCBwYXJhbXMpXG5cdFx0fVxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkgJHdpbmRvdy5vbnBvcHN0YXRlID0gZGVib3VuY2VBc3luYyhyZXNvbHZlUm91dGUpXG5cdFx0ZWxzZSBpZiAocm91dGVyLnByZWZpeC5jaGFyQXQoMCkgPT09IFwiI1wiKSAkd2luZG93Lm9uaGFzaGNoYW5nZSA9IHJlc29sdmVSb3V0ZVxuXHRcdHJlc29sdmVSb3V0ZSgpXG5cdH1cblx0cmV0dXJuIHJvdXRlclxufVxudmFyIF8yMCA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UwKSB7XG5cdHZhciByb3V0ZVNlcnZpY2UgPSBjb3JlUm91dGVyKCR3aW5kb3cpXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHYpIHtyZXR1cm4gdn1cblx0dmFyIHJlbmRlcjEsIGNvbXBvbmVudCwgYXR0cnMzLCBjdXJyZW50UGF0aCwgbGFzdFVwZGF0ZVxuXHR2YXIgcm91dGUgPSBmdW5jdGlvbihyb290LCBkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuXHRcdGlmIChyb290ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIGBtLnJvdXRlYCBpcyBub3QgdW5kZWZpbmVkXCIpXG5cdFx0dmFyIHJ1bjEgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZW5kZXIxICE9IG51bGwpIHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCByZW5kZXIxKFZub2RlKGNvbXBvbmVudCwgYXR0cnMzLmtleSwgYXR0cnMzKSkpXG5cdFx0fVxuXHRcdHZhciBiYWlsID0gZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0aWYgKHBhdGggIT09IGRlZmF1bHRSb3V0ZSkgcm91dGVTZXJ2aWNlLnNldFBhdGgoZGVmYXVsdFJvdXRlLCBudWxsLCB7cmVwbGFjZTogdHJ1ZX0pXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGRlZmF1bHQgcm91dGUgXCIgKyBkZWZhdWx0Um91dGUpXG5cdFx0fVxuXHRcdHJvdXRlU2VydmljZS5kZWZpbmVSb3V0ZXMocm91dGVzLCBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIHBhdGgpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzMyA9IHBhcmFtcywgY3VycmVudFBhdGggPSBwYXRoLCBsYXN0VXBkYXRlID0gbnVsbFxuXHRcdFx0XHRyZW5kZXIxID0gKHJvdXRlUmVzb2x2ZXIucmVuZGVyIHx8IGlkZW50aXR5KS5iaW5kKHJvdXRlUmVzb2x2ZXIpXG5cdFx0XHRcdHJ1bjEoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGJhaWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB1cGRhdGUocGF5bG9hZCwgXCJkaXZcIilcblx0XHRcdH1cblx0XHR9LCBiYWlsKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4xKVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXHRcdFx0b3B0aW9ucy5yZXBsYWNlID0gdHJ1ZVxuXHRcdH1cblx0XHRsYXN0VXBkYXRlID0gbnVsbFxuXHRcdHJvdXRlU2VydmljZS5zZXRQYXRoKHBhdGgsIGRhdGEsIG9wdGlvbnMpXG5cdH1cblx0cm91dGUuZ2V0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIGN1cnJlbnRQYXRofVxuXHRyb3V0ZS5wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgwKSB7cm91dGVTZXJ2aWNlLnByZWZpeCA9IHByZWZpeDB9XG5cdHJvdXRlLmxpbmsgPSBmdW5jdGlvbih2bm9kZTEpIHtcblx0XHR2bm9kZTEuZG9tLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgcm91dGVTZXJ2aWNlLnByZWZpeCArIHZub2RlMS5hdHRycy5ocmVmKVxuXHRcdHZub2RlMS5kb20ub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS53aGljaCA9PT0gMikgcmV0dXJuXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KClcblx0XHRcdGUucmVkcmF3ID0gZmFsc2Vcblx0XHRcdHZhciBocmVmID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpXG5cdFx0XHRpZiAoaHJlZi5pbmRleE9mKHJvdXRlU2VydmljZS5wcmVmaXgpID09PSAwKSBocmVmID0gaHJlZi5zbGljZShyb3V0ZVNlcnZpY2UucHJlZml4Lmxlbmd0aClcblx0XHRcdHJvdXRlLnNldChocmVmLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0cm91dGUucGFyYW0gPSBmdW5jdGlvbihrZXkzKSB7XG5cdFx0aWYodHlwZW9mIGF0dHJzMyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Yga2V5MyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGF0dHJzM1trZXkzXVxuXHRcdHJldHVybiBhdHRyczNcblx0fVxuXHRyZXR1cm4gcm91dGVcbn1cbm0ucm91dGUgPSBfMjAod2luZG93LCByZWRyYXdTZXJ2aWNlKVxubS53aXRoQXR0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lLCBjYWxsYmFjazEsIGNvbnRleHQpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRjYWxsYmFjazEuY2FsbChjb250ZXh0IHx8IHRoaXMsIGF0dHJOYW1lIGluIGUuY3VycmVudFRhcmdldCA/IGUuY3VycmVudFRhcmdldFthdHRyTmFtZV0gOiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSlcblx0fVxufVxudmFyIF8yOCA9IGNvcmVSZW5kZXJlcih3aW5kb3cpXG5tLnJlbmRlciA9IF8yOC5yZW5kZXJcbm0ucmVkcmF3ID0gcmVkcmF3U2VydmljZS5yZWRyYXdcbm0ucmVxdWVzdCA9IHJlcXVlc3RTZXJ2aWNlLnJlcXVlc3Rcbm0uanNvbnAgPSByZXF1ZXN0U2VydmljZS5qc29ucFxubS5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZ1xubS5idWlsZFF1ZXJ5U3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZ1xubS52ZXJzaW9uID0gXCIxLjEuNlwiXG5tLnZub2RlID0gVm5vZGVcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGVbXCJleHBvcnRzXCJdID0gbVxuZWxzZSB3aW5kb3cubSA9IG1cbn0oKSk7IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZW5kZXIvcmVuZGVyXCIpKHdpbmRvdylcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdHRycywgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRycy5rZXksIGF0dHJzLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxuXG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqZWN0KSB7XG5cdGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChoYXNPd24uY2FsbChvYmplY3QsIGtleSkpIHJldHVybiBmYWxzZVxuXHRyZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuXG5mdW5jdGlvbiBleGVjU2VsZWN0b3Ioc3RhdGUsIGF0dHJzLCBjaGlsZHJlbikge1xuXHR2YXIgaGFzQXR0cnMgPSBmYWxzZSwgY2hpbGRMaXN0LCB0ZXh0XG5cdHZhciBjbGFzc05hbWUgPSBhdHRycy5jbGFzc05hbWUgfHwgYXR0cnMuY2xhc3NcblxuXHRpZiAoIWlzRW1wdHkoc3RhdGUuYXR0cnMpICYmICFpc0VtcHR5KGF0dHJzKSkge1xuXHRcdHZhciBuZXdBdHRycyA9IHt9XG5cblx0XHRmb3IodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpKSB7XG5cdFx0XHRcdG5ld0F0dHJzW2tleV0gPSBhdHRyc1trZXldXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXR0cnMgPSBuZXdBdHRyc1xuXHR9XG5cblx0Zm9yICh2YXIga2V5IGluIHN0YXRlLmF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKHN0YXRlLmF0dHJzLCBrZXkpKSB7XG5cdFx0XHRhdHRyc1trZXldID0gc3RhdGUuYXR0cnNba2V5XVxuXHRcdH1cblx0fVxuXG5cdGlmIChjbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChhdHRycy5jbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhdHRycy5jbGFzcyA9IHVuZGVmaW5lZFxuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG5cdFx0fVxuXG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXG5cdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSAmJiBrZXkgIT09IFwia2V5XCIpIHtcblx0XHRcdGhhc0F0dHJzID0gdHJ1ZVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblxuXHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdICE9IG51bGwgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIiNcIikge1xuXHRcdHRleHQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkTGlzdCA9IGNoaWxkcmVuXG5cdH1cblxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cblxuZnVuY3Rpb24gaHlwZXJzY3JpcHQoc2VsZWN0b3IpIHtcblx0Ly8gQmVjYXVzZSBzbG9wcHkgbW9kZSBzdWNrc1xuXHR2YXIgYXR0cnMgPSBhcmd1bWVudHNbMV0sIHN0YXJ0ID0gMiwgY2hpbGRyZW5cblxuXHRpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNlbGVjdG9yLnZpZXcgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHRocm93IEVycm9yKFwiVGhlIHNlbGVjdG9yIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgY29tcG9uZW50LlwiKTtcblx0fVxuXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cblx0aWYgKGF0dHJzID09IG51bGwpIHtcblx0XHRhdHRycyA9IHt9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJzLnRhZyAhPSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHRcdHN0YXJ0ID0gMVxuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IHN0YXJ0ICsgMSkge1xuXHRcdGNoaWxkcmVuID0gYXJndW1lbnRzW3N0YXJ0XVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIGNoaWxkcmVuID0gW2NoaWxkcmVuXVxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkcmVuID0gW11cblx0XHR3aGlsZSAoc3RhcnQgPCBhcmd1bWVudHMubGVuZ3RoKSBjaGlsZHJlbi5wdXNoKGFyZ3VtZW50c1tzdGFydCsrXSlcblx0fVxuXG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBleGVjU2VsZWN0b3IoY2FjaGVkLCBhdHRycywgbm9ybWFsaXplZClcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gVm5vZGUoc2VsZWN0b3IsIGF0dHJzLmtleSwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBlcnNjcmlwdFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyICRkb2MgPSAkd2luZG93LmRvY3VtZW50XG5cdHZhciAkZW1wdHlGcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cblx0ZnVuY3Rpb24gZ2V0TmFtZVNwYWNlKHZub2RlKSB7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzICYmIHZub2RlLmF0dHJzLnhtbG5zIHx8IG5hbWVTcGFjZVt2bm9kZS50YWddXG5cdH1cblxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2ggPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaFsxXV0gfHwgXCJkaXZcIlxuXHRcdHZhciB0ZW1wID0gJGRvYy5jcmVhdGVFbGVtZW50KHBhcmVudDEpXG5cblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzID0gdm5vZGUuYXR0cnNcblx0XHR2YXIgaXMgPSBhdHRycyAmJiBhdHRycy5pc1xuXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblxuXHRcdGlmIChhdHRycyAhPSBudWxsKSB7XG5cdFx0XHRzZXRBdHRycyh2bm9kZSwgYXR0cnMsIG5zKVxuXHRcdH1cblxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUudGV4dCAhPT0gXCJcIikgZWxlbWVudC50ZXh0Q29udGVudCA9IHZub2RlLnRleHRcblx0XHRcdFx0ZWxzZSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdH1cblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRcdGNyZWF0ZU5vZGVzKGVsZW1lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHRcdFx0c2V0TGF0ZUF0dHJzKHZub2RlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKSB7XG5cdFx0dmFyIHNlbnRpbmVsXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcudmlldyA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IE9iamVjdC5jcmVhdGUodm5vZGUudGFnKVxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS5zdGF0ZS52aWV3XG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB2b2lkIDBcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUudGFnXG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHRcdHZub2RlLnN0YXRlID0gKHZub2RlLnRhZy5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUudGFnLnByb3RvdHlwZS52aWV3ID09PSBcImZ1bmN0aW9uXCIpID8gbmV3IHZub2RlLnRhZyh2bm9kZSkgOiB2bm9kZS50YWcodm5vZGUpXG5cdFx0fVxuXHRcdHZub2RlLl9zdGF0ZSA9IHZub2RlLnN0YXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuZG9tICE9IG51bGwgPyB2bm9kZS5pbnN0YW5jZS5kb21TaXplIDogMFxuXHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXHRcdFx0cmV0dXJuIGVsZW1lbnRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdFx0cmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0fVxuXHR9XG5cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0ZWxzZSBpZiAodm5vZGVzID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgMCwgb2xkLmxlbmd0aCwgdm5vZGVzKVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC5sZW5ndGggPT09IHZub2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlzVW5rZXllZCA9IGZhbHNlXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIG9sZFtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpc1Vua2V5ZWQgPSB2bm9kZXNbaV0ua2V5ID09IG51bGwgJiYgb2xkW2ldLmtleSA9PSBudWxsXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNVbmtleWVkKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChvbGRbaV0gPT09IHZub2Rlc1tpXSkgY29udGludWVcblx0XHRcdFx0XHRcdGVsc2UgaWYgKG9sZFtpXSA9PSBudWxsICYmIHZub2Rlc1tpXSAhPSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGVzW2ldLCBob29rcywgbnMsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHZub2Rlc1tpXSA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIGksIGkgKyAxLCB2bm9kZXMpXG5cdFx0XHRcdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGRbaV0sIHZub2Rlc1tpXSwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlY3ljbGluZyA9IHJlY3ljbGluZyB8fCBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpXG5cdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdHZhciBwb29sID0gb2xkLnBvb2xcblx0XHRcdFx0b2xkID0gb2xkLmNvbmNhdChvbGQucG9vbClcblx0XHRcdH1cblxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlIG11bHRpcGxlIGNoaWxkcmVuXG5cdFx0XHRcdHZub2RlLnRleHQgPSB1bmRlZmluZWRcblx0XHRcdH1cblx0XHR9XG5cdFx0dXBkYXRlQXR0cnModm5vZGUsIG9sZC5hdHRycywgdm5vZGUuYXR0cnMsIG5zKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT09IFwiXCIpIHtcblx0XHRcdGlmIChvbGQudGV4dC50b1N0cmluZygpICE9PSB2bm9kZS50ZXh0LnRvU3RyaW5nKCkpIG9sZC5kb20uZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2bm9kZS50ZXh0XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC50ZXh0ICE9IG51bGwpIG9sZC5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZC50ZXh0LCB1bmRlZmluZWQsIG9sZC5kb20uZmlyc3RDaGlsZCldXG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdHVwZGF0ZU5vZGVzKGVsZW1lbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR9XG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdGlmIChvbGQuaW5zdGFuY2UgPT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLmluc3RhbmNlLCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQuaW5zdGFuY2UsIG51bGwpXG5cdFx0XHR2bm9kZS5kb20gPSB1bmRlZmluZWRcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcykge1xuXHRcdGlmIChvbGQucG9vbCAhPSBudWxsICYmIE1hdGguYWJzKG9sZC5wb29sLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpIDw9IE1hdGguYWJzKG9sZC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSkge1xuXHRcdFx0dmFyIG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkWzBdICYmIG9sZFswXS5jaGlsZHJlbiAmJiBvbGRbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciBwb29sQ2hpbGRyZW5MZW5ndGggPSBvbGQucG9vbFswXSAmJiBvbGQucG9vbFswXS5jaGlsZHJlbiAmJiBvbGQucG9vbFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHZub2Rlc0NoaWxkcmVuTGVuZ3RoID0gdm5vZGVzWzBdICYmIHZub2Rlc1swXS5jaGlsZHJlbiAmJiB2bm9kZXNbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdGlmIChNYXRoLmFicyhwb29sQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkgPD0gTWF0aC5hYnMob2xkQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gZ2V0S2V5TWFwKHZub2RlcywgZW5kKSB7XG5cdFx0dmFyIG1hcCA9IHt9LCBpID0gMFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGtleSA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5ICE9IG51bGwpIG1hcFtrZXldID0gaVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cblx0ZnVuY3Rpb24gdG9GcmFnbWVudCh2bm9kZSkge1xuXHRcdHZhciBjb3VudCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudCA+IDApIHtcblx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHR3aGlsZSAoLS1jb3VudCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0Q29udGVudEVkaXRhYmxlKHZub2RlKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIjxcIikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHRcdFx0aWYgKHZub2RlLmRvbS5pbm5lckhUTUwgIT09IGNvbnRlbnQpIHZub2RlLmRvbS5pbm5lckhUTUwgPSBjb250ZW50XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZub2RlLnRleHQgIT0gbnVsbCB8fCBjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgbm9kZSBvZiBhIGNvbnRlbnRlZGl0YWJsZSBtdXN0IGJlIHRydXN0ZWRcIilcblx0fVxuXG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1jb3VudCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSBvbnJlbW92ZSh2bm9kZS5pbnN0YW5jZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL2F0dHJzXG5cdGZ1bmN0aW9uIHNldEF0dHJzKHZub2RlLCBhdHRycywgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdHNldEF0dHIodm5vZGUsIGtleSwgbnVsbCwgYXR0cnNba2V5XSwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldEF0dHIodm5vZGUsIGtleSwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkgPT09IFwia2V5XCIgfHwga2V5ID09PSBcImlzXCIgfHwgKG9sZCA9PT0gdmFsdWUgJiYgIWlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwga2V5KSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkuaW5kZXhPZihcIjpcIilcblx0XHRpZiAobnNMYXN0SW5kZXggPiAtMSAmJiBrZXkuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleVswXSA9PT0gXCJvXCIgJiYga2V5WzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5IGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleSkgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0aWYgKGtleSA9PT0gXCJ2YWx1ZVwiKSB7XG5cdFx0XHRcdHZhciBub3JtYWxpemVkID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0Ly9zZXR0aW5nIHNlbGVjdFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlLmRvbS5zZWxlY3RlZEluZGV4ID09PSAtMSAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvbGQgIT09IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJvcHRpb25cIiAmJiBvbGQgIT0gbnVsbCAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQpIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3Igd2lsbCBvY2N1ci5cblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXldID0gdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRpZiAodmFsdWUpIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSA9PT0gXCJjbGFzc05hbWVcIiA/IFwiY2xhc3NcIiA6IGtleSwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRycyA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRycyAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJ2YWx1ZVwiIGluIGF0dHJzKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMpIHNldEF0dHIodm5vZGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsLCBhdHRycy5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzLCBucykge1xuXHRcdGlmIChhdHRycyAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5LCBvbGQgJiYgb2xkW2tleV0sIGF0dHJzW2tleV0sIG5zKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2xkICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzID09IG51bGwgfHwgIShrZXkgaW4gYXR0cnMpKSB7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gXCJjbGFzc05hbWVcIikga2V5ID0gXCJjbGFzc1wiXG5cdFx0XHRcdFx0aWYgKGtleVswXSA9PT0gXCJvXCIgJiYga2V5WzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5KSkgdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleSAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNGb3JtQXR0cmlidXRlKHZub2RlLCBhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwidmFsdWVcIiB8fCBhdHRyID09PSBcImNoZWNrZWRcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkSW5kZXhcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkXCIgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpc0xpZmVjeWNsZU1ldGhvZChhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwib25pbml0XCIgfHwgYXR0ciA9PT0gXCJvbmNyZWF0ZVwiIHx8IGF0dHIgPT09IFwib251cGRhdGVcIiB8fCBhdHRyID09PSBcIm9ucmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmV1cGRhdGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQXR0cmlidXRlKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJocmVmXCIgfHwgYXR0ciA9PT0gXCJsaXN0XCIgfHwgYXR0ciA9PT0gXCJmb3JtXCIgfHwgYXR0ciA9PT0gXCJ3aWR0aFwiIHx8IGF0dHIgPT09IFwiaGVpZ2h0XCIvLyB8fCBhdHRyID09PSBcInR5cGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh2bm9kZSl7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzLmlzIHx8IHZub2RlLnRhZy5pbmRleE9mKFwiLVwiKSA+IC0xXG5cdH1cblx0ZnVuY3Rpb24gaGFzSW50ZWdyYXRpb25NZXRob2RzKHNvdXJjZSkge1xuXHRcdHJldHVybiBzb3VyY2UgIT0gbnVsbCAmJiAoc291cmNlLm9uY3JlYXRlIHx8IHNvdXJjZS5vbnVwZGF0ZSB8fCBzb3VyY2Uub25iZWZvcmVyZW1vdmUgfHwgc291cmNlLm9ucmVtb3ZlKVxuXHR9XG5cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleSBpbiBzdHlsZSkpIGVsZW1lbnQuc3R5bGVba2V5XSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdmFsdWUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdHZhciBjYWxsYmFjayA9IHR5cGVvZiBvbmV2ZW50ICE9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSA6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWx1ZS5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRvbmV2ZW50LmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9XG5cdFx0aWYgKGtleSBpbiBlbGVtZW50KSBlbGVtZW50W2tleV0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleS5zbGljZSgyKVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50cyA9PT0gdW5kZWZpbmVkKSB2bm9kZS5ldmVudHMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXldID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleV0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleV0sIGZhbHNlKVxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHZub2RlLmV2ZW50c1trZXldID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleV0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vbGlmZWN5Y2xlXG5cdGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmluaXQgPT09IFwiZnVuY3Rpb25cIikgc291cmNlLm9uaW5pdC5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbmNyZWF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub251cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub251cGRhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSB7XG5cdFx0dmFyIGZvcmNlVm5vZGVVcGRhdGUsIGZvcmNlQ29tcG9uZW50VXBkYXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlVm5vZGVVcGRhdGUgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VDb21wb25lbnRVcGRhdGUgPSB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAoIShmb3JjZVZub2RlVXBkYXRlID09PSB1bmRlZmluZWQgJiYgZm9yY2VDb21wb25lbnRVcGRhdGUgPT09IHVuZGVmaW5lZCkgJiYgIWZvcmNlVm5vZGVVcGRhdGUgJiYgIWZvcmNlQ29tcG9uZW50VXBkYXRlKSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHRcdHZub2RlLmluc3RhbmNlID0gb2xkLmluc3RhbmNlXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXG5cdFx0Ly8gRmlyc3QgdGltZSByZW5kZXJpbmcgaW50byBhIG5vZGUgY2xlYXJzIGl0IG91dFxuXHRcdGlmIChkb20udm5vZGVzID09IG51bGwpIGRvbS50ZXh0Q29udGVudCA9IFwiXCJcblxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHQvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiByZXR1cm4gbnVsbCBpbiBJRSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvYWN0aXZlRWxlbWVudFxuXHRcdGlmIChhY3RpdmUgIT0gbnVsbCAmJiAkZG9jLmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZSkgYWN0aXZlLmZvY3VzKClcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdH1cblxuXHRyZXR1cm4ge3JlbmRlcjogcmVuZGVyLCBzZXRFdmVudENhbGxiYWNrOiBzZXRFdmVudENhbGxiYWNrfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMsIGNoaWxkcmVuLCB0ZXh0LCBkb20pIHtcblx0cmV0dXJuIHt0YWc6IHRhZywga2V5OiBrZXksIGF0dHJzOiBhdHRycywgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0OiB0ZXh0LCBkb206IGRvbSwgZG9tU2l6ZTogdW5kZWZpbmVkLCBzdGF0ZTogdW5kZWZpbmVkLCBfc3RhdGU6IHVuZGVmaW5lZCwgZXZlbnRzOiB1bmRlZmluZWQsIGluc3RhbmNlOiB1bmRlZmluZWQsIHNraXA6IGZhbHNlfVxufVxuVm5vZGUubm9ybWFsaXplID0gZnVuY3Rpb24obm9kZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShub2RlKSkgcmV0dXJuIFZub2RlKFwiW1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4obm9kZSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRpZiAobm9kZSAhPSBudWxsICYmIHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBub2RlID09PSBmYWxzZSA/IFwiXCIgOiBub2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0cmV0dXJuIG5vZGVcbn1cblZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNoaWxkcmVuW2ldID0gVm5vZGUubm9ybWFsaXplKGNoaWxkcmVuW2ldKVxuXHR9XG5cdHJldHVybiBjaGlsZHJlblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZub2RlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3N0cmVhbS9zdHJlYW1cIilcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG47KGZ1bmN0aW9uKCkge1xuXCJ1c2Ugc3RyaWN0XCJcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGd1aWQgPSAwLCBIQUxUID0ge31cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSgpIHtcblx0ZnVuY3Rpb24gc3RyZWFtKCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IEhBTFQpIHVwZGF0ZVN0cmVhbShzdHJlYW0sIGFyZ3VtZW50c1swXSlcblx0XHRyZXR1cm4gc3RyZWFtLl9zdGF0ZS52YWx1ZVxuXHR9XG5cdGluaXRTdHJlYW0oc3RyZWFtKVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IEhBTFQpIHVwZGF0ZVN0cmVhbShzdHJlYW0sIGFyZ3VtZW50c1swXSlcblxuXHRyZXR1cm4gc3RyZWFtXG59XG5mdW5jdGlvbiBpbml0U3RyZWFtKHN0cmVhbSkge1xuXHRzdHJlYW0uY29uc3RydWN0b3IgPSBjcmVhdGVTdHJlYW1cblx0c3RyZWFtLl9zdGF0ZSA9IHtpZDogZ3VpZCsrLCB2YWx1ZTogdW5kZWZpbmVkLCBzdGF0ZTogMCwgZGVyaXZlOiB1bmRlZmluZWQsIHJlY292ZXI6IHVuZGVmaW5lZCwgZGVwczoge30sIHBhcmVudHM6IFtdLCBlbmRTdHJlYW06IHVuZGVmaW5lZCwgdW5yZWdpc3RlcjogdW5kZWZpbmVkfVxuXHRzdHJlYW0ubWFwID0gc3RyZWFtW1wiZmFudGFzeS1sYW5kL21hcFwiXSA9IG1hcCwgc3RyZWFtW1wiZmFudGFzeS1sYW5kL2FwXCJdID0gYXAsIHN0cmVhbVtcImZhbnRhc3ktbGFuZC9vZlwiXSA9IGNyZWF0ZVN0cmVhbVxuXHRzdHJlYW0udmFsdWVPZiA9IHZhbHVlT2YsIHN0cmVhbS50b0pTT04gPSB0b0pTT04sIHN0cmVhbS50b1N0cmluZyA9IHZhbHVlT2ZcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJlYW0sIHtcblx0XHRlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCFzdHJlYW0uX3N0YXRlLmVuZFN0cmVhbSkge1xuXHRcdFx0XHR2YXIgZW5kU3RyZWFtID0gY3JlYXRlU3RyZWFtKClcblx0XHRcdFx0ZW5kU3RyZWFtLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0dW5yZWdpc3RlclN0cmVhbShzdHJlYW0pXG5cdFx0XHRcdFx0XHRlbmRTdHJlYW0uX3N0YXRlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbigpe3VucmVnaXN0ZXJTdHJlYW0oZW5kU3RyZWFtKX1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHN0cmVhbS5fc3RhdGUuZW5kU3RyZWFtID0gZW5kU3RyZWFtXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyZWFtLl9zdGF0ZS5lbmRTdHJlYW1cblx0XHR9fVxuXHR9KVxufVxuZnVuY3Rpb24gdXBkYXRlU3RyZWFtKHN0cmVhbSwgdmFsdWUpIHtcblx0dXBkYXRlU3RhdGUoc3RyZWFtLCB2YWx1ZSlcblx0Zm9yICh2YXIgaWQgaW4gc3RyZWFtLl9zdGF0ZS5kZXBzKSB1cGRhdGVEZXBlbmRlbmN5KHN0cmVhbS5fc3RhdGUuZGVwc1tpZF0sIGZhbHNlKVxuXHRpZiAoc3RyZWFtLl9zdGF0ZS51bnJlZ2lzdGVyICE9IG51bGwpIHN0cmVhbS5fc3RhdGUudW5yZWdpc3RlcigpXG5cdGZpbmFsaXplKHN0cmVhbSlcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHN0cmVhbSwgdmFsdWUpIHtcblx0c3RyZWFtLl9zdGF0ZS52YWx1ZSA9IHZhbHVlXG5cdHN0cmVhbS5fc3RhdGUuY2hhbmdlZCA9IHRydWVcblx0aWYgKHN0cmVhbS5fc3RhdGUuc3RhdGUgIT09IDIpIHN0cmVhbS5fc3RhdGUuc3RhdGUgPSAxXG59XG5mdW5jdGlvbiB1cGRhdGVEZXBlbmRlbmN5KHN0cmVhbSwgbXVzdFN5bmMpIHtcblx0dmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZSwgcGFyZW50cyA9IHN0YXRlLnBhcmVudHNcblx0aWYgKHBhcmVudHMubGVuZ3RoID4gMCAmJiBwYXJlbnRzLmV2ZXJ5KGFjdGl2ZSkgJiYgKG11c3RTeW5jIHx8IHBhcmVudHMuc29tZShjaGFuZ2VkKSkpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJlYW0uX3N0YXRlLmRlcml2ZSgpXG5cdFx0aWYgKHZhbHVlID09PSBIQUxUKSByZXR1cm4gZmFsc2Vcblx0XHR1cGRhdGVTdGF0ZShzdHJlYW0sIHZhbHVlKVxuXHR9XG59XG5mdW5jdGlvbiBmaW5hbGl6ZShzdHJlYW0pIHtcblx0c3RyZWFtLl9zdGF0ZS5jaGFuZ2VkID0gZmFsc2Vcblx0Zm9yICh2YXIgaWQgaW4gc3RyZWFtLl9zdGF0ZS5kZXBzKSBzdHJlYW0uX3N0YXRlLmRlcHNbaWRdLl9zdGF0ZS5jaGFuZ2VkID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tYmluZShmbiwgc3RyZWFtcykge1xuXHRpZiAoIXN0cmVhbXMuZXZlcnkodmFsaWQpKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCBlYWNoIGl0ZW0gcGFzc2VkIHRvIHN0cmVhbS5jb21iaW5lL3N0cmVhbS5tZXJnZSBpcyBhIHN0cmVhbVwiKVxuXHRyZXR1cm4gaW5pdERlcGVuZGVuY3koY3JlYXRlU3RyZWFtKCksIHN0cmVhbXMsIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSh0aGlzLCBzdHJlYW1zLmNvbmNhdChbc3RyZWFtcy5maWx0ZXIoY2hhbmdlZCldKSlcblx0fSlcbn1cblxuZnVuY3Rpb24gaW5pdERlcGVuZGVuY3koZGVwLCBzdHJlYW1zLCBkZXJpdmUpIHtcblx0dmFyIHN0YXRlID0gZGVwLl9zdGF0ZVxuXHRzdGF0ZS5kZXJpdmUgPSBkZXJpdmVcblx0c3RhdGUucGFyZW50cyA9IHN0cmVhbXMuZmlsdGVyKG5vdEVuZGVkKVxuXG5cdHJlZ2lzdGVyRGVwZW5kZW5jeShkZXAsIHN0YXRlLnBhcmVudHMpXG5cdHVwZGF0ZURlcGVuZGVuY3koZGVwLCB0cnVlKVxuXG5cdHJldHVybiBkZXBcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVwZW5kZW5jeShzdHJlYW0sIHBhcmVudHMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0cGFyZW50c1tpXS5fc3RhdGUuZGVwc1tzdHJlYW0uX3N0YXRlLmlkXSA9IHN0cmVhbVxuXHRcdHJlZ2lzdGVyRGVwZW5kZW5jeShzdHJlYW0sIHBhcmVudHNbaV0uX3N0YXRlLnBhcmVudHMpXG5cdH1cbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJTdHJlYW0oc3RyZWFtKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3RyZWFtLl9zdGF0ZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHBhcmVudCA9IHN0cmVhbS5fc3RhdGUucGFyZW50c1tpXVxuXHRcdGRlbGV0ZSBwYXJlbnQuX3N0YXRlLmRlcHNbc3RyZWFtLl9zdGF0ZS5pZF1cblx0fVxuXHRmb3IgKHZhciBpZCBpbiBzdHJlYW0uX3N0YXRlLmRlcHMpIHtcblx0XHR2YXIgZGVwZW5kZW50ID0gc3RyZWFtLl9zdGF0ZS5kZXBzW2lkXVxuXHRcdHZhciBpbmRleCA9IGRlcGVuZGVudC5fc3RhdGUucGFyZW50cy5pbmRleE9mKHN0cmVhbSlcblx0XHRpZiAoaW5kZXggPiAtMSkgZGVwZW5kZW50Ll9zdGF0ZS5wYXJlbnRzLnNwbGljZShpbmRleCwgMSlcblx0fVxuXHRzdHJlYW0uX3N0YXRlLnN0YXRlID0gMiAvL2VuZGVkXG5cdHN0cmVhbS5fc3RhdGUuZGVwcyA9IHt9XG59XG5cbmZ1bmN0aW9uIG1hcChmbikge3JldHVybiBjb21iaW5lKGZ1bmN0aW9uKHN0cmVhbSkge3JldHVybiBmbihzdHJlYW0oKSl9LCBbdGhpc10pfVxuZnVuY3Rpb24gYXAoc3RyZWFtKSB7cmV0dXJuIGNvbWJpbmUoZnVuY3Rpb24oczEsIHMyKSB7cmV0dXJuIHMxKCkoczIoKSl9LCBbc3RyZWFtLCB0aGlzXSl9XG5mdW5jdGlvbiB2YWx1ZU9mKCkge3JldHVybiB0aGlzLl9zdGF0ZS52YWx1ZX1cbmZ1bmN0aW9uIHRvSlNPTigpIHtyZXR1cm4gdGhpcy5fc3RhdGUudmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdGhpcy5fc3RhdGUudmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9zdGF0ZS52YWx1ZS50b0pTT04oKSA6IHRoaXMuX3N0YXRlLnZhbHVlfVxuXG5mdW5jdGlvbiB2YWxpZChzdHJlYW0pIHtyZXR1cm4gc3RyZWFtLl9zdGF0ZSB9XG5mdW5jdGlvbiBhY3RpdmUoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDF9XG5mdW5jdGlvbiBjaGFuZ2VkKHN0cmVhbSkge3JldHVybiBzdHJlYW0uX3N0YXRlLmNoYW5nZWR9XG5mdW5jdGlvbiBub3RFbmRlZChzdHJlYW0pIHtyZXR1cm4gc3RyZWFtLl9zdGF0ZS5zdGF0ZSAhPT0gMn1cblxuZnVuY3Rpb24gbWVyZ2Uoc3RyZWFtcykge1xuXHRyZXR1cm4gY29tYmluZShmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc3RyZWFtcy5tYXAoZnVuY3Rpb24ocykge3JldHVybiBzKCl9KVxuXHR9LCBzdHJlYW1zKVxufVxuXG5mdW5jdGlvbiBzY2FuKHJlZHVjZXIsIHNlZWQsIHN0cmVhbSkge1xuXHR2YXIgbmV3U3RyZWFtID0gY29tYmluZShmdW5jdGlvbiAocykge1xuXHRcdHJldHVybiBzZWVkID0gcmVkdWNlcihzZWVkLCBzLl9zdGF0ZS52YWx1ZSlcblx0fSwgW3N0cmVhbV0pXG5cblx0aWYgKG5ld1N0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDApIG5ld1N0cmVhbShzZWVkKVxuXG5cdHJldHVybiBuZXdTdHJlYW1cbn1cblxuZnVuY3Rpb24gc2Nhbk1lcmdlKHR1cGxlcywgc2VlZCkge1xuXHR2YXIgc3RyZWFtcyA9IHR1cGxlcy5tYXAoZnVuY3Rpb24odHVwbGUpIHtcblx0XHR2YXIgc3RyZWFtID0gdHVwbGVbMF1cblx0XHRpZiAoc3RyZWFtLl9zdGF0ZS5zdGF0ZSA9PT0gMCkgc3RyZWFtKHVuZGVmaW5lZClcblx0XHRyZXR1cm4gc3RyZWFtXG5cdH0pXG5cblx0dmFyIG5ld1N0cmVhbSA9IGNvbWJpbmUoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoYW5nZWQgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdXG5cblx0XHRzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtLCBpZHgpIHtcblx0XHRcdGlmIChjaGFuZ2VkLmluZGV4T2Yoc3RyZWFtKSA+IC0xKSB7XG5cdFx0XHRcdHNlZWQgPSB0dXBsZXNbaWR4XVsxXShzZWVkLCBzdHJlYW0uX3N0YXRlLnZhbHVlKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRyZXR1cm4gc2VlZFxuXHR9LCBzdHJlYW1zKVxuXG5cdHJldHVybiBuZXdTdHJlYW1cbn1cblxuY3JlYXRlU3RyZWFtW1wiZmFudGFzeS1sYW5kL29mXCJdID0gY3JlYXRlU3RyZWFtXG5jcmVhdGVTdHJlYW0ubWVyZ2UgPSBtZXJnZVxuY3JlYXRlU3RyZWFtLmNvbWJpbmUgPSBjb21iaW5lXG5jcmVhdGVTdHJlYW0uc2NhbiA9IHNjYW5cbmNyZWF0ZVN0cmVhbS5zY2FuTWVyZ2UgPSBzY2FuTWVyZ2VcbmNyZWF0ZVN0cmVhbS5IQUxUID0gSEFMVFxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IGNyZWF0ZVN0cmVhbVxuZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5tID09PSBcImZ1bmN0aW9uXCIgJiYgIShcInN0cmVhbVwiIGluIHdpbmRvdy5tKSkgd2luZG93Lm0uc3RyZWFtID0gY3JlYXRlU3RyZWFtXG5lbHNlIHdpbmRvdy5tID0ge3N0cmVhbSA6IGNyZWF0ZVN0cmVhbX1cblxufSgpKTtcbiIsIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyAod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbKG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddO1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHdlZWtkYXlzW20uZGF5KCldIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICB2YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgVVQ6IDAsXG4gICAgICAgIEdNVDogMCxcbiAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICBQU1Q6IC04ICogNjBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XG4gICAgICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgICAgIHZhciB6b25lID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQ7XG4gICAgdmFyIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFO1xuICAgIHZhciBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMyArIDMsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX0hPVVIgLSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBwcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIHByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG4gICAgcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIHByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIHByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4gICAgcHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6ICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzogcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6ICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1F1YXJ0ZXJzICAgICA9IG1ha2VBcygnUScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbiAgICBwcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzICAgICA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjQuMCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG4gICAgaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIGhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICBob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIHZpbTp0cz00OnN0cz00OnN3PTQ6XG4vKiFcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEyIEtyaXMgS293YWwgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVRcbiAqIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvcmF3L21hc3Rlci9MSUNFTlNFXG4gKlxuICogV2l0aCBwYXJ0cyBieSBUeWxlciBDbG9zZVxuICogQ29weXJpZ2h0IDIwMDctMjAwOSBUeWxlciBDbG9zZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBYIGxpY2Vuc2UgZm91bmRcbiAqIGF0IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UuaHRtbFxuICogRm9ya2VkIGF0IHJlZl9zZW5kLmpzIHZlcnNpb246IDIwMDktMDUtMTFcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IE1hcmsgTWlsbGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBUaGlzIGZpbGUgd2lsbCBmdW5jdGlvbiBwcm9wZXJseSBhcyBhIDxzY3JpcHQ+IHRhZywgb3IgYSBtb2R1bGVcbiAgICAvLyB1c2luZyBDb21tb25KUyBhbmQgTm9kZUpTIG9yIFJlcXVpcmVKUyBtb2R1bGUgZm9ybWF0cy4gIEluXG4gICAgLy8gQ29tbW9uL05vZGUvUmVxdWlyZUpTLCB0aGUgbW9kdWxlIGV4cG9ydHMgdGhlIFEgQVBJIGFuZCB3aGVuXG4gICAgLy8gZXhlY3V0ZWQgYXMgYSBzaW1wbGUgPHNjcmlwdD4sIGl0IGNyZWF0ZXMgYSBRIGdsb2JhbCBpbnN0ZWFkLlxuXG4gICAgLy8gTW9udGFnZSBSZXF1aXJlXG4gICAgaWYgKHR5cGVvZiBib290c3RyYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBib290c3RyYXAoXCJwcm9taXNlXCIsIGRlZmluaXRpb24pO1xuXG4gICAgLy8gQ29tbW9uSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAvLyBSZXF1aXJlSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcblxuICAgIC8vIFNFUyAoU2VjdXJlIEVjbWFTY3JpcHQpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICghc2VzLm9rKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcy5tYWtlUSA9IGRlZmluaXRpb247XG4gICAgICAgIH1cblxuICAgIC8vIDxzY3JpcHQ+XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZWxmLlEgPSBkZWZpbml0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGVudmlyb25tZW50IHdhcyBub3QgYW50aWNpYXB0ZWQgYnkgUS4gUGxlYXNlIGZpbGUgYSBidWcuXCIpO1xuICAgIH1cblxufSkoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoYXNTdGFja3MgPSBmYWxzZTtcbnRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzU3RhY2tzID0gISFlLnN0YWNrO1xufVxuXG4vLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWRcbi8vIGJ5IFEuXG52YXIgcVN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG52YXIgcUZpbGVOYW1lO1xuXG4vLyBzaGltc1xuXG4vLyB1c2VkIGZvciBmYWxsYmFjayBpbiBcImFsbFJlc29sdmVkXCJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cbnZhciBuZXh0VGljayA9KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBsaW5rZWQgbGlzdCBvZiB0YXNrcyAoc2luZ2xlLCB3aXRoIGhlYWQgbm9kZSlcbiAgICB2YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xuICAgIHZhciB0YWlsID0gaGVhZDtcbiAgICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSB2b2lkIDA7XG4gICAgdmFyIGlzTm9kZUpTID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG5cbiAgICAgICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgICAgIHZhciB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgaGVhZC5kb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb250aW51YXRpb24gaWYgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyBzdXBwcmVzc2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBicm93c2VycywgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLlxuICAgICAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5leHRUaWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAgICAgLy8gTm9kZS5qcyBiZWZvcmUgMC45LiBOb3RlIHRoYXQgc29tZSBmYWtlLU5vZGUgZW52aXJvbm1lbnRzLCBsaWtlIHRoZVxuICAgICAgICAvLyBNb2NoYSB0ZXN0IHJ1bm5lciwgaW50cm9kdWNlIGEgYHByb2Nlc3NgIGdsb2JhbCB3aXRob3V0IGEgYG5leHRUaWNrYC5cbiAgICAgICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgU2FmYXJpIFZlcnNpb24gNi4wLjUgKDg1MzYuMzAuMSkgaW50ZXJtaXR0ZW50bHkgY2Fubm90IGNyZWF0ZVxuICAgICAgICAvLyB3b3JraW5nIG1lc3NhZ2UgcG9ydHMgdGhlIGZpcnN0IHRpbWUgYSBwYWdlIGxvYWRzLlxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gcmVxdWVzdFBvcnRUaWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0UG9ydFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIHVzZSBpdC5cbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICByZXF1ZXN0UG9ydFRpY2soKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBicm93c2Vyc1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0VGljaztcbn0pKCk7XG5cbi8vIEF0dGVtcHQgdG8gbWFrZSBnZW5lcmljcyBzYWZlIGluIHRoZSBmYWNlIG9mIGRvd25zdHJlYW1cbi8vIG1vZGlmaWNhdGlvbnMuXG4vLyBUaGVyZSBpcyBubyBzaXR1YXRpb24gd2hlcmUgdGhpcyBpcyBuZWNlc3NhcnkuXG4vLyBJZiB5b3UgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSwgdGhlc2UgcHJpbW9yZGlhbHMgbmVlZCB0byBiZVxuLy8gZGVlcGx5IGZyb3plbiBhbnl3YXksIGFuZCBpZiB5b3UgZG9u4oCZdCBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLFxuLy8gdGhpcyBpcyBqdXN0IHBsYWluIHBhcmFub2lkLlxuLy8gSG93ZXZlciwgdGhpcyAqKm1pZ2h0KiogaGF2ZSB0aGUgbmljZSBzaWRlLWVmZmVjdCBvZiByZWR1Y2luZyB0aGUgc2l6ZSBvZlxuLy8gdGhlIG1pbmlmaWVkIGNvZGUgYnkgcmVkdWNpbmcgeC5jYWxsKCkgdG8gbWVyZWx5IHgoKVxuLy8gU2VlIE1hcmsgTWlsbGVy4oCZcyBleHBsYW5hdGlvbiBvZiB3aGF0IHRoaXMgZG9lcy5cbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWNvbnZlbnRpb25zOnNhZmVfbWV0YV9wcm9ncmFtbWluZ1xudmFyIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjYWxsLmFwcGx5KGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCwgYnV0IHNsb3dlcjpcbi8vIHVuY3VycnlUaGlzID0gRnVuY3Rpb25fYmluZC5iaW5kKEZ1bmN0aW9uX2JpbmQuY2FsbCk7XG4vLyBodHRwOi8vanNwZXJmLmNvbS91bmN1cnJ5dGhpc1xuXG52YXIgYXJyYXlfc2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheS5wcm90b3R5cGUuc2xpY2UpO1xuXG52YXIgYXJyYXlfcmVkdWNlID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIGJhc2lzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgLy8gY29uY2VybmluZyB0aGUgaW5pdGlhbCB2YWx1ZSwgaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gc2VlayB0byB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFycmF5LCBhY2NvdW50aW5nXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgaXMgaXMgYSBzcGFyc2UgYXJyYXlcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBiYXNpcyA9IHRoaXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZHVjZVxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSBhcnJheSBpcyBzcGFyc2VcbiAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgYmFzaXMgPSBjYWxsYmFjayhiYXNpcywgdGhpc1tpbmRleF0sIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzaXM7XG4gICAgfVxuKTtcblxudmFyIGFycmF5X2luZGV4T2YgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbm90IGEgdmVyeSBnb29kIHNoaW0sIGJ1dCBnb29kIGVub3VnaCBmb3Igb3VyIG9uZSB1c2Ugb2YgaXRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuKTtcblxudmFyIGFycmF5X21hcCA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xsZWN0ID0gW107XG4gICAgICAgIGFycmF5X3JlZHVjZShzZWxmLCBmdW5jdGlvbiAodW5kZWZpbmVkLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjYWxsYmFjay5jYWxsKHRoaXNwLCB2YWx1ZSwgaW5kZXgsIHNlbGYpKTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Q7XG4gICAgfVxuKTtcblxudmFyIG9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUpIHtcbiAgICBmdW5jdGlvbiBUeXBlKCkgeyB9XG4gICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgcmV0dXJuIG5ldyBUeXBlKCk7XG59O1xuXG52YXIgb2JqZWN0X2hhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbnZhciBvYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdF9oYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcblxudmFyIG9iamVjdF90b1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gT2JqZWN0KHZhbHVlKTtcbn1cblxuLy8gZ2VuZXJhdG9yIHJlbGF0ZWQgc2hpbXNcblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGZ1bmN0aW9uIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbmZ1bmN0aW9uIGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBvYmplY3RfdG9TdHJpbmcoZXhjZXB0aW9uKSA9PT0gXCJbb2JqZWN0IFN0b3BJdGVyYXRpb25dXCIgfHxcbiAgICAgICAgZXhjZXB0aW9uIGluc3RhbmNlb2YgUVJldHVyblZhbHVlXG4gICAgKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGhlbHBlciBhbmQgUS5yZXR1cm4gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW5cbi8vIFNwaWRlck1vbmtleS5cbnZhciBRUmV0dXJuVmFsdWU7XG5pZiAodHlwZW9mIFJldHVyblZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUVJldHVyblZhbHVlID0gUmV0dXJuVmFsdWU7XG59IGVsc2Uge1xuICAgIFFSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbn1cblxuLy8gbG9uZyBzdGFjayB0cmFjZXNcblxudmFyIFNUQUNLX0pVTVBfU0VQQVJBVE9SID0gXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiO1xuXG5mdW5jdGlvbiBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpIHtcbiAgICAvLyBJZiBwb3NzaWJsZSwgdHJhbnNmb3JtIHRoZSBlcnJvciBzdGFjayB0cmFjZSBieSByZW1vdmluZyBOb2RlIGFuZCBRXG4gICAgLy8gY3J1ZnQsIHRoZW4gY29uY2F0ZW5hdGluZyB3aXRoIHRoZSBzdGFjayB0cmFjZSBvZiBgcHJvbWlzZWAuIFNlZSAjNTcuXG4gICAgaWYgKGhhc1N0YWNrcyAmJlxuICAgICAgICBwcm9taXNlLnN0YWNrICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnJvci5zdGFjayAmJlxuICAgICAgICBlcnJvci5zdGFjay5pbmRleE9mKFNUQUNLX0pVTVBfU0VQQVJBVE9SKSA9PT0gLTFcbiAgICApIHtcbiAgICAgICAgdmFyIHN0YWNrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwID0gcHJvbWlzZTsgISFwOyBwID0gcC5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChwLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tzLnVuc2hpZnQocC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnVuc2hpZnQoZXJyb3Iuc3RhY2spO1xuXG4gICAgICAgIHZhciBjb25jYXRlZFN0YWNrcyA9IHN0YWNrcy5qb2luKFwiXFxuXCIgKyBTVEFDS19KVU1QX1NFUEFSQVRPUiArIFwiXFxuXCIpO1xuICAgICAgICBlcnJvci5zdGFjayA9IGZpbHRlclN0YWNrU3RyaW5nKGNvbmNhdGVkU3RhY2tzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlclN0YWNrU3RyaW5nKHN0YWNrU3RyaW5nKSB7XG4gICAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGRlc2lyZWRMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICBpZiAoIWlzSW50ZXJuYWxGcmFtZShsaW5lKSAmJiAhaXNOb2RlRnJhbWUobGluZSkgJiYgbGluZSkge1xuICAgICAgICAgICAgZGVzaXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRMaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVGcmFtZShzdGFja0xpbmUpIHtcbiAgICByZXR1cm4gc3RhY2tMaW5lLmluZGV4T2YoXCIobW9kdWxlLmpzOlwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgc3RhY2tMaW5lLmluZGV4T2YoXCIobm9kZS5qczpcIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKSB7XG4gICAgLy8gTmFtZWQgZnVuY3Rpb25zOiBcImF0IGZ1bmN0aW9uTmFtZSAoZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXIpXCJcbiAgICAvLyBJbiBJRTEwIGZ1bmN0aW9uIG5hbWUgY2FuIGhhdmUgc3BhY2VzIChcIkFub255bW91cyBmdW5jdGlvblwiKSBPX29cbiAgICB2YXIgYXR0ZW1wdDEgPSAvYXQgLisgXFwoKC4rKTooXFxkKyk6KD86XFxkKylcXCkkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQxKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDFbMV0sIE51bWJlcihhdHRlbXB0MVsyXSldO1xuICAgIH1cblxuICAgIC8vIEFub255bW91cyBmdW5jdGlvbnM6IFwiYXQgZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MiA9IC9hdCAoW14gXSspOihcXGQrKTooPzpcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDIpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MlsxXSwgTnVtYmVyKGF0dGVtcHQyWzJdKV07XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCBzdHlsZTogXCJmdW5jdGlvbkBmaWxlbmFtZTpsaW5lTnVtYmVyIG9yIEBmaWxlbmFtZTpsaW5lTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDMgPSAvLipAKC4rKTooXFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQzKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDNbMV0sIE51bWJlcihhdHRlbXB0M1syXSldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnRlcm5hbEZyYW1lKHN0YWNrTGluZSkge1xuICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKTtcblxuICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG5cbiAgICByZXR1cm4gZmlsZU5hbWUgPT09IHFGaWxlTmFtZSAmJlxuICAgICAgICBsaW5lTnVtYmVyID49IHFTdGFydGluZ0xpbmUgJiZcbiAgICAgICAgbGluZU51bWJlciA8PSBxRW5kaW5nTGluZTtcbn1cblxuLy8gZGlzY292ZXIgb3duIGZpbGUgbmFtZSBhbmQgbGluZSBudW1iZXIgcmFuZ2UgZm9yIGZpbHRlcmluZyBzdGFja1xuLy8gdHJhY2VzXG5mdW5jdGlvbiBjYXB0dXJlTGluZSgpIHtcbiAgICBpZiAoIWhhc1N0YWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gbGluZXNbMF0uaW5kZXhPZihcIkBcIikgPiAwID8gbGluZXNbMV0gOiBsaW5lc1syXTtcbiAgICAgICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihmaXJzdExpbmUpO1xuICAgICAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcUZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgICAgICByZXR1cm4gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKGNhbGxiYWNrLCBuYW1lLCBhbHRlcm5hdGl2ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcIiArIGFsdGVybmF0aXZlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpbnN0ZWFkLlwiLCBuZXcgRXJyb3IoXCJcIikuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShjYWxsYmFjaywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vLyBlbmQgb2Ygc2hpbXNcbi8vIGJlZ2lubmluZyBvZiByZWFsIHdvcmtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZSwgcGFzc2VzIHByb21pc2VzIHRocm91Z2gsIG9yXG4gKiBjb2VyY2VzIHByb21pc2VzIGZyb20gZGlmZmVyZW50IHN5c3RlbXMuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZSBvciBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIFEodmFsdWUpIHtcbiAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIGFscmVhZHkgYSBQcm9taXNlLCByZXR1cm4gaXQgZGlyZWN0bHkuICBUaGlzIGVuYWJsZXNcbiAgICAvLyB0aGUgcmVzb2x2ZSBmdW5jdGlvbiB0byBib3RoIGJlIHVzZWQgdG8gY3JlYXRlZCByZWZlcmVuY2VzIGZyb20gb2JqZWN0cyxcbiAgICAvLyBidXQgdG8gdG9sZXJhYmx5IGNvZXJjZSBub24tcHJvbWlzZXMgdG8gcHJvbWlzZXMuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gYXNzaW1pbGF0ZSB0aGVuYWJsZXNcbiAgICBpZiAoaXNQcm9taXNlQWxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsKHZhbHVlKTtcbiAgICB9XG59XG5RLnJlc29sdmUgPSBRO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuIG9mIHRoZSBldmVudCBsb29wLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdGFza1xuICovXG5RLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbi8qKlxuICogQ29udHJvbHMgd2hldGhlciBvciBub3QgbG9uZyBzdGFjayB0cmFjZXMgd2lsbCBiZSBvblxuICovXG5RLmxvbmdTdGFja1N1cHBvcnQgPSBmYWxzZTtcblxuLy8gZW5hYmxlIGxvbmcgc3RhY2tzIGlmIFFfREVCVUcgaXMgc2V0XG5pZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5RX0RFQlVHKSB7XG4gICAgUS5sb25nU3RhY2tTdXBwb3J0ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEge3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH0gb2JqZWN0LlxuICpcbiAqIGByZXNvbHZlYCBpcyBhIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGEgbW9yZSByZXNvbHZlZCB2YWx1ZSBmb3IgdGhlXG4gKiBwcm9taXNlLiBUbyBmdWxmaWxsIHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYW55IHZhbHVlIHRoYXQgaXNcbiAqIG5vdCBhIHRoZW5hYmxlLiBUbyByZWplY3QgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhIHJlamVjdGVkXG4gKiB0aGVuYWJsZSwgb3IgaW52b2tlIGByZWplY3RgIHdpdGggdGhlIHJlYXNvbiBkaXJlY3RseS4gVG8gcmVzb2x2ZSB0aGVcbiAqIHByb21pc2UgdG8gYW5vdGhlciB0aGVuYWJsZSwgdGh1cyBwdXR0aW5nIGl0IGluIHRoZSBzYW1lIHN0YXRlLCBpbnZva2VcbiAqIGByZXNvbHZlYCB3aXRoIHRoYXQgb3RoZXIgdGhlbmFibGUuXG4gKi9cblEuZGVmZXIgPSBkZWZlcjtcbmZ1bmN0aW9uIGRlZmVyKCkge1xuICAgIC8vIGlmIFwibWVzc2FnZXNcIiBpcyBhbiBcIkFycmF5XCIsIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHByb21pc2UgaGFzIG5vdCB5ZXRcbiAgICAvLyBiZWVuIHJlc29sdmVkLiAgSWYgaXQgaXMgXCJ1bmRlZmluZWRcIiwgaXQgaGFzIGJlZW4gcmVzb2x2ZWQuICBFYWNoXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgbWVzc2FnZXMgYXJyYXkgaXMgaXRzZWxmIGFuIGFycmF5IG9mIGNvbXBsZXRlIGFyZ3VtZW50cyB0b1xuICAgIC8vIGZvcndhcmQgdG8gdGhlIHJlc29sdmVkIHByb21pc2UuICBXZSBjb2VyY2UgdGhlIHJlc29sdXRpb24gdmFsdWUgdG8gYVxuICAgIC8vIHByb21pc2UgdXNpbmcgdGhlIGByZXNvbHZlYCBmdW5jdGlvbiBiZWNhdXNlIGl0IGhhbmRsZXMgYm90aCBmdWxseVxuICAgIC8vIG5vbi10aGVuYWJsZSB2YWx1ZXMgYW5kIG90aGVyIHRoZW5hYmxlcyBncmFjZWZ1bGx5LlxuICAgIHZhciBtZXNzYWdlcyA9IFtdLCBwcm9ncmVzc0xpc3RlbmVycyA9IFtdLCByZXNvbHZlZFByb21pc2U7XG5cbiAgICB2YXIgZGVmZXJyZWQgPSBvYmplY3RfY3JlYXRlKGRlZmVyLnByb3RvdHlwZSk7XG4gICAgdmFyIHByb21pc2UgPSBvYmplY3RfY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcblxuICAgIHByb21pc2UucHJvbWlzZURpc3BhdGNoID0gZnVuY3Rpb24gKHJlc29sdmUsIG9wLCBvcGVyYW5kcykge1xuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChhcmdzKTtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJ3aGVuXCIgJiYgb3BlcmFuZHNbMV0pIHsgLy8gcHJvZ3Jlc3Mgb3BlcmFuZFxuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXJzLnB1c2gob3BlcmFuZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShyZXNvbHZlZFByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gWFhYIGRlcHJlY2F0ZWRcbiAgICBwcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lYXJlclZhbHVlID0gbmVhcmVyKHJlc29sdmVkUHJvbWlzZSk7XG4gICAgICAgIGlmIChpc1Byb21pc2UobmVhcmVyVmFsdWUpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZWFyZXJWYWx1ZTsgLy8gc2hvcnRlbiBjaGFpblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXJWYWx1ZTtcbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicGVuZGluZ1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgfTtcblxuICAgIGlmIChRLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTk9URTogZG9uJ3QgdHJ5IHRvIHVzZSBgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VgIG9yIHRyYW5zZmVyIHRoZVxuICAgICAgICAgICAgLy8gYWNjZXNzb3IgYXJvdW5kOyB0aGF0IGNhdXNlcyBtZW1vcnkgbGVha3MgYXMgcGVyIEdILTExMS4gSnVzdFxuICAgICAgICAgICAgLy8gcmVpZnkgdGhlIHN0YWNrIHRyYWNlIGFzIGEgc3RyaW5nIEFTQVAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSwgY3V0IG9mZiB0aGUgZmlyc3QgbGluZTsgaXQncyBhbHdheXMganVzdFxuICAgICAgICAgICAgLy8gXCJbb2JqZWN0IFByb21pc2VdXFxuXCIsIGFzIHBlciB0aGUgYHRvU3RyaW5nYC5cbiAgICAgICAgICAgIHByb21pc2Uuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cmluZyhlLnN0YWNrLmluZGV4T2YoXCJcXG5cIikgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IHdlIGRvIHRoZSBjaGVja3MgZm9yIGByZXNvbHZlZFByb21pc2VgIGluIGVhY2ggbWV0aG9kLCBpbnN0ZWFkIG9mXG4gICAgLy8gY29uc29saWRhdGluZyB0aGVtIGludG8gYGJlY29tZWAsIHNpbmNlIG90aGVyd2lzZSB3ZSdkIGNyZWF0ZSBuZXdcbiAgICAvLyBwcm9taXNlcyB3aXRoIHRoZSBsaW5lcyBgYmVjb21lKHdoYXRldmVyKHZhbHVlKSlgLiBTZWUgZS5nLiBHSC0yNTIuXG5cbiAgICBmdW5jdGlvbiBiZWNvbWUobmV3UHJvbWlzZSkge1xuICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZXdQcm9taXNlO1xuICAgICAgICBwcm9taXNlLnNvdXJjZSA9IG5ld1Byb21pc2U7XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKG1lc3NhZ2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShuZXdQcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuXG4gICAgICAgIG1lc3NhZ2VzID0gdm9pZCAwO1xuICAgICAgICBwcm9ncmVzc0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICBkZWZlcnJlZC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShRKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGRlZmVycmVkLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKGZ1bGZpbGwodmFsdWUpKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKHJlamVjdChyZWFzb24pKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UocHJvZ3Jlc3NMaXN0ZW5lcnMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb2dyZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIGRlZmVycmVkXG4gKiBwcm9taXNlLlxuICogQHJldHVybnMgYSBub2RlYmFja1xuICovXG5kZWZlci5wcm90b3R5cGUubWFrZU5vZGVSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZShhcnJheV9zbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gcmVzb2x2ZXIge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub3RoaW5nIGFuZCBhY2NlcHRzXG4gKiB0aGUgcmVzb2x2ZSwgcmVqZWN0LCBhbmQgbm90aWZ5IGZ1bmN0aW9ucyBmb3IgYSBkZWZlcnJlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IG1heSBiZSByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiByZXNvbHZlIGFuZCByZWplY3RcbiAqIGZ1bmN0aW9ucywgb3IgcmVqZWN0ZWQgYnkgYSB0aHJvd24gZXhjZXB0aW9uIGluIHJlc29sdmVyXG4gKi9cblEuUHJvbWlzZSA9IHByb21pc2U7IC8vIEVTNlxuUS5wcm9taXNlID0gcHJvbWlzZTtcbmZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbnByb21pc2UucmFjZSA9IHJhY2U7IC8vIEVTNlxucHJvbWlzZS5hbGwgPSBhbGw7IC8vIEVTNlxucHJvbWlzZS5yZWplY3QgPSByZWplY3Q7IC8vIEVTNlxucHJvbWlzZS5yZXNvbHZlID0gUTsgLy8gRVM2XG5cbi8vIFhYWCBleHBlcmltZW50YWwuICBUaGlzIG1ldGhvZCBpcyBhIHdheSB0byBkZW5vdGUgdGhhdCBhIGxvY2FsIHZhbHVlIGlzXG4vLyBzZXJpYWxpemFibGUgYW5kIHNob3VsZCBiZSBpbW1lZGlhdGVseSBkaXNwYXRjaGVkIHRvIGEgcmVtb3RlIHVwb24gcmVxdWVzdCxcbi8vIGluc3RlYWQgb2YgcGFzc2luZyBhIHJlZmVyZW5jZS5cblEucGFzc0J5Q29weSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIElmIHR3byBwcm9taXNlcyBldmVudHVhbGx5IGZ1bGZpbGwgdG8gdGhlIHNhbWUgdmFsdWUsIHByb21pc2VzIHRoYXQgdmFsdWUsXG4gKiBidXQgb3RoZXJ3aXNlIHJlamVjdHMuXG4gKiBAcGFyYW0geCB7QW55Kn1cbiAqIEBwYXJhbSB5IHtBbnkqfVxuICogQHJldHVybnMge0FueSp9IGEgcHJvbWlzZSBmb3IgeCBhbmQgeSBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYnV0IGEgcmVqZWN0aW9uXG4gKiBvdGhlcndpc2UuXG4gKlxuICovXG5RLmpvaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBRKHgpLmpvaW4oeSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICByZXR1cm4gUShbdGhpcywgdGhhdF0pLnNwcmVhZChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gVE9ETzogXCI9PT1cIiBzaG91bGQgYmUgT2JqZWN0LmlzIG9yIGVxdWl2XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGpvaW46IG5vdCB0aGUgc2FtZTogXCIgKyB4ICsgXCIgXCIgKyB5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGZpcnN0IG9mIGFuIGFycmF5IG9mIHByb21pc2VzIHRvIGJlY29tZSBzZXR0bGVkLlxuICogQHBhcmFtIGFuc3dlcnMge0FycmF5W0FueSpdfSBwcm9taXNlcyB0byByYWNlXG4gKiBAcmV0dXJucyB7QW55Kn0gdGhlIGZpcnN0IHByb21pc2UgdG8gYmUgc2V0dGxlZFxuICovXG5RLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShhbnN3ZXJQcykge1xuICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24oYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG5cbiAgICBmdW5jdGlvbiBfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiID8gZnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWplY3RlZChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXhjZXB0aW9uLCBzZWxmKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ld0V4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wcm9ncmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvZ3Jlc3NlZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvZ3Jlc3NlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9mdWxmaWxsZWQodmFsdWUpKTtcbiAgICAgICAgfSwgXCJ3aGVuXCIsIFtmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9yZWplY3RlZChleGNlcHRpb24pKTtcbiAgICAgICAgfV0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvZ3Jlc3MgcHJvcGFnYXRvciBuZWVkIHRvIGJlIGF0dGFjaGVkIGluIHRoZSBjdXJyZW50IHRpY2suXG4gICAgc2VsZi5wcm9taXNlRGlzcGF0Y2godm9pZCAwLCBcIndoZW5cIiwgW3ZvaWQgMCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9wcm9ncmVzc2VkKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblEudGFwID0gZnVuY3Rpb24gKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGFwKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogV29ya3MgYWxtb3N0IGxpa2UgXCJmaW5hbGx5XCIsIGJ1dCBub3QgY2FsbGVkIGZvciByZWplY3Rpb25zLlxuICogT3JpZ2luYWwgcmVzb2x1dGlvbiB2YWx1ZSBpcyBwYXNzZWQgdGhyb3VnaCBjYWxsYmFjayB1bmFmZmVjdGVkLlxuICogQ2FsbGJhY2sgbWF5IHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGF3YWl0ZWQgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtRLlByb21pc2V9XG4gKiBAZXhhbXBsZVxuICogZG9Tb21ldGhpbmcoKVxuICogICAudGhlbiguLi4pXG4gKiAgIC50YXAoY29uc29sZS5sb2cpXG4gKiAgIC50aGVuKC4uLik7XG4gKi9cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwodmFsdWUpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIG9ic2VydmVyIG9uIGEgcHJvbWlzZS5cbiAqXG4gKiBHdWFyYW50ZWVzOlxuICpcbiAqIDEuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gKiAyLiB0aGF0IGVpdGhlciB0aGUgZnVsZmlsbGVkIGNhbGxiYWNrIG9yIHRoZSByZWplY3RlZCBjYWxsYmFjayB3aWxsIGJlXG4gKiAgICBjYWxsZWQsIGJ1dCBub3QgYm90aC5cbiAqIDMuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIG5vdCBiZSBjYWxsZWQgaW4gdGhpcyB0dXJuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSB0byBvYnNlcnZlXG4gKiBAcGFyYW0gZnVsZmlsbGVkICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiBAcGFyYW0gcmVqZWN0ZWQgICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcmVqZWN0aW9uIGV4Y2VwdGlvblxuICogQHBhcmFtIHByb2dyZXNzZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgaW52b2tlZCBjYWxsYmFja1xuICovXG5RLndoZW4gPSB3aGVuO1xuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufTtcblxuUS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IHJlYXNvbjsgfSk7XG59O1xuXG5RLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlamVjdChyZWFzb24pO1xufTtcblxuLyoqXG4gKiBJZiBhbiBvYmplY3QgaXMgbm90IGEgcHJvbWlzZSwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUuXG4gKiBJZiBhIHByb21pc2UgaXMgcmVqZWN0ZWQsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlIHRvby5cbiAqIElmIGl04oCZcyBhIGZ1bGZpbGxlZCBwcm9taXNlLCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmVhcmVyLlxuICogSWYgaXTigJlzIGEgZGVmZXJyZWQgcHJvbWlzZSBhbmQgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLCB0aGVcbiAqIHJlc29sdXRpb24gaXMgXCJuZWFyZXJcIi5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIG1vc3QgcmVzb2x2ZWQgKG5lYXJlc3QpIGZvcm0gb2YgdGhlIG9iamVjdFxuICovXG5cbi8vIFhYWCBzaG91bGQgd2UgcmUtZG8gdGhpcz9cblEubmVhcmVyID0gbmVhcmVyO1xuZnVuY3Rpb24gbmVhcmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHZhbHVlLmluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZS5cbiAqIE90aGVyd2lzZSBpdCBpcyBhIGZ1bGZpbGxlZCB2YWx1ZS5cbiAqL1xuUS5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFByb21pc2U7XG59XG5cblEuaXNQcm9taXNlQWxpa2UgPSBpc1Byb21pc2VBbGlrZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUFsaWtlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgbWVhbmluZyBub3RcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAqL1xuUS5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG5mdW5jdGlvbiBpc1BlbmRpbmcob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsdWUgb3IgZnVsZmlsbGVkXG4gKiBwcm9taXNlLlxuICovXG5RLmlzRnVsZmlsbGVkID0gaXNGdWxmaWxsZWQ7XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZChvYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUHJvbWlzZShvYmplY3QpIHx8IG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuUS5pc1JlamVjdGVkID0gaXNSZWplY3RlZDtcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn07XG5cbi8vLy8gQkVHSU4gVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vLyBUaGlzIHByb21pc2UgbGlicmFyeSBjb25zdW1lcyBleGNlcHRpb25zIHRocm93biBpbiBoYW5kbGVycyBzbyB0aGV5IGNhbiBiZVxuLy8gaGFuZGxlZCBieSBhIHN1YnNlcXVlbnQgcHJvbWlzZS4gIFRoZSBleGNlcHRpb25zIGdldCBhZGRlZCB0byB0aGlzIGFycmF5IHdoZW5cbi8vIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSBhcmUgaGFuZGxlZC4gIE5vdGUgdGhhdCBpbiBFUzYgb3Jcbi8vIHNoaW1tZWQgZW52aXJvbm1lbnRzLCB0aGlzIHdvdWxkIG5hdHVyYWxseSBiZSBhIGBTZXRgLlxudmFyIHVuaGFuZGxlZFJlYXNvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24uc3RhY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKHJlYXNvbi5zdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKFwiKG5vIHN0YWNrKSBcIiArIHJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5zcGxpY2UoYXQsIDEpO1xuICAgIH1cbn1cblxuUS5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMgPSByZXNldFVuaGFuZGxlZFJlamVjdGlvbnM7XG5cblEuZ2V0VW5oYW5kbGVkUmVhc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyB0aGF0IGNvbnN1bWVycyBjYW4ndCBpbnRlcmZlcmUgd2l0aCBvdXIgaW50ZXJuYWwgc3RhdGUuXG4gICAgcmV0dXJuIHVuaGFuZGxlZFJlYXNvbnMuc2xpY2UoKTtcbn07XG5cblEuc3RvcFVuaGFuZGxlZFJlamVjdGlvblRyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZhbHNlO1xufTtcblxucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG5cbi8vLy8gRU5EIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqIEBwYXJhbSByZWFzb24gdmFsdWUgZGVzY3JpYmluZyB0aGUgZmFpbHVyZVxuICovXG5RLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICB2YXIgcmVqZWN0aW9uID0gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGUgZXJyb3IgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdW50cmFja1JlamVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkKHJlYXNvbikgOiB0aGlzO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcInJlamVjdGVkXCIsIHJlYXNvbjogcmVhc29uIH07XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIHJlYXNvbiBoYXMgbm90IGJlZW4gaGFuZGxlZC5cbiAgICB0cmFja1JlamVjdGlvbihyZWplY3Rpb24sIHJlYXNvbik7XG5cbiAgICByZXR1cm4gcmVqZWN0aW9uO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBmdWxmaWxsZWQgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlXG4gKi9cblEuZnVsZmlsbCA9IGZ1bGZpbGw7XG5mdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBcImdldFwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInNldFwiOiBmdW5jdGlvbiAobmFtZSwgcmhzKSB7XG4gICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IHJocztcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3N0XCI6IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAvLyBNYXJrIE1pbGxlciBwcm9wb3NlcyB0aGF0IHBvc3Qgd2l0aCBubyBuYW1lIHNob3VsZCBhcHBseSBhXG4gICAgICAgICAgICAvLyBwcm9taXNlZCBmdW5jdGlvbi5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBudWxsIHx8IG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV0uYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImFwcGx5XCI6IGZ1bmN0aW9uICh0aGlzcCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXNwLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJrZXlzXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGVuYWJsZXMgdG8gUSBwcm9taXNlcy5cbiAqIEBwYXJhbSBwcm9taXNlIHRoZW5hYmxlIHByb21pc2VcbiAqIEByZXR1cm5zIGEgUSBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZShwcm9taXNlKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuLyoqXG4gKiBBbm5vdGF0ZXMgYW4gb2JqZWN0IHN1Y2ggdGhhdCBpdCB3aWxsIG5ldmVyIGJlXG4gKiB0cmFuc2ZlcnJlZCBhd2F5IGZyb20gdGhpcyBwcm9jZXNzIG92ZXIgYW55IHByb21pc2VcbiAqIGNvbW11bmljYXRpb24gY2hhbm5lbC5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIHByb21pc2UgYSB3cmFwcGluZyBvZiB0aGF0IG9iamVjdCB0aGF0XG4gKiBhZGRpdGlvbmFsbHkgcmVzcG9uZHMgdG8gdGhlIFwiaXNEZWZcIiBtZXNzYWdlXG4gKiB3aXRob3V0IGEgcmVqZWN0aW9uLlxuICovXG5RLm1hc3RlciA9IG1hc3RlcjtcbmZ1bmN0aW9uIG1hc3RlcihvYmplY3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwiaXNEZWZcIjogZnVuY3Rpb24gKCkge31cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjayhvcCwgYXJncykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncyk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUShvYmplY3QpLmluc3BlY3QoKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTcHJlYWRzIHRoZSB2YWx1ZXMgb2YgYSBwcm9taXNlZCBhcnJheSBvZiBhcmd1bWVudHMgaW50byB0aGVcbiAqIGZ1bGZpbGxtZW50IGNhbGxiYWNrLlxuICogQHBhcmFtIGZ1bGZpbGxlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHZhcmlhZGljIGFyZ3VtZW50cyBmcm9tIHRoZVxuICogcHJvbWlzZWQgYXJyYXlcbiAqIEBwYXJhbSByZWplY3RlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBleGNlcHRpb24gaWYgdGhlIHByb21pc2VcbiAqIGlzIHJlamVjdGVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9yIHRocm93biBleGNlcHRpb24gb2ZcbiAqIGVpdGhlciBjYWxsYmFjay5cbiAqL1xuUS5zcHJlYWQgPSBzcHJlYWQ7XG5mdW5jdGlvbiBzcHJlYWQodmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkuc3ByZWFkKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFsbCgpLnRoZW4oZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWQuYXBwbHkodm9pZCAwLCBhcnJheSk7XG4gICAgfSwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBUaGUgYXN5bmMgZnVuY3Rpb24gaXMgYSBkZWNvcmF0b3IgZm9yIGdlbmVyYXRvciBmdW5jdGlvbnMsIHR1cm5pbmdcbiAqIHRoZW0gaW50byBhc3luY2hyb25vdXMgZ2VuZXJhdG9ycy4gIEFsdGhvdWdoIGdlbmVyYXRvcnMgYXJlIG9ubHkgcGFydFxuICogb2YgdGhlIG5ld2VzdCBFQ01BU2NyaXB0IDYgZHJhZnRzLCB0aGlzIGNvZGUgZG9lcyBub3QgY2F1c2Ugc3ludGF4XG4gKiBlcnJvcnMgaW4gb2xkZXIgZW5naW5lcy4gIFRoaXMgY29kZSBzaG91bGQgY29udGludWUgdG8gd29yayBhbmQgd2lsbFxuICogaW4gZmFjdCBpbXByb3ZlIG92ZXIgdGltZSBhcyB0aGUgbGFuZ3VhZ2UgaW1wcm92ZXMuXG4gKlxuICogRVM2IGdlbmVyYXRvcnMgYXJlIGN1cnJlbnRseSBwYXJ0IG9mIFY4IHZlcnNpb24gMy4xOSB3aXRoIHRoZVxuICogLS1oYXJtb255LWdlbmVyYXRvcnMgcnVudGltZSBmbGFnIGVuYWJsZWQuICBTcGlkZXJNb25rZXkgaGFzIGhhZCB0aGVtXG4gKiBmb3IgbG9uZ2VyLCBidXQgdW5kZXIgYW4gb2xkZXIgUHl0aG9uLWluc3BpcmVkIGZvcm0uICBUaGlzIGZ1bmN0aW9uXG4gKiB3b3JrcyBvbiBib3RoIGtpbmRzIG9mIGdlbmVyYXRvcnMuXG4gKlxuICogRGVjb3JhdGVzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHN1Y2ggdGhhdDpcbiAqICAtIGl0IG1heSB5aWVsZCBwcm9taXNlc1xuICogIC0gZXhlY3V0aW9uIHdpbGwgY29udGludWUgd2hlbiB0aGF0IHByb21pc2UgaXMgZnVsZmlsbGVkXG4gKiAgLSB0aGUgdmFsdWUgb2YgdGhlIHlpZWxkIGV4cHJlc3Npb24gd2lsbCBiZSB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiAgLSBpdCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSAod2hlbiB0aGUgZ2VuZXJhdG9yXG4gKiAgICBzdG9wcyBpdGVyYXRpbmcpXG4gKiAgLSB0aGUgZGVjb3JhdGVkIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKiAgICBvZiB0aGUgZ2VuZXJhdG9yIG9yIHRoZSBmaXJzdCByZWplY3RlZCBwcm9taXNlIGFtb25nIHRob3NlXG4gKiAgICB5aWVsZGVkLlxuICogIC0gaWYgYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBnZW5lcmF0b3IsIGl0IHByb3BhZ2F0ZXMgdGhyb3VnaFxuICogICAgZXZlcnkgZm9sbG93aW5nIHlpZWxkIHVudGlsIGl0IGlzIGNhdWdodCwgb3IgdW50aWwgaXQgZXNjYXBlc1xuICogICAgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBhbHRvZ2V0aGVyLCBhbmQgaXMgdHJhbnNsYXRlZCBpbnRvIGFcbiAqICAgIHJlamVjdGlvbiBmb3IgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGRlY29yYXRlZCBnZW5lcmF0b3IuXG4gKi9cblEuYXN5bmMgPSBhc3luYztcbmZ1bmN0aW9uIGFzeW5jKG1ha2VHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJzZW5kXCIsIGFyZyBpcyBhIHZhbHVlXG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInRocm93XCIsIGFyZyBpcyBhbiBleGNlcHRpb25cbiAgICAgICAgZnVuY3Rpb24gY29udGludWVyKHZlcmIsIGFyZykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgLy8gVW50aWwgVjggMy4xOSAvIENocm9taXVtIDI5IGlzIHJlbGVhc2VkLCBTcGlkZXJNb25rZXkgaXMgdGhlIG9ubHlcbiAgICAgICAgICAgIC8vIGVuZ2luZSB0aGF0IGhhcyBhIGRlcGxveWVkIGJhc2Ugb2YgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBTTSdzIGdlbmVyYXRvcnMgdXNlIHRoZSBQeXRob24taW5zcGlyZWQgc2VtYW50aWNzIG9mXG4gICAgICAgICAgICAvLyBvdXRkYXRlZCBFUzYgZHJhZnRzLiAgV2Ugd291bGQgbGlrZSB0byBzdXBwb3J0IEVTNiwgYnV0IHdlJ2QgYWxzb1xuICAgICAgICAgICAgLy8gbGlrZSB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHVzZSBnZW5lcmF0b3JzIGluIGRlcGxveWVkIGJyb3dzZXJzLCBzb1xuICAgICAgICAgICAgLy8gd2UgYWxzbyBzdXBwb3J0IFB5dGhvbi1zdHlsZSBnZW5lcmF0b3JzLiAgQXQgc29tZSBwb2ludCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgICAgICAvLyB0aGlzIGJsb2NrLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIFN0b3BJdGVyYXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBFUzYgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdC52YWx1ZSwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3BpZGVyTW9ua2V5IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogUmVtb3ZlIHRoaXMgY2FzZSB3aGVuIFNNIGRvZXMgRVM2IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEoZXhjZXB0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gbWFrZUdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwibmV4dFwiKTtcbiAgICAgICAgdmFyIGVycmJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwidGhyb3dcIik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIHNwYXduIGZ1bmN0aW9uIGlzIGEgc21hbGwgd3JhcHBlciBhcm91bmQgYXN5bmMgdGhhdCBpbW1lZGlhdGVseVxuICogY2FsbHMgdGhlIGdlbmVyYXRvciBhbmQgYWxzbyBlbmRzIHRoZSBwcm9taXNlIGNoYWluLCBzbyB0aGF0IGFueVxuICogdW5oYW5kbGVkIGVycm9ycyBhcmUgdGhyb3duIGluc3RlYWQgb2YgZm9yd2FyZGVkIHRvIHRoZSBlcnJvclxuICogaGFuZGxlci4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBpdCdzIGV4dHJlbWVseSBjb21tb24gdG8gcnVuXG4gKiBnZW5lcmF0b3JzIGF0IHRoZSB0b3AtbGV2ZWwgdG8gd29yayB3aXRoIGxpYnJhcmllcy5cbiAqL1xuUS5zcGF3biA9IHNwYXduO1xuZnVuY3Rpb24gc3Bhd24obWFrZUdlbmVyYXRvcikge1xuICAgIFEuZG9uZShRLmFzeW5jKG1ha2VHZW5lcmF0b3IpKCkpO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaW50ZXJmYWNlIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbi8qKlxuICogVGhyb3dzIGEgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHRvIHN0b3AgYW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvci5cbiAqXG4gKiBUaGlzIGludGVyZmFjZSBpcyBhIHN0b3AtZ2FwIG1lYXN1cmUgdG8gc3VwcG9ydCBnZW5lcmF0b3IgcmV0dXJuXG4gKiB2YWx1ZXMgaW4gb2xkZXIgRmlyZWZveC9TcGlkZXJNb25rZXkuICBJbiBicm93c2VycyB0aGF0IHN1cHBvcnQgRVM2XG4gKiBnZW5lcmF0b3JzIGxpa2UgQ2hyb21pdW0gMjksIGp1c3QgdXNlIFwicmV0dXJuXCIgaW4geW91ciBnZW5lcmF0b3JcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHJldHVybiB2YWx1ZSBmb3IgdGhlIHN1cnJvdW5kaW5nIGdlbmVyYXRvclxuICogQHRocm93cyBSZXR1cm5WYWx1ZSBleGNlcHRpb24gd2l0aCB0aGUgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uKiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIHJldHVybiBmb28gKyBiYXI7XG4gKiB9KVxuICogLy8gT2xkZXIgU3BpZGVyTW9ua2V5IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgUS5yZXR1cm4oZm9vICsgYmFyKTtcbiAqIH0pXG4gKi9cblFbXCJyZXR1cm5cIl0gPSBfcmV0dXJuO1xuZnVuY3Rpb24gX3JldHVybih2YWx1ZSkge1xuICAgIHRocm93IG5ldyBRUmV0dXJuVmFsdWUodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBwcm9taXNlZCBmdW5jdGlvbiBkZWNvcmF0b3IgZW5zdXJlcyB0aGF0IGFueSBwcm9taXNlIGFyZ3VtZW50c1xuICogYXJlIHNldHRsZWQgYW5kIHBhc3NlZCBhcyB2YWx1ZXMgKGB0aGlzYCBpcyBhbHNvIHNldHRsZWQgYW5kIHBhc3NlZFxuICogYXMgYSB2YWx1ZSkuICBJdCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdCBvZiBhIGZ1bmN0aW9uIGlzXG4gKiBhbHdheXMgYSBwcm9taXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgYWRkID0gUS5wcm9taXNlZChmdW5jdGlvbiAoYSwgYikge1xuICogICAgIHJldHVybiBhICsgYjtcbiAqIH0pO1xuICogYWRkKFEoYSksIFEoQikpO1xuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBkZWNvcmF0ZVxuICogQHJldHVybnMge2Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW4gZGVjb3JhdGVkLlxuICovXG5RLnByb21pc2VkID0gcHJvbWlzZWQ7XG5mdW5jdGlvbiBwcm9taXNlZChjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzcHJlYWQoW3RoaXMsIGFsbChhcmd1bWVudHMpXSwgZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBzZW5kcyBhIG1lc3NhZ2UgdG8gYSB2YWx1ZSBpbiBhIGZ1dHVyZSB0dXJuXG4gKiBAcGFyYW0gb2JqZWN0KiB0aGUgcmVjaXBpZW50XG4gKiBAcGFyYW0gb3AgdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2Ugb3BlcmF0aW9uLCBlLmcuLCBcIndoZW5cIixcbiAqIEBwYXJhbSBhcmdzIGZ1cnRoZXIgYXJndW1lbnRzIHRvIGJlIGZvcndhcmRlZCB0byB0aGUgb3BlcmF0aW9uXG4gKiBAcmV0dXJucyByZXN1bHQge1Byb21pc2V9IGEgcHJvbWlzZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKi9cblEuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbmZ1bmN0aW9uIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKG9wLCBhcmdzKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAob3AsIGFyZ3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZGVmZXJyZWQucmVzb2x2ZSwgb3AsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGdldFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcHJvcGVydHkgdmFsdWVcbiAqL1xuUS5nZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciBvYmplY3Qgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0gdmFsdWUgICAgIG5ldyB2YWx1ZSBvZiBwcm9wZXJ0eVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGRlbGV0ZVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSB2YWx1ZSAgICAgYSB2YWx1ZSB0byBwb3N0LCB0eXBpY2FsbHkgYW4gYXJyYXkgb2ZcbiAqICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBhcmd1bWVudHMgZm9yIHByb21pc2VzIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgYXJlIHVsdGltYXRlbHkgYmFja2VkIHdpdGggYHJlc29sdmVgIHZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgYXMgb3Bwb3NlZCB0byB0aG9zZSBiYWNrZWQgd2l0aCBVUkxzXG4gKiAgICAgICAgICAgICAgICAgIHdoZXJlaW4gdGhlIHBvc3RlZCB2YWx1ZSBjYW4gYmUgYW55XG4gKiAgICAgICAgICAgICAgICAgIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG4vLyBib3VuZCBsb2NhbGx5IGJlY2F1c2UgaXQgaXMgdXNlZCBieSBvdGhlciBtZXRob2RzXG5RLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGludm9jYXRpb24gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblEubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMildKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUHJvbWlzZS5wcm90b3R5cGUubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSBhcmdzICAgICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmFwcGx5ID0gZnVuY3Rpb24gKG9iamVjdCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBDYWxscyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblFbXCJ0cnlcIl0gPVxuUS5mY2FsbCA9IGZ1bmN0aW9uIChvYmplY3QgLyogLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMpXSk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiwgdHJhbnNmb3JtaW5nIHJldHVybiB2YWx1ZXMgaW50byBhIGZ1bGZpbGxlZFxuICogcHJvbWlzZSBhbmQgdGhyb3duIGVycm9ycyBpbnRvIGEgcmVqZWN0ZWQgb25lLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYmluZCA9IGZ1bmN0aW9uIChvYmplY3QgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IFEob2JqZWN0KTtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5mYmluZCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIG5hbWVzIG9mIHRoZSBvd25lZCBwcm9wZXJ0aWVzIG9mIGEgcHJvbWlzZWRcbiAqIG9iamVjdCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIGtleXMgb2YgdGhlIGV2ZW50dWFsbHkgc2V0dGxlZCBvYmplY3RcbiAqL1xuUS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5LiAgSWYgYW55IG9mXG4gKiB0aGUgcHJvbWlzZXMgZ2V0cyByZWplY3RlZCwgdGhlIHdob2xlIGFycmF5IGlzIHJlamVjdGVkIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzXG4gKi9cbi8vIEJ5IE1hcmsgTWlsbGVyXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1zdHJhd21hbjpjb25jdXJyZW5jeSZyZXY9MTMwODc3NjUyMSNhbGxmdWxmaWxsZWRcblEuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICB2YXIgY291bnREb3duID0gMDtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb21pc2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9taXNlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzUHJvbWlzZShwcm9taXNlKSAmJlxuICAgICAgICAgICAgICAgIChzbmFwc2hvdCA9IHByb21pc2UuaW5zcGVjdCgpKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gc25hcHNob3QudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsrY291bnREb3duO1xuICAgICAgICAgICAgICAgIHdoZW4oXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1jb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7IGluZGV4OiBpbmRleCwgdmFsdWU6IHByb2dyZXNzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgaWYgKGNvdW50RG93biA9PT0gMCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIHRvIGJlIHNldHRsZWQsIGVpdGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiAgVGhpcyBpcyBkaXN0aW5jdCBmcm9tIGBhbGxgIHNpbmNlIHRoYXQgd291bGQgc3RvcFxuICogd2FpdGluZyBhdCB0aGUgZmlyc3QgcmVqZWN0aW9uLiAgVGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAqIGBhbGxSZXNvbHZlZGAgd2lsbCBuZXZlciBiZSByZWplY3RlZC5cbiAqIEBwYXJhbSBwcm9taXNlcyBhIHByb21pc2UgZm9yIGFuIGFycmF5IChvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcbiAqIChvciB2YWx1ZXMpXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXNcbiAqL1xuUS5hbGxSZXNvbHZlZCA9IGRlcHJlY2F0ZShhbGxSZXNvbHZlZCwgXCJhbGxSZXNvbHZlZFwiLCBcImFsbFNldHRsZWRcIik7XG5mdW5jdGlvbiBhbGxSZXNvbHZlZChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcHJvbWlzZXMgPSBhcnJheV9tYXAocHJvbWlzZXMsIFEpO1xuICAgICAgICByZXR1cm4gd2hlbihhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbFJlc29sdmVkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAc2VlIFByb21pc2UjYWxsU2V0dGxlZFxuICovXG5RLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xuICAgIHJldHVybiBRKHByb21pc2VzKS5hbGxTZXR0bGVkKCk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUShwcm9taXNlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2FyZGxlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZWdhcmRsZXNzLCByZWdhcmRsZXNzKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgZmFpbHVyZSBvZiBhIHByb21pc2UsIGdpdmluZyBhbiBvcG9ydHVuaXR5IHRvIHJlY292ZXJcbiAqIHdpdGggYSBjYWxsYmFjay4gIElmIHRoZSBnaXZlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gKiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlmIHRoZVxuICogZ2l2ZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFja1xuICovXG5RLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBsaXN0ZW5lciB0aGF0IGNhbiByZXNwb25kIHRvIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZnJvbSBhXG4gKiBwcm9taXNlJ3Mgb3JpZ2luYXRpbmcgZGVmZXJyZWQuIFRoaXMgbGlzdGVuZXIgcmVjZWl2ZXMgdGhlIGV4YWN0IGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGBgZGVmZXJyZWQubm90aWZ5YGAuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybnMgdGhlIGdpdmVuIHByb21pc2UsIHVuY2hhbmdlZFxuICovXG5RLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5mdW5jdGlvbiBwcm9ncmVzcyhvYmplY3QsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIG9ic2VydmUgdGhlIHNldHRsaW5nIG9mIGEgcHJvbWlzZSxcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBGb3J3YXJkc1xuICogdGhlIHJlc29sdXRpb24gdG8gdGhlIHJldHVybmVkIHByb21pc2Ugd2hlbiB0aGUgY2FsbGJhY2sgaXMgZG9uZS5cbiAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBjb21wbGV0aW9uLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBvYnNlcnZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlblxuICogcHJvbWlzZSwgdGFrZXMgbm8gYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSB3aGVuXG4gKiBgYGZpbmBgIGlzIGRvbmUuXG4gKi9cblEuZmluID0gLy8gWFhYIGxlZ2FjeVxuUVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdClbXCJmaW5hbGx5XCJdKGNhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZpbiA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVE9ETyBhdHRlbXB0IHRvIHJlY3ljbGUgdGhlIHJlamVjdGlvbiB3aXRoIFwidGhpc1wiLlxuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgYSBjaGFpbiBvZiBwcm9taXNlcywgZm9yY2luZyByZWplY3Rpb25zIHRvIGJlXG4gKiB0aHJvd24gYXMgZXhjZXB0aW9ucy5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBhdCB0aGUgZW5kIG9mIGEgY2hhaW4gb2YgcHJvbWlzZXNcbiAqIEByZXR1cm5zIG5vdGhpbmdcbiAqL1xuUS5kb25lID0gZnVuY3Rpb24gKG9iamVjdCwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRvbmUoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHZhciBvblVuaGFuZGxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGZvcndhcmQgdG8gYSBmdXR1cmUgdHVybiBzbyB0aGF0IGBgd2hlbmBgXG4gICAgICAgIC8vIGRvZXMgbm90IGNhdGNoIGl0IGFuZCB0dXJuIGl0IGludG8gYSByZWplY3Rpb24uXG4gICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IGBuZXh0VGlja2BpbmcgdmlhIGFuIHVubmVjZXNzYXJ5IGB3aGVuYC5cbiAgICB2YXIgcHJvbWlzZSA9IGZ1bGZpbGxlZCB8fCByZWplY3RlZCB8fCBwcm9ncmVzcyA/XG4gICAgICAgIHRoaXMudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykgOlxuICAgICAgICB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgICAgb25VbmhhbmRsZWRFcnJvciA9IHByb2Nlc3MuZG9tYWluLmJpbmQob25VbmhhbmRsZWRFcnJvcik7XG4gICAgfVxuXG4gICAgcHJvbWlzZS50aGVuKHZvaWQgMCwgb25VbmhhbmRsZWRFcnJvcik7XG59O1xuXG4vKipcbiAqIENhdXNlcyBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgaWYgaXQgZG9lcyBub3QgZ2V0IGZ1bGZpbGxlZCBiZWZvcmVcbiAqIHNvbWUgbWlsbGlzZWNvbmRzIHRpbWUgb3V0LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzIHRpbWVvdXRcbiAqIEBwYXJhbSB7QW55Kn0gY3VzdG9tIGVycm9yIG1lc3NhZ2Ugb3IgRXJyb3Igb2JqZWN0IChvcHRpb25hbClcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgaWYgaXQgaXNcbiAqIGZ1bGZpbGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAqL1xuUS50aW1lb3V0ID0gZnVuY3Rpb24gKG9iamVjdCwgbXMsIGVycm9yKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aW1lb3V0KG1zLCBlcnJvcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBlcnJvcikge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVycm9yIHx8IFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IgfHwgXCJUaW1lZCBvdXQgYWZ0ZXIgXCIgKyBtcyArIFwiIG1zXCIpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IFwiRVRJTUVET1VUXCI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICB9LCBtcyk7XG5cbiAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9LCBkZWZlcnJlZC5ub3RpZnkpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgKG9yIHByb21pc2VkIHZhbHVlKSwgc29tZVxuICogbWlsbGlzZWNvbmRzIGFmdGVyIGl0IHJlc29sdmVkLiBQYXNzZXMgcmVqZWN0aW9ucyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBhZnRlciBtaWxsaXNlY29uZHNcbiAqIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UuXG4gKiBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSByZWplY3RzLCB0aGF0IGlzIHBhc3NlZCBpbW1lZGlhdGVseS5cbiAqL1xuUS5kZWxheSA9IGZ1bmN0aW9uIChvYmplY3QsIHRpbWVvdXQpIHtcbiAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kZWxheSh0aW1lb3V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGFzIGFuIGFycmF5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogICAgICBRLm5mYXBwbHkoRlMucmVhZEZpbGUsIFtfX2ZpbGVuYW1lXSlcbiAqICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqICAgICAgfSlcbiAqXG4gKi9cblEubmZhcHBseSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgaW5kaXZpZHVhbGx5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmNhbGwoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpXG4gKiAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogfSlcbiAqXG4gKi9cblEubmZjYWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIE5vZGVKUyBjb250aW51YXRpb24gcGFzc2luZyBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbiBlcXVpdmFsZW50XG4gKiB2ZXJzaW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmJpbmQoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpKFwidXRmLThcIilcbiAqIC50aGVuKGNvbnNvbGUubG9nKVxuICogLmRvbmUoKVxuICovXG5RLm5mYmluZCA9XG5RLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIFEoY2FsbGJhY2spLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZiaW5kID1cblByb21pc2UucHJvdG90eXBlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEuZGVub2RlaWZ5LmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG5RLm5iaW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFEoYm91bmQpLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmJpbmQgPSBmdW5jdGlvbiAoLyp0aGlzcCwgLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDApO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5uYmluZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIHdpdGggYSBnaXZlbiBhcnJheSBvZiBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZCBjYWxsYmFjay5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLm5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkubnBvc3QobmFtZSwgYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLm5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzIHx8IFtdKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2ssIGZvcndhcmRpbmcgdGhlIGdpdmVuIHZhcmlhZGljIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkXG4gKiBjYWxsYmFjayBhcmd1bWVudC5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSAuLi5hcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFjayB3aWxsXG4gKiBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblEubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUS5uaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5Qcm9taXNlLnByb3RvdHlwZS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5Qcm9taXNlLnByb3RvdHlwZS5uaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogSWYgYSBmdW5jdGlvbiB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgYm90aCBOb2RlIGNvbnRpbnVhdGlvbi1wYXNzaW5nLXN0eWxlIGFuZFxuICogcHJvbWlzZS1yZXR1cm5pbmctc3R5bGUsIGl0IGNhbiBlbmQgaXRzIGludGVybmFsIHByb21pc2UgY2hhaW4gd2l0aFxuICogYG5vZGVpZnkobm9kZWJhY2spYCwgZm9yd2FyZGluZyB0aGUgb3B0aW9uYWwgbm9kZWJhY2sgYXJndW1lbnQuICBJZiB0aGUgdXNlclxuICogZWxlY3RzIHRvIHVzZSBhIG5vZGViYWNrLCB0aGUgcmVzdWx0IHdpbGwgYmUgc2VudCB0aGVyZS4gIElmIHRoZXkgZG8gbm90XG4gKiBwYXNzIGEgbm9kZWJhY2ssIHRoZXkgd2lsbCByZWNlaXZlIHRoZSByZXN1bHQgcHJvbWlzZS5cbiAqIEBwYXJhbSBvYmplY3QgYSByZXN1bHQgKG9yIGEgcHJvbWlzZSBmb3IgYSByZXN1bHQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBub2RlYmFjayBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2tcbiAqIEByZXR1cm5zIGVpdGhlciB0aGUgcHJvbWlzZSBvciBub3RoaW5nXG4gKi9cblEubm9kZWlmeSA9IG5vZGVpZnk7XG5mdW5jdGlvbiBub2RlaWZ5KG9iamVjdCwgbm9kZWJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5vZGVpZnkobm9kZWJhY2spO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrKSB7XG4gICAgaWYgKG5vZGViYWNrKSB7XG4gICAgICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG4vLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxudmFyIHFFbmRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcblxucmV0dXJuIFE7XG5cbn0pO1xuIiwiLypcbiAqIFFhbmltYXRpb25mcmFtZS5qcyAtIFByb21pc2lmaWVkIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aXRoIFFcbiAqL1xuLypqc2xpbnQgbmV3Y2FwOiB0cnVlICovXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LlFhbmltYXRpb25GcmFtZSA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KShmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIEltcG9ydCBRXG4gIHZhciBRID0gd2luZG93LlEgfHwgcmVxdWlyZShcInFcIik7XG5cbiAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsXG4gIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XG4gICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICB9O1xuICB9KSgpO1xuXG4gIC8vIFFhbmltYXRpb25GcmFtZShmOiBmdW5jdGlvbikgPT4gcHJvbWlzZSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgZlxuICAvLyAtLS1cbiAgLy9cbiAgdmFyIFFhbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGQgPSBRLmRlZmVyKCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQucmVzb2x2ZShmKCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZC5wcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBRYW5pbWF0aW9uRnJhbWU7XG59KTtcbiIsIi8vIFRoaXMgbGlicmFyeSBzdGFydGVkIGFzIGFuIGV4cGVyaW1lbnQgdG8gc2VlIGhvdyBzbWFsbCBJIGNvdWxkIG1ha2Vcbi8vIGEgZnVuY3Rpb25hbCByb3V0ZXIuIEl0IGhhcyBzaW5jZSBiZWVuIG9wdGltaXplZCAoYW5kIHRodXMgZ3Jvd24pLlxuLy8gVGhlIHJlZHVuZGFuY3kgYW5kIGluZWxlZ2FuY2UgaGVyZSBpcyBmb3IgdGhlIHNha2Ugb2YgZWl0aGVyIHNpemVcbi8vIG9yIHNwZWVkLlxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIHZhciBkZWZpbmUgPSByb290LmRlZmluZTtcblxuICBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3JsaXRlJywgW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5SbGl0ZSA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcm91dGVzID0ge30sXG4gICAgICAgIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZ1bmN0aW9uIG5vb3AocykgeyByZXR1cm4gczsgfVxuXG4gICAgZnVuY3Rpb24gc2FuaXRpemUodXJsKSB7XG4gICAgICB+dXJsLmluZGV4T2YoJy8/JykgJiYgKHVybCA9IHVybC5yZXBsYWNlKCcvPycsICc/JykpO1xuICAgICAgdXJsWzBdID09ICcvJyAmJiAodXJsID0gdXJsLnNsaWNlKDEpKTtcbiAgICAgIHVybFt1cmwubGVuZ3RoIC0gMV0gPT0gJy8nICYmICh1cmwgPSB1cmwuc2xpY2UoMCwgLTEpKTtcblxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzVXJsKHVybCwgZXNjKSB7XG4gICAgICB2YXIgcGllY2VzID0gdXJsLnNwbGl0KCcvJyksXG4gICAgICAgICAgcnVsZXMgPSByb3V0ZXMsXG4gICAgICAgICAgcGFyYW1zID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aCAmJiBydWxlczsgKytpKSB7XG4gICAgICAgIHZhciBwaWVjZSA9IGVzYyhwaWVjZXNbaV0pO1xuICAgICAgICBydWxlcyA9IHJ1bGVzW3BpZWNlLnRvTG93ZXJDYXNlKCldIHx8IHJ1bGVzWyc6J107XG4gICAgICAgIHJ1bGVzICYmIHJ1bGVzWyd+J10gJiYgKHBhcmFtc1tydWxlc1snfiddXSA9IHBpZWNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1bGVzICYmIHtcbiAgICAgICAgY2I6IHJ1bGVzWydAJ10sXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NRdWVyeSh1cmwsIGN0eCwgZXNjKSB7XG4gICAgICBpZiAodXJsICYmIGN0eC5jYikge1xuICAgICAgICB2YXIgaGFzaCA9IHVybC5pbmRleE9mKCcjJyksXG4gICAgICAgICAgICBxdWVyeSA9IChoYXNoIDwgMCA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoKSkuc3BsaXQoJyYnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIG5hbWVWYWx1ZSA9IHF1ZXJ5W2ldLnNwbGl0KCc9Jyk7XG5cbiAgICAgICAgICBjdHgucGFyYW1zW25hbWVWYWx1ZVswXV0gPSBlc2MobmFtZVZhbHVlWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb2t1cCh1cmwpIHtcbiAgICAgIHZhciBxdWVyeVNwbGl0ID0gc2FuaXRpemUodXJsKS5zcGxpdCgnPycpLFxuICAgICAgICAgIGVzYyA9IH51cmwuaW5kZXhPZignJScpID8gZGVjb2RlIDogbm9vcDtcblxuICAgICAgcmV0dXJuIHByb2Nlc3NRdWVyeShxdWVyeVNwbGl0WzFdLCBwcm9jZXNzVXJsKHF1ZXJ5U3BsaXRbMF0sIGVzYykgfHwge30sIGVzYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZDogZnVuY3Rpb24ocm91dGUsIGhhbmRsZXIpIHtcblxuICAgICAgICB2YXIgcGllY2VzID0gcm91dGUuc3BsaXQoJy8nKSxcbiAgICAgICAgICAgIHJ1bGVzID0gcm91dGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHBpZWNlID0gcGllY2VzW2ldLFxuICAgICAgICAgICAgICBuYW1lID0gcGllY2VbMF0gPT0gJzonID8gJzonIDogcGllY2UudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIHJ1bGVzID0gcnVsZXNbbmFtZV0gfHwgKHJ1bGVzW25hbWVdID0ge30pO1xuXG4gICAgICAgICAgbmFtZSA9PSAnOicgJiYgKHJ1bGVzWyd+J10gPSBwaWVjZS5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBydWxlc1snQCddID0gaGFuZGxlcjtcbiAgICAgIH0sXG5cbiAgICAgIGV4aXN0czogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gISFsb29rdXAodXJsKS5jYjtcbiAgICAgIH0sXG5cbiAgICAgIGxvb2t1cDogbG9va3VwLFxuXG4gICAgICBydW46IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbG9va3VwKHVybCk7XG5cbiAgICAgICAgcmVzdWx0LmNiICYmIHJlc3VsdC5jYih7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgcGFyYW1zOiByZXN1bHQucGFyYW1zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAhIXJlc3VsdC5jYjtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufSkpO1xuIiwiLypqc2xpbnQgb25ldmFyOnRydWUsIHVuZGVmOnRydWUsIG5ld2NhcDp0cnVlLCByZWdleHA6dHJ1ZSwgYml0d2lzZTp0cnVlLCBtYXhlcnI6NTAsIGluZGVudDo0LCB3aGl0ZTpmYWxzZSwgbm9tZW46ZmFsc2UsIHBsdXNwbHVzOmZhbHNlICovXG4vKmdsb2JhbCBkZWZpbmU6ZmFsc2UsIHJlcXVpcmU6ZmFsc2UsIGV4cG9ydHM6ZmFsc2UsIG1vZHVsZTpmYWxzZSwgc2lnbmFsczpmYWxzZSAqL1xuXG4vKiogQGxpY2Vuc2VcbiAqIEpTIFNpZ25hbHMgPGh0dHA6Ly9taWxsZXJtZWRlaXJvcy5naXRodWIuY29tL2pzLXNpZ25hbHMvPlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBBdXRob3I6IE1pbGxlciBNZWRlaXJvc1xuICogVmVyc2lvbjogMS4wLjAgLSBCdWlsZDogMjY4ICgyMDEyLzExLzI5IDA1OjQ4IFBNKVxuICovXG5cbihmdW5jdGlvbihnbG9iYWwpe1xuXG4gICAgLy8gU2lnbmFsQmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgdGhhdCByZXByZXNlbnRzIGEgYmluZGluZyBiZXR3ZWVuIGEgU2lnbmFsIGFuZCBhIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgICAqIDxiciAvPi0gPHN0cm9uZz5UaGlzIGlzIGFuIGludGVybmFsIGNvbnN0cnVjdG9yIGFuZCBzaG91bGRuJ3QgYmUgY2FsbGVkIGJ5IHJlZ3VsYXIgdXNlcnMuPC9zdHJvbmc+XG4gICAgICogPGJyIC8+LSBpbnNwaXJlZCBieSBKb2EgRWJlcnQgQVMzIFNpZ25hbEJpbmRpbmcgYW5kIFJvYmVydCBQZW5uZXIncyBTbG90IGNsYXNzZXMuXG4gICAgICogQGF1dGhvciBNaWxsZXIgTWVkZWlyb3NcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAbmFtZSBTaWduYWxCaW5kaW5nXG4gICAgICogQHBhcmFtIHtTaWduYWx9IHNpZ25hbCBSZWZlcmVuY2UgdG8gU2lnbmFsIG9iamVjdCB0aGF0IGxpc3RlbmVyIGlzIGN1cnJlbnRseSBib3VuZCB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc09uY2UgSWYgYmluZGluZyBzaG91bGQgYmUgZXhlY3V0ZWQganVzdCBvbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XSBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldIFRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuIChkZWZhdWx0ID0gMCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2lnbmFsQmluZGluZyhzaWduYWwsIGxpc3RlbmVyLCBpc09uY2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlciBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2lnbmFsLlxuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYmluZGluZyBzaG91bGQgYmUgZXhlY3V0ZWQganVzdCBvbmNlLlxuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc09uY2UgPSBpc09uY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRleHQgb24gd2hpY2ggbGlzdGVuZXIgd2lsbCBiZSBleGVjdXRlZCAob2JqZWN0IHRoYXQgc2hvdWxkIHJlcHJlc2VudCB0aGUgYHRoaXNgIHZhcmlhYmxlIGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbikuXG4gICAgICAgICAqIEBtZW1iZXJPZiBTaWduYWxCaW5kaW5nLnByb3RvdHlwZVxuICAgICAgICAgKiBAbmFtZSBjb250ZXh0XG4gICAgICAgICAqIEB0eXBlIE9iamVjdHx1bmRlZmluZWR8bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbGlzdGVuZXJDb250ZXh0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gU2lnbmFsIG9iamVjdCB0aGF0IGxpc3RlbmVyIGlzIGN1cnJlbnRseSBib3VuZCB0by5cbiAgICAgICAgICogQHR5cGUgU2lnbmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaWduYWwgPSBzaWduYWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbmVyIHByaW9yaXR5XG4gICAgICAgICAqIEB0eXBlIE51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuICAgIH1cblxuICAgIFNpZ25hbEJpbmRpbmcucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBiaW5kaW5nIGlzIGFjdGl2ZSBhbmQgc2hvdWxkIGJlIGV4ZWN1dGVkLlxuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmUgOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHBhcmFtZXRlcnMgcGFzc2VkIHRvIGxpc3RlbmVyIGR1cmluZyBgU2lnbmFsLmRpc3BhdGNoYCBhbmQgYFNpZ25hbEJpbmRpbmcuZXhlY3V0ZWAuIChjdXJyaWVkIHBhcmFtZXRlcnMpXG4gICAgICAgICAqIEB0eXBlIEFycmF5fG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBhcmFtcyA6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGwgbGlzdGVuZXIgcGFzc2luZyBhcmJpdHJhcnkgcGFyYW1ldGVycy5cbiAgICAgICAgICogPHA+SWYgYmluZGluZyB3YXMgYWRkZWQgdXNpbmcgYFNpZ25hbC5hZGRPbmNlKClgIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gc2lnbmFsIGRpc3BhdGNoIHF1ZXVlLCB0aGlzIG1ldGhvZCBpcyB1c2VkIGludGVybmFsbHkgZm9yIHRoZSBzaWduYWwgZGlzcGF0Y2guPC9wPlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFyYW1zQXJyXSBBcnJheSBvZiBwYXJhbWV0ZXJzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgbGlzdGVuZXJcbiAgICAgICAgICogQHJldHVybiB7Kn0gVmFsdWUgcmV0dXJuZWQgYnkgdGhlIGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXhlY3V0ZSA6IGZ1bmN0aW9uIChwYXJhbXNBcnIpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyUmV0dXJuLCBwYXJhbXM7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUgJiYgISF0aGlzLl9saXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMucGFyYW1zPyB0aGlzLnBhcmFtcy5jb25jYXQocGFyYW1zQXJyKSA6IHBhcmFtc0FycjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyUmV0dXJuID0gdGhpcy5fbGlzdGVuZXIuYXBwbHkodGhpcy5jb250ZXh0LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc09uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlclJldHVybjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0YWNoIGJpbmRpbmcgZnJvbSBzaWduYWwuXG4gICAgICAgICAqIC0gYWxpYXMgdG86IG15U2lnbmFsLnJlbW92ZShteUJpbmRpbmcuZ2V0TGlzdGVuZXIoKSk7XG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9IEhhbmRsZXIgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNpZ25hbCBvciBgbnVsbGAgaWYgYmluZGluZyB3YXMgcHJldmlvdXNseSBkZXRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIGRldGFjaCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQm91bmQoKT8gdGhpcy5fc2lnbmFsLnJlbW92ZSh0aGlzLl9saXN0ZW5lciwgdGhpcy5jb250ZXh0KSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBiaW5kaW5nIGlzIHN0aWxsIGJvdW5kIHRvIHRoZSBzaWduYWwgYW5kIGhhdmUgYSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGlzQm91bmQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCEhdGhpcy5fc2lnbmFsICYmICEhdGhpcy5fbGlzdGVuZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiBTaWduYWxCaW5kaW5nIHdpbGwgb25seSBiZSBleGVjdXRlZCBvbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNPbmNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzT25jZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IEhhbmRsZXIgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldExpc3RlbmVyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWx9IFNpZ25hbCB0aGF0IGxpc3RlbmVyIGlzIGN1cnJlbnRseSBib3VuZCB0by5cbiAgICAgICAgICovXG4gICAgICAgIGdldFNpZ25hbCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZGVzdHJveSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaWduYWw7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jb250ZXh0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tTaWduYWxCaW5kaW5nIGlzT25jZTonICsgdGhpcy5faXNPbmNlICsnLCBpc0JvdW5kOicrIHRoaXMuaXNCb3VuZCgpICsnLCBhY3RpdmU6JyArIHRoaXMuYWN0aXZlICsgJ10nO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbi8qZ2xvYmFsIFNpZ25hbEJpbmRpbmc6ZmFsc2UqL1xuXG4gICAgLy8gU2lnbmFsIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCBmbk5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnbGlzdGVuZXIgaXMgYSByZXF1aXJlZCBwYXJhbSBvZiB7Zm59KCkgYW5kIHNob3VsZCBiZSBhIEZ1bmN0aW9uLicucmVwbGFjZSgne2ZufScsIGZuTmFtZSkgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBldmVudCBicm9hZGNhc3RlclxuICAgICAqIDxiciAvPi0gaW5zcGlyZWQgYnkgUm9iZXJ0IFBlbm5lcidzIEFTMyBTaWduYWxzLlxuICAgICAqIEBuYW1lIFNpZ25hbFxuICAgICAqIEBhdXRob3IgTWlsbGVyIE1lZGVpcm9zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2lnbmFsKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgQXJyYXkuPFNpZ25hbEJpbmRpbmc+XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wcmV2UGFyYW1zID0gbnVsbDtcblxuICAgICAgICAvLyBlbmZvcmNlIGRpc3BhdGNoIHRvIGF3YXlzIHdvcmsgb24gc2FtZSBjb250ZXh0ICgjNDcpXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBTaWduYWwucHJvdG90eXBlLmRpc3BhdGNoLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgU2lnbmFsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2lnbmFscyBWZXJzaW9uIE51bWJlclxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqL1xuICAgICAgICBWRVJTSU9OIDogJzEuMC4wJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgU2lnbmFsIHNob3VsZCBrZWVwIHJlY29yZCBvZiBwcmV2aW91c2x5IGRpc3BhdGNoZWQgcGFyYW1ldGVycyBhbmRcbiAgICAgICAgICogYXV0b21hdGljYWxseSBleGVjdXRlIGxpc3RlbmVyIGR1cmluZyBgYWRkKClgL2BhZGRPbmNlKClgIGlmIFNpZ25hbCB3YXNcbiAgICAgICAgICogYWxyZWFkeSBkaXNwYXRjaGVkIGJlZm9yZS5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgbWVtb3JpemUgOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Nob3VsZFByb3BhZ2F0ZSA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIFNpZ25hbCBpcyBhY3RpdmUgYW5kIHNob3VsZCBicm9hZGNhc3QgZXZlbnRzLlxuICAgICAgICAgKiA8cD48c3Ryb25nPklNUE9SVEFOVDo8L3N0cm9uZz4gU2V0dGluZyB0aGlzIHByb3BlcnR5IGR1cmluZyBhIGRpc3BhdGNoIHdpbGwgb25seSBhZmZlY3QgdGhlIG5leHQgZGlzcGF0Y2gsIGlmIHlvdSB3YW50IHRvIHN0b3AgdGhlIHByb3BhZ2F0aW9uIG9mIGEgc2lnbmFsIHVzZSBgaGFsdCgpYCBpbnN0ZWFkLjwvcD5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlIDogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc09uY2VcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0ZW5lckNvbnRleHRdXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldXG4gICAgICAgICAqIEByZXR1cm4ge1NpZ25hbEJpbmRpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfcmVnaXN0ZXJMaXN0ZW5lciA6IGZ1bmN0aW9uIChsaXN0ZW5lciwgaXNPbmNlLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG5cbiAgICAgICAgICAgIHZhciBwcmV2SW5kZXggPSB0aGlzLl9pbmRleE9mTGlzdGVuZXIobGlzdGVuZXIsIGxpc3RlbmVyQ29udGV4dCksXG4gICAgICAgICAgICAgICAgYmluZGluZztcblxuICAgICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbcHJldkluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5pc09uY2UoKSAhPT0gaXNPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBhZGQnKyAoaXNPbmNlPyAnJyA6ICdPbmNlJykgKycoKSB0aGVuIGFkZCcrICghaXNPbmNlPyAnJyA6ICdPbmNlJykgKycoKSB0aGUgc2FtZSBsaXN0ZW5lciB3aXRob3V0IHJlbW92aW5nIHRoZSByZWxhdGlvbnNoaXAgZmlyc3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gbmV3IFNpZ25hbEJpbmRpbmcodGhpcywgbGlzdGVuZXIsIGlzT25jZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQmluZGluZyhiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5tZW1vcml6ZSAmJiB0aGlzLl9wcmV2UGFyYW1zKXtcbiAgICAgICAgICAgICAgICBiaW5kaW5nLmV4ZWN1dGUodGhpcy5fcHJldlBhcmFtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1NpZ25hbEJpbmRpbmd9IGJpbmRpbmdcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9hZGRCaW5kaW5nIDogZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIC8vc2ltcGxpZmllZCBpbnNlcnRpb24gc29ydFxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICBkbyB7IC0tbjsgfSB3aGlsZSAodGhpcy5fYmluZGluZ3Nbbl0gJiYgYmluZGluZy5fcHJpb3JpdHkgPD0gdGhpcy5fYmluZGluZ3Nbbl0uX3ByaW9yaXR5KTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLnNwbGljZShuICsgMSwgMCwgYmluZGluZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pbmRleE9mTGlzdGVuZXIgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fYmluZGluZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGN1cjtcbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICBjdXIgPSB0aGlzLl9iaW5kaW5nc1tuXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLl9saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiYgY3VyLmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBsaXN0ZW5lciB3YXMgYXR0YWNoZWQgdG8gU2lnbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIFNpZ25hbCBoYXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGhhcyA6IGZ1bmN0aW9uIChsaXN0ZW5lciwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lciwgY29udGV4dCkgIT09IC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgc2lnbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBTaWduYWwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0ZW5lckNvbnRleHRdIENvbnRleHQgb24gd2hpY2ggbGlzdGVuZXIgd2lsbCBiZSBleGVjdXRlZCAob2JqZWN0IHRoYXQgc2hvdWxkIHJlcHJlc2VudCB0aGUgYHRoaXNgIHZhcmlhYmxlIGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbikuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldIFRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuIExpc3RlbmVycyB3aXRoIGhpZ2hlciBwcmlvcml0eSB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBsaXN0ZW5lcnMgd2l0aCBsb3dlciBwcmlvcml0eS4gTGlzdGVuZXJzIHdpdGggc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgd2VyZSBhZGRlZC4gKGRlZmF1bHQgPSAwKVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfSBBbiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIGJldHdlZW4gdGhlIFNpZ25hbCBhbmQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBhZGQgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIsICdhZGQnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmVyLCBmYWxzZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBsaXN0ZW5lciB0byB0aGUgc2lnbmFsIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgYWZ0ZXIgZmlyc3QgZXhlY3V0aW9uICh3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgb25jZSkuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFNpZ25hbCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpc3RlbmVyQ29udGV4dF0gQ29udGV4dCBvbiB3aGljaCBsaXN0ZW5lciB3aWxsIGJlIGV4ZWN1dGVkIChvYmplY3QgdGhhdCBzaG91bGQgcmVwcmVzZW50IHRoZSBgdGhpc2AgdmFyaWFibGUgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9uKS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eV0gVGhlIHByaW9yaXR5IGxldmVsIG9mIHRoZSBldmVudCBsaXN0ZW5lci4gTGlzdGVuZXJzIHdpdGggaGlnaGVyIHByaW9yaXR5IHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIGxpc3RlbmVycyB3aXRoIGxvd2VyIHByaW9yaXR5LiBMaXN0ZW5lcnMgd2l0aCBzYW1lIHByaW9yaXR5IGxldmVsIHdpbGwgYmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgb3JkZXIgYXMgdGhleSB3ZXJlIGFkZGVkLiAoZGVmYXVsdCA9IDApXG4gICAgICAgICAqIEByZXR1cm4ge1NpZ25hbEJpbmRpbmd9IEFuIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJpbmRpbmcgYmV0d2VlbiB0aGUgU2lnbmFsIGFuZCBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGFkZE9uY2UgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIsICdhZGRPbmNlJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lciwgdHJ1ZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIHNpbmdsZSBsaXN0ZW5lciBmcm9tIHRoZSBkaXNwYXRjaCBxdWV1ZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgSGFuZGxlciBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIEV4ZWN1dGlvbiBjb250ZXh0IChzaW5jZSB5b3UgY2FuIGFkZCB0aGUgc2FtZSBoYW5kbGVyIG11bHRpcGxlIHRpbWVzIGlmIGV4ZWN1dGluZyBpbiBhIGRpZmZlcmVudCBjb250ZXh0KS5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IExpc3RlbmVyIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmUgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIsICdyZW1vdmUnKTtcblxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9pbmRleE9mTGlzdGVuZXIobGlzdGVuZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ3NbaV0uX2Rlc3Ryb3koKTsgLy9ubyByZWFzb24gdG8gYSBTaWduYWxCaW5kaW5nIGV4aXN0IGlmIGl0IGlzbid0IGF0dGFjaGVkIHRvIGEgc2lnbmFsXG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmcm9tIHRoZSBTaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVBbGwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nc1tuXS5fZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmluZGluZ3MubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoZSBTaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXROdW1MaXN0ZW5lcnMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCwgYmxvY2tpbmcgdGhlIGRpc3BhdGNoIHRvIG5leHQgbGlzdGVuZXJzIG9uIHRoZSBxdWV1ZS5cbiAgICAgICAgICogPHA+PHN0cm9uZz5JTVBPUlRBTlQ6PC9zdHJvbmc+IHNob3VsZCBiZSBjYWxsZWQgb25seSBkdXJpbmcgc2lnbmFsIGRpc3BhdGNoLCBjYWxsaW5nIGl0IGJlZm9yZS9hZnRlciBkaXNwYXRjaCB3b24ndCBhZmZlY3Qgc2lnbmFsIGJyb2FkY2FzdC48L3A+XG4gICAgICAgICAqIEBzZWUgU2lnbmFsLnByb3RvdHlwZS5kaXNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBoYWx0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc2hvdWxkUHJvcGFnYXRlID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BhdGNoL0Jyb2FkY2FzdCBTaWduYWwgdG8gYWxsIGxpc3RlbmVycyBhZGRlZCB0byB0aGUgcXVldWUuXG4gICAgICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcmFtc10gUGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gZWFjaCBoYW5kbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGF0Y2ggOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoISB0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmFtc0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgbiA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBiaW5kaW5ncztcblxuICAgICAgICAgICAgaWYgKHRoaXMubWVtb3JpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2UGFyYW1zID0gcGFyYW1zQXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISBuKSB7XG4gICAgICAgICAgICAgICAgLy9zaG91bGQgY29tZSBhZnRlciBtZW1vcml6ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncy5zbGljZSgpOyAvL2Nsb25lIGFycmF5IGluIGNhc2UgYWRkL3JlbW92ZSBpdGVtcyBkdXJpbmcgZGlzcGF0Y2hcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IHRydWU7IC8vaW4gY2FzZSBgaGFsdGAgd2FzIGNhbGxlZCBiZWZvcmUgZGlzcGF0Y2ggb3IgZHVyaW5nIHRoZSBwcmV2aW91cyBkaXNwYXRjaC5cblxuICAgICAgICAgICAgLy9leGVjdXRlIGFsbCBjYWxsYmFja3MgdW50aWwgZW5kIG9mIHRoZSBsaXN0IG9yIHVudGlsIGEgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgIG9yIHN0b3BzIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAvL3JldmVyc2UgbG9vcCBzaW5jZSBsaXN0ZW5lcnMgd2l0aCBoaWdoZXIgcHJpb3JpdHkgd2lsbCBiZSBhZGRlZCBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBkbyB7IG4tLTsgfSB3aGlsZSAoYmluZGluZ3Nbbl0gJiYgdGhpcy5fc2hvdWxkUHJvcGFnYXRlICYmIGJpbmRpbmdzW25dLmV4ZWN1dGUocGFyYW1zQXJyKSAhPT0gZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JnZXQgbWVtb3JpemVkIGFyZ3VtZW50cy5cbiAgICAgICAgICogQHNlZSBTaWduYWwubWVtb3JpemVcbiAgICAgICAgICovXG4gICAgICAgIGZvcmdldCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLl9wcmV2UGFyYW1zID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFsbCBiaW5kaW5ncyBmcm9tIHNpZ25hbCBhbmQgZGVzdHJveSBhbnkgcmVmZXJlbmNlIHRvIGV4dGVybmFsIG9iamVjdHMgKGRlc3Ryb3kgU2lnbmFsIG9iamVjdCkuXG4gICAgICAgICAqIDxwPjxzdHJvbmc+SU1QT1JUQU5UOjwvc3Ryb25nPiBjYWxsaW5nIGFueSBtZXRob2Qgb24gdGhlIHNpZ25hbCBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRpc3Bvc2Ugd2lsbCB0aHJvdyBlcnJvcnMuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmluZGluZ3M7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJldlBhcmFtcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbU2lnbmFsIGFjdGl2ZTonKyB0aGlzLmFjdGl2ZSArJyBudW1MaXN0ZW5lcnM6JysgdGhpcy5nZXROdW1MaXN0ZW5lcnMoKSArJ10nO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbiAgICAvLyBOYW1lc3BhY2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgbmFtZXNwYWNlXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBuYW1lIHNpZ25hbHNcbiAgICAgKi9cbiAgICB2YXIgc2lnbmFscyA9IFNpZ25hbDtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBldmVudCBicm9hZGNhc3RlclxuICAgICAqIEBzZWUgU2lnbmFsXG4gICAgICovXG4gICAgLy8gYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChzZWUgI2doLTQ0KVxuICAgIHNpZ25hbHMuU2lnbmFsID0gU2lnbmFsO1xuXG5cblxuICAgIC8vZXhwb3J0cyB0byBtdWx0aXBsZSBlbnZpcm9ubWVudHNcbiAgICBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpeyAvL0FNRFxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmFsczsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyl7IC8vbm9kZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHNpZ25hbHM7XG4gICAgfSBlbHNlIHsgLy9icm93c2VyXG4gICAgICAgIC8vdXNlIHN0cmluZyBiZWNhdXNlIG9mIEdvb2dsZSBjbG9zdXJlIGNvbXBpbGVyIEFEVkFOQ0VEX01PREVcbiAgICAgICAgLypqc2xpbnQgc3ViOnRydWUgKi9cbiAgICAgICAgZ2xvYmFsWydzaWduYWxzJ10gPSBzaWduYWxzO1xuICAgIH1cblxufSh0aGlzKSk7XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKS5zdHlsZSxcbiAgICBwcmVmaXhlcyA9ICdPIG1zIE1veiB3ZWJraXQnLnNwbGl0KCcgJyksXG4gICAgaGFzUHJlZml4ID0gL14ob3xtc3xtb3p8d2Via2l0KS8sXG4gICAgdXBwZXIgPSAvKFtBLVpdKS9nLFxuICAgIG1lbW8gPSB7fTtcblxuZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgcmV0dXJuIChrZXkgaW4gbWVtbykgPyBtZW1vW2tleV0gOiBtZW1vW2tleV0gPSBwcmVmaXgoa2V5KTtcbn1cblxuZnVuY3Rpb24gcHJlZml4KGtleSl7XG4gICAgdmFyIGNhcGl0YWxpemVkS2V5ID0ga2V5LnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uKHMsIG1hdGNoKXtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgaSA9IHByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgbmFtZTtcblxuICAgIGlmIChzdHlsZVtjYXBpdGFsaXplZEtleV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGNhcGl0YWxpemVkS2V5O1xuXG4gICAgY2FwaXRhbGl6ZWRLZXkgPSBjYXBpdGFsaXplKGtleSk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIG5hbWUgPSBwcmVmaXhlc1tpXSArIGNhcGl0YWxpemVkS2V5O1xuICAgICAgICBpZiAoc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gcHJlZml4ICcgKyBrZXkpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cil7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gZGFzaGVkUHJlZml4KGtleSl7XG4gICAgdmFyIHByZWZpeGVkS2V5ID0gZ2V0KGtleSksXG4gICAgICAgIHVwcGVyID0gLyhbQS1aXSkvZztcblxuICAgIGlmICh1cHBlci50ZXN0KHByZWZpeGVkS2V5KSkge1xuICAgICAgICBwcmVmaXhlZEtleSA9IChoYXNQcmVmaXgudGVzdChwcmVmaXhlZEtleSkgPyAnLScgOiAnJykgKyBwcmVmaXhlZEtleS5yZXBsYWNlKHVwcGVyLCAnLSQxJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeGVkS2V5LnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xubW9kdWxlLmV4cG9ydHMuZGFzaCA9IGRhc2hlZFByZWZpeDtcbiIsIi8vIFphbmltby5qcyAtIFByb21pc2UgYmFzZWQgQ1NTMyB0cmFuc2l0aW9uc1xuLy8gKGMpIDIwMTEtMjAxNCBQYXVsIFBhbnNlcnJpZXVcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUSA9IHJlcXVpcmUoJ3EnKSxcbiAgICBRYW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCdxYW5pbWF0aW9uZnJhbWUnKSxcbiAgICBwcmVmaXggPSByZXF1aXJlKCd2ZW5kb3ItcHJlZml4JyksXG4gICAgbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUgPSByZXF1aXJlKCcuLi9zcmMvbm9ybWFsaXplLXRyYW5zZm9ybS12YWx1ZScpLFxuICAgIHNob3J0aGFuZCA9IHJlcXVpcmUoJy4uL3NyYy90cmFuc2l0aW9uLXNob3J0aGFuZC1wcm9wZXJ0eScpLFxuICAgIHRyYW5zaXRpb24gPSBwcmVmaXgoJ3RyYW5zaXRpb24nKSxcbiAgICB0cmFuc2l0aW9uZW5kID0gJ1dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCcsXG5cbiAgICBpc0RPTSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGVsICYmIGVsLm5vZGVUeXBlO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhZGRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGVsdCwgYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGVsdC5zdHlsZVt0cmFuc2l0aW9uXTtcbiAgICAgICAgYXR0ciA9IHByZWZpeC5kYXNoKGF0dHIpO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGVbdHJhbnNpdGlvbl0gPSBjdXJyZW50VmFsdWUgKyBcIiwgXCIgKyBzaG9ydGhhbmQoYXR0ciwgZHVyYXRpb24sIGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuc3R5bGVbdHJhbnNpdGlvbl0gPSBzaG9ydGhhbmQoYXR0ciwgZHVyYXRpb24sIGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWx0LnN0eWxlW3ByZWZpeChhdHRyKV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChlbCwgYXR0cikge1xuICAgICAgICBlbC5zdHlsZVt0cmFuc2l0aW9uXSA9IGVsLnN0eWxlW3RyYW5zaXRpb25dXG4gICAgICAgICAgICAuc3BsaXQoJywnKS5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdC5tYXRjaChhdHRyKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICB9LFxuXG4gICAgYXBwbHljc3MgPSBmdW5jdGlvbiAoZWwsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBRYW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGVsLnN0eWxlW3ByZWZpeC5kYXNoKGF0dHIpXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY3NzID0gZnVuY3Rpb24gKGVsLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICBpZihlbC5femFuaW1vICYmIGVsLl96YW5pbW8uaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgIGVsLl96YW5pbW9bYXR0cl0uZGVmZXIucmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlphbmltbyB0cmFuc2l0aW9uIHdpdGggdHJhbnNmb3JtPVwiICtcbiAgICAgICAgICAgICAgICBlbC5femFuaW1vW2F0dHJdLnZhbHVlICtcbiAgICAgICAgICAgICAgICBcIiBzdG9wcGVkIGJ5IHRyYW5zZm9ybT1cIiArIHZhbHVlXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGVsLl96YW5pbW9bYXR0cl0uY2IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHljc3MoZWwsIGF0dHIsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgYW5pbWF0ZSA9IGZ1bmN0aW9uIChlbCwgYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIHByZWZpeGVkID0gcHJlZml4LmRhc2goYXR0ciksXG4gICAgICAgICAgICBkID0gUS5kZWZlcigpLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIGNiID0gZnVuY3Rpb24gKGNsZWFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHsgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyB0aW1lb3V0ID0gbnVsbDsgfVxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb24oZWwsIGF0dHIpO1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbmVuZCwgY2JUcmFuc2l0aW9uZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXIpIHsgZGVsZXRlIGVsLl96YW5pbW9bYXR0cl07IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYlRyYW5zaXRpb25lbmQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYocHJlZml4KGV2dC5wcm9wZXJ0eU5hbWUpID09PSBwcmVmaXgocHJlZml4ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uZW5kLCBjYlRyYW5zaXRpb25lbmQpO1xuXG4gICAgICAgIFFhbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uKGVsLCBhdHRyLCBub3JtYWxpemVUcmFuc2Zvcm1WYWx1ZSh2YWx1ZSksIGR1cmF0aW9uLCBlYXNpbmcpO1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByYXdWYWwgPSBlbC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByZWZpeGVkKSxcbiAgICAgICAgICAgICAgICAgICAgZG9tVmFsID0gbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUocmF3VmFsKSxcbiAgICAgICAgICAgICAgICAgICAgZ2l2ZW5WYWwgPSBub3JtYWxpemVUcmFuc2Zvcm1WYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tVmFsID09PSBnaXZlblZhbCkgeyBkLnJlc29sdmUoZWwpOyB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KCBuZXcgRXJyb3IoXCJaYW5pbW8gdHJhbnNpdGlvbjogd2l0aCBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhdHRyICsgXCIgPSBcIiArIGdpdmVuVmFsICsgXCIsIERPTSB2YWx1ZT1cIiArIGRvbVZhbFxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBkdXJhdGlvbiArIDIwICk7XG5cbiAgICAgICAgICAgIGVsLl96YW5pbW8gPSBlbC5femFuaW1vIHx8IHsgfTtcbiAgICAgICAgICAgIGlmKGVsLl96YW5pbW9bYXR0cl0pIHtcbiAgICAgICAgICAgICAgICBlbC5femFuaW1vW2F0dHJdLmRlZmVyLnJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiWmFuaW1vIHRyYW5zaXRpb24gd2l0aCBcIiArXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgKyBcIj1cIiArIGVsLl96YW5pbW9bYXR0cl0udmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICBcIiBzdG9wcGVkIGJ5IHRyYW5zaXRpb24gd2l0aCBcIiArIGF0dHIgKyBcIj1cIiArIHZhbHVlXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgZWwuX3phbmltb1thdHRyXS5jYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuX3phbmltb1thdHRyXSA9IHtjYjogY2IsIHZhbHVlOiB2YWx1ZSwgZGVmZXI6IGR9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZC5wcm9taXNlO1xuICAgIH07XG5cbi8qKlxuICogWmFuaW1vKGVsIHwgcHJvbWlzZVtlbF0pXG4gKiA+IFJldHVybnMgYSBQcm9taXNlIG9mIGVsLlxuICpcbiAqIFphbmltbyhlbCB8IHByb21pc2VbZWxdLCBhdHRyLCB2YWx1ZSlcbiAqID4gU2V0cyBlbC5zdHlsZVthdHRyXT12YWx1ZSBhbmQgcmV0dXJucyB0aGUgcHJvbWlzZSBvZiBlbC5cbiAqXG4gKiBaYW5pbW8oZWwgfCBwcm9taXNlW2VsXSwgYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBbZWFzaW5nXSlcbiAqID4gUGVyZm9ybXMgYSB0cmFuc2l0aW9uLlxuICovXG52YXIgWmFuaW1vID0gZnVuY3Rpb24gKGVsLCBhdHRyLCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZykge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBhcml0eSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGFyaXR5ID09PSAwIHx8IGFyaXR5ID09PSAyIHx8IGFyaXR5ID4gNSkge1xuICAgICAgICByZXR1cm4gUS5yZWplY3QobmV3IEVycm9yKFwiWmFuaW1vIGludmFsaWQgYXJndW1lbnRzXCIpKTtcbiAgICB9XG4gICAgaWYgKFEuaXNQcm9taXNlKGVsKSkge1xuICAgICAgICByZXR1cm4gZWwudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gWmFuaW1vLmFwcGx5KHRoaXMsIFt2YWxdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0RPTShlbCkpIHtcbiAgICAgICAgcmV0dXJuIFEucmVqZWN0KG5ldyBFcnJvcihcIlphbmltbyByZXF1aXJlIGFuIEhUTUxFbGVtZW50LCBvciBhIHByb21pc2Ugb2YgYW4gSFRNTEVsZW1lbnRcIikpO1xuICAgIH1cbiAgICBpZiAoYXJpdHkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFEoZWwpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBwcmVmaXguZGFzaChhdHRyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUS5yZWplY3QobmV3IEVycm9yKFwiWmFuaW1vIHRyYW5zaXRpb246IFwiICsgYXR0ciArICcgaXMgbm90IHN1cHBvcnRlZCEnKSk7XG4gICAgfTtcbiAgICBpZiAoYXJpdHkgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGNzcyhlbCwgYXR0ciwgdmFsdWUpO1xuICAgIH1cbiAgICBpZih3aW5kb3cuaXNOYU4ocGFyc2VJbnQoZHVyYXRpb24sIDEwKSkpIHtcbiAgICAgICAgcmV0dXJuIFEucmVqZWN0KG5ldyBFcnJvcihcIlphbmltbyB0cmFuc2l0aW9uOiBkdXJhdGlvbiBtdXN0IGJlIGFuIGludGVnZXIhXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGUoZWwsIGF0dHIsIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nKTtcbn07XG5cbi8qKlxuICogQSBmdW5jdGlvbiB3cmFwcGluZyBgWmFuaW1vKGVsLCAuLi4pYCBhcyBhIGBmKC4uLikoZWwpYCBmb3IgZWFzeSBjaGFpbmluZyBwdXJwb3NlLlxuICovXG5aYW5pbW8uZiA9IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBaYW5pbW8uYXBwbHkodGhpcywgW2VsXS5jb25jYXQoYXJncykpO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFphbmltbztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGNoUGFyZW50aGVzaXMgPSAvKFxcKC4rP1xcKSkvZyxcbiAgICBzcGFjZSA9IC8gKy9nLFxuICAgIGVtcHR5U3RyaW5nID0gXCJcIixcbiAgICB3aGl0ZXNwYWNlID0gXCIgXCIsXG5cbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5zdWJzdHIoMSwgbWF0Y2gubGVuZ3RoLTIpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICAgIHJzdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhcmcucmVwbGFjZShzcGFjZSwgZW1wdHlTdHJpbmcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gXCIoXCIgKyByc3Quam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuICB0eXBlb2YgdCA9PT0gJ3N0cmluZycgPyB0LnJlcGxhY2Uoc3BhY2UsIHdoaXRlc3BhY2UpLnJlcGxhY2UobWF0Y2hQYXJlbnRoZXNpcywgbm9ybWFsaXplKSA6IHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sb3IgPSByZXF1aXJlKCdjb2xvcicpLFxuICAgIG1hdGNoUGFyZW50aGVzaXMgPSAvKFxcKC4rP1xcKSkvZyxcbiAgICBtYXRjaENvbG9ycyA9IC8oXFxicmdiYVxcYnxcXGJoc2xcXGJ8XFxiaHNsYVxcYikoXFwoLis/XFwpKS9nLFxuICAgIHNwYWNlID0gLyArL2csXG4gICAgZW1wdHlTdHJpbmcgPSBcIlwiLFxuICAgIHdoaXRlc3BhY2UgPSBcIiBcIixcbiAgICB6ZXJvcGl4ZWwgPSAvXjBweCQvZyxcbiAgICB6ZXJvID0gXCIwXCIsXG5cbiAgICBub3JtQXJncyA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICB2YXIgYXJncyA9IG1hdGNoLnN1YnN0cigxLCBtYXRjaC5sZW5ndGgtMikuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgcnN0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcucmVwbGFjZShzcGFjZSwgZW1wdHlTdHJpbmcpLnJlcGxhY2UoemVyb3BpeGVsLCB6ZXJvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gXCIoXCIgKyByc3Quam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9LFxuXG4gICAgbm9ybUNvbG9ycyA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICB2YXIgYyA9IENvbG9yKG1hdGNoKTtcbiAgICAgICAgaWYgKGMuYWxwaGEoKSApIHsgYy5hbHBoYShNYXRoLnJvdW5kKGMuYWxwaGEoKSAqIDEwKSAvIDEwKTsgfVxuICAgICAgICByZXR1cm4gYy5yZ2JTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2Uoc3BhY2UsIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICAucmVwbGFjZShtYXRjaENvbG9ycywgbm9ybUNvbG9ycylcbiAgICAgICAgICAgIC5yZXBsYWNlKG1hdGNoUGFyZW50aGVzaXMsIG5vcm1BcmdzKTtcbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZW1wdHlTdHJpbmc7XG4gICAgcmV0dXJuIHdpbmRvdy5pc05hTih2YWwpID8gbm9ybWFsaXplKHZhbCkgOiB2YWwudG9TdHJpbmcoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwcmVmaXggPSByZXF1aXJlKCd2ZW5kb3ItcHJlZml4JyksXG4gICAgbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZS10cmFuc2Zvcm0tdmFsdWUnKSxcbiAgICBub3JtYWxpemVUaW1pbmdGdW5jdGlvbiA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXRpbWluZy1mdW5jdGlvbicpLFxuICAgIHRyYW5zaXRpb24gPSBwcmVmaXguZGFzaCgndHJhbnNpdGlvbicpLFxuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgdGVzdCA9ICdvcGFjaXR5IDEwMG1zIGxpbmVhciAwcycsXG4gICAgbm9ybWFsaXplZFRlc3QgPSBub3JtYWxpemVUcmFuc2Zvcm1WYWx1ZSh0ZXN0KSxcbiAgICBzaG9ydGhhbmQgPSBmdW5jdGlvbiBzaG9ydGhhbmQodiwgZCwgdCkge1xuICAgICAgICByZXR1cm4gdiArIFwiIFwiICsgZCArIFwibXMgXCIgKyAodCB8fCBcImxpbmVhclwiKTtcbiAgICB9O1xuXG5lbC5zdHlsZVt0cmFuc2l0aW9uXSA9IG5vcm1hbGl6ZWRUZXN0O1xuXG5pZihub3JtYWxpemVUcmFuc2Zvcm1WYWx1ZShlbC5zdHlsZVt0cmFuc2l0aW9uXSkgPT09IG5vcm1hbGl6ZWRUZXN0KSB7XG4gICAgc2hvcnRoYW5kID0gZnVuY3Rpb24gKHYsIGQsIHQpIHtcbiAgICAgICAgcmV0dXJuIHYgKyBcIiBcIiArIGQgKyBcIm1zIFwiICsgKG5vcm1hbGl6ZVRpbWluZ0Z1bmN0aW9uKHQpIHx8IFwibGluZWFyXCIpICsgXCIgMHNcIjtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0aGFuZDtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJ2xvZGFzaC9pc0Z1bmN0aW9uJztcbmltcG9ydCBpMThuIGZyb20gJy4vaTE4bic7XG5pbXBvcnQgeyBiYWNrSGlzdG9yeSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmNvbnN0IHN0YWNrID0gW107XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhY2tidXR0b24oKSB7XG4gIHZhciBiID0gc3RhY2sucG9wKCk7XG4gIGlmIChpc0Z1bmN0aW9uKGIpKSB7XG4gICAgYignYmFja2J1dHRvbicpO1xuICAgIG0ucmVkcmF3KCk7XG4gIH0gZWxzZSBpZiAoIS9eXFwvJC8udGVzdChtLnJvdXRlKCkpKSB7XG4gICAgLy8gaWYgcGxheWluZyBhIGdhbWUgYXMgYW5vbiBhc2sgZm9yIGNvbmZpcm1hdGlvblxuICAgIGlmICgvXlxcL2dhbWVcXC9bYS16QS1aMC05XXsxMn0vLnRlc3QobS5yb3V0ZSgpKSkge1xuICAgICAgbmF2aWdhdG9yLm5vdGlmaWNhdGlvbi5jb25maXJtKFxuICAgICAgICBpMThuKCd0aGVyZUlzQUdhbWVJblByb2dyZXNzJyksXG4gICAgICAgIGkgPT4geyBpZiAoaT09PTEpIGJhY2tIaXN0b3J5KCk7IH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2tIaXN0b3J5KCk7XG4gICAgfVxuICB9ZWxzZSB7XG4gICAgd2luZG93Lm5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICB9XG59O1xuXG5iYWNrYnV0dG9uLnN0YWNrID0gc3RhY2s7XG4iLCJjb25zdCBkZWZhdWx0cyA9IHtcbiAgYXBpVmVyc2lvbjogMSxcbiAgZmV0Y2hUaW1lb3V0TXM6IDEwMDAwXG59O1xuXG5jb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgd2luZG93Lm95dW5rZXlmKTtcblxuZXhwb3J0IGRlZmF1bHQgY29uZmlnO1xuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5pbXBvcnQgc3Bpbm5lciBmcm9tICcuL3NwaW5uZXInO1xuaW1wb3J0IGdsb2JhbENvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBidWlsZFF1ZXJ5U3RyaW5nIH0gZnJvbSAnLi91dGlscy9xdWVyeXN0cmluZyc7XG5pbXBvcnQgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UnO1xuXG5leHBvcnQgY29uc3QgU0VTU0lPTl9JRF9LRVkgPSAnc2Vzc2lvbklkJztcblxuY29uc3QgYmFzZVVybCA9IGdsb2JhbENvbmZpZy5hcGlFbmRQb2ludDtcblxuZnVuY3Rpb24gYWRkUXVlcnlTdHJpbmcodXJsLCBxdWVyeVN0cmluZykge1xuICBjb25zdCBwcmVmaXggPSB1cmwuaW5kZXhPZignPycpIDwgMCA/ICc/JyA6ICcmJztcbiAgbGV0IHJlcyA9IHVybCArIHByZWZpeCArIHF1ZXJ5U3RyaW5nO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0KHVybCwgdHlwZSwgb3B0cywgZmVlZGJhY2spIHtcblxuICBsZXQgdGltZW91dElkO1xuXG4gIGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgaWYgKGZlZWRiYWNrKSBzcGlubmVyLnN0b3AoKTtcbiAgfVxuXG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcob3B0cy5xdWVyeSk7XG4gICAgaWYgKHF1ZXJ5ICE9PSAnJykge1xuICAgICAgdXJsID0gYWRkUXVlcnlTdHJpbmcodXJsLCBxdWVyeSk7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRzLnF1ZXJ5O1xuICB9XG4gIFxuICBjb25zdCBjZmcgPSB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL3ZuZC5veXVua2V5Zi52JyArIGdsb2JhbENvbmZpZy5hcGlWZXJzaW9uICsgJytqc29uJ1xuICAgIH1cbiAgfTtcblxuICBtZXJnZShjZmcsIG9wdHMpO1xuXG4gIGNvbnN0IGluaXQgPSB7XG4gICAgLi4uY2ZnLFxuICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoY2ZnLmhlYWRlcnMpXG4gIH07XG5cbiAgaWYgKChpbml0Lm1ldGhvZCA9PT0gJ1BPU1QnIHx8IGluaXQubWV0aG9kID09PSAnUFVUJykgJiZcbiAgICAgICFpbml0LmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkge1xuICAgIChpbml0LmhlYWRlcnMpLmFwcGVuZCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnKTtcbiAgICBpZiAoIWluaXQuYm9keSl7XG4gICAgICBpbml0LmJvZHkgPSAne30nO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNpZCA9IHN0b3JhZ2UuZ2V0KFNFU1NJT05fSURfS0VZKTtcbiAgaWYgKHNpZCAhPT0gbnVsbCkge1xuICAgIGluaXQuaGVhZGVycy5hcHBlbmQoU0VTU0lPTl9JRF9LRVksIHNpZCk7XG4gIH1cblxuICBjb25zdCBmdWxsVXJsID0gdXJsLmluZGV4T2YoJ2h0dHAnKSA+IC0xID8gdXJsIDogYmFzZVVybCArIHVybDtcblxuICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0JykpLFxuICAgICAgZ2xvYmFsQ29uZmlnLmZldGNoVGltZW91dE1zXG4gICAgKTtcbiAgfSk7XG5cbiAgY29uc3QgcmVzcE9yVGltZW91dCA9IFByb21pc2UucmFjZShbXG4gICAgZmV0Y2goZnVsbFVybCwgaW5pdCksXG4gICAgdGltZW91dFByb21pc2VcbiAgXSk7XG5cbiAgaWYgKGZlZWRiYWNrKSB7XG4gICAgc3Bpbm5lci5zcGluKCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc3BPclRpbWVvdXRcbiAgICAgIC50aGVuKChyKSA9PiB7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgaWYgKHIub2spIHtcbiAgICAgICAgICByZXNvbHZlKHJbdHlwZV0oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgci50ZXh0KClcbiAgICAgICAgICAgIC50aGVuKChib2R5VGV4dCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXM6IHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5wYXJzZShib2R5VGV4dClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXM6IHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgYm9keTogci5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgIGJvZHk6IGVyci5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hKU09OKHVybCwgb3B0cywgZmVlZGJhY2sgPSBmYWxzZSkge1xuICByZXR1cm4gcmVxdWVzdCh1cmwsICdqc29uJywgb3B0cywgZmVlZGJhY2spO1xufVxuXG5leHBvcnQgY29uc3QgYXBpVmVyc2lvbiA9IDE7XG5cbi8vIGNvbnN0IGJhc2VVcmwgPSB3aW5kb3cub3l1bmtleWYuYXBpRW5kUG9pbnQ7XG5cbmZ1bmN0aW9uIG9uU3VjY2VzcyhkYXRhKSB7XG4gIHNwaW5uZXIuc3RvcCgpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gb25FcnJvcihkYXRhKSB7XG4gIHNwaW5uZXIuc3RvcCgpO1xuICB0aHJvdyBkYXRhO1xufVxuXG5mdW5jdGlvbiB4aHJDb25maWcoeGhyKSB7XG4gIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vdm5kLm95dW5rZXlmLnYnICsgYXBpVmVyc2lvbiArICcranNvbicpO1xuICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgeGhyLnRpbWVvdXQgPSA4MDAwO1xufVxuXG4vLyBjb252ZW5pZW50IHdyYXBwZXIgYXJvdW5kIG0ucmVxdWVzdFxuLy8gZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRzLCBmZWVkYmFjaywgeGhyQ29uZikge1xuLy8gICB2YXIgY2ZnID0ge1xuLy8gICAgIHVybDogYmFzZVVybCArIHVybCxcbi8vICAgICBtZXRob2Q6ICdHRVQnLFxuLy8gICAgIGRhdGE6IHsgfSxcbi8vICAgICBjb25maWc6IHhockNvbmYgfHwgeGhyQ29uZmlnLFxuLy8gICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbih0ZXh0KSB7XG4vLyAgICAgICB0cnkge1xuLy8gICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbi8vICAgICAgIH0gY2F0Y2ggKGUpIHtcbi8vICAgICAgICAgdGhyb3cgeyByZXNwb25zZTogeyBlcnJvcjogJ0Nhbm5vdCByZWFkIGRhdGEgZnJvbSB0aGUgc2VydmVyJyB9fTtcbi8vICAgICAgIH1cbi8vICAgICB9LFxuLy8gICAgIHVud3JhcEVycm9yOiBmdW5jdGlvbihyZXNwb25zZSwgeGhyKSB7XG4vLyAgICAgICByZXR1cm4geyByZXNwb25zZSwgc3RhdHVzOiB4aHIuc3RhdHVzIH07XG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICBtZXJnZShjZmcsIG9wdHMpO1xuXG4vLyAgIGlmIChjZmcubWV0aG9kID09PSAnR0VUJykge1xuLy8gICAgIGNmZy5kYXRhLl8gPSBEYXRlLm5vdygpO1xuLy8gICB9XG5cbi8vICAgdmFyIHByb21pc2UgPSBtLnJlcXVlc3QoY2ZnKTtcblxuLy8gICBpZiAoZmVlZGJhY2spIHtcbi8vICAgICBzcGlubmVyLnNwaW4oZG9jdW1lbnQuYm9keSk7XG4vLyAgICAgcmV0dXJuIHByb21pc2UudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuLy8gICB9IGVsc2Uge1xuLy8gICAgIHJldHVybiBwcm9taXNlO1xuLy8gICB9XG4vLyB9IFxuIiwiaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgbG9hZExvY2FsSnNvbkZpbGUgfSBmcm9tICcuL3V0aWxzJztcblxuXG5jb25zdCBkZWZhdWx0Q29kZSA9ICd0cic7XG5cbmxldCBsYW5nID0gZGVmYXVsdENvZGU7XG5sZXQgbWVzc2FnZXMgPSB7fTtcblxuY29uc3QgdW50cmFuc2xhdGVkID0ge1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmcoKSB7XG4gIHJldHVybiBsYW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpMThuKGtleSwgLi4uYXJncykge1xuICB2YXIgc3RyID0gbWVzc2FnZXNba2V5XSB8fCB1bnRyYW5zbGF0ZWRba2V5XXx8IGtleTtcbiAgYXJncy5mb3JFYWNoKGEgPT4geyBzdHIgPSBzdHIucmVwbGFjZSgnJXMnLCBTdHJpbmcoYSkpOyB9KTtcbiAgXG4gIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUHJlZmVycmVkTGFuZ3VhZ2UoKSB7XG4gIGNvbnN0IGZyb21TZXR0aW5ncyA9IHNldHRpbmdzLmdlbmVyYWwubGFuZygpO1xuICBpZiAoZnJvbVNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGxvYWRMYW5ndWFnZShmcm9tU2V0dGluZ3MpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbi5nZXRQcmVmZXJyZWRMYW5ndWFnZShcbiAgICAgIGwgPT4gcmVzb2x2ZShsLnZhbHVlLnNwbGl0KCctJylbMF0pLFxuICAgICAgKCkgPT4gcmVzb2x2ZShkZWZhdWx0Q29kZSlcbiAgICApO1xuICB9KS50aGVuKChjb2RlKSA9PiB7XG4gICAgc2V0dGluZ3MuZ2VuZXJhbC5sYW5nKGNvZGUpO1xuICAgIHJldHVybiBjb2RlO1xuICB9KS50aGVuKGxvYWRGaWxlKVxuICAgIC50aGVuKGxvYWRNb21lbnRMb2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZExhbmd1YWdlKGxhbmcpIHtcbiAgcmV0dXJuIGxvYWRGaWxlKGxhbmcpXG4gICAgLnRoZW4obG9hZE1vbWVudExvY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRGaWxlKGNvZGUpIHtcbiAgcmV0dXJuIGxvYWRMb2NhbEpzb25GaWxlKCdpMThuLycgKyBjb2RlICsgJy5qc29uJylcbiAgICAudGhlbihkYXRhID0+IHtcbiAgICAgIGxhbmcgPSBjb2RlO1xuICAgICAgbWVzc2FnZXMgPSBkYXRhO1xuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgaWYgKGNvZGUgPT09IGRlZmF1bHRDb2RlKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGxvYWRGaWxlKGRlZmF1bHRDb2RlKTtcbiAgICB9KTtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGdldEF2YWlsYWJsZUxhbmd1YWdlcygpIHtcbi8vICAgcmV0dXJuIG0ucmVxdWVzdCh7XG4vLyAgICAgdXJsOiAnaTE4bi9yZWZzLmpzb24nLFxuLy8gICAgIG1ldGhvZDogJ0dFVCdcbi8vICAgfSkudGhlbihkYXRhID0+IHsgcmV0dXJuIGRhdGE7IH0sIGVycm9yID0+IHtcbi8vICAgICAvLyBzYW1lIHdvcmthcm91bmQgZm9yIGlPUyBhcyBhYm92ZVxuLy8gICAgIGlmIChlcnJvciAmJiBlcnJvclswXVswXSA9PT0gJ3RyJylcbi8vICAgICAgIHJldHVybiBlcnJvcjtcbi8vICAgICBlbHNlXG4vLyAgICAgICB0aHJvdyB7IGVycm9yOiAnQ2Fubm90IGxvYWQgbGFuZ3VhZ2VzJyB9O1xuLy8gICB9KTtcbi8vIH1cblxuXG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBsb2FkRnJvbVNldHRpbmdzKCkge1xuLy8gICByZXR1cm4gbG9hZEZpbGUoc2V0dGluZ3MuZ2VuZXJhbC5sYW5nKCkpLnRoZW4obG9hZE1vbWVudExvY2FsZSk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGxvYWRGaWxlKGNvZGUpIHtcbi8vICAgcmV0dXJuIG0ucmVxdWVzdCh7XG4vLyAgICAgdXJsOiAnaTE4bi8nICsgY29kZSArICcuanNvbicsXG4vLyAgICAgbWV0aG9kOiAnR0VUJyxcbi8vICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24odGV4dCkge1xuLy8gICAgICAgdHJ5IHtcbi8vICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4vLyAgICAgICB9IGNhdGNoIChlKSB7XG4vLyAgICAgICAgIHRocm93IHsgZXJyb3I6ICdMYW5nIG5vdCBhdmFpbGFibGUnIH07XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbi8vICAgICBtZXNzYWdlcyA9IGRhdGE7XG4vLyAgICAgcmV0dXJuIGNvZGU7XG4vLyAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4vLyAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaU9TOiBiZWNhdXNlIHhociBmb3IgbG9jYWwgZmlsZSBoYXMgYSAwIHN0YXR1cyBpdCB3aWxsXG4vLyAgICAgLy8gcmVqZWN0IHRoZSBwcm9taXNlIGFuZCBzdGlsbCBoYXZlIHRoZSByZXNwb25zZSBvYmplY3Rcbi8vICAgICBpZiAoZXJyb3IgJiYgZXJyb3IucGxheVdpdGhBRnJpZW5kKSB7XG4vLyAgICAgICBtZXNzYWdlcyA9IGVycm9yO1xuLy8gICAgICAgcmV0dXJuIGNvZGU7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIGlmIChjb2RlID09PSBkZWZhdWx0Q29kZSkgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbi8vICAgICAgIHJldHVybiBsb2FkRmlsZShkZWZhdWx0Q29kZSk7XG4vLyAgICAgfVxuLy8gICB9KTtcbi8vIH1cblxuZnVuY3Rpb24gbG9hZE1vbWVudExvY2FsZShjb2RlKSB7XG4gIGlmIChjb2RlICE9PSAnZW4nKSB7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSAnbW9tZW50L2xvY2FsZS8nICsgY29kZSArICcuanMnO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB3aW5kb3cubW9tZW50LmxvY2FsZShjb2RlKTtcbiAgcmV0dXJuIGNvZGU7XG59XG5cbiIsIi8qIGFwcGxpY2F0aW9uIGVudHJ5IHBvaW50ICovXG5cbi8vIGltcG9ydCAnLi9wb2x5ZmlsbHMnO1xuXG5cbi8vIGZvciBtb21lbnQgYSBnbG9iYWwgb2JqZWN0IG1ha2VzIGxvYWRpbmcgbG9jYWxlcyBlYXNpZXJcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbndpbmRvdy5tb21lbnQgPSBtb21lbnQ7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi9zZXNzaW9uJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgbG9hZFByZWZlcnJlZExhbmd1YWdlLCBlbnN1cmVMYW5nSXNBdmFpbGFibGUsIGxvYWRMYW5ndWFnZSB9IGZyb20gJy4vaTE4bic7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi94aHInO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4vdWkvaGVscGVyJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4vYmFja2J1dHRvbic7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4vc29ja2V0JztcbmltcG9ydCByb3V0ZXMgZnJvbSAnLi9yb3V0ZXMnO1xuaW1wb3J0IHsgaXNGb3JlZ3JvdW5kLCBzZXRGb3JlZ3JvdW5kLCBzZXRCYWNrZ3JvdW5kIH0gZnJvbSAnLi91dGlscy9hcHBNb2RlJztcblxubGV0IGZpcnN0Q29ubmVjdGlvbiA9IHRydWU7XG5cbmZ1bmN0aW9uIG1haW4oKSB7XG4gIHJvdXRlcy5pbml0KCk7XG4gIC8vIGNhY2hlIHZpZXdwb3J0IGRpbXNcbiAgaGVscGVyLnZpZXdwb3J0RGltKCk7XG5cbiAgLy8gcHVsbCBzZXNzaW9uIGRhdGEgb25jZSAodG8gbG9nIGluIHVzZXIgYXV0b21hdGljYWxseSB0aGFua3MgdG8gY29va2llKVxuICAvLyBhbmQgYWxzbyBsaXN0ZW4gdG8gb25saW5lIGV2ZW50IGluIGNhc2UgbmV0d29yayB3YXMgZGlzY29ubmVjdGVkIGF0IGFwcFxuICAvLyBzdGFydHVwXG4gIGlmICh1dGlscy5oYXNOZXR3b3JrKCkpIHtcbiAgICBvbk9ubGluZSgpO1xuICB9XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgb25PbmxpbmUsIGZhbHNlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIG9uT2ZmbGluZSwgZmFsc2UpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXN1bWUnLCBvblJlc3VtZSwgZmFsc2UpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIG9uUGF1c2UsIGZhbHNlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGJhY2tidXR0b24sIGZhbHNlKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgc29ja2V0LnRlcm1pbmF0ZSgpO1xuICB9KTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCBmYWxzZSk7XG5cbiAgaWYgKGNvcmRvdmEucGxhdGZvcm1JZCA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgd2luZG93LlN0YXR1c0Jhci5iYWNrZ3JvdW5kQ29sb3JCeUhleFN0cmluZygnIzE1MUExRScpO1xuICB9XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cubmF2aWdhdG9yLnNwbGFzaHNjcmVlbi5oaWRlKCk7XG4gICAgd2luZG93LlN0YXR1c0Jhci5oaWRlKCk7XG4gICAgLy8geGhyU3RhdHVzKCk7XG4gIH0sIDUwMCk7XG59XG5cbmZ1bmN0aW9uIG9uT25saW5lKCkge1xuICBpZiAoaXNGb3JlZ3JvdW5kKCkpIHtcbiAgICBpZiAoZmlyc3RDb25uZWN0aW9uKSB7XG4gICAgICBmaXJzdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIC8vIHhoci5zdGF0dXMoKTtcbiAgICAgIFxuICAgICAgc2Vzc2lvbi5yZW1lbWJlckxvZ2luKClcbiAgICAgICAgLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBzZXJ2ZXJMYW5nID0gdXNlci5sYW5ndWFnZSAmJiB1c2VyLmxhbmd1YWdlLnNwbGl0KCctJylbMF07XG4gICAgICAgICAgaWYgKHNlcnZlckxhbmcpIHtcbiAgICAgICAgICAgIGVuc3VyZUxhbmdJc0F2YWlsYWJsZShzZXJ2ZXJMYW5nKVxuICAgICAgICAgICAgICAudGhlbihsYW5nID0+IHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLmxhbmcobGFuZyk7XG4gICAgICAgICAgICAgICAgbG9hZExhbmd1YWdlKGxhbmcpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdGVkIGFzIGFub255bW91cycpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIHNlc3Npb24ucmVmcmVzaCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbk9mZmxpbmUoKSB7XG4gIGlmIChpc0ZvcmVncm91bmQoKSAmJiAhaGFzTmV0d29yaygpKSB7XG4gICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICByZWRyYXcoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgaGVscGVyLmNsZWFyQ2FjaGVkVmlld3BvcnREaW0oKTtcbiAgcmVkcmF3KCk7XG59XG5cbmZ1bmN0aW9uIG9uUmVzdW1lKCkge1xuICBzZXRGb3JlZ3JvdW5kKCk7XG4gIHNlc3Npb24ucmVmcmVzaCgpO1xuICBzb2NrZXQuY29ubmVjdCgpO1xuICByZWRyYXcoKTtcbn1cblxuZnVuY3Rpb24gb25QYXVzZSgpIHtcbiAgc2V0QmFja2dyb3VuZCgpO1xuICBzb2NrZXQuZGlzY29ubmVjdCgpO1xufVxuXG4vLyBmdW5jdGlvbiBoYW5kbGVFcnJvcihldmVudCwgc291cmNlLCBmaWxlbm8sIGNvbHVtTnVtYmVyKSB7XG4vLyAgIHZhciBkZXNjcmlwdGlvbiA9IGV2ZW50ICsgJyBhdCAnICsgc291cmNlICsgJyBbJyArIGZpbGVubyArICcsICcgKyBjb2x1bU51bWJlciArICddJztcbi8vIH1cblxuLy8gd2luZG93Lm9uZXJyb3IgPSBoYW5kbGVFcnJvcjtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiBsb2FkUHJlZmVycmVkTGFuZ3VhZ2UoKS50aGVuKG1haW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcbmltcG9ydCBzdGF0dXMgZnJvbSAnLi9zdGF0dXMnO1xuXG5mdW5jdGlvbiBwbGF5YWJsZShkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkIDwgc3RhdHVzLmlkcy5hYm9ydGVkO1xufVxuXG5mdW5jdGlvbiBpc1BsYXllclBsYXlpbmcoZGF0YSkge1xuICByZXR1cm4gcGxheWFibGUoZGF0YSkgJiYgIWRhdGEucGxheWVyLnNwZWN0YXRvcjtcbn1cblxuZnVuY3Rpb24gaXNQbGF5ZXJUdXJuKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxheWVyUGxheWluZyhkYXRhKSAmJiBkYXRhLmdhbWUucGxheWVyID09PSBkYXRhLnBsYXllci5zaWRlO1xufVxuXG5mdW5jdGlvbiBnZXRQbGF5ZXIoZGF0YSwgc2lkZSkge1xuICByZXR1cm4gWydwbGF5ZXInLCAnb3Bwb25lbnRMZWZ0JywgJ29wcG9uZW50UmlnaHQnLCAnb3Bwb25lbnRVcCddXG4gICAgLm1hcChrID0+IGRhdGFba10pXG4gICAgLmZpbHRlcihwbGF5ZXIgPT4gcGxheWVyLnNpZGUgPT09IHNpZGUpWzBdO1xufVxuXG5mdW5jdGlvbiByZXN1bHQoZGF0YSkge1xuICBpZiAoc3RhdHVzLmFib3J0ZWQoZGF0YSkpIHtcbiAgICByZXR1cm4gaTE4bignZ2FtZUFib3J0ZWQnKTtcbiAgfSBlbHNlIGlmIChzdGF0dXMuZmluaXNoZWQoZGF0YSkpIHtcbiAgICByZXR1cm4gaTE4bignZ2FtZUZpbmlzaGVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IHNpZGVzID0gW1wiZWFzdFwiLCBcIm5vcnRoXCIsIFwid2VzdFwiLCBcInNvdXRoXCJdO1xuXG5mdW5jdGlvbiBzaWRlQnlQbHkocGx5KSB7XG4gIHJldHVybiBzaWRlc1twbHkgJSA0XTtcbn1cblxuZnVuY3Rpb24gc2V0T25HYW1lKGRhdGEsIHNpZGUsIG9uR2FtZSkge1xuICB2YXIgcGxheWVyID0gZ2V0UGxheWVyKGRhdGEsIHNpZGUpO1xuICBwbGF5ZXIub25HYW1lID0gb25HYW1lO1xufVxuXG4vLyBmdW5jdGlvbiByb3VuZHNPclNjb3JlcyhnYW1lKSB7XG4vLyAgIGlmIChnYW1lLnJvdW5kcykge1xuLy8gICAgIHJldHVybiBkYXRhLlxuLy8gICB9IGVsc2UgaWYgKGRhdGEuc2NvcmVzKSB7XG4gICAgXG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgcmV0dXJuICcnO1xuLy8gICB9XG4vLyB9XG5cbmZ1bmN0aW9uIHRpdGxlKGRhdGEpIHtcbiAgdmFyIHRleHQ7XG4gIGlmIChpc1BsYXllclR1cm4oZGF0YSkpIHtcbiAgICB0ZXh0ID0gaTE4bigneW91clR1cm4nKTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0ID0gaTE4bignd2FpdGluZ0Zvck9wcG9uZW50Jyk7XG4gIH1cbiAgLy8gY29uc3QgdmFyaWFudCA9IGdldFZhcmlhbnQoZGF0YS5nYW1lLnZhcmlhbnQua2V5KTtcbiAgLy8gY29uc3QgbmFtZSA9IHZhcmlhbnQgPyAodmFyaWFudC5zaG9ydE5hbWUgfHwgdmFyaWFudC5uYW1lKSA6ICcnO1xuICByZXR1cm4gdGV4dDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc1BsYXllclBsYXlpbmcsXG4gIGlzUGxheWVyVHVybixcbiAgZ2V0UGxheWVyLFxuICBzaWRlQnlQbHksXG4gIHBsYXlhYmxlLFxuICBzZXRPbkdhbWUsXG4gIHRpdGxlLFxuICByZXN1bHRcbn07XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcblxuZXhwb3J0IGZ1bmN0aW9uIHBsYXllck5hbWUocGxheWVyKSB7XG4gIGlmIChwbGF5ZXIubmFtZSB8fCBwbGF5ZXIudXNlcm5hbWUgfHwgcGxheWVyLnVzZXIpIHtcbiAgICBsZXQgbmFtZSA9IHBsYXllci5uYW1lIHx8IHBsYXllci51c2VybmFtZSB8fCBwbGF5ZXIudXNlci51c2VybmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBpZiAocGxheWVyLmFpKSB7XG4gICAgcmV0dXJuIGFpTmFtZShwbGF5ZXIpO1xuICB9XG4gIHJldHVybiAnQW5vbnltb3VzJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFpTmFtZShwbGF5ZXIpIHtcbiAgcmV0dXJuIGkxOG4oJ2FpQm90JywgMSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaHVtYW5TZXR1cEZyb21TZXR0aW5ncyhzZXR0aW5nc09iaikge1xuICByZXR1cm4ge1xuICAgIG1vZGU6IHNldHRpbmdzT2JqLm1vZGUoKSxcbiAgICB2YXJpYW50OiBzZXR0aW5nc09iai52YXJpYW50KCksXG4gICAgcm91bmRzOiBzZXR0aW5nc09iai5yb3VuZHMoKVxuICB9O1xufVxuIiwiLy8gc2NhbGFva2V5L3NyYy9tYWluL3NjYWxhL1N0YXR1cy5zY2FsYVxuXG5pbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcblxuY29uc3QgaWRzID0ge1xuICBjcmVhdGVkOiAxMCxcbiAgc3RhcnRlZDogMjAsXG4gIGFib3J0ZWQ6IDI1LFxuICBtaWRkbGVFbmQ6IDMwLFxuICBub3JtYWxFbmQ6IDQwLFxuICB2YXJpYW50RW5kOiA3MFxufTtcblxuZnVuY3Rpb24gc3RhcnRlZChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkID49IGlkcy5zdGFydGVkO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hlZChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkID49IGlkcy5taWRkbGVFbmQ7XG59XG5cbmZ1bmN0aW9uIGFib3J0ZWQoZGF0YSkge1xuICByZXR1cm4gZGF0YS5nYW1lLnN0YXR1cy5pZCA9PT0gaWRzLmFib3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1pZGRsZUVuZChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkID09PSBpZHMubWlkZGxlRW5kO1xufVxuXG5cbmZ1bmN0aW9uIHBsYXlpbmcoZGF0YSkge1xuICByZXR1cm4gc3RhcnRlZChkYXRhKSAmJiAhZmluaXNoZWQoZGF0YSkgJiYgIWFib3J0ZWQoZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHRvTGFiZWwoc3RhdHVzLCB3aW5uZXIsIHZhcmlhbnQpIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgY2FzZSAnc3RhcnRlZCc6XG4gICAgcmV0dXJuIGkxOG4oJ3BsYXlpbmdSaWdodE5vdycpO1xuICBjYXNlICdhYm9ydGVkJzpcbiAgICByZXR1cm4gaTE4bignZ2FtZUFib3J0ZWQnKTtcbiAgY2FzZSAnbWlkZGxlRW5kJzpcbiAgICByZXR1cm4gaTE4bignZ2FtZU1pZGRsZUZpbmlzaGVkJyk7XG4gIGNhc2UgJ25vcm1hbEVuZCc6XG4gICAgcmV0dXJuIGkxOG4oJ2dhbWVGaW5pc2hlZCcpO1xuICBjYXNlICd2YXJpYW50RW5kJzpcbiAgICByZXR1cm4gaTE4bignZ2FtZUZpbmlzaGVkJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWRzLFxuICBzdGFydGVkLFxuICBmaW5pc2hlZCxcbiAgYWJvcnRlZCxcbiAgcGxheWluZyxcbiAgbWlkZGxlRW5kLFxuICB0b0xhYmVsXG59O1xuIiwiaW1wb3J0IFJsaXRlIGZyb20gJ3JsaXRlLXJvdXRlcic7XG5pbXBvcnQgKiBhcyBSZW5kZXJTZXJ2aWNlIGZyb20gJ21pdGhyaWwvcmVuZGVyJztcbmltcG9ydCBWbm9kZSBmcm9tICdtaXRocmlsL3JlbmRlci92bm9kZSc7XG5pbXBvcnQgc2lnbmFscyBmcm9tICcuL3NpZ25hbHMnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuL3V0aWxzL3JlZHJhdyc7XG5cbmNvbnN0IHJvdXRlciA9IG5ldyBSbGl0ZSgpO1xuXG5sZXQgY3VycmVudFN0YXRlSWQgPSAwO1xubGV0IHZpZXdTbGlkZURpcmVjdGlvbiA9ICdmd2QnO1xuXG5sZXQgcHJldmlvdXNQYXRoID0gJy8nO1xuXG5jb25zdCB1aWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiAoKSA9PiBpZCsrO1xufSkoKTtcblxuY29uc3QgYmFja2J1dHRvbiA9ICgoKSA9PiB7XG4gIGNvbnN0IHggPSAoKSA9PiB7XG5cbiAgICBjb25zdCBiID0gKHguc3RhY2subGVuZ3RoID09PSAwKSA/bnVsbDp4LnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oYikpIHtcbiAgICAgIGIoJ2JhY2tidXR0b24nKTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH0gZWxzZSBpZiAoIS9eXFwvJC8udGVzdChnZXQoKSkpIHtcbiAgICAgIGJhY2tIaXN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgICB9XG4gICAgXG4gIH07XG5cbiAgeC5zdGFjayA9IFtdO1xuICBcbiAgcmV0dXJuIHg7XG59KSgpO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUm91dGVzKG1vdW50UG9pbnQsIHJvdXRlcykge1xuXG4gIGZvciAobGV0IHJvdXRlIGluIHJvdXRlcykge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlc1tyb3V0ZV07XG4gICAgcm91dGVyLmFkZChyb3V0ZSwgZnVuY3Rpb24gb25Sb3V0ZU1hdGNoKHsgcGFyYW1zIH0pIHtcbiAgICAgIGNvbnN0IFJvdXRlQ29tcG9uZW50ID0geyB2aWV3KCkge1xuICAgICAgICB2YXIgbm9kZSA9IFZub2RlKGNvbXBvbmVudCwgdW5kZWZpbmVkLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH19O1xuXG4gICAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgIFJlbmRlclNlcnZpY2UucmVuZGVyKG1vdW50UG9pbnQsIFZub2RlKFJvdXRlQ29tcG9uZW50KSk7XG4gICAgICB9XG5cbiAgICAgIHNpZ25hbHMucmVkcmF3LnJlbW92ZUFsbCgpO1xuICAgICAgc2lnbmFscy5yZWRyYXcuYWRkKHJlZHJhdyk7XG4gICAgICB0cnkge1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2lnbmFscy5yZWRyYXcucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgcHJvY2Vzc1F1ZXJ5c3RyaW5nKTtcbiAgcHJvY2Vzc1F1ZXJ5c3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NRdWVyeXN0cmluZyhlKSB7XG4gIGlmIChlICYmIGUuc3RhdGUpIHtcbiAgICBpZiAoZS5zdGF0ZS5pZCA8IGN1cnJlbnRTdGF0ZUlkKSB7XG4gICAgICB2aWV3U2xpZGVEaXJlY3Rpb24gPSAnYndkJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld1NsaWRlRGlyZWN0aW9uID0gJ2Z3ZCc7XG4gICAgfVxuICAgIGN1cnJlbnRTdGF0ZUlkID0gZS5zdGF0ZS5pZDtcbiAgfVxuICBwcmV2aW91c1BhdGggPSBnZXQoKTtcbiAgY29uc3QgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8ICc/PSc7XG4gIGNvbnN0IG1hdGNoZWQgPSByb3V0ZXIucnVuKHFzLnNsaWNlKDIpKTtcbiAgaWYgKCFtYXRjaGVkKSByb3V0ZXIucnVuKCcvJyk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnblN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZSA/XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgc3RhdGUpIDpcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zdGF0ZTtcblxuICAgIGlmIChwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShuZXdTdGF0ZSwgJycsICc/PScgKyBwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG5ld1N0YXRlLCAnJyk7XG4gICAgfVxuICB9IGNhdGNoKGUpIHsgY29uc29sZS5lcnJvcihlKTsgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlUGF0aChwYXRoKSB7XG4gIGFzc2lnblN0YXRlKHVuZGVmaW5lZCwgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGRvU2V0KHBhdGgsIHJlcGxhY2UgPSBmYWxzZSkge1xuICBiYWNrYnV0dG9uLnN0YWNrID0gW107XG4gIHByZXZpb3VzUGF0aCA9IGdldCgpO1xuICBpZiAocmVwbGFjZSkge1xuICAgIHJlcGxhY2VQYXRoKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0YXRlSWQgPSB1aWQoKTtcbiAgICBjdXJyZW50U3RhdGVJZCA9IHN0YXRlSWQ7XG4gICAgdmlld1NsaWRlRGlyZWN0aW9uID0gJ2Z3ZCc7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7IGlkOiBzdGF0ZUlkIH0sICcnLCAnPz0nICsgcGF0aCk7XG4gICAgfSBjYXRjaCAoZSkgeyBjb25zb2xlLmVycm9yKGUpOyB9XG4gIH1cbiAgY29uc3QgbWF0Y2hlZCA9IHJvdXRlci5ydW4ocGF0aCk7XG4gIGlmICghbWF0Y2hlZCkgcm91dGVyLnJ1bignLycpO1xufVxuXG5mdW5jdGlvbiBzZXQocGF0aCwgcmVwbGFjZSA9IGZhbHNlKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4gZG9TZXQocGF0aCwgcmVwbGFjZSksIDApO1xufVxuXG5mdW5jdGlvbiBnZXQoKSB7XG4gIGNvbnN0IHBhdGggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8ICc/PS8nO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhdGguc3Vic3RyaW5nKDIpKTtcbn1cblxuZnVuY3Rpb24gYmFja0hpc3RvcnkoKSB7XG4gIHdpbmRvdy5oaXN0b3J5LmdvKC0xKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXQsXG4gIHNldCxcbiAgYmFja2J1dHRvbixcbiAgYmFja0hpc3Rvcnlcbn07XG4iLCJpbXBvcnQgaG9tZSBmcm9tICcuL3VpL2hvbWUnO1xuaW1wb3J0IGdhbWUgZnJvbSAnLi91aS9nYW1lJztcbmltcG9ydCB1c2VyIGZyb20gJy4vdWkvdXNlcic7XG5pbXBvcnQgcGxheWVycyBmcm9tICcuL3VpL3BsYXllcnMnO1xuaW1wb3J0IG1hc2FEZXRhaWwgZnJvbSAnLi91aS9tYXNhL2RldGFpbCc7XG5pbXBvcnQgbWFzYSBmcm9tICcuL3VpL21hc2EnO1xuaW1wb3J0IHNldHRpbmdzVWkgZnJvbSAnLi91aS9zZXR0aW5ncyc7XG5pbXBvcnQgc2V0dGluZ3NMYW5nIGZyb20gJy4vdWkvc2V0dGluZ3MvbGFuZyc7XG5pbXBvcnQgeyBkZWZpbmVSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCgpIHtcbiAgICBkZWZpbmVSb3V0ZXMoZG9jdW1lbnQuYm9keSwge1xuICAgICAgJyc6IGhvbWUsXG4gICAgICAnQC86aWQnOiB1c2VyLFxuICAgICAgJ3BsYXllcnMnOiBwbGF5ZXJzLFxuICAgICAgJ2dhbWUvOmlkJzogZ2FtZSxcbiAgICAgICdtYXNhLzptYXNhSWQvZ2FtZS86aWQnOiBnYW1lLFxuICAgICAgJ21hc2FzJzogbWFzYSxcbiAgICAgICdtYXNhLzppZCc6IG1hc2FEZXRhaWwsXG4gICAgICAnc2V0dGluZ3MnOiBzZXR0aW5nc1VpLFxuICAgICAgJ3NldHRpbmdzL2xhbmcnOiBzZXR0aW5nc0xhbmcsXG4gICAgfSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBTRVNTSU9OX0lEX0tFWSwgZmV0Y2hKU09OIH0gZnJvbSAnLi9odHRwJztcbmltcG9ydCB7IGhhc05ldHdvcmssIGhhbmRsZVhockVycm9yIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgaTE4biBmcm9tICcuL2kxOG4nO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UnO1xuXG5sZXQgc2Vzc2lvbjtcblxuZnVuY3Rpb24gaXNDb25uZWN0ZWQoKSB7XG4gIHJldHVybiBzZXNzaW9uICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFNlc3Npb24oKSB7XG4gIHJldHVybiBzZXNzaW9uO1xufVxuXG5mdW5jdGlvbiBpc1Nlc3Npb24oZGF0YSkge1xuICByZXR1cm4gZGF0YS5pZCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzdG9yZVNlc3Npb24oZCkge1xuICBcbn1cblxuZnVuY3Rpb24gbG9naW4odXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9sb2dpbicsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB1c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkXG4gICAgfSlcbiAgfSwgdHJ1ZSlcbiAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGlzU2Vzc2lvbihkYXRhKSkge1xuICAgICAgICBzZXNzaW9uID0gZGF0YTtcbiAgICAgICAgaWYgKHNlc3Npb24uc2Vzc2lvbklkKSB7XG4gICAgICAgICAgc3RvcmFnZS5zZXQoU0VTU0lPTl9JRF9LRVksIHNlc3Npb24uc2Vzc2lvbklkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdG9yZVNlc3Npb24oZGF0YSk7XG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzaWdudXAodXNlcm5hbWUsIGVtYWlsLCBwYXNzd29yZCkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvc2lnbnVwJywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgZW1haWwsXG4gICAgICBwYXNzd29yZFxuICAgIH0pXG4gIH0sIHRydWUpXG4gICAgLnRoZW4oZCA9PiB7XG4gICAgICBpZiAoaXNTZXNzaW9uKGQpKSB7XG4gICAgICAgIHNlc3Npb24gPSBkO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zZXNzaW9uSWQpIHtcbiAgICAgICAgICBzdG9yYWdlLnNldChTRVNTSU9OX0lEX0tFWSwgc2Vzc2lvbi5zZXNzaW9uSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtZW1iZXJMb2dpbigpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL2FjY291bnQvaW5mbycpXG4gICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHNlc3Npb24gPSBkYXRhO1xuICAgICAgc3RvcmVTZXNzaW9uKGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9hY2NvdW50L2luZm8nLCB7IGNhY2hlOiAncmVsb2FkJyB9KVxuICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICBzZXNzaW9uID0gZGF0YTtcbiAgICAgIHN0b3JlU2Vzc2lvbihkYXRhKTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChzZXNzaW9uICE9PSB1bmRlZmluZWQgJiYgZXJyLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgIHNlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIG9uTG9nb3V0KCk7XG4gICAgICAgIHJlZHJhdygpO1xuICAgICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ3NpZ25lZE91dCcpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uTG9nb3V0KCkge1xuICBzdG9yYWdlLnJlbW92ZShTRVNTSU9OX0lEX0tFWSk7XG4gIHNpZ25hbHMuYWZ0ZXJMb2dvdXQuZGlzcGF0Y2goKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0Nvbm5lY3RlZCxcbiAgc2lnbnVwLFxuICBsb2dpbjogdGhyb3R0bGUobG9naW4sIDEwMDApLFxuICByZW1lbWJlckxvZ2luOiB0aHJvdHRsZShyZW1lbWJlckxvZ2luLCAxMDAwKSxcbiAgZ2V0OiBnZXRTZXNzaW9uLFxuICByZWZyZXNoOiB0aHJvdHRsZShyZWZyZXNoLCAxMDAwKVxufTtcblxuXG4iLCJpbXBvcnQgc3RvcmUgZnJvbSAnLi9zdG9yYWdlJztcbmltcG9ydCByYW5nZSBmcm9tICdsb2Rhc2gvcmFuZ2UnO1xuXG5mdW5jdGlvbiB0dXBsZU9mKHgpIHtcbiAgcmV0dXJuIFt4LnRvU3RyaW5nKCksIHgudG9TdHJpbmcoKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2VuZXJhbDoge1xuICAgIGxhbmc6IHN0b3JlLnByb3AoJ3NldHRpbmdzLmxhbmcnLCBudWxsKSxcbiAgICB0aGVtZToge1xuICAgICAgYmFja2dyb3VuZDogc3RvcmUucHJvcCgnc2V0dGluZ3MuYmdUaGVtZScsICdkYXJrJylcbiAgICB9XG4gIH0sXG4gIGdhbWU6IHtcbiAgICBzdXBwb3J0ZWRWYXJpYW50czogWydzdGFuZGFyZCcsICd5dXpiaXInLCAnZHV6b2tleSddXG4gIH0sXG4gIGdhbWVTZXR1cDoge1xuICAgIGF2YWlsYWJsZVJvdW5kczogWzEsIDUsIDEwLCAxNSwgMjAsIDI1LCAzMF0ubWFwKHR1cGxlT2YpLFxuICAgIGlzUm91bmRWYWxpZDogZnVuY3Rpb24oZ2FtZVNldHRpbmdzKSB7XG4gICAgICByZXR1cm4gZ2FtZVNldHRpbmdzLnJvdW5kcygpICE9PSAnMCc7XG4gICAgfSxcbiAgICBodW1hbjoge1xuICAgICAgYXZhaWxhYmxlVmFyaWFudHM6IFtcbiAgICAgICAgWycxMDEgT2tleScsICcxJ10sXG4gICAgICAgIFsnRMO8eiBPa2V5JywgJzMnXVxuICAgICAgXSxcbiAgICAgIHZhcmlhbnQ6IHN0b3JlLnByb3AoJ3NldHRpbmdzLmdhbWUuaHVtYW4udmFyaWFudCcsICcxJyksXG4gICAgICByb3VuZHM6IHN0b3JlLnByb3AoJ3NldHRpbmdzLmdhbWUuaHVtYW4ucm91bmRzJywgJzEnKSxcbiAgICAgIG1vZGU6IHN0b3JlLnByb3AoJ3NldHRpbmdzLmdhbWUuaHVtYW4ubW9kZScsICcwJyksXG4gICAgICBtZW1iZXJzT25seTogc3RvcmUucHJvcCgnc2V0dGluZ3MuZ2FtZS5odW1hbi5tZW1iZXJzT25seScsIGZhbHNlKVxuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ3NpZ25hbHMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICByZWRyYXc6IG5ldyBTaWduYWwoKSxcblxuICBhZnRlckxvZ2luOiBuZXcgU2lnbmFsKCksXG5cbiAgYWZ0ZXJMb2dvdXQ6IG5ldyBTaWduYWwoKSxcblxuICBzZXNzaW9uUmVzdG9yZWQ6IG5ldyBTaWduYWwoKVxuXG59O1xuIiwiaW1wb3J0IGdsb2JhbENvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZSc7XG5pbXBvcnQgeyBTRVNTSU9OX0lEX0tFWSB9IGZyb20gJy4vaHR0cCc7XG5pbXBvcnQgeyBuZXdTcmksIGF1dG9yZWRyYXcsIGhhc05ldHdvcmsgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGFza1dvcmtlciwgdGVsbFdvcmtlciB9IGZyb20gJy4vdXRpbHMvd29ya2VyJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4vc2Vzc2lvbic7XG5cblxuZnVuY3Rpb24gc2V0dXBDb25uZWN0aW9uKHNldHVwLCBzb2NrZXRIYW5kbGVycykge1xuICBjb25zdCBzaWQgPSBzdG9yYWdlLmdldChTRVNTSU9OX0lEX0tFWSk7XG4gIGlmIChzaWQgIT09IG51bGwpIHtcbiAgICBpZiAoc2V0dXAub3B0cy5wYXJhbXMpIHtcbiAgICAgIHNldHVwLm9wdHMucGFyYW1zW1NFU1NJT05fSURfS0VZXSA9IHNpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dXAub3B0cy5wYXJhbXMgPSB7XG4gICAgICAgIFtTRVNTSU9OX0lEX0tFWV06IHNpZFxuICAgICAgfTsgICAgICAgXG4gICAgfVxuICB9IGVsc2UgaWYgKHNldHVwLm9wdHMucGFyYW1zKSB7XG4gICAgZGVsZXRlIHNldHVwLm9wdHMucGFyYW1zLnNlc3Npb25JZDtcbiAgfVxuICBzZXR1cC5vcHRzLm9wdGlvbnMuaXNBdXRoID0gISFzaWQ7XG4gIHdvcmtlci5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cuZGF0YS50b3BpYykge1xuICAgIGNhc2UgJ29uT3Blbic6XG4gICAgICBpZiAoc29ja2V0SGFuZGxlcnMub25PcGVuKSBzb2NrZXRIYW5kbGVycy5vbk9wZW4oKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICBvbkRpc2Nvbm5lY3RlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgIG9uQ29ubmVjdGVkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvbkVycm9yJzpcbiAgICAgIGlmIChzb2NrZXRIYW5kbGVycy5vbkVycm9yKSBzb2NrZXRIYW5kbGVycy5vbkVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdoYW5kbGUnOlxuICAgICAgbGV0IGggPSBzb2NrZXRIYW5kbGVycy5ldmVudHNbbXNnLmRhdGEucGF5bG9hZC50XTtcbiAgICAgIGlmIChoKSBoKG1zZy5kYXRhLnBheWxvYWQuZCwgbXNnLmRhdGEucGF5bG9hZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgdGVsbFdvcmtlcih3b3JrZXIsICdjcmVhdGUnLCBzZXR1cCk7XG59XG5cbmZ1bmN0aW9uIG9uQ29ubmVjdGVkKCkge1xuICBpZiAoIWNvbm5lY3RlZFdTKSB7XG4gICAgY29ubmVjdGVkV1MgPSB0cnVlO1xuICAgIHJlZHJhdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uRGlzY29ubmVjdGVkKCkge1xuICBpZiAoY29ubmVjdGVkV1MpIHtcbiAgICBjb25uZWN0ZWRXUyA9IGZhbHNlO1xuICAgIHJlZHJhdygpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVjb25uZWN0Q3VycmVudCgpIHtcbiAgXG59XG5cbmxldCBjb25uZWN0ZWRXUyA9IGZhbHNlO1xuXG5jb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKCdsaWIvc29ja2V0V29ya2VyLmpzJyk7XG5jb25zdCBkZWZhdWx0SGFuZGxlcnMgPSB7XG4gIFxufTtcblxuZnVuY3Rpb24gY3JlYXRlTG9iYnkobmFtZSwgb25PcGVuLCBoYW5kbGVycykge1xuICBjb25zdCBzb2NrZXRIYW5kbGVycyA9IHtcbiAgICBvbk9wZW46ICgpID0+IHtcbiAgICAgIHNlc3Npb24ucmVmcmVzaCgpO1xuICAgICAgb25PcGVuKCk7XG4gICAgfSxcbiAgICBldmVudHM6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIYW5kbGVycywgaGFuZGxlcnMpXG4gIH07XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgbmFtZSxcbiAgICAgIGRlYnVnOiBnbG9iYWxDb25maWcubW9kZSA9PT0gJ2RldicsXG4gICAgICBwaW5nRGVsYXk6IDIwMDAsXG4gICAgICBzZW5kT25PcGVuOiBbXSxcbiAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldHVwID0ge1xuICAgIGNsaWVudElkOiBuZXdTcmkoKSxcbiAgICBzb2NrZXRFbmRQb2ludDogZ2xvYmFsQ29uZmlnLnNvY2tldEVuZFBvaW50LFxuICAgIHVybDogYC9sb2JieS9zb2NrZXQvdiR7Z2xvYmFsQ29uZmlnLmFwaVZlcnNpb259YCxcbiAgICBvcHRzXG4gIH07XG4gIHNldHVwQ29ubmVjdGlvbihzZXR1cCwgc29ja2V0SGFuZGxlcnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXNhKG1hc2FJZCwgdmVyc2lvbiwgaGFuZGxlcnMpIHtcbiAgbGV0IHVybCA9ICcvbWFzYS8nICsgbWFzYUlkICsgYC9zb2NrZXQvdiR7Z2xvYmFsQ29uZmlnLmFwaVZlcnNpb259YDtcbiAgY29uc3Qgc29ja2V0SGFuZGxlcnMgPSB7XG4gICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGFuZGxlcnMsIGhhbmRsZXJzKSxcbiAgICBvbk9wZW46IHNlc3Npb24uYmFja2dyb3VuZFJlZnJlc2hcbiAgfTtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBuYW1lOiAnbWFzYScsXG4gICAgICBkZWJ1ZzogZ2xvYmFsQ29uZmlnLm1vZGUgPT09ICdkZXYnLFxuICAgICAgcGluZ0RlbGF5OiAyMDAwLFxuICAgICAgcmVnaXN0ZXJlZEV2ZW50czogT2JqZWN0LmtleXMoc29ja2V0SGFuZGxlcnMuZXZlbnRzKVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXAgPSB7XG4gICAgY2xpZW50SWQ6IG5ld1NyaSgpLFxuICAgIHNvY2tldEVuZFBvaW50OiBnbG9iYWxDb25maWcuc29ja2V0RW5kUG9pbnQsXG4gICAgdXJsLFxuICAgIHZlcnNpb24sXG4gICAgb3B0c1xuICB9O1xuICBzZXR1cENvbm5lY3Rpb24oc2V0dXAsIHNvY2tldEhhbmRsZXJzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBjcmVhdGVMb2JieSxcbiAgY3JlYXRlTWFzYSxcbiAgcmVjb25uZWN0Q3VycmVudCxcbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIGNvbm5lY3RlZFdTO1xuICB9LFxuICBjb25uZWN0KCkge1xuICAgIHRlbGxXb3JrZXIod29ya2VyLCAnY29ubmVjdCcpO1xuICB9LFxuICBkZXN0cm95KCkge1xuICAgIHRlbGxXb3JrZXIod29ya2VyLCAnZGVzdHJveScpO1xuICB9XG59O1xuXG5cbi8vLyBPTERcblxuXG4vLyBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKCdsaWIvc29ja2V0V29ya2VyLmpzJyk7XG5cbi8vIGxldCBzb2NrZXRIYW5kbGVycztcbi8vIGxldCBlcnJvckRldGVjdGVkID0gZmFsc2U7XG4vLyBsZXQgY29ubmVjdGVkV1MgPSB0cnVlO1xuXG4vLyBsZXQgYWxyZWFkeVdhcm5lZCA9IGZhbHNlO1xuLy8gbGV0IHJlZHJhd09uRGlzY29ubmVjdGVkVGltZW91dElEO1xuLy8gbGV0IHByb3h5RmFpbFRpbWVvdXRJRDtcbi8vIGNvbnN0IHByb3h5RmFpbE1zZyA9IFwiT3l1bmtleWYgc3VudWN1bGFyxLFuYSBiYcSfbGFudMSxIGtvcHR1LiBQcm9ibGVtIHPDvHJla2xpIHlhxZ9hbsSxeW9yc2EgcHJveHkgeWFkYSBuZXR3b3JrJ2xhIGlsZ2lsaSBvbGFiaWxpci5cIjtcblxuLy8gY29uc3QgZGVmYXVsdEhhbmRsZXJzID0ge1xuLy8gfTtcblxuLy8gZnVuY3Rpb24gY3JlYXRlR2FtZSh1cmwsIHZlcnNpb24sIGhhbmRsZXJzLCBnYW1lVXJsKSB7XG4vLyAgIGVycm9yRGV0ZWN0ZWQgPSBmYWxzZTtcbi8vICAgc29ja2V0SGFuZGxlcnMgPSB7XG4vLyAgICAgb25FcnJvcjogZnVuY3Rpb24oKSB7XG4vLyAgICAgICAvLyB3ZSBjYW4ndCBnZXQgc29ja2V0IGVycm9yLCBzbyB3ZSBzZW5kIGFuIHhociB0byB0ZXN0IHdoZXRoZXIgdGhlXG4vLyAgICAgICAvLyByZWplY3Rpb24gaXMgYW4gYXV0aG9yaXphdGlvbiBpc3N1ZVxuLy8gICAgICAgaWYgKCFlcnJvckRldGVjdGVkKSB7XG4vLyAgICAgICAgIC8vIGp1c3QgdG8gYmUgc3VyZSB0aGF0IHdlIGRvbid0IHNlbmQgYW4geGhyIGV2ZXJ5IHNlY29uZCB3aGVuIHRoZVxuLy8gICAgICAgICAvLyB3ZWJzb2NrZXQgaXMgdHJ5aW5nIHRvIHJlY29ubmVjdFxuLy8gICAgICAgICBlcnJvckRldGVjdGVkID0gdHJ1ZTtcbi8vICAgICAgICAgeGhyLmdhbWUoZ2FtZVVybC5zdWJzdHJpbmcoMSkpLnRoZW4oZnVuY3Rpb24oKSB7fSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQwMSkge1xuLy8gICAgICAgICAgICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhpMThuKCd1bmF1dGhvcml6ZWRFcnJvcicpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4vLyAgICAgICAgICAgICBtLnJvdXRlKCcvJyk7XG4vLyAgICAgICAgICAgfVxuLy8gICAgICAgICB9KTtcbi8vICAgICAgIH1cbi8vICAgICB9LFxuLy8gICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycylcbi8vICAgfTtcblxuLy8gICBjb25zdCBvcHRzID0ge1xuLy8gICAgIG9wdGlvbnM6IHtcbi8vICAgICAgIG5hbWU6ICdnYW1lJyxcbi8vICAgICAgIGRlYnVnOiBmYWxzZSxcbi8vICAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbi8vICAgICB9XG4vLyAgIH07XG4vLyAgIHRlbGxXb3JrZXIod29ya2VyLCAnY3JlYXRlJywge1xuLy8gICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbi8vICAgICBzb2NrZXRFbmRQb2ludDogd2luZG93Lm95dW5rZXlmLnNvY2tldEVuZFBvaW50LFxuLy8gICAgIHVybCxcbi8vICAgICB2ZXJzaW9uLFxuLy8gICAgIG9wdHNcbi8vICAgfSk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZU1hc2EobWFzYUlkLCB2ZXJzaW9uLCBoYW5kbGVycykge1xuLy8gICBsZXQgdXJsID0gJy9tYXNhLycgKyBtYXNhSWQgKyAnL3NvY2tldC92MSc7XG5cbi8vICAgc29ja2V0SGFuZGxlcnMgPSB7XG4vLyAgICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGFuZGxlcnMsIGhhbmRsZXJzKVxuLy8gICB9O1xuLy8gICBjb25zdCBvcHRzID0ge1xuLy8gICAgIG9wdGlvbnM6IHtcbi8vICAgICAgIG5hbWU6ICdtYXNhJyxcbi8vICAgICAgIGRlYnVnOiBmYWxzZSxcbi8vICAgICAgIHBpbmdEZWxheTogMjAwMCxcbi8vICAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbi8vICAgICB9XG4vLyAgIH07XG4vLyAgIHRlbGxXb3JrZXIod29ya2VyLCAnY3JlYXRlJywge1xuLy8gICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbi8vICAgICBzb2NrZXRFbmRQb2ludDogd2luZG93Lm95dW5rZXlmLnNvY2tldEVuZFBvaW50LFxuLy8gICAgIHVybCxcbi8vICAgICB2ZXJzaW9uLFxuLy8gICAgIG9wdHNcbi8vICAgfSk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZU1hc2FIb21lKGhhbmRsZXJzKSB7XG4vLyAgIGxldCB1cmwgPSAnL3NvY2tldCc7XG5cbi8vICAgc29ja2V0SGFuZGxlcnMgPSB7XG4vLyAgICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGFuZGxlcnMsIGhhbmRsZXJzKVxuLy8gICB9O1xuLy8gICBjb25zdCBvcHRzID0ge1xuLy8gICAgIHBhcmFtczogeyBmbGFnOiAnbWFzYScgfSxcbi8vICAgICBvcHRpb25zOiB7XG4vLyAgICAgICBuYW1lOiAnbWFzYUhvbWUnLFxuLy8gICAgICAgZGVidWc6IGZhbHNlLFxuLy8gICAgICAgcGluZ0RlbGF5OiAyMDAwLFxuLy8gICAgICAgcmVnaXN0ZXJlZEV2ZW50czogT2JqZWN0LmtleXMoc29ja2V0SGFuZGxlcnMuZXZlbnRzKVxuLy8gICAgIH1cbi8vICAgfTtcbi8vICAgdGVsbFdvcmtlcih3b3JrZXIsICdjcmVhdGUnLCB7XG4vLyAgICAgY2xpZW50SWQ6IG95dW5rZXlmU3JpLFxuLy8gICAgIHNvY2tldEVuZFBvaW50OiB3aW5kb3cub3l1bmtleWYuc29ja2V0RW5kUG9pbnQsXG4vLyAgICAgdXJsLFxuLy8gICAgIHZlcnNpb246IDAsXG4vLyAgICAgb3B0c1xuLy8gICB9KTtcbi8vIH1cblxuLy8gZnVuY3Rpb24gY3JlYXRlTG9iYnkobG9iYnlWZXJzaW9uLCBvbk9wZW4sIGhhbmRsZXJzKSB7XG4vLyAgIHNvY2tldEhhbmRsZXJzID0ge1xuLy8gICAgIG9uT3Blbixcbi8vICAgICBldmVudHM6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIYW5kbGVycywgaGFuZGxlcnMpXG4vLyAgIH07XG4vLyAgIGNvbnN0IG9wdHMgPSB7XG4vLyAgICAgb3B0aW9uczoge1xuLy8gICAgICAgbmFtZTogJ2xvYmJ5Jyxcbi8vICAgICAgIGRlYnVnOiBmYWxzZSxcbi8vICAgICAgIHBpbmdEZWxheTogMjAwMCxcbi8vICAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbi8vICAgICB9XG4vLyAgIH07XG4vLyAgIHRlbGxXb3JrZXIod29ya2VyLCAnY3JlYXRlJywge1xuLy8gICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbi8vICAgICBzb2NrZXRFbmRQb2ludDogd2luZG93Lm95dW5rZXlmLnNvY2tldEVuZFBvaW50LFxuLy8gICAgIHVybDogJy9sb2JieS9zb2NrZXQvdjEnLFxuLy8gICAgIHZlcnNpb246IGxvYmJ5VmVyc2lvbixcbi8vICAgICBvcHRzXG4vLyAgIH0pO1xuLy8gfVxuXG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHQoKSB7XG4vLyAgIC8vIGRlZmF1bHQgc29ja2V0IGlzIHVzZWxlc3Mgd2hlbiBhbm9uLj9cbi8vICAgaWYgKGhhc05ldHdvcmsoKSkge1xuLy8gICAgIHNvY2tldEhhbmRsZXJzID0ge1xuLy8gICAgICAgZXZlbnRzOiBkZWZhdWx0SGFuZGxlcnNcbi8vICAgICB9O1xuLy8gICAgIGNvbnN0IG9wdHMgPSB7XG4vLyAgICAgICBvcHRpb25zOiB7XG4vLyAgICAgICAgIG5hbWU6ICdkZWZhdWx0Jyxcbi8vICAgICAgICAgZGVidWc6IGZhbHNlLFxuLy8gICAgICAgICBwaW5nRGVsYXk6IDIwMDAsXG4vLyAgICAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbi8vICAgICAgIH1cbi8vICAgICB9O1xuLy8gICAgIHRlbGxXb3JrZXIod29ya2VyLCAnY3JlYXRlJywge1xuLy8gICAgICAgY2xpZW50SWQ6IG95dW5rZXlmU3JpLFxuLy8gICAgICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbi8vICAgICAgIHVybDogJy9zb2NrZXQnLFxuLy8gICAgICAgdmVyc2lvbjogMCxcbi8vICAgICAgIG9wdHNcbi8vICAgICB9KTtcbi8vICAgfVxuLy8gfVxuXG4vLyBmdW5jdGlvbiBvbkNvbm5lY3RlZCgpIHtcbi8vICAgY29uc3Qgd2FzT2ZmID0gIWNvbm5lY3RlZFdTO1xuLy8gICBjb25uZWN0ZWRXUyA9IHRydWU7XG4vLyAgIGNsZWFyVGltZW91dChwcm94eUZhaWxUaW1lb3V0SUQpO1xuLy8gICBjbGVhclRpbWVvdXQocmVkcmF3T25EaXNjb25uZWN0ZWRUaW1lb3V0SUQpO1xuLy8gICBpZiAod2FzT2ZmKSBtLnJlZHJhdygpO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiBvbkRpc2Nvbm5lY3RlZCgpIHtcbi8vICAgY29uc3Qgd2FzT24gPSBjb25uZWN0ZWRXUztcbi8vICAgY29ubmVjdGVkV1MgPSBmYWxzZTtcbi8vICAgaWYgKHdhc09uKSByZWRyYXdPbkRpc2Nvbm5lY3RlZFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4vLyAgICAgbS5yZWRyYXcoKTtcbi8vICAgfSwgMjAwMCk7XG4vLyAgIGlmICh3YXNPbiAmJiAhYWxyZWFkeVdhcm5lZCAmJiAhc3RvcmFnZS5nZXQoJ2Rvbm90c2hvd3Byb3h5ZmFpbHdhcm5pbmcnKSkgcHJveHlGYWlsVGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG4vLyAgICAgLy8gY2hlY2sgaWYgZGlzY29ubmVjdGlvbiBsYXN0cywgaXQgY291bGQgbWVhbiBhIHByb3h5IHByZXZlbnRzXG4vLyAgICAgLy8gZXN0YWJsaXNoaW5nIGEgdHVubmVsXG4vLyAgICAgaWYgKGhhc05ldHdvcmsoKSAmJiAhY29ubmVjdGVkV1MpIHtcbi8vICAgICAgIGFscmVhZHlXYXJuZWQgPSB0cnVlO1xuLy8gICAgICAgd2luZG93Lm5hdmlnYXRvci5ub3RpZmljYXRpb24uYWxlcnQocHJveHlGYWlsTXNnLCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgc3RvcmFnZS5zZXQoJ2Rvbm90c2hvd3Byb3h5ZmFpbHdhcm5pbmcnLCB0cnVlKTtcbi8vICAgICAgIH0pO1xuLy8gICAgIH1cbi8vICAgfSwgMjAwMDApO1xuLy8gfVxuXG4vLyB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuLy8gICBzd2l0Y2gobXNnLmRhdGEudG9waWMpIHtcbi8vICAgY2FzZSAnb25PcGVuJzpcbi8vICAgICBpZiAoc29ja2V0SGFuZGxlcnMub25PcGVuKSBzb2NrZXRIYW5kbGVycy5vbk9wZW4oKTtcbi8vICAgICBicmVhaztcbi8vICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbi8vICAgICBvbkRpc2Nvbm5lY3RlZCgpO1xuLy8gICAgIGJyZWFrO1xuLy8gICBjYXNlICdjb25uZWN0ZWQnOlxuLy8gICAgIG9uQ29ubmVjdGVkKCk7XG4vLyAgICAgYnJlYWs7XG4vLyAgIGNhc2UgJ29uRXJyb3InOlxuLy8gICAgIGlmIChzb2NrZXRIYW5kbGVycy5vbkVycm9yKSBzb2NrZXRIYW5kbGVycy5vbkVycm9yKCk7XG4vLyAgICAgYnJlYWs7XG4vLyAgIGNhc2UgJ2hhbmRsZSc6XG4vLyAgICAgdmFyIGggPSBzb2NrZXRIYW5kbGVycy5ldmVudHNbbXNnLmRhdGEucGF5bG9hZC50XTtcbi8vICAgICBpZiAoaCkgaChtc2cuZGF0YS5wYXlsb2FkLmQgfHwgbnVsbCwgbXNnLmRhdGEucGF5bG9hZCk7XG4vLyAgICAgYnJlYWs7XG4vLyAgIH1cbi8vIH0pO1xuXG4vLyAvLyBleHBvcnQgZGVmYXVsdCB7XG4vLyAvLyAgIGNyZWF0ZURlZmF1bHQsXG4vLyAvLyAgIGNyZWF0ZU1hc2EsXG4vLyAvLyAgIGNyZWF0ZU1hc2FIb21lLFxuLy8gLy8gICBjcmVhdGVHYW1lLFxuLy8gLy8gICBjcmVhdGVMb2JieSxcbi8vIC8vICAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4vLyAvLyAgICAgdGVsbFdvcmtlcih3b3JrZXIsICdzZXRWZXJzaW9uJywgdmVyc2lvbik7XG4vLyAvLyAgIH0sXG4vLyAvLyAgIHNlbmQodHlwZSwgZGF0YSwgb3B0cykge1xuLy8gLy8gICAgIHRlbGxXb3JrZXIod29ya2VyLCAnc2VuZCcsIFt0eXBlLCBkYXRhLCBvcHRzXSk7XG4vLyAvLyAgIH0sXG4vLyAvLyAgIGNvbm5lY3QoKSB7XG4vLyAvLyAgICAgdGVsbFdvcmtlcih3b3JrZXIsICdjb25uZWN0Jyk7XG4vLyAvLyAgIH0sXG4vLyAvLyAgIGRpc2Nvbm5lY3QoKSB7XG4vLyAvLyAgICAgdGVsbFdvcmtlcih3b3JrZXIsICdkaXNjb25uZWN0Jyk7XG4vLyAvLyAgIH0sXG4vLyAvLyAgIGlzQ29ubmVjdGVkKCkge1xuLy8gLy8gICAgIHJldHVybiBjb25uZWN0ZWRXUztcbi8vIC8vICAgfSxcbi8vIC8vICAgZGVzdHJveSgpIHtcbi8vIC8vICAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ2Rlc3Ryb3knKTtcbi8vIC8vICAgfSxcbi8vIC8vICAgdGVybWluYXRlKCkge1xuLy8gLy8gICAgIGlmICh3b3JrZXIpIHdvcmtlci50ZXJtaW5hdGUoKTtcbi8vIC8vICAgfVxuLy8gLy8gfTtcbiIsInZhciB0aW1lb3V0SWQ7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3BpbigpIHtcbiAgICBpZiAodGltZW91dElkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2dsb2JhbFNwaW5uZXInKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgc3Bpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNwaW5uZXIuY2xhc3NOYW1lID0gJ3NwaW5uZXIgZ2xvYmFsU3Bpbm5lcic7XG4gICAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgJzAgMCA0MCA0MCcpO1xuICAgIGNvbnN0IGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnY2lyY2xlJyk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3gnLCAnMjAnKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdjeScsICcyMCcpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ3InLCAnMTgnKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQoY2lyY2xlKTtcbiAgICBzcGlubmVyLmFwcGVuZENoaWxkKHN2Zyk7XG5cbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3Bpbm5lciksIDIwMCk7XG4gIH0sXG5cbiAgc3RvcCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgIGNvbnN0IHNwaW5uZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZ2xvYmFsU3Bpbm5lcicpO1xuICAgIGlmIChzcGlubmVycy5sZW5ndGgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlIChzcGlubmVyc1swXSkgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzcGlubmVyc1swXSk7XG4gICAgICB9LCA1MDApO1xuICAgIH1cbiAgfSxcblxuICBnZXRWZG9tKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz17J3NwaW5uZXIgJyArIGNsYXNzZXN9PlxuICAgICAgICA8c3ZnIHZpZXdCb3g9XCIwIDAgNDAgNDBcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMjBcIiBjeT1cIjIwXCIgcj1cIjE4XCIgZmlsbD1cIm5vbmVcIj48L2NpcmNsZT5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCJmdW5jdGlvbiB3aXRoU3RvcmFnZShmKSB7XG4gIC8vIGNhbiB0aHJvdyBhbiBleGNlcHRpb24gaWYgc3RvcmFnZSBpcyBmdWxsXG4gIHRyeSB7XG4gICAgcmV0dXJuICEhd2luZG93LmxvY2FsU3RvcmFnZSA/IGYod2luZG93LmxvY2FsU3RvcmFnZSkgOiBudWxsO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5mdW5jdGlvbiBnZXQoaykge1xuICByZXR1cm4gd2l0aFN0b3JhZ2UoZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHMuZ2V0SXRlbShrKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlKGspIHtcbiAgcmV0dXJuIHdpdGhTdG9yYWdlKGZ1bmN0aW9uKHMpIHtcbiAgICBzLnJlbW92ZUl0ZW0oayk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0KGssIHYpIHtcbiAgcmV0dXJuIHdpdGhTdG9yYWdlKGZ1bmN0aW9uKHMpIHtcbiAgICBzLnJlbW92ZUl0ZW0oayk7XG4gICAgcy5zZXRJdGVtKGssIEpTT04uc3RyaW5naWZ5KHYpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByb3Aoa2V5LCBpbml0aWFsVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSBzZXQoa2V5LCBhcmd1bWVudHNbMF0pO1xuICAgIGNvbnN0IHJldCA9IGdldChrZXkpO1xuICAgIHJldHVybiAocmV0ICE9PSBudWxsICYmIHJldCAhPT0gdW5kZWZpbmVkKSA/IHJldCA6IGluaXRpYWxWYWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXQsXG4gIHNldCxcbiAgcmVtb3ZlLFxuICBwcm9wXG59O1xuIiwiaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vc29ja2V0JztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vcm91dGVyJztcbmltcG9ydCB7IGhhc05ldHdvcmssIGhhbmRsZVhockVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2FtZSBhcyBnYW1lWGhyIH0gZnJvbSAnLi4vLi4veGhyJztcbmltcG9ydCAqIGFzIHNsZWVwVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvc2xlZXAnO1xuaW1wb3J0IE9ubGluZVJvdW5kIGZyb20gJy4uL3NoYXJlZC9yb3VuZC9PbmxpbmVSb3VuZCc7XG5pbXBvcnQgcm91bmRWaWV3IGZyb20gJy4uL3NoYXJlZC9yb3VuZC92aWV3L3JvdW5kVmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KHsgYXR0cnMgfSkge1xuICAgIGxldCBnYW1lRGF0YTtcblxuICAgIHNsZWVwVXRpbHMua2VlcEF3YWtlKCk7XG5cbiAgICBpZiAoaGFzTmV0d29yaygpKSB7XG4gICAgICBnYW1lWGhyKGF0dHJzLmlkKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICBnYW1lRGF0YSA9IGRhdGE7XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvdW5kID0gbmV3IE9ubGluZVJvdW5kKGF0dHJzLmlkLCBkYXRhKTtcbiAgICAgICAgICB9LCA0MDApO1xuXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBoYW5kbGVYaHJFcnJvcihlcnJvcik7XG4gICAgICAgICAgcm91dGVyLnNldCgnLycpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIG9uY3JlYXRlKHZub2RlKSB7XG4gICAgaWYgKHZub2RlLmRvbSlcbiAgICAgIGhlbHBlci5lbEZhZGVJbih2bm9kZS5kb20pO1xuICB9LFxuICBvbnJlbW92ZSgpIHtcbiAgICBzbGVlcFV0aWxzLmFsbG93U2xlZXBBZ2FpbigpO1xuICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgaWYgKHRoaXMucm91bmQpIHtcbiAgICAgIHRoaXMucm91bmQudW5sb2FkKCk7XG4gICAgfVxuICB9LFxuICB2aWV3KHthdHRyc30pIHtcbiAgICBpZiAodGhpcy5yb3VuZCkgcmV0dXJuIHJvdW5kVmlldyh0aGlzLnJvdW5kKTtcbiAgICBcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbiIsImltcG9ydCBwb3B1cFdpZGdldCBmcm9tICcuL3NoYXJlZC9wb3B1cCc7XG5pbXBvcnQgZm9ybVdpZGdldHMgZnJvbSAnLi9zaGFyZWQvZm9ybSc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBuZXdHYW1lRm9ybSBmcm9tICcuL25ld0dhbWVGb3JtJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IGlTY3JvbGwgZnJvbSAnaXNjcm9sbCc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MnO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vc2Vzc2lvbic7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi9iYWNrYnV0dG9uJztcbmltcG9ydCBsb2JieSBmcm9tICcuL2xvYmJ5JztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IFZpZXdPbmx5Qm9hcmQgZnJvbSAnLi9zaGFyZWQvVmlld09ubHlCb2FyZCc7XG5cbnZhciBzY3JvbGxlciA9IG51bGw7XG5cbmNvbnN0IGdhbWVzTWVudSA9IHt9O1xuXG5nYW1lc01lbnUuaXNPcGVuID0gZmFsc2U7XG5cbmdhbWVzTWVudS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGJhY2tidXR0b24uc3RhY2sucHVzaChnYW1lc01lbnUuY2xvc2UpO1xuICBnYW1lc01lbnUuaXNPcGVuID0gdHJ1ZTtcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbHMuaGFzTmV0d29yaygpICYmIHNjcm9sbGVyKSBzY3JvbGxlci5nb1RvUGFnZSgxLCAwKTtcbiAgfSwgNDAwKTtcbiAgc2Vzc2lvbi5yZWZyZXNoKCk7XG59O1xuXG5nYW1lc01lbnUuY2xvc2UgPSBmdW5jdGlvbihmcm9tQkIpIHtcbiAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGdhbWVzTWVudS5pc09wZW4pIGJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4gIGdhbWVzTWVudS5pc09wZW4gPSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGpvaW5HYW1lKGcpIHtcbiAgZ2FtZXNNZW51LmNsb3NlKCk7XG4gIG0ucm91dGUoJy9nYW1lLycgKyBnLmZ1bGxJZCk7XG59XG5cbmZ1bmN0aW9uIGNhcmREaW1zKCkge1xuICBjb25zdCB2cCA9IGhlbHBlci52aWV3cG9ydERpbSgpO1xuXG4gIC8vIGlmIHdlJ3JlIGhlcmUgaXQncyBhIHBob25lXG4gIGxldCB3aWR0aCA9IDIwMDtcbiAgbGV0IGhlaWdodCA9IHdpZHRoIC8gKDQvMyk7XG4gIGxldCBtYXJnaW4gPSAxMDtcbiAgcmV0dXJuIHtcbiAgICB3OiB3aWR0aCArIG1hcmdpbiAqIDIsXG4gICAgaDogaGVpZ2h0ICsgNzAsXG4gICAgaW5uZXJXOiB3aWR0aCxcbiAgICBtYXJnaW46IG1hcmdpblxuICB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJWaWV3T25seUJvYXJkKGNEaW0sIGZlbiwgb3JpZW50YXRpb24sIHZhcmlhbnQpIHtcbiAgY29uc3QgaW5uZXJIID0gY0RpbSA/IGNEaW0uaW5uZXJXIC8gKDQvMyk6IDA7XG4gIGNvbnN0IGlubmVyVyA9IGNEaW0gPyBjRGltLmlubmVyVyA6IDA7XG4gIGNvbnN0IHN0eWxlID0gY0RpbSA/IHsgaGVpZ2h0OiBpbm5lckggKyAncHgnIH0gOiB7fTtcbiAgY29uc3QgYm91bmRzID0gY0RpbSA/IHsgd2lkdGg6IGlubmVyVywgaGVpZ2h0OiBpbm5lckggfSA6IG51bGw7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJib2FyZFdyYXBwZXJcIiBzdHlsZT17c3R5bGV9PlxuICAgICAge20uY29tcG9uZW50KFZpZXdPbmx5Qm9hcmQsIHsgYm91bmRzLCBmZW4sIG9yaWVudGF0aW9uLCB2YXJpYW50fSl9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHRpbWVMZWZ0KGcpIHtcbiAgaWYgKCFnLmlzTXlUdXJuKSByZXR1cm4gaTE4bignd2FpdGluZ0Zvck9wcG9uZW50Jyk7XG4gIHJldHVybiBpMThuKCd5b3VyVHVybicpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHYW1lKGcsIGNEaW0sIGNhcmRTdHlsZSkge1xuICBjb25zdCBpY29uID0gdXRpbHMuZ2FtZUljb24oZy5wZXJmKTtcbiAgY29uc3QgY2FyZENsYXNzID0gW1xuICAgICdjYXJkJyxcbiAgICAnc3RhbmRhcmQnXG4gIF0uam9pbignICcpO1xuXG4gIGNvbnN0IHRpbWVDbGFzcyA9IFtcbiAgICAndGltZUluZGljYXRpb24nLFxuICAgIGcuaXNNeVR1cm4gPyAnbXlUdXJuJzogJ29wcG9uZW50VHVybidcbiAgXS5qb2luKCcgJyk7XG4gIGNvbnN0IGNvbmZpZyA9IGhlbHBlci5vbnRvdWNoWCgoKSA9PiBqb2luR2FtZShnKSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2FyZENsYXNzfSBrZXk9eydnYW1lLicgKyBnLmdhbWVJZH0gc3R5bGU9e2NhcmRTdHlsZX1cbiAgICBjb25maWc9e2NvbmZpZ30+XG4gICAgICB7cmVuZGVyVmlld09ubHlCb2FyZChjRGltLCBnLmZlbiwgZy5zaWRlLCBnLnZhcmlhbnQpfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbmZvc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgPHA+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ2YXJpYW50XCI+e2cudmFyaWFudC5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17dGltZUNsYXNzfT57dGltZUxlZnQoZyl9PC9zcGFuPlxuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQWxsR2FtZXMoY0RpbSkge1xuICBjb25zdCBub3dQbGF5aW5nID0gc2Vzc2lvbi5ub3dQbGF5aW5nKCk7IC8vIC5jb25jYXQoc2Vzc2lvbi5ub3dQbGF5aW5nKCkpO1xuICBjb25zdCBjYXJkU3R5bGUgPSBjRGltID8ge1xuICAgIHdpZHRoOiAoY0RpbS53IC0gY0RpbS5tYXJnaW4gKiAyKSArICdweCcsXG4gICAgaGVpZ2h0OiBjRGltLmggKyAncHgnLFxuICAgIG1hcmdpbkxlZnQ6IGNEaW0ubWFyZ2luICsgJ3B4JyxcbiAgICBtYXJnaW5SaWdodDogY0RpbS5tYXJnaW4gKyAncHgnXG4gIH0gOiB7fTtcblxuICBjb25zdCBuYkNhcmRzID0gdXRpbHMuaGFzTmV0d29yaygpID9cbiAgICAgICAgICAgICAgICAgIG5vd1BsYXlpbmcubGVuZ3RoICsgMSA6XG4gICAgICAgICAgICAgICAgICAwO1xuXG4gIGxldCB3cmFwcGVyU3R5bGUsIHdyYXBwZXJXaWR0aDtcbiAgaWYgKGNEaW0pIHtcbiAgICAvLyBzY3JvbGxlciB3cmFwcGVyIHdpZHRoXG4gICAgLy8gY2FsY3VsIGlzOlxuICAgIC8vICgoY2FyZFdpZHRoICsgdmlzaWJsZSBwYXJ0IG9mIGFkamFjZW50IGNhcmQpICogbmIgb2YgY2FyZHMpICtcbiAgICAvLyB3cmFwcGVyJ3MgbWFyZ2luTGVmdFxuICAgIHdyYXBwZXJXaWR0aCA9ICgoY0RpbS53ICsgY0RpbS5tYXJnaW4gKiAyKSAqIG5iQ2FyZHMpICtcbiAgICAgICAgICAgICAgICAgICAoY0RpbS5tYXJnaW4gKiAyKTtcbiAgICB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICB3aWR0aDogd3JhcHBlcldpZHRoICsgJ3B4JyxcbiAgICAgIG1hcmdpbkxlZnQ6IChjRGltLm1hcmdpbiAqIDMpICsgJ3B4J1xuICAgIH07XG4gIH1cblxuICB2YXIgYWxsQ2FyZHMgPSBub3dQbGF5aW5nLm1hcChnID0+IHJlbmRlckdhbWUoZywgY0RpbSwgY2FyZFN0eWxlKSk7XG5cbiAgaWYgKCFoZWxwZXIuaXNXaWRlU2NyZWVuKCkpIHtcblxuICAgIGNvbnN0IG5ld0dhbWVDYXJkID0gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkIHN0YW5kYXJkXCIga2V5PVwiZ2FtZS5uZXctZ2FtZVwiIHN0eWxlPXtjYXJkU3R5bGV9XG4gICAgICAgICAgIGNvbmZpZz17aGVscGVyLm9udG91Y2hYKCgpID0+IHsgZ2FtZXNNZW51LmNsb3NlKCk7IG5ld0dhbWVGb3JtLm9wZW4oKTsgfSl9PlxuICAgICAgICB7cmVuZGVyVmlld09ubHlCb2FyZChjRGltKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbmZvc1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVzY3JpcHRpb25cIj5cbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0aXRsZVwiPntpMThuKCdjcmVhdGVBR2FtZScpfTwvaDI+XG4gICAgICAgICAgICA8cD57aTE4bignbmV3T3Bwb25lbnQnKX08L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgICBpZiAodXRpbHMuaGFzTmV0d29yaygpKSBhbGxDYXJkcy51bnNoaWZ0KG5ld0dhbWVDYXJkKTtcbiAgfVxuXG4gIHJldHVybiBtKCdkaXYjYWxsX2dhbWVzJywgeyBzdHlsZTogd3JhcHBlclN0eWxlIH0sIGFsbENhcmRzKTtcbn1cblxuXG5nYW1lc01lbnUudmlldyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWdhbWVzTWVudS5pc09wZW4pIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHZoID0gaGVscGVyLnZpZXdwb3J0RGltKCkudmhcbiAgY29uc3QgY0RpbSA9IGNhcmREaW1zKCk7XG4gIGNvbnN0IHdyYXBwZXJTdHlsZSA9IGhlbHBlci5pc1dpZGVTY3JlZW4oKSA/IHt9IDogeyB0b3A6ICgodmggLSBjRGltLmgpIC8gMikgKyAncHgnIH07XG4gIGNvbnN0IHdyYXBwZXJDb25maWcgPVxuICBoZWxwZXIuaXNXaWRlU2NyZWVuKCkgPyB1dGlscy5ub29wIDpcbiAgZnVuY3Rpb24oZWwsIGlzVXBkYXRlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc1VwZGF0ZSkge1xuICAgICAgc2Nyb2xsZXIgPSBuZXcgaVNjcm9sbChlbCwge1xuICAgICAgICBzY3JvbGxYOiB0cnVlLFxuICAgICAgICBzY3JvbGxZOiBmYWxzZSxcbiAgICAgICAgbW9tZW50dW06IGZhbHNlLFxuICAgICAgICBzbmFwOiAnLmNhcmQnLFxuICAgICAgICBzbmFwU3BlZWQ6IDQwMCxcbiAgICAgICAgcHJldmVudERlZmF1bHRFeGNlcHRpb246IHtcbiAgICAgICAgICB0YWdOYW1lOiAvXihJTlBVVHxURVhUQVJFQXxCVVRUT058U0VMRUNUfExBQkVMKSQvXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb250ZXh0LnVub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzY3JvbGxlcikge1xuICAgICAgICAgIHNjcm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICBzY3JvbGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3ViaXEvaXNjcm9sbC9pc3N1ZXMvNDEyXG4gICAgc2Nyb2xsZXIub3B0aW9ucy5zbmFwID0gZWwucXVlcnlTZWxlY3RvckFsbCgnLmNhcmQnKTtcbiAgICBzY3JvbGxlci5yZWZyZXNoKCk7XG4gIH07XG5cbiAgY29uc3QgaXNXaWRlU2NyZWVuID0gaGVscGVyLmlzV2lkZVNjcmVlbigpO1xuXG4gIGNvbnN0IHdyYXBwZXJDbGFzcyA9IGlzV2lkZVNjcmVlbiA/ICdvdmVybGF5X3BvcHVwJyA6ICcnO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBpZD1cImdhbWVzX21lbnVcIiBjbGFzc05hbWU9XCJvdmVybGF5X3BvcHVwX3dyYXBwZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwid3JhcHBlcl9vdmVybGF5X2Nsb3NlXCJcbiAgICAgICAgICAgY29uZmlnPXtoZWxwZXIub250b3VjaChoZWxwZXIuZmFkZXNPdXQoZ2FtZXNNZW51LmNsb3NlLCAnLm92ZXJsYXlfcG9wdXBfd3JhcHBlcicpKX0vPlxuICAgICAgPGRpdiBpZD1cIndyYXBwZXJfZ2FtZXNcIiBjbGFzc05hbWU9e3dyYXBwZXJDbGFzc30gc3R5bGU9e3dyYXBwZXJTdHlsZX0gY29uZmlnPXt3cmFwcGVyQ29uZmlnfT5cbiAgICAgICAgeyBpc1dpZGVTY3JlZW4gPyAoXG4gICAgICAgICAgPGhlYWRlcj5cbiAgICAgICAgICAgIHtpMThuKCduYkdhbWVzSW5QbGF5Jywgc2Vzc2lvbi5ub3dQbGF5aW5nKCkubGVuZ3RoKX1cbiAgICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgKSA6IG51bGwgfVxuICAgICAgICB7IGlzV2lkZVNjcmVlbiA/IChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBvcHVwX2NvbnRlbnRcIj5cbiAgICAgICAgICB7cmVuZGVyQWxsR2FtZXMobnVsbCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICkgOiByZW5kZXJBbGxHYW1lcyhjRGltKSB9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdhbWVzTWVudTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cblxudmFyIGFuaW1hdGluZyA9IGZhbHNlO1xuXG4vLyBBdXRob3IgQmFybmV5IENhcm9sbFxuLy8gdGFrZW4gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iYXJuZXljYXJyb2xsL2M2OWZiZTA3ODZlMzdjOTQxYmFmXG5cbi8vIERlZmluZSBhbiBhbmltYXRvciBjb25zaXN0aW5nIG9mIG9wdGlvbmFsIGluY29taW5nIGFuZCBvdXRnb2luZyBhbmltYXRpb25zLlxuLy8gYWx3YXlzQW5pbWF0ZSBpcyBmYWxzZSB1bmxlc3Mgc3BlY2lmaWVkIGFzIHRydWU6IGZhbHNlIG1lYW5zIGFuIGluY29taW5nIGFuaW1hdGlvbiB3aWxsIG9ubHkgdHJpZ2dlciBpZiBhbiBvdXRnb2luZyBhbmltYXRpb24gaXMgYWxzbyBpbiBwcm9ncmVzcy5cbi8vIGZvcmNpbmcgZG9udENsb25lIHRvIHRydWUgbWVhbnMgdGhlIG91dHdhcmQgYW5pbWF0aW9uIHdpbGwgdXNlIHRoZSBvcmlnaW5hbCBlbGVtZW50IHJhdGhlciB0aGFuIGEgY2xvbmUuIFRoaXMgY291bGQgaW1wcm92ZSBwZXJmb3JtYW5jZSBieSByZWN5Y2xpbmcgZWxlbWVudHMsIGJ1dCBjYW4gbGVhZCB0byB0cm91YmxlOiBjbG9uZXMgaGF2ZSB0aGUgYWR2YW50YWdlIG9mIGJlaW5nIHN0cmlwcGVkIG9mIGFsbCBldmVudCBsaXN0ZW5lcnMuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhbmltYXRvcihpbmNvbWluZywgb3V0Z29pbmcsIGFsd2F5c0FuaW1hdGUsIGRvbnRDbG9uZSkge1xuICAvLyBUaGUgcmVzdWx0aW5nIGFuaW1hdG9yIGNhbiBiZSBhcHBsaWVkIHRvIGFueSBudW1iZXIgb2YgY29tcG9uZW50c1xuICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZSggeCwgeSwgeiApe1xuICAgIHZhciBjb25maWc7XG4gICAgdmFyIHBhcmVudDtcbiAgICB2YXIgbmV4dDtcblxuICAgIC8vIFdoZW4gdXNlZCBhcyBhIGNvbmZpZyBmdW5jdGlvblxuICAgIGlmICggeC5ub2RlVHlwZSApIHtcbiAgICAgIHJldHVybiBhbmltYXRpb25Db25maWcoeCwgeSwgeik7XG4gICAgfVxuICAgIC8vIFdoZW4gcGFzc2VkIGEgdmlydHVhbCBET00gbm9kZSAodGhlIG91dHB1dCBvZiBtKVxuICAgIGVsc2UgaWYgKCB4LmF0dHJzICkge1xuICAgICAgcmV0dXJuIGJpbmRDb25maWdUbyggeCApO1xuICAgIH1cbiAgICAvLyBXaGVuIGFwcGxpZWQgdG8gYSBNaXRocmlsIG1vZHVsZSAvIGNvbXBvbmVudFxuICAgIGVsc2UgaWYgKCB4LnZpZXcgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250cm9sbGVyOiB4LmNvbnRyb2xsZXIgfHwgbm9vcCxcbiAgICAgICAgdmlldzogZnVuY3Rpb24gYW5pbWF0ZWRWaWV3KGN0cmwpe1xuICAgICAgICAgIHJldHVybiBiaW5kQ29uZmlnVG8oeC52aWV3KGN0cmwpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5kQ29uZmlnVG8oIG5vZGUgKXtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbmZpZyA9IG5vZGUuYXR0cnMuY29uZmlnO1xuXG4gICAgICBub2RlLmF0dHJzLmNvbmZpZyA9IGFuaW1hdGlvbkNvbmZpZztcblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYW5pbWF0aW9uQ29uZmlnKGVsLCBpbml0LCBjb250ZXh0KXtcbiAgICAgIHZhciBvdXRwdXQ7XG4gICAgICB2YXIgb251bmxvYWQ7XG5cbiAgICAgIGlmIChjb25maWcpe1xuICAgICAgICBvdXRwdXQgPSBjb25maWcoZWwsIGluaXQsIGNvbnRleHQpO1xuICAgICAgICAvLyBJZiB0aGUgcm9vdCBlbGVtZW50IGFscmVhZHkgaGFzIGEgY29uZmlnLCBpdCBtYXkgYWxzbyBoYXZlIGFuIG9udW5sb2FkIHdoaWNoIHdlIHNob3VsZCB0YWtlIGNhcmUgdG8gcHJlc2VydmVcbiAgICAgICAgb251bmxvYWQgPSBjb250ZXh0Lm9udW5sb2FkO1xuICAgICAgfVxuXG4gICAgICBpZiAoICFpbml0ICl7XG4gICAgICAgIGlmIChpbmNvbWluZyAmJiBhbHdheXNBbmltYXRlIHx8IGFuaW1hdGluZykge1xuICAgICAgICAgIGluY29taW5nKGVsLCBub29wLCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQub251bmxvYWQgPSBvdXRnb2luZyA/IG9udW5sb2FkID8gZnVuY3Rpb24gb251bmxvYWRXcmFwcGVyKCkge1xuICAgICAgICAgIHRlYXJkb3duKCk7XG4gICAgICAgICAgb251bmxvYWQoKTtcbiAgICAgICAgfSA6IHRlYXJkb3duIDogb251bmxvYWQ7XG5cbiAgICAgICAgcGFyZW50ID0gZWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgbmV4dCA9IGVsLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuXG4gICAgICBmdW5jdGlvbiB0ZWFyZG93bigpIHtcbiAgICAgICAgdmFyIGluc2VydGlvbiA9IGRvbnRDbG9uZSA/IGVsIDogZWwuY2xvbmVOb2RlKCB0cnVlICk7XG4gICAgICAgIHZhciByZWZlcmVuY2UgPSBudWxsO1xuXG4gICAgICAgIGlmICggbmV4dCAmJiBwYXJlbnQgJiYgbmV4dC5wYXJlbnROb2RlID09PSBwYXJlbnQgKXtcbiAgICAgICAgICByZWZlcmVuY2UgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbiByZXNldEFuaW1hdGlvbkZsYWcoKXtcbiAgICAgICAgICBhbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgMCApO1xuXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoIGluc2VydGlvbiwgcmVmZXJlbmNlICk7XG5cbiAgICAgICAgb3V0Z29pbmcoIGluc2VydGlvbiwgZnVuY3Rpb24gZGVzdHJveSgpe1xuICAgICAgICAgIGlmICggcGFyZW50LmNvbnRhaW5zKCBpbnNlcnRpb24gKSApe1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKCBpbnNlcnRpb24gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRleHQgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuY29uc3QgSE9MRF9EVVJBVElPTiA9IDYwMDtcbmNvbnN0IFJFUEVBVF9SQVRFID0gMjA7XG5jb25zdCBTQ1JPTExfVE9MRVJBTkNFID0gODtcbmNvbnN0IEFDVElWRV9DTEFTUyA9ICdhY3RpdmUnO1xuXG5mdW5jdGlvbiBoYXNDb250ZXh0TWVudSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5jb3Jkb3ZhLnBsYXRmb3JtSWQgIT09ICdpb3MnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCdXR0b25IYW5kbGVyKGVsLFxuICB0YXBIYW5kbGVyLFxuICBob2xkSGFuZGxlcixcbiAgcmVwZWF0SGFuZGxlcixcbiAgc2Nyb2xsWCxcbiAgc2Nyb2xsWSxcbiAgdG91Y2hFbmRGZWVkYmFjaykge1xuXG4gIGxldCBzdGFydFgsIHN0YXJ0WSwgYm91bmRhcmllcywgYWN0aXZlLCBob2xkVGltZW91dElELCByZXBlYXRUaW1lb3V0SWQsIHJlcGVhdEludGVydmFsSUQ7XG5cbiAgaWYgKHR5cGVvZiB0YXBIYW5kbGVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignQnV0dG9uSGFuZGxlciAybmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuXG4gIGlmIChob2xkSGFuZGxlciAmJiB0eXBlb2YgaG9sZEhhbmRsZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdXR0b25IYW5kbGVyIDNyZCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24hJyk7XG5cbiAgaWYgKHJlcGVhdEhhbmRsZXIgJiYgdHlwZW9mIHJlcGVhdEhhbmRsZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdXR0b25IYW5kbGVyIDRyZCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24hJyk7XG5cbiAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2hvdy1qYXZhc2NyaXB0LXRpbWVycy13b3JrL1xuICBmdW5jdGlvbiBvblJlcGVhdCgpIHtcbiAgICB2YXIgcmVzID0gcmVwZWF0SGFuZGxlcigpO1xuICAgIHJlcGVhdEludGVydmFsSUQgPSBzZXRUaW1lb3V0KG9uUmVwZWF0LCBSRVBFQVRfUkFURSk7XG4gICAgaWYgKCFyZXMpIGNsZWFyVGltZW91dChyZXBlYXRJbnRlcnZhbElEKTtcbiAgICBtLnJlZHJhdygpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICBsZXQgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGxldCBib3VuZGluZ1JlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBzdGFydFggPSB0b3VjaC5jbGllbnRYO1xuICAgIHN0YXJ0WSA9IHRvdWNoLmNsaWVudFk7XG4gICAgYm91bmRhcmllcyA9IHtcbiAgICAgIG1pblg6IGJvdW5kaW5nUmVjdC5sZWZ0LFxuICAgICAgbWF4WDogYm91bmRpbmdSZWN0LnJpZ2h0LFxuICAgICAgbWluWTogYm91bmRpbmdSZWN0LnRvcCxcbiAgICAgIG1heFk6IGJvdW5kaW5nUmVjdC5ib3R0b21cbiAgICB9O1xuICAgIGFjdGl2ZSA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoYWN0aXZlKSBlbC5jbGFzc0xpc3QuYWRkKEFDVElWRV9DTEFTUyk7XG4gICAgfSwgMjAwKTtcbiAgICBpZiAoIWhhc0NvbnRleHRNZW51KCkpIGhvbGRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KG9uSG9sZCwgSE9MRF9EVVJBVElPTik7XG4gICAgY2xlYXJUaW1lb3V0KHJlcGVhdEludGVydmFsSUQpO1xuICAgIGlmIChyZXBlYXRIYW5kbGVyKSByZXBlYXRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlcGVhdEludGVydmFsSUQgPSBzZXRUaW1lb3V0KG9uUmVwZWF0LCBSRVBFQVRfUkFURSk7XG4gICAgfSwgMTUwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICAvLyBpZiBnb2luZyBvdXQgb2YgYm91bmRzLCBubyB3YXkgdG8gcmVlbmFibGUgdGhlIGJ1dHRvblxuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIGxldCB0b3VjaCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBhY3RpdmUgPSBpc0FjdGl2ZSh0b3VjaCk7XG4gICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaG9sZFRpbWVvdXRJRCk7XG4gICAgICAgIGNsZWFyVGltZW91dChyZXBlYXRUaW1lb3V0SWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVwZWF0SW50ZXJ2YWxJRCk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoQUNUSVZFX0NMQVNTKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoRW5kKGUpIHtcbiAgICBpZiAoZS5jYW5jZWxhYmxlKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY2xlYXJUaW1lb3V0KHJlcGVhdFRpbWVvdXRJZCk7XG4gICAgY2xlYXJUaW1lb3V0KHJlcGVhdEludGVydmFsSUQpO1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIGNsZWFyVGltZW91dChob2xkVGltZW91dElEKTtcbiAgICAgIGlmICh0b3VjaEVuZEZlZWRiYWNrKSBlbC5jbGFzc0xpc3QuYWRkKEFDVElWRV9DTEFTUyk7XG4gICAgICB0YXBIYW5kbGVyKGUpO1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoQUNUSVZFX0NMQVNTKSwgODApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hDYW5jZWwoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGhvbGRUaW1lb3V0SUQpO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRUaW1lb3V0SWQpO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRJbnRlcnZhbElEKTtcbiAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoaG9sZFRpbWVvdXRJRCA9PT0gdW5kZWZpbmVkKSBvbkhvbGQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSG9sZCgpIHtcbiAgICBpZiAoaG9sZEhhbmRsZXIpIHtcbiAgICAgIGhvbGRIYW5kbGVyKCk7XG4gICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoQUNUSVZFX0NMQVNTKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0FjdGl2ZSh0b3VjaCkge1xuICAgIGxldCB4ID0gdG91Y2guY2xpZW50WCxcbiAgICAgIHkgPSB0b3VjaC5jbGllbnRZLFxuICAgICAgYiA9IGJvdW5kYXJpZXMsXG4gICAgICBkID0gMDtcbiAgICBpZiAoc2Nyb2xsWCkgZCA9IE1hdGguYWJzKHggLSBzdGFydFgpO1xuICAgIGlmIChzY3JvbGxZKSBkID0gTWF0aC5hYnMoeSAtIHN0YXJ0WSk7XG4gICAgcmV0dXJuIHggPCBiLm1heFggJiYgeCA+IGIubWluWCAmJiB5IDwgYi5tYXhZICYmIHkgPiBiLm1pblkgJiYgZCA8IFNDUk9MTF9UT0xFUkFOQ0U7XG4gIH1cblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIG9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51LCBmYWxzZSk7XG59XG4iLCJpbXBvcnQgWmFuaW1vIGZyb20gJ3phbmltbyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgQnV0dG9uSGFuZGxlciBmcm9tICcuL2J1dHRvbic7XG5pbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuY29uc3QgYW5pbUR1cmF0aW9uID0gMjUwO1xuXG5mdW5jdGlvbiBjcmVhdGVUYXBIYW5kbGVyKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCByZXBlYXRIYW5kbGVyLCBzY3JvbGxYLCBzY3JvbGxZLCBnZXRFbGVtZW50LCBwcmV2ZW50RW5kRGVmYXVsdCkge1xuICByZXR1cm4gZnVuY3Rpb24odm5vZGUpIHtcbiAgICBCdXR0b25IYW5kbGVyKHZub2RlLmRvbSxcbiAgICAgICAgICAgICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcEhhbmRsZXIoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGhvbGRIYW5kbGVyID8gKGUpID0+IHV0aWxzLmF1dG9yZWRyYXcoKCkgPT4gaG9sZEhhbmRsZXIoZSkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgcmVwZWF0SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgIHNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICBzY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgIHByZXZlbnRFbmREZWZhdWx0KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9udGFwKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCByZXBlYXRIYW5kbGVyLCBnZXRFbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVUYXBIYW5kbGVyKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCByZXBlYXRIYW5kbGVyLCBmYWxzZSwgZmFsc2UsIGdldEVsZW1lbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb250YXBYWSh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgZ2V0RWxlbWVudCwgcHJldmVudEVuZERlZmF1bHQgPSB0cnVlKSB7XG4gIHJldHVybiBjcmVhdGVUYXBIYW5kbGVyKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCB1bmRlZmluZWQsIHRydWUsIHRydWUsIGdldEVsZW1lbnQsIHByZXZlbnRFbmREZWZhdWx0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsaWRlc0luVXAodm5vZGUpIHtcbiAgY29uc3QgZWwgPSB2bm9kZS5kb207XG4gIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKDEwMCUpJztcbiAgdm5vZGUuc3RhdGUubG9sID0gZWwub2Zmc2V0SGVpZ2h0O1xuICByZXR1cm4gWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoMCknLCAyNTAsICdlYXNlLW91dCcpXG4gICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xpZGVzT3V0RG93bihjYWxsYmFjaywgZWxJRCkge1xuICByZXR1cm4gZnVuY3Rpb24oZnJvbUJCKSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbElEKTtcbiAgICByZXR1cm4gWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoMTAwJSknLCAyNTAsICdlYXNlLW91dCcpXG4gICAgICAudGhlbigoKSA9PiB1dGlscy5hdXRvcmVkcmF3KCgpID0+IGNhbGxiYWNrKGZyb21CQikpKVxuICAgICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO1xuICB9O1xufVxuXG5cblxuLy8gZWwgZmFkZSBpbiB0cmFuc2l0aW9uLCBjYW4gYmUgYXBwbGllZCB0byBhbnkgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGVsRmFkZUluKGVsLCBkdXJhdGlvbiA9IGFuaW1EdXJhdGlvbiwgb3JpZ09wYWNpdHkgPSAnMC41JywgZW5kT3BhY2l0eSA9ICcxJykge1xuICBsZXQgdElkO1xuXG4gIGVsLnN0eWxlLm9wYWNpdHkgPSBvcmlnT3BhY2l0eTtcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IGBvcGFjaXR5ICR7ZHVyYXRpb259bXMgZWFzZS1vdXRgO1xuXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGVsLnN0eWxlLm9wYWNpdHkgPSBlbmRPcGFjaXR5O1xuICB9KTtcblxuICBmdW5jdGlvbiBhZnRlcigpIHtcbiAgICBjbGVhclRpbWVvdXQodElkKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBhZnRlciwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBhZnRlciwgZmFsc2UpO1xuICAvLyBpbiBjYXNlIHRyYW5zaXRpb25lbmQgZG9lcyBub3QgZmlyZVxuICB0SWQgPSBzZXRUaW1lb3V0KGFmdGVyLCBkdXJhdGlvbiArIDEwKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnV0dG9uKGUpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIHJldHVybiB0YXJnZXQudGFnTmFtZSA9PT0gJ0JVVFRPTicgPyB0YXJnZXQgOiBmaW5kUGFyZW50QnlTZWxlY3Rvcih0YXJnZXQsICdidXR0b24nKTtcbn1cblxuLy8gT0xEXG5cbi8vc3RvcmUgdGVtcG9yYXJpbHkgbGFzdCByb3V0ZSB0byBkaXNhYmxlIGFuaW1hdGlvbnMgb24gc2FtZSByb3V0ZVxuLy8gVE9ETyBmaW5kIGEgYmV0dGVyIHdheSBjYXVzZSB0aGlzIGlzIHVnbHlcbmxldCBsYXN0Um91dGU7XG5cbi8vIHRoaXMgbXVzdCBiZSBjYWNoZWQgYmVjYXVzZSBvZiB0aGUgYWNjZXNzIHRvIGRvY3VtZW50LmJvZHkuc3R5bGVcbmxldCBjYWNoZWRUcmFuc2Zvcm1Qcm9wO1xubGV0IGNhY2hlZFZpZXdwb3J0RGltID0gbnVsbDtcblxuZnVuY3Rpb24gdmlld1NsaWRlSW4oZWwsIGNhbGxiYWNrKSB7XG4gIGlmIChtLnJvdXRlKCkgPT09IGxhc3RSb3V0ZSkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGFzdFJvdXRlID0gbS5yb3V0ZSgpO1xuXG4gIGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIHV0aWxzLnNldFZpZXdTbGlkZURpcmVjdGlvbignZndkJyk7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBjb25zdCBkaXJlY3Rpb24gPSB1dGlscy5nZXRWaWV3U2xpZGVEaXJlY3Rpb24oKSA9PT0gJ2Z3ZCcgPyAnMTAwJScgOiAnLTEwMCUnO1xuICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtkaXJlY3Rpb259LDAsMClgO1xuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gJ3RyYW5zZm9ybSAyMDBtcyBlYXNlLW91dCc7XG5cbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtPSAndHJhbnNsYXRlM2QoMCUsMCwwKSc7XG4gIH0pO1xuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBhZnRlciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiB2aWV3U2xpZGVPdXQoZWwsIGNhbGxiYWNrKSB7XG4gIGlmIChtLnJvdXRlKCkgPT09IGxhc3RSb3V0ZSkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgdXRpbHMuc2V0Vmlld1NsaWRlRGlyZWN0aW9uKCdmd2QnKTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgY29uc3QgZGlyZWN0aW9uID0gdXRpbHMuZ2V0Vmlld1NsaWRlRGlyZWN0aW9uKCkgPT09ICdmd2QnID8gJy0xMDAlJyA6ICcxMDAlJztcbiAgZWwuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDAlLDAsMCknO1xuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gJ3RyYW5zZm9ybSAyMDBtcyBlYXNlLW91dCc7XG5cbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtPSBgdHJhbnNsYXRlM2QoJHtkaXJlY3Rpb259LDAsMClgO1xuICB9KTtcblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgYWZ0ZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gdmlld0ZhZGVzSW4oZWwsIGNhbGxiYWNrKSB7XG4gIHZhciB0SWQ7XG5cbiAgZWwuc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMjAwbXMgZWFzZS1vdXQnO1xuXG4gIHNldFRpbWVvdXQoKCk9PiB7XG4gICAgZWwuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRJZCk7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZWQnLCBhZnRlciwgZmFsc2UpO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVkJywgYWZ0ZXIsIGZhbHNlKTtcblxuICAvLyBpbiBjYXNlIHRyYW5zaXRpb25lZCBkb2VzIG5vdCBmaXJlXG4gIC8vIFRPRE8gZmluZCBhIHdheSB0byBhdm9pZCBpdFxuICB0SWQgPSBzZXRUaW1lb3V0KGFmdGVyLCAyNTApO1xufVxuXG5mdW5jdGlvbiB2aWV3RmFkZXNPdXQoZWwsIGNhbGxiYWNrKSB7XG4gIHZhciB0SWQ7XG5cbiAgZWwuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDIwMG1zIGVhc2Utb3V0LCB2aXNpYmlsaXR5IDBzIGxpbmVhciAyMDBtcyc7XG5cbiAgc2V0VGltZW91dCgoKT0+IHtcbiAgICBlbC5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRJZCk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lZCcsIGFmdGVyLCBmYWxzZSk7XG5cbiAgLy8gaW4gY2FzZSB0cmFuc2l0aW9uZWQgZG9lcyBub3QgZmlyZVxuICAvLyBUT0RPIGZpbmQgYSB3YXkgdG8gYXZvaWQgaXRcbiAgdElkID0gc2V0VGltZW91dChhZnRlciwgMjUwKTtcbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvbkhhcyhjb2xsLCBlbCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29sbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjb2xsW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaW5kUGFyZW50QnlTZWxlY3RvcihlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIG1hdGNoZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgdmFyIGN1ciA9IGVsLnBhcmVudE5vZGU7XG4gIHdoaWxlIChjdXIgJiYgIWNvbGxlY3Rpb25IYXMobWF0Y2hlcywgY3VyKSkge1xuICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBjdXI7XG59XG5cbmZ1bmN0aW9uIG9udG91Y2godGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIHNjcm9sbFgsIHNjcm9sbFksIHRvdWNoRW5kRmVlZGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSkge1xuICAgIGlmICghaXNVcGRhdGUpIHtcbiAgICAgIEJ1dHRvbkhhbmRsZXIoZWwsXG4gICAgICAgICAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIG0uc3RhcnRDb21wdXRhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXBIYW5kbGVyKGUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmVuZENvbXB1dGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBob2xkSGFuZGxlciA/ICgpID0+IHV0aWxzLmF1dG9yZWRyYXcoaG9sZEhhbmRsZXIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWSxcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hFbmRGZWVkYmFja1xuICAgICAgICAgICAgICAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlVHJhbnNmb3JtUHJvcCgpIHtcbiAgcmV0dXJuICd0cmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUgP1xuICAgICd0cmFuc2Zvcm0nIDogJ3dlYmtpdFRyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSA/XG4gICAgJ3dlYmtpdFRyYW5zZm9ybScgOiAnbW96VHJhbnNmb3JtJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlID9cbiAgICAnbW96VHJhbnNmb3JtJyA6ICdvVHJhbnNmb3JtJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlID9cbiAgICAnb1RyYW5zZm9ybScgOiAnbXNUcmFuc2Zvcm0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlld3BvcnREaW0oKSB7XG4gIGlmIChjYWNoZWRWaWV3cG9ydERpbSkgcmV0dXJuIGNhY2hlZFZpZXdwb3J0RGltO1xuXG4gIGxldCBlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBsZXQgdnBkID0gY2FjaGVkVmlld3BvcnREaW0gPSB7XG4gICAgdnc6IGUuY2xpZW50V2lkdGgsXG4gICAgdmg6IGUuY2xpZW50SGVpZ2h0XG4gIH07XG4gIHJldHVybiB2cGQ7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25IYXMoY29sbCwgZWwpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvbGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoY29sbFtpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYXJlbnRCeVNlbGVjdG9yKGVsLCBzZWxlY3Rvcikge1xuICBjb25zdCBtYXRjaGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIGxldCBjdXIgPSBlbDtcbiAgd2hpbGUgKGN1ciAmJiAhY29sbGVjdGlvbkhhcyhtYXRjaGVzLCBjdXIpKSB7XG4gICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGN1cjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExJKGUpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIHJldHVybiB0YXJnZXQudGFnTmFtZSA9PT0gJ0xJJyA/IHRhcmdldCA6IGZpbmRQYXJlbnRCeVNlbGVjdG9yKHRhcmdldCwgJ0xJJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc1NldChjbGFzc2VzKSB7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpIGluIGNsYXNzZXMpIHtcbiAgICBpZiAoY2xhc3Nlc1tpXSkgYXJyLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIGFyci5qb2luKCcgJyk7XG59XG5cbi8vIGV4cG9ydCBkZWZhdWx0IHtcbi8vICAgc2xpZGluZ1BhZ2U6IGFuaW1hdG9yKHZpZXdTbGlkZUluLCB2aWV3U2xpZGVPdXQpLFxuLy8gICBmYWRpbmdQYWdlOiBhbmltYXRvcih2aWV3RmFkZXNJbiwgdmlld0ZhZGVzT3V0KSxcbi8vICAgdmlld3BvcnREaW0sXG4vLyAgIGNsZWFyQ2FjaGVkVmlld3BvcnREaW0oKSB7XG4vLyAgICAgY2FjaGVkVmlld3BvcnREaW0gPSBudWxsO1xuLy8gICB9LFxuXG4vLyAgIHRyYW5zZm9ybVByb3A6IGZ1bmN0aW9uKCkge1xuLy8gICAgIGlmICghY2FjaGVkVHJhbnNmb3JtUHJvcCkgY2FjaGVkVHJhbnNmb3JtUHJvcCA9IGNvbXB1dGVUcmFuc2Zvcm1Qcm9wKCk7XG4vLyAgICAgcmV0dXJuIGNhY2hlZFRyYW5zZm9ybVByb3A7XG4vLyAgIH0sXG5cbi8vICAgc2xpZGVzSW5VcDogZnVuY3Rpb24oZWwsIGlzVXBkYXRlLCBjb250ZXh0KSB7XG4vLyAgICAgaWYgKCFpc1VwZGF0ZSkge1xuLy8gICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoMTAwJSknO1xuLy8gICAgICAgLy8gZm9yY2UgcmVmbG93IGJhY2tcbi8vICAgICAgIGNvbnRleHQubG9sID0gZWwub2Zmc2V0SGVpZ2h0O1xuLy8gICAgICAgWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoMCknLCAyNTAsICdlYXNlLW91dCcpXG4vLyAgICAgICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTtcbi8vICAgICB9XG4vLyAgIH0sXG4vLyAgIHNsaWRlc091dERvd246IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbElEKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbElEKTtcbi8vICAgICAgIG0ucmVkcmF3LnN0cmF0ZWd5KCdub25lJyk7XG4vLyAgICAgICByZXR1cm4gWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoMTAwJSknLCAyNTAsICdlYXNlLW91dCcpXG4vLyAgICAgICAgIC50aGVuKHV0aWxzLmF1dG9yZWRyYXcuYmluZChudWxsLCBjYWxsYmFjaykpXG4vLyAgICAgICAgIC5jYXRjaChjYWxsYmFjayk7XG4vLyAgICAgfTtcbi8vICAgfSxcblxuLy8gICBmYWRlc091dDogZnVuY3Rpb24oY2FsbGJhY2ssIHNlbGVjdG9yLCB0aW1lID0gMTUwKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbi8vICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4vLyAgICAgICB2YXIgZWwgPSBzZWxlY3RvciA/IGZpbmRQYXJlbnRCeVNlbGVjdG9yKGUudGFyZ2V0LCBzZWxlY3RvcikgOiBlLnRhcmdldDtcbi8vICAgICAgIG0ucmVkcmF3LnN0cmF0ZWd5KCdub25lJyk7XG4vLyAgICAgICByZXR1cm4gWmFuaW1vKGVsLCAnb3BhY2l0eScsIDAsIHRpbWUpXG4vLyAgICAgICAgIC50aGVuKCgpID0+IHV0aWxzLmF1dG9yZWRyYXcoY2FsbGJhY2spKVxuLy8gICAgICAgICAuY2F0Y2goY29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7XG4vLyAgICAgfTtcbi8vICAgfSxcblxuLy8gICBvbnRvdWNoOiBmdW5jdGlvbih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgdG91Y2hFbmRGZWVkYmFjayA9IHRydWUpIHtcbi8vICAgICByZXR1cm4gb250b3VjaCh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgZmFsc2UsIGZhbHNlLCB0b3VjaEVuZEZlZWRiYWNrKTtcbi8vICAgfSxcbi8vICAgb250b3VjaFg6IGZ1bmN0aW9uKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCB0b3VjaEVuZEZlZWRiYWNrID0gdHJ1ZSkge1xuLy8gICAgIHJldHVybiBvbnRvdWNoKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCBudWxsLCB0cnVlLCBmYWxzZSwgdG91Y2hFbmRGZWVkYmFjayk7XG4vLyAgIH0sXG4vLyAgIG9udG91Y2hZOiBmdW5jdGlvbih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgdG91Y2hFbmRGZWVkYmFjayA9IHRydWUpIHtcbi8vICAgICByZXR1cm4gb250b3VjaCh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgbnVsbCwgZmFsc2UsIHRydWUsIHRvdWNoRW5kRmVlZGJhY2spO1xuLy8gICB9LFxuLy8gICBjbGFzc1NldDogZnVuY3Rpb24oY2xhc3Nlcykge1xuLy8gICAgIHZhciBhcnIgPSBbXTtcbi8vICAgICBmb3IgKHZhciBpIGluIGNsYXNzZXMpIHtcbi8vICAgICAgIGlmIChjbGFzc2VzW2ldKSBhcnIucHVzaChpKTtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIGFyci5qb2luKCcgJyk7XG4vLyAgIH0sXG5cbi8vICAgaXNXaWRlU2NyZWVuOiBmdW5jdGlvbigpIHtcbi8vICAgICByZXR1cm4gdmlld3BvcnREaW0oKS52dyA+PSA2MDA7XG4vLyAgIH0sXG4vLyAgIGlzSXBhZExpa2U6IGZ1bmN0aW9uKCkge1xuLy8gICAgIGNvbnN0IHsgdmgsIHZ3IH0gPSB2aWV3cG9ydERpbSgpO1xuLy8gICAgIHJldHVybiB2aCA+PSA3MDAgJiYgdncgPD0gMTA1MDtcbi8vICAgfSxcbi8vICAgaXNQb3J0cmFpdDogZnVuY3Rpb24oKSB7XG4vLyAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcob3JpZW50YXRpb246IHBvcnRyYWl0KScpLm1hdGNoZXM7XG4vLyAgIH0sXG4vLyAgIGlzTGFuZHNjYXBlOiBmdW5jdGlvbigpIHtcbi8vICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEoJyhvcmllbnRhdGlvbjogbGFuZHNjYXBlKScpLm1hdGNoZXM7XG4vLyAgIH0sXG4vLyAgIHByb2dyZXNzOiBmdW5jdGlvbiAocCkge1xuLy8gICAgIGlmIChwID09PSAwKSByZXR1cm4gbnVsbDtcbi8vICAgICByZXR1cm4gbSgnc3BhbicsIHtcbi8vICAgICAgIGNsYXNzTmFtZTogJ3Byb2dyZXNzICcgKyAocCA+IDAgPyAncG9zaXRpdmUnIDogJ25lZ2F0aXZlJyksXG4vLyAgICAgICAnZGF0YS1pY29uJzogcCA+IDAgPyAnTicgOiAnTSdcbi8vICAgICB9LCBNYXRoLmFicyhwKSk7XG4vLyAgIH1cbi8vIH07XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCB7IHJlbmRlclF1aWNrU2V0dXAgfSBmcm9tICcuLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IHsgaGVhZGVyIGFzIGhlYWRlcldpZGdldCB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBib2R5KGN0cmwpIHtcbiAgY29uc3QgbmJQbGF5ZXJzID0gaTE4bignbmJDb25uZWN0ZWRQbGF5ZXJzJywgY3RybC5uYkNvbm5lY3RlZFBsYXllcnMoKSB8fCAnPycpO1xuICBjb25zdCBuYkdhbWVzID0gaTE4bignbmJHYW1lc0luUGxheScsIGN0cmwubmJHYW1lc0luUGxheSgpIHx8ICc/Jyk7XG5cbiAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibmF0aXZlX3Njcm9sbGVyIHBhZ2VcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJob21lXCI+XG4gICAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwic3RhdHNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibnVtUGxheWVyc1wiPntuYlBsYXllcnN9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm51bUdhbWVzXCI+e25iR2FtZXN9PC9kaXY+XG4gICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgeyByZW5kZXJRdWlja0dhbWUoKSB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICk7XG5cbiAgLy8gY29uc3QgaGVhZGVyID0gaGVhZGVyV2lkZ2V0LmJpbmQobnVsbCwgJ295dW5rZXlmLm5ldCcpO1xuXG4gIC8vIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIsIGJvZHkpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJRdWlja0dhbWUoKSB7XG4gIHJldHVybiBoKCdkaXYuaG9tZUNyZWF0ZScsIFtcbiAgICBoKCdoMi5ob21lVGl0bGUnLCAnSGVtZW4gb3luYScpLFxuICAgIHJlbmRlclF1aWNrU2V0dXAoKCkgPT4gbmV3R2FtZUZvcm0ub3BlblJlYWx0aW1lKCdjdXN0b20nKSlcbiAgXSk7XG59XG4iLCJpbXBvcnQgc3RyZWFtIGZyb20gJ21pdGhyaWwvc3RyZWFtJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vc29ja2V0JztcbmltcG9ydCB7IGhhc05ldHdvcmssIG5vb3AgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgeyBpc0ZvcmVncm91bmQsIHNldEZvcmVncm91bmQgfSBmcm9tICcuLi8uLi91dGlscy9hcHBNb2RlJztcbmltcG9ydCB7IGRyb3BTaGFkb3dIZWFkZXIgfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCB7IGJvZHkgfSBmcm9tICcuL2hvbWVWaWV3JztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQoKSB7XG4gICAgY29uc3QgbmJDb25uZWN0ZWRQbGF5ZXJzID0gc3RyZWFtKCk7XG4gICAgY29uc3QgbmJHYW1lc0luUGxheSA9IHN0cmVhbSgpO1xuICAgIFxuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBpZiAoaXNGb3JlZ3JvdW5kKCkpIHtcbiAgICAgICAgc29ja2V0LmNyZWF0ZUxvYmJ5KCdob21lTG9iYnknLCBub29wLCB7XG4gICAgICAgICAgbjogKF8sIGQpID0+IHtcbiAgICAgICAgICAgIG5iQ29ubmVjdGVkUGxheWVycyhkLmQpO1xuICAgICAgICAgICAgbmJHYW1lc0luUGxheShkLnIpO1xuICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlc3VtZSgpIHtcbiAgICAgIHNldEZvcmVncm91bmQoKTtcbiAgICAgIGluaXQoKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzTmV0d29yaygpKSB7XG4gICAgICBpbml0KCk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgaW5pdCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgb25SZXN1bWUpO1xuXG4gICAgdGhpcy5jdHJsID0ge1xuICAgICAgbmJDb25uZWN0ZWRQbGF5ZXJzLFxuICAgICAgbmJHYW1lc0luUGxheVxuICAgIH07XG4gIH0sXG4gIFxuICB2aWV3KCkge1xuICAgIGNvbnN0IGhlYWRlciA9IGRyb3BTaGFkb3dIZWFkZXIoJ295dW5rZXlmLm5ldCcpO1xuXG4gICAgcmV0dXJuIGxheW91dC5mcmVlKGhlYWRlciwgYm9keSh0aGlzLmN0cmwpKTtcbiAgfVxufTtcbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuaW1wb3J0ICogYXMgbWVudSBmcm9tICcuL21lbnUnO1xuaW1wb3J0IE1lbnVWaWV3IGZyb20gJy4vbWVudS9tZW51Vmlldyc7XG5pbXBvcnQgTWFpbkJvYXJkIGZyb20gJy4vc2hhcmVkL2xheW91dC9NYWluQm9hcmQnO1xuaW1wb3J0IGdhbWVzTWVudSBmcm9tICcuL2dhbWVzTWVudSc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgbG9naW5Nb2RhbCBmcm9tICcuL2xvZ2luTW9kYWwnO1xuaW1wb3J0IHNpZ251cE1vZGFsIGZyb20gJy4vc2lnbnVwTW9kYWwnO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MnO1xuXG52YXIgYmFja2dyb3VuZDtcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIGJvYXJkOiBmdW5jdGlvbihoZWFkZXIsIGNvbnRlbnQsIG92ZXJsYXkpIHtcbiAgICBiYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuICAgIHJldHVybiBoKCdkaXYudmlldy1jb250YWluZXInLCB7IGNsYXNzTmFtZTogYmdDbGFzcyhiYWNrZ3JvdW5kKSB9LCBbXG4gICAgICBoKE1haW5Cb2FyZCwgeyBoZWFkZXIgfSwgY29udGVudCksXG4gICAgICBoKE1lbnVWaWV3KSxcbiAgICAgIG92ZXJsYXlcbiAgICBdKTtcbiAgfSxcblxuXG4gIGZyZWU6IGZ1bmN0aW9uKGhlYWRlciwgY29udGVudCwgZm9vdGVyLCBvdmVybGF5KSB7XG4gICAgYmFja2dyb3VuZCA9IGJhY2tncm91bmQgfHwgc2V0dGluZ3MuZ2VuZXJhbC50aGVtZS5iYWNrZ3JvdW5kKCk7XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgIGgoJ2Rpdi52aWV3LWNvbnRhaW5lcicsIHsgY2xhc3NOYW1lOiBiZ0NsYXNzKGJhY2tncm91bmQpIH0sIFtcbiAgICAgICAgaCgnbWFpbiNwYWdlJywgeyBvbmNyZWF0ZTogaGFuZGxlTWVudU9wZW4gfSwgW1xuICAgICAgICAgIGgoJ2hlYWRlci5tYWluX2hlYWRlcicsIGhlYWRlciksXG4gICAgICAgICAgaCgnZGl2I2ZyZWVfY29udGVudC5jb250ZW50Lm5hdGl2ZV9zY3JvbGxlcicsIGNvbnRlbnQpLFxuICAgICAgICAgIGZvb3RlciA/IGgoJ2Zvb3Rlci5tYWluX2Zvb3RlcicsIGZvb3RlcikgOiBudWxsLFxuICAgICAgICAgIGgoJ2RpdiNtZW51LWNsb3NlLW92ZXJsYXkubWVudS1iYWNrZHJvcCcsIHsgb25jcmVhdGU6IG1lbnUuYmFja2Ryb3BDbG9zZUhhbmRsZXIgfSlcbiAgICAgICAgXSksXG4gICAgICAgIGgoTWVudVZpZXcpLFxuICAgICAgICBsb2dpbk1vZGFsLnZpZXcoKSxcbiAgICAgICAgc2lnbnVwTW9kYWwudmlldygpLFxuICAgICAgICBuZXdHYW1lRm9ybS52aWV3KCksXG4gICAgICAgIG92ZXJsYXlcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNZW51T3BlbigpIHtcbn1cblxuZnVuY3Rpb24gYmdDbGFzcyhiZ1RoZW1lKSB7XG4gIHJldHVybiBiZ1RoZW1lID09PSAnZGFyaycgfHwgYmdUaGVtZSA9PT0gJ2xpZ2h0JyA/IGJnVGhlbWUgOiAndHJhbnNwICcgKyBiZ1RoZW1lO1xufVxuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4uL3hocic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RhcnRTZWVraW5nKGNvbmYpIHtcbiAgICBkb1N0YXJ0U2Vla2luZyhjb25mKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZG9TdGFydFNlZWtpbmcoY29uZikge1xuICAvLyByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wdXNoKHVzZXJDYW5jZWxTZWVraW5nKTtcblxuICBzZW5kSG9vayhjb25mKTtcbn1cblxuZnVuY3Rpb24gc2VuZEhvb2soc2V0dXApIHtcbiAgeGhyLnNlZWtHYW1lKHNldHVwKVxuICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coZGF0YSk7XG4gICAgICByb3V0ZXIuc2V0KCcvbWFzYS8nICsgZGF0YS5pZCk7XG4gICAgfSkuY2F0Y2godXRpbHMuaGFuZGxlWGhyRXJyb3IpO1xufVxuXG4vLyBpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG4vLyBpbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi4veGhyJztcbi8vIGltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG4vLyBsZXQgbmJQbGF5ZXJzID0gMDtcbi8vIGxldCBuYkdhbWVzID0gMDtcblxuLy8gY29uc3QgbG9iYnkgPSB7fTtcbi8vIGxvYmJ5LmlzT3BlbiA9IGZhbHNlO1xuXG4vLyBsb2JieS5zdGFydFNlZWtpbmcgPSBmdW5jdGlvbigpIHtcbi8vICAgeGhyLm5ld0dhbWUoKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbi8vICAgICAvLyBhbmFseXRpY3Ncbi8vICAgICBtLnJvdXRlKCcvbWFzYS8nICsgZGF0YS5pZCk7XG4vLyAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4vLyAgICAgdXRpbHMuaGFuZGxlWGhyRXJyb3IoZXJyb3IpO1xuLy8gICAgIHRocm93IGVycm9yO1xuLy8gICB9KTtcbi8vIH07XG5cblxuLy8gZXhwb3J0IGRlZmF1bHQgbG9iYnk7XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uL3Nlc3Npb24nO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgc2lnbmFscyBmcm9tICcuLi9zaWduYWxzJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgeyBoYW5kbGVYaHJFcnJvciB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uL2JhY2tidXR0b24nO1xuaW1wb3J0IHNpZ251cE1vZGFsIGZyb20gJy4vc2lnbnVwTW9kYWwnO1xuaW1wb3J0IHsgY2xvc2VJY29uIH0gZnJvbSAnLi9zaGFyZWQvaWNvbnMnO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi9yb3V0ZXInO1xuXG5sZXQgaXNPcGVuID0gZmFsc2U7XG5sZXQgZm9ybUVycm9yID0gbnVsbDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvcGVuLFxuICBjbG9zZSxcbiAgdmlldygpIHtcbiAgICBpZiAoIWlzT3BlbikgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gaCgnZGl2Lm1vZGFsI2xvZ2luTW9kYWwnLCB7IG9uY3JlYXRlOiBoZWxwZXIuc2xpZGVzSW5VcCB9LCBbXG4gICAgICBoKCdoZWFkZXInLCBbXG4gICAgICAgIGgoJ2J1dHRvbi5tb2RhbF9jbG9zZScsIHtcbiAgICAgICAgICBvbmNyZWF0ZTogaGVscGVyLm9udGFwKGhlbHBlci5zbGlkZXNPdXREb3duKGNsb3NlLCAnbG9naW5Nb2RhbCcpKVxuICAgICAgICB9LCBjbG9zZUljb24pLFxuICAgICAgICBoKCdoMicsIGkxOG4oJ3NpZ25JbicpKVxuICAgICAgXSksXG4gICAgICBoKCdkaXYubW9kYWxfY29udGVudCcsIFtcbiAgICAgICAgaCgnZm9ybS5sb2dpbicsIHtcbiAgICAgICAgICBvbnN1Ym1pdDogKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHN1Ym1pdChlLnRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgZm9ybUVycm9yID8gaCgnZGl2LmZvcm0tZXJyb3InLCBmb3JtRXJyb3IpOiBudWxsLFxuICAgICAgICAgIGgoJ2Rpdi5maWVsZCcsIFtcbiAgICAgICAgICAgIGgoJ2lucHV0I3VzZXJuYW1lJywge1xuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogZm9ybUVycm9yID8gJ2Zvcm0tZXJyb3InOicnLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bigndXNlcm5hbWUnKSxcbiAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuICAgICAgICAgICAgICBhdXRvY29ycmVjdDogJ29mZicsXG4gICAgICAgICAgICAgIHNwZWxsY2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgICAgICBoKCdpbnB1dCNwYXNzd29yZCcsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBmb3JtRXJyb3I/ICdmb3JtLWVycm9yJzonJyxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3Bhc3N3b3JkJyksXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIGgoJ2Rpdi5zdWJtaXQnLCBbXG4gICAgICAgICAgICBoKCdidXR0b24uc3VibWl0QnV0dG9uW2RhdGEtaWNvbj1GXScsIGkxOG4oJ3NpZ25JbicpKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pLFxuICAgICAgICBoKCdkaXYuc2lnbnVwJywgW1xuICAgICAgICAgIGkxOG4oJ25ld1RvT3l1bmtleWYnKSArICcgJyxcbiAgICAgICAgICBoKCdicicpLFxuICAgICAgICAgIGgoJ2EnLCB7XG4gICAgICAgICAgICBvbmNyZWF0ZTogaGVscGVyLm9udGFwKHNpZ251cE1vZGFsLm9wZW4pXG4gICAgICAgICAgfSwgW2kxOG4oJ3NpZ25VcCcpXSlcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgXSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG9wZW4oKSB7XG4gIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24oY2xvc2UsICdsb2dpbk1vZGFsJykpO1xuICBpc09wZW4gPSB0cnVlO1xuICBmb3JtRXJyb3IgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjbG9zZShmcm9tQkIpIHtcbiAgd2luZG93LktleWJvYXJkLmhpZGUoKTtcbiAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGlzT3Blbikgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4gIGlzT3BlbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdWJtaXQoZm9ybSkge1xuICBjb25zdCB1c2VybmFtZSA9IGZvcm1bJ3VzZXJuYW1lJ10udmFsdWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gZm9ybVsncGFzc3dvcmQnXS52YWx1ZTtcbiAgaWYgKCF1c2VybmFtZSB8fCAhcGFzc3dvcmQpIHJldHVybjtcblxuICByZWRyYXcoKTtcbiAgd2luZG93LktleWJvYXJkLmhpZGUoKTtcbiAgc2Vzc2lvbi5sb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgY2xvc2UoKTtcbiAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bignbG9naW5TdWNjZXNzZnVsJyksICdzaG9ydCcsICdjZW50ZXInKTtcbiAgICAgIHNpZ25hbHMuYWZ0ZXJMb2dpbi5kaXNwYXRjaCgpO1xuICAgICAgcmVkcmF3KCk7XG4gICAgICBzb2NrZXQucmVjb25uZWN0Q3VycmVudCgpO1xuICAgICAgc2Vzc2lvbi5yZWZyZXNoKCk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5zdGF0dXMgIT09IDQwMCAmJiBlcnIuc3RhdHVzICE9PSA0MDEpIGhhbmRsZVhockVycm9yKGVycik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVyci5ib2R5Lmdsb2JhbCkge1xuICAgICAgICAgIGZvcm1FcnJvciA9IGVyci5ib2R5Lmdsb2JhbFswXTtcbiAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICBcbn1cblxuXG4vLyBPTERcblxuY29uc3QgbG9naW5Nb2RhbCA9IHt9O1xuXG5mdW5jdGlvbiBzdWJtaXRPTEQoZm9ybSkge1xuICBjb25zdCBsb2dpbiA9IGZvcm1bMF0udmFsdWUudHJpbSgpO1xuICBjb25zdCBwYXNzID0gZm9ybVsxXS52YWx1ZTtcbiAgaWYgKCFsb2dpbiB8fCAhcGFzcykgcmV0dXJuIGZhbHNlO1xuICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmNsb3NlKCk7XG4gIHJldHVybiBzZXNzaW9uLmxvZ2luKGxvZ2luLCBwYXNzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIGxvZ2luTW9kYWwuY2xvc2UoKTtcbiAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ2xvZ2luU3VjY2Vzc2Z1bCcpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4gICAgLy8gcHVzaC5yZWdpc3RlcigpO1xuICAgIHNlc3Npb24ucmVmcmVzaCgpXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWxvY2UvbGljaG9iaWxlL2Jsb2IvbWFzdGVyL3Byb2plY3Qvc3JjL2pzL3VpL2xvZ2luTW9kYWwuanMjTDI4XG4gICAgICAgICAgd2luZG93Lm5hdmlnYXRvci5ub3RpZmljYXRpb24uYWxlcnQoJ295dW5rZXlmQXV0aGVudGljYXRpb25DYW5ub3RXb3JrV2l0aG91dENvb2tpZXMnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pXG4gICAgLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbn1cblxubG9naW5Nb2RhbC5vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGJhY2tidXR0b24uc3RhY2sucHVzaChoZWxwZXIuc2xpZGVzT3V0RG93bihsb2dpbk1vZGFsLmNsb3NlLCAnbG9naW5Nb2RhbCcpKTtcbiAgaXNPcGVuID0gdHJ1ZTtcbn07XG5cbmxvZ2luTW9kYWwuY2xvc2UgPSBmdW5jdGlvbihmcm9tQkIpIHtcbiAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5jbG9zZSgpO1xuICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgaXNPcGVuKSBiYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBpc09wZW4gPSBmYWxzZTtcbn07XG5cbmxvZ2luTW9kYWwudmlldyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWlzT3BlbikgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIG0oJ2Rpdi5tb2RhbCNsb2dpbk1vZGFsJywgeyBjb25maWc6IGhlbHBlci5zbGlkZXNJblVwIH0sIFtcbiAgICBtKCdoZWFkZXInLCBbXG4gICAgICBtKCdidXR0b24ubW9kYWxfY2xvc2VbZGF0YS1pY29uPUxdJywge1xuICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKGhlbHBlci5zbGlkZXNPdXREb3duKGxvZ2luTW9kYWwuY2xvc2UsICdsb2dpbk1vZGFsJykpXG4gICAgICB9KSxcbiAgICAgIG0oJ2gyJywgaTE4bignc2lnbkluJykpXG4gICAgXSksXG4gICAgbSgnZGl2Lm1vZGFsX2NvbnRlbnQnLCBbXG4gICAgICBtKCdmb3JtLmxvZ2luJywge1xuICAgICAgICBvbnN1Ym1pdDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gc3VibWl0KGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSwgW1xuICAgICAgICBtKCdpbnB1dCNwc2V1ZG9bdHlwZT10ZXh0XScsIHtcbiAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bigndXNlcm5hbWUnKSxcbiAgICAgICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiAnb2ZmJyxcbiAgICAgICAgICBhdXRvY29ycmVjdDogJ29mZicsXG4gICAgICAgICAgc3BlbGxjaGVjazogJ2ZhbHNlJyxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgbSgnaW5wdXQjcGFzc3dvcmRbdHlwZT1wYXNzd29yZF0nLCB7XG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3Bhc3N3b3JkJyksXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIG0oJ2J1dHRvbi5mYXQnLCBpMThuKCdzaWduSW4nKSlcbiAgICAgIF0pLFxuICAgICAgbSgnZGl2LnNpZ251cCcsIFtcbiAgICAgICAgbSgnYScsIHtcbiAgICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKHNpZ251cE1vZGFsLm9wZW4pXG4gICAgICAgIH0sIFtpMThuKCduZXdUb095dW5rZXlmJyksICcgJywgaTE4bignc2lnblVwJyldKVxuICAgICAgXSlcbiAgICBdKVxuICBdKTtcbn07XG5cbi8vIGV4cG9ydCBkZWZhdWx0IGxvZ2luTW9kYWw7XG4iLCJpbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgeyBoYW5kbGVYaHJFcnJvciB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuL21hc2FYaHInO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXNhc0xpc3RDdHJsKGRlZmF1bHRUYWIpIHtcbiAgdGhpcy5jdXJyZW50VGFiID0gZGVmYXVsdFRhYiB8fCAwO1xuXG4gIHhoci5jdXJyZW50TWFzYXMoKVxuICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgdGhpcy5tYXNhcyA9IGRhdGE7XG4gICAgICByZWRyYXcoKTtcbiAgICB9KS5jYXRjaChoYW5kbGVYaHJFcnJvcik7XG5cbiAgdGhpcy5vblRhYkNoYW5nZSA9ICh0YWJJbmRleCkgPT4ge1xuICAgIGNvbnN0IGxvYyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gucmVwbGFjZSgvXFw/dGFiXFw9XFx3KyQvLCAnJyk7XG5cbiAgICB0cnkge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgbG9jICsgJz90YWI9JyArIHRhYkluZGV4KTtcbiAgICB9IGNhdGNoIChlKSB7IGNvbnNvbGUuZXJyb3IoZSk7IH1cbiAgICB0aGlzLmN1cnJlbnRUYWIgPSB0YWJJbmRleDtcbiAgICByZWRyYXcoKTtcbiAgfTtcblxufVxuIiwiaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi4vbWFzYVhocic7XG5pbXBvcnQgZmFxIGZyb20gJy4uL2ZhcSc7XG5pbXBvcnQgc29ja2V0SGFuZGxlciBmcm9tICcuL3NvY2tldEhhbmRsZXInO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi8uLi9yb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXNhQ3RybChpZCkge1xuXG4gIHRoaXMuaWQgPSBpZDtcblxuICB0aGlzLmZhcUN0cmwgPSBmYXEuY29udHJvbGxlcih0aGlzKTtcbiAgXG4gIHhoci5tYXNhKGlkKS50aGVuKChkYXRhKSA9PiB7XG4gICAgdGhpcy5tYXNhID0gZGF0YTtcbiAgICB0aGlzLnNlYXRJZCA9IGRhdGEuc2VhdElkO1xuXG4gICAgdGhpcy5zdGFydHNBdCA9IHdpbmRvdy5tb21lbnQoZGF0YS5zdGFydHNBdCkuY2FsZW5kYXIoKTtcbiAgICBsb2FkQ3VycmVudFBhZ2UodGhpcy5tYXNhLnN0YW5kaW5nKTtcbiAgICB0aGlzLmhhc0pvaW5lZCA9ICEhKGRhdGEubWUgJiYgIWRhdGEubWUud2l0aGRyYXcpO1xuXG4gICAgc29ja2V0LmNyZWF0ZU1hc2EoXG4gICAgICB0aGlzLmlkLFxuICAgICAgdGhpcy5tYXNhLnNvY2tldFZlcnNpb24sXG4gICAgICBzb2NrZXRIYW5kbGVyKHRoaXMpKTtcblxuICAgIHJlZHJhdygpO1xuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKGVyci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgdGhpcy5ub3RGb3VuZCA9IHRydWU7XG4gICAgICByZWRyYXcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbHMuaGFuZGxlWGhyRXJyb3IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuaW52aXRlID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgIHhoci5pbnZpdGUodGhpcy5tYXNhLmlkKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0pLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbiAgfSwgMTAwMCk7XG5cbiAgdGhpcy5qb2luID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgIHhoci5qb2luKHRoaXMubWFzYS5pZClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5oYXNKb2luZWQgPSB0cnVlO1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0pLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbiAgfSwgMTAwMCk7XG5cbiAgdGhpcy53aXRoZHJhdyA9IHRocm90dGxlKCgpID0+IHtcbiAgICB4aHIud2l0aGRyYXcodGhpcy5tYXNhLmlkKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhc0pvaW5lZCA9IGZhbHNlO1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0pLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbiAgfSwgMTAwMCk7XG5cbiAgdGhpcy5yZWxvYWQgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgeGhyLnJlbG9hZCh0aGlzLmlkKVxuICAgICAgLnRoZW4ob25SZWxvYWQpXG4gICAgICAuY2F0Y2gob25YaHJFcnJvcik7XG4gIH0sIDIwMDApO1xuXG5cbiAgdGhpcy51bmxvYWQgPSAoKSA9PiB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgdGhpcy5yZWxvYWQpO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVsb2FkID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5tYXNhO1xuICAgIHRoaXMubWFzYSA9IGRhdGE7XG4gICAgdGhpcy5zZWF0SWQgPSBkYXRhLnNlYXRJZDtcbiAgICBsb2FkQ3VycmVudFBhZ2UoZGF0YS5zdGFuZGluZyk7XG4gICAgdGhpcy5oYXNKb2luZWQgPSAhIShkYXRhLm1lICYmICFkYXRhLm1lLndpdGhkcmF3KTtcbiAgICByZWRpcmVjdFRvTXlHYW1lKCk7XG4gICAgcmVkcmF3KCk7XG4gIH07XG5cbiAgY29uc3QgcmVkaXJlY3RUb015R2FtZSA9ICgpID0+IHtcbiAgICB2YXIgZ2FtZUlkID0gbXlDdXJyZW50R2FtZUlkKHRoaXMpO1xuICAgIGlmIChnYW1lSWQpXG4gICAgICByb3V0ZXIuc2V0KCcvbWFzYS8nICsgdGhpcy5tYXNhLmlkICsgJy9nYW1lLycgKyBnYW1lSWQsIHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IG15Q3VycmVudEdhbWVJZCA9IChjdHJsKSA9PiB7XG4gICAgdmFyIGlkcyA9IHtcbiAgICAgIGNyZWF0ZWQ6IDEwLFxuICAgICAgc3RhcnRlZDogMjAsXG4gICAgICBhYm9ydGVkOiAyNVxuICAgIH07XG5cbiAgICB2YXIgc2VhdElkID0gY3RybC5zZWF0SWQ7XG4gICAgaWYgKCFzZWF0SWQpIHJldHVybiBudWxsO1xuICAgIHZhciBwYWlyaW5nID0gY3RybC5tYXNhLnBhaXJpbmdzLmZpbHRlcihwID0+IHtcbiAgICAgIHJldHVybiBwLnMgPCBpZHMuYWJvcnRlZCAmJiAoXG4gICAgICAgIHAudS5maWx0ZXIoKGlkKSA9PiBpZC50b0xvd2VyQ2FzZSgpID09PSBzZWF0SWQudG9Mb3dlckNhc2UoKSlbMF1cbiAgICAgICk7XG4gICAgfSlbMF07XG4gICAgcmV0dXJuIHBhaXJpbmcgPyBwYWlyaW5nLmlkIDogbnVsbDtcbiAgfTtcblxuICBjb25zdCBvblhockVycm9yID0gKGVycikgPT4ge1xuICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHRoaXMubm90Rm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICByZWRyYXcoKTtcbiAgfTtcblxuICBjb25zdCBsb2FkQ3VycmVudFBhZ2UgPSAoZGF0YSkgPT4ge1xuICAgIHRoaXMuY3VycmVudFBhZ2VSZXN1bHRzID0gZGF0YS5wbGF5ZXJzO1xuICB9O1xufVxuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi8uLi9pMThuJztcbmltcG9ydCB7IGRyb3BTaGFkb3dIZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uLCBjb25uZWN0aW5nRHJvcFNoYWRvd0hlYWRlciB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uLy4uL2hlbHBlcic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uLy4uL2xheW91dCc7XG5pbXBvcnQgeyBtYXNhQm9keSwgcmVuZGVyRkFRT3ZlcmxheSwgcmVuZGVyRm9vdGVyLCB0aW1lSW5mbyB9IGZyb20gJy4vbWFzYVZpZXcnO1xuXG5pbXBvcnQgTWFzYUN0cmwgZnJvbSAnLi9NYXNhQ3RybCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KHthdHRyc30pIHtcbiAgICB0aGlzLmN0cmwgPSBuZXcgTWFzYUN0cmwoYXR0cnMuaWQpO1xuICB9LFxuICBvbmNyZWF0ZTogaGVscGVyLnZpZXdTbGlkZUluLFxuICBvbnJlbW92ZSgpIHtcbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgIHRoaXMuY3RybC51bmxvYWQoKTtcbiAgfSxcbiAgdmlldygpIHtcbiAgICBpZiAodGhpcy5jdHJsLm5vdEZvdW5kKSB7XG4gICAgICByZXR1cm4gbGF5b3V0LmZyZWUoXG4gICAgICAgIGhlYWRlcldpZGdldChudWxsLCBiYWNrQnV0dG9uKGkxOG4oJ21hc2FOb3RGb3VuZCcpKSksXG4gICAgICAgIGgoJ2Rpdi5tYXNhTm90Rm91bmQnLCB7IGtleTogJ21hc2Etbm90LWZvdW5kJyB9LCBbXG4gICAgICAgICAgaCgncCcsIGkxOG4oJ21hc2FEb2VzTm90RXhpc3QnKSksXG4gICAgICAgICAgaCgncCcsIGkxOG4oJ21hc2FNYXlIYXZlQmVlbkNhbmNlbGVkJykpXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG1hc2EgPSB0aGlzLmN0cmwubWFzYTtcbiAgICBsZXQgaGVhZGVyO1xuXG4gICAgaWYgKG1hc2EpIHtcbiAgICAgIGhlYWRlciA9IGhlYWRlcldpZGdldChudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tCdXR0b24oaCgnZGl2Lm1haW5faGVhZGVyX3RpdGxlLndpdGhTdWInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdoMScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnc3Bhbi5mYS5mYS10cm9waHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHJsLm1hc2EuZnVsbE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnaDIuaGVhZGVyLXN1YlRpdGxlLm1hc2Etc3ViVGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbWFzYS5pc0ZpbmlzaGVkICYmICFtYXNhLmlzU3RhcnRlZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVJbmZvKCdjcmVhdGVkJywgbWFzYS5wbGF5ZXJzVG9TdGFydCwgJ095dW5jdSBiZWtsZW5peW9yJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lSW5mbygnc3RhcnRlZCcsIG1hc2Eucm91bmRzVG9GaW5pc2gsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlciA9IGNvbm5lY3RpbmdEcm9wU2hhZG93SGVhZGVyKCk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IG1hc2FCb2R5KHRoaXMuY3RybCk7XG4gICAgY29uc3QgZm9vdGVyID0gcmVuZGVyRm9vdGVyKHRoaXMuY3RybCk7XG4gICAgY29uc3QgZmFxT3ZlcmxheSA9IHJlbmRlckZBUU92ZXJsYXkodGhpcy5jdHJsKTtcbiAgICBjb25zdCBvdmVybGF5ID0gW1xuICAgICAgZmFxT3ZlcmxheVxuICAgIF07XG5cbiAgICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCBib2R5LCBmb290ZXIsIG92ZXJsYXkpO1xuICB9XG59O1xuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uLy4uL3JvdXRlcic7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi8uLi9zZXNzaW9uJztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uLy4uL2kxOG4nO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uLy4uL2hlbHBlcic7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MnO1xuXG5pbXBvcnQgZmFxIGZyb20gJy4uL2ZhcSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJGQVFPdmVybGF5KGN0cmwpIHtcbiAgcmV0dXJuIFtcbiAgICBmYXEudmlldyhjdHJsLmZhcUN0cmwpXG4gIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXNhQm9keShjdHJsKSB7XG4gIGNvbnN0IGRhdGEgPSBjdHJsLm1hc2E7XG4gIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIGgoJ2Rpdi5tYXNhQ29udGFpbmVyLm5hdGl2ZV9zY3JvbGxlci5wYWdlJywgW1xuICAgIG1hc2FIZWFkZXIoZGF0YSwgY3RybCksXG4gICAgZGF0YS5wb2RpdW0gPyBtYXNhUG9kaXVtKGRhdGEucG9kaXVtKTogbnVsbCxcbiAgICBtYXNhTGVhZGVyYm9hcmQoY3RybClcbiAgXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJGb290ZXIoY3RybCkge1xuICBjb25zdCBtID0gY3RybC5tYXNhO1xuICBpZiAoIW0pIHJldHVybiBudWxsO1xuICBjb25zdCBtVXJsID0gJ2h0dHBzOi8vb3l1bmtleWYubmV0L21hc2EvJyArIG0uaWQ7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbnNfYmFyXCI+XG4gICAgICA8YnV0dG9uIGtleT1cImZhcVwiIGNsYXNzTmFtZT1cImFjdGlvbl9iYXJfYnV0dG9uXCIgb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLmZhcUN0cmwub3Blbil9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1xdWVzdGlvbi1jaXJjbGVcIi8+XG4gICAgICAgICAgU1NTXG4gICAgICA8L2J1dHRvbj5cbiAgICAgIHtjdHJsLmhhc0pvaW5lZCA/IHdpdGhkcmF3QnV0dG9uKGN0cmwsIG0pIDogam9pbkJ1dHRvbihjdHJsLCBtKSB9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lSW5mbyhrZXksIHJvdW5kcywgcHJlY2VlZGluZ1RleHQpIHtcbiAgaWYgKHJvdW5kcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gW1xuICAgIHByZWNlZWRpbmdUZXh0ID8gKHByZWNlZWRpbmdUZXh0ICsgJyAnKSA6IG51bGwsXG4gICAgLy8gaChcbiAgXTtcbn1cblxuZnVuY3Rpb24gbWFzYUhlYWRlcihkYXRhLCBjdHJsKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBrZXk9XCJoZWFkZXJcIiBjbGFzc05hbWU9XCJtYXNhSGVhZGVyXCI+XG4gICAgICB7bWFzYVRpbWVJbmZvKGRhdGEpfVxuICAgIHttYXNhQ3JlYXRvckluZm8oZGF0YSwgY3RybC5zdGFydHNBdCl9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hc2FUaW1lSW5mbyhkYXRhKSB7XG4gIGNvbnN0IHZhcmlhbnQgPSBkYXRhLnZhcmlhbnQ7XG4gIGNvbnN0IGNvbnRyb2wgPSBkYXRhLnNjb3JlcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2FUaW1lSW5mb1wiPlxuICAgICAgPHN0cm9uZyBjbGFzc05hbWU9XCJtYXNhSW5mbyB3aXRoSWNvblwiPlxuICAgICAgICB7IHZhcmlhbnQgKyAnIOKAoiAnICsgY29udHJvbCB9XG4gICAgICA8L3N0cm9uZz5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFzYUNyZWF0b3JJbmZvKGRhdGEsIHN0YXJ0c0F0KSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhQ3JlYXRvckluZm9cIj5cbiAgICAgIHtpMThuKCdieScsIGRhdGEuY3JlYXRlZEJ5KX1cbiAgICAgICZuYnNwO+KAoiZuYnNwO3tzdGFydHNBdH1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gam9pbkJ1dHRvbihjdHJsLCBtKSB7XG4gIGlmICghc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpIHx8IG0uaXNGaW5pc2hlZCkgeyByZXR1cm4gbnVsbDsgfVxuICBjb25zdCBhY3Rpb24gPSAoKSA9PiBjdHJsLmpvaW4oKTtcbiAgcmV0dXJuIChcbiAgICAgIDxidXR0b24ga2V5PVwiam9pblwiIGNsYXNzTmFtZT1cImFjdGlvbl9iYXJfYnV0dG9uXCIgb25jcmVhdGU9e2hlbHBlci5vbnRhcChhY3Rpb24pfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcGxheVwiLz5cbiAgICAgICAge2kxOG4oJ2pvaW4nKX1cbiAgICAgIDwvYnV0dG9uPlxuICApOyAgXG59XG5cbmZ1bmN0aW9uIHdpdGhkcmF3QnV0dG9uKGN0cmwsIG0pIHtcbiAgaWYgKG0uaXNGaW5pc2hlZCkgeyByZXR1cm4gbnVsbDsgfVxuICByZXR1cm4gKFxuICAgIDxidXR0b24ga2V5PVwid2l0aGRyYXdcIiBjbGFzc05hbWU9XCJhY3Rpb25fYmFyX2J1dHRvblwiIG9uY3JlYXRlPXtoZWxwZXIub250YXAoY3RybC53aXRoZHJhdyl9PlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtZmxhZ1wiLz5cbiAgICAgIHtpMThuKCd3aXRoZHJhdycpfVxuICAgIDwvYnV0dG9uPlxuICApO1xufVxuXG5mdW5jdGlvbiBtYXNhTGVhZGVyYm9hcmQoY3RybCkge1xuXG4gIGNvbnN0IGRhdGEgPSBjdHJsLm1hc2E7XG4gIGNvbnN0IHBsYXllcnMgPSBjdHJsLmN1cnJlbnRQYWdlUmVzdWx0cztcbiAgY29uc3QgdXNlciA9IHNlc3Npb24uZ2V0KCk7XG4gIGNvbnN0IHVzZXJOYW1lID0gdXNlciA/IHVzZXIudXNlcm5hbWUgOiAnJztcbiAgXG4gIHJldHVybiAoXG4gICAgPGRpdiBrZXk9XCJsZWFkZXJib2FyZFwiIGNsYXNzTmFtZT1cIm1hc2FMZWFkZXJib2FyZFwiPlxuICAgICAgeyBkYXRhLm5iUGxheWVycyA+IDAgP1xuICAgICAgICA8cCBjbGFzc05hbWU9XCJtYXNhVGl0bGVcIj4ge2kxOG4oXCJsZWFkZXJib2FyZFwiKX0gKHtpMThuKCduYkNvbm5lY3RlZFBsYXllcnMnLCBkYXRhLm5iUGxheWVycyl9KTwvcD4gOiBudWxsIH1cbiAgICAgIDx1bCBjbGFzc05hbWU9eydtYXNhU3RhbmRpbmdzJ30+XG4gICAgICB7cGxheWVycy5tYXAocCA9PiByZW5kZXJQbGF5ZXJFbnRyeShjdHJsLCB1c2VyTmFtZSwgcCkpfVxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGxheWVyRW50cnkoY3RybCwgdXNlck5hbWUsIHBsYXllcikge1xuICBjb25zdCBpc01lID0gcGxheWVyLm5hbWUgPT09IHVzZXJOYW1lO1xuXG4gIHJldHVybiAoXG4gICAgKCFwbGF5ZXIuYWN0aXZlKSA/IChcbiAgICAgIDxsaSBrZXk9e3BsYXllci5pZH0gY2xhc3NOYW1lPXsnbGlzdC1pdGVtIG1hc2EtbGlzdC1wbGF5ZXInfT5cbiAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2FQbGF5ZXJcIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZsYWdSYW5rXCIgZGF0YS1pY29uPXtwbGF5ZXIud2l0aGRyYXcgPyAnYic6Jyd9PiB7cGxheWVyLndpdGhkcmF3ID8gJycgOiAocGxheWVyLnJhbmsgKyAnLiAnKX08L3NwYW4+XG4gICAgICAgICA8c3Bhbj4ge2kxOG4oJ2VtcHR5U2VhdCcpfTwvc3Bhbj5cbiAgICAgICAgIDxidXR0b24gb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLmludml0ZSl9PntpMThuKCdpbnZpdGVCb3QnKX08L2J1dHRvbj5cbiAgICAgICA8L2Rpdj5cbiAgICAgICA8c3BhbiBjbGFzc05hbWU9eydtYXNhUG9pbnRzICd9IGRhdGEtaWNvbj0nUSc+e3BsYXllci5zY29yZX08L3NwYW4+XG4gICAgICA8L2xpPlxuICAgICkgOlxuICAgIDxsaSBjbGFzc05hbWU9eydsaXN0LWl0ZW0gbWFzYS1saXN0LXBsYXllciAnICsgKGlzTWUgPyAnbWFzYS1tZScgOiAnJyl9ID5cbiAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2FQbGF5ZXJcIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZsYWdSYW5rXCIgZGF0YS1pY29uPXtwbGF5ZXIud2l0aGRyYXcgPyAnYic6Jyd9PiB7cGxheWVyLndpdGhkcmF3ID8gJycgOiAocGxheWVyLnJhbmsgKyAnLiAnKX08L3NwYW4+XG4gICAgICAgICA8c3Bhbj4geyEocGxheWVyLm5hbWUpID8gJ0Fub255bW91cycgOiBwbGF5ZXIubmFtZSArICcgKCcgKyBwbGF5ZXIucmF0aW5nICsgJykgJ308L3NwYW4+XG4gICAgICAgPC9kaXY+XG4gICAgICAgPHNwYW4gY2xhc3NOYW1lPXsnbWFzYVBvaW50cyAnfSBkYXRhLWljb249J1EnPntwbGF5ZXIuc2NvcmV9PC9zcGFuPlxuICAgIDwvbGk+XG4gICk7XG5cbn1cbiIsImltcG9ydCByZWRyYXcgZnJvbSAnLi4vLi4vLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vLi4vcm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY3RybCkge1xuICByZXR1cm4ge1xuICAgIHJlbG9hZDogY3RybC5yZWxvYWQsXG4gICAgcmVkaXJlY3QoZ2FtZUlkKSB7XG4gICAgICAvLyBkb2Vzbid0IGZpcmUgZm9yIG5ldyBqb2luXG4gICAgICBjb25zb2xlLmxvZyhcInJlZGlyZWN0XCIrZ2FtZUlkKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uLy4uL2JhY2tidXR0b24nO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uL3JvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29udHJvbGxlcjogZnVuY3Rpb24obWFzYSkge1xuICAgIGxldCBpc09wZW4gPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wdXNoKGNsb3NlKTtcbiAgICAgIGlzT3BlbiA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlKGZyb21CQikge1xuICAgICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGlzT3Blbikgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4gICAgICBpc09wZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3BlbixcbiAgICAgIGNsb3NlLFxuICAgICAgaXNPcGVuOiBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT3BlbjsgfSxcbiAgICAgIG1hc2FcbiAgICB9O1xuICB9LFxuICB2aWV3OiBmdW5jdGlvbihjdHJsKSB7XG4gICAgaWYgKCFjdHJsLmlzT3BlbigpKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBtYXNhID0gY3RybC5tYXNhO1xuXG4gICAgaWYgKCFtYXNhKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsXCIgaWQ9XCJtYXNhRmFxTW9kYWxcIiBjb25maWc9e2hlbHBlci5zbGlkZXNJblVwfT5cbiAgICAgICAgPGhlYWRlcj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIm1vZGFsX2Nsb3NlXCIgZGF0YS1pY29uPVwiTFwiXG4gICAgICAgICAgICAgICAgICBvbmNyZWF0ZT17aGVscGVyLm9udGFwKGhlbHBlci5zbGlkZXNPdXREb3duKGN0cmwuY2xvc2UsIFwibWFzYUZhcU1vZGFsXCIpKX0vPlxuICAgICAgICAgIDxoMj57aTE4bignbWFzYUZBUScpfTwvaDI+XG4gICAgICAgIDwvaGVhZGVyPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsX2NvbnRlbnRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2FGYXFcIj5cblxuICAgICAgICAgICAgPGgyPlB1YW5sxLEgbcSxPzwvaDI+XG5cbiAgICAgICAgICAgIHsgbWFzYS5yYXRlZCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICdCYXrEsSBtYXNhbGFyIHB1YW5sxLFkxLFyIHZlIHJleXRpbmdpbml6aSBldGtpbGVyLicgOlxuICAgICAgICAgICAgbWFzYS5yYXRlZCA/XG4gICAgICAgICAgICAgICdCdSBtYXNhIHB1YW5sxLFkxLFyIHZlIHJleXRpbmdpbml6aSBldGtpbGVyLicgOlxuICAgICAgICAgICAgICAnQnUgbWFzYSBwdWFubMSxICpkZcSfaWxkaXIqIHZlIHJleXRpbmdpbml6aSAqZXRraWxlbWV6Ki4nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIDxoMj4gUHVhbmxhciBuYXPEsWwgaGVzYXBsYW7EsXI/IDwvaDI+XG5cbiAgICAgICAgICAgIE1hc2F5YSBrYXTEsWzEsW1kYSBoZXIgb3l1bmN1IG9ydGF5YSBlbCBzYXnEsXPEsSBrYWRhciBwdWFuxLFuxLEga295YXIuIE1hc2Egc29udW5kYSBvcnRhZGFraSBwdWFubGFyIMWfw7Z5bGUgZGHEn8SxdMSxbMSxcjpcblxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICA8bGk+MS4gJTUwIHB1YW48L2xpPlxuICAgICAgICAgICAgICA8bGk+Mi4gJTI1IHB1YW48L2xpPlxuICAgICAgICAgICAgICA8bGk+My4gJTE1IHB1YW48L2xpPlxuICAgICAgICAgICAgICA8bGk+NC4gJTEwIHB1YW48L2xpPlxuICAgICAgICAgICAgPC91bD5cblxuICAgICAgICAgICAgw5ZybmXEn2luIDEwIGVsbGlrIGJpciBveXVuZGEgb3l1bmN1bGFyxLFuIHB1YW5sYXLEsSAxNTAwIG9sc3VuLlxuXG4gICAgICAgICAgICBNYXNheWEga2F0xLFsZMSxa2xhcsSxbmRhIHB1YW5sYXLEsSAxNDkwIG9sdXIuIE9ydGFkYSB0b3BsYW0gNDAgcHVhbiB2YXJkxLFyLCB2ZSDFn8O2eWxlIGRhxJ/EsXTEsWzEsXI6XG5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgPGxpPjEuICsyMCA9IDE1MTA8L2xpPlxuICAgICAgICAgICAgICA8bGk+Mi4gKzEwID0gMTUwMDwvbGk+XG4gICAgICAgICAgICAgIDxsaT4zLiArNiA9IDE0OTY8L2xpPlxuICAgICAgICAgICAgICA8bGk+NC4gKzQgPSAxNDk0PC9saT5cbiAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgIE1hc2EgYml0bWVkZW4gYXlyxLFsYW4gb3l1bmN1IHB1YW4gYWxhbWF6LlxuXG4gICAgICAgICAgICA8aDI+IEthemFuYW4gbmFzxLFsIGJlbGlybGVuaXI/IDwvaDI+XG5cbiAgICAgICAgICAgIE1hc2FkYSBiw7x0w7xuIGVsbGVyIG95bmFuZMSxa3RhbiBzb25yYSBlbiBheiBjZXphc8SxIG9sYW4gb3l1bmN1IGdhbGlwIGlsYW4gZWRpbGlyLlxuXG4gICAgICAgICAgICA8aDI+IE1hc2FkYSBlc2xlc3Rpcm1lIG5hc2lsIHlhcGlsaXI/IDwvaDI+XG5cbiAgICAgICAgICAgIE1hc2F5YSA0IG95dW5jdSBrYXRpbGRpZ2luZGEgZWwgYmFzbGFyLiBCaXIgZWwgYml0dGlrdGVuIHNvbnJhIHllbmkgZWwgYmFzbGFyLCB5ZW5pIGVsZSBrYXRpbG1hayBpY2luIG95dW5jdWxhciBtYXNheWEgZ2VyaSBkb25tZWxpZGlyLlxuXG4gICAgICAgICAgICA8aDI+IE1hc2EgbmUgemFtYW4gYml0ZXI/IDwvaDI+XG5cbiAgICAgICAgICAgIE1hc2FkYSBlbCBzYXnEsXPEsSBrYWRhciBveXVuIG95bmFuZMSxxJ/EsW5kYSBtYXNhIGJpdGVyLlxuXG4gICAgICAgICAgICA8aDI+IE95dW5kYW4gYXlyxLFsbWEgPC9oMj5cblxuICAgICAgICAgICAgT3l1biBkZXZhbSBlZGVya2VuIG95dW5kYW4gYXlyaWxhbiBveXVuY3UgbWFzYWRhbiBhdGlsaXIsIHZlIG8gZWwgaXB0YWwgb2x1ci4gTWFzYSBiaXRtZWRlbiBtYXNhZGFuIGF5csSxbGFuIG95dW5jdSBwdWFuIGFsYW1hei5cblxuICAgICAgICAgICAgPGgyPiBEacSfZXIgw7ZuZW1saSBrdXJhbGxhciA8L2gyPlxuXG4gICAgICAgICAgICBTaXJhbml6IGdlbGRpZ2luZGUsIG95YW5hbWEgc8O8cmVuaXppIGHFn2Fyc2FuxLF6IHNpc3RlbSBzaXppbiB5ZXJpbml6ZSBveW5hci5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59O1xuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCB7IHNhZmVTdHJpbmdUb051bSB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IHsgaGVhZGVyIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5cbmltcG9ydCBNYXNhc0xpc3RDdHJsIGZyb20gJy4vTWFzYXNMaXN0Q3RybCc7XG5pbXBvcnQgeyByZW5kZXJNYXNhc0xpc3QsIHJlbmRlckZvb3RlciB9IGZyb20gJy4vbWFzYXNMaXN0Vmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBvbmNyZWF0ZTogaGVscGVyLnZpZXdGYWRlSW4sXG5cbiAgb25pbml0KHsgYXR0cnMgfSkge1xuICAgIC8vIHNvY2tldC5jcmVhdGVEZWZhdWx0KClcblxuICAgIHRoaXMuY3RybCA9IG5ldyBNYXNhc0xpc3RDdHJsKHNhZmVTdHJpbmdUb051bShhdHRycy50YWIpKTtcbiAgfSxcblxuICB2aWV3KCkge1xuICAgIGNvbnN0IGN0cmwgPSB0aGlzLmN0cmw7XG4gICAgXG4gICAgY29uc3QgYm9keSA9IHJlbmRlck1hc2FzTGlzdChjdHJsKTtcbiAgICBjb25zdCBmb290ZXIgPSByZW5kZXJGb290ZXIoKTtcbiAgICBjb25zdCBvdmVybGF5ID0gbnVsbDtcbiAgICBcbiAgICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyKGkxOG4oJ21hc2FzJykpLCBib2R5LCBmb290ZXIsIG92ZXJsYXkpO1xuICB9XG5cbn07XG4iLCJpbXBvcnQgeyBmZXRjaEpTT04gfSBmcm9tICcuLi8uLi9odHRwJztcblxuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnRNYXNhcygpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL21hc2EnLCB7fSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXNhKGlkKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9tYXNhLycgKyBpZCwgeyBxdWVyeTogeyBzb2NrZXRWZXJzaW9uOiAxIH19LCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbG9hZChpZCwgcGFnZSkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvbWFzYS8nICsgaWQsIHsgbWV0aG9kOiAnR0VUJywgcXVlcnk6IHBhZ2UgPyB7IHBhZ2UgfToge319KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpvaW4oaWQpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL21hc2EvJysgaWQgKyAnL2pvaW4nLCB7IG1ldGhvZDogJ1BPU1QnIH0sIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52aXRlKGlkKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9tYXNhLycrIGlkICsgJy9pbnZpdGUnLCB7IG1ldGhvZDogJ1BPU1QnIH0sIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aGRyYXcoaWQpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL21hc2EvJysgaWQgKyAnL3dpdGhkcmF3JywgeyBtZXRob2Q6ICdQT1NUJyB9LCB0cnVlKTtcbn1cblxuLy8gaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJy4uLy4uL2h0dHAnO1xuXG4vLyBleHBvcnQgZnVuY3Rpb24gY3VycmVudE1hc2FzKCkge1xuLy8gICByZXR1cm4gcmVxdWVzdCgnL21hc2EnLCB7fSwgdHJ1ZSk7XG4vLyB9XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBtYXNhKGlkKSB7XG4vLyAgIHJldHVybiByZXF1ZXN0KCcvbWFzYS8nICsgaWQsIHsgZGF0YToge3NvY2tldFZlcnNpb246IDF9fSwgdHJ1ZSk7XG4vLyB9XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiByZWxvYWQoaWQpIHtcbi8vICAgcmV0dXJuIHJlcXVlc3QoJy9tYXNhLycgKyBpZCxcbi8vICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4vLyAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXG4vLyAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJ1ZVxuLy8gICAgICAgICAgICAgICAgICB9KTtcbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGpvaW4oaWQsIHNpZGUpIHtcbi8vICAgc2lkZSA9IHNpZGUgPyBgP3NpZGU9JHtzaWRlfWA6ICcnO1xuLy8gICByZXR1cm4gcmVxdWVzdCgnL21hc2EvJyArIGlkICsgJy9qb2luJyArIHNpZGUsIHsgbWV0aG9kOiAnUE9TVCcgfSwgdHJ1ZSk7XG4vLyB9XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiB3aXRoZHJhdyhpZCkge1xuLy8gICByZXR1cm4gcmVxdWVzdCgnL21hc2EvJyArIGlkICsgJy93aXRoZHJhdycsIHsgbWV0aG9kOiAnUE9TVCcgfSwgdHJ1ZSk7XG4vLyB9XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi9yb3V0ZXInO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgeyBjYXBpdGFsaXplIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IFRhYk5hdmlnYXRpb24gZnJvbSAnLi4vc2hhcmVkL1RhYk5hdmlnYXRpb24nO1xuaW1wb3J0IFRhYlZpZXcgZnJvbSAnLi4vc2hhcmVkL1RhYlZpZXcnO1xuXG5jb25zdCBUQUJTID0gW3tcbiAgbGFiZWw6ICdBw6fEsWsnXG59LCB7XG4gIGxhYmVsOiAnT3luYW5hbidcbn0sIHtcbiAgbGFiZWw6ICdCaXRlbidcbn0gIFxuXTtcblxuZnVuY3Rpb24gb25NYXNhVGFwKGUpIHtcbiAgY29uc3QgZWwgPSBoZWxwZXIuZ2V0TEkoZSk7XG4gIGNvbnN0IGRzID0gZWwuZGF0YXNldDtcbiAgaWYgKGVsICYmIGRzLmlkKSB7XG4gICAgcm91dGVyLnNldCgnL21hc2EvJyArIGRzLmlkKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWFzYXNMaXN0KGN0cmwpIHtcbiAgaWYgKCFjdHJsLm1hc2FzKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCB0YWJzQ29udGVudCA9IFtcbiAgICBjdHJsLm1hc2FzWydjcmVhdGVkJ10sXG4gICAgY3RybC5tYXNhc1snc3RhcnRlZCddLFxuICAgIGN0cmwubWFzYXNbJ2ZpbmlzaGVkJ10sXG4gIF07XG5cbiAgcmV0dXJuIFtcbiAgICBoKCdkaXYudGFicy1uYXYtaGVhZGVyLnN1YkhlYWRlcicsXG4gICAgICBoKFRhYk5hdmlnYXRpb24sIHtcbiAgICAgICAgYnV0dG9uczogVEFCUyxcbiAgICAgICAgc2VsZWN0ZWRJbmRleDogY3RybC5jdXJyZW50VGFiLFxuICAgICAgICBvblRhYkNoYW5nZTogY3RybC5vblRhYkNoYW5nZVxuICAgICAgfSksXG4gICAgICBoKCdkaXYubWFpbl9oZWFkZXJfZHJvcF9zaGFkb3cnKVxuICAgICApLFxuICAgIGgoVGFiVmlldywge1xuICAgICAgY2xhc3NOYW1lOiAnbWFzYVRhYnNXcmFwcGVyJyxcbiAgICAgIHNlbGVjdGVkSW5kZXg6IGN0cmwuY3VycmVudFRhYixcbiAgICAgIGNvbnRlbnQ6IHRhYnNDb250ZW50LFxuICAgICAgcmVuZGVyZXI6IHJlbmRlck1hc2FMaXN0LFxuICAgICAgb25UYWJDaGFuZ2U6IGN0cmwub25UYWJDaGFuZ2VcbiAgICB9KVxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWFzYUxpc3QobGlzdCkge1xuICByZXR1cm4gaCgndWwubmF0aXZlX3Njcm9sbGVyLm1hc2FMaXN0Jywge1xuICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXBYWShvbk1hc2FUYXAsIHVuZGVmaW5lZCwgaGVscGVyLmdldExJKVxuICB9LCBsaXN0Lm1hcChyZW5kZXJNYXNhTGlzdEl0ZW0pKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWFzYUxpc3RJdGVtKG1hc2EsIGluZGV4KSB7XG4gIGNvbnN0IG1vZGUgPSBtYXNhLnJhdGVkID8gaTE4bigncmF0ZWQnKSA6IGkxOG4oJ2Nhc3VhbCcpO1xuICBjb25zdCB2YXJpYW50ID0gY2FwaXRhbGl6ZShtYXNhLnZhcmlhbnQuc2hvcnQpO1xuICBjb25zdCBldmVuT3JPZGQgPSBpbmRleCAlIDIgPT09IDAgPyAnIGV2ZW4gJyA6ICcgb2RkICc7XG4gIGNvbnN0IHNjb3JlcyA9IG1hc2Euc2NvcmVzO1xuICBjb25zdCByb3VuZHMgPSBtYXNhLnJvdW5kcztcbiAgXG4gIHJldHVybiAoXG4gICAgICA8bGkga2V5PXttYXNhLmlkfVxuICAgICAgICAgIGNsYXNzTmFtZT17J2xpc3RfaXRlbSBtYXNhX2l0ZW0nICsgZXZlbk9yT2RkfVxuICAgICAgICAgIGRhdGEtaWQ9e21hc2EuaWR9XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWFzYUxpc3ROYW1lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmdWxsTmFtZVwiPnttYXNhLmZ1bGxOYW1lfTwvZGl2PlxuICAgICAgPHNtYWxsIGNsYXNzTmFtZT1cImluZm9zXCI+e3ZhcmlhbnR9IHttb2RlfSDigKIge3Njb3Jlcz9zY29yZXMgKyAnICcgKyBpMThuKCdwb2ludHMnKTppMThuKCdyb3VuZHMnLCByb3VuZHMpfTwvc21hbGw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2FMaXN0VGltZVwiPlxuICAgICAgICAgIDxzbWFsbCBjbGFzc05hbWU9XCJuYlVzZXJzIHdpdGhJY29uXCIgZGF0YS1pY29uPVwiclwiPnttYXNhLm5iUGxheWVyc308L3NtYWxsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbGk+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJGb290ZXIoKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zX2JhclwiPlxuICAgICAgPGJ1dHRvbiBrZXk9XCJjcmVhdGVNYXNhXCIgY2xhc3NOYW1lPVwiYWN0aW9uX2NyZWF0ZV9idXR0b25cIj5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcGx1cy1jaXJjbGVcIi8+XG4gICAgICAgIHtpMThuKCdjcmVhdGVBTmV3TWFzYScpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgc3RyZWFtIGZyb20gJ21pdGhyaWwvc3RyZWFtJztcbmltcG9ydCBaYW5pbW8gZnJvbSAnemFuaW1vJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uLy4uL2JhY2tidXR0b24nO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi9yb3V0ZXInO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgU2lkZU1lbnVDdHJsIGZyb20gJy4uL3NoYXJlZC9zaWRlTWVudS9TaWRlTWVudUN0cmwnO1xuaW1wb3J0IHsgb250YXAgfSBmcm9tICcuLi9oZWxwZXInO1xuXG5cbmV4cG9ydCBjb25zdCBwcm9maWxlTWVudU9wZW4gPSBzdHJlYW0oZmFsc2UpO1xuXG5mdW5jdGlvbiBvbk1lbnVPcGVuKCkge1xufVxuXG5mdW5jdGlvbiBvbk1lbnVDbG9zZSgpIHtcbn1cblxuXG5leHBvcnQgY29uc3QgbWFpbk1lbnVDdHJsID0gbmV3IFNpZGVNZW51Q3RybChcbiAgJ2xlZnQnLFxuICAnc2lkZV9tZW51JyxcbiAgJ21lbnUtY2xvc2Utb3ZlcmxheScsXG4gIG9uTWVudU9wZW4sXG4gIG9uTWVudUNsb3NlXG4pO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1haW5NZW51Q3RybC5jbG9zZSgpLnRoZW4oKCkgPT4gcm91dGVyLnNldChyb3V0ZSkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wdXAoYWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWFpbk1lbnVDdHJsLmNsb3NlKCkudGhlbigoKSA9PiB7XG4gICAgICBhY3Rpb24oKTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgYmFja2Ryb3BDbG9zZUhhbmRsZXIgPSBvbnRhcCgoKSA9PiB7XG4gIG1haW5NZW51Q3RybC5jbG9zZSgpO1xufSk7XG5cbmNvbnN0IG1lbnUgPSB7fTtcblxuLyogcHJvcGVydGllcyAqL1xubWVudS5pc09wZW4gPSBmYWxzZTtcbi8vIG1lbnUuaGVhZGVyT3BlbiA9IG0ucHJvcChmYWxzZSk7XG5cbm1lbnUucm91dGUgPSBmdW5jdGlvbihyb3V0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1lbnUuY2xvc2UoKS50aGVuKG0ucm91dGUuYmluZChudWxsLCByb3V0ZSkpO1xuICB9O1xufTtcblxubWVudS5wb3B1cCA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1lbnUuY2xvc2UoKS50aGVuKCgpID0+IHtcbiAgICAgIGFjdGlvbigpO1xuICAgICAgbS5yZWRyYXcoKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbm1lbnUudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChtZW51LmlzT3BlbikgbWVudS5jbG9zZSgpO1xuICBlbHNlIG1lbnUub3BlbigpO1xufTtcblxubWVudS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGJhY2tidXR0b24uc3RhY2sucHVzaChtZW51LmNsb3NlKTtcbiAgbWVudS5pc09wZW4gPSB0cnVlO1xufTtcblxubWVudS53aWxsQ2xvc2UgPSBmYWxzZTtcbm1lbnUuY2xvc2UgPSBmdW5jdGlvbihmcm9tQkIpIHtcbiAgY29uc3Qgc2lkZU1lbnUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2lkZV9tZW51Jyk7XG5cbiAgaWYgKG1lbnUud2lsbENsb3NlIHx8ICFzaWRlTWVudSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcblxuICBtZW51LndpbGxDbG9zZSA9IHRydWU7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBtZW51LmlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgbS5yZWRyYXcuc3RyYXRlZ3koJ25vbmUnKTtcbiAgcmV0dXJuIFphbmltbyhcbiAgICBzaWRlTWVudSxcbiAgICAndHJhbnNmb3JtJyxcbiAgICAndHJhbnNsYXRlM2QoLTEwMCUsMCwwJywgMjUwLCAnZWFzZS1vdXQnXG4gICkudGhlbigoKSA9PiB7XG4gICAgbWVudS5oZWFkZXJPcGVuKGZhbHNlKTtcbiAgICBtZW51LmlzT3BlbiA9IGZhbHNlO1xuICAgIG1lbnUud2lsbENsb3NlID0gZmFsc2U7XG4gICAgbS5yZWRyYXcoKTtcbiAgfSlcbiAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgbWVudS5oZWFkZXJPcGVuKGZhbHNlKTtcbiAgICAgIG1lbnUuaXNPcGVuID0gZmFsc2U7XG4gICAgICBtZW51LndpbGxDbG9zZSA9IGZhbHNlO1xuICAgICAgbS5yZWRyYXcoKTtcbiAgICB9KTtcbn07XG5cbm1lbnUudG9nZ2xlSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBtZW51LmhlYWRlck9wZW4oKSA/IG1lbnUuaGVhZGVyT3BlbihmYWxzZSkgOiBtZW51LmhlYWRlck9wZW4odHJ1ZSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtZW51O1xuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCBsb2dpbk1vZGFsIGZyb20gJy4uL2xvZ2luTW9kYWwnO1xuaW1wb3J0IG5ld0dhbWVGb3JtIGZyb20gJy4uL25ld0dhbWVGb3JtJztcbmltcG9ydCB7IGhhc05ldHdvcmssIG5vb3AgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBaYW5pbW8gZnJvbSAnemFuaW1vJztcbmltcG9ydCAqIGFzIG1lbnUgZnJvbSAnLic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25iZWZvcmV1cGRhdGUoKSB7XG4gICAgcmV0dXJuIG1lbnUubWFpbk1lbnVDdHJsLmlzT3BlbjtcbiAgfSxcblxuICB2aWV3KCkge1xuICAgIGNvbnN0IHVzZXIgPSBzZXNzaW9uLmdldCgpO1xuICAgIFxuICAgIHJldHVybiAoXG4gICAgICA8YXNpZGUgaWQ9XCJzaWRlX21lbnVcIj5cbiAgICAgICAge3JlbmRlckhlYWRlcih1c2VyKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXRpdmVfc2Nyb2xsZXIgc2lkZV9tZW51X3Njcm9sbGVyXCI+XG4gICAgICAgICAge3VzZXIgJiYgbWVudS5wcm9maWxlTWVudU9wZW4oKSA/IHJlbmRlclByb2ZpbGVBY3Rpb25zKHVzZXIpIDogcmVuZGVyTGlua3ModXNlcil9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9hc2lkZT5cblxuICAgICk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbmRlckhlYWRlcih1c2VyKSB7XG4gIGNvbnN0IHByb2ZpbGVMaW5rID0gdXNlciA/IG1lbnUucm91dGUoJy9ALycgKyB1c2VyLmlkKSA6IG5vb3A7XG5cbiAgcmV0dXJuIChcbiAgICA8aGVhZGVyIGNsYXNzTmFtZT1cInNpZGVfbWVudV9oZWFkZXJcIj5cbiAgICAgIHsgaGFzTmV0d29yaygpICYmICF1c2VyID9cbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJzaWduSW5CdXR0b25cIiBvbmNyZWF0ZT17aGVscGVyLm9udGFwWFkobG9naW5Nb2RhbC5vcGVuKX0+XG4gICAgICAgICAge2kxOG4oJ3NpZ25JbicpfVxuICAgICAgICA8L2J1dHRvbj4gOiBudWxsXG4gICAgICB9XG4gICAgICB7IHVzZXIgP1xuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidXNlcm5hbWVcIiBvbmNyZWF0ZT17aGVscGVyLm9udGFwWFkocHJvZmlsZUxpbmspfT5cbiAgICAgICAgICB7dXNlci51c2VybmFtZX1cbiAgICAgICAgPC9oMj4gOiBudWxsXG4gICAgICB9XG4gICAgPC9oZWFkZXI+XG4gICk7XG59XG5cblxuZnVuY3Rpb24gc2xpZGVzSW5VcChlbCwgaXNVcGRhdGUsIGNvbnRleHQpIHtcbiAgaWYgKCFpc1VwZGF0ZSkge1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknO1xuICAgIC8vIGZvcmNlIHJlZmxvdyBiYWNrXG4gICAgY29udGV4dC5sb2wgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScsIDI1MCwgJ2Vhc2Utb3V0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlua3ModXNlcikge1xuXG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT1cInNpZGVfbGlua3NcIlxuICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcFhZKG9uTGlua1RhcCwgdW5kZWZpbmVkLCBoZWxwZXIuZ2V0TEkpfT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBkYXRhLXJvdXRlPVwiL1wiPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1ob21lXCIgLz57aTE4bignaG9tZScpfVxuICAgICAgPC9saT5cbiAgICAgIHtoYXNOZXR3b3JrKCkgPyBcbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cInNlcF9saW5rXCIga2V5PVwic2VwX2xpbmtfb25saW5lXCI+e2kxOG4oJ3BsYXlPbmxpbmUnKX08L2xpPiA6IG51bGwgXG4gICAgICB9XG4gICAgICB7aGFzTmV0d29yaygpID9cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGRhdGEtcG9wdXA9XCJjcmVhdGVBR2FtZVwiPlxuICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcGx1cy1jaXJjbGVcIi8+e2kxOG4oJ2NyZWF0ZUFHYW1lJyl9XG4gICAgICAgIDwvbGk+IDogbnVsbCB9XG4gICAgICB7aGFzTmV0d29yaygpID8gPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGRhdGEtcm91dGU9XCIvbWFzYXNcIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXRyb3BoeVwiLz57aTE4bignbWFzYXMnKX1cbiAgICAgICA8L2xpPiA6IG51bGwgfVxuICAgICAge2hhc05ldHdvcmsoKSA/IDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBkYXRhLXJvdXRlPVwiL3BsYXllcnNcIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWF0XCIvPntpMThuKCdwbGF5ZXJzJyl9XG4gICAgICAgPC9saT4gOiBudWxsIH1cbiAgICAgIHtoYXNOZXR3b3JrKCkgPyA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgZGF0YS1yb3V0ZT1cIi9yYW5raW5nXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWN1YmVzXCIvPntpMThuKCdsZWFkZXJib2FyZCcpfVxuICAgICAgIDwvbGk+IDogbnVsbCB9XG4gICAgICAgPGxpIGNsYXNzTmFtZT1cImhyXCI+PC9saT5cbiAgICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgZGF0YS1yb3V0ZT1cIi9zZXR0aW5nc1wiPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1jb2dcIi8+e2kxOG4oJ3NldHRpbmdzJyl9XG4gICAgICAgPC9saT5cbiAgICA8L3VsPlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQcm9maWxlQWN0aW9ucyh1c2VyKSB7XG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT1cInNpZGVfbGlua3MgcHJvZmlsZUFjdGlvbnNcIj5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRvdWNoKG1lbnUucm91dGUoJy9ALycgKyB1c2VyLmlkKSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCJyXCIgLz5cbiAgICAgICAge2kxOG4oJ3Byb2ZpbGUnKX1cbiAgICAgIDwvbGk+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250b3VjaChtZW51LnJvdXRlKCcvc2V0dGluZ3MvcHJlZmVyZW5jZXMnKSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCIlXCIgLz5cbiAgICAgICAge2kxOG4oJ3ByZWZlcmVuY2VzJyl9XG4gICAgICA8L2xpPlxuICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGNvbmZpZz17aGVscGVyLm9udG91Y2goKCkgPT4ge1xuICAgICAgICBzZXNzaW9uLmxvZ291dCgpO1xuICAgICAgICBtZW51LmhlYWRlck9wZW4oZmFsc2UpO1xuICAgICAgfSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCJ3XCIgLz5cbiAgICAgICAge2kxOG4oJ2xvZ091dCcpfVxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICApO1xufVxuXG5jb25zdCBwb3B1cEFjdGlvbk1hcCA9IHtcbiAgJ2NyZWF0ZUFHYW1lJzogKCkgPT4gbmV3R2FtZUZvcm0ub3BlblJlYWx0aW1lKClcbn07XG5cbmZ1bmN0aW9uIG9uTGlua1RhcChlKSB7XG4gIGNvbnN0IGVsID0gaGVscGVyLmdldExJKGUpO1xuICBjb25zdCBkcyA9IGVsLmRhdGFzZXQ7XG4gIGlmIChlbCAmJiBkcy5yb3V0ZSkge1xuICAgIG1lbnUucm91dGUoZHMucm91dGUpKCk7XG4gIH0gZWxzZSBpZiAoZWwgJiYgZHMucG9wdXApIHtcbiAgICBtZW51LnBvcHVwKHBvcHVwQWN0aW9uTWFwW2RzLnBvcHVwXSkoKTtcbiAgfVxufVxuXG5cbi8vIE9MRFxuXG5mdW5jdGlvbiByZW5kZXJQcm9maWxlQWN0aW9uc09MRCh1c2VyKSB7XG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT1cInNpZGVfbGlua3MgcHJvZmlsZUFjdGlvbnNcIj5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRhcFhZKG1lbnUucm91dGUoJy9ALycgKyB1c2VyLmlkKSl9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS11c2VyXCIvPntpMThuKCdwcm9maWxlJyl9XG4gICAgPC9saT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRhcFhZKG1lbnUucm91dGUoJy9zZXR0aW5ncy9wcmVmZXJlbmNlcycpKX0+XG4gICAgICAgIDxzcGFuIGRhdGEtaWNvbj1cIiVcIiAvPntpMThuKCdwcmVmZXJlbmNlcycpfVxuICAgICAgPC9saT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRhcFhZKCgpID0+IHtcbiAgICAgICAgc2Vzc2lvbi5sb2dvdXQoKTtcbiAgICAgICAgbWVudS5wcm9maWxlTWVudU9wZW4oZmFsc2UpO1xuICAgICAgfSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCJ3XCIgLz5cbiAgICAgICAge2kxOG4oJ2xvZ091dCcpfVxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJNZW51KCkge1xuICBjb25zdCB1c2VyID0gc2Vzc2lvbi5nZXQoKTtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm5hdGl2ZV9zY3JvbGxlclwiPlxuICAgICAge3JlbmRlckhlYWRlcih1c2VyKX1cbiAgICAgIHsgdXNlciAmJiBtZW51LmhlYWRlck9wZW4oKSA/IHJlbmRlclByb2ZpbGVBY3Rpb25zKHVzZXIpIDogcmVuZGVyTGlua3ModXNlcikgfVxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgaHVtYW5TZXR1cEZyb21TZXR0aW5ncyB9IGZyb20gJy4uL295dW5rZXlmL3NldHVwJztcbmltcG9ydCBwb3B1cFdpZGdldCBmcm9tICcuL3NoYXJlZC9wb3B1cCc7XG5pbXBvcnQgZm9ybVdpZGdldHMgZnJvbSAnLi9zaGFyZWQvZm9ybSc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi9zZXR0aW5ncyc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi9zZXNzaW9uJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uL2JhY2tidXR0b24nO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4uL3hocic7XG5pbXBvcnQgbG9iYnkgZnJvbSAnLi9sb2JieSc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxubGV0IGlzT3BlbiA9IGZhbHNlO1xuXG5jb25zdCBodW1hblNldHVwID0gc2V0dGluZ3MuZ2FtZVNldHVwLmh1bWFuO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9wZW4sXG4gIGNsb3NlLFxuICBvcGVuUmVhbHRpbWUoKSB7XG4gICAgb3BlbigpO1xuICB9LFxuICB2aWV3KCkge1xuICAgIHJldHVybiBwb3B1cFdpZGdldChcbiAgICAgICduZXdfZ2FtZV9mb3JtX3BvcHVwIGdhbWVfZm9ybV9wb3B1cCcsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICByZW5kZXJDb250ZW50LFxuICAgICAgaXNPcGVuLFxuICAgICAgY2xvc2UpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvcGVuKCkge1xuICByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wdXNoKGNsb3NlKTtcbiAgaXNPcGVuID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2xvc2UoZnJvbUJCKSB7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBpc09wZW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGVudCgpIHtcbiAgY29uc3QgY29uZiA9IGh1bWFuU2V0dXA7XG5cbiAgcmV0dXJuIGgoJ2RpdicsIFtcbiAgICBoKCdkaXYubmV3R2FtZS1wcmVzZXRfc3dpdGNoJywgW1xuICAgICAgcmVuZGVyQ3VzdG9tU2V0dXAoXG4gICAgICAgICdodW1hbicsXG4gICAgICAgIGNvbmYsXG4gICAgICAgIGNvbmYuYXZhaWxhYmxlVmFyaWFudHNcbiAgICAgIClcbiAgICBdKVxuICBdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ3VzdG9tU2V0dXAoZm9ybU5hbWUsIHNldHRpbmdzT2JqLCB2YXJpYW50cykge1xuICBjb25zdCBnZW5lcmFsRmllbGRzZXQgPSBbXG4gICAgaCgnZGl2LnNlbGVjdF9pbnB1dCcsIHtcbiAgICAgIGtleTogZm9ybU5hbWUgKyAndmFyaWFudCdcbiAgICB9LCBmb3JtV2lkZ2V0cy5yZW5kZXJTZWxlY3QoJ3ZhcmlhbnQnLCBmb3JtTmFtZSArICd2YXJpYW50JywgdmFyaWFudHMsIHNldHRpbmdzT2JqLnZhcmlhbnQpXG4gICAgIClcbiAgXTtcblxuICBjb25zdCBtb2RlcyA9IFtcbiAgICBbJ2Nhc3VhbCcsICcwJ10sXG4gICAgWydyYXRlZCcsICcxJ11cbiAgXTtcblxuICBnZW5lcmFsRmllbGRzZXQucHVzaChoKCdkaXYuc2VsZWN0X2lucHV0Jywge1xuICAgIGtleTogZm9ybU5hbWUgKyAnbW9kZSdcbiAgfSwgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCdtb2RlJywgZm9ybU5hbWUgKyAnbW9kZScsIG1vZGVzLCBzZXR0aW5nc09iai5tb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG5cbiAgY29uc3QgdGltZUZpZWxkc2V0ID0gW107XG5cbiAgdGltZUZpZWxkc2V0LnB1c2goXG4gICAgaCgnZGl2LnNlbGVjdF9pbnB1dC5pbmxpbmUnLCB7XG4gICAgICBrZXk6IGZvcm1OYW1lICsgJ3JvdW5kJ1xuICAgIH0sXG4gICAgICBmb3JtV2lkZ2V0cy5yZW5kZXJTZWxlY3QoJ3JvdW5kcycsIGZvcm1OYW1lICsgJ3JvdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2FtZVNldHVwLmF2YWlsYWJsZVJvdW5kcywgc2V0dGluZ3NPYmoucm91bmRzLCBmYWxzZSlcbiAgICAgKVxuICApO1xuXG4gIHJldHVybiBoKCdmb3JtLmdhbWVfZm9ybScsIHtcbiAgICBrZXk6ICdjdXN0b21TZXR1cCcsXG4gICAgb25zdWJtaXQoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY2xvc2UoKTtcbiAgICAgIGdvU2VlayhodW1hblNldHVwRnJvbVNldHRpbmdzKHNldHRpbmdzT2JqKSk7XG4gICAgfVxuICB9LCBbXG4gICAgaCgnZmllbGRzZXQnLCBnZW5lcmFsRmllbGRzZXQpLFxuICAgIGgoJ2ZpZWxkc2V0JywgdGltZUZpZWxkc2V0KSxcbiAgICBoKCdkaXYucG9wdXBBY3Rpb25XcmFwcGVyJywgW1xuICAgICAgaCgnYnV0dG9uW2RhdGEtaWNvbj1FXVt0eXBlPXN1Ym1pdF0ucG9wdXBBY3Rpb24nLCBpMThuKCdjcmVhdGVBR2FtZScpKVxuICAgIF0pXG4gIF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyUXVpY2tTZXR1cChvbkN1c3RvbSkge1xuICByZXR1cm4gaCgnZGl2Lm5ld0dhbWUtcG9vbHMnLCB7IGtleTogJ3F1aWNrU2V0dXAnIH0sXG4gICAgICAgICAgIGgoJ2Rpdi5uZXdHYW1lLXBvb2wnLCB7XG4gICAgICAgICAgICAga2V5OiAncG9vbC1jdXN0b20nLFxuICAgICAgICAgICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXAob25DdXN0b20pXG4gICAgICAgICAgIH0sIGgoJ2Rpdi5uZXdHYW1lLWN1c3RvbScsICfDlnplbCcpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbn1cblxuZnVuY3Rpb24gZ29TZWVrKGNvbmYpIHtcbiAgY2xvc2UoKTtcblxuICBsb2JieS5zdGFydFNlZWtpbmcoY29uZik7XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiByZW5kZXJRdWlja1NldHVwKCkge1xuLy8gICByZXR1cm4gaCgnZGl2Lm5ld0dhbWUtcG9vbHMnLCB7IGtleTogJ3F1aWNrU2V0dXAnIH0sXG4vLyAgICAgICAgICAgIHhoci5jYWNoZWRQb29scy5tYXAocCA9PiByZW5kZXJQb29sKHApKVxuLy8gICAgICAgICAgICk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIHJlbmRlclBvb2wocCkge1xuLy8gICByZXR1cm4gaCgnZGl2Lm5ld0dhbWUtcG9vbCcsIHtcbi8vICAgICBrZXk6ICdwb29sLScgKyBwLmlkLFxuLy8gICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXAoKCkgPT4ge1xuLy8gICAgICAgY29uc29sZS5sb2coJ29uY3JlYXRlJyk7XG4vLyAgICAgfSlcbi8vICAgfSwgW2goJ2Rpdi5uZXdHYW1lLXJvdW5kcycsIHAuaWQpLFxuLy8gICAgICAgaCgnZGl2Lm5ld0dhbWUtcGVyZicsIHAucGVyZilcbi8vICAgICAgXSk7XG4vLyB9XG5cbi8vIGNvbnN0IG5ld0dhbWVGb3JtID0ge307XG5cbi8vIG5ld0dhbWVGb3JtLmlzT3BlbiA9IGZhbHNlO1xuXG4vLyBuZXdHYW1lRm9ybS5vcGVuID0gZnVuY3Rpb24oKSB7XG4vLyAgIGJhY2tidXR0b24uc3RhY2sucHVzaChuZXdHYW1lRm9ybS5jbG9zZSk7XG4vLyAgIG5ld0dhbWVGb3JtLmlzT3BlbiA9IHRydWU7XG4vLyB9O1xuXG4vLyBuZXdHYW1lRm9ybS5jbG9zZSA9IGZ1bmN0aW9uKGZyb21CQikge1xuLy8gICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgbmV3R2FtZUZvcm0uaXNPcGVuKSBiYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuLy8gICBuZXdHYW1lRm9ybS5pc09wZW4gPSBmYWxzZTtcbi8vIH07XG5cbi8vIG5ld0dhbWVGb3JtLm9wZW5SZWFsdGltZSA9IGZ1bmN0aW9uKCkge1xuLy8gICBuZXdHYW1lRm9ybS5vcGVuKCk7XG4vLyB9O1xuXG4vLyBmdW5jdGlvbiBzZWVrSHVtYW5HYW1lKCkge1xuLy8gICBuZXdHYW1lRm9ybS5jbG9zZSgpO1xuLy8gICBsb2JieS5zdGFydFNlZWtpbmcoKTtcbi8vIH1cblxuLy8gZnVuY3Rpb24gcmVuZGVyRm9ybShmb3JtTmFtZSwgYWN0aW9uLCBzZXR0aW5nc09iaiwgdmFyaWFudHMpIHtcbi8vICAgdmFyIGdlbmVyYWxGaWVsZHNldCA9IFtcbi8vICAgICBtKCdkaXYuc2VsZWN0X2lucHV0Jywge1xuLy8gICAgICAga2V5OiBmb3JtTmFtZSArICd2YXJpYW50J1xuLy8gICAgIH0sIFtcbi8vICAgICAgIGZvcm1XaWRnZXRzLnJlbmRlclNlbGVjdCgndmFyaWFudCcsIGZvcm1OYW1lICsgJyB2YXJpYW50JywgdmFyaWFudHMsIHNldHRpbmdzT2JqLnZhcmlhbnQpXG4vLyAgICAgXSlcbi8vICAgXTtcbiAgXG5cbi8vICAgLy8gSHVtYW4gb25seVxuLy8gICBpZiAoc2V0dGluZ3NPYmoubW9kZSkge1xuLy8gICAgIHZhciBtb2RlcyA9IChzZXNzaW9uLmlzQ29ubmVjdGVkKCkpID8gW1xuLy8gICAgICAgWydjYXN1YWwnLCAnMCddLFxuLy8gICAgICAgWydyYXRlZCcsICcxJ11cbi8vICAgICBdIDogWyBbJ2Nhc3VhbCcsICcwJ10gXTtcblxuLy8gICAgIGdlbmVyYWxGaWVsZHNldC5wdXNoKG0oJ2Rpdi5zZWxlY3RfaW5wdXQnLCB7XG4vLyAgICAgICBrZXk6IGZvcm1OYW1lICsgJ21vZGUnXG4vLyAgICAgfSwgW1xuLy8gICAgICAgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCdtb2RlJywgZm9ybU5hbWUgKyAnbW9kZScsIG1vZGVzLCBzZXR0aW5nc09iai5tb2RlKVxuLy8gICAgIF0pKTtcblxuLy8gICAgIGlmIChzZXNzaW9uLmlzQ29ubmVjdGVkKCkgJiYgc2V0dGluZ3NPYmoubW9kZSgpID09PSAnMCcpIHtcbi8vICAgICAgIGdlbmVyYWxGaWVsZHNldC5wdXNoKFxuLy8gICAgICAgICBmb3JtV2lkZ2V0cy5yZW5kZXJDaGVja2JveChpMThuKCdtZW1iZXJzT25seScpLCAnbWVtYmVyc09ubHknLCBzZXR0aW5nc09iai5tZW1iZXJzT25seSkpO1xuLy8gICAgIH1cbi8vICAgfVxuXG4vLyAgIC8vIGJvdGggaHVtYW5cbi8vICAgdmFyIHJvdW5kRmllbGRzZXQgPSBbXG4vLyAgICAgLy8gbSgnZGl2LnNlbGVjdF9pbnB1dCcsIHtcbi8vICAgICAvLyAgIGtleTogZm9ybU5hbWUgKyAncm91bmRzJ1xuLy8gICAgIC8vIH0sIFtcbi8vICAgICAvLyAgIGZvcm1XaWRnZXRzLnJlbmRlclNlbGVjdCgncm91bmQnLCBmb3JtTmFtZSArICdyb3VuZHMnLCByb3VuZE1vZGVzLCBzZXR0aW5nc09iai5yb3VuZE1vZGUpXG4vLyAgICAgLy8gXSlcbi8vICAgXTtcblxuLy8gICBpZiAodHJ1ZSkge1xuLy8gICAgIHJvdW5kRmllbGRzZXQucHVzaChcbi8vICAgICAgIG0oJ2Rpdi5zZWxlY3RfaW5wdXQnLCB7XG4vLyAgICAgICAgIGtleTogZm9ybU5hbWUgKyAncm91bmRzJ1xuLy8gICAgICAgfSwgW1xuLy8gICAgICAgICBmb3JtV2lkZ2V0cy5yZW5kZXJTZWxlY3QoJ3JvdW5kcycsIGZvcm1OYW1lICsgJ3JvdW5kJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmdhbWVTZXR1cC5hdmFpbGFibGVSb3VuZHMsIHNldHRpbmdzT2JqLnJvdW5kcywgZmFsc2UpXG4vLyAgICAgICBdKVxuLy8gICAgICk7XG4vLyAgIH1cblxuLy8gICByZXR1cm4gbSgnZm9ybSNuZXdfZ2FtZV9mb3JtLmdhbWVfZm9ybScsIHtcbi8vICAgICBvbnN1Ym1pdDogZnVuY3Rpb24oZSkge1xuLy8gICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuLy8gICAgICAgaWYgKCFzZXR0aW5ncy5nYW1lU2V0dXAuaXNSb3VuZFZhbGlkKHNldHRpbmdzT2JqKSkgcmV0dXJuO1xuLy8gICAgICAgbmV3R2FtZUZvcm0uY2xvc2UoKTtcbi8vICAgICAgIGFjdGlvbigpO1xuLy8gICAgIH1cbi8vICAgfSwgW1xuLy8gICAgIG0oJ2ZpZWxkc2V0JywgW1xuLy8gICAgIF0pLFxuLy8gICAgIG0oJ2ZpZWxkc2V0JywgZ2VuZXJhbEZpZWxkc2V0KSxcbi8vICAgICBtKCdmaWVsZHNldCNyb3VuZCcsIHJvdW5kRmllbGRzZXQpLFxuLy8gICAgIG0oJ2J1dHRvbltkYXRhLWljb249RV1bdHlwZT1zdWJtaXRdLm5ld0dhbWVCdXR0b24nLCBpMThuKCdjcmVhdGVBR2FtZScpKVxuLy8gICBdKTtcbi8vIH1cblxuLy8gbmV3R2FtZUZvcm0udmlldyA9IGZ1bmN0aW9uKCkge1xuLy8gICBmdW5jdGlvbiBmb3JtKCkge1xuLy8gICAgIHJldHVybiByZW5kZXJGb3JtKFxuLy8gICAgICAgJ2h1bWFuJyxcbi8vICAgICAgIHNlZWtIdW1hbkdhbWUsXG4vLyAgICAgICBzZXR0aW5ncy5nYW1lU2V0dXAuaHVtYW4sXG4vLyAgICAgICBzZXR0aW5ncy5nYW1lU2V0dXAuaHVtYW4uYXZhaWxhYmxlVmFyaWFudHMpO1xuLy8gfTtcblxuLy8gICByZXR1cm4gcG9wdXBXaWRnZXQoXG4vLyAgICAgJ25ld19nYW1lX2Zvcm1fcG9wdXAgZ2FtZV9mb3JtX3BvcHVwJyxcbi8vICAgICBudWxsLFxuLy8gICAgIGZvcm0sXG4vLyAgICAgbmV3R2FtZUZvcm0uaXNPcGVuLFxuLy8gICAgIG5ld0dhbWVGb3JtLmNsb3NlXG4vLyAgICk7XG4vLyB9O1xuXG4vLyBleHBvcnQgZGVmYXVsdCBuZXdHYW1lRm9ybTtcbiIsImltcG9ydCBjb250cm9sbGVyIGZyb20gJy4vcGxheWVyc0N0cmwnO1xuaW1wb3J0IHZpZXcgZnJvbSAnLi9wbGF5ZXJzVmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29udHJvbGxlcixcbiAgdmlld1xufTtcbiIsImltcG9ydCB7IHJlcXVlc3QgfSBmcm9tICcuLi8uLi9odHRwJztcblxuZXhwb3J0IGZ1bmN0aW9uIG9ubGluZVBsYXllcnMoKSB7XG4gIHJldHVybiByZXF1ZXN0KCcvcGxheWVyL29ubGluZScsIHt9LCB0cnVlKTtcbn1cbiIsImltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vc29ja2V0JztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuL3BsYXllclhocic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udHJvbGxlcigpIHtcbiAgc29ja2V0LmNyZWF0ZURlZmF1bHQoKTtcblxuICBjb25zdCBwbGF5ZXJzID0gbS5wcm9wKFtdKTtcblxuICB4aHIub25saW5lUGxheWVycygpLnRoZW4ocGxheWVycywgZXJyID0+IHV0aWxzLmhhbmRsZVhockVycm9yKGVycikpO1xuXG4gIHJldHVybiB7XG4gICAgcGxheWVycyxcbiAgICBnb1RvUHJvZmlsZSh1KSB7XG4gICAgICBtLnJvdXRlKCcvQC8nICsgdSk7XG4gICAgfSxcbiAgICBvbnVubG9hZDogKCkgPT4ge1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20nLi4vLi4vdXRpbHMnO1xuaW1wb3J0IGggZnJvbSAnLi4vaGVscGVyJ1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuaW1wb3J0IHsgbWVudUJ1dHRvbiwgdXNlclN0YXR1cyB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2aWV3KGN0cmwpIHtcblxuICBjb25zdCBoZWFkZXJDdHJsID0gaGVhZGVyLmJpbmQobnVsbCwgY3RybCk7XG4gIGNvbnN0IGJvZHlDdHJsID0gYm9keS5iaW5kKG51bGwsIGN0cmwpO1xuXG4gIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXJDdHJsLCBib2R5Q3RybCwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGhlYWRlcihjdHJsKSB7XG4gIHJldHVybiAoXG4gICAgPG5hdj5cbiAgICAgIHttZW51QnV0dG9uKCl9XG4gICAgICA8aDE+e2kxOG4oJ3BsYXllcnMnKX08L2gxPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwibWFpbl9oZWFkZXJfYnV0dG9uXCIga2V5PVwic2VhcmNoUGxheWVyc1wiIGRhdGEtaWNvbj1cInlcIi8+XG4gICAgICA8L2Rpdj5cbiAgICA8L25hdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gYm9keShjdHJsKSB7XG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT1cInBsYXllcnNTdWdnZXN0aW9uIG5hdGl2ZV9zY3JvbGxlcl9wYWdlXCI+XG4gICAgICB7Y3RybC5wbGF5ZXJzKCkubWFwKHJlbmRlclBsYXllcil9XG4gICAgPC91bD5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGxheWVyKHVzZXIpIHtcbiAgLy8gZmluZCBiZXN0IHBlcmZcbiAgY29uc3QgcGVyZiA9IE9iamVjdC5rZXlzKHVzZXIucGVyZnMpLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgIGlmICghcHJldikgcmV0dXJuIGN1cnI7XG4gICAgaWYgKHVzZXIucGVyZnNbcHJldl0ucmF0aW5nIDwgdXNlci5wZXJmc1tjdXJyXS5yYXRpbmcpXG4gICAgICByZXR1cm4gY3VycjtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gcHJldjtcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8bGkgY2xhc3NOYW1lPVwibGlzdF9pdGVtIHBsYXllclN1Z2dlc3Rpb24gbmF2XCIgY29uZmlnPXtoLm9udG91Y2hZKCgpID0+IG0ucm91dGUoJy9ALycgKyB1c2VyLmlkKSl9PlxuICAgICAge3VzZXJTdGF0dXModXNlcil9XG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJyYXRpbmdcIiBkYXRhLWljb249e3V0aWxzLmdhbWVJY29uKHBlcmYpfT5cbiAgICAgICAge3VzZXIucGVyZnNbcGVyZl0ucmF0aW5nfVxuICAgICAgPC9zcGFuPlxuICAgIDwvbGk+XG4gICk7XG59XG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgeyBoZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgZm9ybVdpZGdldHMgZnJvbSAnLi4vc2hhcmVkL2Zvcm0nO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi9zb2NrZXQnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBjb250cm9sbGVyKCkge1xuICAgIHNvY2tldC5jcmVhdGVEZWZhdWx0KCk7XG4gIH0sXG5cbiAgdmlldygpIHtcbiAgICBjb25zdCBoZWFkZXIgPSB1dGlscy5wYXJ0aWFsZihoZWFkZXJXaWRnZXQsIG51bGwsIGJhY2tCdXR0b24oaTE4bignc2V0dGluZ3MnKSkpO1xuXG4gICAgcmV0dXJuIGxheW91dC5mcmVlKGhlYWRlciwgcmVuZGVyQm9keSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gcmVuZGVyQm9keSgpIHtcbiAgcmV0dXJuIG0oJ2RpdicsIHtcbiAgICBzdHlsZTogeyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMDAlJyB9XG4gIH0sIFtcbiAgICBtKCd1bC5zZXR0aW5nc19saXN0LmdlbmVyYWwubmF0aXZlX3Njcm9sbGVyLnBhZ2UnLCBbXG4gICAgICBtKCdsaS5saXN0X2l0ZW0ubmF2Jywge1xuICAgICAgICBrZXk6ICdsYW5nJyxcbiAgICAgICAgY29uZmlnOiBoZWxwZXIub250b3VjaFkodXRpbHMuZihtLnJvdXRlLCAnL3NldHRpbmdzL2xhbmcnKSlcbiAgICAgIH0sIGkxOG4oJ2xhbmd1YWdlJykpLFxuICAgICAgbSgnbGkubGlzdF9pdGVtLnNldHRpbmdzQ2hvaWNlc0lubGluZScsIHtcbiAgICAgICAga2V5OiAnYmFja2dyb3VuZFRoZW1lJ1xuICAgICAgfSwgW1xuICAgICAgICBtKCdsYWJlbCcsIGkxOG4oJ2JhY2tncm91bmQnKSksXG4gICAgICAgIG0oJ2ZpZWxkc2V0JywgW1xuICAgICAgICAgIG0oJ2Rpdi5uaWNlLXJhZGlvJywgZm9ybVdpZGdldHMucmVuZGVyUmFkaW8oXG4gICAgICAgICAgICBpMThuKCdkYXJrJyksXG4gICAgICAgICAgICAnYmdUaGVtZScsXG4gICAgICAgICAgICAnZGFyaycsXG4gICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLnRoZW1lLmJhY2tncm91bmQoKSA9PT0gJ2RhcmsnLFxuICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLmdlbmVyYWwudGhlbWUuYmFja2dyb3VuZChlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgIGxheW91dC5vbkJhY2tncm91bmRDaGFuZ2UoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgIG0oJ2Rpdi5uaWNlLXJhZGlvJywgZm9ybVdpZGdldHMucmVuZGVyUmFkaW8oXG4gICAgICAgICAgICBpMThuKCdsaWdodCcpLFxuICAgICAgICAgICAgJ2JnVGhlbWUnLFxuICAgICAgICAgICAgJ2xpZ2h0JyxcbiAgICAgICAgICAgIHNldHRpbmdzLmdlbmVyYWwudGhlbWUuYmFja2dyb3VuZCgpID09PSAnbGlnaHQnLFxuICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLmdlbmVyYWwudGhlbWUuYmFja2dyb3VuZChlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgIGxheW91dC5vbkJhY2tncm91bmRDaGFuZ2UoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICBdKV0pXG4gICAgXSksXG4gICAgd2luZG93Lm95dW5rZXlmLnZlcnNpb24gPyBtKCdzZWN0aW9uLmFwcF92ZXJzaW9uJywgJ3YnICsgd2luZG93Lm95dW5rZXlmLnZlcnNpb24pIDogbnVsbFxuICBdKTtcbn1cbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGhlYWRlciBhcyBoZWFkZXJXaWRnZXQsIGJhY2tCdXR0b24gfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCBmb3JtV2lkZ2V0cyBmcm9tICcuLi9zaGFyZWQvZm9ybSc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vc2V0dGluZ3MnO1xuaW1wb3J0IGkxOG4sIHsgbG9hZEZyb21TZXR0aW5ncywgZ2V0QXZhaWxhYmxlTGFuZ3VhZ2VzIH0gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgeyBzZXRTZXJ2ZXJMYW5nIH0gZnJvbSAnLi4vLi4veGhyJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGxhbmdzID0gbS5wcm9wKFtdKTtcbiAgICBnZXRBdmFpbGFibGVMYW5ndWFnZXMoKS50aGVuKGxhbmdzKTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYW5nc1xuICAgIH07XG4gIH0sXG4gIHZpZXc6IGZ1bmN0aW9uKGN0cmwpIHtcbiAgICBjb25zdCBoZWFkZXIgPSB1dGlscy5wYXJ0aWFsZihoZWFkZXJXaWRnZXQsIG51bGwsIGJhY2tCdXR0b24oaTE4bignbGFuZ3VhZ2UnKSlcbiAgICAgICk7XG5cbiAgICBmdW5jdGlvbiByZW5kZXJMYW5nKGwpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxsaSBjbGFzc05hbWU9XCJsaXN0X2l0ZW1cIj5cbiAgICAgICAge2Zvcm1XaWRnZXRzLnJlbmRlclJhZGlvKGxbMV0sICdsYW5nJywgbFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmdlbmVyYWwubGFuZygpID09PSBsWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmdlbmVyYWwubGFuZyhlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlcnZlckxhbmcoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkRnJvbVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICl9XG4gICAgICAgIDwvbGk+XG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckJvZHkoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8dWwgY2xhc3NOYW1lPVwibmF0aXZlX3Njcm9sbGVyIHBhZ2Ugc2V0dGluZ3NfbGlzdCByYWRpb19saXN0XCI+XG4gICAgICAgICAge2N0cmwubGFuZ3MoKS5tYXAobCA9PiByZW5kZXJMYW5nKGwpKX1cbiAgICAgICAgPC91bD5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIsIHJlbmRlckJvZHkpO1xuICB9XG59O1xuIiwiaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vLi4vdXRpbHMvcmVkcmF3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQodm5vZGUpIHtcbiAgICBcbiAgICBjb25zdCB7IG9rZXlncm91bmQgfSA9IHZub2RlLmF0dHJzO1xuXG4gICAgdGhpcy53cmFwcGVyT25DcmVhdGUgPSAoKHtkb219KSA9PiB7XG4gICAgfSk7XG5cbiAgICB0aGlzLmJvYXJkT25DcmVhdGUgPSAoe2RvbX0pID0+IHtcbiAgICAgIG9rZXlncm91bmQuYXR0YWNoKGRvbSk7XG4gICAgfTtcblxuICAgIHRoaXMuYm9hcmRPblJlbW92ZSA9ICgpID0+IHtcbiAgICAgIG9rZXlncm91bmQuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBcbiAgfSxcblxuICB2aWV3KHZub2RlKSB7XG4gICAgY29uc3QgeyBib3VuZHMgfSA9IHZub2RlLmF0dHJzO1xuXG4gICAgY29uc3QgYm9hcmRDbGFzcyA9IFtcbiAgICAgICdkaXNwbGF5X2JvYXJkJyxcbiAgICBdLmpvaW4oJyAnKTtcblxuICAgIGxldCB3cmFwcGVyQ2xhc3MgPSAnZ2FtZV9ib2FyZF93cmFwcGVyJztcblxuICAgIGNvbnN0IHdyYXBwZXJTdHlsZSA9IGJvdW5kcyA/IHtcbiAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodCArICdweCcsXG4gICAgICB3aWR0aDogYm91bmRzLndpZHRoICsgJ3B4J1xuICAgIH0gOiB7fTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxzZWN0aW9uIG9uY3JlYXRlPXt0aGlzLndyYXBwZXJPbkNyZWF0ZX0gY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3N9IHN0eWxlPXt3cmFwcGVyU3R5bGV9PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtib2FyZENsYXNzfVxuICAgICAgICAgICAgIG9uY3JlYXRlPXt0aGlzLmJvYXJkT25DcmVhdGV9XG4gICAgICAgICAgICAgb25yZW1vdmU9e3RoaXMuYm9hcmRPblJlbW92ZX0vPlxuICAgICAgICA8L3NlY3Rpb24+XG4gICAgKTtcbiAgfVxuICBcbn07XG5cblxuLy8gZnVuY3Rpb24gcmVuZGVyVG9wTWVudSgpIHtcbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IGNsYXNzPVwiZGlzcGxheV9tZW51XCI+XG4vLyAgICAgICB7bWVudUJ1dHRvbigpfVxuLy8gICAgIDwvZGl2PlxuLy8gICApO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiByZW5kZXJQbGF5ZXJJbmZvKGN0cmwsIHBsYXllciwgcG9zaXRpb24pIHtcbi8vICAgY29uc3Qgd3JhcHBlckNsYXNzID0gaGVscGVyLmNsYXNzU2V0KHtcbi8vICAgICAncGxheWVySW5mb3MnOiB0cnVlLFxuLy8gICB9KSArIGAgJHtwb3NpdGlvbn1gO1xuXG4vLyAgIGNvbnN0IHBsYXllck5hbWUgPSBwbGF5ZXIuYWkgP1xuLy8gICAgICAgICAgICAgICAgICAgICAgaTE4bignYWlCb3QnLCBwbGF5ZXIuYWkpIDpcbi8vICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnBsYXllck5hbWUocGxheWVyKTtcbi8vICAgY29uc3QgcGxheWVyT25HYW1lID0gKHBsYXllci5vbkdhbWUgfHwgcGxheWVyLmFpID9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm9uZ2FtZSB5ZXNcIiBkYXRhLWljb249XCIzXCIvPiA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJvbmdhbWUgbm9cIiBkYXRhLWljb249XCIwXCIvPlxuLy8gICApO1xuXG4vLyAgIGNvbnN0IHRvZ2dsZVBvcHVwID0gY3RybC50b2dnbGVVc2VyUG9wdXAuYmluZChjdHJsLCBwb3NpdGlvbiwgcGxheWVyLnVzZXIpO1xuLy8gICBjb25zdCB2Q29uZiA9IGhlbHBlci5vbnRvdWNoKHRvZ2dsZVBvcHVwKTtcblxuLy8gICBjb25zdCBydW5uaW5nU2lkZSA9IGN0cmwuaXNDbG9ja1J1bm5pbmcoKSA/IGN0cmwuZGF0YS5nYW1lLnBsYXllciA6IG51bGw7XG4vLyAgIGNvbnN0IHJ1bm5pbmcgPSBjdHJsLmRhdGEuZ2FtZS5wbGF5ZXIgPT09IHBsYXllci5zaWRlO1xuXG4vLyAgIGNvbnN0IG9wZW5zID0gY3RybC5kYXRhLmdhbWUub3Njb3JlcyA/IGN0cmwuZGF0YS5nYW1lLm9zY29yZXNbcGxheWVyLnNpZGVdIDogbnVsbDtcbi8vICAgY29uc3Qgb3BlbnNIaW50ID0gb3BlbnMgPyAob3BlbnMuc2VyaWVzID8gJ29wZW5lZFNlcmllcycgOiAnb3BlbmVkUGFpcnMnKSA6IG51bGw7XG4vLyAgIGNvbnN0IG9wZW5zQ2xhc3MgPSBcIm9wZW5zXCIgKyAoKG9wZW5zICYmIG9wZW5zLm5ldykgPyBcIiBuZXdcIiA6IFwiXCIpO1xuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9e3dyYXBwZXJDbGFzc30gY29uZmlnPXt2Q29uZn0+XG4vLyAgICAgICA8ZGl2IGNsYXNzPVwid3JhcF9pbmZvXCI+XG4vLyAgICAgICAgIHtvcGVucyA/XG4vLyAgICAgICAgICA8ZGl2IGNsYXNzPXtvcGVuc0NsYXNzfT5cbi8vICAgICAgICAgICAgeyhvcGVucy5zZXJpZXMgPyBvcGVucy5zZXJpZXMgOiBvcGVucy5wYWlycyl9XG4vLyAgICAgICAgICAgIHsnICd9XG4vLyAgICAgICAgICAgIHtpMThuKG9wZW5zSGludCkuc3BsaXQoJyAnKVswXX1cbi8vICAgICAgICAgIDwvZGl2PjogbnVsbFxuLy8gICAgICAgICB9XG4vLyAgICAgICA8L2Rpdj5cbi8vICAgICAgIDxkaXYgY2xhc3M9XCJ3cmFwX3VzZXJcIj5cbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInBsYXllclVzZXJcIj5cbi8vICAgICAgICAgICB7cGxheWVyTmFtZX1cbi8vICAgICAgICAgICB7cGxheWVyT25HYW1lfVxuLy8gICAgICAgICA8L2gyPlxuLy8gICAgICAgICB7IChjdHJsLmNsb2NrICYmIHJ1bm5pbmcpID9cbi8vICAgICAgICAgICByZW5kZXJDbG9jayhjdHJsLmNsb2NrLCBwbGF5ZXIuc2lkZSwgcnVubmluZ1NpZGUsIHBvc2l0aW9uKSA6IG51bGxcbi8vICAgICAgICAgfVxuLy8gICAgICAgPC9kaXY+XG4vLyAgICAgPC9kaXY+XG4vLyAgICk7XG4vLyB9XG5cbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFxuLy8gICBjdHJsLFxuLy8gICBva2V5Z3JvdW5kQ3RybCxcbi8vICAgYm91bmRzLFxuLy8gICBpc1BvcnRyYWl0LFxuLy8gICB3cmFwcGVyQ2xhc3Nlcykge1xuLy8gICAgIGNvbnN0IGRhdGEgPSBjdHJsLmRhdGE7XG5cbi8vICAgICBjb25zdCBib2FyZENsYXNzID0gW1xuLy8gICAgICAgJ2Rpc3BsYXlfYm9hcmQnLFxuLy8gICAgIF0uam9pbignICcpO1xuXG4vLyAgICAgY29uc3Qga2V5ID0gJ2JvYXJkJyArIChpc1BvcnRyYWl0ID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnKTtcbi8vICAgICBsZXQgd3JhcHBlckNsYXNzID0gJ2dhbWVfYm9hcmRfd3JhcHBlcic7XG5cbi8vICAgICBpZiAod3JhcHBlckNsYXNzZXMpIHtcbi8vICAgICAgIHdyYXBwZXJDbGFzcyArPSAnICcgKyB3cmFwcGVyQ2xhc3Nlcztcbi8vICAgICB9XG5cbi8vICAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSBib3VuZHMgPyB7XG4vLyAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgKyAncHgnLFxuLy8gICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCArICdweCdcbi8vICAgICB9IDoge307XG5cblxuLy8gICAgIGZ1bmN0aW9uIHdyYXBwZXJDb25maWcoZWwsIGlzVXBkYXRlKSB7XG4vLyAgICAgICBpZiAoIWlzVXBkYXRlKSB7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuXG4vLyAgICAgZnVuY3Rpb24gYm9hcmRDb25maWcoZWwsIGlzVXBkYXRlKSB7XG4vLyAgICAgICBpZiAoIWlzVXBkYXRlKSB7XG4vLyAgICAgICAgIGlmICghYm91bmRzKSB7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgb2tleWdyb3VuZC5yZW5kZXIoZWwsIG9rZXlncm91bmRDdHJsKTtcbi8vICAgICAgIH1cbi8vICAgICB9XG5cbi8vICAgICBva2V5Z3JvdW5kQ3RybC5kYXRhLnRvcEhvb2tzID0gW1xuLy8gICAgICAgLy8gcmVuZGVyVG9wTWVudSgpLFxuLy8gICAgICAgcmVuZGVyUGxheWVySW5mbyhjdHJsLCBkYXRhLm9wcG9uZW50VXAsICd0b3AnKSxcbi8vICAgICAgIHJlbmRlclBsYXllckluZm8oY3RybCwgZGF0YS5vcHBvbmVudExlZnQsICdsZWZ0JyksXG4vLyAgICAgICByZW5kZXJQbGF5ZXJJbmZvKGN0cmwsIGRhdGEucGxheWVyLCAnYm90dG9tJyksXG4vLyAgICAgICByZW5kZXJQbGF5ZXJJbmZvKGN0cmwsIGRhdGEub3Bwb25lbnRSaWdodCwgJ3JpZ2h0Jylcbi8vICAgICBdO1xuXG5cbi8vICAgICByZXR1cm4gKFxuLy8gICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3N9IGNvbmZpZz17d3JhcHBlckNvbmZpZ31cbi8vICAgICAgICAgICAgICAgIHN0eWxlPXt3cmFwcGVyU3R5bGV9IGtleT17a2V5fT5cbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2JvYXJkQ2xhc3N9IGNvbmZpZz17Ym9hcmRDb25maWd9IC8+XG4vLyAgICAgICA8L3NlY3Rpb24+XG4vLyAgICAgKTtcbi8vIH1cbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZpZXcoeyBhdHRycyB9KSB7XG5cbiAgICBjb25zdCB0aXRsZSA9ICdnYW1lQXBpLnRpdGxlKGRhdGEpJztcblxuICAgIHJldHVybiBoKCdkaXYubWFpbl9oZWFkZXJfdGl0bGUnLCB7XG4gICAgfSwgW1xuICAgICAgaCgnaDEuaGVhZGVyLWdhbWVUaXRsZScsIFtcbiAgICAgICAgaCgnc3BhbicsIHRpdGxlKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfVxufTtcbiIsImltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdCh7YXR0cnN9KSB7XG4gICAgdGhpcy5vblRhcCA9IChlKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IGhlbHBlci5nZXRCdXR0b24oZSk7XG4gICAgICBsZXQgaTtcbiAgICAgIGlmIChlbCAmJiAoaSA9IChlbC5kYXRhc2V0KS5pbmRleCkpIHtcbiAgICAgICAgYXR0cnMub25UYWJDaGFuZ2UoTnVtYmVyKGkpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHZpZXcodm5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBidXR0b25zLFxuICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgIG5vSW5kaWNhdG9yLFxuICAgICAgd3JhcHBlckNsYXNzXG4gICAgfSA9IHZub2RlLmF0dHJzO1xuXG4gICAgY29uc3QgaVdpZHRoID0gMTAwIC8gYnV0dG9ucy5sZW5ndGg7XG4gICAgY29uc3Qgc2hpZnQgPSBzZWxlY3RlZEluZGV4ICogKGlXaWR0aCAqIGJ1dHRvbnMubGVuZ3RoKTtcblxuICAgIGNvbnN0IGluZGljYXRvclN0eWxlID0ge1xuICAgICAgd2lkdGg6IGlXaWR0aCArICclJyxcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtzaGlmdH0lKWBcbiAgICB9O1xuXG4gICAgY29uc3QgYnV0dG9uU3R5bGUgPSB7XG4gICAgICB3aWR0aDogaVdpZHRoICsgJyUnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbmRlclRhYihiLCBpKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBbXG4gICAgICAgICd0YWItYnV0dG9uJyxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCA9PT0gaSA/ICdzZWxlY3RlZCc6ICcnLFxuICAgICAgICBiLmNsYXNzTmFtZVxuICAgICAgXS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAgIDxidXR0b24gZGF0YS1pbmRleD17aX0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IHN0eWxlPXtidXR0b25TdHlsZX0+XG4gICAgICAgICAgICB7Yi5sYWJlbH1cbiAgICAgICAgICAgIHtiLmNoaXAgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY2hpcFwiPntiLmNoaXB9PC9zcGFuPiA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXsndGFicy1uYXZpZ2F0aW9uJyArICh3cmFwcGVyQ2xhc3MgPyAnICcgKyB3cmFwcGVyQ2xhc3MgOiAnJyl9XG4gICAgICAgICAgIG9uY3JlYXRlPXtoZWxwZXIub250YXAodGhpcy5vblRhcCl9PlxuICAgICAgICAgIHtidXR0b25zLm1hcChyZW5kZXJUYWIpfVxuICAgICAgICAgIHsgbm9JbmRpY2F0b3IgPyBudWxsIDogPGRpdiBjbGFzc05hbWU9XCJ0YWJJbmRpY2F0b3JcIiBzdHlsZT1cImluZGljYXRvclN0eWxlXCIvPiB9XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuaW1wb3J0IHsgdmlld3BvcnREaW0gfSBmcm9tICcuLi9oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uY3JlYXRlKHthdHRycywgZG9tfSkge1xuICB9LFxuXG4gIHZpZXcoe2F0dHJzfSkge1xuICAgIGNvbnN0IGN1ckluZGV4ID0gYXR0cnMuc2VsZWN0ZWRJbmRleDtcbiAgICBjb25zdCB2dyA9IHZpZXdwb3J0RGltKCkudnc7XG4gICAgY29uc3Qgd2lkdGggPSBhdHRycy5jb250ZW50Lmxlbmd0aCAqIDEwMDtcbiAgICBjb25zdCBzaGlmdCA9IC0oY3VySW5kZXggKiB2dyk7XG5cbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIHdpZHRoOiBgJHt3aWR0aH12d2AsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7c2hpZnR9cHgpYFxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGgoJ2Rpdi50YWJzLXZpZXctd3JhcHBlcicsIGgoJ2Rpdi50YWJzLXZpZXcnLCB7XG4gICAgICBzdHlsZSxcbiAgICAgIGNsYXNzTmFtZTogYXR0cnMuY2xhc3NOYW1lXG4gICAgfSwgYXR0cnMuY29udGVudC5tYXAoKF8sIGluZGV4KSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2Rpdi50YWItY29udGVudCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWluZGV4JzppbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY3VySW5kZXggPT09IGluZGV4ID8gJ2N1cnJlbnQnOicnXG4gICAgICAgICAgICAgICAgICAgICAgICAgfSwgY3VySW5kZXggPT09IGluZGV4ID8gaChUYWIsIHsgaW5kZXgsIC4uLmF0dHJzIH0pIDogbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICApO1xuICAgIFxuICB9XG5cbn1cblxuY29uc3QgVGFiID0ge1xuICBvbmJlZm9yZXVwZGF0ZSh7YXR0cnN9LCB7YXR0cnM6IG9sZGF0dHJzIH0pIHtcbiAgICByZXR1cm4gYXR0cnMuY29udGVudFthdHRycy5pbmRleF0gIT09IG9sZGF0dHJzLmNvbnRlbnRbb2xkYXR0cnMuaW5kZXhdO1xuICB9LFxuXG4gIHZpZXcoe2F0dHJzfSkge1xuICAgIHJldHVybiBhdHRycy5yZW5kZXJlcihhdHRycy5jb250ZW50W2F0dHJzLmluZGV4XSwgYXR0cnMuaW5kZXgpO1xuICB9XG59XG4iLCJpbXBvcnQgb2tleWdyb3VuZCBmcm9tICdva2V5Z3JvdW5kLW1vYmlsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmlldyhfLCBhcmdzKSB7XG4gICAgY29uc3QgYm9hcmRDbGFzcyA9IFtcbiAgICAgICdkaXNwbGF5X2JvYXJkJyxcbiAgICAgIGFyZ3MudmFyaWFudCA/IGFyZ3MudmFyaWFudC5rZXkgOiAnJ1xuICAgIF0uam9pbignICcpO1xuXG4gICAgZnVuY3Rpb24gYm9hcmRDb25mKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuICAgICAgY29uc3QgY29uZmlnID0gbWFrZUNvbmZpZyhhcmdzKTtcbiAgICAgIGlmIChjb250ZXh0Lmdyb3VuZCkge1xuICAgICAgICBjb250ZXh0Lmdyb3VuZC5zZXQoY29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE8gdHJ5IHRvIGF2b2lkIHRoYXRcbiAgICAgICAgaWYgKCFjb25maWcuYm91bmRzKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ25vIGJvYXJkIGJvdW5kcycpO1xuICAgICAgICAgIC8vIGNvbmZpZy5ib3VuZHMgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lmdyb3VuZCA9IG9rZXlncm91bmQoZWwsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtib2FyZENsYXNzfSBjb25maWc9e2JvYXJkQ29uZn0vPlxuICAgICk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1ha2VDb25maWcoYXJncykge1xuICBjb25zdCB7IGZlbiwgb3JpZW50YXRpb24sIGJvdW5kcyB9ID0gYXJncztcbiAgY29uc3QgY29uZiA9IHtcbiAgICB2aWV3T25seTogdHJ1ZSxcbiAgICBtaW5pbWFsRG9tOiB0cnVlLFxuICAgIGZlblxuICB9O1xuXG4gIC8vIGlmIChib3VuZHMpIGNvbmYuYm91bmRzID0gYm91bmRzO1xuXG4gIHJldHVybiBjb25mO1xufVxuIiwiaW1wb3J0ICogYXMgbWVudSBmcm9tICcuLi9tZW51JztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBnYW1lc01lbnUgZnJvbSAnLi4vZ2FtZXNNZW51JztcbmltcG9ydCBuZXdHYW1lRm9ybSBmcm9tICcuLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi9yb3V0ZXInO1xuaW1wb3J0IHsgYmFja0Fycm93IH0gZnJvbSAnLi9pY29ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZW51QnV0dG9uKCkge1xuICByZXR1cm4gaCgnYnV0dG9uLmZhLmZhLW5hdmljb24ubWFpbl9oZWFkZXJfYnV0dG9uLm1lbnVfYnV0dG9uJywge1xuICAgIGtleTogJ21haW4tbWVudScsXG4gICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcChtZW51Lm1haW5NZW51Q3RybC50b2dnbGUpXG4gIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoZWFkZXJCdG5zKCkge1xuXG4gIGlmICh1dGlscy5oYXNOZXR3b3JrKCkgJiYgc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYga2V5PVwiYnV0dG9uc1wiIGNsYXNzTmFtZT1cImJ1dHRvbnNcIj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYga2V5PVwiYnV0dG9uc1wiIGNsYXNzTmFtZT1cImJ1dHRvbnNcIj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbiAgXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcm9wU2hhZG93SGVhZGVyKHRpdGxlLCBsZWZ0QnV0dG9uKSB7XG5cbiAgcmV0dXJuIFtcbiAgICBoKCduYXYnLCBbXG4gICAgICBsZWZ0QnV0dG9uID8gbGVmdEJ1dHRvbiA6IG1lbnVCdXR0b24oKSxcbiAgICAgIHRpdGxlID8gPGRpdiBjbGFzc05hbWU9XCJtYWluX2hlYWRlcl90aXRsZVwiIGtleT1cInRpdGxlXCI+e3RpdGxlfTwvZGl2PjogbnVsbCxcbiAgICAgIGhlYWRlckJ0bnMoKVxuICAgIF0pLFxuICAgIGgoJ2Rpdi5tYWluX2hlYWRlcl9kcm9wX3NoYWRvdycpXG4gIF07XG4gIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdGluZ0Ryb3BTaGFkb3dIZWFkZXIodGl0bGUpIHtcbiAgcmV0dXJuIFtcbiAgICBoKCduYXYnLCBbXG4gICAgICBtZW51QnV0dG9uKCksXG4gICAgICBoKCdkaXYubWFpbl9oZWFkZXJfdGl0bGUucmVjb25uZWN0aW5nJywge1xuICAgICAgICBjbGFzc05hbWU6IHRpdGxlID8gJ3dpdGhUaXRsZSc6JycsXG4gICAgICAgIGtleTogJ2Nvbm5lY3RpbmctdGl0bGUnXG4gICAgICB9KSxcbiAgICAgIHRpdGxlID8gaCgnZGl2Lm1haW5faGVhZGVyX3RpdGxlJywgeyBrZXk6ICd0aXRsZScgfSwgdGl0bGUpIDogbnVsbCxcbiAgICAgIGhlYWRlckJ0bnMoKVxuICAgIF0pLFxuICAgIGgoJ2Rpdi5tYWluX2hlYWRlcl9kcm9wX3NoYWRvdycpXG4gIF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrQnV0dG9uKHRpdGxlKSB7XG4gIHJldHVybiBoKCdkaXYuYmFja19idXR0b24nLCB7IGtleTogJ2RlZmF1bHQtaGlzdG9yeS1iYWNrYnV0dG9uJyB9LCBbXG4gICAgaCgnYnV0dG9uJywgeyBvbmNyZWF0ZTogaGVscGVyLm9udGFwKHJvdXRlci5iYWNrSGlzdG9yeSkgfSwgYmFja0Fycm93KSxcbiAgICB0aXRsZSAhPT0gdW5kZWZpbmVkID8gdHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJyA/IGgoJ2Rpdi5tYWluX2hlYWRlcl90aXRsZScsIHRpdGxlKSA6IHRpdGxlIDogbnVsbFxuICBdKTtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIG1lbnVCdXR0b24oKSB7XG4vLyAgIHJldHVybiAoXG4vLyAgICAgICA8YnV0dG9uIGtleT1cIm1haW4tbWVudVwiIGNsYXNzTmFtZT1cImZhIGZhLW5hdmljb24gbWFpbl9oZWFkZXJfYnV0dG9uIG1lbnVfYnV0dG9uXCIgY29uZmlnPXtoZWxwZXIub250b3VjaChtZW51LnRvZ2dsZSl9PlxuLy8gICAgIDwvYnV0dG9uPlxuLy8gICApO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gYmFja0J1dHRvbih0aXRsZSkge1xuLy8gICByZXR1cm4gKFxuLy8gICAgICAgPGJ1dHRvbiBrZXk9XCJkZWZhdWx0LWhpc3RvcnktYmFja2J1dHRvblwiIGNsYXNzTmFtZT1cImJhY2tfYnV0dG9uIG1haW5faGVhZGVyX2J1dHRvblwiIGNvbmZpZz17aGVscGVyLm9udG91Y2godXRpbHMuYmFja0hpc3RvcnkpfT5cbi8vICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWFycm93LWxlZnRcIi8+XG4vLyAgICAgICB7dGl0bGUgPyA8ZGl2IGNsYXNzTmFtZT1cInRpdGxlXCI+e3RpdGxlfTwvZGl2PiA6IG51bGwgfVxuLy8gICAgIDwvYnV0dG9uPlxuLy8gICApO1xuLy8gfVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtZXNCdXR0b24oKSB7XG4gIGxldCBrZXksIGFjdGlvbjtcblxuICBrZXk9J2dhbWVzLW1lbnUnO1xuXG4gIGlmIChzZXNzaW9uLm5vd1BsYXlpbmcoKS5sZW5ndGgpIHtcbiAgICBrZXkgPSAnZ2FtZXMtbWVudSc7XG4gICAgYWN0aW9uID0gZ2FtZXNNZW51Lm9wZW47XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gJ25ldy1nYW1lLWZvcm0nO1xuICAgIGFjdGlvbiA9IG5ld0dhbWVGb3JtLm9wZW47XG4gIH1cblxuICBjb25zdCBjbGFzc05hbWUgPSBbXG4gICAgJ21haW5faGVhZGVyX2J1dHRvbicsXG4gICAgJ2dhbWVfbWVudV9idXR0b24nLFxuICAgICF1dGlscy5oYXNOZXR3b3JrKCkgPyAnaW52aXNpYmxlJyA6ICcnXG4gIF0uam9pbignICcpO1xuXG4gIGNvbnN0IGxvbmdBY3Rpb24gPSAoKSA9PiB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ25iR2FtZXNJblBsYXknLCBzZXNzaW9uLm5vd1BsYXlpbmcoKS5sZW5ndGgpLCAnc2hvcnQnLCAndG9wJyk7XG5cbiAgcmV0dXJuIChcbiAgICAgIDxidXR0b24ga2V5PXtrZXl9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBjb25maWc9e2hlbHBlci5vbnRvdWNoKGFjdGlvbiwgbG9uZ0FjdGlvbil9PlxuICAgIDwvYnV0dG9uPlxuICApO1xufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gaGVhZGVyQnRucygpIHtcbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IGtleT1cImJ1dHRvbnNcIiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4vLyAgICAgICB7Z2FtZXNCdXR0b24oKX1cbi8vICAgICA8L2Rpdj5cbi8vICAgKTtcbi8vIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGhlYWRlcih0aXRsZSwgbGVmdEJ1dHRvbikge1xuICByZXR1cm4gKFxuICAgIDxuYXY+XG4gICAgICB7bGVmdEJ1dHRvbiA/IGxlZnRCdXR0b24gOiBtZW51QnV0dG9uKCl9XG4gICAgICB7dGl0bGUgPyA8aDEga2V5PVwidGl0bGVcIj57dGl0bGV9PC9oMT4gOiBudWxsIH1cbiAgICAgIHtoZWFkZXJCdG5zKCl9XG4gICAgPC9uYXY+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2aWV3T25seUJvYXJkQ29udGVudCgpIHtcbiAgY29uc3QgaXNQb3J0cmFpdCA9IGZhbHNlO1xuICBjb25zdCB7IHZ3LCB2aCB9ID0geyB2dzogMTAsIHZoOiAxMCB9XG4gIGNvbnN0IGJvYXJkU3R5bGUgPSBpc1BvcnRyYWl0ID8geyB3aWR0aDogdncgKyAncHgnLCBoZWlnaHQ6IHZ3ICsgJ3B4JyB9IDoge307XG4gIGNvbnN0IGJvYXJkS2V5ID0gJ3ZpZXdvbmx5Ym9hcmQnXG4gIGNvbnN0IGNsYXNzTmFtZSA9ICdib2FyZF93cmFwcGVyJ1xuICBjb25zdCBib2FyZCA9IChcbiAgICA8c2VjdGlvbiBrZXk9e2JvYXJkS2V5fSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gc3R5bGU9e2JvYXJkU3R5bGV9PlxuICAgICAge20uY29tcG9uZW50KFZpZXdPbmx5Qm9hcmQpfVxuICAgIDwvc2VjdGlvbj5cbiAgKTtcbiAgcmV0dXJuIFtcbiAgICBib2FyZFxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZXJTdGF0dXModXNlcikge1xuICBjb25zdCBzdGF0dXMgPSB1c2VyLm9ubGluZSA/ICdvbmxpbmUnIDogJ29mZmxpbmUnO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXNlclwiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPXsndXNlclN0YXR1cyAnICsgc3RhdHVzfSBkYXRhLWljb249XCJyXCIgLz5cbiAgICAgIHt1c2VyLnVzZXJuYW1lfVxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5cbmltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmVuZGVyU2VsZWN0KFxuICAgIGxhYmVsLFxuICAgIG5hbWUsXG4gICAgb3B0aW9ucyxcbiAgICBzZXR0aW5nc1Byb3AsXG4gICAgaXNEaXNhYmxlZCxcbiAgICBvbkNoYW5nZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvcCA9IHNldHRpbmdzUHJvcCgpO1xuICAgIHJldHVybiBbXG4gICAgICBoKCdsYWJlbCcsIHtcbiAgICAgICAgJ2Zvcic6ICdzZWxlY3RfJyArIG5hbWVcbiAgICAgIH0sIGkxOG4obGFiZWwpKSxcbiAgICAgIGgoJ3NlbGVjdCcsIHtcbiAgICAgICAgaWQ6ICdzZWxlY3RfJyArIG5hbWUsXG4gICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICBvbmNoYW5nZShlKSB7XG4gICAgICAgICAgY29uc3QgdmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgc2V0dGluZ3NQcm9wKHZhbCk7XG4gICAgICAgICAgaWYgKG9uQ2hhbmdlQ2FsbGJhY2spIG9uQ2hhbmdlQ2FsbGJhY2sodmFsKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KHJlZHJhdywgMTApO1xuICAgICAgICB9XG4gICAgICB9LCBvcHRpb25zLm1hcChlID0+IHJlbmRlck9wdGlvbihlWzBdLCBlWzFdLCBwcm9wLCBlWzJdLCBlWzNdKSkpXG4gICAgXTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVuZGVyT3B0aW9uKGxhYmVsLCB2YWx1ZSwgcHJvcCwgbGFiZWxBcmcsIGxhYmVsQXJnMikge1xuICBjb25zdCBsID0gbGFiZWxBcmcgJiYgbGFiZWxBcmcyID8gaTE4bihsYWJlbCwgbGFiZWxBcmcsIGxhYmVsQXJnMikgOlxuICAgICAgICAgIGxhYmVsQXJnID8gaTE4bihsYWJlbCwgbGFiZWxBcmcpIDogaTE4bihsYWJlbCk7XG4gIHJldHVybiBoKCdvcHRpb24nLCB7XG4gICAga2V5OiB2YWx1ZSxcbiAgICB2YWx1ZSxcbiAgICBzZWxlY3RlZDogcHJvcCA9PT0gdmFsdWVcbiAgfSwgbCk7XG59XG5cbi8vIGltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuLy8gaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbi8vIGZ1bmN0aW9uIHJlbmRlck9wdGlvbihsYWJlbCwgdmFsdWUsIHN0b3JlZFZhbHVlLCBsYWJlbEFyZywgbGFiZWxBcmcyKSB7XG4vLyAgIHJldHVybiBtKCdvcHRpb24nLCB7XG4vLyAgICAgdmFsdWU6IHZhbHVlLFxuLy8gICAgIHNlbGVjdGVkOiBzdG9yZWRWYWx1ZSA9PT0gdmFsdWVcbi8vICAgfSwgaTE4bihsYWJlbCwgbGFiZWxBcmcsIGxhYmVsQXJnMikpO1xuLy8gfVxuXG4vLyBleHBvcnQgZGVmYXVsdCB7XG4vLyAgIHJlbmRlclJhZGlvOiBmdW5jdGlvbihsYWJlbCwgbmFtZSwgdmFsdWUsIGNoZWNrZWQsIG9uY2hhbmdlKSB7XG4vLyAgICAgdmFyIGlkID0gbmFtZSArICdfJyArIHZhbHVlO1xuLy8gICAgIHJldHVybiBbXG4vLyAgICAgICBtKCdpbnB1dC5yYWRpb1t0eXBlPXJhZGlvXScsIHtcbi8vICAgICAgICAgbmFtZSxcbi8vICAgICAgICAgaWQsXG4vLyAgICAgICAgIGNsYXNzTmFtZTogdmFsdWUsXG4vLyAgICAgICAgIHZhbHVlLFxuLy8gICAgICAgICBjaGVja2VkLFxuLy8gICAgICAgICBvbmNoYW5nZVxuLy8gICAgICAgfSksXG4vLyAgICAgICBtKCdsYWJlbCcsIHtcbi8vICAgICAgICAgJ2Zvcic6IGlkXG4vLyAgICAgICB9LCBpMThuKGxhYmVsKSlcbi8vICAgICBdO1xuLy8gICB9LFxuXG4vLyAgIHJlbmRlclNlbGVjdDogZnVuY3Rpb24obGFiZWwsIG5hbWUsIG9wdGlvbnMsIHNldHRpbmdzUHJvcCwgaXNEaXNhYmxlZCwgb25DaGFuZ2VDYWxsYmFjaykge1xuLy8gICAgIHZhciBzdG9yZWRWYWx1ZSA9IHNldHRpbmdzUHJvcCgpO1xuLy8gICAgIHJldHVybiBbXG4vLyAgICAgICBtKCdsYWJlbCcsIHtcbi8vICAgICAgICAgJ2Zvcic6ICdzZWxlY3RfJyArIG5hbWVcbi8vICAgICAgIH0sIGkxOG4obGFiZWwpKSxcbi8vICAgICAgIG0oJ3NlbGVjdCcsIHtcbi8vICAgICAgICAgaWQ6ICdzZWxlY3RfJyArIG5hbWUsXG4vLyAgICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxuLy8gICAgICAgICBjb25maWc6IGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuLy8gICAgICAgICAgIGlmICghaXNVcGRhdGUpIHtcbi8vICAgICAgICAgICAgIHZhciBvbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbi8vICAgICAgICAgICAgICAgc2V0dGluZ3NQcm9wKGUudGFyZ2V0LnZhbHVlKTtcbi8vICAgICAgICAgICAgICAgaWYgKG9uQ2hhbmdlQ2FsbGJhY2spIG9uQ2hhbmdlQ2FsbGJhY2soZS50YXJnZXQudmFsdWUpO1xuLy8gICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4vLyAgICAgICAgICAgICAgIH0sIDEwKTtcbi8vICAgICAgICAgICAgIH07XG4vLyAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuLy8gICAgICAgICAgICAgY29udGV4dC5vbnVubG9hZCA9ICgpID0+IHtcbi8vICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbi8vICAgICAgICAgICAgIH07XG4vLyAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyAgICAgICB9LCBvcHRpb25zLm1hcChmdW5jdGlvbihlKSB7XG4vLyAgICAgICAgIHJldHVybiByZW5kZXJPcHRpb24oZVswXSwgZVsxXSwgc3RvcmVkVmFsdWUsIGVbMl0sIGVbM10pO1xuLy8gICAgICAgfSkpXG4vLyAgICAgXTtcbi8vICAgfSxcbi8vICAgcmVuZGVyQ2hlY2tib3g6IGZ1bmN0aW9uKGxhYmVsLCBuYW1lLCBzZXR0aW5nc1Byb3AsIGNhbGxiYWNrLCBkaXNhYmxlZCkge1xuLy8gICAgIHZhciBpc09uID0gc2V0dGluZ3NQcm9wKCk7XG4vLyAgICAgcmV0dXJuIG0oJ2Rpdi5jaGVja19jb250YWluZXInLCB7XG4vLyAgICAgICBjbGFzc05hbWU6IGRpc2FibGVkID8gJ2Rpc2FibGVkJzogJydcbi8vICAgICB9LCBbXG4vLyAgICAgICBtKCdsYWJlbCcsIHtcbi8vICAgICAgICAgJ2Zvcic6IG5hbWVcbi8vICAgICAgIH0sIGxhYmVsKSxcbi8vICAgICAgIG0oJ2lucHV0W3R5cGU9Y2hlY2tib3hdJywge1xuLy8gICAgICAgICBuYW1lOiBuYW1lLFxuLy8gICAgICAgICBkaXNhYmxlZCxcbi8vICAgICAgICAgY2hlY2tlZDogaXNPbixcbi8vICAgICAgICAgb25jaGFuZ2U6IGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9ICFpc09uO1xuLy8gICAgICAgICAgIHNldHRpbmdzUHJvcChuZXdWYWwpO1xuLy8gICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobmV3VmFsKTtcbi8vICAgICAgICAgfVxuLy8gICAgICAgfSlcbi8vICAgICBdKTtcbi8vICAgfVxuLy8gfTtcbiIsImV4cG9ydCBjb25zdCBiYWNrQXJyb3cgPVxuICA8ZGl2IGNsYXNzTmFtZT1cInN2Z19pY29uXCI+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJzdmdfaWNvbl9pbm5lclwiPlxuICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjAgMTFINy44M2w1LjU5LTUuNTlMMTIgNGwtOCA4IDggOCAxLjQxLTEuNDFMNy44MyAxM0gyMHYtMnpcIj48L3BhdGg+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+O1xuXG5leHBvcnQgY29uc3QgY2xvc2VJY29uID1cbiAgPGRpdiBjbGFzc05hbWU9XCJzdmdfaWNvblwiPlxuICAgIDxkaXYgY2xhc3NOYW1lPVwic3ZnX2ljb25faW5uZXJcIj5cbiAgICAgIDxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnpcIi8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+O1xuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KCkge1xuICB9LFxuICB2aWV3KHsgYXR0cnMsIGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB7IGhlYWRlciB9ID0gYXR0cnM7XG5cbiAgICByZXR1cm4gaCgnbWFpbiNwYWdlJywge30sIFtcbiAgICAgIC8vIGgoJ2hlYWRlci5tYWluX2hlYWRlci5ib2FyZCcsIGhlYWRlciksXG4gICAgICBoKCdkaXYuY29udGVudF9yb3VuZCcsIGNoaWxkcmVuKVxuICAgIF0pO1xuXG4gIH1cblxufTtcbiIsImltcG9ydCB7IGdhbWVJY29uIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGtleSwgbmFtZSwgcGVyZiwgdXNlcikge1xuICB2YXIgb3B0aW9ucyA9IHsgY2xhc3NOYW1lOiAncHJvZmlsZVBlcmYnLCAnZGF0YS1pY29uJzogZ2FtZUljb24oa2V5KSB9O1xuXG4gIGlmICh2YXJpYW50UGVyZkF2YWlsYWJsZShrZXksIHBlcmYpKSB7XG4gICAgb3B0aW9ucy5jbGFzc05hbWUgKz0gJyBuYXYnO1xuICAgIG9wdGlvbnMuY29uZmlnID0gaGVscGVyLm9udG91Y2hZKGdvVG9WYXJpYW50UGVyZih1c2VyLCBrZXkpKTtcbiAgfVxuXG4gIHJldHVybiBtKCdkaXYnLCBvcHRpb25zLCBbXG4gICAgbSgnc3Bhbi5uYW1lJywgbmFtZSksXG4gICAgbSgnZGl2LnJhdGluZycsIFtcbiAgICAgIHBlcmYucmF0aW5nLFxuICAgICAgaGVscGVyLnByb2dyZXNzKHBlcmYucHJvZyksXG4gICAgICBtKCdzcGFuLm5iJywgJy8gJyArIHBlcmYuZ2FtZXMpXG4gICAgXSlcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIGdvVG9WYXJpYW50UGVyZih1c2VyLCBrZXkpIHtcbiAgcmV0dXJuICgpID0+IG0ucm91dGUoJy9ALyR7dXNlci5pZH0vJHtrZXl9L3BlcmYnKTtcbn1cblxuZnVuY3Rpb24gdmFyaWFudFBlcmZBdmFpbGFibGUoa2V5LCBwZXJmKSB7XG4gIHJldHVybiBwZXJmLmdhbWVzID4gMDtcbn1cbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwb3B1cChcbiAgY2xhc3NlcyxcbiAgaGVhZGVyRixcbiAgY29udGVudEYsXG4gIGlzU2hvd2luZyxcbiAgY2xvc2VmKSB7XG4gIFxuICBpZiAoIWlzU2hvd2luZykgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgZGVmYXVsdENsYXNzZXMgPSB7XG4gICAgb3ZlcmxheV9wb3B1cDogdHJ1ZSxcbiAgICBuYXRpdmVfc2Nyb2xsZXI6IHRydWVcbiAgfTtcbiAgXG4gIGxldCBjbGFzc05hbWU7XG5cbiAgaWYgKHR5cGVvZiBjbGFzc2VzID09PSAnb2JqZWN0Jykge1xuICAgIGNsYXNzTmFtZSA9IGhlbHBlci5jbGFzc1NldChPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q2xhc3NlcywgY2xhc3NlcykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjbGFzc2VzID09PSAnc3RyaW5nJykge1xuICAgIGNsYXNzTmFtZSA9IGhlbHBlci5jbGFzc1NldChkZWZhdWx0Q2xhc3NlcykgKyAnICcgKyBjbGFzc2VzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcG9wdXAgYXJndW1lbnQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBjb25zdCBjb250ZW50Q2xhc3MgPSBoZWxwZXIuY2xhc3NTZXQoe1xuICAgICdwb3B1cF9jb250ZW50JzogdHJ1ZSxcbiAgICAnbm9oZWFkZXInOiAhaGVhZGVyRlxuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYga2V5PXtTdHJpbmcoY29udGVudEYpfSBjbGFzc05hbWU9XCJvdmVybGF5X3BvcHVwX3dyYXBwZXIgZmFkZS1pblwiXG4gICAgb25iZWZvcmVtb3ZlPXsodm5vZGUpID0+IHtcbiAgICAgIHZub2RlLmRvbS5jbGFzc0xpc3QuYWRkKCdmYWRpbmdfb3V0Jyk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCA1MDApO1xuICAgICAgfSk7XG4gICAgfX0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInBvcHVwX292ZXJsYXlfY2xvc2VcIlxuICAgICAgICBvbmNyZWF0ZT17Y2xvc2VmID8gaGVscGVyLm9udGFwKGNsb3NlZik6IHV0aWxzLm5vb3AgfS8+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgIHtoZWFkZXJGID8gPGhlYWRlcj57aGVhZGVyRigpfTwvaGVhZGVyPjogbnVsbH1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NvbnRlbnRDbGFzc30+XG4gICAgICAgICAge2NvbnRlbnRGKCl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbi8vIGZ1bmN0aW9uIHN0eWxlQ29uZihlbCkge1xuLy8gICBjb25zdCB2aCA9IGhlbHBlci52aWV3cG9ydERpbSgpLnZoO1xuLy8gICBjb25zdCBoID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuLy8gICBjb25zdCB0b3AgPSAodmggLSBoKSAvIDI7XG4vLyAgIC8vIGVsLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4vLyB9XG5cbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNsYXNzZXMsIGhlYWRlckYsIGNvbnRlbnRGLCBpc1Nob3dpbmcsIGNsb3NlRikge1xuLy8gICBpZiAoIWlzU2hvd2luZykgcmV0dXJuIG51bGw7XG5cbi8vICAgY29uc3QgZGVmYXVsdENsYXNzZXMgPSB7XG4vLyAgICAgb3ZlcmxheV9wb3B1cDogdHJ1ZSxcbi8vICAgICBuYXRpdmVfc2Nyb2xsZXI6IHRydWVcbi8vICAgfTtcblxuLy8gICBsZXQgY2xhc3NOYW1lO1xuXG4vLyAgIGlmICh0eXBlb2YgY2xhc3NlcyA9PT0gJ29iamVjdCcpIHtcbi8vICAgICBjbGFzc05hbWUgPSBoZWxwZXIuY2xhc3NTZXQoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENsYXNzZXMsIGNsYXNzZXMpKTtcbi8vICAgfSBlbHNlIGlmICh0eXBlb2YgY2xhc3NlcyA9PT0gJ3N0cmluZycpIHtcbi8vICAgICBjbGFzc05hbWUgPSBoZWxwZXIuY2xhc3NTZXQoZGVmYXVsdENsYXNzZXMpICsgJyAnICsgY2xhc3Nlcztcbi8vICAgfSBlbHNlXG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBwb3B1cCBhcmd1bWVudCBtdXN0IGJlIGVpdGhlciBzdHJpbmcgb3IgYW4gb2JqZWN0Jyk7XG5cbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IGNsYXNzTmFtZT1cIm92ZXJsYXlfcG9wdXBfd3JhcHBlclwiPlxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cF9vdmVybGF5X2Nsb3NlXCJcbi8vICAgICAgICAgICAgY29uZmlnPXtjbG9zZUYgPyBoZWxwZXIub250b3VjaChoZWxwZXIuZmFkZXNPdXQoY2xvc2VGLCAnLm92ZXJsYXlfcG9wdXBfd3JhcHBlcicpKSA6IHV0aWxzLm5vb3AgfSAvPlxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gY29uZmlnPXtzdHlsZUNvbmZ9PlxuLy8gICAgICAgICB7aGVhZGVyRiA/IDxoZWFkZXI+e2hlYWRlckYoKX08L2hlYWRlcj4gOiBudWxsIH1cbi8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cF9jb250ZW50XCI+XG4vLyAgICAgICAgICAge2NvbnRlbnRGKCl9XG4vLyAgICAgICAgIDwvZGl2PlxuLy8gICAgICAgPC9kaXY+XG4vLyAgICAgPC9kaXY+XG4vLyAgICk7XG4vLyB9XG4iLCJpbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgZ3JvdW5kIGZyb20gJy4vZ3JvdW5kJztcbmltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uLy4uL295dW5rZXlmL2dhbWUnO1xuaW1wb3J0IENsb2NrQ3RybCBmcm9tICcuL2Nsb2NrL0Nsb2NrQ3RybCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9ubGluZVJvdW5kKGlkLCBjZmcpIHtcbiAgY29uc3Qgc2V0RGF0YSA9IChjZmcpID0+IHtcbiAgICB0aGlzLmRhdGEgPSBjZmc7XG4gIH07XG4gIFxuICB0aGlzLmlkID0gaWQ7XG4gIHNldERhdGEoY2ZnKTtcbiAgXG4gIHRoaXMub2tleWdyb3VuZCA9IGdyb3VuZC5tYWtlKFxuICAgIHRoaXMuZGF0YSxcbiAgICBjZmcuZ2FtZS5mZW4sXG4gICk7XG5cbiAgdGhpcy5jbG9jayA9IHRoaXMuZGF0YS5jbG9jayA/IG5ldyBDbG9ja0N0cmwodGhpcy5kYXRhLCB7XG4gICAgb25GbGFnOiB0aGlzLm91dG9mdGltZVxuICB9KSA6IG51bGw7XG5cbiAgaWYgKHRoaXMuY2xvY2spIHtcbiAgICBjb25zdCB0aWNrTm93ID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbG9jayAmJiB0aGlzLmNsb2NrLnRpY2soKTtcbiAgICAgIGlmIChnYW1lQXBpLnBsYXlhYmxlKHRoaXMuZGF0YSkpIHRoaXMuY2xvY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRpY2tOb3csIDEwMCk7XG4gICAgfTtcbiAgICB0aGlzLmNsb2NrVGltZW91dElkID0gc2V0VGltZW91dCh0aWNrTm93LCAxMDApO1xuICB9XG5cbiAgdGhpcy51bmxvYWQgPSAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvY2tUaW1lb3V0SWQpO1xuICB9O1xuXG4gIHJlZHJhdygpO1xuXG59XG4iLCJpbXBvcnQgZ2FtZUFwaSBmcm9tICcuLi8uLi8uLi8uLi9veXVua2V5Zi9nYW1lJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2xvY2tDdHJsKGQsIG9wdHMpIHtcblxuICB0aGlzLnNldENsb2NrID0gKGQsIGVhc3QsIHdlc3QsIHNvdXRoLCBub3J0aCkgPT4ge1xuICAgIGNvbnN0IGlzQ2xvY2tSdW5uaW5nID0gZ2FtZUFwaS5wbGF5YWJsZShkKSAmJlxuICAgICAgICAgICAgKChkLmdhbWUudHVybnMgLSBkLmdhbWUuc3RhcnRlZEF0VHVybikgPiAtMSB8fCAoZC5jbG9jayAmJiBkLmNsb2NrLnJ1bm5pbmcpKTtcblxuICAgIHRoaXMudGltZXMgPSB7XG4gICAgICBlYXN0OiBlYXN0ICogMTAwMCxcbiAgICAgIHdlc3Q6IHdlc3QgKiAxMDAwLFxuICAgICAgbm9ydGg6IG5vcnRoICogMTAwMCxcbiAgICAgIHNvdXRoOiBzb3V0aCAqIDEwMDAsXG4gICAgICBhY3RpdmVTaWRlOiBpc0Nsb2NrUnVubmluZyA/IGQuZ2FtZS5wbGF5ZXIgOiB1bmRlZmluZWQsXG4gICAgICBsYXN0VXBkYXRlOiBwZXJmb3JtYW5jZS5ub3coKVxuICAgIH07XG4gIH07XG5cblxuICB0aGlzLm9wdHMgPSBvcHRzO1xuXG4gIGNvbnN0IGNkYXRhID0gZC5jbG9jaztcblxuICB0aGlzLmVtZXJnTXMgPSBjZGF0YS5lbWVyZzsgLy8gMTAwMCAqIE1hdGgubWluKDYwLCBNYXRoLm1heCgxMCwgY2RhdGEuZW1lcmcgKiAuMTI1KSk7XG5cbiAgdGhpcy5zZXRDbG9jayhkLCBjZGF0YS5zaWRlcy5lYXN0LCBjZGF0YS5zaWRlcy53ZXN0LCBjZGF0YS5zaWRlcy5zb3V0aCwgY2RhdGEuc2lkZXMubm9ydGgpO1xuXG4gIHRoaXMuZWxlbWVudHMgPSB7XG4gICAgZWFzdDogbnVsbCxcbiAgICB3ZXN0OiBudWxsLFxuICAgIHNvdXRoOiBudWxsLFxuICAgIG5vcnRoOiBudWxsXG4gIH07XG5cblxuXG4gIHRoaXMudGljayA9ICgpID0+IHtcbiAgICBjb25zdCBzaWRlID0gdGhpcy50aW1lcy5hY3RpdmVTaWRlO1xuICAgIGlmICghc2lkZSkgcmV0dXJuO1xuXG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgbWlsbGlzID0gdGhpcy50aW1lc1tzaWRlXSAtIHRoaXMuZWxhcHNlZChub3cpO1xuICAgIGlmIChtaWxsaXMgPD0gMCkgdGhpcy5vcHRzLm9uRmxhZygpO1xuICAgIGVsc2UgdGhpcy51cGRhdGVFbGVtZW50KHNpZGUsIG1pbGxpcyk7XG4gIH07XG5cbiAgdGhpcy51cGRhdGVFbGVtZW50ID0gKHNpZGUsIG1pbGxpcykgPT4ge1xuICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50c1tzaWRlXTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gbWlsbGlzO1xuICAgICAgaWYgKG1pbGxpcyA8IHRoaXMuZW1lcmdNcykgZWwuY2xhc3NMaXN0LmFkZCgnZW1lcmcnKTtcbiAgICAgIGVsc2UgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZW1lcmcnKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5lbGFwc2VkID0gKG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpKSA9PiBNYXRoLm1heCgwLCBub3cgLSB0aGlzLnRpbWVzLmxhc3RVcGRhdGUpO1xuICBcbiAgdGhpcy5taWxsaXNPZiA9IChzaWRlKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMudGltZXMuYWN0aXZlU2lkZSA9PT0gc2lkZSA/XG4gICAgICBNYXRoLm1heCgwLCB0aGlzLnRpbWVzW3NpZGVdIC0gdGhpcy5lbGFwc2VkKCkpIDogdGhpcy50aW1lc1tzaWRlXTtcbiAgfTtcblxuICB0aGlzLmlzUnVubmluZyA9ICgpID0+IHRoaXMudGltZXMuYWN0aXZlU2lkZSAhPT0gdW5kZWZpbmVkO1xuXG59XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQoe2F0dHJzfSkge1xuICAgIGNvbnN0IHsgY3RybCwgc2lkZSB9ID0gYXR0cnM7XG5cbiAgICB0aGlzLmNsb2NrT25DcmVhdGUgPSAoe2RvbX0pID0+IHtcbiAgICAgIGN0cmwuZWxlbWVudHNbc2lkZV0gPSBkb207XG4gICAgICBjdHJsLnVwZGF0ZUVsZW1lbnQoc2lkZSwgY3RybC5taWxsaXNPZihzaWRlKSk7XG4gICAgfTtcbiAgICB0aGlzLmNsb2NrT25VcGRhdGUgPSAoe2RvbX0pID0+IHtcbiAgICAgIGN0cmwuZWxlbWVudHNbc2lkZV0gPSBkb207XG4gICAgICBjdHJsLnVwZGF0ZUVsZW1lbnQoc2lkZSwgY3RybC5taWxsaXNPZihzaWRlKSk7XG4gICAgfTtcbiAgfSxcblxuICB2aWV3KHthdHRyc30pIHtcblxuICAgIHJldHVybiBoKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2JhcicgfSwgW1xuICAgICAgaCgnc3BhbicsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYmFyMicsXG4gICAgICAgIG9uY3JlYXRlOiB0aGlzLmNsb2NrT25DcmVhdGUsXG4gICAgICAgIG9udXBkYXRlOiB0aGlzLmNsb2NrT25VcGRhdGVcbiAgICAgIH0pXG4gICAgXSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgT2tleWdyb3VuZCBmcm9tICdva2V5Z3JvdW5kLW1vYmlsZSc7XG5cbmZ1bmN0aW9uIG1ha2VDb25maWcoZGF0YSwgZmVuKSB7XG4gIHJldHVybiB7XG4gICAgZmVuLFxuICAgIHR1cm5TaWRlOiBkYXRhLmdhbWUucGxheWVyXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2UoZGF0YSwgZmVuKSB7XG4gIGNvbnN0IGNvbmZpZyA9IG1ha2VDb25maWcoZGF0YSwgZmVuKTtcbiAgXG4gIHJldHVybiBuZXcgT2tleWdyb3VuZChjb25maWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gbWFrZSBcbn07XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uLy4uLy4uL2kxOG4nO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi8uLi8uLi9sYXlvdXQnO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi8uLi8uLi9zb2NrZXQnO1xuaW1wb3J0ICogYXMgcGxheWVyQXBpIGZyb20gJy4uLy4uLy4uLy4uL295dW5rZXlmL3BsYXllcic7XG5pbXBvcnQgQm9hcmQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0JvYXJkJztcbmltcG9ydCBHYW1lVGl0bGUgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0dhbWVUaXRsZSc7XG5pbXBvcnQgQ2xvY2sgZnJvbSAnLi4vY2xvY2svY2xvY2tWaWV3JztcbmltcG9ydCB7IG1lbnVCdXR0b24sIGhlYWRlckJ0bnMsIGJhY2tCdXR0b24gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29tbW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlldyhjdHJsKSB7XG5cbiAgcmV0dXJuIGxheW91dC5ib2FyZChcbiAgICByZW5kZXJIZWFkZXIoY3RybCksXG4gICAgcmVuZGVyQ29udGVudChjdHJsKSxcbiAgICBvdmVybGF5KGN0cmwpKTtcblxufVxuXG5mdW5jdGlvbiBvdmVybGF5KGN0cmwpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiByZW5kZXJIZWFkZXIoY3RybCkge1xuICBsZXQgY2hpbGRyZW47XG5cbiAgY2hpbGRyZW4gPSBbXG4gICAgbWVudUJ1dHRvbigpLFxuICAgIHJlbmRlclRpdGxlKGN0cmwpXG4gIF07XG5cbiAgY2hpbGRyZW4ucHVzaChoZWFkZXJCdG5zKCkpO1xuXG4gIHJldHVybiBoKCduYXYnLCB7XG4gICAgY2xhc3NOYW1lOiBzb2NrZXQuaXNDb25uZWN0ZWQoKSA/ICcnOidyZWNvbm5lY3RpbmcnXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVGl0bGUoY3RybCkge1xuICBjb25zdCBkYXRhID0gY3RybC5kYXRhO1xuICBjb25zdCBtYXNhID0gY3RybC5kYXRhLm1hc2E7XG5cbiAgcmV0dXJuIGgoR2FtZVRpdGxlLCB7XG4gICAga2V5OiAncGxheWluZy10aXRsZScsXG4gICAgZGF0YTogY3RybC5kYXRhXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb250ZW50KGN0cmwpIHtcbiAgY29uc3QgcGxheWVyID0gcmVuZGVyUGxheVRhYmxlKGN0cmwsIGN0cmwuZGF0YS5wbGF5ZXIsICdwbGF5ZXInKTtcbiAgY29uc3Qgb3Bwb25lbnRMZWZ0ID0gcmVuZGVyUGxheVRhYmxlKGN0cmwsIGN0cmwuZGF0YS5vcHBvbmVudExlZnQsICdvcHBvbmVudExlZnQnKTtcbiAgY29uc3Qgb3Bwb25lbnRSaWdodCA9IHJlbmRlclBsYXlUYWJsZShjdHJsLCBjdHJsLmRhdGEub3Bwb25lbnRSaWdodCwgJ29wcG9uZW50UmlnaHQnKTtcbiAgY29uc3Qgb3Bwb25lbnRVcCA9IHJlbmRlclBsYXlUYWJsZShjdHJsLCBjdHJsLmRhdGEub3Bwb25lbnRVcCwgJ29wcG9uZW50VXAnKTtcblxuICAvLyAgY29uc3QgYm91bmRzID0gaGVscGVyLmdldEJvYXJkQm91bmRzKGhlbHBlci52aWV3cG9ydERpbSgpKTtcbiAgXG4gIGNvbnN0IGJvYXJkID0gaChCb2FyZCwge1xuICAgIHZhcmlhbnQ6IGN0cmwuZGF0YS5nYW1lLnZhcmlhbnQua2V5LFxuICAgIG9rZXlncm91bmQ6IGN0cmwub2tleWdyb3VuZCxcbiAgICAgIC8vICAgIGJvdW5kc1xuICB9KTtcbiAgXG4gIHJldHVybiBoLmZyYWdtZW50KHt9LCBbXG4gICAgcmVuZGVyTWVudUFjdGlvbnNCYXIoY3RybCksXG4gICAgcGxheWVyLFxuICAgIG9wcG9uZW50TGVmdCxcbiAgICBvcHBvbmVudFJpZ2h0LFxuICAgIG9wcG9uZW50VXAsXG4gICAgYm9hcmQsXG4gIF0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJNZW51QWN0aW9uc0JhcihjdHJsKSB7XG4gIHJldHVybiAoPHNlY3Rpb24gY2xhc3NOYW1lPVwibWVudV9hY3Rpb25zX2JhclwiPlxuICAgICAgICAgIHtiYWNrQnV0dG9uKCl9XG4gICAgICAgICAgPC9zZWN0aW9uPik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBsYXlUYWJsZShjdHJsLCBwbGF5ZXIsIHBvc2l0aW9uKSB7XG4gIFxuICBjb25zdCBjbGFzc04gPSAncGxheVRhYmxlICcgKyBwb3NpdGlvbjtcblxuICByZXR1cm4gKFxuICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPXtjbGFzc059PlxuICAgICAge3JlbmRlckFudGFnb25pc3RJbmZvKGN0cmwsIHBsYXllciwgcG9zaXRpb24pfVxuICAgICAgPC9zZWN0aW9uPlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJBbnRhZ29uaXN0SW5mbyhjdHJsLCBwbGF5ZXIsIHBvc2l0aW9uKSB7XG4gIC8vIGNvbnN0IHJ1bm5pbmdTaWRlID0gY3RybC5pc0Nsb2NrUnVubmluZygpID8gY3RybC5kYXRhLmdhbWUucGxheWVyIDogdW5kZWZpbmVkO1xuICBjb25zdCB1c2VyID0gcGxheWVyLnVzZXI7XG4gIGNvbnN0IHBsYXllck5hbWUgPSBwbGF5ZXJBcGkucGxheWVyTmFtZShwbGF5ZXIpO1xuXG4gIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17J2FudGFnb25pc3RJbmZvcyd9PlxuICAgICAgICA8aDIgY2xhc3NOYW1lPXsnYW50YWdvbmlzdFVzZXInfT5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9eydmYSBmYS1jaXJjbGUgc3RhdHVzICcgKyAocGxheWVyLm9uR2FtZSA/ICdvbmdhbWUnIDogJ29mZmdhbWUnKX0vPlxuICAgICAgICAgIHtwbGF5ZXJOYW1lfVxuICAgICAgICA8L2gyPlxuICAgICAgICB7cmVuZGVyQ2xvY2soY3RybC5jbG9jaywgcGxheWVyLnNpZGUpfVxuICAgICAgPC9kaXY+XG4gICk7XG5cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xvY2soY3RybCwgc2lkZSwgcnVubmluZ1NpZGUpIHtcbiAgcmV0dXJuIGgoQ2xvY2ssIHtcbiAgICBjdHJsLFxuICAgIHNpZGUsXG4gICAgcnVubmluZ1NpZGVcbiAgfSk7XG59XG4iLCJpbXBvcnQgWmFuaW1vIGZyb20gJ3phbmltbyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uLy4uL3JvdXRlcic7XG5cbmltcG9ydCB7IEJBQ0tEUk9QX09QQUNJVFkgfSBmcm9tICcuJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lkZU1lbnVDdHJsKHNpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVudUlELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25PcGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2UpIHtcbiAgdGhpcy5pc09wZW4gPSBmYWxzZTtcblxuICB0aGlzLnNpZGUgPSBzaWRlO1xuICB0aGlzLm1lbnVJRCA9IG1lbnVJRDtcbiAgdGhpcy5iYWNrZHJvcElEID0gYmFja2Ryb3BJRDtcbiAgdGhpcy5vbk9wZW4gPSBvbk9wZW47XG4gIHRoaXMub25DbG9zZSA9IG9uQ2xvc2U7XG5cblxuICB0aGlzLm9wZW4gPSAoKSA9PiB7XG4gICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnB1c2godGhpcy5jbG9zZSk7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm1lbnVJRCk7XG4gICAgY29uc3QgYmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmJhY2tkcm9wSUQpO1xuICAgIGlmICh0aGlzLm9uT3BlbikgdGhpcy5vbk9wZW4oKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgWmFuaW1vKGJkLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJywgMCksXG4gICAgICBaYW5pbW8oYmQsICdvcGFjaXR5JywgQkFDS0RST1BfT1BBQ0lUWSwgMjUwLCAnbGluZWFyJyksXG4gICAgICBaYW5pbW8oZWwsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnLCAwKSxcbiAgICAgIFphbmltbyhcbiAgICAgICAgZWwsXG4gICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAndHJhbnNsYXRlM2QoMCwwLDApJywgMjUwLCAnZWFzZS1vdXQnXG4gICAgICApXG4gICAgICBcbiAgICBdKS50aGVuKHJlZHJhdylcbiAgICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTtcbiAgfTtcblxuICB0aGlzLmNsb3NlID0gKGZyb21CQikgPT4ge1xuICAgIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiB0aGlzLmlzT3Blbikgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4gICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMubWVudUlEKTtcbiAgICBjb25zdCBiZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuYmFja2Ryb3BJRCk7XG4gICAgaWYgKHRoaXMub25DbG9zZSkgdGhpcy5vbkNsb3NlKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIFphbmltbyhiZCwgJ29wYWNpdHknLCAwLCAyNTAsICdsaW5lYXInKSxcbiAgICAgIFphbmltbyhcbiAgICAgICAgZWwsXG4gICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICB0aGlzLmNsb3NlVHJhbnNsYXRlKCksIDI1MCwgJ2Vhc2Utb3V0JylcbiAgICBdKS50aGVuKCgpID0+IHtcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgWmFuaW1vKGVsLCAndmlzaWJpbGl0eScsICdoaWRkZW4nLCAwKSxcbiAgICAgICAgWmFuaW1vKGJkLCAndmlzaWJpbGl0eScsICdoaWRkZW4nLCAwKSxcbiAgICAgIF0pO1xuICAgIH0pLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO1xuICB9O1xuXG4gIHRoaXMudG9nZ2xlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlzT3BlbikgdGhpcy5jbG9zZSgpO1xuICAgIGVsc2UgdGhpcy5vcGVuKCk7XG4gIH07XG4gIFxuICB0aGlzLmNsb3NlVHJhbnNsYXRlID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLnNpZGUgPT09ICdsZWZ0JyA/ICd0cmFuc2xhdGUzZCgtMTAwJSwwLDApJzondHJhbnNsYXRlM2QoMTAwJSwwLDApJztcbiAgfTtcblxufTtcbiIsImV4cG9ydCBjb25zdCBCQUNLRFJPUF9PUEFDSVRZID0gMC43O1xuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uL3NvY2tldCc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi9zZXNzaW9uJztcbmltcG9ydCBpMThuIGZyb20gJy4uL2kxOG4nO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4vaGVscGVyJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCBsb2dpbk1vZGFsIGZyb20gJy4vbG9naW5Nb2RhbCc7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi9iYWNrYnV0dG9uJztcbmltcG9ydCB7IGNsb3NlSWNvbiB9IGZyb20gJy4vc2hhcmVkL2ljb25zJztcblxubGV0IGlzT3BlbiA9IGZhbHNlO1xubGV0IGxvYWRpbmcgPSBmYWxzZTtcblxubGV0IGZvcm1FcnJvciA9IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb3BlbixcbiAgY2xvc2UsXG4gIHZpZXcoKSB7XG4gICAgaWYgKCFpc09wZW4pIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIGgoJ2Rpdi5tb2RhbCNzaWdudXBNb2RhbCcsIHsgb25jcmVhdGU6IGhlbHBlci5zbGlkZXNJblVwIH0sIFtcbiAgICAgIGgoJ2hlYWRlcicsIFtcbiAgICAgICAgaCgnYnV0dG9uLm1vZGFsX2Nsb3NlJywge1xuICAgICAgICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXAoaGVscGVyLnNsaWRlc091dERvd24oY2xvc2UsICdzaWdudXBNb2RhbCcpKVxuICAgICAgICB9LCBjbG9zZUljb24pLFxuICAgICAgICBoKCdoMicsIGkxOG4oJ3NpZ25VcCcpKVxuICAgICAgXSksXG4gICAgICBoKCdkaXYjc2lnbnVwTW9kYWxDb250ZW50Lm1vZGFsX2NvbnRlbnQnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogbG9hZGluZyA/ICdsb2FkaW5nJyA6ICcnXG4gICAgICB9LCByZW5kZXJGb3JtKCkpXG4gICAgXSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbmRlckZvcm0oKSB7XG4gIHJldHVybiBbXG4gICAgaCgnZm9ybS5sb2dpbicsIHtcbiAgICAgIG9uc3VibWl0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHN1Ym1pdChlLnRhcmdldCk7XG4gICAgICB9XG4gICAgfSwgW1xuICAgICAgaCgnZGl2LmZpZWxkJywgW1xuICAgICAgICBmb3JtRXJyb3IgJiYgZm9ybUVycm9yLnVzZXJuYW1lID9cbiAgICAgICAgICBoKCdkaXYuZm9ybS1lcnJvcicsIGZvcm1FcnJvci51c2VybmFtZVswXSkgOiBudWxsLFxuICAgICAgICBoKCdpbnB1dCNwc2V1ZG9bdHlwZT10ZXh0XScsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGZvcm1FcnJvciAmJiBmb3JtRXJyb3IudXNlcm5hbWUgPyAnZm9ybS1lcnJvcic6ICcnLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCd1c2VybmFtZScpLFxuICAgICAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4gICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuICAgICAgICAgIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbiAgICAgICAgICBzcGVsbGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICBvbmZvY3VzOiBzY3JvbGxUb1RvcFxuICAgICAgICB9KSxcbiAgICAgIF0pLFxuICAgICAgaCgnZGl2LmZpZWxkJywgW1xuICAgICAgICBmb3JtRXJyb3IgJiYgZm9ybUVycm9yLmVtYWlsID9cbiAgICAgICAgICBoKCdkaXYuZm9ybS1lcnJvcicsIGZvcm1FcnJvci5lbWFpbFswXSk6IG51bGwsXG4gICAgICAgIGgoJ2lucHV0I2VtYWlsW3R5cGU9ZW1haWxdJywge1xuICAgICAgICAgIG9uZm9jdXM6IHNjcm9sbFRvVG9wLFxuICAgICAgICAgIGNsYXNzTmFtZTogZm9ybUVycm9yICYmIGZvcm1FcnJvci5lbWFpbCA/ICdmb3JtLWVycm9yJyA6ICcnLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdlbWFpbCcpLFxuICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiAnb2ZmJyxcbiAgICAgICAgICBhdXRvY29ycmVjdDogJ29mZicsXG4gICAgICAgICAgc3BlbGxjaGVjazogZmFsc2UsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIF0pLFxuICAgICAgaCgnZGl2LmZpZWxkJywgW1xuICAgICAgICBmb3JtRXJyb3IgJiYgZm9ybUVycm9yLnBhc3N3b3JkID9cbiAgICAgICAgICBoKCdkaXYuZm9ybS1lcnJvcicsIGZvcm1FcnJvci5wYXNzd29yZFswXSkgOiBudWxsLFxuICAgICAgICBoKCdpbnB1dCNwYXNzd29yZFt0eXBlPXBhc3N3b3JkXScsIHtcbiAgICAgICAgICBvbmZvY3VzOiBzY3JvbGxUb1RvcCxcbiAgICAgICAgICBjbGFzc05hbWU6IGZvcm1FcnJvciAmJiBmb3JtRXJyb3IucGFzc3dvcmQgPyAnZm9ybS1lcnJvcicgOiAnJyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bigncGFzc3dvcmQnKSxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICBoKCdkaXYuc3VibWl0JywgW1xuICAgICAgICBoKCdidXR0b24uc3VibWl0QnV0dG9uW2RhdGEtaWNvbj1GXScsIGkxOG4oJ3NpZ25VcCcpKVxuICAgICAgXSlcbiAgICBdKVxuICBdO1xufVxuXG5mdW5jdGlvbiBzY3JvbGxUb1RvcChlKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNvbnN0IGVsID0gZS50YXJnZXQ7XG4gICAgZWwuc2Nyb2xsSW50b1ZpZXcodHJ1ZSk7XG4gIH0sIDMwMCk7XG59XG5cbmZ1bmN0aW9uIHN1Ym1pdChmb3JtKSB7XG4gIGNvbnN0IGxvZ2luID0gZm9ybVswXS52YWx1ZS50cmltKCk7XG4gIGNvbnN0IGVtYWlsID0gZm9ybVsxXS52YWx1ZS50cmltKCk7XG4gIGNvbnN0IHBhc3MgPSBmb3JtWzJdLnZhbHVlLnRyaW0oKTtcbiAgaWYgKCFsb2dpbiB8fCAhZW1haWwgfHwgIXBhc3MpIHJldHVybjtcbiAgd2luZG93LktleWJvYXJkLmhpZGUoKTtcbiAgbG9hZGluZyA9IHRydWU7XG4gIGZvcm1FcnJvciA9IG51bGw7XG4gIHJlZHJhdygpO1xuICBzZXNzaW9uLnNpZ251cChsb2dpbiwgZW1haWwsIHBhc3MpXG4gICAgLnRoZW4oZCA9PiB7XG4gICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ2xvZ2luU3VjY2Vzc2Z1bCcpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4gICAgICBzb2NrZXQucmVjb25uZWN0Q3VycmVudCgpO1xuICAgICAgcmVkcmF3KCk7XG4gICAgICBsb2dpbk1vZGFsLmNsb3NlKCk7XG4gICAgICBjbG9zZSgpO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgaWYgKGlzU3VibWl0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgZm9ybUVycm9yID0gZXJyb3IuYm9keS5lcnJvcjtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVYaHJFcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzU3VibWl0RXJyb3IoZXJyKSB7XG4gIHJldHVybiBlcnIuYm9keS5lcnJvciAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBvcGVuKCkge1xuICByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wdXNoKGhlbHBlci5zbGlkZXNPdXREb3duKGNsb3NlLCAnc2lnbnVwTW9kYWwnKSk7XG4gIGZvcm1FcnJvciA9IG51bGw7XG4gIGlzT3BlbiA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsb3NlKGZyb21CQikge1xuICB3aW5kb3cuS2V5Ym9hcmQuaGlkZSgpO1xuICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgaXNPcGVuKSByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgaXNPcGVuID0gZmFsc2U7XG59XG5cbi8vIGNvbnN0IHNpZ251cE1vZGFsID0ge307XG5cbi8vIHZhciBpc09wZW4gPSBmYWxzZTtcblxuLy8gZnVuY3Rpb24gc3VibWl0KGZvcm0pIHtcbi8vICAgdmFyIGxvZ2luID0gZm9ybVswXS52YWx1ZS50cmltKCk7XG4vLyAgIHZhciBlbWFpbCA9IGZvcm1bMV0udmFsdWUudHJpbSgpO1xuLy8gICB2YXIgcGFzcyA9IGZvcm1bMl0udmFsdWUudHJpbSgpO1xuLy8gICBpZiAoIWxvZ2luIHx8ICFlbWFpbCB8fCAhcGFzcykgcmV0dXJuIGZhbHNlO1xuLy8gICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmNsb3NlKCk7XG4vLyAgIHJldHVybiBzZXNzaW9uLnNpZ251cChsb2dpbiwgZW1haWwsIHBhc3MpLnRoZW4oZnVuY3Rpb24oKSB7XG4vLyAgICAgc2lnbnVwTW9kYWwuY2xvc2UoKTtcbi8vICAgICBsb2dpbk1vZGFsLmNsb3NlKCk7XG4vLyAgICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhpMThuKCdsb2dpblN1Y2Nlc3NmdWxsJyksICdzaG9ydCcsICdjZW50ZXInKTtcbi8vICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbi8vICAgICB2YXIgZGF0YSA9IGVycm9yLnJlc3BvbnNlO1xuLy8gICAgIGlmIChkYXRhLmVycm9yLnVzZXJuYW1lKSB7XG4vLyAgICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGRhdGEuZXJyb3IudXNlcm5hbWVbMF0sICdzaG9ydCcsICdjZW50ZXInKTtcbi8vICAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IucGFzc3dvcmQpIHtcbi8vICAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coZGF0YS5lcnJvci5wYXNzd29yZFswXSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICAgIH1cbi8vICAgfSk7XG4vLyB9XG5cbi8vIHNpZ251cE1vZGFsLm9wZW4gPSBmdW5jdGlvbigpIHtcbi8vICAgYmFja2J1dHRvbi5zdGFjay5wdXNoKGhlbHBlci5zbGlkZXNPdXREb3duKHNpZ251cE1vZGFsLmNsb3NlLCAnc2lnbnVwTW9kYWwnKSk7XG4vLyAgIGlzT3BlbiA9IHRydWU7XG4vLyB9O1xuXG4vLyBzaWdudXBNb2RhbC5jbG9zZSA9IGZ1bmN0aW9uKGZyb21CQikge1xuLy8gICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmNsb3NlKCk7XG4vLyAgIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIGJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4vLyAgIGlzT3BlbiA9IGZhbHNlO1xuLy8gfTtcblxuLy8gc2lnbnVwTW9kYWwudmlldyA9IGZ1bmN0aW9uKCkge1xuLy8gICBpZiAoIWlzT3BlbikgcmV0dXJuIG51bGw7XG5cbi8vICAgcmV0dXJuIG0oJ2Rpdi5tb2RhbCNzaWdudXBNb2RhbCcsIHsgY29uZmlnOiBoZWxwZXIuc2xpZGVzSW5VcCB9LCBbXG4vLyAgICAgbSgnaGVhZGVyJywgW1xuLy8gICAgICAgbSgnYnV0dG9uLm1vZGFsX2Nsb3NlW2RhdGEtaWNvbj1MXScsIHtcbi8vICAgICAgICAgY29uZmlnOiBoZWxwZXIub250b3VjaChoZWxwZXIuc2xpZGVzT3V0RG93bihzaWdudXBNb2RhbC5jbG9zZSwgJ3NpZ251cE1vZGFsJykpXG4vLyAgICAgICB9KSxcbi8vICAgICAgIG0oJ2gyJywgaTE4bignc2lnblVwJykpXG4vLyAgICAgXSksXG4vLyAgICAgbSgnZGl2Lm1vZGFsX2NvbnRlbnQnLCBbXG4vLyAgICAgICBtKCdwLnNpZ251cFdhcm5pbmcud2l0aEljb25bZGF0YS1pY29uPSFdJywgW1xuLy8gICAgICAgICBpMThuKCdjb21wdXRlcnNBcmVOb3RBbGxvd2VkVG9QbGF5Jylcbi8vICAgICAgIF0pLFxuLy8gICAgICAgbSgncC50b3NXYXJuaW5nJywgW1xuLy8gICAgICAgICBpMThuKCdieVJlZ2lzdGVyaW5nWW91QWdyZWVUb0JlQm91bmRCeU91cicpLFxuLy8gICAgICAgICBtKCdhJywge1xuLy8gICAgICAgICB9LCBpMThuKCd0ZXJtc09mU2VydmljZScpKSwgJy4nXG4vLyAgICAgICBdKSxcbi8vICAgICAgIG0oJ2Zvcm0ubG9naW4nLCB7XG4vLyAgICAgICAgIG9uc3VibWl0OiBmdW5jdGlvbihlKSB7XG4vLyAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuLy8gICAgICAgICAgIHJldHVybiBzdWJtaXQoZS50YXJnZXQpO1xuLy8gICAgICAgICB9XG4vLyAgICAgICB9LCBbXG4vLyAgICAgICAgIG0oJ2lucHV0I3BzZXVkb1t0eXBlPXRleHRdJywge1xuLy8gICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCd1c2VybmFtZScpLFxuLy8gICAgICAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4vLyAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuLy8gICAgICAgICAgIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbi8vICAgICAgICAgICBzcGVsbGNoZWNrOiAnZmFsc2UnLFxuLy8gICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4vLyAgICAgICAgIH0pLFxuLy8gICAgICAgICBtKCdpbnB1dCNlbWFpbFt0eXBlPWVtYWlsXScsIHtcbi8vICAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bignZW1haWwnKSxcbi8vICAgICAgICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuLy8gICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiAnb2ZmJyxcbi8vICAgICAgICAgICBhdXRvY29ycmVjdDogJ29mZicsXG4vLyAgICAgICAgICAgc3BlbGxjaGVjazogJ2ZhbHNlJyxcbi8vICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuLy8gICAgICAgICB9KSxcbi8vICAgICAgICAgbSgnaW5wdXQjcGFzc3dvcmRbdHlwZT1wYXNzd29yZF0nLCB7XG4vLyAgICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3Bhc3N3b3JkJyksXG4vLyAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbi8vICAgICAgICAgfSksXG4vLyAgICAgICAgIG0oJ2J1dHRvbi5mYXQnLCBpMThuKCdzaWduVXAnKSlcbi8vICAgICAgIF0pXG4vLyAgICAgXSlcbi8vICAgXSk7XG4vLyB9O1xuXG4vLyBleHBvcnQgZGVmYXVsdCBzaWdudXBNb2RhbDtcbiIsImltcG9ydCBjb250cm9sbGVyIGZyb20gJy4vdXNlckN0cmwnO1xuaW1wb3J0IHZpZXcgZnJvbSAnLi91c2VyVmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29udHJvbGxlcixcbiAgdmlld1xufTtcbiIsImltcG9ydCBzZXNzaW9uIGZyb20gJy4uLy4uL3Nlc3Npb24nO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4vdXNlclhocic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udHJvbGxlcigpIHtcbiAgc29ja2V0LmNyZWF0ZURlZmF1bHQoKTtcblxuICBjb25zdCB1c2VyID0gbS5wcm9wKCk7XG5cbiAgeGhyLnVzZXIobS5yb3V0ZS5wYXJhbSgnaWQnKSkudGhlbih1c2VyLCBlcnJvciA9PiB7XG4gICAgdXRpbHMuaGFuZGxlWGhyRXJyb3IoZXJyb3IpO1xuICAgIG0ucm91dGUoJy8nKTtcbiAgfSkudGhlbihzZXNzaW9uLnJlZnJlc2gpO1xuXG4gIHJldHVybiB7XG4gICAgdXNlcixcbiAgICBpc01lOiAoKSA9PiBzZXNzaW9uLmdldFVzZXJJZCgpID09PSB1c2VyKCkuaWRcbiAgfTtcbn1cbiIsIi8vIGltcG9ydCB1c2VyUGVyZnMgZnJvbSAnLi4vLi4vb3l1bmtleWYvcGVyZnMnO1xuaW1wb3J0IHBlcmYgZnJvbSAnLi4vc2hhcmVkL3BlcmYnO1xuaW1wb3J0IHsgaGVhZGVyIGFzIGhlYWRlcldpZGdldCwgYmFja0J1dHRvbiB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi9zZXNzaW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlldyhjdHJsKSB7XG4gIGNvbnN0IHVzZXIgPSBjdHJsLnVzZXIoKTtcblxuICBpZiAoIXVzZXIpIHJldHVybiBudWxsO1xuXG4gIGZ1bmN0aW9uIGhlYWRlcigpIHtcbiAgICBjb25zdCB0aXRsZSA9IHVzZXIudXNlcm5hbWU7XG4gICAgcmV0dXJuIGhlYWRlcldpZGdldChudWxsLCBiYWNrQnV0dG9uKHRpdGxlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9maWxlKCkge1xuICAgIC8vIFRPRE9cbiAgICAvLyBzdGF0c1xuICAgIC8vIHJhdGluZ3NcbiAgICAvLyBhY3Rpb25zXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgaWQ9XCJ1c2VyUHJvZmlsZVwiIGNsYXNzTmFtZT1cIm5hdGl2ZV9zY3JvbGxlciBwYWdlXCI+XG4gICAgICAgIHtyZW5kZXJTdGF0dXModXNlcil9XG4gICAgICAgIHtyZW5kZXJQcm9maWxlKHVzZXIpfVxuICAgICAgICB7cmVuZGVyUmF0aW5ncyh1c2VyKX1cbiAgICAgICAge3JlbmRlckFjdGlvbnMoY3RybCl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGxheW91dC5mcmVlKGhlYWRlciwgcHJvZmlsZSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN0YXR1cyh1c2VyKSB7XG4gIGNvbnN0IHN0YXR1cyA9IHVzZXIub25saW5lID8gJ29ubGluZScgOiAnb2ZmbGluZSc7XG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwib25saW5lU3RhdHVzXCI+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9eyd1c2VyU3RhdHVzICcgKyBzdGF0dXN9IGRhdGEtaWNvbj0ncicgLz5cbiAgICAgIHtpMThuKHN0YXR1cyl9XG4gICAgPC9zZWN0aW9uPlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQcm9maWxlKHVzZXIpIHtcbiAgaWYgKCF1c2VyLnByb2ZpbGUpIHJldHVybiBudWxsO1xuICBcbiAgbGV0IGZ1bGxOYW1lID0gJyc7XG4gIGlmICh1c2VyLnByb2ZpbGUuZmlyc3ROYW1lKSBmdWxsTmFtZSArPSB1c2VyLnByb2ZpbGUuZmlyc3ROYW1lO1xuICBpZiAodXNlci5wcm9maWxlLmxhc3ROYW1lKSBmdWxsTmFtZSArPSAodXNlci5wcm9maWxlLmZpcnN0TmFtZSA/ICcgJyA6JycpICsgdXNlci5wcm9maWxlLmxhc3ROYW1lO1xuICAvLyBjb25zdCBjb3VudHJ5ID0gY291bnRyaWVzW3VzZXIucHJvZmlsZS5jb3VudHJ5XTtcbiAgY29uc3QgbG9jYXRpb24gPSB1c2VyLnByb2ZpbGUubG9jYXRpb247XG4gIGNvbnN0IG1lbWJlclNpbmNlID0gaTE4bignbWVtYmVyU2luY2UnKSArICcgJyArIHdpbmRvdy5tb21lbnQodXNlci5jcmVhdGVkQXQpLmZvcm1hdCgnTEwnKTtcbiAgY29uc3Qgc2VlbkF0ID0gdXNlci5zZWVuQXQgPyBpMThuKCdsYXN0TG9naW4nKSArICcgJyArIHdpbmRvdy5tb21lbnQodXNlci5zZWVuQXQpLmNhbGVuZGFyKCkgOiBudWxsO1xuXG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gY2xhc3NuYW1lPVwicHJvZmlsZVwiPlxuICAgICAge2Z1bGxOYW1lID9cbiAgICAgICA8aDMgY2xhc3NOYW1lPVwiZnVsbG5hbWVcIj57ZnVsbE5hbWV9PC9oMz46IG51bGxcbiAgICAgIH1cbiAgICAgIHt1c2VyLnByb2ZpbGUuYmlvID9cbiAgICAgICA8cCBjbGFzc05hbWU9XCJwcm9maWxlQmlvXCI+e3VzZXIucHJvZmlsZS5iaW99PC9wPjogbnVsbFxuICAgICAgfVxuICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidXNlckluZm9zXCI+XG4gICAgICAgICB7XG4gICAgICAgICAgIHVzZXIubGFuZ3VhZ2UgP1xuICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJsYW5ndWFnZSB3aXRoSWNvblwiPlxuICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWNvbW1lbnQtb1wiPlxuICAgICAgICAgICAgICAge2dldExhbmd1YWdlTmF0aXZlTmFtZSh1c2VyLmxhbmd1YWdlKX1cbiAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgIDwvcD4gOiBudWxsXG4gICAgICAgICB9XG4gICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImxvY2F0aW9uXCI+e2xvY2F0aW9ufTwvcD5cbiAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibWVtYmVyU2luY2VcIj57bWVtYmVyU2luY2V9PC9wPlxuICAgICAgICAgICB7c2VlbkF0ID9cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImxhc3RTZWVuXCI+e3NlZW5BdH08L3A+OiBudWxsXG4gICAgICAgICAgIH1cbiAgICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJhdGluZ3ModXNlcikge1xuICBmdW5jdGlvbiBpc1Nob3dpbmcocCkge1xuICAgIHJldHVybiBbXG4gICAgICAneXV6YmlyJywgJ2R1em9rZXknXG4gICAgXS5pbmRleE9mKHAua2V5KSE9PSAtMSB8fCBwLnBlcmYuZ2FtZXMgPiAwO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8c2VjdGlvbiBpZD1cInVzZXJQcm9maWxlUmF0aW5nc1wiIGNsYXNzTmFtZT1cInBlcmZzXCI+XG4gICAgICAvLyB7dXNlclBlcmZzKHVzZXIpLmZpbHRlcihpc1Nob3dpbmcpLm1hcChwID0+IHBlcmYocC5rZXksIHAubmFtZSwgcC5wZXJmLCB1c2VyKSl9XG4gICAgPC9zZWN0aW9uPlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJBY3Rpb25zKGN0cmwpIHtcbiAgY29uc3QgdXNlciA9IGN0cmwudXNlcigpO1xuICByZXR1cm4gKFxuICAgIDxzZWN0aW9uIGlkPVwidXNlclByb2ZpbGVBY3Rpb25zXCIgY2xhc3M9XCJub1BhZGRpbmdcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGlzdF9pdGVtX25hdlwiXG4gICAgICAgICAgIGNvbmZpZz17aGVscGVyLm9udG91Y2hZKGN0cmwuZ29Ub0dhbWVzKX1cbiAgICAgICAgICAga2V5PVwidmlld19hbGxfZ2FtZXNcIj5cbiAgICAgICAge2kxOG4oJ3ZpZXdBbGxOYkdhbWVzJywgdXNlci5jb3VudC5hbGwpfVxuICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuICApO1xufVxuIiwiaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJy4uLy4uL2h0dHAnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlcihpZCkge1xuICB2YXIgdXJsID0gJy9hcGkvdXNlci8nICsgaWQ7XG4gIHJldHVybiByZXF1ZXN0KHVybCwge30sIHRydWUpO1xufVxuIiwibGV0IGZvcmVncm91bmQgPSB0cnVlO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNGb3JlZ3JvdW5kKCkge1xuICByZXR1cm4gZm9yZWdyb3VuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEZvcmVncm91bmQoKSB7XG4gIGZvcmVncm91bmQgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QmFja2dyb3VuZCgpIHtcbiAgZm9yZWdyb3VuZCA9IGZhbHNlO1xufVxuIiwibGV0IGNhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmxldCBiYXRjaGluZyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gYmF0Y2hSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gIGlmICghYmF0Y2hpbmcpIHtcbiAgICBiYXRjaGluZyA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0cykgPT4ge1xuICAgICAgY29uc3QgYmF0Y2ggPSBjYWxsYmFja3M7XG4gICAgICBiYXRjaGluZyA9IGZhbHNlO1xuICAgICAgY2FsbGJhY2tzID0gbmV3IFNldCgpO1xuICAgICAgYmF0Y2guZm9yRWFjaChmID0+IGYodHMpKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4vcmVkcmF3JztcblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9yZWRyYXcoYWN0aW9uKSB7XG4gIGNvbnN0IHJlcyA9IGFjdGlvbigpO1xuICByZWRyYXcoKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlWGhyRXJyb3IoZXJyb3IpIHtcbiAgY29uc3Qgc3RhdHVzID0gZXJyb3Iuc3RhdHVzO1xuICBjb25zdCBkYXRhID0gZXJyb3IuYm9keTtcbiAgbGV0IG1lc3NhZ2U7XG5cbiAgaWYgKCFzdGF0dXMgfHwgc3RhdHVzID09PSAwKSB7XG4gICAgbWVzc2FnZSA9ICdveXVua2V5ZklzVW5yZWFjaGFibGUnO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgbWVzc2FnZSA9ICd1bmF1dGhvcml6ZWRFcnJvcic7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBtZXNzYWdlID0gJ3Jlc291cmNlTm90Rm91bmRFcnJvcic7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA1MDMpIHtcbiAgICBtZXNzYWdlID0gJ295dW5rZXlmSXNVbmF2YWlsYWJsZUVycm9yJztcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlID0gJ0Vycm9yLic7XG4gIH1cblxuICBtZXNzYWdlID0gaTE4bihtZXNzYWdlKTtcblxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSArPSBgICR7ZGF0YX1gO1xuIH1cbiAgZWxzZSBpZiAodHlwZW9mIGRhdGEuZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSArPSBgICR7aTE4bihkYXRhLmdsb2JhbFswXSl9YDtcbiAgfVxuICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KG1lc3NhZ2UsICdzaG9ydCcsICdjZW50ZXInKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRMb2NhbEpzb25GaWxlKHVybCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCB8fCB4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCh4aHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgfSk7XG59XG5cbmxldCBzcmk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50U3JpKCkge1xuICByZXR1cm4gc3JpIHx8IG5ld1NyaSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV3U3JpKCkge1xuICBzcmkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikuc2xpY2UoMCwgMTApO1xuICByZXR1cm4gc3JpO1xufVxuXG5leHBvcnQgY29uc3Qgb3l1bmtleWZTcmkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZWxsV29ya2VyKHdvcmtlciwgdG9waWMsIHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHRvcGljLCBwYXlsb2FkIH0pO1xuICB9IGVsc2Uge1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHRvcGljIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2tXb3JrZXIod29ya2VyLCBtc2csIGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgZnVuY3Rpb24gbGlzdGVuKGUpIHtcbiAgICAgIGlmIChlLmRhdGEudG9waWMgPT09IG1zZy50b3BpYykge1xuICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3Rlbik7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGUuZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGUuZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3Rlbik7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNOZXR3b3JrKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5jb25uZWN0aW9uLnR5cGUgIT09IENvbm5lY3Rpb24uTk9ORTtcbn1cblxuXG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBoYW5kbGVYaHJFcnJvcihlcnJvcikge1xuLy8gICB2YXIge3Jlc3BvbnNlOiBkYXRhLCBzdGF0dXN9ID0gZXJyb3I7XG4vLyAgIGlmICghaGFzTmV0d29yaygpKSB7XG4vLyAgICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhpMThuKCdub0ludGVybmV0Q29ubmVjdGlvbicpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgbGV0IG1lc3NhZ2U7XG4vLyAgICAgaWYgKCFzdGF0dXMgfHwgc3RhdHVzID09PSAwKSB7XG4vLyAgICAgICBtZXNzYWdlID0gJ295dW5rZXlmSXNVbnJlYWNoYWJsZSc7XG4vLyAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwMSkge1xuLy8gICAgICAgbWVzc2FnZSA9ICd1bmF1dGhvcml6ZWRFcnJvcic7XG4vLyAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuLy8gICAgICAgbWVzc2FnZSA9ICdyZXNvdXJjZU5vdEZvdW5kRXJyb3InO1xuLy8gICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSA1MDMpIHtcbi8vICAgICAgIG1lc3NhZ2UgPSAnb3l1bmtleWZJc1VuYXZhaWxhYmxlRXJyb3InO1xuLy8gICAgIH0gZWxzZSBpZiAoc3RhdHVzID49IDUwMCkge1xuLy8gICAgICAgbWVzc2FnZSA9ICdzZXJ2ZXJFcnJvcic7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIG1lc3NhZ2UgPSAnRXJyb3IuJztcbi8vICAgICB9XG5cbi8vICAgICBtZXNzYWdlID0gaTE4bihtZXNzYWdlKTtcblxuLy8gICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbi8vICAgICAgIG1lc3NhZ2UgKz0gYCAke2RhdGF9YDtcbi8vICAgICB9IGVsc2UgaWYgKGRhdGEuZ2xvYmFsICYmIGRhdGEuZ2xvYmFsLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuLy8gICAgICAgbWVzc2FnZSArPSBgICR7ZGF0YS5nbG9iYWxbMF19YDtcbi8vICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLmVycm9yID09PSAnc3RyaW5nJykge1xuLy8gICAgICAgbWVzc2FnZSArPSBgICR7ZGF0YS5lcnJvcn1gO1xuLy8gICAgIH1cblxuLy8gICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3cobWVzc2FnZSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICB9XG4vLyB9XG5cbmZ1bmN0aW9uIHBhcnRpYWxBcHBseShmbiwgYXJncykge1xuICByZXR1cm4gZm4uYmluZC5hcHBseShmbiwgW251bGxdLmNvbmNhdChhcmdzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsZigpIHtcbiAgcmV0dXJuIHBhcnRpYWxBcHBseShhcmd1bWVudHNbMF0sIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZigpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICBmbiA9IGFyZ3VtZW50c1swXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGZuLmFwcGx5KGZuLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwbGF5ZXJOYW1lKHBsYXllciwgd2l0aFJhdGluZykge1xuICBpZiAocGxheWVyLnVzZXJuYW1lIHx8IHBsYXllci51c2VyKSB7XG4gICAgdmFyIG5hbWUgPSBwbGF5ZXIudXNlcm5hbWUgfHwgcGxheWVyLnVzZXIudXNlcm5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgaWYgKHBsYXllci5haSkge1xuICAgIHJldHVybiBhaU5hbWUocGxheWVyLmFpKTtcbiAgfVxuXG4gIGlmIChwbGF5ZXIuc2lkZSkge1xuICAgIHJldHVybiBpMThuKHBsYXllci5zaWRlKTtcbiAgfVxuXG4gIHJldHVybiBpMThuKCdhbm9ueW1vdXMnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFpTmFtZShsZXZlbCkge1xuICByZXR1cm4gaTE4bignYWlCb3QnLCBsZXZlbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYWNrSGlzdG9yeSgpIHtcbiAgc2V0Vmlld1NsaWRlRGlyZWN0aW9uKCdid2QnKTtcbiAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IuYXBwICYmIHdpbmRvdy5uYXZpZ2F0b3IuYXBwLmJhY2tIaXN0b3J5KSB7XG4gICAgd2luZG93Lm5hdmlnYXRvci5hcHAuYmFja0hpc3RvcnkoKTtcbiAgfVxuICBlbHNlXG4gICAgd2luZG93Lmhpc3RvcnkuZ28oLTEpO1xufVxuXG4vLyBzaW1wbGUgd2F5IHRvIGRldGVybWluZSB2aWV3cyBhbmltYXRpb24gZGlyZWN0aW9uXG52YXIgdmlld1NsaWRlRGlyZWN0aW9uID0gJ2Z3ZCc7XG5leHBvcnQgZnVuY3Rpb24gc2V0Vmlld1NsaWRlRGlyZWN0aW9uKGQpIHtcbiAgdmlld1NsaWRlRGlyZWN0aW9uID0gZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3U2xpZGVEaXJlY3Rpb24oKSB7XG4gIHJldHVybiB2aWV3U2xpZGVEaXJlY3Rpb247XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJvYXJkQm91bmRzKHZpZXdwb3J0RGltLCBpc1BvcnRyYWl0LCBpc0lwYWRMaWtlLCBtb2RlKSB7XG4gIGNvbnN0IHsgdmgsIHZ3IH0gPSB2aWV3cG9ydERpbTtcbiAgY29uc3QgdG9wID0gNTA7XG5cbiAgaWYgKGlzUG9ydHJhaXQpIHtcbiAgICAvLyBjb25zdCBjb250ZW50SGVpZ2h0ID0gdmggLSA1MDtcbiAgICAvLyBjb25zdCBwVG9wID0gNTAgKyAobW9kZSA9PT0gJ2dhbWUnID8gKChjb250ZW50SGVpZ2h0IC0gdncgLSA0MCkgLyAyKSA6IDApO1xuICAgIGNvbnN0IGNvbnRlbnRIZWlnaHQgPSB2aDtcbiAgICBjb25zdCBwVG9wID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwVG9wLFxuICAgICAgcmlnaHQ6IHZ3LFxuICAgICAgYm90dG9tOiBwVG9wICsgdncsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgd2lkdGg6IHZ3LFxuICAgICAgaGVpZ2h0OiB2d1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc3QgbFNpZGUgPSB2aCAtIHRvcDtcbiAgICBjb25zdCBsU2lkZSA9IHZoIC0gNTtcbiAgICBjb25zdCBsV2lkdGggPSB2dyAtIDU7IC8vIGxTaWRlICogKDQvMyk7XG4gICAgY29uc3Qgc3BhY2VDZW50ZXIgPSB2dyAtIGxXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wLFxuICAgICAgcmlnaHQ6IGxTaWRlLFxuICAgICAgYm90dG9tOiB0b3AgKyBsU2lkZSxcbiAgICAgIGxlZnQ6IHNwYWNlQ2VudGVyIC8gMixcbiAgICAgIHdpZHRoOiBsV2lkdGgsXG4gICAgICBoZWlnaHQ6IGxTaWRlXG4gICAgfTtcbiAgfVxufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gYXV0b3JlZHJhdyhhY3Rpb24pIHtcbi8vICAgbS5zdGFydENvbXB1dGF0aW9uKCk7XG4vLyAgIHRyeSB7XG4vLyAgICAgcmV0dXJuIGFjdGlvbigpO1xuLy8gICB9IGZpbmFsbHkge1xuLy8gICAgIG0uZW5kQ29tcHV0YXRpb24oKTtcbi8vICAgfVxuLy8gfVxuXG5jb25zdCBwZXJmSWNvbnNNYXAgPSB7XG4gIHl1emJpcjogJ1QnLFxuICBkdXpva2V5OiAnKydcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnYW1lSWNvbihwZXJmKSB7XG4gIHJldHVybiBwZXJmSWNvbnNNYXBbcGVyZl0gfHwgJzgnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TWFzYUR1cmF0aW9uKHJvdW5kcywgc2NvcmVzKSB7XG4gIHJldHVybiByb3VuZHMgPyByb3VuZHMgKyBpMThuKCdoYW5kcycpIDogc2NvcmVzICsgaTE4bignc2NvcmVzJylbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWQobnVtLCBzaXplKSB7XG4gIHZhciBzID0gbnVtICsgJyc7XG4gIHdoaWxlIChzLmxlbmd0aCA8IHNpemUpIHMgPSAnMCcgKyBzO1xuICByZXR1cm4gcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYWZlU3RyaW5nVG9OdW0ocykge1xuICBjb25zdCBuID0gTnVtYmVyKHMpO1xuICByZXR1cm4gaXNOYU4obikgPyB1bmRlZmluZWQgOiBuO1xufVxuIiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR296YWxhL3F1ZXJ5c3RyaW5nXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVByaW1pdGl2ZSAodikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gIGNhc2UgJ3N0cmluZyc6XG4gICAgcmV0dXJuIHY7XG5cbiAgY2FzZSAnYm9vbGVhbic6XG4gICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gIGNhc2UgJ251bWJlcic6XG4gICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFF1ZXJ5U3RyaW5nKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICBsZXQga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59XG4iLCJpbXBvcnQgc2lnbmFscyBmcm9tICcuLi9zaWduYWxzJztcbmltcG9ydCB7IGJhdGNoUmVxdWVzdEFuaW1hdGlvbkZyYW1lIH0gZnJvbSAnLi9iYXRjaFJBRic7XG5cbmV4cG9ydCBjb25zdCByZWRyYXdTeW5jID0gc2lnbmFscy5yZWRyYXcuZGlzcGF0Y2g7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgLy8gY29uc29sZS50cmFjZSgpO1xuICBiYXRjaFJlcXVlc3RBbmltYXRpb25GcmFtZShyZWRyYXdTeW5jKTtcbn1cbiIsImNvbnN0IElETEVfVElNRVJfREVMQVkgPSAxNSAqIDYwICogMTAwMFxuY29uc3QgU0xFRVBfREVMQVkgPSA2MCAqIDYwICogMTAwMFxuXG5sZXQgc2xlZXBBZ2FpblRpbWVvdXRJZFxubGV0IGNhbmNlbFRpbWVyXG5cbmV4cG9ydCBmdW5jdGlvbiBrZWVwQXdha2UoKSB7XG4gIHdpbmRvdy5wbHVnaW5zLmluc29tbmlhLmtlZXBBd2FrZSgpXG4gIGlmIChjYW5jZWxUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2FuY2VsVGltZXIoKVxuICB9XG4gIGNhbmNlbFRpbWVyID0gaWRsZVRpbWVyKFxuICAgIElETEVfVElNRVJfREVMQVksXG4gICAgKCkgPT4ge1xuICAgICAgc2xlZXBBZ2FpblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3aW5kb3cucGx1Z2lucy5pbnNvbW5pYS5hbGxvd1NsZWVwQWdhaW4oKVxuICAgICAgfSwgU0xFRVBfREVMQVkpXG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoc2xlZXBBZ2FpblRpbWVvdXRJZClcbiAgICB9XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbG93U2xlZXBBZ2FpbigpIHtcbiAgaWYgKGNhbmNlbFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBjYW5jZWxUaW1lcigpXG4gICAgY2FuY2VsVGltZXIgPSB1bmRlZmluZWRcbiAgfVxuICB3aW5kb3cucGx1Z2lucy5pbnNvbW5pYS5hbGxvd1NsZWVwQWdhaW4oKVxufVxuXG5mdW5jdGlvbiBpZGxlVGltZXIoZGVsYXksIG9uSWRsZSwgb25XYWtlVXApIHtcbiAgY29uc3QgZXZlbnRzID0gWyd0b3VjaHN0YXJ0J11cbiAgbGV0IGxpc3RlbmluZyA9IGZhbHNlXG4gIGxldCBhY3RpdmUgPSB0cnVlXG4gIGxldCBsYXN0U2VlbkFjdGl2ZSA9IERhdGUubm93KClcbiAgbGV0IGludGVydmFsSURcbiAgY29uc3Qgb25BY3Rpdml0eSA9ICgpID0+IHtcbiAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ1dha2UgdXAnKVxuICAgICAgb25XYWtlVXAoKVxuICAgIH1cbiAgICBhY3RpdmUgPSB0cnVlXG4gICAgbGFzdFNlZW5BY3RpdmUgPSBEYXRlLm5vdygpXG4gICAgc3RvcExpc3RlbmluZygpXG4gIH1cbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAoKSA9PiB7XG4gICAgaWYgKCFsaXN0ZW5pbmcpIHtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZSwgb25BY3Rpdml0eSlcbiAgICAgIH0pXG4gICAgICBsaXN0ZW5pbmcgPSB0cnVlXG4gICAgfVxuICB9XG4gIGNvbnN0IHN0b3BMaXN0ZW5pbmcgPSAoKSA9PiB7XG4gICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgZXZlbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBvbkFjdGl2aXR5KVxuICAgICAgfSlcbiAgICAgIGxpc3RlbmluZyA9IGZhbHNlXG4gICAgfVxuICB9XG4gIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSUQpXG4gICAgc3RvcExpc3RlbmluZygpXG4gIH1cbiAgaW50ZXJ2YWxJRCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICBpZiAoYWN0aXZlICYmIERhdGUubm93KCkgLSBsYXN0U2VlbkFjdGl2ZSA+IGRlbGF5KSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnSWRsZSBtb2RlJylcbiAgICAgIG9uSWRsZSgpXG4gICAgICBhY3RpdmUgPSBmYWxzZVxuICAgIH1cbiAgICBzdGFydExpc3RlbmluZygpXG4gIH0sIDMwICogMTAwMClcblxuICByZXR1cm4gY2FuY2VsXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gdGVsbFdvcmtlcih3b3JrZXIsIHRvcGljLCBwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0b3BpYywgcGF5bG9hZCB9KTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0b3BpYyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNrV29ya2VyKHdvcmtlciwgbXNnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnVuY3Rpb24gbGlzdGVuKGUpIHtcbiAgICAgIGlmIChlLmRhdGEudG9waWMgPT09IG1zZy50b3BpYyAmJiAobXNnLnJlcWlkID09PSB1bmRlZmluZWQgfHwgZS5kYXRhLnJlcWlkID09PSBtc2cucmVxaWQpKSB7XG4gICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuKTtcbiAgICAgICAgcmVzb2x2ZShlLmRhdGEucGF5bG9hZCk7XG4gICAgICB9IGVsc2UgaWYgKGUuZGF0YS50b3BpYyA9PT0gJ2Vycm9yJyAmJiBlLmRhdGEucGF5bG9hZC5jYWxsZXJUb3BpYyA9PT0gbXNnLnRvcGljICYmIChcbiAgICAgICAgbXNnLnJlcWlkID09PSB1bmRlZmluZWQgfHwgZS5kYXRhLnJlcWlkID09PSBtc2cucmVxaWQpKSB7XG4gICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuKTtcbiAgICAgICAgcmVqZWN0KGUuZGF0YS5wYXlsb2FkLmVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW4pO1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9KTtcbn1cbiIsImltcG9ydCB7IGZldGNoSlNPTiB9IGZyb20gJy4vaHR0cCc7XG5pbXBvcnQgeyBjdXJyZW50U3JpLCBub29wIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuL3Nlc3Npb24nO1xuXG4vLyBleHBvcnQgbGV0IGNhY2hlZFBvb2xzID0gW107XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBuZXdHYW1lKCkge1xuLy8gICBjb25zdCBjb25maWcgPSBzZXR0aW5ncy5nYW1lU2V0dXAuaHVtYW47XG5cbi8vICAgY29uc3QgZGF0YSA9IHtcbi8vICAgICB2YXJpYW50OiBjb25maWcudmFyaWFudCgpLFxuLy8gICAgIHJvdW5kczogY29uZmlnLnJvdW5kcygpLFxuLy8gICAgIG1vZGU6IHNlc3Npb24uaXNDb25uZWN0ZWQoKSA/IGNvbmZpZy5tb2RlKCkgOiAnMCcsXG4vLyAgICAgbWVtYmVyc09ubHk6IHNlc3Npb24uaXNDb25uZWN0ZWQoKSA/IGNvbmZpZy5tZW1iZXJzT25seSgpIDogZmFsc2Vcbi8vICAgfTtcblxuLy8gICByZXR1cm4gcmVxdWVzdCgnL21hc2EvbmV3Jywge1xuLy8gICAgIG1ldGhvZDogJ1BPU1QnLFxuLy8gICAgIGRhdGFcbi8vICAgfSwgdHJ1ZSk7XG4vLyB9XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBsb2JieShmZWVkYmFjaykge1xuLy8gICByZXR1cm4gcmVxdWVzdCgnLycsIG51bGwsIGZlZWRiYWNrKTtcbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGdhbWUoaWQsIGJhY2tncm91bmQpIHtcbi8vICAgdmFyIHVybCA9ICcvJyArIGlkO1xuLy8gICByZXR1cm4gcmVxdWVzdCh1cmwsIHsgYmFja2dyb3VuZCB9LCB0cnVlKTtcbi8vIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbWUoaWQpIHtcbiAgbGV0IHVybCA9ICcvJyArIGlkO1xuICByZXR1cm4gZmV0Y2hKU09OKHVybCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWVrR2FtZShzZXR1cCkge1xuICBjb25zdCB7IC4uLnJlc3QgfSA9IHNldHVwO1xuXG4gIGxldCBib2R5O1xuXG4gIGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7IC4uLnJlc3QgfSk7XG5cbiAgcmV0dXJuIGZldGNoSlNPTignL21hc2EvbmV3Jywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHlcbiAgfSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTZXJ2ZXJMYW5nKGxhbmcpIHtcbiAgaWYgKHNlc3Npb24uaXNDb25uZWN0ZWQoKSkge1xuICAgIC8vIHJldHVybiByZXF1ZXN0KCcvdHJhbnNsYXRpb24vc2VsZWN0Jywge1xuICAgIC8vICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgLy8gICBkYXRhOiB7IGxhbmcgfVxuICAgIC8vIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbiJdfQ==
