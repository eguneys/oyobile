(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.Okeyground=e()}}(function(){var e;return function(){function e(t,n,r){function a(o,u){if(!n[o]){if(!t[o]){var l="function"==typeof require&&require;if(!u&&l)return l(o,!0);if(i)return i(o,!0);var d=new Error("Cannot find module '"+o+"'");throw d.code="MODULE_NOT_FOUND",d}var s=n[o]={exports:{}};t[o][0].call(s.exports,function(e){var n=t[o][1][e];return a(n||e)},s,s.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)a(r[o]);return a}return e}()({1:[function(e,t,n){!function(e){function n(e,t){if("object"!==a(e))return t;for(var r in t)"object"===a(e[r])&&"object"===a(t[r])?e[r]=n(e[r],t[r]):e[r]=t[r];return e}function r(e,t,r){var o=r[0],u=r.length;(e||"object"!==a(o))&&(o={});for(var l=0;l<u;++l){var d=r[l],s=a(d);if("object"===s)for(var c in d)if("__proto__"!==c){var f=e?i.clone(d[c]):d[c];t?o[c]=n(o[c],f):o[c]=f}}return o}function a(e){return{}.toString.call(e).slice(8,-1).toLowerCase()}var i=function(e){return r(e===!0,!1,arguments)},o="merge";i.recursive=function(e){return r(e===!0,!0,arguments)},i.clone=function(e){var t,n,r=e,o=a(e);if("array"===o)for(r=[],n=e.length,t=0;t<n;++t)r[t]=i.clone(e[t]);else if("object"===o){r={};for(t in e)r[t]=i.clone(e[t])}return r},e?t.exports=i:window[o]=i}("object"==typeof t&&t&&"object"==typeof t.exports&&t.exports)},{}],2:[function(t,n,r){!function(t,r){"use strict";var a=r(t);"undefined"==typeof window&&a.deps({document:"undefined"!=typeof document?document:{},location:"undefined"!=typeof location?location:{},clearTimeout:clearTimeout,setTimeout:setTimeout}),"object"==typeof n&&null!=n&&n.exports?n.exports=a:"function"==typeof e&&e.amd?e(function(){return a}):t.m=a}("undefined"!=typeof window?window:this,function a(e,t){"use strict";function n(e){return"function"==typeof e}function r(e){return"[object Object]"===Ke.call(e)}function i(e){return"[object String]"===Ke.call(e)}function o(){}function u(e){xe=e.document,Se=e.location,Me=e.cancelAnimationFrame||e.clearTimeout,Ee=e.requestAnimationFrame||e.setTimeout}function l(e,t){for(var n,r=[],a=/(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;n=a.exec(t);)if(""===n[1]&&n[2])e.tag=n[2];else if("#"===n[1])e.attrs.id=n[2];else if("."===n[1])r.push(n[2]);else if("["===n[3].charAt(0)){var i=n[6];i&&(i=i.replace(/\\(["'])/g,"$1")),"class"===n[4]?r.push(i):e.attrs[n[4]]=i||!0}return r}function d(e,t){var n=t?e.slice(1):e;return 1===n.length&&Te(n[0])?n[0]:n}function s(e,t,n){var r="class"in t?"class":"className";for(var a in t)Ce.call(t,a)&&(a===r&&null!=t[a]&&""!==t[a]?(n.push(t[a]),e[a]=""):e[a]=t[a]);n.length&&(e[r]=n.join(" "))}function c(e,t){for(var a=[],o=1,u=arguments.length;o<u;o++)a[o-1]=arguments[o];if(e&&n(e.view))return ae(e,a);if(!i(e))throw new Error("selector in m(selector, attrs, children) should be a string");var c=null!=t&&r(t)&&!("tag"in t||"view"in t||"subtree"in t),f=c?t:{},p={tag:"div",attrs:{},children:d(a,c)};return s(p.attrs,f,l(p,e)),p}function f(e,t){for(var n=0;n<e.length&&!t(e[n],n++););}function p(e,t){f(e,function(e,n){return(e=e&&e.attrs)&&null!=e.key&&t(e,n)})}function v(e){try{if("boolean"!=typeof e&&null!=e&&null!=e.toString())return e}catch(t){}return""}function m(e,t,n,r){try{h(e,t,n),t.nodeValue=r}catch(a){}}function g(e){for(var t=0;t<e.length;t++)Te(e[t])&&(e=e.concat.apply([],e),t--);return e}function h(e,t,n){e.insertBefore(t,e.childNodes[n]||null)}function y(e,t,n,r){p(e,function(e,r){t[e=e.key]=t[e]?{action:je,index:r,from:t[e].index,element:n.nodes[t[e].index]||xe.createElement("div")}:{action:Be,index:r}});var a=[];for(var i in t)Ce.call(t,i)&&a.push(t[i]);var o=a.sort(q),u=new Array(n.length);return u.nodes=n.nodes.slice(),f(o,function(t){var a=t.index;if(t.action===De&&(V(n[a].nodes,n[a]),u.splice(a,1)),t.action===Be){var i=xe.createElement("div");i.key=e[a].attrs.key,h(r,i,a),u.splice(a,0,{attrs:{key:e[a].attrs.key},nodes:[i]}),u.nodes[a]=i}if(t.action===je){var o=t.element,l=r.childNodes[a];l!==o&&null!==o&&r.insertBefore(o,l||null),u[a]=n[t.from],u.nodes[a]=o}}),u}function w(e,t,n,r){var a=e.length!==t.length;return a||p(e,function(e,n){var r=t[n];return a=r&&r.attrs&&r.attrs.key!==e.key}),a?y(e,n,t,r):t}function b(e,t,n){f(e,function(e,r){null!=t[r]&&n.push.apply(n,t[r].nodes)}),f(t.nodes,function(e,r){null!=e.parentNode&&n.indexOf(e)<0&&V([e],[t[r]])}),e.length<t.length&&(t.length=e.length),t.nodes=n}function P(e){var t=0;p(e,function(){return f(e,function(e){(e=e&&e.attrs)&&null==e.key&&(e.key="__mithril__"+t++)}),1})}function k(e,t,n){return e.tag!==t.tag||(n.sort().join()!==Object.keys(t.attrs).sort().join()||(e.attrs.id!==t.attrs.id||(e.attrs.key!==t.attrs.key||("all"===c.redraw.strategy()?!t.configContext||t.configContext.retain!==!0:"diff"===c.redraw.strategy()&&(t.configContext&&t.configContext.retain===!1)))))}function O(e,t,r){k(e,t,r)&&(t.nodes.length&&V(t.nodes),t.configContext&&n(t.configContext.onunload)&&t.configContext.onunload(),t.controllers&&f(t.controllers,function(e){e.onunload&&e.onunload({preventDefault:o})}))}function x(e,t){return e.attrs.xmlns?e.attrs.xmlns:"svg"===e.tag?"http://www.w3.org/2000/svg":"math"===e.tag?"http://www.w3.org/1998/Math/MathML":t}function S(e,t,n){n.length&&(e.views=t,e.controllers=n,f(n,function(e){if(e.onunload&&e.onunload.$old&&(e.onunload=e.onunload.$old),Re&&e.onunload){var t=e.onunload;e.onunload=function(){},e.onunload.$old=t}}))}function E(e,t,r,a,i){if(n(t.attrs.config)){var o=i.configContext=i.configContext||{};e.push(function(){return t.attrs.config.call(t,r,!a,o,i)})}}function M(e,n,r,a,i,o,u,l){var d=e.nodes[0];return a&&J(d,n.tag,n.attrs,e.attrs,i),e.children=U(d,n.tag,t,t,n.children,e.children,!1,0,n.attrs.contenteditable?d:r,i,u),e.nodes.intact=!0,l.length&&(e.views=o,e.controllers=l),d}function C(e,t,n){var r;e.$trusted?r=ee(t,n,e):(r=[xe.createTextNode(e)],t.nodeName in Ae||h(t,r[0],n));var a;return a="string"==typeof e||"number"==typeof e||"boolean"==typeof e?new e.constructor(e):e,a.nodes=r,a}function K(e,t,n,r,a,i){var o=t.nodes;return r&&r===xe.activeElement&&e===t||(e.$trusted?(V(o,t),o=ee(n,a,e)):"textarea"===i?n.value=e:r?(r.innerHTML=e,o=[].slice.call(r.childNodes)):((1===o[0].nodeType||o.length>1||o[0].nodeValue.trim&&!o[0].nodeValue.trim())&&(V(t.nodes,t),o=[xe.createTextNode(e)]),m(n,o[0],a,e))),t=new e.constructor(e),t.nodes=o,t.$trusted=e.$trusted,t}function T(e,t,n,r,a,i,o){return e.nodes.length?e.valueOf()!==t.valueOf()||a?K(t,e,r,i,n,o):(e.nodes.intact=!0,e):C(t,r,n)}function A(e){return e.$trusted?e.nodes.length:Te(e)?e.length:1}function D(e,n,r,a,i,o,u,l,d){e=g(e);var s=[],c=n.length===e.length,f=0,v={},m=!1;p(n,function(e,t){m=!0,v[n[t].attrs.key]={action:De,index:t}}),P(e),m&&(n=w(e,n,v,r));for(var h=0,y=0,k=e.length;y<k;y++){var O=U(r,i,n,a,e[y],n[h],o,a+f||f,u,l,d);O!==t&&(c=c&&O.nodes.intact,f+=A(O),n[h++]=O)}return c||b(e,n,s),n}function B(e,t,n,r,a){if(null!=t){if(Ke.call(t)===Ke.call(e))return t;if(a&&a.nodes){var i=n-r,o=i+(Te(e)?e:t.nodes).length;V(a.nodes.slice(i,o),a.slice(i,o))}else t.nodes&&V(t.nodes,t)}return t=new e.constructor,t.tag&&(t={}),t.nodes=[],t}function j(e,t){return e.attrs.is?null==t?xe.createElement(e.tag,e.attrs.is):xe.createElementNS(t,e.tag,e.attrs.is):null==t?xe.createElement(e.tag):xe.createElementNS(t,e.tag)}function R(e,t,n,r){return r?J(t,e.tag,e.attrs,{},n):e.attrs}function L(e,n,r,a,i,o){return null!=e.children&&e.children.length>0?U(n,e.tag,t,t,e.children,r.children,!0,0,e.attrs.contenteditable?n:a,i,o):e.children}function G(e,t,n,r,a,i,o){var u={tag:e.tag,attrs:t,children:n,nodes:[r]};return S(u,i,o),u.children&&!u.children.nodes&&(u.children.nodes=[]),u}function F(e,t,r,a){var i;return i="diff"===c.redraw.strategy()&&e?e.indexOf(t):-1,i>-1?r[i]:n(a)?new a:{}}function N(e,t,n,r){null!=r.onunload&&Ge.map(function(e){return e.handler}).indexOf(r.onunload)<0&&Ge.push({controller:r,handler:r.onunload}),e.push(n),t.push(r)}function _(e,t,n,r,a,i){var o=F(n.views,t,r,e.controller),u=e&&e.attrs&&e.attrs.key;return e=0===Re||Fe||r&&r.indexOf(o)>-1?e.view(o):{tag:"placeholder"},"retain"===e.subtree?e:(e.attrs=e.attrs||{},e.attrs.key=u,N(i,a,t,o),e)}function I(e,t,n,r){for(var a=t&&t.controllers;null!=e.view;)e=_(e,e.view.$original||e.view,t,a,r,n);return e}function H(e,t,n,r,a,o,u,l){var d=[],s=[];if(e=I(e,t,d,s),"retain"===e.subtree)return t;if(!e.tag&&s.length)throw new Error("Component template must return a virtual element, not an array, string, etc.");e.attrs=e.attrs||{},t.attrs=t.attrs||{};var c=Object.keys(e.attrs),f=c.length>("key"in e.attrs?1:0);if(O(e,t,c),i(e.tag)){var p=0===t.nodes.length;u=x(e,u);var v;if(p){v=j(e,u);var m=R(e,v,u,f);h(r,v,a);var g=L(e,v,t,n,u,l);t=G(e,m,g,v,u,d,s)}else v=M(t,e,n,f,u,d,l,s);return"select"===e.tag&&"value"in e.attrs&&J(v,e.tag,{value:e.attrs.value},{},u),p||o!==!0||null==v||h(r,v,a),E(l,e,v,p,t),t}}function U(e,t,a,i,o,u,l,d,s,c,f){return o=v(o),"retain"===o.subtree?u:(u=B(o,u,d,i,a),Te(o)?D(o,u,e,d,t,l,s,c,f):null!=o&&r(o)?H(o,u,s,e,d,l,c,f):n(o)?u:T(u,o,d,e,l,s,t))}function q(e,t){return e.action-t.action||e.index-t.index}function X(e,t,n){n===t&&(e.style="",n={});for(var r in t)Ce.call(t,r)&&(null!=n&&n[r]===t[r]||(e.style[r]=t[r]));for(r in n)Ce.call(n,r)&&(Ce.call(t,r)||(e.style[r]=""))}function z(e,t,a,i,o,u){if("config"===t||"key"===t)return!0;if(n(a)&&"on"===t.slice(0,2))e[t]=te(a,e);else if("style"===t&&null!=a&&r(a))X(e,a,i);else if(null!=u)"href"===t?e.setAttributeNS("http://www.w3.org/1999/xlink","href",a):e.setAttribute("className"===t?"class":t,a);else if(t in e&&!Ne[t])try{("input"!==o&&!e.isContentEditable||e[t]!=a)&&(e[t]=a)}catch(l){e.setAttribute(t,a)}else try{e.setAttribute(t,a)}catch(l){}}function $(e,t,n,r,a,i,o){if(t in a&&r===n&&"object"!=typeof n&&xe.activeElement!==e)"value"===t&&"input"===i&&e.value!=n&&(e.value=n);else{a[t]=n;try{return z(e,t,n,r,i,o)}catch(u){if(u.message.indexOf("Invalid argument")<0)throw u}}}function J(e,t,n,r,a){for(var i in n)!Ce.call(n,i)||!$(e,i,n[i],r[i],r,t,a);return r}function V(e,t){for(var n=e.length-1;n>-1;n--)if(e[n]&&e[n].parentNode){try{e[n].parentNode.removeChild(e[n])}catch(r){}t=[].concat(t),t[n]&&Y(t[n])}e.length&&(e.length=0)}function Y(e){e.configContext&&n(e.configContext.onunload)&&(e.configContext.onunload(),e.configContext.onunload=null),e.controllers&&f(e.controllers,function(e){n(e.onunload)&&e.onunload({preventDefault:o})}),e.children&&(Te(e.children)?f(e.children,Y):e.children.tag&&Y(e.children))}function Q(e,t){try{e.appendChild(xe.createRange().createContextualFragment(t))}catch(n){e.insertAdjacentHTML("beforeend",t),W(e)}}function W(e){if("SCRIPT"===e.tagName)e.parentNode.replaceChild(Z(e),e);else{var t=e.childNodes;if(t&&t.length)for(var n=0;n<t.length;n++)W(t[n])}return e}function Z(e){for(var t=document.createElement("script"),n=e.attributes,r=0;r<n.length;r++)t.setAttribute(n[r].name,n[r].value);return t.text=e.innerHTML,t}function ee(e,t,n){var r=e.childNodes[t];if(r){var a=1!==r.nodeType,i=xe.createElement("span");a?(e.insertBefore(i,r||null),i.insertAdjacentHTML("beforebegin",n),e.removeChild(i)):r.insertAdjacentHTML("beforebegin",n)}else Q(e,n);for(var o=[];e.childNodes[t]!==r;)o.push(e.childNodes[t]),t++;return o}function te(e,t){return function(n){n=n||event,c.redraw.strategy("diff"),c.startComputation();try{return e.call(t,n)}finally{le()}}}function ne(e){var t=Ie.indexOf(e);return t<0?Ie.push(e)-1:t}function re(e){function t(){return arguments.length&&(e=arguments[0]),e}return t.toJSON=function(){return e&&n(e.toJSON)?e.toJSON():e},t}function ae(e,t){function n(){return(e.controller||o).apply(this,t)||this}function r(n){for(var r=[n].concat(t),a=1;a<arguments.length;a++)r.push(arguments[a]);return e.view.apply(e,r)}e.controller&&(n.prototype=e.controller.prototype),r.$original=e.view;var a={controller:n,view:r};return t[0]&&null!=t[0].key&&(a.attrs={key:t[0].key}),a}function ie(e,t,n,r){if(!r){c.redraw.strategy("all"),c.startComputation(),qe[n]=t;var a;a=Ue=e?e:e={controller:o};var i=new(e.controller||o);return a===Ue&&(ze[n]=i,Xe[n]=e),le(),null===e&&oe(t,n),ze[n]}null==e&&oe(t,n),Ze&&(We=Ze)}function oe(e,t){qe.splice(t,1),ze.splice(t,1),Xe.splice(t,1),me(e),Ie.splice(ne(e),1),Ge=[]}function ue(){Ve&&(Ve(),Ve=null),f(qe,function(e,t){var n=Xe[t];if(ze[t]){var r=[ze[t]];c.render(e,n.view?n.view(ze[t],r):"")}}),Ye&&(Ye(),Ye=null),$e=null,Je=new Date,c.redraw.strategy("diff")}function le(){"none"===c.redraw.strategy()?(Re--,c.redraw.strategy("diff")):c.endComputation()}function de(e){return e.slice(nt[c.route.mode].length)}function se(e,t,n){tt={};var r=n.indexOf("?");r!==-1&&(tt=ve(n.substr(r+1,n.length)),n=n.substr(0,r));var a=Object.keys(t),i=a.indexOf(n);if(i!==-1)return c.mount(e,t[a[i]]),!0;for(var o in t)if(Ce.call(t,o)){if(o===n)return c.mount(e,t[o]),!0;var u=new RegExp("^"+o.replace(/:[^\/]+?\.{3}/g,"(.*?)").replace(/:[^\/]+/g,"([^\\/]+)")+"/?$");if(u.test(n))return n.replace(u,function(){var n=o.match(/:[^\/]+/g)||[],r=[].slice.call(arguments,1,-2);f(n,function(e,t){tt[e.replace(/:|\./g,"")]=decodeURIComponent(r[t])}),c.mount(e,t[o])}),!0}}function ce(e){if(e=e||event,!(e.ctrlKey||e.metaKey||e.shiftKey||2===e.which)){e.preventDefault?e.preventDefault():e.returnValue=!1;var t,n=e.currentTarget||e.srcElement;for(t="pathname"===c.route.mode&&n.search?ve(n.search.slice(1)):{};n&&!/a/i.test(n.nodeName);)n=n.parentNode;Re=0,c.route(n[c.route.mode].slice(nt[c.route.mode].length),t)}}function fe(){"hash"!==c.route.mode&&Se.hash?Se.hash=Se.hash:e.scrollTo(0,0)}function pe(e,n){var a={},i=[];for(var o in e)if(Ce.call(e,o)){var u=n?n+"["+o+"]":o,l=e[o];if(null===l)i.push(encodeURIComponent(u));else if(r(l))i.push(pe(l,u));else if(Te(l)){var d=[];a[u]=a[u]||{},f(l,function(e){a[u][e]||(a[u][e]=!0,d.push(encodeURIComponent(u)+"="+encodeURIComponent(e)))}),i.push(d.join("&"))}else l!==t&&i.push(encodeURIComponent(u)+"="+encodeURIComponent(l))}return i.join("&")}function ve(e){if(""===e||null==e)return{};"?"===e.charAt(0)&&(e=e.slice(1));var t=e.split("&"),n={};return f(t,function(e){var t=e.split("="),r=decodeURIComponent(t[0]),a=2===t.length?decodeURIComponent(t[1]):null;null!=n[r]?(Te(n[r])||(n[r]=[n[r]]),n[r].push(a)):n[r]=a}),n}function me(e){var n=ne(e);V(e.childNodes,He[n]),He[n]=t}function ge(e,t){var n=c.prop(t);return e.then(n),n.then=function(n,r){return ge(e.then(n,r),t)},n["catch"]=n.then.bind(null,null),n}function he(e,t){function a(e){l=e||lt,s.map(function(e){l===ut?e.resolve(d):e.reject(d)})}function i(e,t,a,i){if((null!=d&&r(d)||n(d))&&n(e))try{var o=0;e.call(d,function(e){o++||(d=e,t())},function(e){o++||(d=e,a())})}catch(u){c.deferred.onerror(u),d=u,a()}else i()}function o(){var r;try{r=d&&d.then}catch(s){return c.deferred.onerror(s),d=s,l=ot,o()}l===ot&&c.deferred.onerror(d),i(r,function(){l=it,o()},function(){l=ot,o()},function(){try{l===it&&n(e)?d=e(d):l===ot&&n(t)&&(d=t(d),l=it)}catch(o){return c.deferred.onerror(o),d=o,a()}d===u?(d=TypeError(),a()):i(r,function(){a(ut)},a,function(){a(l===it&&ut)})})}var u=this,l=0,d=0,s=[];u.promise={},u.resolve=function(e){return l||(d=e,l=it,o()),u},u.reject=function(e){return l||(d=e,l=ot,o()),u},u.promise.then=function(e,t){var n=new he(e,t);return l===ut?n.resolve(d):l===lt?n.reject(d):s.push(n),n.promise}}function ye(e){return e}function we(n){var r=n.callbackName||"mithril_callback_"+(new Date).getTime()+"_"+Math.round(1e16*Math.random()).toString(36),a=xe.createElement("script");e[r]=function(i){a.parentNode.removeChild(a),n.onload({type:"load",target:{responseText:i}}),e[r]=t},a.onerror=function(){return a.parentNode.removeChild(a),n.onerror({type:"error",target:{status:500,responseText:JSON.stringify({error:"Error making jsonp request"})}}),e[r]=t,!1},a.onload=function(){return!1},a.src=n.url+(n.url.indexOf("?")>0?"&":"?")+(n.callbackKey?n.callbackKey:"callback")+"="+r+"&"+pe(n.data||{}),xe.body.appendChild(a)}function be(t){var a=new e.XMLHttpRequest;if(a.open(t.method,t.url,!0,t.user,t.password),a.onreadystatechange=function(){4===a.readyState&&(a.status>=200&&a.status<300?t.onload({type:"load",target:a}):t.onerror({type:"error",target:a}))},t.serialize===JSON.stringify&&t.data&&"GET"!==t.method&&a.setRequestHeader("Content-Type","application/json; charset=utf-8"),t.deserialize===JSON.parse&&a.setRequestHeader("Accept","application/json, text/*"),r(t.headers))for(var o in t.headers)Ce.call(t.headers,o)&&a.setRequestHeader(o,t.headers[o]);if(n(t.config)){var u=t.config(a,t);null!=u&&(a=u)}var l="GET"!==t.method&&t.data?t.data:"";if(l&&!i(l)&&l.constructor!==e.FormData)throw new Error("Request data should be either be a string or FormData. Check the `serialize` option in `m.request`");return a.send(l),a}function Pe(e){return e.dataType&&"jsonp"===e.dataType.toLowerCase()?we(e):be(e)}function ke(e,t,n){if("GET"===e.method&&"jsonp"!==e.dataType){var r=e.url.indexOf("?")<0?"?":"&",a=pe(t);e.url+=a?r+a:""}else e.data=n(t)}function Oe(e,t){return t&&(e=e.replace(/:[a-z]\w+/gi,function(e){var n=e.slice(1),r=t[n]||e;return delete t[n],r})),e}c.version=function(){return"v0.2.8"};var xe,Se,Ee,Me,Ce={}.hasOwnProperty,Ke={}.toString,Te=Array.isArray||function(e){return"[object Array]"===Ke.call(e)},Ae={AREA:1,BASE:1,BR:1,COL:1,COMMAND:1,EMBED:1,HR:1,IMG:1,INPUT:1,KEYGEN:1,LINK:1,META:1,PARAM:1,SOURCE:1,TRACK:1,WBR:1};c.deps=function(t){return u(e=t||window),e},c.deps.factory=c.factory=a,c.deps(e);var De=1,Be=2,je=3,Re=0;c.startComputation=function(){Re++},c.endComputation=function(){Re>1?Re--:(Re=0,c.redraw())};var Le,Ge=[],Fe=!1,Ne={list:1,style:1,form:1,type:1,width:1,height:1},_e={appendChild:function(e){Le===t&&(Le=xe.createElement("html")),xe.documentElement&&xe.documentElement!==e?xe.replaceChild(e,xe.documentElement):xe.appendChild(e),this.childNodes=xe.childNodes},insertBefore:function(e){this.appendChild(e)},childNodes:[]},Ie=[],He={};c.render=function(e,n,r){if(!e)throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");var a,i=[],o=ne(e),u=e===xe;a=u||e===xe.documentElement?_e:e,u&&"html"!==n.tag&&(n={tag:"html",attrs:{},children:n}),He[o]===t&&V(a.childNodes),r===!0&&me(e),He[o]=U(a,null,t,t,n,He[o],!1,0,null,t,i),f(i,function(e){e()})},c.trust=function(e){return e=new String(e),e.$trusted=!0,e},c.prop=function(e){return(null!=e&&(r(e)||n(e))||"undefined"!=typeof Promise&&e instanceof Promise)&&n(e.then)?ge(e):re(e)};var Ue,qe=[],Xe=[],ze=[],$e=null,Je=0,Ve=null,Ye=null,Qe=16;c.component=function(e){for(var t=new Array(arguments.length-1),n=1;n<arguments.length;n++)t[n-1]=arguments[n];return ae(e,t)};var We,Ze;c.mount=c.module=function(e,t){if(!e)throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");var r=qe.indexOf(e);r<0&&(r=qe.length);var a=!1,i={preventDefault:function(){a=!0,Ve=Ye=null}};return f(Ge,function(e){e.handler.call(e.controller,i),e.controller.onunload=null}),a?f(Ge,function(e){e.controller.onunload=e.handler}):Ge=[],ze[r]&&n(ze[r].onunload)&&ze[r].onunload(i),ie(t,e,r,a)};var et=!1;c.redraw=function(t){if(!et){et=!0,t&&(Fe=!0);try{$e&&!t?(Ee===e.requestAnimationFrame||new Date-Je>Qe)&&($e>0&&Me($e),$e=Ee(ue,Qe)):(ue(),$e=Ee(function(){$e=null},Qe))}finally{et=Fe=!1}}},c.redraw.strategy=c.prop(),c.withAttr=function(e,t,n){return function(r){r=r||window.event;var a=r.currentTarget||this,i=n||this,o=e in a?a[e]:a.getAttribute(e);t.call(i,o)}};var tt,nt={pathname:"",hash:"#",search:"?"},rt=o,at=!1;c.route=function(t,n,r,a){if(0===arguments.length)return We;if(3===arguments.length&&i(n)){rt=function(e){var a=We=de(e);if(!se(t,r,a)){if(at)throw new Error("Ensure the default route matches one of the routes defined in m.route");at=!0,c.route(n,!0),at=!1}};var o="hash"===c.route.mode?"onhashchange":"onpopstate";return e[o]=function(){var e=Se[c.route.mode];"pathname"===c.route.mode&&(e+=Se.search),We!==de(e)&&rt(e)},Ve=fe,void e[o]()}if(t.addEventListener||t.attachEvent){var u="pathname"!==c.route.mode?Se.pathname:"";return t.href=u+nt[c.route.mode]+a.attrs.href,void(t.addEventListener?(t.removeEventListener("click",ce),t.addEventListener("click",ce)):(t.detachEvent("onclick",ce),t.attachEvent("onclick",ce)))}if(i(t)){Ze=We,We=t;var l,d=n||{},s=We.indexOf("?");l=s>-1?ve(We.slice(s+1)):{};for(var f in d)Ce.call(d,f)&&(l[f]=d[f]);var p,v=pe(l);p=s>-1?We.slice(0,s):We,v&&(We=p+(p.indexOf("?")===-1?"?":"&")+v);var m=(3===arguments.length?r:n)===!0||Ze===We;if(e.history.pushState){var g=m?"replaceState":"pushState";Ve=fe,Ye=function(){try{e.history[g](null,xe.title,nt[c.route.mode]+We)}catch(t){Se[c.route.mode]=We}},rt(nt[c.route.mode]+We)}else Se[c.route.mode]=We,rt(nt[c.route.mode]+We);Ze=null}},c.route.param=function(e){if(!tt)throw new Error("You must call m.route(element, defaultRoute, routes) before calling m.route.param()");return e?tt[e]:tt},c.route.mode="search",c.route.buildQueryString=pe,c.route.parseQueryString=ve,c.deferred=function(){var e=new he;return e.promise=ge(e.promise),e};var it=1,ot=2,ut=3,lt=4;return c.deferred.onerror=function(e){if("[object Error]"===Ke.call(e)&&!/ Error/.test(e.constructor.toString()))throw Re=0,e},c.sync=function(e){function t(e,t){return function(o){return a[e]=o,t||(i="reject"),0===--r&&(n.promise(a),n[i](a)),o}}var n=c.deferred(),r=e.length,a=[],i="resolve";return e.length>0?f(e,function(e,n){e.then(t(n,!0),t(n,!1))}):n.resolve([]),n.promise},c.request=function(e){e.background!==!0&&c.startComputation();var t,n,r,a=new he,i=e.dataType&&"jsonp"===e.dataType.toLowerCase();return i?(t=e.serialize=n=e.deserialize=ye,r=function(e){return e.responseText}):(t=e.serialize=e.serialize||JSON.stringify,n=e.deserialize=e.deserialize||JSON.parse,r=e.extract||function(e){return e.responseText.length||n!==JSON.parse?e.responseText:null}),e.method=(e.method||"GET").toUpperCase(),e.url=Oe(e.url,e.data),ke(e,e.data,t),e.onload=e.onerror=function(t){try{t=t||event;var i=n(r(t.target,e));"load"===t.type?(e.unwrapSuccess&&(i=e.unwrapSuccess(i,t.target)),Te(i)&&e.type?f(i,function(t,n){i[n]=new e.type(t)}):e.type&&(i=new e.type(i)),a.resolve(i)):(e.unwrapError&&(i=e.unwrapError(i,t.target)),a.reject(i))}catch(o){a.reject(o),c.deferred.onerror(o)}finally{e.background!==!0&&c.endComputation()}},Pe(e),a.promise=ge(a.promise,e.initialValue),a.promise},c})},{}],3:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){var n=.7*e.width,r=.7*e.height,a=p["default"].miniKey2pos(t),i=[a[0]*(n/p["default"].miniColumns),a[1]*(r/p["default"].miniRows)];return i}function i(e,t,n){var r=p["default"].key2pos(n),a=[r[0]*(e.width/p["default"].columns),r[1]*e.height*.5],i=[e.left-t.left,e.top-t.top];return[i[0]+a[0],i[1]+a[1]]}function o(e,t){return[e[0]-t[0],e[1]-t[1]]}function u(e,t){return t[0]}function l(e,t,n){return{key:e,distance:n,color:t.color,number:t.number}}function d(e,t){var n,r,d,s,c=t.animation.current,f=p["default"].findPov(t.povSide,t.turnSide),m=p["default"].vectorByPov(f),g=(t.bounds(),t.topBounds()),h=t.boardBounds(),y=h.width,w=(h.height,g.width),b=g.height,P=.0625*w,k=.14*b,O=.0625*y,x={},S=[],E={},M={},C=p["default"].discardByPov(f),K=p["default"].drawByPov(f),T=p["default"].topKey2pos(K),A=p["default"].topKey2pos(C),D=[w*m[0],b*m[1]+("up"===f?-k:"left"===f?-k/2:0)],B=[12*P,b-k],j=[P*A[0],k*A[1]],R=[P*T[0],k*T[1]],L=[1*P,1*k],G=[],F=[],N=[],_=[];for(n=0;n<p["default"].allAllowedBoardKeys.length;n++){r=p["default"].allAllowedBoardKeys[n],d=t.pieces[r],s=e.pieces[r];var I=i(h,g,r);!d&&s?G.push(l(r,s,I)):d&&!s&&F.push(l(r,d,I))}for(n=0;n<p["default"].miniAllKeys.length;n++){r=p["default"].miniAllKeys[n],d=t.opens.layout?t.opens.layout.layout[r]:null,s=e.opens.layout?e.opens.layout.layout[r]:null;var H=a(g,r);d&&!s?_.push(l(r,d,H)):!d&&s&&N.push(l(r,s,H))}var U,q,X;return"down"!==f||t.spectator?c.hint===v["default"].drawMiddle?(U=[12*P,b],q=D,X=[q[0]-U[0],q[1]-U[1]],x[p["default"].middleCount]=[X,X,!0]):c.hint===v["default"].discard?(U=[P*A[0],k*A[1]],q=D,X=[q[0]-U[0],q[1]-U[1]],x[C]=[X,X]):c.hint===v["default"].drawLeft?(U=[P*T[0],k*T[1]],q=D,X=[q[0]-U[0],q[1]-U[1]],x[v["default"].drawLeft+K]=[X,X,!0],M.piece=e.discards[K]):c.hint===v["default"].leaveTaken?(U=[P*T[0],k*T[1]],q=D,X=[q[0]-U[0],q[1]-U[1]],x[K]=[X,X]):c.hint===v["default"].openSeries?_.forEach(function(e,t){q=D,q=o(q,L),q=o(q,e.distance),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[e.key]=[X,X],E[e.key]=[1.75,1.75]}):c.hint===v["default"].collectOpen&&N.forEach(function(e,t){q=D,q=o(q,L),q=o(q,e.distance),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[e.key]=[X,X,!0],M[e.key]=e}):c.hint===v["default"].drawMiddle&&F[0]?(r=F[0].key,U=F[0].distance,U=o(U,B),q=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[r]=[X,X]):c.hint===v["default"].discard&&G[0]?(q=G[0].distance,q=o(q,j),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[C]=[X,X]):c.hint===v["default"].leaveTaken?G[0]?(q=G[0].distance,q=o(q,R),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[K]=[X,X]):(U=[P*T[0],k*T[1]],q=D,X=[q[0]-U[0],q[1]-U[1]],x[K]=[X,X]):c.hint===v["default"].openSeries&&_.forEach(function(e,t){var n=u(e,G.filter(p["default"].partial(p["default"].pieceEqual,e)));G.splice(G.indexOf(n),1),n&&(q=n.distance,q=o(n.distance,[O,0]),q=o(q,L),q=o(q,e.distance),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[e.key]=[X,X],E[e.key]=[1.75,1.75])}),{anims:x,fadings:S,scales:E,extra:M}}function s(e,t){return Math.round(e*t)/t}function c(e){if(e.animation.current.start){var t=1-((new Date).getTime()-e.animation.current.start)/e.animation.current.duration;if(t<=0)e.animation.current={},e.render();else{var n,r=m.easeInOutCubic(t);for(var a in e.animation.current.anims)n=e.animation.current.anims[a],n[1]=[s(n[0][0]*r,10),s(n[0][1]*r,10)],n[2]&&(n[1]=[n[0][0]-n[1][0],n[0][1]-n[1][1]]);var i;for(i in e.animation.current.fadings)e.animations.current.fadings[i].opacity=s(r,100);for(i in e.animation.current.scales)n=e.animation.current.scales[i],n[0]=1+s(.7*r,10),n[1]=1+s(.7*r,10);e.render(),p["default"].requestAnimationFrame(function(){c(e)})}}}function f(e,t){var n,r={pieces:{},opens:{},middles:{},discards:{}};for(n in t.pieces)t.pieces[n]&&(r.pieces[n]={color:t.pieces[n].color,number:t.pieces[n].number});for(n in t.discards)t.discards[n]&&t.discards[n][0]&&(r.discards[n]={color:t.discards[n][0].color,number:t.discards[n][0].number});if(t.opens.layout){var a;r.opens.layout={layout:{}};for(n in t.opens.layout.layout)a=t.opens.layout.layout[n],r.opens.layout.layout[n]={color:a.color,number:a.number}}var i=e(),o=d(r,t);if(Object.keys(o.anims).length>0||o.fadings.length>0){var u=t.animation.current.start;t.animation.current={start:(new Date).getTime(),duration:t.animation.duration,anims:o.anims,fadings:o.fadings,scales:o.scales,extra:o.extra},u||c(t)}else t.renderRAF();return i}var p=r(e("./util")),v=r(e("./move")),m={easeInOutCubic:function(e){return e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1}};t.exports=function(e,t){return function(){var n=[t].concat(Array.prototype.slice.call(arguments,0));if(t.animation.enabled)return f(p["default"].partialApply(e,n),t);var r=e.apply(null,n);return t.renderRAF(),r}}},{"./move":12,"./util":17}],4:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=r(e("mithril")),i=r(e("./view")),o=r(e("./board"));t.exports=function(e){return{set:e.set,getPieceGroups:function(){return o["default"].getPieceGroups(e.data)},attach:function(t){a["default"].render(t,(0,i["default"])(e),!0)},detach:function(){},sortPairs:e.sortPairs,sortSeries:e.sortSeries,apiMove:e.apiMove,apiDrawMiddleEnd:e.apiDrawMiddleEnd,playOpenSeries:e.playOpenSeries,playOpenPairs:e.playOpenPairs,playLeaveTaken:e.playLeaveTaken,canOpenSeries:e.canOpenSeries,canOpenPairs:e.canOpenPairs,canCollectOpen:e.canCollectOpen,canLeaveTaken:e.canLeaveTaken,stop:e.stop,getPieceGroupSeries:e.getPieceGroupSeries,getPieceGroupPairs:e.getPieceGroupPairs,getFen:e.getFen}}},{"./board":5,"./view":18,mithril:2}],5:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){return l(e)||u(e,t)||o()}function o(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function u(e,t){var n=[],r=!0,a=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(r=(o=u.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(l){a=!0,i=l}finally{try{r||null==u["return"]||u["return"]()}finally{if(a)throw i}}return n}function l(e){if(Array.isArray(e))return e}function d(e){if(F(e)){var t=e.middles[ne["default"].gosterge],n=ee(e);if(n=n.filter(function(n){return ie["default"].series(n.map(function(t){return e.pieces[t]}),t)}),n.length>0){var r=Y(n.map(function(t){return t.map(function(t){return e.pieces[t]})}));return m(e,n),ue(ne["default"].partial(e.movable.events.after,re["default"].openSeries,oe(r))),e.animation.current.hint=re["default"].openSeries,!0}}return!1}function s(e){if(N(e)){var t=e.middles[ne["default"].gosterge],n=ee(e);if(n=n.filter(function(n){return ie["default"].pairs(n.map(function(t){return e.pieces[t]}),t)}),n.length>0){var r=Y(n.map(function(t){return t.map(function(t){return e.pieces[t]})}));return v(e,n),ue(ne["default"].partial(e.movable.events.after,re["default"].openPairs,oe(r))),e.animation.current.hint=re["default"].openSeries,!0}}return!1}function c(e,t){return t=ae["default"].readPiece(t).piece,!(!_(e)||!O(e,t))&&(ue(ne["default"].partial(e.movable.events.after,re["default"].leaveTaken)),e.animation.current.hint=re["default"].leaveTaken,!0)}function f(e,t){var n=ne["default"].middleCount;w(e,n),p(e,t)}function p(e,t){"string"==typeof t&&(t=ae["default"].readPiece(t).piece),e.middleHolder.piece=t,g(e)}function v(e,t){var n=t.map(function(t){return t.map(function(t){return e.pieces[t]})}),r=Y(n);ue(ne["default"].partial(e.events.move,re["default"].openPairs,oe(r))),t.forEach(function(t){return t.map(function(t){return delete e.pieces[t]})});var a=e.opens.pairs.concat(n);e.opens.pairs=a,e.opens.relayout(e)}function m(e,t){var n=t.map(function(t){return t.map(function(t){return e.pieces[t]})}),r=Y(n);ue(ne["default"].partial(e.events.move,re["default"].openSeries,oe(r))),t.forEach(function(t){return t.map(function(t){return delete e.pieces[t]})});var a=e.opens.series.concat(n);e.opens.series=a,e.opens.relayout(e)}function g(e){var t=e.middleHolder.key,n=e.middleHolder.piece;t&&n&&(e.pieces[t]=n,e.lastMove=[ne["default"].middleCount],e.middleHolder.current=!1,e.middleHolder.key=null,e.middleHolder.piece=null)}function h(e,t,n){var r=X(e,t);if(r.length>0){var a=r[0].map(function(t,a){var i=r[0].length-a-1,o=ne["default"].decBoardKey(n,2*i);return[t,o,e.pieces[t]]}),o=a.every(function(t){var n=i(t,3),r=(n[0],n[1]);n[2];return ne["default"].isAllAllowedBoardKey(r)&&[r,ne["default"].decBoardKey(r,-1)].every(function(t){return!e.pieces[t]||a.filter(function(e){var n=i(e,3),r=n[0];n[1],n[2];return r===t}).length>0})});return!!o&&(a.map(function(t){var n=i(t,3),r=n[0],a=n[1],o=n[2];return delete e.pieces[r],[r,a,o]}).map(function(t){var n=i(t,3),r=(n[0],n[1]),a=n[2];e.pieces[r]=a}),!0)}return!1}function y(e,t,n){if(t===n||!e.pieces[t])return!1;var r=e.pieces[n];return e.pieces[n]=e.pieces[t],e.pieces[t]=r,!0}function w(e,t){e.middles[ne["default"].middleCount]--,e.middleHolder.current=!0;var n=z(e);return e.middleHolder.key=n,!0}function b(e,t,n){if(!n||e.pieces[n]){var r=z(e);n=r}return ue(ne["default"].partial(e.events.move,re["default"].drawMiddleEnd)),e.middleHolder.key=n,g(e),!0}function P(e,t){return ue(ne["default"].partial(e.events.move,re["default"].drawMiddle)),e.middles[ne["default"].middleCount]--,e.middleHolder.current=!0,!0}function k(e,t,n){return!e.pieces[n]&&(ue(ne["default"].partial(e.events.move,re["default"].drawLeft)),e.pieces[n]=e.discards[ne["default"].discards[1]][0],e.discards[ne["default"].discards[1]].shift(),
!0)}function O(e,t){var n=$(e,t);if(!n)return!1;ue(ne["default"].partial(e.events.move,re["default"].leaveTaken));var r=ne["default"].findPov(e.povSide,e.turnSide);return delete e.pieces[n],e.discards[ne["default"].drawByPov(r)].unshift(t),!0}function x(e,t,n){if(n&&ne["default"].isBoardKey(t)&&ne["default"].isBoardKey(n)&&B(e,t,n)){if(h(e,t,n))return!0;if(y(e,t,n))return!0}}function S(e,t){if(ne["default"].isMiddleKey(t)&&R(e,t))return P(e,t),!0}function E(e,t,n){if(ne["default"].isMiddleKey(t)&&L(e,t))return b(e,t,n),!0}function M(e,t,n){if(n&&ne["default"].isBoardKey(n)&&ne["default"].isDrawLeftKey(t)&&G(e,t,n)&&k(e,t,n))return ue(ne["default"].partial(e.movable.events.after,re["default"].drawLeft)),!0}function C(e,t,n){n||(ne["default"].isMiddleKey(t)?S(e,t)&&T(e,t):ne["default"].isDrawLeftKey(t)&&G(e)&&T(e,t))}function K(e,t){e.selected?(t?e.selected!==t&&(x(e,e.selected,t)||M(e,e.selected,t)||E(e,e.selected,t)):E(e,e.selected,t),T(e,null)):D(e,t)&&T(e,t)}function T(e,t){if(e.selected=t,t&&ne["default"].isBoardKey(t))if(q(e,t)){var n=e.middles[ne["default"].gosterge];e.openable.dests=ie["default"].compute(e.opens,e.pieces[t],n)}else e.openable.dests=[];else e.openable.dests=[]}function A(e){return e.povSide===e.turnSide}function D(e,t){var n=e.pieces[t];return n&&e.movable.board}function B(e,t,n){return t!=n&&D(e,t)}function j(e){return A(e)}function R(e,t){return j(e)&&!e.middleHolder.current&&ne["default"].containsX(e.movable.dests,re["default"].drawMiddle)}function L(e){return e.middleHolder.current}function G(e,t,n){return j(e)&&!L(e)&&ne["default"].containsX(e.movable.dests,re["default"].drawLeft)}function F(e){return A(e)&&ne["default"].containsX(e.movable.dests,re["default"].openSeries)}function N(e){return A(e)&&ne["default"].containsX(e.movable.dests,re["default"].openPairs)}function _(e){return A(e)&&ne["default"].containsX(e.movable.dests,re["default"].leaveTaken)}function I(e){return A(e)&&ne["default"].containsX(e.movable.dests,re["default"].collectOpen)}function H(e){K(e,null)}function U(e){e.movable.side=null,e.movable.dests=[],e.openable.dests=[],e.movable.board=!1,H(e)}function q(e,t){var n=e.pieces[t];return!(!n||e.povSide!==e.turnSide)}function X(e,t){var n=e.middles[ne["default"].gosterge],r=ee(e);return r=r.filter(function(e){return e[e.length-1]===t}),r=r.filter(function(t){return ie["default"].series(t.map(function(t){return e.pieces[t]}),n)||ie["default"].pairs(t.map(function(t){return e.pieces[t]}),n)})}function z(e){var t=ne["default"].allAllowedBoardKeys.slice(1),n=ne["default"].allAllowedBoardKeys.slice(2),r=ne["default"].allAllowedBoardKeys.map(function(e,r){return[e,t[r],n[r]]}).filter(function(t){var n=i(t,3),r=n[0],a=n[1],o=n[2];return r&&a&&o&&!e.pieces[r]&&!e.pieces[a]&&!e.pieces[o]});return r[r.length-1][1]}function $(e,t){return ne["default"].allAllowedBoardKeys.filter(function(n){return e.pieces[n]&&ne["default"].pieceEqual(e.pieces[n],t)})[0]}function J(e,t,n,r){var a=V(e,t,n);if(!a)return a;var i=ne["default"].decBoardKey(a);return i!==r&&e.pieces[i]&&(a=i),ne["default"].notAllowedBoardKeys.indexOf(a)!==-1?null:a}function V(e,t,n){if(n||e.bounds){n=n||e.bounds();var r=Math.floor(ne["default"].columns*((t[0]-n.left)/n.width)),a=Math.floor(ne["default"].rows*((t[1]-n.top)/n.height));return a>=0&&a<ne["default"].rows&&r>=0&&r<ne["default"].columns?ne["default"].pos2key([r,a]):void 0}}function Y(e){return e.map(function(e){return e.map(function(e){return e.key}).join("")}).join(" ")}function Q(e){var t=e.middles[ne["default"].gosterge],n=e.withTore,r=Z(e).filter(function(e){return ie["default"].series(e,t,n)});return Y(r)}function W(e){var t=e.middles[ne["default"].gosterge],n=Z(e).filter(function(e){return ie["default"].pairs(e,t)});return Y(n)}function Z(e){return ee(e).map(function(t){return t.map(function(t){return e.pieces[t]})})}function ee(e){var t=ne["default"].pos2key([ne["default"].columns-1,0]),n=ne["default"].allKeys.slice(1),r=ne["default"].allKeys.map(function(e,t){return[e,n[t]]}).reduce(function(n,r){var a=i(n,2),o=a[0],u=a[1],l=i(r,2),d=l[0],s=l[1];return e.pieces[d]&&o.push(d),(d&&!e.pieces[d]&&s&&!e.pieces[s]||d===t)&&0!==o.length&&(u.push(o),o=[]),[o,u]},[[],[]]),a=i(r,2),o=a[0],u=a[1];return 0!==o.length&&u.push(o),u}var te,ne=r(e("./util")),re=r(e("./move")),ae=r(e("./pieces")),ie=r(e("./open")),oe=ne["default"].wrapGroup,ue=ne["default"].callUserFunction;t.exports=(te={playOpenSeries:d,playOpenPairs:s,playLeaveTaken:c,apiDrawMiddleEnd:p},a(te,"apiDrawMiddleEnd",p),a(te,"apiForceDrawMiddleEnd",f),a(te,"apiForceDrawMiddleEnd",f),a(te,"userMove",x),a(te,"userDrawLeft",M),a(te,"userBeginDrawMiddle",S),a(te,"userEndDrawMiddle",E),a(te,"selectSquare",K),a(te,"selectTop",C),a(te,"setSelected",T),a(te,"canOpenSeries",F),a(te,"canOpenPairs",N),a(te,"canLeaveTaken",_),a(te,"canCollectOpen",I),a(te,"stop",U),a(te,"cancelMove",H),a(te,"isDroppableOpens",q),a(te,"findBoardDragGroup",X),a(te,"getKeyAtDomPos",V),a(te,"getKeyAtDomPosOnPiece",J),a(te,"getPieceGroups",Z),a(te,"getPieceGroupSeries",Q),a(te,"getPieceGroupPairs",W),te)},{"./move":12,"./open":13,"./pieces":14,"./util":17}],6:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=r(e("merge")),i=r(e("./pieces"));t.exports=function(e,t){if(t)if(a["default"].recursive(e,t),e.fen){e.spectator&&(e.fen=e.povSide[0]+e.fen.slice(1)),e.animationHint?(e.animation.current.hint=e.animationHint,delete e.animationHint):e.animation.current.hint="";var n=i["default"].read(e.fen);e.pieces=n.pieces,e.discards=n.discards,e.opens=n.opens,e.middles=n.middles,delete e.fen}else e.animation.current.hint=""}},{"./pieces":14,merge:1}],7:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=r(e("./table")),i=r(e("./board")),o=r(e("./sorter")),u=r(e("./data")),l=r(e("./configure")),d=r(e("./util")),s=r(e("./anim")),c=r(e("./drag")),f=r(e("./pieces"));t.exports=function(e){var t=this;this.data=(0,u["default"])(e),this.data.flipPiece=function(e,t){var n=this;t&&!this.flippable.current.orig&&(this.flippable.current={orig:e},this.renderRAF(),setTimeout(function(){n.flippable.current.flip=!0,n.renderRAF(),setTimeout(function(){t.flip=!t.flip,n.flippable.current={},n.renderRAF()},600)},10))}.bind(this.data),this.getFen=function(){return f["default"].write(t.data.pieces)},this.getPieceGroupSeries=function(){return i["default"].getPieceGroupSeries(t.data)},this.getPieceGroupPairs=function(){return i["default"].getPieceGroupPairs(t.data)},this.set=(0,s["default"])(l["default"],this.data),this.apiMove=(0,s["default"])(a["default"].apiMove,this.data),this.apiDrawMiddleEnd=(0,s["default"])(i["default"].apiDrawMiddleEnd,this.data),this.playOpenSeries=(0,s["default"])(i["default"].playOpenSeries,this.data),this.playOpenPairs=(0,s["default"])(i["default"].playOpenPairs,this.data),this.playLeaveTaken=(0,s["default"])(i["default"].playLeaveTaken,this.data),this.sortPairs=(0,s["default"])(o["default"].sortPairs,this.data),this.sortSeries=(0,s["default"])(o["default"].sortSeries,this.data),this.canLeaveTaken=d["default"].partial(i["default"].canLeaveTaken,this.data),this.canCollectOpen=d["default"].partial(i["default"].canCollectOpen,this.data),this.canOpenSeries=d["default"].partial(i["default"].canOpenSeries,this.data),this.canOpenPairs=d["default"].partial(i["default"].canOpenPairs,this.data),this.stop=(0,s["default"])(function(e){i["default"].stop(e),c["default"].cancel(e)},this.data),this.onunload=function(){}}},{"./anim":3,"./board":5,"./configure":6,"./data":8,"./drag":9,"./pieces":14,"./sorter":15,"./table":16,"./util":17}],8:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=(r(e("merge")),r(e("./pieces"))),i=r(e("./configure"));t.exports=function(e){var t={povSide:"east",turnSide:"east",lastMove:null,withTore:!1,pieces:a["default"].readBoard(a["default"].mixed),discards:a["default"].readDiscards(a["default"].initialDiscards,"east"),opens:a["default"].readOpenGroups(a["default"].initialOpenGroups),middles:a["default"].readMiddles(a["default"].initialMiddles),selected:null,middleHolder:{current:!1,key:null,piece:null},viewOnly:!1,animation:{enabled:!0,duration:500,current:{}},draggable:{enabled:!0,distance:3,current:{}},movable:{board:!0,free:!0,events:{after:function(e,t){}}},flippable:{enabled:!0,current:{}},openable:{dests:[]},events:{move:function(e,t){}}};return(0,i["default"])(t,e||{}),t}},{"./configure":6,"./pieces":14,merge:1}],9:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p["default"].rows,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:p["default"].columns;return{left:t.left+t.width*n[0]/a,top:t.top+t.height*n[1]/r,width:t.width/a,height:t.height/r}}function i(e,t){if((void 0===t.button||0===t.button)&&(t.stopPropagation(),t.preventDefault(),!e.viewOnly)){s=t.target;var n=e.selected,r=p["default"].eventPosition(t),i=e.boardBounds(),u=e.opensBounds(),l=e.topBounds(),d=c["default"].getKeyAtDomPosOnPiece(e,r,i);c["default"].selectSquare(e,d),d||(d=f["default"].getDrawKeyAtDomPos(e,r,l))&&c["default"].selectTop(e,d,n),!d&&n&&((d=f["default"].getOpensKeyAtDomPos(e,r,u))?f["default"].dropOpens(e,n,d):(d=f["default"].getDiscardKeyAtDomPos(e,r,l))&&f["default"].dropTop(e,n,d));var v=e.selected===d;if(v&&f["default"].isDraggable(e,d)){var m=p["default"].isBoardKey(d)?a(e,i,p["default"].key2pos(d)):a(e,l,p["default"].topKey2pos(d),p["default"].topRows,p["default"].topColumns),g=c["default"].findBoardDragGroup(e,d)[0];e.draggable.current={dragGroup:g,orig:d,rel:r,epos:r,pos:[0,0],dec:[r[0]-(m.left+m.width/2),r[1]-(m.top+m.height/2)],boardBounds:i,opensBounds:u,topBounds:l,started:!1}}o(e)}}function o(e){p["default"].requestAnimationFrame(function(){var t=e.draggable.current;t.orig&&(!t.started&&p["default"].distance(t.epos,t.rel)>=e.draggable.distance&&(t.started=!0),t.started&&(t.pos=[t.epos[0]-t.rel[0],t.epos[1]-t.rel[1]],t.over=c["default"].getKeyAtDomPosOnPiece(e,t.epos,t.boardBounds,t.orig),!t.over&&p["default"].isBoardKey(t.orig)&&(t.over=f["default"].getOpensKeyAtDomPos(e,t.epos,t.opensBounds)||f["default"].getDiscardKeyAtDomPos(e,t.epos,t.topBounds)))),e.render(),t.orig&&o(e)})}function u(e,t){e.draggable.current.orig&&(e.draggable.current.epos=p["default"].eventPosition(t))}function l(e,t){var n=e.draggable,r=n.current?n.current.orig:null;if(r){var a=n.current.over;n.current.started&&(c["default"].setSelected(e,null),c["default"].userMove(e,r,a)||f["default"].dropOpens(e,r,a)||f["default"].dropTop(e,r,a)||c["default"].userDrawLeft(e,r,a)||c["default"].userEndDrawMiddle(e,r,a)),n.current={}}}function d(e){e.draggable.current.orig&&(e.draggable.current={},c["default"].selectSquare(e,null))}var s,c=r(e("./board")),f=r(e("./table")),p=r(e("./util"));t.exports={start:i,move:u,end:l,cancel:d}},{"./board":5,"./table":16,"./util":17}],10:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){t.stopPropagation(),t.preventDefault(),u["default"].cancelMove(e);var n=l["default"].eventPosition(t),r=e.boardBounds(),a=u["default"].getKeyAtDomPosOnPiece(e,n,r),i=e.pieces[a];e.flipPiece(a,i)}function i(e,t){}function o(e,t){}var u=r(e("./board")),l=r(e("./util"));t.exports={start:a,move:i,end:o}},{"./board":5,"./util":17}],11:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){var t=new i["default"](e);return(0,l["default"])(t)}var i=r(e("./ctrl")),o=r(e("./util")),u=r(e("./move")),l=r(e("./api")),d=r(e("./anim")),s=r(e("./drag"));t.exports=a,t.exports.controller=i["default"],t.exports.util=o["default"],t.exports.move=u["default"],t.exports.anim=d["default"],t.exports.drag=s["default"]},{"./anim":3,"./api":4,"./ctrl":7,"./drag":9,"./move":12,"./util":17}],12:[function(e,t,n){"use strict";var r="dm",a="dl",i="dd",o="lt",u="ss",l="os",d="op",s="co",c="dos",f="dop",p="dds",v="ddp",m="l",g="r",h="p";t.exports={drawMiddle:r,drawLeft:a,discard:i,leaveTaken:o,sign:u,openSeries:l,openPairs:d,collectOpen:s,dropOpenSeries:c,dropOpenPairs:f,dropLeft:m,dropRight:g,dropReplace:h,discardEndSeries:p,discardEndPairs:v}},{}],13:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){return u(e)||o(e,t)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e,t){var n=[],r=!0,a=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(r=(o=u.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(l){a=!0,i=l}finally{try{r||null==u["return"]||u["return"]()}finally{if(a)throw i}}return n}function u(e){if(Array.isArray(e))return e}function l(e,t){return e.length===t.length&&e.every(function(e,n){return e===t[n]})}function d(e,t){return t.every(function(t,n){return t.color===e[n]})}function s(e,t){if(e.length<3)return!1;var n=e.length,r=e[0].color,a=e.map(function(e){return e.key}),i=a.slice(0).reverse(),o=w["default"].seriesByColor(r);t&&(o=o.slice(0),o.push(o[0]));for(var u=0;u<=o.length-n;u++){var d=o.slice(u,u+n);if(l(d,a)|l(d,i))return!0}return!1}function c(e){var t=e.length,n=e[0].number;return!!(3===t|4===t)&&(!!e.every(function(e){return e.number===n})&&b.some(function(t){return d(t.slice(0,e.length),e)}))}function f(e,t){var n=w["default"].makePiece(t.c,t.n);return n.isFake=!0,w["default"].pieceFake(e)?n:e}function p(e,t){return!e.isFake&&e.key===t.key}function v(e,t){function n(e,t){return e.filter(function(e){return t.indexOf(e)<0})}function r(e,t){return e.key===t.key}function i(e,t){var r=["r","g","b","l"],a=e.filter(function(e){return!p(e,t)}),i=n(r,a.map(function(e){return e.c}));if(i.length<1)return e;if(a.length<1)return e;if(!(a.length<e.length))return e;var o=i[0],u=a[0].n,l=w["default"].makePiece(o,u);return a.push(l),a}function o(e,t){var n;if(0===e.length)return e;if(e.length<3)return e;var i=a(e,3),u=i[0],l=i[1],d=i[2],s=[u,l,d];if(n=e.slice(3,e.length),p(u,t))r(w["default"].pieceUp(l),d)?s=[w["default"].pieceDown(l),l,d]:r(w["default"].pieceDown(l),d)&&(s=[w["default"].pieceUp(l),l,d]);else if(p(l,t))r(w["default"].pieceUp(w["default"].pieceUp(u)),d)?s=[u,w["default"].pieceUp(u),d]:r(w["default"].pieceDown(w["default"].pieceDown(u)),d)&&(s=[u,w["default"].pieceDown(u),d]);else{if(!p(d,t))return n=o(e.slice(1,e.length),t),n.unshift(e[0]),n;r(w["default"].pieceUp(u),l)?s=[u,l,w["default"].pieceUp(l)]:r(w["default"].pieceDown(u),l)&&(s=[u,l,w["default"].pieceDown(l)])}return s.concat(n)}function u(e,t){if(2!=e.length)return e;var n=a(e,2),r=n[0],i=n[1];return p(r,t)?[i,i]:p(i,t)?[r,r]:e}if(e.filter(function(e){return p(e,t)}).length>1)return e;if(e.length<3)return u(e,t);var l=e.filter(function(e){return!p(e,t)});return l.every(function(e){return e.n===l[0].n})?i(e,t):l.every(function(e){return e.c===l[0].c})?o(e,t):e}function m(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=w["default"].pieceUp(t),a=e.map(function(e){return f(e,r)}),i=v(a,r);return s(i,n)|c(i)}function g(e,t){if(2!==e.length)return!1;var n=w["default"].pieceUp(t),r=e.map(function(e){return f(e,n)}),i=v(r,n),o=a(i,2),u=o[0],l=o[1];return u.key===l.key}function h(e,t,n){var r=[],a=w["default"].pieceUp(n);return t=f(t,a),e.series.forEach(function(i,o){var u=i.slice(0),l=i.slice(0);u.splice(0,0,t),l.splice(i.length,0,t),m(u,n)&&r.push(w["default"].getOpenSerieKeyFromGroupIndex(e,o,0)),m(l,n)&&r.push(w["default"].getOpenSerieKeyFromGroupIndex(e,o,i.length+1));var d=i.map(function(e){return p(e,a)?t:e});if(m(d,n)){var s;i.forEach(function(e,t){p(e,a)&&(s=t)}),r.push(w["default"].getOpenSerieKeyFromGroupIndex(e,o,s+1))}}),e.pairs.forEach(function(i,o){var u=i.map(function(e){return p(e,a)?t:e});if(g(u,n)){var l=y(i,a);r.push(w["default"].getOpenPairKeyFromGroupIndex(e,o,l))}}),r}function y(e,t){var n;return e.forEach(function(e,r){p(e,t)&&(n=r)}),n}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=void 0;var w=r(e("./pieces")),b=function(){var e=w["default"].colors,t=[];for(var n in e)for(var r in e)for(var a in e)for(var i in e)n!==r&&n!==a&&n!==i&&r!==a&&r!==i&&a!==i&&t.push([e[n],e[r],e[a],e[i]]);return t}(),P={compute:h,series:m,pairs:g,findOkeyIndex:y};n["default"]=P},{"./pieces":14}],14:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){return u(e)||o(e,t)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e,t){var n=[],r=!0,a=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(r=(o=u.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(l){a=!0,i=l}finally{try{r||null==u["return"]||u["return"]()}finally{if(a)throw i}}return n}function u(e){if(Array.isArray(e))return e}function l(e){var t=[];for(var n in B)t.push(E(e,n).key);return t}function d(e){var t={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9},n=t[e[0]],r=t[e[1]];return void 0===r?void 0===n?{left:e.slice(1)}:{number:n,left:e.slice(1)}:{number:10*n+r,left:e.slice(2)}}function s(e){var t=/([l|r|p])(\d\d?)/,n=e.match(t),r=n[1],a=parseInt(n[2]);return{type:r,groupIndex:a}}function c(e){var t=e[0],n=e[1],r=e[2],a=2;return D[t]?(B[n+r]&&(n+=r,a=3),{piece:E(t,n),left:e.slice(a)}):{left:e.slice(1)}}function f(e){var t=[],n=[];for(e+="\n";e.length>0;){var r=c(e);r.piece?n.push(r.piece):(n.length>0&&t.push(n),n=[]),e=r.left}return t}function p(e){for(var t=[],n=0;e.length>0;){var r=c(e);r.piece&&(t[n]=r.piece),n++,e=r.left}return t}function v(e){var t={};e=p(e);for(var n=0,r=0;r<e.length;r++){if(e[r]){for(;n<100&&!A["default"].isAllowedBoardKey(A["default"].encodeKey(n,"b"));)n++;t[A["default"].encodeKey(n,"b")]=e[r],n++}n++}return t}function m(e,t){e=e.split(" ");var n={};return A["default"].allSides.map(function(e){return A["default"].findPov(t,e)}).forEach(function(t,r){var a=p(e[r]||"");n[A["default"].discardByPov(t)]=a}),n}function g(e){var t=e.split("/"),n=a(t,2),r=n[0],i=n[1];r=f(r),i=f(i);var o=h(r,i);return{series:r,pairs:i,layout:o,relayout:function(e){e.opens.layout=h(e.opens.series,e.opens.pairs)}}}function h(e,t){var n,r,a,i,o,u={},l={series:{},pairs:{}},d=[],s=0;for(n=0;n<e.length;n++){var c=e[n];i=(d[s]||1)-1,o=s,l.series[A["default"].miniPos2key([i,o])]=n;for(var f=0;f<c.length;f++)a=d[s]||1,r=A["default"].miniPos2key([a,s]),u[r]=c[f],d[s]=a+1;d[s]+=2,s++,s>=A["default"].miniRows&&(s=0)}for(d=[],n=0,f=0,r=0,a=0,s=0,n=0;n<t.length;n++){var p=t[n];for(i=(d[s]||A["default"].miniColumns-1)-1,o=s,l.pairs[A["default"].miniPos2key([i,o])]=n,f=p.length-1;f>=0;f--)a=d[s]||A["default"].miniColumns-1,r=A["default"].miniPos2key([a,s]),u[r]=p[f],d[s]=a-1;d[s]-=1,s++,s>=A["default"].miniRows&&(s=0)}return{layout:u,groupMap:l}}function y(e,t,n){for(var r in e)if(e[r]===t){var i=A["default"].miniKey2pos(r),o=a(i,2),u=o[0],l=o[1],d=[u+n,l];return A["default"].miniPos2key(d)}}function w(e,t,n){var r=e.layout.groupMap.pairs;return y(r,t,n)}function b(e,t,n){var r=e.layout.groupMap.series;return y(r,t,n)}function P(e,t){var n=e.opens,r=n.series,i=n.layout.groupMap,o=a(t,2),u=o[0],l=o[1];for(var d in i.series){var s=i.series[d],c=r[s],f=A["default"].miniKey2pos(d),p=a(f,2),v=p[0],m=p[1],g=u-v;if(!(g<0||g>c.length+1||l!=m))return[s,g]}}function k(e,t){var n=e.opens,r=n.pairs,i=n.layout.groupMap,o=a(t,2),u=o[0],l=o[1];for(var d in i.pairs){var s=i.pairs[d],c=(r[s],A["default"].miniKey2pos(d)),f=a(c,2),p=f[0],v=f[1],m=u-p;if(!(m<0||m>1||l!=v))return[s,m]}}function O(e){var t={},n=d(e);return t[A["default"].middleCount]=n.number,n=c(n.left),t[A["default"].gosterge]=n.piece,t}function x(e){e=e.split("/");var t=2,n=3,r=4,a=1,i=0,o={e:"east",w:"west",n:"north",s:"south"}[e[i]];return{pieces:v(e[t]),discards:m(e[n],o),opens:g([e[r],e[r+1]].join("/")),middles:O(e[a])}}function S(e){var t=A["default"].allKeys.map(function(t){return e[t]}).map(function(e){return e&&e.key||" "}).join("");return t.replace(/([^\s])\s/g,"$1")}function E(e,t){return{color:D[e],number:B[t],c:e,n:parseInt(t),key:e+t}}function M(e){var t=e.c,n=e.n%13+1;return E(t,n)}function C(e){var t=e.c,n=(e.n+11)%13+1;return E(t,n)}function K(e){return"fake"===e.color}function T(e){return e.length>0&&14===e.match(j).length}var A=r(e("./util")),D={b:"blue",r:"red",g:"green",l:"black",f:"fake"},B={1:"one",2:"two",3:"three",4:"four",5:"five",6:"six",7:"seven",8:"eight",9:"nine",10:"ten",11:"eleven",12:"twelve",13:"thirteen"},j=/[f|r|l|b|g]\d\d?/g,R=function(){var e={};for(var t in D)e[D[t]]=l(t);return e}(),L=function(e){return R[e]},G="g7r7b7l7 g8r8b8l8 g13r13b13l13 l12 r6r5r4r12r13 g9g8g13 g6 l8l7l12",F="r1g1l1b1 r2g2l2b2 r3g3l3b3 r4g4l4b4 r13g13l13b13 r1g1l1b1",N="r1r2 r3r4r5r6r7r8r9r10r11r12r13l1l2l3l4l5l6l7   g1g2  l3",_="20l3",I="b1  r1r2 g1",H="r8l8b8\nb1b2b3\nb9b10b11b12\nl13r13b13\nr12b12g12\nr7r8r9r10\ng10g11g12\nl6b6r6\nl9l10l11\nb7l7r7g7\nr13l13b13g13\nl10r10b10g10\nl6r6g6\nl1b1g1\n/r1r1\ng1g1\ng2g2\ng3g3\ng4g4\ng5g5\ng6g6\ng7g7\ng8g8\ng9g9\ng10g10\ng11g11\ng12g12\n\n";t.exports={validDuzOkeyGroupFen:T,initial:N,rainbow:F,mixed:G,write:S,read:x,readDropPos:s,readPiece:c,readBoard:v,initialMiddles:_,initialDiscards:I,initialOpenGroups:H,readMiddles:O,readDiscards:m,readPieceGroup:f,readOpenGroups:g,layoutOpens:h,seriesByColor:L,makePiece:E,pieceUp:M,pieceDown:C,pieceFake:K,colors:D,getOpenSerieKeyFromGroupIndex:b,getOpenPairKeyFromGroupIndex:w,getOpenSerieFromPos:P,getOpenPairFromPos:k}},{"./util":17}],15:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){return u(e)||o(e)||i()}function i(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function o(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function u(e){if(Array.isArray(e)){for(var t=0,n=new Array(e.length);t<e.length;t++)n[t]=e[t];return n}}function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function d(e){function t(e,n,r){for(var i in r){var o=r[i];if(i!==n&&o.c===e.c){if(1===o.n&&2===e.n)return[l({},i,o)];if(13===o.n&&1===e.n||o.n===e.n-1)return[l({},i,o)].concat(a(t(o,i,r)))}}return[]}function n(e,t,r){for(var i in r){var o=r[i];if(i!==t&&o.c===e.c){if(1===o.n&&13===e.n)return[l({},i,o)];if(o.n===e.n+1)return[l({},i,o)].concat(a(n(o,i,r)))}}return[]}function r(e,t,n){var r={};for(var a in n){var i=n[a];a!==t&&i.n===e.n&&i.c!==e.c&&(r[i.c]=l({},a,i))}return Object.values(r)}function i(e){var a={};for(var i in e){var o=e[i];o&&(a[i]={downs:t(o,i,e),ups:n(o,i,e),same:r(o,i,e)})}var u={type:null,key:null,value:0};for(var d in a){var s=a[d];["downs","ups","same"].map(function(e){s[e].length>=u.value&&(u.type=e,u.key=d,u.value=s[e].length)})}var c=a[u.key][u.type];return"downs"===u.type?c.unshift(l({},u.key,e[u.key])):c.unshift(l({},u.key,e[u.key])),c}for(var o in e.pieces)e.pieces[o]||delete e.pieces[o];var u=Object.assign({},e.pieces);for(o in e.pieces)e.pieces[o]=void 0,delete e.pieces[o];for(var d=1;Object.keys(u).length>0;){var s=i(u),c=s.length;d=f["default"].nextIteratorForGroup(d,c),s.forEach(function(t,n){for(var r in t){var a=t[r];e.pieces[f["default"].iterator2Key(d+2*n)]=a,u[r]=void 0,delete u[r]}}),d+=2*c+1}console.log(e.pieces)}function s(e){var t={};for(var n in e.pieces){var r=e.pieces[n];r&&(t[r.key]?t[r.key]++:t[r.key]=1,delete e.pieces[n])}var a=1;for(var i in t){var o=t[i];a=f["default"].nextIteratorForGroup(a,o);for(var u=0;u<o;u++)e.pieces[f["default"].iterator2Key(a+2*u)]=c["default"].readPiece(i).piece;a+=2*o+1}}var c=r(e("./pieces")),f=r(e("./util"));t.exports={sortPairs:s,sortSeries:d}},{"./pieces":14,"./util":17}],16:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){return u(e)||o(e,t)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e,t){var n=[],r=!0,a=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(r=(o=u.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(l){a=!0,i=l}finally{try{r||null==u["return"]||u["return"]()}finally{if(a)throw i}}return n}function u(e){if(Array.isArray(e))return e}function l(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.piece,a=n.group,i=n.pos,o=R["default"].findPov(e.povSide,e.turnSide);if(e.turnSide!==e.povSide||e.spectator)switch(t){case L["default"].drawMiddle:v(e),e.animation.current.hint=L["default"].drawMiddle;break;case L["default"].drawLeft:m(e,R["default"].drawByPov(o)),e.animation.current.hint=L["default"].drawLeft;break;case L["default"].discard:r=G["default"].readPiece(r).piece,p(e,R["default"].discardByPov(o),r),e.animation.current.hint=L["default"].discard;break;case L["default"].leaveTaken:r=G["default"].readPiece(r).piece,g(e,R["default"].drawByPov(o),r),e.animation.current.hint=L["default"].leaveTaken;break;case L["default"].openSeries:a=G["default"].readPieceGroup(a),c(e,a),e.animation.current.hint=L["default"].openSeries;break;case L["default"].openPairs:a=G["default"].readPieceGroup(a),f(e,a),e.animation.current.hint=L["default"].openSeries;break;case L["default"].dropOpenSeries:r=G["default"].readPiece(r).piece,i=G["default"].readDropPos(i),d(e,r,i);break;case L["default"].dropOpenPairs:r=G["default"].readPiece(r).piece,i=G["default"].readDropPos(i),s(e,r,i);break;default:console.error("unknown move")}else if(e.spectator)t===L["default"].leaveTaken&&(r=G["default"].readPiece(r).piece,g(e,R["default"].drawByPov(o),r),e.animation.current.hint=L["default"].leaveTaken);else switch(t){case L["default"].discard:r=G["default"].readPiece(r).piece,w(e,r,R["default"].discards[2]),e.animation.current.hint=L["default"].discard;break;case L["default"].drawMiddle:r=G["default"].readPiece(r).piece,e.middleHolder.current?N["default"].apiDrawMiddleEnd(e,r):N["default"].apiForceDrawMiddleEnd(e,r),e.animation.current.hint=L["default"].drawMiddle;break;case L["default"].leaveTaken:N["default"].playLeaveTaken(e,r)}}function d(e,t,n){var r=n.type,a=n.groupIndex,i=e.opens.series[a],o=r!==L["default"].dropReplace?0:1,u=0;if(r===L["default"].dropLeft)u=0;else if(r===L["default"].dropRight)u=i.length+1;else{var l=G["default"].pieceUp(e.middles[R["default"].gosterge]);u=F["default"].findOkeyIndex(i,l)+1}i.splice(u-o,o,t),e.opens.relayout(e)}function s(e,t,n){var r=n.groupIndex,a=e.opens.pairs[r],i=G["default"].pieceUp(e.middles[R["default"].gosterge]),o=F["default"].findOkeyIndex(a,i);a.splice(o,1,t),e.opens.relayout(e)}function c(e,t){var n=t,r=e.opens.series.concat(n);e.opens.series=r,e.opens.relayout(e)}function f(e,t){var n=t,r=e.opens.pairs.concat(n);e.opens.pairs=r,e.opens.relayout(e)}function p(e,t,n){return e.discards[t].unshift(n),e.lastMove=[t],!0}function v(e){return e.middles[R["default"].middleCount]--,e.lastMove=[R["default"].middleCount],!0}function m(e,t){return e.discards[t].shift(),!0}function g(e,t,n){return e.discards[t].unshift(n),!0}function h(e,t,n,r){if(!e.pieces[t]||!r)return!1;var i=e.pieces[t];U(R["default"].partial(e.events.move,L["default"].dropOpenSeries,I(i.key)));var o=a(r,2),u=o[0],l=o[1],d=e.opens.series[u],s=O(d,l),c=s!==L["default"].dropReplace?0:1;if(d.splice(l-c,c,i),e.opens.relayout(e),delete e.pieces[t],s===L["default"].dropReplace){var f=G["default"].pieceUp(e.middles[R["default"].gosterge]);e.pieces[t]=f}return!0}function y(e,t,n,r){if(!e.pieces[t]||!r)return!1;var i=e.pieces[t];U(R["default"].partial(e.events.move,L["default"].dropOpenPairs,I(i.key)));var o=a(r,2),u=o[0],l=o[1],d=e.opens.pairs[u];d.splice(l,1,i),e.opens.relayout(e),delete e.pieces[t];var s=G["default"].pieceUp(e.middles[R["default"].gosterge]);return e.pieces[t]=s,!0}function w(e,t,n){for(var r in e.pieces){var a=e.pieces[r];if(a&&R["default"].pieceEqual(t,a))return b(e,r,n),!0}return!1}function b(e,t,n){var r=e.pieces[t];return!!r&&(U(R["default"].partial(e.events.move,L["default"].discard,I(r.key))),e.discards[n].unshift(e.pieces[t]),delete e.pieces[t],e.lastMove=[n],!0)}function P(e,t){var n=e.pieces[t];return!!n&&(!!R["default"].pieceEqual(n,e.middles[R["default"].gosterge])&&(U(R["default"].partial(e.events.move,L["default"].sign,I(n.key))),!0))}function k(e,t){var n=e.pieces[t];if(!n)return!1;delete e.pieces[t];var r=(G["default"].write(e.pieces),N["default"].getPieceGroupSeries(e)),a=N["default"].getPieceGroupPairs(e);if(G["default"].validDuzOkeyGroupFen(r))U(R["default"].partial(e.events.move,L["default"].discardEndSeries,H(r)));else{if(!G["default"].validDuzOkeyGroupFen(a))return e.pieces[t]=n,!1;U(R["default"].partial(e.events.move,L["default"].discardEndPairs,H(a)))}return!0}function O(e,t){return 0===t?L["default"].dropLeft:t===e.length+1?L["default"].dropRight:L["default"].dropReplace}function x(e,t,n){if(n&&R["default"].isOpensKey(n)&&T(e,t,n)){var r,i,o,u,l,d=e.pieces[t],s=G["default"].getOpenSerieFromPos(e,R["default"].miniKey2pos(n));if(s){var c=a(s,2);r=c[0],i=c[1],o=e.opens.series[r],u=O(o,i),l=u+r}if(h(e,t,n,s))return U(R["default"].partial(e.movable.events.after,L["default"].dropOpenSeries,_(d.key,l))),!0;var f=G["default"].getOpenPairFromPos(e,R["default"].miniKey2pos(n));if(f){var p=a(f,2);r=p[0],i=p[1],o=e.opens.pairs[r],u=O(o,i),l=u+r}if(y(e,t,n,f))return U(R["default"].partial(e.movable.events.after,L["default"].dropOpenPairs,_(d.key,l))),!0}return!1}function S(e,t,n){var r=e.pieces[t];if(n&&n===R["default"].discards[2]){if(A(e,t,n)&&b(e,t,n))return U(R["default"].partial(e.movable.events.after,L["default"].discard,I(r.key))),!0}else if(n===R["default"].gosterge){if(B(e,t)&&P(e,t))return U(R["default"].partial(e.movable.events.after,L["default"].sign,I(r.key))),!0;if(D(e,t)&&k(e,t)){var a=(G["default"].write(e.pieces),N["default"].getPieceGroupSeries(e)),i=N["default"].getPieceGroupPairs(e);return G["default"].validDuzOkeyGroupFen(a)?U(R["default"].partial(e.movable.events.after,L["default"].discardEndSeries,H(a))):G["default"].validDuzOkeyGroupFen(i)&&U(R["default"].partial(e.movable.events.after,L["default"].discardEndPairs,H(i))),!0}}return!1}function E(e,t){M(e,t)}function M(e,t){e.selected=t}function C(e,t){return R["default"].isMiddleKey(t)||R["default"].isDrawLeftKey(t)?e.povSide===e.turnSide:R["default"].isBoardKey(t)}function K(e){return e.povSide===e.turnSide}function T(e,t,n){var r=e.middles[R["default"].gosterge];return N["default"].isDroppableOpens(e,t)&&R["default"].isBoardKey(t)&&R["default"].isOpensKey(n)&&R["default"].containsX(e.movable.dests,L["default"].dropOpenSeries)&&R["default"].containsX(e.movable.dests,L["default"].dropOpenPairs)&&R["default"].containsX(F["default"].compute(e.opens,e.pieces[t],r),n)}function A(e,t,n){return K(e)&&R["default"].containsX(e.movable.dests,L["default"].discard)}function D(e,t){return K(e)&&R["default"].containsX(e.movable.dests,L["default"].discardEndSeries)}function B(e,t){return K(e)&&R["default"].containsX(e.movable.dests,L["default"].showSign)}function j(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R["default"].topColumns,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:R["default"].topRows;return function(r,a,i){if(i||r.bounds){i=i||r.bounds();var o=Math.floor(t*((a[0]-i.left)/i.width)),u=Math.floor(n*((a[1]-i.top)/i.height));return u>=0&&u<n&&o>=0&&o<t?e(u,o):void 0}}}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=void 0;var R=r(e("./util")),L=r(e("./move")),G=r(e("./pieces")),F=r(e("./open")),N=r(e("./board")),_=R["default"].wrapDrop,I=R["default"].wrapPiece,H=R["default"].wrapGroup,U=R["default"].callUserFunction,q=j(function(e,t){return R["default"].miniPos2key([t,e])},R["default"].miniColumns,R["default"].miniRows),X=j(function(e,t){if(e===R["default"].topRows-1){if(0===t)return R["default"].discards[1];if(t===R["default"].topColumns-4)return R["default"].middleCount}}),z=j(function(e,t){if(e===R["default"].topRows-1){if(t===R["default"].topColumns-1)return R["default"].discards[2];if(t===R["default"].topColumns-3)return R["default"].gosterge}}),$={apiMove:l,selectTop:E,dropTop:S,dropOpens:x,isDraggable:C,getDrawKeyAtDomPos:X,
getDiscardKeyAtDomPos:z,getOpensKeyAtDomPos:q};n["default"]=$},{"./board":5,"./move":12,"./open":13,"./pieces":14,"./util":17}],17:[function(e,t,n){"use strict";function r(e,t){return _[e][t]}function a(e,t){return e.color===t.color&&e.number===t.number}function i(e,t){for(var n=[],r=0;r<e;r++)for(var a=0;a<t;a++)n.push([a,r]);return n}function o(e,t){return t+e}function u(e,t){return parseInt(e.slice(1))}function l(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return o(u(e)-t,W)}function d(e){return e[0]===W}function s(e){return e[0]===Z}function c(e){return e===J}function f(e){return e===$[1]}function p(e){var t=e[1]*B+e[0];return o(t,W)}function v(e){return e=u(e),[e%B,Math.floor(e/B)]}function m(e){return o(e,W)}function g(e,t){function n(e){var t=Math.floor(e/B),n=e%B;return[n,t]}function r(e){return e[1]*B+e[0]}var a=n(e),i=n(e+2*t);return a[1]!==i[1]?r([1,1]):(1===a[1]&&0===a[0]&&(a[0]=1),r(a))}function h(e){return Y[e]}function y(e){var t=e[1]*G+e[0];return o(t,Z)}function w(e){return e=u(e),[e%G,Math.floor(e/G)]}function b(e){var t=[];for(var n in e)e[n]&&t.push(n);return t.join(" ")}function P(e,t){return e&&e.indexOf(t)!==-1}function k(e){return e.touches?[e.targetTouches[0].clientX,e.targetTouches[0].clientY]:[e.clientX,e.clientY]}function O(e,t){return Math.sqrt(Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2))}function x(){return"transform"in document.body.style?"transform":"webkitTransform"in document.body.style?"webkitTransform":"mozTransform"in document.body.style?"mozTransform":"oTransform"in document.body.style?"oTransform":"msTransform"}function S(){return D||(D=x()),D}function E(e){return"translate("+e[0]+"px,"+e[1]+"px)"}function M(e,t){return e.bind.apply(e,[null].concat(t))}function C(){return M(arguments[0],Array.prototype.slice.call(arguments,1))}function K(e){return 2===e.buttons||2===e.button}function T(e){var t,n=function(){return void 0===t&&(t=e()),t};return n.clear=function(){t=void 0},n}function A(e){setTimeout(e,1)}var D,B=32,j=2,R=16,L=7,G=20,F=8,N=["east","west","north","south"],_={east:{east:"down",west:"up",north:"right",south:"left"},west:{east:"up",west:"down",north:"left",south:"right"},north:{east:"left",west:"right",north:"down",south:"up"},south:{east:"right",west:"left",north:"up",south:"down"}},I={up:0,left:1,down:2,right:3},H={up:3,left:0,down:1,right:2},U={up:[.5,0],left:[0,.5],right:[1,.5],down:[.5,1]},q=function(e){return U[e]},X=function(e){return $[I[e]]},z=function(e){return $[H[e]]},$=["dup","dleft","ddown","dright"],J="mmiddleCount",V="mgosterge",Y={dup:[0,0],dleft:[0,L-1],ddown:[R-1,L-1],dright:[R-1,0],mmiddleCount:[R-4,L-1],mgosterge:[R-3,L-1]},Q={color:"empty",number:1},W="b",Z="o",ee=i(j,B),te=i(F,G),ne=[[0,0],[30,0],[31,0],[32,0],[62,0],[63,0]].map(p),re=function(e){return ne.indexOf(e)===-1},ae=ee.map(p),ie=ae.filter(re),oe=function(e){return ie.indexOf(e)!==-1},ue=te.map(y),le=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t.piece=e,t},de=function(e){return{group:e}},se=function(e,t){return{piece:e,pos:t}};t.exports={topColumns:R,topRows:L,columns:B,rows:j,emptyPiece:Q,pieceEqual:a,allSides:N,allPos:ee,allKeys:ae,topKey2pos:h,pos2key:p,key2pos:v,iterator2Key:m,nextIteratorForGroup:g,miniColumns:G,miniRows:F,miniAllPos:te,miniAllKeys:ue,miniPos2key:y,miniKey2pos:w,encodeKey:o,decBoardKey:l,notAllowedBoardKeys:ne,isAllowedBoardKey:re,isAllAllowedBoardKey:oe,allAllowedBoardKeys:ie,isBoardKey:d,isOpensKey:s,isMiddleKey:c,isDrawLeftKey:f,findPov:r,vectorByPov:q,drawByPov:z,discardByPov:X,discards:$,middleCount:J,gosterge:V,classSet:b,containsX:P,eventPosition:k,distance:O,transformProp:S,translate:E,requestAnimationFrame:(window.requestAnimationFrame||window.setTimeout).bind(window),partialApply:M,partial:C,isRightButton:K,memo:T,wrapPiece:le,wrapGroup:de,wrapDrop:se,callUserFunction:A}},{}],18:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){return e.color+" "+e.number}function i(e){return{left:e[0]*(100/T["default"].columns)+"%",top:e[1]*(100/T["default"].rows)+"%"}}function o(e){return{left:e[0]*(100/T["default"].miniColumns)+"%",top:e[1]*(100/T["default"].miniRows)+"%"}}function u(e,t,n,r){var i=(e.data,{key:n,style:o(t),"class":a(r)+" mini"});if(e.data.animation.current.anims){var u=e.data.animation.current.anims[n],l=e.data.animation.current.scales[n];u&&(i["class"]+=" animating",i.style[T["default"].transformProp()]=T["default"].translate(u[1]),l&&(i.style[T["default"].transformProp()]+=" scale(".concat(l[0],", ").concat(l[1],")"),i.style.transformOrigin="center"))}return{tag:"piece",attrs:i}}function l(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=e.data,o=T["default"].classSet({selected:i.selected===t,"last-move":i.lastMove&&T["default"].containsX(i.lastMove,t)}),u={style:{},"class":[a(n),t,o].join(" "),"data-middle-count":e.data.middles[t]},l=e.data.draggable.current;if(r&&l.orig===t)u.style[T["default"].transformProp()]=T["default"].translate([l.pos[0]+l.dec[0],l.pos[1]+l.dec[1]]),u["class"]+=" dragging";else if(!r&&e.data.animation.current.anims){var d=e.data.animation.current.anims[t];d&&(u["class"]+=" animating",u.style[T["default"].transformProp()]=T["default"].translate(d[1]))}return{tag:"piece",attrs:u}}function d(e,t,n,r){var i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:t,u=e.data,l=T["default"].classSet({selected:u.selected===t}),d={style:{},"class":[a(n),t,l].join(" ")};r&&(d["class"]+=" "+r);var s=e.data.draggable.current;if(i&&s.orig===t)d.style[T["default"].transformProp()]=T["default"].translate([s.pos[0]+s.dec[0],s.pos[1]+s.dec[1]]),d["class"]+=" dragging";else if(i&&e.data.animation.current.anims){var c=e.data.animation.current.anims[o];c&&(d["class"]+=" animating",d.style[T["default"].transformProp()]=T["default"].translate(c[1]))}return{tag:"piece",attrs:d}}function s(e,t,n){var r=(e.data,T["default"].classSet({"piece-holder":!0})),a={style:{},"class":[t,r,n].join(" ")};return{tag:"div",attrs:a}}function c(e,t,n,r){var a="flipper"+(n?" hover":"")+" "+r,i={top:0,left:0},o=e.attrs.style;e.attrs.style=i,t.attrs.style=i;var u={"class":a,style:o};return{tag:"div",attrs:u,children:[{tag:"div",attrs:{"class":"front"},children:[e]},{tag:"div",attrs:{"class":"back"},children:[t]}]}}function f(e,t,n,r,o){var u=e.data,l=T["default"].classSet({selected:u.selected===n}),d={key:n,style:i(t),"class":[a(r),l].join(" ")};o&&(d["class"]+=" "+o);var s=e.data.draggable.current;if(s.dragGroup&&s.dragGroup.indexOf(n)!==-1?(d.style[T["default"].transformProp()]=T["default"].translate([s.pos[0]+s.dec[0],s.pos[1]+s.dec[1]]),d["class"]+=" group dragging"):s.orig===n&&(s.over&&T["default"].isOpensKey(s.over)&&(d.style.width=s.opensBounds.width/T["default"].miniColumns+"px",d.style.height=s.opensBounds.height/T["default"].miniRows+"px"),d.style[T["default"].transformProp()]=T["default"].translate([s.pos[0]+s.dec[0],s.pos[1]+s.dec[1]]),d["class"]+=" dragging"),e.data.animation.current.anims){var c=e.data.animation.current.anims[n];c&&(d["class"]+=" animating",d.style[T["default"].transformProp()]=T["default"].translate(c[1]))}return{tag:"piece",attrs:d}}function p(e,t,n){return{tag:"div",attrs:{"class":e+" oc "+n}}}function v(e,t,n){return{tag:"div",attrs:{style:o(n),"class":e+" oc"}}}function m(e,t,n){return{tag:"div",attrs:{style:i(n),"class":e}}}function g(e){function t(e){return{tag:"div",attrs:{"class":"wood "+e}}}var n,r=e.data,a=T["default"].allPos,i=[];i.push(t("left"),t("right"));for(var o=0;o<a.length;o++){var u=T["default"].pos2key(a[o]),l=r.pieces[u];if(l){var d=f(e,a[o],u,l);if(r.flippable.current.orig===u){var s,p,v=r.flippable.current.flip,g=f(e,a[o],u,T["default"].emptyPiece);l.flip?(s=g,p=d):(s=d,p=g),i.push(c(s,p,v))}else l.flip&&(d=f(e,a[o],u,T["default"].emptyPiece)),i.push(d)}r.draggable.current.over===u&&(n=m("drag-over",e,a[o]))}return r.middleHolder.key&&i.push(f(e,T["default"].key2pos(r.middleHolder.key),r.middleHolder.key,T["default"].emptyPiece,"loading")),n&&i.push(n),{tag:"div",attrs:{config:function(t,n,r){n||(e.data.boardBounds=T["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-board"},children:i}}function h(e,t){for(var n=e.data,r=T["default"].miniAllPos,a=[],i=[],o=0;o<r.length;o++){var l=T["default"].miniPos2key(r[o]),d=t[l];if(d&&a.push(u(e,r[o],l,d)),e.data.animation.current.anims){var s=e.data.animation.current.anims[l];d=e.data.animation.current.extra[l],s&&d&&a.push(u(e,r[o],l,d))}var c=T["default"].classSet({"drag-over":n.draggable.current.over===l,"move-dest":T["default"].containsX(n.openable.dests,l)});""!==c&&i.push(v(c,e,r[o]))}return a.push(i),a}function y(e){var t=e.data,n=h(e,t.opens.layout.layout);return{tag:"div",attrs:{config:function(t,n,r){n||(e.data.opensBounds=T["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-opens"},children:n}}function w(e){var t=e.data,n=[],r=[];for(var a in t.discards){var i=t.discards[a][0],o=T["default"].classSet({"drag-over":t.draggable.current.over===a,"move-dest":"ddown"===a&&t.selected&&T["default"].isBoardKey(t.selected)&&T["default"].containsX(t.movable.dests,A["default"].discard),"last-move":t.lastMove&&T["default"].containsX(t.lastMove,a)});if(i){t.discards[a][1]&&r.push(d(e,a,t.discards[a][1],"fake",!1)),r.push(d(e,a,i,o));var u=A["default"].drawLeft+a,l=!!e.data.animation.current.anims&&e.data.animation.current.anims[u];if(l){var c=e.data.animation.current.extra.piece;r.push(d(e,a,c,o,!0,u))}}else n.push(s(e,a,o))}return n.push(r),n}function b(e){var t=e.data,n=[],r=t.middleHolder.piece||T["default"].emptyPiece;if(n.push(d(e,T["default"].gosterge,t.middles[T["default"].gosterge])),n.push(l(e,T["default"].middleCount,T["default"].emptyPiece)),T["default"].isMiddleKey(t.draggable.current.orig)||t.animation.current.anims&&t.animation.current.anims[T["default"].middleCount]){var a=l(e,T["default"].middleCount,r,!0);n.push(a)}return t.draggable.current.over===T["default"].gosterge&&n.push(p("drag-over",e,T["default"].gosterge)),n}function P(e){var t=[],n=e.data.topHooks;return n&&t.push(n),t}function k(e){var t=[b(e),w(e),y(e),P(e)];return{tag:"div",attrs:{config:function(t,n,r){n||(e.data.topBounds=T["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-top"},children:t}}function O(e){return[k(e),g(e)]}function x(e,t,n){return function(r){T["default"].isRightButton(r)?n(e,r):e.viewOnly||t(e,r)}}function S(e,t,n){var r=e.data,a=x(r,C["default"].start,K["default"].start),i=x(r,C["default"].move,K["default"].move),o=x(r,C["default"].end,K["default"].end),u=["touchstart","mousedown"],l=["touchmove","mousemove"],d=["touchend","mouseup"];u.forEach(function(e){t.addEventListener(e,a)}),l.forEach(function(e){document.addEventListener(e,i)}),d.forEach(function(e){document.addEventListener(e,o)}),n.onunload=function(){u.forEach(function(e){t.removeEventListener(e,a)}),l.forEach(function(e){document.removeEventListener(e,i)}),d.forEach(function(e){document.removeEventListener(e,o)})}}function E(e){return{tag:"div",attrs:{"class":"og-table",config:function(t,n,r){n||(e.data.viewOnly||S(e,t,r),e.data.render=function(){M["default"].render(t,O(e))},e.data.renderRAF=function(){T["default"].requestAnimationFrame(e.data.render)},e.data.bounds=T["default"].memo(t.getBoundingClientRect.bind(t)),e.data.element=t,e.data.render())}},children:[]}}var M=r(e("mithril")),C=r(e("./drag")),K=r(e("./draw")),T=r(e("./util")),A=r(e("./move"));t.exports=function(e){return{tag:"div",attrs:{config:function(t,n){n||(t.addEventListener("contextmenu",function(e){return e.preventDefault(),!1}),["onscroll","onresize"].forEach(function(t){var n=window[t];window[t]=function(){n&&n(),e.data.bounds.clear(),e.data.boardBounds.clear(),e.data.opensBounds.clear(),e.data.topBounds.clear()}}))},"class":["og-table-wrap"].join(" ")},children:[E(e)]}}},{"./drag":9,"./draw":10,"./move":12,"./util":17,mithril:2}]},{},[11])(11)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

},{}],3:[function(require,module,exports){
var conversions = require("./conversions");

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;
},{"./conversions":2}],4:[function(require,module,exports){
module.exports={
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
}
},{}],5:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');

module.exports = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
}

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr =  /^#([a-fA-F0-9]{3})$/,
       hex =  /^#([a-fA-F0-9]{6})$/,
       rgba = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d\.]+)\s*)?\)$/,
       per = /^rgba?\(\s*([\d\.]+)\%\s*,\s*([\d\.]+)\%\s*,\s*([\d\.]+)\%\s*(?:,\s*([\d\.]+)\s*)?\)$/,
       keyword = /(\D+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr);
   if (match) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   }
   else if (match = string.match(hex)) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   }
   else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   }
   else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*(\d+)(?:deg)?\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*(?:,\s*([\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(parseFloat(match[4]) || 1, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*(\d+)(?:deg)?\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*(?:,\s*([\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(parseFloat(match[4]) || 1, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   }
   else if (vals = getHsla(string)) {
      return vals[3];
   }
   else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgb) {
   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
              + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return (str.length < 2) ? "0" + str : str;
}


//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
   reverseNames[colorNames[name]] = name;
}
},{"color-name":4}],6:[function(require,module,exports){
/* MIT license */
var convert = require("color-convert"),
    string = require("color-string");

var Color = function(cssString) {
  if (cssString instanceof Color) return cssString;
  if (! (this instanceof Color)) return new Color(cssString);

   this.values = {
      rgb: [0, 0, 0],
      hsl: [0, 0, 0],
      hsv: [0, 0, 0],
      hwb: [0, 0, 0],
      cmyk: [0, 0, 0, 0],
      alpha: 1
   }

   // parse Color() argument
   if (typeof cssString == "string") {
      var vals = string.getRgba(cssString);
      if (vals) {
         this.setValues("rgb", vals);
      }
      else if(vals = string.getHsla(cssString)) {
         this.setValues("hsl", vals);
      }
      else if(vals = string.getHwb(cssString)) {
         this.setValues("hwb", vals);
      }
      else {
        throw new Error("Unable to parse color from string \"" + cssString + "\"");
      }
   }
   else if (typeof cssString == "object") {
      var vals = cssString;
      if(vals["r"] !== undefined || vals["red"] !== undefined) {
         this.setValues("rgb", vals)
      }
      else if(vals["l"] !== undefined || vals["lightness"] !== undefined) {
         this.setValues("hsl", vals)
      }
      else if(vals["v"] !== undefined || vals["value"] !== undefined) {
         this.setValues("hsv", vals)
      }
      else if(vals["w"] !== undefined || vals["whiteness"] !== undefined) {
         this.setValues("hwb", vals)
      }
      else if(vals["c"] !== undefined || vals["cyan"] !== undefined) {
         this.setValues("cmyk", vals)
      }
      else {
        throw new Error("Unable to parse color from object " + JSON.stringify(cssString));
      }
   }
}

Color.prototype = {
   rgb: function (vals) {
      return this.setSpace("rgb", arguments);
   },
   hsl: function(vals) {
      return this.setSpace("hsl", arguments);
   },
   hsv: function(vals) {
      return this.setSpace("hsv", arguments);
   },
   hwb: function(vals) {
      return this.setSpace("hwb", arguments);
   },
   cmyk: function(vals) {
      return this.setSpace("cmyk", arguments);
   },

   rgbArray: function() {
      return this.values.rgb;
   },
   hslArray: function() {
      return this.values.hsl;
   },
   hsvArray: function() {
      return this.values.hsv;
   },
   hwbArray: function() {
      if (this.values.alpha !== 1) {
        return this.values.hwb.concat([this.values.alpha])
      }
      return this.values.hwb;
   },
   cmykArray: function() {
      return this.values.cmyk;
   },
   rgbaArray: function() {
      var rgb = this.values.rgb;
      return rgb.concat([this.values.alpha]);
   },
   hslaArray: function() {
      var hsl = this.values.hsl;
      return hsl.concat([this.values.alpha]);
   },
   alpha: function(val) {
      if (val === undefined) {
         return this.values.alpha;
      }
      this.setValues("alpha", val);
      return this;
   },

   red: function(val) {
      return this.setChannel("rgb", 0, val);
   },
   green: function(val) {
      return this.setChannel("rgb", 1, val);
   },
   blue: function(val) {
      return this.setChannel("rgb", 2, val);
   },
   hue: function(val) {
      return this.setChannel("hsl", 0, val);
   },
   saturation: function(val) {
      return this.setChannel("hsl", 1, val);
   },
   lightness: function(val) {
      return this.setChannel("hsl", 2, val);
   },
   saturationv: function(val) {
      return this.setChannel("hsv", 1, val);
   },
   whiteness: function(val) {
      return this.setChannel("hwb", 1, val);
   },
   blackness: function(val) {
      return this.setChannel("hwb", 2, val);
   },
   value: function(val) {
      return this.setChannel("hsv", 2, val);
   },
   cyan: function(val) {
      return this.setChannel("cmyk", 0, val);
   },
   magenta: function(val) {
      return this.setChannel("cmyk", 1, val);
   },
   yellow: function(val) {
      return this.setChannel("cmyk", 2, val);
   },
   black: function(val) {
      return this.setChannel("cmyk", 3, val);
   },

   hexString: function() {
      return string.hexString(this.values.rgb);
   },
   rgbString: function() {
      return string.rgbString(this.values.rgb, this.values.alpha);
   },
   rgbaString: function() {
      return string.rgbaString(this.values.rgb, this.values.alpha);
   },
   percentString: function() {
      return string.percentString(this.values.rgb, this.values.alpha);
   },
   hslString: function() {
      return string.hslString(this.values.hsl, this.values.alpha);
   },
   hslaString: function() {
      return string.hslaString(this.values.hsl, this.values.alpha);
   },
   hwbString: function() {
      return string.hwbString(this.values.hwb, this.values.alpha);
   },
   keyword: function() {
      return string.keyword(this.values.rgb, this.values.alpha);
   },

   rgbNumber: function() {
      return (this.values.rgb[0] << 16) | (this.values.rgb[1] << 8) | this.values.rgb[2];
   },

   luminosity: function() {
      // http://www.w3.org/TR/WCAG20/#relativeluminancedef
      var rgb = this.values.rgb;
      var lum = [];
      for (var i = 0; i < rgb.length; i++) {
         var chan = rgb[i] / 255;
         lum[i] = (chan <= 0.03928) ? chan / 12.92
                  : Math.pow(((chan + 0.055) / 1.055), 2.4)
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
   },

   contrast: function(color2) {
      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
         return (lum1 + 0.05) / (lum2 + 0.05)
      };
      return (lum2 + 0.05) / (lum1 + 0.05);
   },

   level: function(color2) {
     var contrastRatio = this.contrast(color2);
     return (contrastRatio >= 7.1)
       ? 'AAA'
       : (contrastRatio >= 4.5)
        ? 'AA'
        : '';
   },

   dark: function() {
      // YIQ equation from http://24ways.org/2010/calculating-color-contrast
      var rgb = this.values.rgb,
          yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
   	return yiq < 128;
   },

   light: function() {
      return !this.dark();
   },

   negate: function() {
      var rgb = []
      for (var i = 0; i < 3; i++) {
         rgb[i] = 255 - this.values.rgb[i];
      }
      this.setValues("rgb", rgb);
      return this;
   },

   lighten: function(ratio) {
      this.values.hsl[2] += this.values.hsl[2] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   darken: function(ratio) {
      this.values.hsl[2] -= this.values.hsl[2] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   saturate: function(ratio) {
      this.values.hsl[1] += this.values.hsl[1] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   desaturate: function(ratio) {
      this.values.hsl[1] -= this.values.hsl[1] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   whiten: function(ratio) {
      this.values.hwb[1] += this.values.hwb[1] * ratio;
      this.setValues("hwb", this.values.hwb);
      return this;
   },

   blacken: function(ratio) {
      this.values.hwb[2] += this.values.hwb[2] * ratio;
      this.setValues("hwb", this.values.hwb);
      return this;
   },

   greyscale: function() {
      var rgb = this.values.rgb;
      // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      this.setValues("rgb", [val, val, val]);
      return this;
   },

   clearer: function(ratio) {
      this.setValues("alpha", this.values.alpha - (this.values.alpha * ratio));
      return this;
   },

   opaquer: function(ratio) {
      this.setValues("alpha", this.values.alpha + (this.values.alpha * ratio));
      return this;
   },

   rotate: function(degrees) {
      var hue = this.values.hsl[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      this.values.hsl[0] = hue;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   mix: function(color2, weight) {
      weight = 1 - (weight == null ? 0.5 : weight);

      // algorithm from Sass's mix(). Ratio of first color in mix is
      // determined by the alphas of both colors and the weight
      var t1 = weight * 2 - 1,
          d = this.alpha() - color2.alpha();

      var weight1 = (((t1 * d == -1) ? t1 : (t1 + d) / (1 + t1 * d)) + 1) / 2;
      var weight2 = 1 - weight1;

      var rgb = this.rgbArray();
      var rgb2 = color2.rgbArray();

      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = rgb[i] * weight1 + rgb2[i] * weight2;
      }
      this.setValues("rgb", rgb);

      var alpha = this.alpha() * weight + color2.alpha() * (1 - weight);
      this.setValues("alpha", alpha);

      return this;
   },

   toJSON: function() {
     return this.rgb();
   },

   clone: function() {
     return new Color(this.rgb());
   }
}


Color.prototype.getValues = function(space) {
   var vals = {};
   for (var i = 0; i < space.length; i++) {
      vals[space[i]] = this.values[space][i];
   }
   if (this.values.alpha != 1) {
      vals["a"] = this.values.alpha;
   }
   // {r: 255, g: 255, b: 255, a: 0.4}
   return vals;
}

Color.prototype.setValues = function(space, vals) {
   var spaces = {
      "rgb": ["red", "green", "blue"],
      "hsl": ["hue", "saturation", "lightness"],
      "hsv": ["hue", "saturation", "value"],
      "hwb": ["hue", "whiteness", "blackness"],
      "cmyk": ["cyan", "magenta", "yellow", "black"]
   };

   var maxes = {
      "rgb": [255, 255, 255],
      "hsl": [360, 100, 100],
      "hsv": [360, 100, 100],
      "hwb": [360, 100, 100],
      "cmyk": [100, 100, 100, 100]
   };

   var alpha = 1;
   if (space == "alpha") {
      alpha = vals;
   }
   else if (vals.length) {
      // [10, 10, 10]
      this.values[space] = vals.slice(0, space.length);
      alpha = vals[space.length];
   }
   else if (vals[space[0]] !== undefined) {
      // {r: 10, g: 10, b: 10}
      for (var i = 0; i < space.length; i++) {
        this.values[space][i] = vals[space[i]];
      }
      alpha = vals.a;
   }
   else if (vals[spaces[space][0]] !== undefined) {
      // {red: 10, green: 10, blue: 10}
      var chans = spaces[space];
      for (var i = 0; i < space.length; i++) {
        this.values[space][i] = vals[chans[i]];
      }
      alpha = vals.alpha;
   }
   this.values.alpha = Math.max(0, Math.min(1, (alpha !== undefined ? alpha : this.values.alpha) ));
   if (space == "alpha") {
      return;
   }

   // cap values of the space prior converting all values
   for (var i = 0; i < space.length; i++) {
      var capped = Math.max(0, Math.min(maxes[space][i], this.values[space][i]));
      this.values[space][i] = Math.round(capped);
   }

   // convert to all the other color spaces
   for (var sname in spaces) {
      if (sname != space) {
         this.values[sname] = convert[space][sname](this.values[space])
      }

      // cap values
      for (var i = 0; i < sname.length; i++) {
         var capped = Math.max(0, Math.min(maxes[sname][i], this.values[sname][i]));
         this.values[sname][i] = Math.round(capped);
      }
   }
   return true;
}

Color.prototype.setSpace = function(space, args) {
   var vals = args[0];
   if (vals === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof vals == "number") {
      vals = Array.prototype.slice.call(args);
   }
   this.setValues(space, vals);
   return this;
}

Color.prototype.setChannel = function(space, index, val) {
   if (val === undefined) {
      // color.red()
      return this.values[space][index];
   }
   // color.red(100)
   this.values[space][index] = val;
   this.setValues(space, this.values[space]);
   return this;
}

module.exports = Color;

},{"color-convert":3,"color-string":5}],7:[function(require,module,exports){
/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
(function (window, document, Math) {
var rAF = window.requestAnimationFrame	||
	window.webkitRequestAnimationFrame	||
	window.mozRequestAnimationFrame		||
	window.oRequestAnimationFrame		||
	window.msRequestAnimationFrame		||
	function (callback) { window.setTimeout(callback, 1000 / 60); };

var utils = (function () {
	var me = {};

	var _elementStyle = document.createElement('div').style;
	var _vendor = (function () {
		var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			transform,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			transform = vendors[i] + 'ransform';
			if ( transform in _elementStyle ) return vendors[i].substr(0, vendors[i].length-1);
		}

		return false;
	})();

	function _prefixStyle (style) {
		if ( _vendor === false ) return false;
		if ( _vendor === '' ) return style;
		return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
	}

	me.getTime = Date.now || function getTime () { return new Date().getTime(); };

	me.extend = function (target, obj) {
		for ( var i in obj ) {
			target[i] = obj[i];
		}
	};

	me.addEvent = function (el, type, fn, capture) {
		el.addEventListener(type, fn, !!capture);
	};

	me.removeEvent = function (el, type, fn, capture) {
		el.removeEventListener(type, fn, !!capture);
	};

	me.prefixPointerEvent = function (pointerEvent) {
		return window.MSPointerEvent ?
			'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8):
			pointerEvent;
	};

	me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
		var distance = current - start,
			speed = Math.abs(distance) / time,
			destination,
			duration;

		deceleration = deceleration === undefined ? 0.0006 : deceleration;

		destination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance < 0 ? -1 : 1 );
		duration = speed / deceleration;

		if ( destination < lowerMargin ) {
			destination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin;
			distance = Math.abs(destination - current);
			duration = distance / speed;
		} else if ( destination > 0 ) {
			destination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0;
			distance = Math.abs(current) + destination;
			duration = distance / speed;
		}

		return {
			destination: Math.round(destination),
			duration: duration
		};
	};

	var _transform = _prefixStyle('transform');

	me.extend(me, {
		hasTransform: _transform !== false,
		hasPerspective: _prefixStyle('perspective') in _elementStyle,
		hasTouch: 'ontouchstart' in window,
		hasPointer: !!(window.PointerEvent || window.MSPointerEvent), // IE10 is prefixed
		hasTransition: _prefixStyle('transition') in _elementStyle
	});

	/*
	This should find all Android browsers lower than build 535.19 (both stock browser and webview)
	- galaxy S2 is ok
    - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`
    - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S3 is badAndroid (stock brower, webview)
     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S4 is badAndroid (stock brower, webview)
     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S5 is OK
     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
   - galaxy S6 is OK
     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
  */
	me.isBadAndroid = (function() {
		var appVersion = window.navigator.appVersion;
		// Android browser is not a chrome browser.
		if (/Android/.test(appVersion) && !(/Chrome\/\d/.test(appVersion))) {
			var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);
			if(safariVersion && typeof safariVersion === "object" && safariVersion.length >= 2) {
				return parseFloat(safariVersion[1]) < 535.19;
			} else {
				return true;
			}
		} else {
			return false;
		}
	})();

	me.extend(me.style = {}, {
		transform: _transform,
		transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
		transitionDuration: _prefixStyle('transitionDuration'),
		transitionDelay: _prefixStyle('transitionDelay'),
		transformOrigin: _prefixStyle('transformOrigin')
	});

	me.hasClass = function (e, c) {
		var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
		return re.test(e.className);
	};

	me.addClass = function (e, c) {
		if ( me.hasClass(e, c) ) {
			return;
		}

		var newclass = e.className.split(' ');
		newclass.push(c);
		e.className = newclass.join(' ');
	};

	me.removeClass = function (e, c) {
		if ( !me.hasClass(e, c) ) {
			return;
		}

		var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
		e.className = e.className.replace(re, ' ');
	};

	me.offset = function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;

		// jshint -W084
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		// jshint +W084

		return {
			left: left,
			top: top
		};
	};

	me.preventDefaultException = function (el, exceptions) {
		for ( var i in exceptions ) {
			if ( exceptions[i].test(el[i]) ) {
				return true;
			}
		}

		return false;
	};

	me.extend(me.eventType = {}, {
		touchstart: 1,
		touchmove: 1,
		touchend: 1,

		mousedown: 2,
		mousemove: 2,
		mouseup: 2,

		pointerdown: 3,
		pointermove: 3,
		pointerup: 3,

		MSPointerDown: 3,
		MSPointerMove: 3,
		MSPointerUp: 3
	});

	me.extend(me.ease = {}, {
		quadratic: {
			style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
			fn: function (k) {
				return k * ( 2 - k );
			}
		},
		circular: {
			style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',	// Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
			fn: function (k) {
				return Math.sqrt( 1 - ( --k * k ) );
			}
		},
		back: {
			style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
			fn: function (k) {
				var b = 4;
				return ( k = k - 1 ) * k * ( ( b + 1 ) * k + b ) + 1;
			}
		},
		bounce: {
			style: '',
			fn: function (k) {
				if ( ( k /= 1 ) < ( 1 / 2.75 ) ) {
					return 7.5625 * k * k;
				} else if ( k < ( 2 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
				} else if ( k < ( 2.5 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
				} else {
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
				}
			}
		},
		elastic: {
			style: '',
			fn: function (k) {
				var f = 0.22,
					e = 0.4;

				if ( k === 0 ) { return 0; }
				if ( k == 1 ) { return 1; }

				return ( e * Math.pow( 2, - 10 * k ) * Math.sin( ( k - f / 4 ) * ( 2 * Math.PI ) / f ) + 1 );
			}
		}
	});

	me.tap = function (e, eventName) {
		var ev = document.createEvent('Event');
		ev.initEvent(eventName, true, true);
		ev.pageX = e.pageX;
		ev.pageY = e.pageY;
		e.target.dispatchEvent(ev);
	};

	me.click = function (e) {
		var target = e.target,
			ev;

		if ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) {
			ev = document.createEvent('MouseEvents');
			ev.initMouseEvent('click', true, true, e.view, 1,
				target.screenX, target.screenY, target.clientX, target.clientY,
				e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
				0, null);

			ev._constructed = true;
			target.dispatchEvent(ev);
		}
	};

	return me;
})();
function IScroll (el, options) {
	this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
	this.scroller = this.wrapper.children[0];
	this.scrollerStyle = this.scroller.style;		// cache style for better performance

	this.options = {

		resizeScrollbars: true,

		mouseWheelSpeed: 20,

		snapThreshold: 0.334,

// INSERT POINT: OPTIONS
		disablePointer : !utils.hasPointer,
		disableTouch : utils.hasPointer || !utils.hasTouch,
		disableMouse : utils.hasPointer || utils.hasTouch,
		startX: 0,
		startY: 0,
		scrollY: true,
		directionLockThreshold: 5,
		momentum: true,

		bounce: true,
		bounceTime: 600,
		bounceEasing: '',

		preventDefault: true,
		preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

		HWCompositing: true,
		useTransition: true,
		useTransform: true,
		bindToWrapper: typeof window.onmousedown === "undefined"
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	// Normalize options
	this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

	this.options.useTransition = utils.hasTransition && this.options.useTransition;
	this.options.useTransform = utils.hasTransform && this.options.useTransform;

	this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
	this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

	// If you want eventPassthrough I have to lock one of the axes
	this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
	this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

	// With eventPassthrough we also need lockDirection mechanism
	this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
	this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

	this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

	this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

	if ( this.options.tap === true ) {
		this.options.tap = 'tap';
	}

	if ( this.options.shrinkScrollbars == 'scale' ) {
		this.options.useTransition = false;
	}

	this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

// INSERT POINT: NORMALIZATION

	// Some defaults
	this.x = 0;
	this.y = 0;
	this.directionX = 0;
	this.directionY = 0;
	this._events = {};

// INSERT POINT: DEFAULTS

	this._init();
	this.refresh();

	this.scrollTo(this.options.startX, this.options.startY);
	this.enable();
}

IScroll.prototype = {
	version: '5.2.0',

	_init: function () {
		this._initEvents();

		if ( this.options.scrollbars || this.options.indicators ) {
			this._initIndicators();
		}

		if ( this.options.mouseWheel ) {
			this._initWheel();
		}

		if ( this.options.snap ) {
			this._initSnap();
		}

		if ( this.options.keyBindings ) {
			this._initKeys();
		}

// INSERT POINT: _init

	},

	destroy: function () {
		this._initEvents(true);
		clearTimeout(this.resizeTimeout);
 		this.resizeTimeout = null;
		this._execEvent('destroy');
	},

	_transitionEnd: function (e) {
		if ( e.target != this.scroller || !this.isInTransition ) {
			return;
		}

		this._transitionTime();
		if ( !this.resetPosition(this.options.bounceTime) ) {
			this.isInTransition = false;
			this._execEvent('scrollEnd');
		}
	},

	_start: function (e) {
		// React to left mouse button only
		if ( utils.eventType[e.type] != 1 ) {
		  // for button property
		  // http://unixpapa.com/js/mouse.html
		  var button;
	    if (!e.which) {
	      /* IE case */
	      button = (e.button < 2) ? 0 :
	               ((e.button == 4) ? 1 : 2);
	    } else {
	      /* All others */
	      button = e.button;
	    }
			if ( button !== 0 ) {
				return;
			}
		}

		if ( !this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated) ) {
			return;
		}

		if ( this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.touches ? e.touches[0] : e,
			pos;

		this.initiated	= utils.eventType[e.type];
		this.moved		= false;
		this.distX		= 0;
		this.distY		= 0;
		this.directionX = 0;
		this.directionY = 0;
		this.directionLocked = 0;

		this.startTime = utils.getTime();

		if ( this.options.useTransition && this.isInTransition ) {
			this._transitionTime();
			this.isInTransition = false;
			pos = this.getComputedPosition();
			this._translate(Math.round(pos.x), Math.round(pos.y));
			this._execEvent('scrollEnd');
		} else if ( !this.options.useTransition && this.isAnimating ) {
			this.isAnimating = false;
			this._execEvent('scrollEnd');
		}

		this.startX    = this.x;
		this.startY    = this.y;
		this.absStartX = this.x;
		this.absStartY = this.y;
		this.pointX    = point.pageX;
		this.pointY    = point.pageY;

		this._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault ) {	// increases performance on Android? TODO: check!
			e.preventDefault();
		}

		var point		= e.touches ? e.touches[0] : e,
			deltaX		= point.pageX - this.pointX,
			deltaY		= point.pageY - this.pointY,
			timestamp	= utils.getTime(),
			newX, newY,
			absDistX, absDistY;

		this.pointX		= point.pageX;
		this.pointY		= point.pageY;

		this.distX		+= deltaX;
		this.distY		+= deltaY;
		absDistX		= Math.abs(this.distX);
		absDistY		= Math.abs(this.distY);

		// We need to move at least 10 pixels for the scrolling to initiate
		if ( timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10) ) {
			return;
		}

		// If you are scrolling in one direction lock the other
		if ( !this.directionLocked && !this.options.freeScroll ) {
			if ( absDistX > absDistY + this.options.directionLockThreshold ) {
				this.directionLocked = 'h';		// lock horizontally
			} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {
				this.directionLocked = 'v';		// lock vertically
			} else {
				this.directionLocked = 'n';		// no lock
			}
		}

		if ( this.directionLocked == 'h' ) {
			if ( this.options.eventPassthrough == 'vertical' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'horizontal' ) {
				this.initiated = false;
				return;
			}

			deltaY = 0;
		} else if ( this.directionLocked == 'v' ) {
			if ( this.options.eventPassthrough == 'horizontal' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'vertical' ) {
				this.initiated = false;
				return;
			}

			deltaX = 0;
		}

		deltaX = this.hasHorizontalScroll ? deltaX : 0;
		deltaY = this.hasVerticalScroll ? deltaY : 0;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		// Slow down if outside of the boundaries
		if ( newX > 0 || newX < this.maxScrollX ) {
			newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
		}
		if ( newY > 0 || newY < this.maxScrollY ) {
			newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
		}

		this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if ( !this.moved ) {
			this._execEvent('scrollStart');
		}

		this.moved = true;

		this._translate(newX, newY);

/* REPLACE START: _move */

		if ( timestamp - this.startTime > 300 ) {
			this.startTime = timestamp;
			this.startX = this.x;
			this.startY = this.y;
		}

/* REPLACE END: _move */

	},

	_end: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.changedTouches ? e.changedTouches[0] : e,
			momentumX,
			momentumY,
			duration = utils.getTime() - this.startTime,
			newX = Math.round(this.x),
			newY = Math.round(this.y),
			distanceX = Math.abs(newX - this.startX),
			distanceY = Math.abs(newY - this.startY),
			time = 0,
			easing = '';

		this.isInTransition = 0;
		this.initiated = 0;
		this.endTime = utils.getTime();

		// reset if we are outside of the boundaries
		if ( this.resetPosition(this.options.bounceTime) ) {
			return;
		}

		this.scrollTo(newX, newY);	// ensures that the last position is rounded

		// we scrolled less than 10 pixels
		if ( !this.moved ) {
			if ( this.options.tap ) {
				utils.tap(e, this.options.tap);
			}

			if ( this.options.click ) {
				utils.click(e);
			}

			this._execEvent('scrollCancel');
			return;
		}

		if ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {
			this._execEvent('flick');
			return;
		}

		// start momentum animation if needed
		if ( this.options.momentum && duration < 300 ) {
			momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
			momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
			newX = momentumX.destination;
			newY = momentumY.destination;
			time = Math.max(momentumX.duration, momentumY.duration);
			this.isInTransition = 1;
		}


		if ( this.options.snap ) {
			var snap = this._nearestSnap(newX, newY);
			this.currentPage = snap;
			time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(newX - snap.x), 1000),
						Math.min(Math.abs(newY - snap.y), 1000)
					), 300);
			newX = snap.x;
			newY = snap.y;

			this.directionX = 0;
			this.directionY = 0;
			easing = this.options.bounceEasing;
		}

// INSERT POINT: _end

		if ( newX != this.x || newY != this.y ) {
			// change easing function when scroller goes out of the boundaries
			if ( newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY ) {
				easing = utils.ease.quadratic;
			}

			this.scrollTo(newX, newY, time, easing);
			return;
		}

		this._execEvent('scrollEnd');
	},

	_resize: function () {
		var that = this;

		clearTimeout(this.resizeTimeout);

		this.resizeTimeout = setTimeout(function () {
			that.refresh();
		}, this.options.resizePolling);
	},

	resetPosition: function (time) {
		var x = this.x,
			y = this.y;

		time = time || 0;

		if ( !this.hasHorizontalScroll || this.x > 0 ) {
			x = 0;
		} else if ( this.x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( !this.hasVerticalScroll || this.y > 0 ) {
			y = 0;
		} else if ( this.y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		if ( x == this.x && y == this.y ) {
			return false;
		}

		this.scrollTo(x, y, time, this.options.bounceEasing);

		return true;
	},

	disable: function () {
		this.enabled = false;
	},

	enable: function () {
		this.enabled = true;
	},

	refresh: function () {
		var rf = this.wrapper.offsetHeight;		// Force reflow

		this.wrapperWidth	= this.wrapper.clientWidth;
		this.wrapperHeight	= this.wrapper.clientHeight;

/* REPLACE START: refresh */

		this.scrollerWidth	= this.scroller.offsetWidth;
		this.scrollerHeight	= this.scroller.offsetHeight;

		this.maxScrollX		= this.wrapperWidth - this.scrollerWidth;
		this.maxScrollY		= this.wrapperHeight - this.scrollerHeight;

/* REPLACE END: refresh */

		this.hasHorizontalScroll	= this.options.scrollX && this.maxScrollX < 0;
		this.hasVerticalScroll		= this.options.scrollY && this.maxScrollY < 0;

		if ( !this.hasHorizontalScroll ) {
			this.maxScrollX = 0;
			this.scrollerWidth = this.wrapperWidth;
		}

		if ( !this.hasVerticalScroll ) {
			this.maxScrollY = 0;
			this.scrollerHeight = this.wrapperHeight;
		}

		this.endTime = 0;
		this.directionX = 0;
		this.directionY = 0;

		this.wrapperOffset = utils.offset(this.wrapper);

		this._execEvent('refresh');

		this.resetPosition();

// INSERT POINT: _refresh

	},

	on: function (type, fn) {
		if ( !this._events[type] ) {
			this._events[type] = [];
		}

		this._events[type].push(fn);
	},

	off: function (type, fn) {
		if ( !this._events[type] ) {
			return;
		}

		var index = this._events[type].indexOf(fn);

		if ( index > -1 ) {
			this._events[type].splice(index, 1);
		}
	},

	_execEvent: function (type) {
		if ( !this._events[type] ) {
			return;
		}

		var i = 0,
			l = this._events[type].length;

		if ( !l ) {
			return;
		}

		for ( ; i < l; i++ ) {
			this._events[type][i].apply(this, [].slice.call(arguments, 1));
		}
	},

	scrollBy: function (x, y, time, easing) {
		x = this.x + x;
		y = this.y + y;
		time = time || 0;

		this.scrollTo(x, y, time, easing);
	},

	scrollTo: function (x, y, time, easing) {
		easing = easing || utils.ease.circular;

		this.isInTransition = this.options.useTransition && time > 0;
		var transitionType = this.options.useTransition && easing.style;
		if ( !time || transitionType ) {
				if(transitionType) {
					this._transitionTimingFunction(easing.style);
					this._transitionTime(time);
				}
			this._translate(x, y);
		} else {
			this._animate(x, y, time, easing.fn);
		}
	},

	scrollToElement: function (el, time, offsetX, offsetY, easing) {
		el = el.nodeType ? el : this.scroller.querySelector(el);

		if ( !el ) {
			return;
		}

		var pos = utils.offset(el);

		pos.left -= this.wrapperOffset.left;
		pos.top  -= this.wrapperOffset.top;

		// if offsetX/Y are true we center the element to the screen
		if ( offsetX === true ) {
			offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
		}
		if ( offsetY === true ) {
			offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
		}

		pos.left -= offsetX || 0;
		pos.top  -= offsetY || 0;

		pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
		pos.top  = pos.top  > 0 ? 0 : pos.top  < this.maxScrollY ? this.maxScrollY : pos.top;

		time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x-pos.left), Math.abs(this.y-pos.top)) : time;

		this.scrollTo(pos.left, pos.top, time, easing);
	},

	_transitionTime: function (time) {
		time = time || 0;

		var durationProp = utils.style.transitionDuration;
		this.scrollerStyle[durationProp] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.scrollerStyle[durationProp] = '0.0001ms';
			// remove 0.0001ms
			var self = this;
			rAF(function() {
				if(self.scrollerStyle[durationProp] === '0.0001ms') {
					self.scrollerStyle[durationProp] = '0s';
				}
			});
		}


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTime(time);
			}
		}


// INSERT POINT: _transitionTime

	},

	_transitionTimingFunction: function (easing) {
		this.scrollerStyle[utils.style.transitionTimingFunction] = easing;


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTimingFunction(easing);
			}
		}


// INSERT POINT: _transitionTimingFunction

	},

	_translate: function (x, y) {
		if ( this.options.useTransform ) {

/* REPLACE START: _translate */

			this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

/* REPLACE END: _translate */

		} else {
			x = Math.round(x);
			y = Math.round(y);
			this.scrollerStyle.left = x + 'px';
			this.scrollerStyle.top = y + 'px';
		}

		this.x = x;
		this.y = y;


	if ( this.indicators ) {
		for ( var i = this.indicators.length; i--; ) {
			this.indicators[i].updatePosition();
		}
	}


// INSERT POINT: _translate

	},

	_initEvents: function (remove) {
		var eventType = remove ? utils.removeEvent : utils.addEvent,
			target = this.options.bindToWrapper ? this.wrapper : window;

		eventType(window, 'orientationchange', this);
		eventType(window, 'resize', this);

		if ( this.options.click ) {
			eventType(this.wrapper, 'click', this, true);
		}

		if ( !this.options.disableMouse ) {
			eventType(this.wrapper, 'mousedown', this);
			eventType(target, 'mousemove', this);
			eventType(target, 'mousecancel', this);
			eventType(target, 'mouseup', this);
		}

		if ( utils.hasPointer && !this.options.disablePointer ) {
			eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
			eventType(target, utils.prefixPointerEvent('pointermove'), this);
			eventType(target, utils.prefixPointerEvent('pointercancel'), this);
			eventType(target, utils.prefixPointerEvent('pointerup'), this);
		}

		if ( utils.hasTouch && !this.options.disableTouch ) {
			eventType(this.wrapper, 'touchstart', this);
			eventType(target, 'touchmove', this);
			eventType(target, 'touchcancel', this);
			eventType(target, 'touchend', this);
		}

		eventType(this.scroller, 'transitionend', this);
		eventType(this.scroller, 'webkitTransitionEnd', this);
		eventType(this.scroller, 'oTransitionEnd', this);
		eventType(this.scroller, 'MSTransitionEnd', this);
	},

	getComputedPosition: function () {
		var matrix = window.getComputedStyle(this.scroller, null),
			x, y;

		if ( this.options.useTransform ) {
			matrix = matrix[utils.style.transform].split(')')[0].split(', ');
			x = +(matrix[12] || matrix[4]);
			y = +(matrix[13] || matrix[5]);
		} else {
			x = +matrix.left.replace(/[^-\d.]/g, '');
			y = +matrix.top.replace(/[^-\d.]/g, '');
		}

		return { x: x, y: y };
	},
	_initIndicators: function () {
		var interactive = this.options.interactiveScrollbars,
			customStyle = typeof this.options.scrollbars != 'string',
			indicators = [],
			indicator;

		var that = this;

		this.indicators = [];

		if ( this.options.scrollbars ) {
			// Vertical scrollbar
			if ( this.options.scrollY ) {
				indicator = {
					el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenX: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}

			// Horizontal scrollbar
			if ( this.options.scrollX ) {
				indicator = {
					el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenY: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}
		}

		if ( this.options.indicators ) {
			// TODO: check concat compatibility
			indicators = indicators.concat(this.options.indicators);
		}

		for ( var i = indicators.length; i--; ) {
			this.indicators.push( new Indicator(this, indicators[i]) );
		}

		// TODO: check if we can use array.map (wide compatibility and performance issues)
		function _indicatorsMap (fn) {
			if (that.indicators) {
				for ( var i = that.indicators.length; i--; ) {
					fn.call(that.indicators[i]);
				}
			}
		}

		if ( this.options.fadeScrollbars ) {
			this.on('scrollEnd', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollCancel', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1);
				});
			});

			this.on('beforeScrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1, true);
				});
			});
		}


		this.on('refresh', function () {
			_indicatorsMap(function () {
				this.refresh();
			});
		});

		this.on('destroy', function () {
			_indicatorsMap(function () {
				this.destroy();
			});

			delete this.indicators;
		});
	},

	_initWheel: function () {
		utils.addEvent(this.wrapper, 'wheel', this);
		utils.addEvent(this.wrapper, 'mousewheel', this);
		utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

		this.on('destroy', function () {
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = null;
			utils.removeEvent(this.wrapper, 'wheel', this);
			utils.removeEvent(this.wrapper, 'mousewheel', this);
			utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
		});
	},

	_wheel: function (e) {
		if ( !this.enabled ) {
			return;
		}

		e.preventDefault();

		var wheelDeltaX, wheelDeltaY,
			newX, newY,
			that = this;

		if ( this.wheelTimeout === undefined ) {
			that._execEvent('scrollStart');
		}

		// Execute the scrollEnd event after 400ms the wheel stopped scrolling
		clearTimeout(this.wheelTimeout);
		this.wheelTimeout = setTimeout(function () {
			if(!that.options.snap) {
				that._execEvent('scrollEnd');
			}
			that.wheelTimeout = undefined;
		}, 400);

		if ( 'deltaX' in e ) {
			if (e.deltaMode === 1) {
				wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
				wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
			} else {
				wheelDeltaX = -e.deltaX;
				wheelDeltaY = -e.deltaY;
			}
		} else if ( 'wheelDeltaX' in e ) {
			wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
			wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
		} else if ( 'wheelDelta' in e ) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
		} else if ( 'detail' in e ) {
			wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
		} else {
			return;
		}

		wheelDeltaX *= this.options.invertWheelDirection;
		wheelDeltaY *= this.options.invertWheelDirection;

		if ( !this.hasVerticalScroll ) {
			wheelDeltaX = wheelDeltaY;
			wheelDeltaY = 0;
		}

		if ( this.options.snap ) {
			newX = this.currentPage.pageX;
			newY = this.currentPage.pageY;

			if ( wheelDeltaX > 0 ) {
				newX--;
			} else if ( wheelDeltaX < 0 ) {
				newX++;
			}

			if ( wheelDeltaY > 0 ) {
				newY--;
			} else if ( wheelDeltaY < 0 ) {
				newY++;
			}

			this.goToPage(newX, newY);

			return;
		}

		newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
		newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

		this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
		this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;

		if ( newX > 0 ) {
			newX = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
		}

		if ( newY > 0 ) {
			newY = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
		}

		this.scrollTo(newX, newY, 0);

// INSERT POINT: _wheel
	},

	_initSnap: function () {
		this.currentPage = {};

		if ( typeof this.options.snap == 'string' ) {
			this.options.snap = this.scroller.querySelectorAll(this.options.snap);
		}

		this.on('refresh', function () {
			var i = 0, l,
				m = 0, n,
				cx, cy,
				x = 0, y,
				stepX = this.options.snapStepX || this.wrapperWidth,
				stepY = this.options.snapStepY || this.wrapperHeight,
				el;

			this.pages = [];

			if ( !this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight ) {
				return;
			}

			if ( this.options.snap === true ) {
				cx = Math.round( stepX / 2 );
				cy = Math.round( stepY / 2 );

				while ( x > -this.scrollerWidth ) {
					this.pages[i] = [];
					l = 0;
					y = 0;

					while ( y > -this.scrollerHeight ) {
						this.pages[i][l] = {
							x: Math.max(x, this.maxScrollX),
							y: Math.max(y, this.maxScrollY),
							width: stepX,
							height: stepY,
							cx: x - cx,
							cy: y - cy
						};

						y -= stepY;
						l++;
					}

					x -= stepX;
					i++;
				}
			} else {
				el = this.options.snap;
				l = el.length;
				n = -1;

				for ( ; i < l; i++ ) {
					if ( i === 0 || el[i].offsetLeft <= el[i-1].offsetLeft ) {
						m = 0;
						n++;
					}

					if ( !this.pages[m] ) {
						this.pages[m] = [];
					}

					x = Math.max(-el[i].offsetLeft, this.maxScrollX);
					y = Math.max(-el[i].offsetTop, this.maxScrollY);
					cx = x - Math.round(el[i].offsetWidth / 2);
					cy = y - Math.round(el[i].offsetHeight / 2);

					this.pages[m][n] = {
						x: x,
						y: y,
						width: el[i].offsetWidth,
						height: el[i].offsetHeight,
						cx: cx,
						cy: cy
					};

					if ( x > this.maxScrollX ) {
						m++;
					}
				}
			}

			this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

			// Update snap threshold if needed
			if ( this.options.snapThreshold % 1 === 0 ) {
				this.snapThresholdX = this.options.snapThreshold;
				this.snapThresholdY = this.options.snapThreshold;
			} else {
				this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
				this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
			}
		});

		this.on('flick', function () {
			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.x - this.startX), 1000),
						Math.min(Math.abs(this.y - this.startY), 1000)
					), 300);

			this.goToPage(
				this.currentPage.pageX + this.directionX,
				this.currentPage.pageY + this.directionY,
				time
			);
		});
	},

	_nearestSnap: function (x, y) {
		if ( !this.pages.length ) {
			return { x: 0, y: 0, pageX: 0, pageY: 0 };
		}

		var i = 0,
			l = this.pages.length,
			m = 0;

		// Check if we exceeded the snap threshold
		if ( Math.abs(x - this.absStartX) < this.snapThresholdX &&
			Math.abs(y - this.absStartY) < this.snapThresholdY ) {
			return this.currentPage;
		}

		if ( x > 0 ) {
			x = 0;
		} else if ( x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( y > 0 ) {
			y = 0;
		} else if ( y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		for ( ; i < l; i++ ) {
			if ( x >= this.pages[i][0].cx ) {
				x = this.pages[i][0].x;
				break;
			}
		}

		l = this.pages[i].length;

		for ( ; m < l; m++ ) {
			if ( y >= this.pages[0][m].cy ) {
				y = this.pages[0][m].y;
				break;
			}
		}

		if ( i == this.currentPage.pageX ) {
			i += this.directionX;

			if ( i < 0 ) {
				i = 0;
			} else if ( i >= this.pages.length ) {
				i = this.pages.length - 1;
			}

			x = this.pages[i][0].x;
		}

		if ( m == this.currentPage.pageY ) {
			m += this.directionY;

			if ( m < 0 ) {
				m = 0;
			} else if ( m >= this.pages[0].length ) {
				m = this.pages[0].length - 1;
			}

			y = this.pages[0][m].y;
		}

		return {
			x: x,
			y: y,
			pageX: i,
			pageY: m
		};
	},

	goToPage: function (x, y, time, easing) {
		easing = easing || this.options.bounceEasing;

		if ( x >= this.pages.length ) {
			x = this.pages.length - 1;
		} else if ( x < 0 ) {
			x = 0;
		}

		if ( y >= this.pages[x].length ) {
			y = this.pages[x].length - 1;
		} else if ( y < 0 ) {
			y = 0;
		}

		var posX = this.pages[x][y].x,
			posY = this.pages[x][y].y;

		time = time === undefined ? this.options.snapSpeed || Math.max(
			Math.max(
				Math.min(Math.abs(posX - this.x), 1000),
				Math.min(Math.abs(posY - this.y), 1000)
			), 300) : time;

		this.currentPage = {
			x: posX,
			y: posY,
			pageX: x,
			pageY: y
		};

		this.scrollTo(posX, posY, time, easing);
	},

	next: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x++;

		if ( x >= this.pages.length && this.hasVerticalScroll ) {
			x = 0;
			y++;
		}

		this.goToPage(x, y, time, easing);
	},

	prev: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x--;

		if ( x < 0 && this.hasVerticalScroll ) {
			x = 0;
			y--;
		}

		this.goToPage(x, y, time, easing);
	},

	_initKeys: function (e) {
		// default key bindings
		var keys = {
			pageUp: 33,
			pageDown: 34,
			end: 35,
			home: 36,
			left: 37,
			up: 38,
			right: 39,
			down: 40
		};
		var i;

		// if you give me characters I give you keycode
		if ( typeof this.options.keyBindings == 'object' ) {
			for ( i in this.options.keyBindings ) {
				if ( typeof this.options.keyBindings[i] == 'string' ) {
					this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
				}
			}
		} else {
			this.options.keyBindings = {};
		}

		for ( i in keys ) {
			this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
		}

		utils.addEvent(window, 'keydown', this);

		this.on('destroy', function () {
			utils.removeEvent(window, 'keydown', this);
		});
	},

	_key: function (e) {
		if ( !this.enabled ) {
			return;
		}

		var snap = this.options.snap,	// we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			newY = snap ? this.currentPage.pageY : this.y,
			now = utils.getTime(),
			prevTime = this.keyTime || 0,
			acceleration = 0.250,
			pos;

		if ( this.options.useTransition && this.isInTransition ) {
			pos = this.getComputedPosition();

			this._translate(Math.round(pos.x), Math.round(pos.y));
			this.isInTransition = false;
		}

		this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

		switch ( e.keyCode ) {
			case this.options.keyBindings.pageUp:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX += snap ? 1 : this.wrapperWidth;
				} else {
					newY += snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.pageDown:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX -= snap ? 1 : this.wrapperWidth;
				} else {
					newY -= snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.end:
				newX = snap ? this.pages.length-1 : this.maxScrollX;
				newY = snap ? this.pages[0].length-1 : this.maxScrollY;
				break;
			case this.options.keyBindings.home:
				newX = 0;
				newY = 0;
				break;
			case this.options.keyBindings.left:
				newX += snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.up:
				newY += snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.right:
				newX -= snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.down:
				newY -= snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			default:
				return;
		}

		if ( snap ) {
			this.goToPage(newX, newY);
			return;
		}

		if ( newX > 0 ) {
			newX = 0;
			this.keyAcceleration = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
			this.keyAcceleration = 0;
		}

		if ( newY > 0 ) {
			newY = 0;
			this.keyAcceleration = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
			this.keyAcceleration = 0;
		}

		this.scrollTo(newX, newY, 0);

		this.keyTime = now;
	},

	_animate: function (destX, destY, duration, easingFn) {
		var that = this,
			startX = this.x,
			startY = this.y,
			startTime = utils.getTime(),
			destTime = startTime + duration;

		function step () {
			var now = utils.getTime(),
				newX, newY,
				easing;

			if ( now >= destTime ) {
				that.isAnimating = false;
				that._translate(destX, destY);

				if ( !that.resetPosition(that.options.bounceTime) ) {
					that._execEvent('scrollEnd');
				}

				return;
			}

			now = ( now - startTime ) / duration;
			easing = easingFn(now);
			newX = ( destX - startX ) * easing + startX;
			newY = ( destY - startY ) * easing + startY;
			that._translate(newX, newY);

			if ( that.isAnimating ) {
				rAF(step);
			}
		}

		this.isAnimating = true;
		step();
	},
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
			case 'orientationchange':
			case 'resize':
				this._resize();
				break;
			case 'transitionend':
			case 'webkitTransitionEnd':
			case 'oTransitionEnd':
			case 'MSTransitionEnd':
				this._transitionEnd(e);
				break;
			case 'wheel':
			case 'DOMMouseScroll':
			case 'mousewheel':
				this._wheel(e);
				break;
			case 'keydown':
				this._key(e);
				break;
			case 'click':
				if ( this.enabled && !e._constructed ) {
					e.preventDefault();
					e.stopPropagation();
				}
				break;
		}
	}
};
function createDefaultScrollbar (direction, interactive, type) {
	var scrollbar = document.createElement('div'),
		indicator = document.createElement('div');

	if ( type === true ) {
		scrollbar.style.cssText = 'position:absolute;z-index:9999';
		indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
	}

	indicator.className = 'iScrollIndicator';

	if ( direction == 'h' ) {
		if ( type === true ) {
			scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
			indicator.style.height = '100%';
		}
		scrollbar.className = 'iScrollHorizontalScrollbar';
	} else {
		if ( type === true ) {
			scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
			indicator.style.width = '100%';
		}
		scrollbar.className = 'iScrollVerticalScrollbar';
	}

	scrollbar.style.cssText += ';overflow:hidden';

	if ( !interactive ) {
		scrollbar.style.pointerEvents = 'none';
	}

	scrollbar.appendChild(indicator);

	return scrollbar;
}

function Indicator (scroller, options) {
	this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
	this.wrapperStyle = this.wrapper.style;
	this.indicator = this.wrapper.children[0];
	this.indicatorStyle = this.indicator.style;
	this.scroller = scroller;

	this.options = {
		listenX: true,
		listenY: true,
		interactive: false,
		resize: true,
		defaultScrollbars: false,
		shrink: false,
		fade: false,
		speedRatioX: 0,
		speedRatioY: 0
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	this.sizeRatioX = 1;
	this.sizeRatioY = 1;
	this.maxPosX = 0;
	this.maxPosY = 0;

	if ( this.options.interactive ) {
		if ( !this.options.disableTouch ) {
			utils.addEvent(this.indicator, 'touchstart', this);
			utils.addEvent(window, 'touchend', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
			utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(this.indicator, 'mousedown', this);
			utils.addEvent(window, 'mouseup', this);
		}
	}

	if ( this.options.fade ) {
		this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
		var durationProp = utils.style.transitionDuration;
		this.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms';
		// remove 0.0001ms
		var self = this;
		if(utils.isBadAndroid) {
			rAF(function() {
				if(self.wrapperStyle[durationProp] === '0.0001ms') {
					self.wrapperStyle[durationProp] = '0s';
				}
			});
		}
		this.wrapperStyle.opacity = '0';
	}
}

Indicator.prototype = {
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
		}
	},

	destroy: function () {
		if ( this.options.fadeScrollbars ) {
			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;
		}
		if ( this.options.interactive ) {
			utils.removeEvent(this.indicator, 'touchstart', this);
			utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
			utils.removeEvent(this.indicator, 'mousedown', this);

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			utils.removeEvent(window, 'touchend', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
			utils.removeEvent(window, 'mouseup', this);
		}

		if ( this.options.defaultScrollbars ) {
			this.wrapper.parentNode.removeChild(this.wrapper);
		}
	},

	_start: function (e) {
		var point = e.touches ? e.touches[0] : e;

		e.preventDefault();
		e.stopPropagation();

		this.transitionTime();

		this.initiated = true;
		this.moved = false;
		this.lastPointX	= point.pageX;
		this.lastPointY	= point.pageY;

		this.startTime	= utils.getTime();

		if ( !this.options.disableTouch ) {
			utils.addEvent(window, 'touchmove', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(window, 'mousemove', this);
		}

		this.scroller._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		var point = e.touches ? e.touches[0] : e,
			deltaX, deltaY,
			newX, newY,
			timestamp = utils.getTime();

		if ( !this.moved ) {
			this.scroller._execEvent('scrollStart');
		}

		this.moved = true;

		deltaX = point.pageX - this.lastPointX;
		this.lastPointX = point.pageX;

		deltaY = point.pageY - this.lastPointY;
		this.lastPointY = point.pageY;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		this._pos(newX, newY);

// INSERT POINT: indicator._move

		e.preventDefault();
		e.stopPropagation();
	},

	_end: function (e) {
		if ( !this.initiated ) {
			return;
		}

		this.initiated = false;

		e.preventDefault();
		e.stopPropagation();

		utils.removeEvent(window, 'touchmove', this);
		utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
		utils.removeEvent(window, 'mousemove', this);

		if ( this.scroller.options.snap ) {
			var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.scroller.x - snap.x), 1000),
						Math.min(Math.abs(this.scroller.y - snap.y), 1000)
					), 300);

			if ( this.scroller.x != snap.x || this.scroller.y != snap.y ) {
				this.scroller.directionX = 0;
				this.scroller.directionY = 0;
				this.scroller.currentPage = snap;
				this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
			}
		}

		if ( this.moved ) {
			this.scroller._execEvent('scrollEnd');
		}
	},

	transitionTime: function (time) {
		time = time || 0;
		var durationProp = utils.style.transitionDuration;
		this.indicatorStyle[durationProp] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.indicatorStyle[durationProp] = '0.0001ms';
			// remove 0.0001ms
			var self = this;
			rAF(function() {
				if(self.indicatorStyle[durationProp] === '0.0001ms') {
					self.indicatorStyle[durationProp] = '0s';
				}
			});
		}
	},

	transitionTimingFunction: function (easing) {
		this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
	},

	refresh: function () {
		this.transitionTime();

		if ( this.options.listenX && !this.options.listenY ) {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
		} else if ( this.options.listenY && !this.options.listenX ) {
			this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
		} else {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
		}

		if ( this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ) {
			utils.addClass(this.wrapper, 'iScrollBothScrollbars');
			utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '8px';
				} else {
					this.wrapper.style.bottom = '8px';
				}
			}
		} else {
			utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
			utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '2px';
				} else {
					this.wrapper.style.bottom = '2px';
				}
			}
		}

		var r = this.wrapper.offsetHeight;	// force refresh

		if ( this.options.listenX ) {
			this.wrapperWidth = this.wrapper.clientWidth;
			if ( this.options.resize ) {
				this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
				this.indicatorStyle.width = this.indicatorWidth + 'px';
			} else {
				this.indicatorWidth = this.indicator.clientWidth;
			}

			this.maxPosX = this.wrapperWidth - this.indicatorWidth;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryX = -this.indicatorWidth + 8;
				this.maxBoundaryX = this.wrapperWidth - 8;
			} else {
				this.minBoundaryX = 0;
				this.maxBoundaryX = this.maxPosX;
			}

			this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));
		}

		if ( this.options.listenY ) {
			this.wrapperHeight = this.wrapper.clientHeight;
			if ( this.options.resize ) {
				this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
				this.indicatorStyle.height = this.indicatorHeight + 'px';
			} else {
				this.indicatorHeight = this.indicator.clientHeight;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryY = -this.indicatorHeight + 8;
				this.maxBoundaryY = this.wrapperHeight - 8;
			} else {
				this.minBoundaryY = 0;
				this.maxBoundaryY = this.maxPosY;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;
			this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
		}

		this.updatePosition();
	},

	updatePosition: function () {
		var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

		if ( !this.options.ignoreBoundaries ) {
			if ( x < this.minBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth + x, 8);
					this.indicatorStyle.width = this.width + 'px';
				}
				x = this.minBoundaryX;
			} else if ( x > this.maxBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
					this.indicatorStyle.width = this.width + 'px';
					x = this.maxPosX + this.indicatorWidth - this.width;
				} else {
					x = this.maxBoundaryX;
				}
			} else if ( this.options.shrink == 'scale' && this.width != this.indicatorWidth ) {
				this.width = this.indicatorWidth;
				this.indicatorStyle.width = this.width + 'px';
			}

			if ( y < this.minBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight + y * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
				}
				y = this.minBoundaryY;
			} else if ( y > this.maxBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
					y = this.maxPosY + this.indicatorHeight - this.height;
				} else {
					y = this.maxBoundaryY;
				}
			} else if ( this.options.shrink == 'scale' && this.height != this.indicatorHeight ) {
				this.height = this.indicatorHeight;
				this.indicatorStyle.height = this.height + 'px';
			}
		}

		this.x = x;
		this.y = y;

		if ( this.scroller.options.useTransform ) {
			this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
		} else {
			this.indicatorStyle.left = x + 'px';
			this.indicatorStyle.top = y + 'px';
		}
	},

	_pos: function (x, y) {
		if ( x < 0 ) {
			x = 0;
		} else if ( x > this.maxPosX ) {
			x = this.maxPosX;
		}

		if ( y < 0 ) {
			y = 0;
		} else if ( y > this.maxPosY ) {
			y = this.maxPosY;
		}

		x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
		y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

		this.scroller.scrollTo(x, y);
	},

	fade: function (val, hold) {
		if ( hold && !this.visible ) {
			return;
		}

		clearTimeout(this.fadeTimeout);
		this.fadeTimeout = null;

		var time = val ? 250 : 500,
			delay = val ? 0 : 300;

		val = val ? '1' : '0';

		this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

		this.fadeTimeout = setTimeout((function (val) {
			this.wrapperStyle.opacity = val;
			this.visible = +val;
		}).bind(this, val), delay);
	}
};

IScroll.utils = utils;

if ( typeof module != 'undefined' && module.exports ) {
	module.exports = IScroll;
} else if ( typeof define == 'function' && define.amd ) {
        define( function () { return IScroll; } );
} else {
	window.IScroll = IScroll;
}

})(window, document, Math);

},{}],8:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":51,"./_hashDelete":52,"./_hashGet":53,"./_hashHas":54,"./_hashSet":55}],9:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":62,"./_listCacheDelete":63,"./_listCacheGet":64,"./_listCacheHas":65,"./_listCacheSet":66}],10:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":47,"./_root":78}],11:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":67,"./_mapCacheDelete":68,"./_mapCacheGet":69,"./_mapCacheHas":70,"./_mapCacheSet":71}],12:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":9,"./_stackClear":82,"./_stackDelete":83,"./_stackGet":84,"./_stackHas":85,"./_stackSet":86}],13:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":78}],14:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":78}],15:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],16:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":33,"./_isIndex":57,"./isArguments":92,"./isArray":93,"./isBuffer":96,"./isTypedArray":103}],17:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":20,"./eq":90}],18:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":20,"./eq":90}],19:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":90}],20:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":44}],21:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":99}],22:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":42}],23:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":13,"./_getRawTag":49,"./_objectToString":75}],24:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":23,"./isObjectLike":100}],25:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":60,"./_toSource":87,"./isFunction":97,"./isObject":99}],26:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":23,"./isLength":98,"./isObjectLike":100}],27:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":61,"./_nativeKeysIn":73,"./isObject":99}],28:[function(require,module,exports){
var Stack = require('./_Stack'),
    assignMergeValue = require('./_assignMergeValue'),
    baseFor = require('./_baseFor'),
    baseMergeDeep = require('./_baseMergeDeep'),
    isObject = require('./isObject'),
    keysIn = require('./keysIn'),
    safeGet = require('./_safeGet');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":12,"./_assignMergeValue":17,"./_baseFor":22,"./_baseMergeDeep":29,"./_safeGet":79,"./isObject":99,"./keysIn":104}],29:[function(require,module,exports){
var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    safeGet = require('./_safeGet'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":17,"./_cloneBuffer":36,"./_cloneTypedArray":37,"./_copyArray":38,"./_initCloneObject":56,"./_safeGet":79,"./isArguments":92,"./isArray":93,"./isArrayLikeObject":95,"./isBuffer":96,"./isFunction":97,"./isObject":99,"./isPlainObject":101,"./isTypedArray":103,"./toPlainObject":112}],30:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;

},{}],31:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":77,"./_setToString":80,"./identity":91}],32:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":44,"./constant":88,"./identity":91}],33:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],34:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],35:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":14}],36:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":78}],37:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":35}],38:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],39:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":18,"./_baseAssignValue":20}],40:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":78}],41:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":31,"./_isIterateeCall":58}],42:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],43:[function(require,module,exports){
var baseRange = require('./_baseRange'),
    isIterateeCall = require('./_isIterateeCall'),
    toFinite = require('./toFinite');

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;

},{"./_baseRange":30,"./_isIterateeCall":58,"./toFinite":110}],44:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":47}],45:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],46:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":59}],47:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":25,"./_getValue":50}],48:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":76}],49:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":13}],50:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],51:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":72}],52:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],53:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":72}],54:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":72}],55:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":72}],56:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":21,"./_getPrototype":48,"./_isPrototype":61}],57:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],58:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":57,"./eq":90,"./isArrayLike":94,"./isObject":99}],59:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],60:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":40}],61:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],62:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],63:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":19}],64:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":19}],65:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":19}],66:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":19}],67:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":8,"./_ListCache":9,"./_Map":10}],68:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":46}],69:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":46}],70:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":46}],71:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":46}],72:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":47}],73:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],74:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":45}],75:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],76:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],77:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":15}],78:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":45}],79:[function(require,module,exports){
/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

},{}],80:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":32,"./_shortOut":81}],81:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],82:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":9}],83:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],84:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],85:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],86:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":9,"./_Map":10,"./_MapCache":11}],87:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],88:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],89:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":99,"./now":106,"./toNumber":111}],90:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],91:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],92:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":24,"./isObjectLike":100}],93:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],94:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":97,"./isLength":98}],95:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":94,"./isObjectLike":100}],96:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":78,"./stubFalse":108}],97:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":23,"./isObject":99}],98:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],99:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],100:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],101:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":23,"./_getPrototype":48,"./isObjectLike":100}],102:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":23,"./isObjectLike":100}],103:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":26,"./_baseUnary":34,"./_nodeUtil":74}],104:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":16,"./_baseKeysIn":27,"./isArrayLike":94}],105:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":28,"./_createAssigner":41}],106:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":78}],107:[function(require,module,exports){
var createRange = require('./_createRange');

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;

},{"./_createRange":43}],108:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],109:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":89,"./isObject":99}],110:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":111}],111:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":99,"./isSymbol":102}],112:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":39,"./keysIn":104}],113:[function(require,module,exports){
"use strict"

var hyperscript = require("./render/hyperscript")

hyperscript.trust = require("./render/trust")
hyperscript.fragment = require("./render/fragment")

module.exports = hyperscript

},{"./render/fragment":116,"./render/hyperscript":117,"./render/trust":119}],114:[function(require,module,exports){
(function (global,setImmediate){
;(function() {
"use strict"
function Vnode(tag, key, attrs0, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
}
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i])
	}
	return children
}
var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty
function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}
function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}
function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text
	var className = attrs.className || attrs.class
	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}
		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key]
			}
		}
		attrs = newAttrs
	}
	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key]
		}
	}
	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined
			attrs.className = className
		}
		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className
		}
	}
	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true
			break
		}
	}
	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children
	} else {
		childList = children
	}
	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}
function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}
	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector)
	}
	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = 1
	}
	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}
	var normalized = Vnode.normalizeChildren(children)
	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}
hyperscript.trust = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}
hyperscript.fragment = function(attrs1, children) {
	return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)
}
var m = hyperscript
/** @constructor */
var PromisePolyfill = function(executor) {
	if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")
	if (typeof executor !== "function") throw new TypeError("executor must be a function")
	var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)
	var instance = self._instance = {resolvers: resolvers, rejectors: rejectors}
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
	function handler(list, shouldAbsorb) {
		return function execute(value) {
			var then
			try {
				if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
					if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
					executeOnce(then.bind(value))
				}
				else {
					callAsync(function() {
						if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)
						for (var i = 0; i < list.length; i++) list[i](value)
						resolvers.length = 0, rejectors.length = 0
						instance.state = shouldAbsorb
						instance.retry = function() {execute(value)}
					})
				}
			}
			catch (e) {
				rejectCurrent(e)
			}
		}
	}
	function executeOnce(then) {
		var runs = 0
		function run(fn) {
			return function(value) {
				if (runs++ > 0) return
				fn(value)
			}
		}
		var onerror = run(rejectCurrent)
		try {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}
	}
	executeOnce(executor)
}
PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
	var self = this, instance = self._instance
	function handle(callback, list, next, state) {
		list.push(function(value) {
			if (typeof callback !== "function") next(value)
			else try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}
		})
		if (typeof instance.retry === "function" && state === instance.state) instance.retry()
	}
	var resolveNext, rejectNext
	var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})
	handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)
	return promise
}
PromisePolyfill.prototype.catch = function(onRejection) {
	return this.then(null, onRejection)
}
PromisePolyfill.resolve = function(value) {
	if (value instanceof PromisePolyfill) return value
	return new PromisePolyfill(function(resolve) {resolve(value)})
}
PromisePolyfill.reject = function(value) {
	return new PromisePolyfill(function(resolve, reject) {reject(value)})
}
PromisePolyfill.all = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		var total = list.length, count = 0, values = []
		if (list.length === 0) resolve([])
		else for (var i = 0; i < list.length; i++) {
			(function(i) {
				function consume(value) {
					count++
					values[i] = value
					if (count === total) resolve(values)
				}
				if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
					list[i].then(consume, reject)
				}
				else consume(list[i])
			})(i)
		}
	})
}
PromisePolyfill.race = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		for (var i = 0; i < list.length; i++) {
			list[i].then(resolve, reject)
		}
	})
}
if (typeof window !== "undefined") {
	if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill
	var PromisePolyfill = window.Promise
} else if (typeof global !== "undefined") {
	if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill
	var PromisePolyfill = global.Promise
} else {
}
var buildQueryString = function(object) {
	if (Object.prototype.toString.call(object) !== "[object Object]") return ""
	var args = []
	for (var key0 in object) {
		destructure(key0, object[key0])
	}
	return args.join("&")
	function destructure(key0, value) {
		if (Array.isArray(value)) {
			for (var i = 0; i < value.length; i++) {
				destructure(key0 + "[" + i + "]", value[i])
			}
		}
		else if (Object.prototype.toString.call(value) === "[object Object]") {
			for (var i in value) {
				destructure(key0 + "[" + i + "]", value[i])
			}
		}
		else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))
	}
}
var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")
var _8 = function($window, Promise) {
	var callbackCount = 0
	var oncompletion
	function setCompletionCallback(callback) {oncompletion = callback}
	function finalizer() {
		var count = 0
		function complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}
		return function finalize(promise0) {
			var then0 = promise0.then
			promise0.then = function() {
				count++
				var next = then0.apply(promise0, arguments)
				next.then(complete, function(e) {
					complete()
					if (count === 0) throw e
				})
				return finalize(next)
			}
			return promise0
		}
	}
	function normalize(args, extra) {
		if (typeof args === "string") {
			var url = args
			args = extra || {}
			if (args.url == null) args.url = url
		}
		return args
	}
	function request(args, extra) {
		var finalize = finalizer()
		args = normalize(args, extra)
		var promise0 = new Promise(function(resolve, reject) {
			if (args.method == null) args.method = "GET"
			args.method = args.method.toUpperCase()
			var useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)
			if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify
			if (typeof args.deserialize !== "function") args.deserialize = deserialize
			if (typeof args.extract !== "function") args.extract = extract
			args.url = interpolate(args.url, args.data)
			if (useBody) args.data = args.serialize(args.data)
			else args.url = assemble(args.url, args.data)
			var xhr = new $window.XMLHttpRequest(),
				aborted = false,
				_abort = xhr.abort
			xhr.abort = function abort() {
				aborted = true
				_abort.call(xhr)
			}
			xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)
			if (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty("Content-Type"))) {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
			}
			if (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty("Accept"))) {
				xhr.setRequestHeader("Accept", "application/json, text/*")
			}
			if (args.withCredentials) xhr.withCredentials = args.withCredentials
			for (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {
				xhr.setRequestHeader(key, args.headers[key])
			}
			if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr
			xhr.onreadystatechange = function() {
				// Don't throw errors on xhr.abort().
				if(aborted) return
				if (xhr.readyState === 4) {
					try {
						var response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))
						if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
							resolve(cast(args.type, response))
						}
						else {
							var error = new Error(xhr.responseText)
							for (var key in response) error[key] = response[key]
							reject(error)
						}
					}
					catch (e) {
						reject(e)
					}
				}
			}
			if (useBody && (args.data != null)) xhr.send(args.data)
			else xhr.send()
		})
		return args.background === true ? promise0 : finalize(promise0)
	}
	function jsonp(args, extra) {
		var finalize = finalizer()
		args = normalize(args, extra)
		var promise0 = new Promise(function(resolve, reject) {
			var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++
			var script = $window.document.createElement("script")
			$window[callbackName] = function(data) {
				script.parentNode.removeChild(script)
				resolve(cast(args.type, data))
				delete $window[callbackName]
			}
			script.onerror = function() {
				script.parentNode.removeChild(script)
				reject(new Error("JSONP request failed"))
				delete $window[callbackName]
			}
			if (args.data == null) args.data = {}
			args.url = interpolate(args.url, args.data)
			args.data[args.callbackKey || "callback"] = callbackName
			script.src = assemble(args.url, args.data)
			$window.document.documentElement.appendChild(script)
		})
		return args.background === true? promise0 : finalize(promise0)
	}
	function interpolate(url, data) {
		if (data == null) return url
		var tokens = url.match(/:[^\/]+/gi) || []
		for (var i = 0; i < tokens.length; i++) {
			var key = tokens[i].slice(1)
			if (data[key] != null) {
				url = url.replace(tokens[i], data[key])
			}
		}
		return url
	}
	function assemble(url, data) {
		var querystring = buildQueryString(data)
		if (querystring !== "") {
			var prefix = url.indexOf("?") < 0 ? "?" : "&"
			url += prefix + querystring
		}
		return url
	}
	function deserialize(data) {
		try {return data !== "" ? JSON.parse(data) : null}
		catch (e) {throw new Error(data)}
	}
	function extract(xhr) {return xhr.responseText}
	function cast(type0, data) {
		if (typeof type0 === "function") {
			if (Array.isArray(data)) {
				for (var i = 0; i < data.length; i++) {
					data[i] = new type0(data[i])
				}
			}
			else return new type0(data)
		}
		return data
	}
	return {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}
}
var requestService = _8(window, PromisePolyfill)
var coreRenderer = function($window) {
	var $doc = $window.document
	var $emptyFragment = $doc.createDocumentFragment()
	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}
	var onevent
	function setEventCallback(callback) {return onevent = callback}
	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}
	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match1 = vnode.children.match(/^\s*?<(\w+)/im) || []
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"
		var temp = $doc.createElement(parent1)
		temp.innerHTML = vnode.children
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodes(fragment, children, 0, children.length, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs2 = vnode.attrs
		var is = attrs2 && attrs2.is
		ns = getNameSpace(vnode) || ns
		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element
		if (attrs2 != null) {
			setAttrs(vnode, attrs2, ns)
		}
		insertNode(parent, element, nextSibling)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(element, children, 0, children.length, hooks, null, ns)
				setLateAttrs(vnode)
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		vnode._state = vnode.state
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		initLifecycle(vnode._state, vnode, hooks)
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
			insertNode(parent, element, nextSibling)
			return element
		}
		else {
			vnode.domSize = 0
			return $emptyFragment
		}
	}
	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes)
			if (recycling) {
				var pool = old.pool
				old = old.concat(old.pool)
			}
			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start]
				if (o === v && !recycling) oldStart++, start++
				else if (o == null) oldStart++
				else if (v == null) start++
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
					oldStart++, start++
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
				}
				else {
					var o = old[oldEnd]
					if (o === v && !recycling) oldEnd--, start++
					else if (o == null) oldEnd--
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
						oldEnd--, start++
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end]
				if (o === v && !recycling) oldEnd--, end--
				else if (o == null) oldEnd--
				else if (v == null) end--
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					if (o.dom != null) nextSibling = o.dom
					oldEnd--, end--
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd)
					if (v != null) {
						var oldIndex = map[v.key]
						if (oldIndex != null) {
							var movable = old[oldIndex]
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
							insertNode(parent, toFragment(movable), nextSibling)
							old[oldIndex].skip = true
							if (movable.dom != null) nextSibling = movable.dom
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling)
							nextSibling = dom
						}
					}
					end--
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
			removeNodes(old, oldStart, oldEnd + 1, vnodes)
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode._state = old._state
			vnode.events = old.events
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {}
						initLifecycle(vnode.attrs, vnode, hooks)
					}
					else updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
		}
		else {
			removeNode(old, null)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns
		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle0 multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks)
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
			updateLifecycle(vnode._state, vnode, hooks)
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance, null)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				var key2 = vnode.key
				if (key2 != null) map[key2] = i
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count0 = vnode.domSize
		if (count0 != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count0 > 0) {
				var dom = vnode.dom
				while (--count0) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}
	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}
	function setContentEditable(vnode) {
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}
	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false
				else removeNode(vnode, context)
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				onremove(vnode)
				if (vnode.dom) {
					var count0 = vnode.domSize || 1
					if (count0 > 1) {
						var dom = vnode.dom
						while (--count0) {
							removeNodeFromDOM(dom.nextSibling)
						}
					}
					removeNodeFromDOM(vnode.dom)
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode]
						else context.pool.push(vnode)
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode
		if (parent != null) parent.removeChild(node)
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}
	//attrs2
	function setAttrs(vnode, attrs2, ns) {
		for (var key2 in attrs2) {
			setAttr(vnode, key2, null, attrs2[key2], ns)
		}
	}
	function setAttr(vnode, key2, old, value, ns) {
		var element = vnode.dom
		if (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return
		var nsLastIndex = key2.indexOf(":")
		if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)
		}
		else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)
		else if (key2 === "style") updateStyle(element, old, value)
		else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
			if (key2 === "value") {
				var normalized0 = "" + value // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return
			}
			// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
			if (vnode.tag === "input" && key2 === "type") {
				element.setAttribute(key2, value)
				return
			}
			element[key2] = value
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key2, "")
				else element.removeAttribute(key2)
			}
			else element.setAttribute(key2 === "className" ? "class" : key2, value)
		}
	}
	function setLateAttrs(vnode) {
		var attrs2 = vnode.attrs
		if (vnode.tag === "select" && attrs2 != null) {
			if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)
			if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)
		}
	}
	function updateAttrs(vnode, old, attrs2, ns) {
		if (attrs2 != null) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, old && old[key2], attrs2[key2], ns)
			}
		}
		if (old != null) {
			for (var key2 in old) {
				if (attrs2 == null || !(key2 in attrs2)) {
					if (key2 === "className") key2 = "class"
					if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)
					else if (key2 !== "key") vnode.dom.removeAttribute(key2)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}
	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null
		if (style == null) element.style.cssText = ""
		else if (typeof style === "string") element.style.cssText = style
		else {
			if (typeof old === "string") element.style.cssText = ""
			for (var key2 in style) {
				element.style[key2] = style[key2]
			}
			if (old != null && typeof old !== "string") {
				for (var key2 in old) {
					if (!(key2 in style)) element.style[key2] = ""
				}
			}
		}
	}
	//event
	function updateEvent(vnode, key2, value) {
		var element = vnode.dom
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e)
			onevent.call(element, e)
			return result
		}
		if (key2 in element) element[key2] = typeof value === "function" ? callback : null
		else {
			var eventName = key2.slice(2)
			if (vnode.events === undefined) vnode.events = {}
			if (vnode.events[key2] === callback) return
			if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)
			if (typeof value === "function") {
				vnode.events[key2] = callback
				element.addEventListener(eventName, vnode.events[key2], false)
			}
		}
	}
	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
			vnode.instance = old.instance
			return true
		}
		return false
	}
	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = $doc.activeElement
		var namespace = dom.namespaceURI
		// First time0 rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""
		if (!Array.isArray(vnodes)) vnodes = [vnodes]
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}
	return {render: render, setEventCallback: setEventCallback}
}
function throttle(callback) {
	//60fps translates to 16.6ms, round it down since setTimeout requires int
	var time = 16
	var last = 0, pending = null
	var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout
	return function() {
		var now = Date.now()
		if (last === 0 || now - last >= time) {
			last = now
			callback()
		}
		else if (pending === null) {
			pending = timeout(function() {
				pending = null
				callback()
				last = Date.now()
			}, time - (now - last))
		}
	}
}
var _11 = function($window) {
	var renderService = coreRenderer($window)
	renderService.setEventCallback(function(e) {
		if (e.redraw === false) e.redraw = undefined
		else redraw()
	})
	var callbacks = []
	function subscribe(key1, callback) {
		unsubscribe(key1)
		callbacks.push(key1, throttle(callback))
	}
	function unsubscribe(key1) {
		var index = callbacks.indexOf(key1)
		if (index > -1) callbacks.splice(index, 2)
	}
	function redraw() {
		for (var i = 1; i < callbacks.length; i += 2) {
			callbacks[i]()
		}
	}
	return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
}
var redrawService = _11(window)
requestService.setCompletionCallback(redrawService.redraw)
var _16 = function(redrawService0) {
	return function(root, component) {
		if (component === null) {
			redrawService0.render(root, [])
			redrawService0.unsubscribe(root)
			return
		}
		
		if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")
		
		var run0 = function() {
			redrawService0.render(root, Vnode(component))
		}
		redrawService0.subscribe(root, run0)
		redrawService0.redraw()
	}
}
m.mount = _16(redrawService)
var Promise = PromisePolyfill
var parseQueryString = function(string) {
	if (string === "" || string == null) return {}
	if (string.charAt(0) === "?") string = string.slice(1)
	var entries = string.split("&"), data0 = {}, counters = {}
	for (var i = 0; i < entries.length; i++) {
		var entry = entries[i].split("=")
		var key5 = decodeURIComponent(entry[0])
		var value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""
		if (value === "true") value = true
		else if (value === "false") value = false
		var levels = key5.split(/\]\[?|\[/)
		var cursor = data0
		if (key5.indexOf("[") > -1) levels.pop()
		for (var j = 0; j < levels.length; j++) {
			var level = levels[j], nextLevel = levels[j + 1]
			var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))
			var isValue = j === levels.length - 1
			if (level === "") {
				var key5 = levels.slice(0, j).join()
				if (counters[key5] == null) counters[key5] = 0
				level = counters[key5]++
			}
			if (cursor[level] == null) {
				cursor[level] = isValue ? value : isNumber ? [] : {}
			}
			cursor = cursor[level]
		}
	}
	return data0
}
var coreRouter = function($window) {
	var supportsPushState = typeof $window.history.pushState === "function"
	var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout
	function normalize1(fragment0) {
		var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)
		if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data
		return data
	}
	var asyncId
	function debounceAsync(callback0) {
		return function() {
			if (asyncId != null) return
			asyncId = callAsync0(function() {
				asyncId = null
				callback0()
			})
		}
	}
	function parsePath(path, queryData, hashData) {
		var queryIndex = path.indexOf("?")
		var hashIndex = path.indexOf("#")
		var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length
		if (queryIndex > -1) {
			var queryEnd = hashIndex > -1 ? hashIndex : path.length
			var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))
			for (var key4 in queryParams) queryData[key4] = queryParams[key4]
		}
		if (hashIndex > -1) {
			var hashParams = parseQueryString(path.slice(hashIndex + 1))
			for (var key4 in hashParams) hashData[key4] = hashParams[key4]
		}
		return path.slice(0, pathEnd)
	}
	var router = {prefix: "#!"}
	router.getPath = function() {
		var type2 = router.prefix.charAt(0)
		switch (type2) {
			case "#": return normalize1("hash").slice(router.prefix.length)
			case "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")
			default: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")
		}
	}
	router.setPath = function(path, data, options) {
		var queryData = {}, hashData = {}
		path = parsePath(path, queryData, hashData)
		if (data != null) {
			for (var key4 in data) queryData[key4] = data[key4]
			path = path.replace(/:([^\/]+)/g, function(match2, token) {
				delete queryData[token]
				return data[token]
			})
		}
		var query = buildQueryString(queryData)
		if (query) path += "?" + query
		var hash = buildQueryString(hashData)
		if (hash) path += "#" + hash
		if (supportsPushState) {
			var state = options ? options.state : null
			var title = options ? options.title : null
			$window.onpopstate()
			if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)
			else $window.history.pushState(state, title, router.prefix + path)
		}
		else $window.location.href = router.prefix + path
	}
	router.defineRoutes = function(routes, resolve, reject) {
		function resolveRoute() {
			var path = router.getPath()
			var params = {}
			var pathname = parsePath(path, params, params)
			var state = $window.history.state
			if (state != null) {
				for (var k in state) params[k] = state[k]
			}
			for (var route0 in routes) {
				var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$")
				if (matcher.test(pathname)) {
					pathname.replace(matcher, function() {
						var keys = route0.match(/:[^\/]+/g) || []
						var values = [].slice.call(arguments, 1, -2)
						for (var i = 0; i < keys.length; i++) {
							params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i])
						}
						resolve(routes[route0], params, path, route0)
					})
					return
				}
			}
			reject(path, params)
		}
		if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)
		else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute
		resolveRoute()
	}
	return router
}
var _20 = function($window, redrawService0) {
	var routeService = coreRouter($window)
	var identity = function(v) {return v}
	var render1, component, attrs3, currentPath, lastUpdate
	var route = function(root, defaultRoute, routes) {
		if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
		var run1 = function() {
			if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))
		}
		var bail = function(path) {
			if (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})
			else throw new Error("Could not resolve default route " + defaultRoute)
		}
		routeService.defineRoutes(routes, function(payload, params, path) {
			var update = lastUpdate = function(routeResolver, comp) {
				if (update !== lastUpdate) return
				component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"
				attrs3 = params, currentPath = path, lastUpdate = null
				render1 = (routeResolver.render || identity).bind(routeResolver)
				run1()
			}
			if (payload.view || typeof payload === "function") update({}, payload)
			else {
				if (payload.onmatch) {
					Promise.resolve(payload.onmatch(params, path)).then(function(resolved) {
						update(payload, resolved)
					}, bail)
				}
				else update(payload, "div")
			}
		}, bail)
		redrawService0.subscribe(root, run1)
	}
	route.set = function(path, data, options) {
		if (lastUpdate != null) {
			options = options || {}
			options.replace = true
		}
		lastUpdate = null
		routeService.setPath(path, data, options)
	}
	route.get = function() {return currentPath}
	route.prefix = function(prefix0) {routeService.prefix = prefix0}
	route.link = function(vnode1) {
		vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)
		vnode1.dom.onclick = function(e) {
			if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return
			e.preventDefault()
			e.redraw = false
			var href = this.getAttribute("href")
			if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)
			route.set(href, undefined, undefined)
		}
	}
	route.param = function(key3) {
		if(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]
		return attrs3
	}
	return route
}
m.route = _20(window, redrawService)
m.withAttr = function(attrName, callback1, context) {
	return function(e) {
		callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))
	}
}
var _28 = coreRenderer(window)
m.render = _28.render
m.redraw = redrawService.redraw
m.request = requestService.request
m.jsonp = requestService.jsonp
m.parseQueryString = parseQueryString
m.buildQueryString = buildQueryString
m.version = "1.1.6"
m.vnode = Vnode
if (typeof module !== "undefined") module["exports"] = m
else window.m = m
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":129}],115:[function(require,module,exports){
"use strict"

module.exports = require("./render/render")(window)

},{"./render/render":118}],116:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function(attrs, children) {
	return Vnode("[", attrs.key, attrs, Vnode.normalizeChildren(children), undefined, undefined)
}

},{"../render/vnode":120}],117:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty

function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}

function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}

function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text
	var className = attrs.className || attrs.class

	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}

		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key]
			}
		}

		attrs = newAttrs
	}

	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key]
		}
	}

	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined
			attrs.className = className
		}

		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className
		}
	}

	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true
			break
		}
	}

	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children
	} else {
		childList = children
	}

	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}

function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children

	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}

	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector)
	}

	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = 1
	}

	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}

	var normalized = Vnode.normalizeChildren(children)

	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}

module.exports = hyperscript

},{"../render/vnode":120}],118:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function($window) {
	var $doc = $window.document
	var $emptyFragment = $doc.createDocumentFragment()

	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}

	var onevent
	function setEventCallback(callback) {return onevent = callback}

	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}

	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match = vnode.children.match(/^\s*?<(\w+)/im) || []
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match[1]] || "div"
		var temp = $doc.createElement(parent1)

		temp.innerHTML = vnode.children
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodes(fragment, children, 0, children.length, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs = vnode.attrs
		var is = attrs && attrs.is

		ns = getNameSpace(vnode) || ns

		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element

		if (attrs != null) {
			setAttrs(vnode, attrs, ns)
		}

		insertNode(parent, element, nextSibling)

		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(element, children, 0, children.length, hooks, null, ns)
				setLateAttrs(vnode)
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		vnode._state = vnode.state
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		initLifecycle(vnode._state, vnode, hooks)
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
			insertNode(parent, element, nextSibling)
			return element
		}
		else {
			vnode.domSize = 0
			return $emptyFragment
		}
	}

	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes)
			if (recycling) {
				var pool = old.pool
				old = old.concat(old.pool)
			}

			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start]
				if (o === v && !recycling) oldStart++, start++
				else if (o == null) oldStart++
				else if (v == null) start++
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
					oldStart++, start++
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
				}
				else {
					var o = old[oldEnd]
					if (o === v && !recycling) oldEnd--, start++
					else if (o == null) oldEnd--
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
						oldEnd--, start++
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end]
				if (o === v && !recycling) oldEnd--, end--
				else if (o == null) oldEnd--
				else if (v == null) end--
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					if (o.dom != null) nextSibling = o.dom
					oldEnd--, end--
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd)
					if (v != null) {
						var oldIndex = map[v.key]
						if (oldIndex != null) {
							var movable = old[oldIndex]
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
							insertNode(parent, toFragment(movable), nextSibling)
							old[oldIndex].skip = true
							if (movable.dom != null) nextSibling = movable.dom
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling)
							nextSibling = dom
						}
					}
					end--
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
			removeNodes(old, oldStart, oldEnd + 1, vnodes)
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode._state = old._state
			vnode.events = old.events
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {}
						initLifecycle(vnode.attrs, vnode, hooks)
					}
					else updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
		}
		else {
			removeNode(old, null)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns

		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks)
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
			updateLifecycle(vnode._state, vnode, hooks)
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance, null)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				var key = vnode.key
				if (key != null) map[key] = i
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count = vnode.domSize
		if (count != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count > 0) {
				var dom = vnode.dom
				while (--count) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}

	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}

	function setContentEditable(vnode) {
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}

	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false
				else removeNode(vnode, context)
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				onremove(vnode)
				if (vnode.dom) {
					var count = vnode.domSize || 1
					if (count > 1) {
						var dom = vnode.dom
						while (--count) {
							removeNodeFromDOM(dom.nextSibling)
						}
					}
					removeNodeFromDOM(vnode.dom)
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode]
						else context.pool.push(vnode)
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode
		if (parent != null) parent.removeChild(node)
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}

	//attrs
	function setAttrs(vnode, attrs, ns) {
		for (var key in attrs) {
			setAttr(vnode, key, null, attrs[key], ns)
		}
	}
	function setAttr(vnode, key, old, value, ns) {
		var element = vnode.dom
		if (key === "key" || key === "is" || (old === value && !isFormAttribute(vnode, key)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key)) return
		var nsLastIndex = key.indexOf(":")
		if (nsLastIndex > -1 && key.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(nsLastIndex + 1), value)
		}
		else if (key[0] === "o" && key[1] === "n" && typeof value === "function") updateEvent(vnode, key, value)
		else if (key === "style") updateStyle(element, old, value)
		else if (key in element && !isAttribute(key) && ns === undefined && !isCustomElement(vnode)) {
			if (key === "value") {
				var normalized = "" + value // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized) return
			}
			// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
			if (vnode.tag === "input" && key === "type") {
				element.setAttribute(key, value)
				return
			}
			element[key] = value
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key, "")
				else element.removeAttribute(key)
			}
			else element.setAttribute(key === "className" ? "class" : key, value)
		}
	}
	function setLateAttrs(vnode) {
		var attrs = vnode.attrs
		if (vnode.tag === "select" && attrs != null) {
			if ("value" in attrs) setAttr(vnode, "value", null, attrs.value, undefined)
			if ("selectedIndex" in attrs) setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, undefined)
		}
	}
	function updateAttrs(vnode, old, attrs, ns) {
		if (attrs != null) {
			for (var key in attrs) {
				setAttr(vnode, key, old && old[key], attrs[key], ns)
			}
		}
		if (old != null) {
			for (var key in old) {
				if (attrs == null || !(key in attrs)) {
					if (key === "className") key = "class"
					if (key[0] === "o" && key[1] === "n" && !isLifecycleMethod(key)) updateEvent(vnode, key, undefined)
					else if (key !== "key") vnode.dom.removeAttribute(key)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}

	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null
		if (style == null) element.style.cssText = ""
		else if (typeof style === "string") element.style.cssText = style
		else {
			if (typeof old === "string") element.style.cssText = ""
			for (var key in style) {
				element.style[key] = style[key]
			}
			if (old != null && typeof old !== "string") {
				for (var key in old) {
					if (!(key in style)) element.style[key] = ""
				}
			}
		}
	}

	//event
	function updateEvent(vnode, key, value) {
		var element = vnode.dom
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e)
			onevent.call(element, e)
			return result
		}
		if (key in element) element[key] = typeof value === "function" ? callback : null
		else {
			var eventName = key.slice(2)
			if (vnode.events === undefined) vnode.events = {}
			if (vnode.events[key] === callback) return
			if (vnode.events[key] != null) element.removeEventListener(eventName, vnode.events[key], false)
			if (typeof value === "function") {
				vnode.events[key] = callback
				element.addEventListener(eventName, vnode.events[key], false)
			}
		}
	}

	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
			vnode.instance = old.instance
			return true
		}
		return false
	}

	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = $doc.activeElement
		var namespace = dom.namespaceURI

		// First time rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""

		if (!Array.isArray(vnodes)) vnodes = [vnodes]
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}

	return {render: render, setEventCallback: setEventCallback}
}

},{"../render/vnode":120}],119:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}

},{"../render/vnode":120}],120:[function(require,module,exports){
"use strict"

function Vnode(tag, key, attrs, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
}
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i])
	}
	return children
}

module.exports = Vnode

},{}],121:[function(require,module,exports){
"use strict"

module.exports = require("./stream/stream")

},{"./stream/stream":122}],122:[function(require,module,exports){
/* eslint-disable */
;(function() {
"use strict"
/* eslint-enable */

var guid = 0, HALT = {}
function createStream() {
	function stream() {
		if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])
		return stream._state.value
	}
	initStream(stream)

	if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])

	return stream
}
function initStream(stream) {
	stream.constructor = createStream
	stream._state = {id: guid++, value: undefined, state: 0, derive: undefined, recover: undefined, deps: {}, parents: [], endStream: undefined, unregister: undefined}
	stream.map = stream["fantasy-land/map"] = map, stream["fantasy-land/ap"] = ap, stream["fantasy-land/of"] = createStream
	stream.valueOf = valueOf, stream.toJSON = toJSON, stream.toString = valueOf

	Object.defineProperties(stream, {
		end: {get: function() {
			if (!stream._state.endStream) {
				var endStream = createStream()
				endStream.map(function(value) {
					if (value === true) {
						unregisterStream(stream)
						endStream._state.unregister = function(){unregisterStream(endStream)}
					}
					return value
				})
				stream._state.endStream = endStream
			}
			return stream._state.endStream
		}}
	})
}
function updateStream(stream, value) {
	updateState(stream, value)
	for (var id in stream._state.deps) updateDependency(stream._state.deps[id], false)
	if (stream._state.unregister != null) stream._state.unregister()
	finalize(stream)
}
function updateState(stream, value) {
	stream._state.value = value
	stream._state.changed = true
	if (stream._state.state !== 2) stream._state.state = 1
}
function updateDependency(stream, mustSync) {
	var state = stream._state, parents = state.parents
	if (parents.length > 0 && parents.every(active) && (mustSync || parents.some(changed))) {
		var value = stream._state.derive()
		if (value === HALT) return false
		updateState(stream, value)
	}
}
function finalize(stream) {
	stream._state.changed = false
	for (var id in stream._state.deps) stream._state.deps[id]._state.changed = false
}

function combine(fn, streams) {
	if (!streams.every(valid)) throw new Error("Ensure that each item passed to stream.combine/stream.merge is a stream")
	return initDependency(createStream(), streams, function() {
		return fn.apply(this, streams.concat([streams.filter(changed)]))
	})
}

function initDependency(dep, streams, derive) {
	var state = dep._state
	state.derive = derive
	state.parents = streams.filter(notEnded)

	registerDependency(dep, state.parents)
	updateDependency(dep, true)

	return dep
}
function registerDependency(stream, parents) {
	for (var i = 0; i < parents.length; i++) {
		parents[i]._state.deps[stream._state.id] = stream
		registerDependency(stream, parents[i]._state.parents)
	}
}
function unregisterStream(stream) {
	for (var i = 0; i < stream._state.parents.length; i++) {
		var parent = stream._state.parents[i]
		delete parent._state.deps[stream._state.id]
	}
	for (var id in stream._state.deps) {
		var dependent = stream._state.deps[id]
		var index = dependent._state.parents.indexOf(stream)
		if (index > -1) dependent._state.parents.splice(index, 1)
	}
	stream._state.state = 2 //ended
	stream._state.deps = {}
}

function map(fn) {return combine(function(stream) {return fn(stream())}, [this])}
function ap(stream) {return combine(function(s1, s2) {return s1()(s2())}, [stream, this])}
function valueOf() {return this._state.value}
function toJSON() {return this._state.value != null && typeof this._state.value.toJSON === "function" ? this._state.value.toJSON() : this._state.value}

function valid(stream) {return stream._state }
function active(stream) {return stream._state.state === 1}
function changed(stream) {return stream._state.changed}
function notEnded(stream) {return stream._state.state !== 2}

function merge(streams) {
	return combine(function() {
		return streams.map(function(s) {return s()})
	}, streams)
}

function scan(reducer, seed, stream) {
	var newStream = combine(function (s) {
		return seed = reducer(seed, s._state.value)
	}, [stream])

	if (newStream._state.state === 0) newStream(seed)

	return newStream
}

function scanMerge(tuples, seed) {
	var streams = tuples.map(function(tuple) {
		var stream = tuple[0]
		if (stream._state.state === 0) stream(undefined)
		return stream
	})

	var newStream = combine(function() {
		var changed = arguments[arguments.length - 1]

		streams.forEach(function(stream, idx) {
			if (changed.indexOf(stream) > -1) {
				seed = tuples[idx][1](seed, stream._state.value)
			}
		})

		return seed
	}, streams)

	return newStream
}

createStream["fantasy-land/of"] = createStream
createStream.merge = merge
createStream.combine = combine
createStream.scan = scan
createStream.scanMerge = scanMerge
createStream.HALT = HALT

if (typeof module !== "undefined") module["exports"] = createStream
else if (typeof window.m === "function" && !("stream" in window.m)) window.m.stream = createStream
else window.m = {stream : createStream}

}());

},{}],123:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],124:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],125:[function(require,module,exports){
(function (process,setImmediate){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof self !== "undefined") {
        self.Q = definition();

    } else {
        throw new Error("This environment was not anticiapted by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":124,"timers":129}],126:[function(require,module,exports){
/*
 * Qanimationframe.js - Promisified requestAnimationFrame with Q
 */
/*jslint newcap: true */
(function (definition) {
    if (typeof exports === "object") {
        module.exports = definition();
    } else {
        window.QanimationFrame = definition();
    }
})(function () {
  "use strict";

  // Import Q
  var Q = window.Q || require("q");

  // requestAnimationFrame polyfill
  var requestAnimationFrame = (function(){
    return window.requestAnimationFrame       ||
           window.oRequestAnimationFrame      ||
           window.msRequestAnimationFrame     ||
           window.mozRequestAnimationFrame    ||
           window.webkitRequestAnimationFrame ||
           function (callback) {
             window.setTimeout(callback, 1000 / 60);
           };
  })();

  // QanimationFrame(f: function) => promise containing the return value of f
  // ---
  //
  var QanimationFrame = function (f) {
    var d = Q.defer();
    requestAnimationFrame(function () {
      try {
        d.resolve(f());
      } catch (e) {
        d.reject(e);
      }
    });
    return d.promise;
  };

  return QanimationFrame;
});

},{"q":125}],127:[function(require,module,exports){
// This library started as an experiment to see how small I could make
// a functional router. It has since been optimized (and thus grown).
// The redundancy and inelegance here is for the sake of either size
// or speed.
(function (root, factory) {
  var define = root.define;

  if (define && define.amd) {
    define('rlite', [], factory);
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = factory();
  } else {
    root.Rlite = factory();
  }
}(this, function () { return function() {
    var routes = {},
        decode = decodeURIComponent;

    function noop(s) { return s; }

    function sanitize(url) {
      ~url.indexOf('/?') && (url = url.replace('/?', '?'));
      url[0] == '/' && (url = url.slice(1));
      url[url.length - 1] == '/' && (url = url.slice(0, -1));

      return url;
    }

    function processUrl(url, esc) {
      var pieces = url.split('/'),
          rules = routes,
          params = {};

      for (var i = 0; i < pieces.length && rules; ++i) {
        var piece = esc(pieces[i]);
        rules = rules[piece.toLowerCase()] || rules[':'];
        rules && rules['~'] && (params[rules['~']] = piece);
      }

      return rules && {
        cb: rules['@'],
        params: params
      };
    }

    function processQuery(url, ctx, esc) {
      if (url && ctx.cb) {
        var hash = url.indexOf('#'),
            query = (hash < 0 ? url : url.slice(0, hash)).split('&');

        for (var i = 0; i < query.length; ++i) {
          var nameValue = query[i].split('=');

          ctx.params[nameValue[0]] = esc(nameValue[1]);
        }
      }

      return ctx;
    }

    function lookup(url) {
      var querySplit = sanitize(url).split('?'),
          esc = ~url.indexOf('%') ? decode : noop;

      return processQuery(querySplit[1], processUrl(querySplit[0], esc) || {}, esc);
    }

    return {
      add: function(route, handler) {

        var pieces = route.split('/'),
            rules = routes;

        for (var i = 0; i < pieces.length; ++i) {
          var piece = pieces[i],
              name = piece[0] == ':' ? ':' : piece.toLowerCase();

          rules = rules[name] || (rules[name] = {});

          name == ':' && (rules['~'] = piece.slice(1));
        }

        rules['@'] = handler;
      },

      exists: function (url) {
        return !!lookup(url).cb;
      },

      lookup: lookup,

      run: function(url) {
        var result = lookup(url);

        result.cb && result.cb({
          url: url,
          params: result.params
        });

        return !!result.cb;
      }
    };
  };
}));

},{}],128:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],129:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":124,"timers":129}],130:[function(require,module,exports){
'use strict';

var style = document.createElement('p').style,
    prefixes = 'O ms Moz webkit'.split(' '),
    hasPrefix = /^(o|ms|moz|webkit)/,
    upper = /([A-Z])/g,
    memo = {};

function get(key){
    return (key in memo) ? memo[key] : memo[key] = prefix(key);
}

function prefix(key){
    var capitalizedKey = key.replace(/-([a-z])/g, function(s, match){
            return match.toUpperCase();
        }),
        i = prefixes.length,
        name;

    if (style[capitalizedKey] !== undefined) return capitalizedKey;

    capitalizedKey = capitalize(key);

    while (i--) {
        name = prefixes[i] + capitalizedKey;
        if (style[name] !== undefined) return name;
    }

    throw new Error('unable to prefix ' + key);
}

function capitalize(str){
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function dashedPrefix(key){
    var prefixedKey = get(key),
        upper = /([A-Z])/g;

    if (upper.test(prefixedKey)) {
        prefixedKey = (hasPrefix.test(prefixedKey) ? '-' : '') + prefixedKey.replace(upper, '-$1');
    }

    return prefixedKey.toLowerCase();
}

module.exports = get;
module.exports.dash = dashedPrefix;

},{}],131:[function(require,module,exports){
// Zanimo.js - Promise based CSS3 transitions
// (c) 2011-2014 Paul Panserrieu

'use strict';

var Q = require('q'),
    QanimationFrame = require('qanimationframe'),
    prefix = require('vendor-prefix'),
    normalizeTransformValue = require('../src/normalize-transform-value'),
    shorthand = require('../src/transition-shorthand-property'),
    transition = prefix('transition'),
    transitionend = 'WebkitTransition' in document.body.style ? 'webkitTransitionEnd' : 'transitionend',

    isDOM = function (el) {
        try {
            return el && el.nodeType;
        } catch(err) {
            return false;
        };
    },

    addTransition = function (elt, attr, value, duration, easing) {
        var currentValue = elt.style[transition];
        attr = prefix.dash(attr);
        if (currentValue) {
            elt.style[transition] = currentValue + ", " + shorthand(attr, duration, easing);
        }
        else {
            elt.style[transition] = shorthand(attr, duration, easing);
        }
        elt.style[prefix(attr)] = value;
    },

    removeTransition = function (el, attr) {
        el.style[transition] = el.style[transition]
            .split(',').filter(function(t) {
                return !t.match(attr);
            }).join(',');
    },

    applycss = function (el, attr, value) {
        return QanimationFrame(function(){
            el.style[prefix.dash(attr)] = value;
            return el;
        });
    },

    css = function (el, attr, value) {
        if(el._zanimo && el._zanimo.hasOwnProperty(attr)) {
            el._zanimo[attr].defer.reject(new Error(
                "Zanimo transition with transform=" +
                el._zanimo[attr].value +
                " stopped by transform=" + value
            ));
            el._zanimo[attr].cb();
        }
        return applycss(el, attr, value);
    },

    animate = function (el, attr, value, duration, easing) {
        var prefixed = prefix.dash(attr),
            d = Q.defer(),
            timeout,
            cb = function (clear) {
                if (timeout) { clearTimeout(timeout); timeout = null; }
                removeTransition(el, attr);
                el.removeEventListener(transitionend, cbTransitionend);
                if (clear) { delete el._zanimo[attr]; }
            },
            cbTransitionend = function (evt) {
                if(prefix(evt.propertyName) === prefix(prefixed)) {
                    cb(true);
                    d.resolve(el);
                }
            };

        el.addEventListener(transitionend, cbTransitionend);

        QanimationFrame(function () {
            addTransition(el, attr, normalizeTransformValue(value), duration, easing);
            timeout = setTimeout(function () {
                var rawVal = el.style.getPropertyValue(prefixed),
                    domVal = normalizeTransformValue(rawVal),
                    givenVal = normalizeTransformValue(value);

                cb(true);
                if (domVal === givenVal) { d.resolve(el); }
                else {
                    d.reject( new Error("Zanimo transition: with "
                        + attr + " = " + givenVal + ", DOM value=" + domVal
                    ));
                }
            }, duration + 20 );

            el._zanimo = el._zanimo || { };
            if(el._zanimo[attr]) {
                el._zanimo[attr].defer.reject(new Error(
                    "Zanimo transition with " +
                    attr + "=" + el._zanimo[attr].value +
                    " stopped by transition with " + attr + "=" + value
                ));
                el._zanimo[attr].cb();
            }
            el._zanimo[attr] = {cb: cb, value: value, defer: d};
        });

        return d.promise;
    };

/**
 * Zanimo(el | promise[el])
 * > Returns a Promise of el.
 *
 * Zanimo(el | promise[el], attr, value)
 * > Sets el.style[attr]=value and returns the promise of el.
 *
 * Zanimo(el | promise[el], attr, value, duration, [easing])
 * > Performs a transition.
 */
var Zanimo = function (el, attr, value, duration, easing) {
    var args = arguments,
        arity = arguments.length;
    if (arity === 0 || arity === 2 || arity > 5) {
        return Q.reject(new Error("Zanimo invalid arguments"));
    }
    if (Q.isPromise(el)) {
        return el.then(function (val) {
            return Zanimo.apply(this, [val].concat(Array.prototype.slice.call(args, 1)));
        });
    }
    if (!isDOM(el)) {
        return Q.reject(new Error("Zanimo require an HTMLElement, or a promise of an HTMLElement"));
    }
    if (arity === 1) {
        return Q(el);
    }
    try {
        prefix.dash(attr);
    } catch(err) {
        return Q.reject(new Error("Zanimo transition: " + attr + ' is not supported!'));
    };
    if (arity === 3) {
        return css(el, attr, value);
    }
    if(window.isNaN(parseInt(duration, 10))) {
        return Q.reject(new Error("Zanimo transition: duration must be an integer!"));
    }
    return animate(el, attr, value, duration, easing);
};

/**
 * A function wrapping `Zanimo(el, ...)` as a `f(...)(el)` for easy chaining purpose.
 */
Zanimo.f = function (attr, value, duration, easing) {
    var args = Array.prototype.slice.call(arguments);
    return function (el) {
        return Zanimo.apply(this, [el].concat(args));
    };
};

module.exports = Zanimo;

},{"../src/normalize-transform-value":133,"../src/transition-shorthand-property":134,"q":125,"qanimationframe":126,"vendor-prefix":130}],132:[function(require,module,exports){
'use strict';

var matchParenthesis = /(\(.+?\))/g,
    space = / +/g,
    emptyString = "",
    whitespace = " ",

    normalize = function (match) {
        var args = match.substr(1, match.length-2).split(","),
            rst = args.map(function (arg) {
                return parseFloat(arg.replace(space, emptyString));
            });
        return "(" + rst.join(",") + ")";
    };

module.exports = function (t) {
    return  typeof t === 'string' ? t.replace(space, whitespace).replace(matchParenthesis, normalize) : t;
};

},{}],133:[function(require,module,exports){
'use strict';

var Color = require('color'),
    matchParenthesis = /(\(.+?\))/g,
    matchColors = /(\brgba\b|\bhsl\b|\bhsla\b)(\(.+?\))/g,
    space = / +/g,
    emptyString = "",
    whitespace = " ",
    zeropixel = /^0px$/g,
    zero = "0",

    normArgs = function (match) {
        var args = match.substr(1, match.length-2).split(","),
            rst = args.map(function (arg) {
                return arg.replace(space, emptyString).replace(zeropixel, zero);
            });
        return "(" + rst.join(",") + ")";
    },

    normColors = function (match) {
        var c = Color(match);
        if (c.alpha() ) { c.alpha(Math.round(c.alpha() * 10) / 10); }
        return c.rgbString();
    },

    normalize = function (val) {
        return val.replace(space, whitespace)
            .replace(matchColors, normColors)
            .replace(matchParenthesis, normArgs);
    };

module.exports = function (val) {
    if (val === null || val === undefined) return emptyString;
    return window.isNaN(val) ? normalize(val) : val.toString();
};

},{"color":6}],134:[function(require,module,exports){
'use strict';

var prefix = require('vendor-prefix'),
    normalizeTransformValue = require('./normalize-transform-value'),
    normalizeTimingFunction = require('./normalize-timing-function'),
    transition = prefix.dash('transition'),
    el = document.createElement('div'),
    test = 'opacity 100ms linear 0s',
    normalizedTest = normalizeTransformValue(test),
    shorthand = function shorthand(v, d, t) {
        return v + " " + d + "ms " + (t || "linear");
    };

el.style[transition] = normalizedTest;

if(normalizeTransformValue(el.style[transition]) === normalizedTest) {
    shorthand = function (v, d, t) {
        return v + " " + d + "ms " + (normalizeTimingFunction(t) || "linear") + " 0s";
    };
}

module.exports = shorthand;

},{"./normalize-timing-function":132,"./normalize-transform-value":133,"vendor-prefix":130}],135:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = backbutton;

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('./utils');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stack = [];

function backbutton() {
  var b = stack.pop();
  if ((0, _isFunction2.default)(b)) {
    b('backbutton');
    _mithril2.default.redraw();
  } else if (!/^\/$/.test(_mithril2.default.route())) {
    // if playing a game as anon ask for confirmation
    if (/^\/game\/[a-zA-Z0-9]{12}/.test(_mithril2.default.route())) {
      navigator.notification.confirm((0, _i18n2.default)('thereIsAGameInProgress'), function (i) {
        if (i === 1) (0, _utils.backHistory)();
      });
    } else {
      (0, _utils.backHistory)();
    }
  } else {
    window.navigator.app.exitApp();
  }
};

backbutton.stack = stack;

},{"./i18n":138,"./utils":208,"lodash/isFunction":97,"mithril":114}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var defaults = {
  apiVersion: 1,
  fetchTimeoutMs: 10000
};

var config = Object.assign({}, defaults, window.oyunkeyf);

exports.default = config;

},{}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.apiVersion = exports.SESSION_ID_KEY = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.fetchJSON = fetchJSON;

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _spinner = require('./spinner');

var _spinner2 = _interopRequireDefault(_spinner);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _querystring = require('./utils/querystring');

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SESSION_ID_KEY = exports.SESSION_ID_KEY = 'sessionId';

var baseUrl = _config2.default.apiEndPoint;

function addQueryString(url, queryString) {
  var prefix = url.indexOf('?') < 0 ? '?' : '&';
  var res = url + prefix + queryString;
  return res;
}

function request(url, type, opts, feedback) {

  var timeoutId = void 0;

  function onComplete() {
    clearTimeout(timeoutId);
    if (feedback) _spinner2.default.stop();
  }

  if (opts && opts.query) {
    var query = (0, _querystring.buildQueryString)(opts.query);
    if (query !== '') {
      url = addQueryString(url, query);
    }
    delete opts.query;
  }

  var cfg = {
    method: 'GET',
    headers: {
      'X-Requested-With': 'XMLHttpRequest',
      'Accept': 'application/vnd.oyunkeyf.v' + _config2.default.apiVersion + '+json'
    }
  };

  (0, _merge2.default)(cfg, opts);

  var init = _extends({}, cfg, {
    credentials: 'include',
    headers: new Headers(cfg.headers)
  });

  if ((init.method === 'POST' || init.method === 'PUT') && !init.headers.get('Content-Type')) {
    init.headers.append('Content-Type', 'application/json; charset=UTF-8');
    if (!init.body) {
      init.body = '{}';
    }
  }

  var sid = _storage2.default.get(SESSION_ID_KEY);
  if (sid !== null) {
    init.headers.append(SESSION_ID_KEY, sid);
  }

  var fullUrl = url.indexOf('http') > -1 ? url : baseUrl + url;

  var timeoutPromise = new Promise(function (_, reject) {
    timeoutId = setTimeout(function () {
      return reject(new Error('Request timeout'));
    }, _config2.default.fetchTimeoutMs);
  });

  var respOrTimeout = Promise.race([fetch(fullUrl, init), timeoutPromise]);

  if (feedback) {
    _spinner2.default.spin();
  }

  return new Promise(function (resolve, reject) {
    respOrTimeout.then(function (r) {
      onComplete();
      if (r.ok) {
        resolve(r[type]());
      } else {
        r.text().then(function (bodyText) {
          try {
            reject({
              status: r.status,
              body: JSON.parse(bodyText)
            });
          } catch (_) {
            reject({
              status: r.status,
              body: r.statusText
            });
          }
        });
      }
    }).catch(function (err) {
      console.log('error ' + err);
      onComplete();
      reject({
        status: 0,
        body: err.message
      });
    });
  });
}

function fetchJSON(url, opts) {
  var feedback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  return request(url, 'json', opts, feedback);
}

var apiVersion = exports.apiVersion = 1;

// const baseUrl = window.oyunkeyf.apiEndPoint;

function onSuccess(data) {
  _spinner2.default.stop();
  return data;
}

function onError(data) {
  _spinner2.default.stop();
  throw data;
}

function xhrConfig(xhr) {
  xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  xhr.setRequestHeader('Accept', 'application/vnd.oyunkeyf.v' + apiVersion + '+json');
  xhr.withCredentials = true;
  xhr.timeout = 8000;
}

// convenient wrapper around m.request
// export function request(url, opts, feedback, xhrConf) {
//   var cfg = {
//     url: baseUrl + url,
//     method: 'GET',
//     data: { },
//     config: xhrConf || xhrConfig,
//     deserialize: function(text) {
//       try {
//         return JSON.parse(text);
//       } catch (e) {
//         throw { response: { error: 'Cannot read data from the server' }};
//       }
//     },
//     unwrapError: function(response, xhr) {
//       return { response, status: xhr.status };
//     }
//   };
//   merge(cfg, opts);

//   if (cfg.method === 'GET') {
//     cfg.data._ = Date.now();
//   }

//   var promise = m.request(cfg);

//   if (feedback) {
//     spinner.spin(document.body);
//     return promise.then(onSuccess, onError);
//   } else {
//     return promise;
//   }
// }

},{"./config":136,"./spinner":150,"./storage":151,"./utils/querystring":209,"lodash/merge":105}],138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLang = getLang;
exports.default = i18n;
exports.loadPreferredLanguage = loadPreferredLanguage;
exports.loadLanguage = loadLanguage;

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultCode = 'tr';

var lang = defaultCode;
var messages = {};

var untranslated = {};

function getLang() {
  return lang;
}

function i18n(key) {
  var str = messages[key] || untranslated[key] || key;

  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  args.forEach(function (a) {
    str = str.replace('%s', String(a));
  });

  return str;
}

function loadPreferredLanguage() {
  var fromSettings = _settings2.default.general.lang();
  if (fromSettings) {
    return loadLanguage(fromSettings);
  }

  return new Promise(function (resolve) {
    window.navigator.globalization.getPreferredLanguage(function (l) {
      return resolve(l.value.split('-')[0]);
    }, function () {
      return resolve(defaultCode);
    });
  }).then(function (code) {
    _settings2.default.general.lang(code);
    return code;
  }).then(loadFile).then(loadMomentLocale);
}

function loadLanguage(lang) {
  return loadFile(lang).then(loadMomentLocale);
}

function loadFile(code) {
  return (0, _utils.loadLocalJsonFile)('i18n/' + code + '.json').then(function (data) {
    lang = code;
    messages = data;
    return code;
  }).catch(function (error) {
    if (code === defaultCode) throw new Error(error);
    return loadFile(defaultCode);
  });
}

// export function getAvailableLanguages() {
//   return m.request({
//     url: 'i18n/refs.json',
//     method: 'GET'
//   }).then(data => { return data; }, error => {
//     // same workaround for iOS as above
//     if (error && error[0][0] === 'tr')
//       return error;
//     else
//       throw { error: 'Cannot load languages' };
//   });
// }


// export function loadFromSettings() {
//   return loadFile(settings.general.lang()).then(loadMomentLocale);
// }

// function loadFile(code) {
//   return m.request({
//     url: 'i18n/' + code + '.json',
//     method: 'GET',
//     deserialize: function(text) {
//       try {
//         return JSON.parse(text);
//       } catch (e) {
//         throw { error: 'Lang not available' };
//       }
//     }
//   }).then(function(data) {
//     messages = data;
//     return code;
//   }, function(error) {
//     // workaround for iOS: because xhr for local file has a 0 status it will
//     // reject the promise and still have the response object
//     if (error && error.playWithAFriend) {
//       messages = error;
//       return code;
//     } else {
//       if (code === defaultCode) throw new Error(error);
//       return loadFile(defaultCode);
//     }
//   });
// }

function loadMomentLocale(code) {
  if (code !== 'en') {
    var script = document.createElement('script');
    script.src = 'moment/locale/' + code + '.js';
    document.head.appendChild(script);
  }
  window.moment.locale(code);
  return code;
}

},{"./settings":147,"./utils":208}],139:[function(require,module,exports){
'use strict';

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('./i18n');

var _xhr = require('./xhr');

var xhr = _interopRequireWildcard(_xhr);

var _helper = require('./ui/helper');

var helper = _interopRequireWildcard(_helper);

var _backbutton = require('./backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _socket = require('./socket');

var _socket2 = _interopRequireDefault(_socket);

var _routes = require('./routes');

var _routes2 = _interopRequireDefault(_routes);

var _router = require('./router');

var _router2 = _interopRequireDefault(_router);

var _appMode = require('./utils/appMode');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.moment = _moment2.default; /* application entry point */

// import './polyfills';


// for moment a global object makes loading locales easier


var firstConnection = true;

function main() {
  _routes2.default.init();
  // cache viewport dims
  helper.viewportDim();

  // pull session data once (to log in user automatically thanks to cookie)
  // and also listen to online event in case network was disconnected at app
  // startup
  if (utils.hasNetwork()) {
    onOnline();
  }

  document.addEventListener('online', onOnline, false);
  document.addEventListener('offline', onOffline, false);
  document.addEventListener('resume', onResume, false);
  document.addEventListener('pause', onPause, false);
  document.addEventListener('backbutton', _router2.default.backbutton, false);
  window.addEventListener('unload', function () {
    _socket2.default.destroy();
    _socket2.default.terminate();
  });
  window.addEventListener('resize', onResize, false);

  if (cordova.platformId === 'android') {
    window.StatusBar.backgroundColorByHexString('#151A1E');
  }

  setTimeout(function () {
    window.navigator.splashscreen.hide();
    window.StatusBar.hide();
    // xhrStatus();
  }, 500);
}

function onOnline() {
  if ((0, _appMode.isForeground)()) {
    if (firstConnection) {
      firstConnection = false;
      // xhr.status();

      _session2.default.rememberLogin().then(function (user) {
        var serverLang = user.language && user.language.split('-')[0];
        if (serverLang) {
          (0, _i18n.ensureLangIsAvailable)(serverLang).then(function (lang) {
            _settings2.default.general.lang(lang);
            (0, _i18n.loadLanguage)(lang);
          });
        }
        (0, _redraw2.default)();
      }).catch(function () {
        console.log('connected as anonymous');
      });
    } else {
      _socket2.default.connect();
      _session2.default.refresh();
    }
  }
}

function onOffline() {
  if ((0, _appMode.isForeground)() && !hasNetwork()) {
    _socket2.default.disconnect();
    (0, _redraw2.default)();
  }
}

function onResize() {
  helper.clearCachedViewportDim();
  (0, _redraw2.default)();
}

function onResume() {
  (0, _appMode.setForeground)();
  _session2.default.refresh();
  _socket2.default.connect();
  (0, _redraw2.default)();
}

function onPause() {
  (0, _appMode.setBackground)();
  _socket2.default.disconnect();
}

// function handleError(event, source, fileno, columNumber) {
//   var description = event + ' at ' + source + ' [' + fileno + ', ' + columNumber + ']';
// }

// window.onerror = handleError;

document.addEventListener('deviceready', function () {
  return (0, _i18n.loadPreferredLanguage)().then(main);
}, false);

},{"./backbutton":135,"./i18n":138,"./router":144,"./routes":145,"./session":146,"./settings":147,"./socket":149,"./ui/helper":156,"./utils":208,"./utils/appMode":206,"./utils/redraw":210,"./xhr":213,"moment":123}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _status = require('./status');

var _status2 = _interopRequireDefault(_status);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function playable(data) {
  return data.game.status.id < _status2.default.ids.aborted;
}

function isPlayerPlaying(data) {
  return playable(data) && !data.player.spectator;
}

function isPlayerTurn(data) {
  return isPlayerPlaying(data) && data.game.player === data.player.side;
}

function getPlayer(data, side) {
  return ['player', 'opponentLeft', 'opponentRight', 'opponentUp'].map(function (k) {
    return data[k];
  }).filter(function (player) {
    return player.side === side;
  })[0];
}

function result(data) {
  if (_status2.default.aborted(data)) {
    return (0, _i18n2.default)('gameAborted');
  } else if (_status2.default.finished(data)) {
    return (0, _i18n2.default)('gameFinished');
  }
};

var sides = ["east", "north", "west", "south"];

function sideByPly(ply) {
  return sides[ply % 4];
}

function setOnGame(data, side, onGame) {
  var player = getPlayer(data, side);
  player.onGame = onGame;
}

// function roundsOrScores(game) {
//   if (game.rounds) {
//     return data.
//   } else if (data.scores) {

//   } else {
//     return '';
//   }
// }

function title(data) {
  var text;
  if (isPlayerTurn(data)) {
    text = (0, _i18n2.default)('yourTurn');
  } else {
    text = (0, _i18n2.default)('waitingForOpponent');
  }
  // const variant = getVariant(data.game.variant.key);
  // const name = variant ? (variant.shortName || variant.name) : '';
  return text;
}

exports.default = {
  isPlayerPlaying: isPlayerPlaying,
  isPlayerTurn: isPlayerTurn,
  getPlayer: getPlayer,
  sideByPly: sideByPly,
  playable: playable,
  setOnGame: setOnGame,
  title: title,
  result: result
};

},{"../i18n":138,"./status":143}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.playerName = playerName;
exports.aiName = aiName;

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function playerName(player) {
  if (player.name || player.username || player.user) {
    var name = player.name || player.username || player.user.username;
    return name;
  }
  if (player.ai) {
    return aiName(player);
  }
  return 'Anonymous';
}

function aiName(player) {
  return (0, _i18n2.default)('aiBot', 1);
}

},{"../i18n":138}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.humanSetupFromSettings = humanSetupFromSettings;
function humanSetupFromSettings(settingsObj) {
  return {
    mode: settingsObj.mode(),
    variant: settingsObj.variant(),
    rounds: settingsObj.rounds()
  };
}

},{}],143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ids = {
  created: 10,
  started: 20,
  aborted: 25,
  middleEnd: 30,
  normalEnd: 40,
  variantEnd: 70
}; // scalaokey/src/main/scala/Status.scala

function started(data) {
  return data.game.status.id >= ids.started;
}

function finished(data) {
  return data.game.status.id >= ids.middleEnd;
}

function aborted(data) {
  return data.game.status.id === ids.aborted;
}

function middleEnd(data) {
  return data.game.status.id === ids.middleEnd;
}

function playing(data) {
  return started(data) && !finished(data) && !aborted(data);
}

function toLabel(status, winner, variant) {
  switch (status) {
    case 'started':
      return (0, _i18n2.default)('playingRightNow');
    case 'aborted':
      return (0, _i18n2.default)('gameAborted');
    case 'middleEnd':
      return (0, _i18n2.default)('gameMiddleFinished');
    case 'normalEnd':
      return (0, _i18n2.default)('gameFinished');
    case 'variantEnd':
      return (0, _i18n2.default)('gameFinished');
  }
};

exports.default = {
  ids: ids,
  started: started,
  finished: finished,
  aborted: aborted,
  playing: playing,
  middleEnd: middleEnd,
  toLabel: toLabel
};

},{"../i18n":138}],144:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineRoutes = defineRoutes;

var _rliteRouter = require('rlite-router');

var _rliteRouter2 = _interopRequireDefault(_rliteRouter);

var _render = require('mithril/render');

var RenderService = _interopRequireWildcard(_render);

var _vnode = require('mithril/render/vnode');

var _vnode2 = _interopRequireDefault(_vnode);

var _signals = require('./signals');

var _signals2 = _interopRequireDefault(_signals);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var router = new _rliteRouter2.default();

var currentStateId = 0;
var viewSlideDirection = 'fwd';

var previousPath = '/';

var uid = function () {
  var id = 0;
  return function () {
    return id++;
  };
}();

var backbutton = function () {
  var x = function x() {

    var b = x.stack.length === 0 ? null : x.stack.pop();

    if (isFunction(b)) {
      b('backbutton');
      (0, _redraw2.default)();
    } else if (!/^\/$/.test(get())) {
      backHistory();
    } else {
      window.navigator.app.exitApp();
    }
  };

  x.stack = [];

  return x;
}();

function defineRoutes(mountPoint, routes) {
  var _loop = function _loop(route) {
    var component = routes[route];
    router.add(route, function onRouteMatch(_ref) {
      var params = _ref.params;

      var RouteComponent = {
        view: function view() {
          var node = (0, _vnode2.default)(component, undefined, params);
          return node;
        }
      };

      function redraw() {
        RenderService.render(mountPoint, (0, _vnode2.default)(RouteComponent));
      }

      _signals2.default.redraw.removeAll();
      _signals2.default.redraw.add(redraw);
      try {
        redraw();
      } catch (e) {
        _signals2.default.redraw.removeAll();
        throw e;
      }
    });
  };

  for (var route in routes) {
    _loop(route);
  }
  window.addEventListener('popstate', processQuerystring);
  processQuerystring();
}

function processQuerystring(e) {
  if (e && e.state) {
    if (e.state.id < currentStateId) {
      viewSlideDirection = 'bwd';
    } else {
      viewSlideDirection = 'fwd';
    }
    currentStateId = e.state.id;
  }
  previousPath = get();
  var qs = window.location.search || '?=';
  var matched = router.run(qs.slice(2));
  if (!matched) router.run('/');
}

function assignState(state, path) {
  try {
    var newState = state ? Object.assign({}, window.history.state, state) : window.history.state;

    if (path !== undefined) {
      window.history.replaceState(newState, '', '?=' + path);
    } else {
      window.history.replaceState(newState, '');
    }
  } catch (e) {
    console.error(e);
  }
}

function replacePath(path) {
  assignState(undefined, path);
}

function doSet(path) {
  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  backbutton.stack = [];
  previousPath = get();
  if (replace) {
    replacePath(path);
  } else {
    var stateId = uid();
    currentStateId = stateId;
    viewSlideDirection = 'fwd';
    try {
      window.history.pushState({ id: stateId }, '', '?=' + path);
    } catch (e) {
      console.error(e);
    }
  }
  var matched = router.run(path);
  if (!matched) router.run('/');
}

function set(path) {
  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  setTimeout(function () {
    return doSet(path, replace);
  }, 0);
}

function get() {
  var path = window.location.search || '?=/';
  return decodeURIComponent(path.substring(2));
}

function backHistory() {
  window.history.go(-1);
}

exports.default = {
  get: get,
  set: set,
  backbutton: backbutton,
  backHistory: backHistory
};

},{"./signals":148,"./utils/redraw":210,"mithril/render":115,"mithril/render/vnode":120,"rlite-router":127}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _home = require('./ui/home');

var _home2 = _interopRequireDefault(_home);

var _game = require('./ui/game');

var _game2 = _interopRequireDefault(_game);

var _user = require('./ui/user');

var _user2 = _interopRequireDefault(_user);

var _players = require('./ui/players');

var _players2 = _interopRequireDefault(_players);

var _detail = require('./ui/masa/detail');

var _detail2 = _interopRequireDefault(_detail);

var _masa = require('./ui/masa');

var _masa2 = _interopRequireDefault(_masa);

var _settings = require('./ui/settings');

var _settings2 = _interopRequireDefault(_settings);

var _lang = require('./ui/settings/lang');

var _lang2 = _interopRequireDefault(_lang);

var _router = require('./router');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  init: function init() {
    (0, _router.defineRoutes)(document.body, {
      '': _home2.default,
      '@/:id': _user2.default,
      'players': _players2.default,
      'game/:id': _game2.default,
      'masa/:masaId/game/:id': _game2.default,
      'masas': _masa2.default,
      'masa/:id': _detail2.default,
      'settings': _settings2.default,
      'settings/lang': _lang2.default
    });
  }
};

},{"./router":144,"./ui/game":152,"./ui/home":158,"./ui/masa":168,"./ui/masa/detail":164,"./ui/players":174,"./ui/settings":178,"./ui/settings/lang":179,"./ui/user":202}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _http = require('./http');

var _utils = require('./utils');

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var session = void 0;

function isConnected() {
  return session !== undefined;
}

function getSession() {
  return session;
}

function isSession(data) {
  return data.id !== undefined;
}

function storeSession(d) {}

function login(username, password) {
  return (0, _http.fetchJSON)('/login', {
    method: 'POST',
    body: JSON.stringify({
      username: username,
      password: password
    })
  }, true).then(function (data) {
    if (isSession(data)) {
      session = data;
      if (session.sessionId) {
        _storage2.default.set(_http.SESSION_ID_KEY, session.sessionId);
      }
      // storeSession(data);
      return session;
    }
    return false;
  });
}

function signup(username, email, password) {
  return (0, _http.fetchJSON)('/signup', {
    method: 'POST',
    body: JSON.stringify({
      username: username,
      email: email,
      password: password
    })
  }, true).then(function (d) {
    if (isSession(d)) {
      session = d;
      if (session.sessionId) {
        _storage2.default.set(_http.SESSION_ID_KEY, session.sessionId);
      }
    }
    return d;
  });
}

function rememberLogin() {
  return (0, _http.fetchJSON)('/account/info').then(function (data) {
    session = data;
    storeSession(data);
    return data;
  });
}

function refresh() {
  return (0, _http.fetchJSON)('/account/info', { cache: 'reload' }).then(function (data) {
    session = data;
    storeSession(data);
    redraw();
  }).catch(function (err) {
    if (session !== undefined && err.status === 401) {
      session = undefined;
      onLogout();
      redraw();
      window.plugins.toast.show((0, _i18n2.default)('signedOut'), 'short', 'center');
    }
  });
}

function onLogout() {
  _storage2.default.remove(_http.SESSION_ID_KEY);
  signals.afterLogout.dispatch();
}

exports.default = {
  isConnected: isConnected,
  signup: signup,
  login: (0, _throttle2.default)(login, 1000),
  rememberLogin: (0, _throttle2.default)(rememberLogin, 1000),
  get: getSession,
  refresh: (0, _throttle2.default)(refresh, 1000)
};

},{"./http":137,"./i18n":138,"./settings":147,"./storage":151,"./utils":208,"lodash/throttle":109}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

var _range = require('lodash/range');

var _range2 = _interopRequireDefault(_range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function tupleOf(x) {
  return [x.toString(), x.toString()];
}

exports.default = {
  general: {
    lang: _storage2.default.prop('settings.lang', null),
    theme: {
      background: _storage2.default.prop('settings.bgTheme', 'dark')
    }
  },
  game: {
    supportedVariants: ['standard', 'yuzbir', 'duzokey']
  },
  gameSetup: {
    availableRounds: [1, 5, 10, 15, 20, 25, 30].map(tupleOf),
    isRoundValid: function isRoundValid(gameSettings) {
      return gameSettings.rounds() !== '0';
    },
    human: {
      availableVariants: [['101 Okey', '1'], ['Düz Okey', '3']],
      variant: _storage2.default.prop('settings.game.human.variant', '1'),
      rounds: _storage2.default.prop('settings.game.human.rounds', '1'),
      mode: _storage2.default.prop('settings.game.human.mode', '0'),
      membersOnly: _storage2.default.prop('settings.game.human.membersOnly', false)
    }
  }
};

},{"./storage":151,"lodash/range":107}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _signals = require('signals');

exports.default = {

  redraw: new _signals.Signal(),

  afterLogin: new _signals.Signal(),

  afterLogout: new _signals.Signal(),

  sessionRestored: new _signals.Signal()

};

},{"signals":128}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

var _http = require('./http');

var _utils = require('./utils');

var _worker = require('./utils/worker');

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function setupConnection(setup, socketHandlers) {
  var sid = _storage2.default.get(_http.SESSION_ID_KEY);
  if (sid !== null) {
    if (setup.opts.params) {
      setup.opts.params[_http.SESSION_ID_KEY] = sid;
    } else {
      setup.opts.params = _defineProperty({}, _http.SESSION_ID_KEY, sid);
    }
  } else if (setup.opts.params) {
    delete setup.opts.params.sessionId;
  }
  setup.opts.options.isAuth = !!sid;
  worker.onmessage = function (msg) {
    switch (msg.data.topic) {
      case 'onOpen':
        if (socketHandlers.onOpen) socketHandlers.onOpen();
        break;
      case 'disconnected':
        onDisconnected();
        break;
      case 'connected':
        onConnected();
        break;
      case 'onError':
        if (socketHandlers.onError) socketHandlers.onError();
        break;
      case 'handle':
        var h = socketHandlers.events[msg.data.payload.t];
        if (h) h(msg.data.payload.d, msg.data.payload);
        break;
    }
  };

  (0, _worker.tellWorker)(worker, 'create', setup);
}

function onConnected() {
  if (!connectedWS) {
    connectedWS = true;
    (0, _redraw2.default)();
  }
}

function onDisconnected() {
  if (connectedWS) {
    connectedWS = false;
    (0, _redraw2.default)();
  }
}

function reconnectCurrent() {}

var connectedWS = false;

var worker = new Worker('lib/socketWorker.js');
var defaultHandlers = {};

function createLobby(name, _onOpen, handlers) {
  var socketHandlers = {
    onOpen: function onOpen() {
      _session2.default.refresh();
      _onOpen();
    },
    events: Object.assign({}, defaultHandlers, handlers)
  };
  var opts = {
    options: {
      name: name,
      debug: _config2.default.mode === 'dev',
      pingDelay: 2000,
      sendOnOpen: [],
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  var setup = {
    clientId: (0, _utils.newSri)(),
    socketEndPoint: _config2.default.socketEndPoint,
    url: '/lobby/socket/v' + _config2.default.apiVersion,
    opts: opts
  };
  setupConnection(setup, socketHandlers);
}

function createMasa(masaId, version, handlers) {
  var url = '/masa/' + masaId + ('/socket/v' + _config2.default.apiVersion);
  var socketHandlers = {
    events: Object.assign({}, defaultHandlers, handlers),
    onOpen: _session2.default.backgroundRefresh
  };
  var opts = {
    options: {
      name: 'masa',
      debug: _config2.default.mode === 'dev',
      pingDelay: 2000,
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  var setup = {
    clientId: (0, _utils.newSri)(),
    socketEndPoint: _config2.default.socketEndPoint,
    url: url,
    version: version,
    opts: opts
  };
  setupConnection(setup, socketHandlers);
}

function createGame(url, version, handlers, gameUrl) {
  var socketHandlers = {
    onOpen: _session2.default.backgroundRefresh,
    events: Object.assign({}, defaultHandlers, handlers)
  };
  var opts = {
    options: {
      name: 'game',
      debug: _config2.default.mode === 'dev',
      sendOnOpen: [],
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  var setup = {
    clientId: (0, _utils.newSri)(),
    socketEndPoint: _config2.default.socketEndPoint,
    url: url,
    version: version,
    opts: opts
  };

  setupConnection(setup, socketHandlers);
}

exports.default = {
  createGame: createGame,
  createLobby: createLobby,
  createMasa: createMasa,
  reconnectCurrent: reconnectCurrent,
  send: function send(t, data, opts) {
    (0, _worker.tellWorker)(worker, 'send', [t, data, opts]);
  },
  isConnected: function isConnected() {
    return connectedWS;
  },
  connect: function connect() {
    (0, _worker.tellWorker)(worker, 'connect');
  },
  destroy: function destroy() {
    (0, _worker.tellWorker)(worker, 'destroy');
  }
};

/// OLD


// const worker = new Worker('lib/socketWorker.js');

// let socketHandlers;
// let errorDetected = false;
// let connectedWS = true;

// let alreadyWarned = false;
// let redrawOnDisconnectedTimeoutID;
// let proxyFailTimeoutID;
// const proxyFailMsg = "Oyunkeyf sunucularına bağlantı koptu. Problem sürekli yaşanıyorsa proxy yada network'la ilgili olabilir.";

// const defaultHandlers = {
// };

// function createGame(url, version, handlers, gameUrl) {
//   errorDetected = false;
//   socketHandlers = {
//     onError: function() {
//       // we can't get socket error, so we send an xhr to test whether the
//       // rejection is an authorization issue
//       if (!errorDetected) {
//         // just to be sure that we don't send an xhr every second when the
//         // websocket is trying to reconnect
//         errorDetected = true;
//         xhr.game(gameUrl.substring(1)).then(function() {}, function(err) {
//           if (err.status === 401) {
//             window.plugins.toast.show(i18n('unauthorizedError'), 'short', 'center');
//             m.route('/');
//           }
//         });
//       }
//     },
//     events: Object.assign({}, defaultHandlers, handlers)
//   };

//   const opts = {
//     options: {
//       name: 'game',
//       debug: false,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version,
//     opts
//   });
// }

// function createMasa(masaId, version, handlers) {
//   let url = '/masa/' + masaId + '/socket/v1';

//   socketHandlers = {
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     options: {
//       name: 'masa',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version,
//     opts
//   });
// }

// function createMasaHome(handlers) {
//   let url = '/socket';

//   socketHandlers = {
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     params: { flag: 'masa' },
//     options: {
//       name: 'masaHome',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version: 0,
//     opts
//   });
// }

// function createLobby(lobbyVersion, onOpen, handlers) {
//   socketHandlers = {
//     onOpen,
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     options: {
//       name: 'lobby',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url: '/lobby/socket/v1',
//     version: lobbyVersion,
//     opts
//   });
// }


// function createDefault() {
//   // default socket is useless when anon.?
//   if (hasNetwork()) {
//     socketHandlers = {
//       events: defaultHandlers
//     };
//     const opts = {
//       options: {
//         name: 'default',
//         debug: false,
//         pingDelay: 2000,
//         registeredEvents: Object.keys(socketHandlers.events)
//       }
//     };
//     tellWorker(worker, 'create', {
//       clientId: oyunkeyfSri,
//       socketEndPoint: window.oyunkeyf.socketEndPoint,
//       url: '/socket',
//       version: 0,
//       opts
//     });
//   }
// }

// function onConnected() {
//   const wasOff = !connectedWS;
//   connectedWS = true;
//   clearTimeout(proxyFailTimeoutID);
//   clearTimeout(redrawOnDisconnectedTimeoutID);
//   if (wasOff) m.redraw();
// }

// function onDisconnected() {
//   const wasOn = connectedWS;
//   connectedWS = false;
//   if (wasOn) redrawOnDisconnectedTimeoutID = setTimeout(function() {
//     m.redraw();
//   }, 2000);
//   if (wasOn && !alreadyWarned && !storage.get('donotshowproxyfailwarning')) proxyFailTimeoutID = setTimeout(() => {
//     // check if disconnection lasts, it could mean a proxy prevents
//     // establishing a tunnel
//     if (hasNetwork() && !connectedWS) {
//       alreadyWarned = true;
//       window.navigator.notification.alert(proxyFailMsg, function() {
//         storage.set('donotshowproxyfailwarning', true);
//       });
//     }
//   }, 20000);
// }

// worker.addEventListener('message', function(msg) {
//   switch(msg.data.topic) {
//   case 'onOpen':
//     if (socketHandlers.onOpen) socketHandlers.onOpen();
//     break;
//   case 'disconnected':
//     onDisconnected();
//     break;
//   case 'connected':
//     onConnected();
//     break;
//   case 'onError':
//     if (socketHandlers.onError) socketHandlers.onError();
//     break;
//   case 'handle':
//     var h = socketHandlers.events[msg.data.payload.t];
//     if (h) h(msg.data.payload.d || null, msg.data.payload);
//     break;
//   }
// });

// // export default {
// //   createDefault,
// //   createMasa,
// //   createMasaHome,
// //   createGame,
// //   createLobby,
// //   setVersion(version) {
// //     tellWorker(worker, 'setVersion', version);
// //   },
// //   send(type, data, opts) {
// //     tellWorker(worker, 'send', [type, data, opts]);
// //   },
// //   connect() {
// //     tellWorker(worker, 'connect');
// //   },
// //   disconnect() {
// //     tellWorker(worker, 'disconnect');
// //   },
// //   isConnected() {
// //     return connectedWS;
// //   },
// //   destroy() {
// //     tellWorker(worker, 'destroy');
// //   },
// //   terminate() {
// //     if (worker) worker.terminate();
// //   }
// // };

},{"./config":136,"./http":137,"./session":146,"./storage":151,"./utils":208,"./utils/redraw":210,"./utils/worker":212}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var timeoutId;

exports.default = {
  spin: function spin() {
    if (timeoutId || document.getElementsByClassName('globalSpinner').length > 0) {
      return false;
    }

    var spinner = document.createElement('div');
    spinner.className = 'spinner globalSpinner';
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 40 40');
    var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', '20');
    circle.setAttribute('cy', '20');
    circle.setAttribute('r', '18');
    circle.setAttribute('fill', 'none');
    svg.appendChild(circle);
    spinner.appendChild(svg);

    timeoutId = setTimeout(function () {
      return document.body.appendChild(spinner);
    }, 200);
  },
  stop: function stop() {
    clearTimeout(timeoutId);
    timeoutId = null;
    var spinners = document.getElementsByClassName('globalSpinner');
    if (spinners.length) {
      setTimeout(function () {
        while (spinners[0]) {
          document.body.removeChild(spinners[0]);
        }
      }, 500);
    }
  },
  getVdom: function getVdom(classes) {
    return h(
      'div',
      { 'class': 'spinner ' + classes },
      h(
        'svg',
        { viewBox: '0 0 40 40' },
        h('circle', { cx: '20', cy: '20', r: '18', fill: 'none' })
      )
    );
  }
};

},{"mithril/hyperscript":113}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function withStorage(f) {
  // can throw an exception if storage is full
  try {
    return !!window.localStorage ? f(window.localStorage) : null;
  } catch (e) {}
}

function get(k) {
  return withStorage(function (s) {
    return JSON.parse(s.getItem(k));
  });
}
function remove(k) {
  return withStorage(function (s) {
    s.removeItem(k);
  });
}
function set(k, v) {
  return withStorage(function (s) {
    s.removeItem(k);
    s.setItem(k, JSON.stringify(v));
  });
}

function prop(key, initialValue) {
  return function () {
    if (arguments.length) set(key, arguments[0]);
    var ret = get(key);
    return ret !== null && ret !== undefined ? ret : initialValue;
  };
}

exports.default = {
  get: get,
  set: set,
  remove: remove,
  prop: prop
};

},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _utils = require('../../utils');

var _xhr = require('../../xhr');

var _sleep = require('../../utils/sleep');

var sleepUtils = _interopRequireWildcard(_sleep);

var _OnlineRound = require('../shared/round/OnlineRound');

var _OnlineRound2 = _interopRequireDefault(_OnlineRound);

var _roundView = require('../shared/round/view/roundView');

var _roundView2 = _interopRequireDefault(_roundView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  oninit: function oninit(_ref) {
    var _this = this;

    var attrs = _ref.attrs;

    var gameData = void 0;

    sleepUtils.keepAwake();

    if ((0, _utils.hasNetwork)()) {
      (0, _xhr.game)(attrs.id).then(function (data) {
        gameData = data;

        setTimeout(function () {
          _this.round = new _OnlineRound2.default(attrs.id, data);
        }, 400);
      }).catch(function (error) {
        (0, _utils.handleXhrError)(error);
        _router2.default.set('/');
      });
    }
  },
  oncreate: function oncreate(vnode) {
    if (vnode.dom) helper.elFadeIn(vnode.dom);
  },
  onremove: function onremove() {
    sleepUtils.allowSleepAgain();
    _socket2.default.destroy();
    if (this.round) {
      this.round.unload();
    }
  },
  view: function view(_ref2) {
    var attrs = _ref2.attrs;

    if (this.round) return (0, _roundView2.default)(this.round);

    return null;
  }
};

},{"../../i18n":138,"../../router":144,"../../socket":149,"../../utils":208,"../../utils/sleep":211,"../../xhr":213,"../helper":156,"../shared/round/OnlineRound":191,"../shared/round/view/roundView":198}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _popup = require('./shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _form = require('./shared/form');

var _form2 = _interopRequireDefault(_form);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _newGameForm = require('./newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _iscroll = require('iscroll');

var _iscroll2 = _interopRequireDefault(_iscroll);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _lobby = require('./lobby');

var _lobby2 = _interopRequireDefault(_lobby);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _ViewOnlyBoard = require('./shared/ViewOnlyBoard');

var _ViewOnlyBoard2 = _interopRequireDefault(_ViewOnlyBoard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scroller = null;

var gamesMenu = {};

gamesMenu.isOpen = false;

gamesMenu.open = function () {
  _backbutton2.default.stack.push(gamesMenu.close);
  gamesMenu.isOpen = true;
  setTimeout(function () {
    if (utils.hasNetwork() && scroller) scroller.goToPage(1, 0);
  }, 400);
  _session2.default.refresh();
};

gamesMenu.close = function (fromBB) {
  if (fromBB !== 'backbutton' && gamesMenu.isOpen) _backbutton2.default.stack.pop();
  gamesMenu.isOpen = false;
};

function joinGame(g) {
  gamesMenu.close();
  _mithril2.default.route('/game/' + g.fullId);
}

function cardDims() {
  var vp = _helper2.default.viewportDim();

  // if we're here it's a phone
  var width = 200;
  var height = width / (4 / 3);
  var margin = 10;
  return {
    w: width + margin * 2,
    h: height + 70,
    innerW: width,
    margin: margin
  };
}

function renderViewOnlyBoard(cDim, fen, orientation, variant) {
  var innerH = cDim ? cDim.innerW / (4 / 3) : 0;
  var innerW = cDim ? cDim.innerW : 0;
  var style = cDim ? { height: innerH + 'px' } : {};
  var bounds = cDim ? { width: innerW, height: innerH } : null;
  return h(
    'div',
    { className: 'boardWrapper', style: style },
    _mithril2.default.component(_ViewOnlyBoard2.default, { bounds: bounds, fen: fen, orientation: orientation, variant: variant })
  );
}

function timeLeft(g) {
  if (!g.isMyTurn) return (0, _i18n2.default)('waitingForOpponent');
  return (0, _i18n2.default)('yourTurn');
}

function renderGame(g, cDim, cardStyle) {
  var icon = utils.gameIcon(g.perf);
  var cardClass = ['card', 'standard'].join(' ');

  var timeClass = ['timeIndication', g.isMyTurn ? 'myTurn' : 'opponentTurn'].join(' ');
  var config = _helper2.default.ontouchX(function () {
    return joinGame(g);
  });

  return h(
    'div',
    { className: cardClass, key: 'game.' + g.gameId, style: cardStyle,
      config: config },
    renderViewOnlyBoard(cDim, g.fen, g.side, g.variant),
    h(
      'div',
      { className: 'infos' },
      h(
        'div',
        { className: 'description' },
        h(
          'p',
          null,
          h(
            'span',
            { className: 'variant' },
            g.variant.name
          ),
          h(
            'span',
            { className: timeClass },
            timeLeft(g)
          )
        )
      )
    )
  );
}

function renderAllGames(cDim) {
  var nowPlaying = _session2.default.nowPlaying(); // .concat(session.nowPlaying());
  var cardStyle = cDim ? {
    width: cDim.w - cDim.margin * 2 + 'px',
    height: cDim.h + 'px',
    marginLeft: cDim.margin + 'px',
    marginRight: cDim.margin + 'px'
  } : {};

  var nbCards = utils.hasNetwork() ? nowPlaying.length + 1 : 0;

  var wrapperStyle = void 0,
      wrapperWidth = void 0;
  if (cDim) {
    // scroller wrapper width
    // calcul is:
    // ((cardWidth + visible part of adjacent card) * nb of cards) +
    // wrapper's marginLeft
    wrapperWidth = (cDim.w + cDim.margin * 2) * nbCards + cDim.margin * 2;
    wrapperStyle = {
      width: wrapperWidth + 'px',
      marginLeft: cDim.margin * 3 + 'px'
    };
  }

  var allCards = nowPlaying.map(function (g) {
    return renderGame(g, cDim, cardStyle);
  });

  if (!_helper2.default.isWideScreen()) {

    var newGameCard = h(
      'div',
      { className: 'card standard', key: 'game.new-game', style: cardStyle,
        config: _helper2.default.ontouchX(function () {
          gamesMenu.close();_newGameForm2.default.open();
        }) },
      renderViewOnlyBoard(cDim),
      h(
        'div',
        { className: 'infos' },
        h(
          'div',
          { className: 'description' },
          h(
            'h2',
            { className: 'title' },
            (0, _i18n2.default)('createAGame')
          ),
          h(
            'p',
            null,
            (0, _i18n2.default)('newOpponent')
          )
        )
      )
    );
    if (utils.hasNetwork()) allCards.unshift(newGameCard);
  }

  return (0, _mithril2.default)('div#all_games', { style: wrapperStyle }, allCards);
}

gamesMenu.view = function () {
  if (!gamesMenu.isOpen) return null;

  var vh = _helper2.default.viewportDim().vh;
  var cDim = cardDims();
  var wrapperStyle = _helper2.default.isWideScreen() ? {} : { top: (vh - cDim.h) / 2 + 'px' };
  var wrapperConfig = _helper2.default.isWideScreen() ? utils.noop : function (el, isUpdate, context) {
    if (!isUpdate) {
      scroller = new _iscroll2.default(el, {
        scrollX: true,
        scrollY: false,
        momentum: false,
        snap: '.card',
        snapSpeed: 400,
        preventDefaultException: {
          tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|LABEL)$/
        }
      });

      context.unonload = function () {
        if (scroller) {
          scroller.destroy();
          scroller = null;
        }
      };
    }
    // see https://github.com/cubiq/iscroll/issues/412
    scroller.options.snap = el.querySelectorAll('.card');
    scroller.refresh();
  };

  var isWideScreen = _helper2.default.isWideScreen();

  var wrapperClass = isWideScreen ? 'overlay_popup' : '';

  return h(
    'div',
    { id: 'games_menu', className: 'overlay_popup_wrapper' },
    h('div', { className: 'wrapper_overlay_close',
      config: _helper2.default.ontouch(_helper2.default.fadesOut(gamesMenu.close, '.overlay_popup_wrapper')) }),
    h(
      'div',
      { id: 'wrapper_games', className: wrapperClass, style: wrapperStyle, config: wrapperConfig },
      isWideScreen ? h(
        'header',
        null,
        (0, _i18n2.default)('nbGamesInPlay', _session2.default.nowPlaying().length)
      ) : null,
      isWideScreen ? h(
        'div',
        { className: 'popup_content' },
        renderAllGames(null)
      ) : renderAllGames(cDim)
    )
  );
};

exports.default = gamesMenu;

},{"../backbutton":135,"../i18n":138,"../session":146,"../settings":147,"../utils":208,"./helper":156,"./lobby":160,"./newGameForm":173,"./shared/ViewOnlyBoard":184,"./shared/form":186,"./shared/popup":190,"iscroll":7,"mithril":114,"mithril/hyperscript":113}],154:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = animator;

var _utils = require('../../utils');

var animating = false;

// Author Barney Caroll
// taken from https://gist.github.com/barneycarroll/c69fbe0786e37c941baf

// Define an animator consisting of optional incoming and outgoing animations.
// alwaysAnimate is false unless specified as true: false means an incoming animation will only trigger if an outgoing animation is also in progress.
// forcing dontClone to true means the outward animation will use the original element rather than a clone. This could improve performance by recycling elements, but can lead to trouble: clones have the advantage of being stripped of all event listeners.
function animator(incoming, outgoing, alwaysAnimate, dontClone) {
  // The resulting animator can be applied to any number of components
  return function animate(x, y, z) {
    var config;
    var parent;
    var next;

    // When used as a config function
    if (x.nodeType) {
      return animationConfig(x, y, z);
    }
    // When passed a virtual DOM node (the output of m)
    else if (x.attrs) {
        return bindConfigTo(x);
      }
      // When applied to a Mithril module / component
      else if (x.view) {
          return {
            controller: x.controller || _utils.noop,
            view: function animatedView(ctrl) {
              return bindConfigTo(x.view(ctrl));
            }
          };
        }

    function bindConfigTo(node) {
      if (!node) return null;

      config = node.attrs.config;

      node.attrs.config = animationConfig;

      return node;
    }

    function animationConfig(el, init, context) {
      var output;
      var onunload;

      if (config) {
        output = config(el, init, context);
        // If the root element already has a config, it may also have an onunload which we should take care to preserve
        onunload = context.onunload;
      }

      if (!init) {
        if (incoming && alwaysAnimate || animating) {
          incoming(el, _utils.noop, context);
        }

        context.onunload = outgoing ? onunload ? function onunloadWrapper() {
          teardown();
          onunload();
        } : teardown : onunload;

        parent = el.parentElement;
        next = el.nextSibling;
      }

      return output;

      function teardown() {
        var insertion = dontClone ? el : el.cloneNode(true);
        var reference = null;

        if (next && parent && next.parentNode === parent) {
          reference = next;
        }

        animating = true;

        setTimeout(function resetAnimationFlag() {
          animating = false;
        }, 0);

        parent.insertBefore(insertion, reference);

        outgoing(insertion, function destroy() {
          if (parent.contains(insertion)) {
            parent.removeChild(insertion);
          }
        }, context);
      }
    }
  };
}

},{"../../utils":208}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ButtonHandler;

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HOLD_DURATION = 600;
var REPEAT_RATE = 20;
var SCROLL_TOLERANCE = 8;
var ACTIVE_CLASS = 'active';

function hasContextMenu() {
  return window.cordova.platformId !== 'ios';
}

function ButtonHandler(el, tapHandler, holdHandler, repeatHandler, scrollX, scrollY, touchEndFeedback) {

  var startX = void 0,
      startY = void 0,
      boundaries = void 0,
      active = void 0,
      holdTimeoutID = void 0,
      repeatTimeoutId = void 0,
      repeatIntervalID = void 0;

  if (typeof tapHandler !== 'function') throw new Error('ButtonHandler 2nd argument must be a function!');

  if (holdHandler && typeof holdHandler !== 'function') throw new Error('ButtonHandler 3rd argument must be a function!');

  if (repeatHandler && typeof repeatHandler !== 'function') throw new Error('ButtonHandler 4rd argument must be a function!');

  // http://ejohn.org/blog/how-javascript-timers-work/
  function onRepeat() {
    var res = repeatHandler();
    repeatIntervalID = setTimeout(onRepeat, REPEAT_RATE);
    if (!res) clearTimeout(repeatIntervalID);
    _mithril2.default.redraw();
  }

  function onTouchStart(e) {
    var touch = e.changedTouches[0];
    var boundingRect = el.getBoundingClientRect();
    startX = touch.clientX;
    startY = touch.clientY;
    boundaries = {
      minX: boundingRect.left,
      maxX: boundingRect.right,
      minY: boundingRect.top,
      maxY: boundingRect.bottom
    };
    active = true;
    setTimeout(function () {
      if (active) el.classList.add(ACTIVE_CLASS);
    }, 200);
    if (!hasContextMenu()) holdTimeoutID = setTimeout(onHold, HOLD_DURATION);
    clearTimeout(repeatIntervalID);
    if (repeatHandler) repeatTimeoutId = setTimeout(function () {
      repeatIntervalID = setTimeout(onRepeat, REPEAT_RATE);
    }, 150);
  }

  function onTouchMove(e) {
    // if going out of bounds, no way to reenable the button
    if (active) {
      var touch = e.changedTouches[0];
      active = isActive(touch);
      if (!active) {
        clearTimeout(holdTimeoutID);
        clearTimeout(repeatTimeoutId);
        clearTimeout(repeatIntervalID);
        el.classList.remove(ACTIVE_CLASS);
      }
    }
  }

  function onTouchEnd(e) {
    if (e.cancelable) e.preventDefault();
    clearTimeout(repeatTimeoutId);
    clearTimeout(repeatIntervalID);
    if (active) {
      clearTimeout(holdTimeoutID);
      if (touchEndFeedback) el.classList.add(ACTIVE_CLASS);
      tapHandler(e);
      active = false;
      setTimeout(function () {
        return el.classList.remove(ACTIVE_CLASS);
      }, 80);
    }
  }

  function onTouchCancel() {
    clearTimeout(holdTimeoutID);
    clearTimeout(repeatTimeoutId);
    clearTimeout(repeatIntervalID);
    active = false;
    el.classList.remove(ACTIVE_CLASS);
  }

  function onContextMenu(e) {
    e.preventDefault();
    e.stopPropagation();
    if (holdTimeoutID === undefined) onHold();
  }

  function onHold() {
    if (holdHandler) {
      holdHandler();
      active = false;
      el.classList.remove(ACTIVE_CLASS);
    }
  }

  function isActive(touch) {
    var x = touch.clientX,
        y = touch.clientY,
        b = boundaries,
        d = 0;
    if (scrollX) d = Math.abs(x - startX);
    if (scrollY) d = Math.abs(y - startY);
    return x < b.maxX && x > b.minX && y < b.maxY && y > b.minY && d < SCROLL_TOLERANCE;
  }

  el.addEventListener('touchstart', onTouchStart, false);
  el.addEventListener('touchmove', onTouchMove, false);
  el.addEventListener('touchend', onTouchEnd, false);
  el.addEventListener('touchcancel', onTouchCancel, false);
  el.addEventListener('contextmenu', onContextMenu, false);
}

},{"mithril":114}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ontap = ontap;
exports.ontapXY = ontapXY;
exports.slidesInUp = slidesInUp;
exports.slidesOutDown = slidesOutDown;
exports.elFadeIn = elFadeIn;
exports.getButton = getButton;
exports.viewportDim = viewportDim;
exports.findParentBySelector = findParentBySelector;
exports.getLI = getLI;
exports.classSet = classSet;
exports.clearCachedViewportDim = clearCachedViewportDim;

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _button = require('./button');

var _button2 = _interopRequireDefault(_button);

var _animator = require('./animator');

var _animator2 = _interopRequireDefault(_animator);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animDuration = 250;

function createTapHandler(tapHandler, holdHandler, repeatHandler, scrollX, scrollY, getElement, preventEndDefault) {
  return function (vnode) {
    (0, _button2.default)(vnode.dom, function (e) {
      tapHandler(e);
      (0, _redraw2.default)();
    }, holdHandler ? function (e) {
      return utils.autoredraw(function () {
        return holdHandler(e);
      });
    } : undefined, repeatHandler, scrollX, scrollY, getElement, preventEndDefault);
  };
}

function ontap(tapHandler, holdHandler, repeatHandler, getElement) {
  return createTapHandler(tapHandler, holdHandler, repeatHandler, false, false, getElement);
}

function ontapXY(tapHandler, holdHandler, getElement) {
  var preventEndDefault = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  return createTapHandler(tapHandler, holdHandler, undefined, true, true, getElement, preventEndDefault);
}

function slidesInUp(vnode) {
  var el = vnode.dom;
  el.style.transform = 'translateY(100%)';
  vnode.state.lol = el.offsetHeight;
  return (0, _zanimo2.default)(el, 'transform', 'translateY(0)', 250, 'ease-out').catch(console.log.bind(console));
}

function slidesOutDown(callback, elID) {
  return function (fromBB) {
    var el = document.getElementById(elID);
    return (0, _zanimo2.default)(el, 'transform', 'translateY(100%)', 250, 'ease-out').then(function () {
      return utils.autoredraw(function () {
        return callback(fromBB);
      });
    }).catch(console.log.bind(console));
  };
}

// el fade in transition, can be applied to any element
function elFadeIn(el) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : animDuration;
  var origOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0.5';
  var endOpacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '1';

  var tId = void 0;

  el.style.opacity = origOpacity;
  el.style.transition = 'opacity ' + duration + 'ms ease-out';

  setTimeout(function () {
    el.style.opacity = endOpacity;
  });

  function after() {
    clearTimeout(tId);
    if (el) {
      el.removeAttribute('style');
      el.removeEventListener('transitionend', after, false);
    }
  }

  el.addEventListener('transitionend', after, false);
  // in case transitionend does not fire
  tId = setTimeout(after, duration + 10);
}

function getButton(e) {
  var target = e.target;
  return target.tagName === 'BUTTON' ? target : findParentBySelector(target, 'button');
}

// OLD

//store temporarily last route to disable animations on same route
// TODO find a better way cause this is ugly
var lastRoute = void 0;

// this must be cached because of the access to document.body.style
var cachedTransformProp = void 0;
var cachedViewportDim = null;

function viewSlideIn(el, callback) {
  if (_mithril2.default.route() === lastRoute) {
    callback();
    return;
  }

  lastRoute = _mithril2.default.route();

  function after() {
    utils.setViewSlideDirection('fwd');
    el.removeAttribute('style');
    callback();
  }

  var direction = utils.getViewSlideDirection() === 'fwd' ? '100%' : '-100%';
  el.style.transform = 'translate3d(' + direction + ',0,0)';
  el.style.transition = 'transform 200ms ease-out';

  setTimeout(function () {
    el.style.transform = 'translate3d(0%,0,0)';
  });

  el.addEventListener('transitionend', after, false);
}

function viewSlideOut(el, callback) {
  if (_mithril2.default.route() === lastRoute) {
    callback();
    return;
  }

  function after() {
    utils.setViewSlideDirection('fwd');
    callback();
  }

  var direction = utils.getViewSlideDirection() === 'fwd' ? '-100%' : '100%';
  el.style.transform = 'translate3d(0%,0,0)';
  el.style.transition = 'transform 200ms ease-out';

  setTimeout(function () {
    el.style.transform = 'translate3d(' + direction + ',0,0)';
  });

  el.addEventListener('transitionend', after, false);
}

function viewFadesIn(el, callback) {
  var tId;

  el.style.opacity = '0.5';
  el.style.transition = 'opacity 200ms ease-out';

  setTimeout(function () {
    el.style.opacity = '1';
  });

  function after() {
    clearTimeout(tId);
    if (el) {
      el.removeAttribute('style');
      el.removeEventListener('transitioned', after, false);
    }
    callback();
  }

  el.addEventListener('transitioned', after, false);

  // in case transitioned does not fire
  // TODO find a way to avoid it
  tId = setTimeout(after, 250);
}

function viewFadesOut(el, callback) {
  var tId;

  el.style.opacity = '1';
  el.style.transition = 'opacity 200ms ease-out, visibility 0s linear 200ms';

  setTimeout(function () {
    el.style.opacity = '0';
    el.style.visibility = 'hidden';
  });

  function after() {
    clearTimeout(tId);
    callback();
  }

  el.addEventListener('transitioned', after, false);

  // in case transitioned does not fire
  // TODO find a way to avoid it
  tId = setTimeout(after, 250);
}

function collectionHas(coll, el) {
  for (var i = 0, len = coll.length; i < len; i++) {
    if (coll[i] === el) return true;
  }
  return false;
}

function findParentBySelector(el, selector) {
  var matches = document.querySelectorAll(selector);
  var cur = el.parentNode;
  while (cur && !collectionHas(matches, cur)) {
    cur = cur.parentNode;
  }
  return cur;
}

function ontouch(tapHandler, holdHandler, repeatHandler, scrollX, scrollY, touchEndFeedback) {
  return function (el, isUpdate) {
    if (!isUpdate) {
      (0, _button2.default)(el, function (e) {
        _mithril2.default.startComputation();
        try {
          tapHandler(e);
        } finally {
          _mithril2.default.endComputation();
        }
      }, holdHandler ? function () {
        return utils.autoredraw(holdHandler);
      } : null, repeatHandler, scrollX, scrollY, touchEndFeedback);
    }
  };
}

function computeTransformProp() {
  return 'transform' in document.body.style ? 'transform' : 'webkitTransform' in document.body.style ? 'webkitTransform' : 'mozTransform' in document.body.style ? 'mozTransform' : 'oTransform' in document.body.style ? 'oTransform' : 'msTransform';
}

function viewportDim() {
  if (cachedViewportDim) return cachedViewportDim;

  var e = document.documentElement;
  var vpd = cachedViewportDim = {
    vw: e.clientWidth,
    vh: e.clientHeight
  };
  return vpd;
}

function collectionHas(coll, el) {
  for (var i = 0, len = coll.length; i < len; i++) {
    if (coll[i] === el) return true;
  }
  return false;
}

function findParentBySelector(el, selector) {
  var matches = document.querySelectorAll(selector);
  var cur = el;
  while (cur && !collectionHas(matches, cur)) {
    cur = cur.parentNode;
  }
  return cur;
}

function getLI(e) {
  var target = e.target;
  return target.tagName === 'LI' ? target : findParentBySelector(target, 'LI');
}

function classSet(classes) {
  var arr = [];
  for (var i in classes) {
    if (classes[i]) arr.push(i);
  }
  return arr.join(' ');
}

function clearCachedViewportDim() {
  cachedViewportDim = null;
}

// export default {
//   slidingPage: animator(viewSlideIn, viewSlideOut),
//   fadingPage: animator(viewFadesIn, viewFadesOut),
//   viewportDim,
//   clearCachedViewportDim() {
//     cachedViewportDim = null;
//   },

//   transformProp: function() {
//     if (!cachedTransformProp) cachedTransformProp = computeTransformProp();
//     return cachedTransformProp;
//   },

//   slidesInUp: function(el, isUpdate, context) {
//     if (!isUpdate) {
//       el.style.transform = 'translateY(100%)';
//       // force reflow back
//       context.lol = el.offsetHeight;
//       Zanimo(el, 'transform', 'translateY(0)', 250, 'ease-out')
//         .catch(console.log.bind(console));
//     }
//   },
//   slidesOutDown: function(callback, elID) {
//     return function() {
//       const el = document.getElementById(elID);
//       m.redraw.strategy('none');
//       return Zanimo(el, 'transform', 'translateY(100%)', 250, 'ease-out')
//         .then(utils.autoredraw.bind(null, callback))
//         .catch(callback);
//     };
//   },

//   fadesOut: function(callback, selector, time = 150) {
//     return function(e) {
//       e.stopPropagation();
//       var el = selector ? findParentBySelector(e.target, selector) : e.target;
//       m.redraw.strategy('none');
//       return Zanimo(el, 'opacity', 0, time)
//         .then(() => utils.autoredraw(callback))
//         .catch(console.log.bind(console));
//     };
//   },

//   ontouch: function(tapHandler, holdHandler, repeatHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, repeatHandler, false, false, touchEndFeedback);
//   },
//   ontouchX: function(tapHandler, holdHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, null, true, false, touchEndFeedback);
//   },
//   ontouchY: function(tapHandler, holdHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, null, false, true, touchEndFeedback);
//   },
//   classSet: function(classes) {
//     var arr = [];
//     for (var i in classes) {
//       if (classes[i]) arr.push(i);
//     }
//     return arr.join(' ');
//   },

//   isWideScreen: function() {
//     return viewportDim().vw >= 600;
//   },
//   isIpadLike: function() {
//     const { vh, vw } = viewportDim();
//     return vh >= 700 && vw <= 1050;
//   },
//   isPortrait: function() {
//     return window.matchMedia('(orientation: portrait)').matches;
//   },
//   isLandscape: function() {
//     return window.matchMedia('(orientation: landscape)').matches;
//   },
//   progress: function (p) {
//     if (p === 0) return null;
//     return m('span', {
//       className: 'progress ' + (p > 0 ? 'positive' : 'negative'),
//       'data-icon': p > 0 ? 'N' : 'M'
//     }, Math.abs(p));
//   }
// };

},{"../../utils":208,"../../utils/redraw":210,"./animator":154,"./button":155,"mithril":114,"zanimo":131}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.body = body;

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _common = require('../shared/common');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function body(ctrl) {
  var nbPlayers = (0, _i18n2.default)('nbConnectedPlayers', ctrl.nbConnectedPlayers() || '?');
  var nbGames = (0, _i18n2.default)('nbGamesInPlay', ctrl.nbGamesInPlay() || '?');

  return h(
    'div',
    { className: 'native_scroller page' },
    h(
      'div',
      { className: 'home' },
      h(
        'section',
        { className: 'stats' },
        h(
          'div',
          { className: 'numPlayers' },
          nbPlayers
        ),
        h(
          'div',
          { className: 'numGames' },
          nbGames
        )
      ),
      renderQuickGame()
    )
  );

  // const header = headerWidget.bind(null, 'oyunkeyf.net');

  // return layout.free(header, body);
}

function renderQuickGame() {
  return h('div.homeCreate', [h('h2.homeTitle', 'Hemen oyna'), (0, _newGameForm.renderQuickSetup)(function () {
    return _newGameForm2.default.openRealtime('custom');
  })]);
}

},{"../../i18n":138,"../helper":156,"../layout":159,"../newGameForm":173,"../shared/common":185,"mithril":114,"mithril/hyperscript":113}],158:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stream = require('mithril/stream');

var _stream2 = _interopRequireDefault(_stream);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _utils = require('../../utils');

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _appMode = require('../../utils/appMode');

var _common = require('../shared/common');

var _homeView = require('./homeView');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit() {
    var nbConnectedPlayers = (0, _stream2.default)();
    var nbGamesInPlay = (0, _stream2.default)();

    function init() {
      if ((0, _appMode.isForeground)()) {
        _socket2.default.createLobby('homeLobby', _utils.noop, {
          n: function n(_, d) {
            nbConnectedPlayers(d.d);
            nbGamesInPlay(d.r);
            (0, _redraw2.default)();
          }
        });
      }
    }

    function onResume() {
      (0, _appMode.setForeground)();
      init();
    }

    if ((0, _utils.hasNetwork)()) {
      init();
    }

    document.addEventListener('online', init);
    document.addEventListener('resume', onResume);

    this.ctrl = {
      nbConnectedPlayers: nbConnectedPlayers,
      nbGamesInPlay: nbGamesInPlay
    };
  },
  view: function view() {
    var header = (0, _common.dropShadowHeader)('oyunkeyf.net');

    return _layout2.default.free(header, (0, _homeView.body)(this.ctrl));
  }
};

},{"../../socket":149,"../../utils":208,"../../utils/appMode":206,"../../utils/redraw":210,"../layout":159,"../shared/common":185,"./homeView":157,"mithril/stream":121}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _menu = require('./menu');

var menu = _interopRequireWildcard(_menu);

var _menuView = require('./menu/menuView');

var _menuView2 = _interopRequireDefault(_menuView);

var _MainBoard = require('./shared/layout/MainBoard');

var _MainBoard2 = _interopRequireDefault(_MainBoard);

var _gamesMenu = require('./gamesMenu');

var _gamesMenu2 = _interopRequireDefault(_gamesMenu);

var _newGameForm = require('./newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _loginModal = require('./loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _signupModal = require('./signupModal');

var _signupModal2 = _interopRequireDefault(_signupModal);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var background;

exports.default = {

  board: function board(header, content, overlay) {
    background = background;

    return (0, _hyperscript2.default)('div.view-container', { className: bgClass(background) }, [(0, _hyperscript2.default)(_MainBoard2.default, { header: header }, content),
    // h(MenuView),
    overlay]);
  },

  free: function free(header, content, footer, overlay) {
    background = background || _settings2.default.general.theme.background();

    return (0, _hyperscript2.default)('div.view-container', { className: bgClass(background) }, [(0, _hyperscript2.default)('main#page', { oncreate: handleMenuOpen }, [(0, _hyperscript2.default)('header.main_header', header), (0, _hyperscript2.default)('div#free_content.content.native_scroller', content), footer ? (0, _hyperscript2.default)('footer.main_footer', footer) : null, (0, _hyperscript2.default)('div#menu-close-overlay.menu-backdrop', { oncreate: menu.backdropCloseHandler })]), (0, _hyperscript2.default)(_menuView2.default), _loginModal2.default.view(), _signupModal2.default.view(), _newGameForm2.default.view(), overlay]);
  }
};


function handleMenuOpen() {}

function bgClass(bgTheme) {
  return bgTheme === 'dark' || bgTheme === 'light' ? bgTheme : 'transp ' + bgTheme;
}

},{"../settings":147,"./gamesMenu":153,"./helper":156,"./loginModal":161,"./menu":171,"./menu/menuView":172,"./newGameForm":173,"./shared/layout/MainBoard":188,"./signupModal":201,"mithril/hyperscript":113}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _xhr = require('../xhr');

var xhr = _interopRequireWildcard(_xhr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  startSeeking: function startSeeking(conf) {
    doStartSeeking(conf);
  }
};


function doStartSeeking(conf) {
  // router.backbutton.stack.push(userCancelSeeking);

  sendHook(conf);
}

function sendHook(setup) {
  xhr.seekGame(setup).then(function (data) {
    // console.log(data);
    _router2.default.set('/masa/' + data.id);
  }).catch(utils.handleXhrError);
}

// import * as utils from '../utils';
// import * as xhr from '../xhr';
// import m from 'mithril';

// let nbPlayers = 0;
// let nbGames = 0;

// const lobby = {};
// lobby.isOpen = false;

// lobby.startSeeking = function() {
//   xhr.newGame().then(function(data) {
//     // analytics
//     m.route('/masa/' + data.id);
//   }, function(error) {
//     utils.handleXhrError(error);
//     throw error;
//   });
// };


// export default lobby;

},{"../router":144,"../utils":208,"../utils/redraw":210,"../xhr":213}],161:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _signals = require('../signals');

var _signals2 = _interopRequireDefault(_signals);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _signupModal = require('./signupModal');

var _signupModal2 = _interopRequireDefault(_signupModal);

var _icons = require('./shared/icons');

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;
var formError = null;

exports.default = {
  open: open,
  close: close,
  view: function view() {
    if (!isOpen) return null;

    return (0, _hyperscript2.default)('div.modal#loginModal', { oncreate: helper.slidesInUp }, [(0, _hyperscript2.default)('header', [(0, _hyperscript2.default)('button.modal_close', {
      oncreate: helper.ontap(helper.slidesOutDown(close, 'loginModal'))
    }, _icons.closeIcon), (0, _hyperscript2.default)('h2', (0, _i18n2.default)('signIn'))]), (0, _hyperscript2.default)('div.modal_content', [(0, _hyperscript2.default)('form.login', {
      onsubmit: function onsubmit(e) {
        e.preventDefault();
        submit(e.target);
      }
    }, [formError ? (0, _hyperscript2.default)('div.form-error', formError) : null, (0, _hyperscript2.default)('div.field', [(0, _hyperscript2.default)('input#username', {
      type: 'text',
      className: formError ? 'form-error' : '',
      placeholder: (0, _i18n2.default)('username'),
      autocomplete: 'off',
      autocapitalize: 'off',
      autocorrect: 'off',
      spellcheck: false,
      required: true
    })]), (0, _hyperscript2.default)('div.field', [(0, _hyperscript2.default)('input#password', {
      type: 'password',
      className: formError ? 'form-error' : '',
      placeholder: (0, _i18n2.default)('password'),
      required: true
    })]), (0, _hyperscript2.default)('div.submit', [(0, _hyperscript2.default)('button.submitButton[data-icon=F]', (0, _i18n2.default)('signIn'))])]), (0, _hyperscript2.default)('div.signup', [(0, _i18n2.default)('newToOyunkeyf') + ' ', (0, _hyperscript2.default)('br'), (0, _hyperscript2.default)('a', {
      oncreate: helper.ontap(_signupModal2.default.open)
    }, [(0, _i18n2.default)('signUp')])])])]);
  }
};


function open() {
  _router2.default.backbutton.stack.push(helper.slidesOutDown(close, 'loginModal'));
  isOpen = true;
  formError = null;
}

function close(fromBB) {
  window.Keyboard.hide();
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

function submit(form) {
  var username = form['username'].value;
  var password = form['password'].value;
  if (!username || !password) return;

  (0, _redraw2.default)();
  window.Keyboard.hide();
  _session2.default.login(username, password).then(function () {
    close();
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    _signals2.default.afterLogin.dispatch();
    (0, _redraw2.default)();
    socket.reconnectCurrent();
    _session2.default.refresh();
  }).catch(function (err) {
    if (err.status !== 400 && err.status !== 401) (0, _utils.handleXhrError)(err);else {
      if (err.body.global) {
        formError = err.body.global[0];
        (0, _redraw2.default)();
      }
    }
  });
}

// OLD

var loginModal = {};

function submitOLD(form) {
  var login = form[0].value.trim();
  var pass = form[1].value;
  if (!login || !pass) return false;
  window.cordova.plugins.Keyboard.close();
  return _session2.default.login(login, pass).then(function () {
    loginModal.close();
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    // push.register();
    _session2.default.refresh().catch(function (err) {
      if (err.status === 401) {
        // https://github.com/veloce/lichobile/blob/master/project/src/js/ui/loginModal.js#L28
        window.navigator.notification.alert('oyunkeyfAuthenticationCannotWorkWithoutCookies');
      }
    });
  }).catch(utils.handleXhrError);
}

loginModal.open = function () {
  _backbutton2.default.stack.push(helper.slidesOutDown(loginModal.close, 'loginModal'));
  isOpen = true;
};

loginModal.close = function (fromBB) {
  window.cordova.plugins.Keyboard.close();
  if (fromBB !== 'backbutton' && isOpen) _backbutton2.default.stack.pop();
  isOpen = false;
};

loginModal.view = function () {
  if (!isOpen) return null;

  return m('div.modal#loginModal', { config: helper.slidesInUp }, [m('header', [m('button.modal_close[data-icon=L]', {
    config: helper.ontouch(helper.slidesOutDown(loginModal.close, 'loginModal'))
  }), m('h2', (0, _i18n2.default)('signIn'))]), m('div.modal_content', [m('form.login', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      return submit(e.target);
    }
  }, [m('input#pseudo[type=text]', {
    placeholder: (0, _i18n2.default)('username'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: 'false',
    required: true
  }), m('input#password[type=password]', {
    placeholder: (0, _i18n2.default)('password'),
    required: true
  }), m('button.fat', (0, _i18n2.default)('signIn'))]), m('div.signup', [m('a', {
    config: helper.ontouch(_signupModal2.default.open)
  }, [(0, _i18n2.default)('newToOyunkeyf'), ' ', (0, _i18n2.default)('signUp')])])])]);
};

// export default loginModal;

},{"../backbutton":135,"../i18n":138,"../router":144,"../session":146,"../signals":148,"../utils":208,"../utils/redraw":210,"./helper":156,"./shared/icons":187,"./signupModal":201,"mithril/hyperscript":113}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MasasListCtrl;

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _utils = require('../../utils');

var _masaXhr = require('./masaXhr');

var xhr = _interopRequireWildcard(_masaXhr);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MasasListCtrl(defaultTab) {
  var _this = this;

  this.currentTab = defaultTab || 0;

  xhr.currentMasas().then(function (data) {
    _this.masas = data;
    (0, _redraw2.default)();
  }).catch(_utils.handleXhrError);

  this.onTabChange = function (tabIndex) {
    var loc = window.location.search.replace(/\?tab\=\w+$/, '');

    try {
      window.history.replaceState(window.history.state, '', loc + '?tab=' + tabIndex);
    } catch (e) {
      console.error(e);
    }
    _this.currentTab = tabIndex;
    (0, _redraw2.default)();
  };
}

},{"../../utils":208,"../../utils/redraw":210,"./masaXhr":169}],163:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MasaCtrl;

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _utils = require('../../../utils');

var utils = _interopRequireWildcard(_utils);

var _masaXhr = require('../masaXhr');

var xhr = _interopRequireWildcard(_masaXhr);

var _faq = require('../faq');

var _faq2 = _interopRequireDefault(_faq);

var _socketHandler = require('./socketHandler');

var _socketHandler2 = _interopRequireDefault(_socketHandler);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MasaCtrl(id) {
  var _this = this;

  this.id = id;

  this.faqCtrl = _faq2.default.controller(this);

  xhr.masa(id).then(function (data) {
    _this.masa = data;
    _this.seatId = data.seatId;

    _this.startsAt = window.moment(data.startsAt).calendar();
    loadCurrentPage(_this.masa.standing);
    _this.hasJoined = !!(data.me && !data.me.withdraw);

    _socket2.default.createMasa(_this.id, _this.masa.socketVersion, (0, _socketHandler2.default)(_this));

    (0, _redraw2.default)();
  }).catch(function (err) {
    if (err.status === 404) {
      _this.notFound = true;
      (0, _redraw2.default)();
    } else {
      utils.handleXhrError(err);
    }
  });

  this.invite = (0, _throttle2.default)(function () {
    xhr.invite(_this.masa.id).then(function () {
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.join = (0, _throttle2.default)(function () {
    xhr.join(_this.masa.id).then(function () {
      _this.hasJoined = true;
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.withdraw = (0, _throttle2.default)(function () {
    xhr.withdraw(_this.masa.id).then(function () {
      _this.hasJoined = false;
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.reload = (0, _throttle2.default)(function () {
    xhr.reload(_this.id).then(onReload).catch(onXhrError);
  }, 2000);

  this.unload = function () {
    document.removeEventListener('resume', _this.reload);
  };

  var onReload = function onReload(data) {
    var oldData = _this.masa;
    _this.masa = data;
    _this.seatId = data.seatId;
    loadCurrentPage(data.standing);
    _this.hasJoined = !!(data.me && !data.me.withdraw);
    redirectToMyGame();
    (0, _redraw2.default)();
  };

  var redirectToMyGame = function redirectToMyGame() {
    var gameId = myCurrentGameId(_this);
    if (gameId) _router2.default.set('/masa/' + _this.masa.id + '/game/' + gameId, true);
  };

  var myCurrentGameId = function myCurrentGameId(ctrl) {
    var ids = {
      created: 10,
      started: 20,
      aborted: 25
    };

    var seatId = ctrl.seatId;
    if (!seatId) return null;
    var pairing = ctrl.masa.pairings.filter(function (p) {
      return p.s < ids.aborted && p.u.filter(function (id) {
        return id.toLowerCase() === seatId.toLowerCase();
      })[0];
    })[0];
    return pairing ? pairing.id : null;
  };

  var onXhrError = function onXhrError(err) {
    if (err.status === 404) {
      _this.notFound = true;
    }
    (0, _redraw2.default)();
  };

  var loadCurrentPage = function loadCurrentPage(data) {
    _this.currentPageResults = data.players;
  };
}

},{"../../../router":144,"../../../socket":149,"../../../utils":208,"../../../utils/redraw":210,"../faq":167,"../masaXhr":169,"./socketHandler":166,"lodash/throttle":109}],164:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _common = require('../../shared/common');

var _helper = require('../../helper');

var helper = _interopRequireWildcard(_helper);

var _layout = require('../../layout');

var _layout2 = _interopRequireDefault(_layout);

var _masaView = require('./masaView');

var _MasaCtrl = require('./MasaCtrl');

var _MasaCtrl2 = _interopRequireDefault(_MasaCtrl);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    this.ctrl = new _MasaCtrl2.default(attrs.id);
  },

  oncreate: helper.viewSlideIn,
  onremove: function onremove() {
    _socket2.default.destroy();
    this.ctrl.unload();
  },
  view: function view() {
    if (this.ctrl.notFound) {
      return _layout2.default.free((0, _common.dropShadowHeader)(null, (0, _common.backButton)((0, _i18n2.default)('masaNotFound'))), (0, _hyperscript2.default)('div.masaNotFound', { key: 'masa-not-found' }, [(0, _hyperscript2.default)('p', (0, _i18n2.default)('masaDoesNotExist')), (0, _hyperscript2.default)('p', (0, _i18n2.default)('masaMayHaveBeenCanceled'))]));
    }

    var masa = this.ctrl.masa;
    var header = void 0;

    if (masa) {
      header = (0, _common.dropShadowHeader)(null, (0, _common.backButton)((0, _hyperscript2.default)('div.main_header_title.withSub', [(0, _hyperscript2.default)('h1', [(0, _hyperscript2.default)('span.fa.fa-trophy'), this.ctrl.masa.fullName]), (0, _hyperscript2.default)('h2.header-subTitle.masa-subTitle', !masa.isFinished && !masa.isStarted ? (0, _masaView.timeInfo)('created', masa.playersToStart, 'Oyuncu bekleniyor') : (0, _masaView.timeInfo)('started', masa.roundsToFinish, ''))])));
    } else {
      header = (0, _common.connectingDropShadowHeader)();
    }

    var body = (0, _masaView.masaBody)(this.ctrl);
    var footer = (0, _masaView.renderFooter)(this.ctrl);
    var faqOverlay = (0, _masaView.renderFAQOverlay)(this.ctrl);
    var overlay = [faqOverlay];

    return _layout2.default.free(header, body, footer, overlay);
  }
};

},{"../../../i18n":138,"../../../socket":149,"../../helper":156,"../../layout":159,"../../shared/common":185,"./MasaCtrl":163,"./masaView":165,"mithril/hyperscript":113}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderFAQOverlay = renderFAQOverlay;
exports.masaBody = masaBody;
exports.renderFooter = renderFooter;
exports.timeInfo = timeInfo;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _session = require('../../../session');

var _session2 = _interopRequireDefault(_session);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../../helper');

var helper = _interopRequireWildcard(_helper);

var _settings = require('../../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _faq = require('../faq');

var _faq2 = _interopRequireDefault(_faq);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderFAQOverlay(ctrl) {
  return [_faq2.default.view(ctrl.faqCtrl)];
}

function masaBody(ctrl) {
  var data = ctrl.masa;
  if (!data) return null;

  return (0, _hyperscript2.default)('div.masaContainer.native_scroller.page', [masaHeader(data, ctrl), data.podium ? masaPodium(data.podium) : null, masaLeaderboard(ctrl)]);
}

function renderFooter(ctrl) {
  var m = ctrl.masa;
  if (!m) return null;
  var mUrl = 'https://oyunkeyf.net/masa/' + m.id;

  return (0, _hyperscript2.default)(
    'div',
    { className: 'actions_bar' },
    (0, _hyperscript2.default)(
      'button',
      { key: 'faq', className: 'action_bar_button', oncreate: helper.ontap(ctrl.faqCtrl.open) },
      (0, _hyperscript2.default)('span', { className: 'fa fa-question-circle' }),
      'SSS'
    ),
    ctrl.hasJoined ? withdrawButton(ctrl, m) : joinButton(ctrl, m)
  );
}

function timeInfo(key, rounds, preceedingText) {
  if (rounds === undefined) return null;

  return [preceedingText ? preceedingText + ' ' : null];
}

function masaHeader(data, ctrl) {
  return (0, _hyperscript2.default)(
    'div',
    { key: 'header', className: 'masaHeader' },
    masaTimeInfo(data),
    masaCreatorInfo(data, ctrl.startsAt)
  );
}

function masaTimeInfo(data) {
  var variant = data.variant;
  var control = data.scores;
  return (0, _hyperscript2.default)(
    'div',
    { className: 'masaTimeInfo' },
    (0, _hyperscript2.default)(
      'strong',
      { className: 'masaInfo withIcon' },
      variant + ' • ' + control
    )
  );
}

function masaCreatorInfo(data, startsAt) {
  return (0, _hyperscript2.default)(
    'div',
    { className: 'masaCreatorInfo' },
    (0, _i18n2.default)('by', data.createdBy),
    '\xA0\u2022\xA0',
    startsAt
  );
}

function joinButton(ctrl, m) {
  if (!_session2.default.isConnected() || m.isFinished) {
    return null;
  }
  var action = function action() {
    return ctrl.join();
  };
  return (0, _hyperscript2.default)(
    'button',
    { key: 'join', className: 'action_bar_button', oncreate: helper.ontap(action) },
    (0, _hyperscript2.default)('span', { className: 'fa fa-play' }),
    (0, _i18n2.default)('join')
  );
}

function withdrawButton(ctrl, m) {
  if (m.isFinished) {
    return null;
  }
  return (0, _hyperscript2.default)(
    'button',
    { key: 'withdraw', className: 'action_bar_button', oncreate: helper.ontap(ctrl.withdraw) },
    (0, _hyperscript2.default)('span', { className: 'fa fa-flag' }),
    (0, _i18n2.default)('withdraw')
  );
}

function masaLeaderboard(ctrl) {

  var data = ctrl.masa;
  var players = ctrl.currentPageResults;
  var user = _session2.default.get();
  var userName = user ? user.username : '';

  return (0, _hyperscript2.default)(
    'div',
    { key: 'leaderboard', className: 'masaLeaderboard' },
    data.nbPlayers > 0 ? (0, _hyperscript2.default)(
      'p',
      { className: 'masaTitle' },
      ' ',
      (0, _i18n2.default)("leaderboard"),
      ' (',
      (0, _i18n2.default)('nbConnectedPlayers', data.nbPlayers),
      ')'
    ) : null,
    (0, _hyperscript2.default)(
      'ul',
      { className: 'masaStandings' },
      players.map(function (p) {
        return renderPlayerEntry(ctrl, userName, p);
      })
    )
  );
}

function renderPlayerEntry(ctrl, userName, player) {
  var isMe = player.name === userName;

  return !player.active ? (0, _hyperscript2.default)(
    'li',
    { key: player.id, className: 'list-item masa-list-player' },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaPlayer' },
      (0, _hyperscript2.default)(
        'span',
        { className: 'flagRank', 'data-icon': player.withdraw ? 'b' : '' },
        ' ',
        player.withdraw ? '' : player.rank + '. '
      ),
      (0, _hyperscript2.default)(
        'span',
        null,
        ' ',
        (0, _i18n2.default)('emptySeat')
      ),
      (0, _hyperscript2.default)(
        'button',
        { oncreate: helper.ontap(ctrl.invite) },
        (0, _i18n2.default)('inviteBot')
      )
    ),
    (0, _hyperscript2.default)(
      'span',
      { className: 'masaPoints ', 'data-icon': 'Q' },
      player.score
    )
  ) : (0, _hyperscript2.default)(
    'li',
    { className: 'list-item masa-list-player ' + (isMe ? 'masa-me' : '') },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaPlayer' },
      (0, _hyperscript2.default)(
        'span',
        { className: 'flagRank', 'data-icon': player.withdraw ? 'b' : '' },
        ' ',
        player.withdraw ? '' : player.rank + '. '
      ),
      (0, _hyperscript2.default)(
        'span',
        null,
        ' ',
        !player.name ? 'Anonymous' : player.name + ' (' + player.rating + ') '
      )
    ),
    (0, _hyperscript2.default)(
      'span',
      { className: 'masaPoints ', 'data-icon': 'Q' },
      player.score
    )
  );
}

},{"../../../i18n":138,"../../../router":144,"../../../session":146,"../../../settings":147,"../../helper":156,"../faq":167,"mithril/hyperscript":113}],166:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ctrl) {
  return {
    reload: ctrl.reload,
    redirect: function redirect(gameId) {
      // doesn't fire for new join
      console.log("redirect" + gameId);
    }
  };
};

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"../../../router":144,"../../../utils/redraw":210}],167:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: function controller(masa) {
    var _isOpen = false;

    function open() {
      _router2.default.backbutton.stack.push(close);
      _isOpen = true;
    }
    function close(fromBB) {
      if (fromBB !== 'backbutton' && _isOpen) _router2.default.backbutton.stack.pop();
      _isOpen = false;
    }

    return {
      open: open,
      close: close,
      isOpen: function isOpen() {
        return _isOpen;
      },
      masa: masa
    };
  },
  view: function view(ctrl) {
    if (!ctrl.isOpen()) return null;
    var masa = ctrl.masa;

    if (!masa) return null;

    return h(
      'div',
      { className: 'modal', id: 'masaFaqModal', config: helper.slidesInUp },
      h(
        'header',
        null,
        h('button', { className: 'modal_close', 'data-icon': 'L',
          oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, "masaFaqModal")) }),
        h(
          'h2',
          null,
          (0, _i18n2.default)('masaFAQ')
        )
      ),
      h(
        'div',
        { className: 'modal_content' },
        h(
          'div',
          { className: 'masaFaq' },
          h(
            'h2',
            null,
            'Puanl\u0131 m\u0131?'
          ),
          masa.rated === undefined ? 'Bazı masalar puanlıdır ve reytinginizi etkiler.' : masa.rated ? 'Bu masa puanlıdır ve reytinginizi etkiler.' : 'Bu masa puanlı *değildir* ve reytinginizi *etkilemez*.',
          h(
            'h2',
            null,
            ' Puanlar nas\u0131l hesaplan\u0131r? '
          ),
          'Masaya kat\u0131l\u0131mda her oyuncu ortaya el say\u0131s\u0131 kadar puan\u0131n\u0131 koyar. Masa sonunda ortadaki puanlar \u015F\xF6yle da\u011F\u0131t\u0131l\u0131r:',
          h(
            'ul',
            null,
            h(
              'li',
              null,
              '1. %50 puan'
            ),
            h(
              'li',
              null,
              '2. %25 puan'
            ),
            h(
              'li',
              null,
              '3. %15 puan'
            ),
            h(
              'li',
              null,
              '4. %10 puan'
            )
          ),
          '\xD6rne\u011Fin 10 ellik bir oyunda oyuncular\u0131n puanlar\u0131 1500 olsun. Masaya kat\u0131ld\u0131klar\u0131nda puanlar\u0131 1490 olur. Ortada toplam 40 puan vard\u0131r, ve \u015F\xF6yle da\u011F\u0131t\u0131l\u0131r:',
          h(
            'ul',
            null,
            h(
              'li',
              null,
              '1. +20 = 1510'
            ),
            h(
              'li',
              null,
              '2. +10 = 1500'
            ),
            h(
              'li',
              null,
              '3. +6 = 1496'
            ),
            h(
              'li',
              null,
              '4. +4 = 1494'
            )
          ),
          'Masa bitmeden ayr\u0131lan oyuncu puan alamaz.',
          h(
            'h2',
            null,
            ' Kazanan nas\u0131l belirlenir? '
          ),
          'Masada b\xFCt\xFCn eller oynand\u0131ktan sonra en az cezas\u0131 olan oyuncu galip ilan edilir.',
          h(
            'h2',
            null,
            ' Masada eslestirme nasil yapilir? '
          ),
          'Masaya 4 oyuncu katildiginda el baslar. Bir el bittikten sonra yeni el baslar, yeni ele katilmak icin oyuncular masaya geri donmelidir.',
          h(
            'h2',
            null,
            ' Masa ne zaman biter? '
          ),
          'Masada el say\u0131s\u0131 kadar oyun oynand\u0131\u011F\u0131nda masa biter.',
          h(
            'h2',
            null,
            ' Oyundan ayr\u0131lma '
          ),
          'Oyun devam ederken oyundan ayrilan oyuncu masadan atilir, ve o el iptal olur. Masa bitmeden masadan ayr\u0131lan oyuncu puan alamaz.',
          h(
            'h2',
            null,
            ' Di\u011Fer \xF6nemli kurallar '
          ),
          'Siraniz geldiginde, oyanama s\xFCrenizi a\u015Farsan\u0131z sistem sizin yerinize oynar.'
        )
      )
    );
  }
};

},{"../../backbutton":135,"../../i18n":138,"../../router":144,"../helper":156,"mithril/hyperscript":113}],168:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('../../utils');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _MasasListCtrl = require('./MasasListCtrl');

var _MasasListCtrl2 = _interopRequireDefault(_MasasListCtrl);

var _masasListView = require('./masasListView');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  oncreate: helper.viewFadeIn,

  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    // socket.createDefault()

    this.ctrl = new _MasasListCtrl2.default((0, _utils.safeStringToNum)(attrs.tab));
  },
  view: function view() {
    var ctrl = this.ctrl;

    var body = (0, _masasListView.renderMasasList)(ctrl);
    var footer = (0, _masasListView.renderFooter)();
    var overlay = null;

    return _layout2.default.free((0, _common.header)((0, _i18n2.default)('masas')), body, footer, overlay);
  }
};

},{"../../i18n":138,"../../session":146,"../../utils":208,"../helper":156,"../layout":159,"../shared/common":185,"./MasasListCtrl":162,"./masasListView":170}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.currentMasas = currentMasas;
exports.masa = masa;
exports.reload = reload;
exports.join = join;
exports.invite = invite;
exports.withdraw = withdraw;

var _http = require('../../http');

function currentMasas() {
  return (0, _http.fetchJSON)('/masa', {}, true);
}

function masa(id) {
  return (0, _http.fetchJSON)('/masa/' + id, { query: { socketVersion: 1 } }, true);
}

function reload(id, page) {
  return (0, _http.fetchJSON)('/masa/' + id, { method: 'GET', query: page ? { page: page } : {} });
}

function join(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/join', { method: 'POST' }, true);
}

function invite(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/invite', { method: 'POST' }, true);
}

function withdraw(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/withdraw', { method: 'POST' }, true);
}

// import { request } from '../../http';

// export function currentMasas() {
//   return request('/masa', {}, true);
// }

// export function masa(id) {
//   return request('/masa/' + id, { data: {socketVersion: 1}}, true);
// }

// export function reload(id) {
//   return request('/masa/' + id,
//                  {
//                    method: 'GET',
//                    data: {},
//                    background: true
//                  });
// }

// export function join(id, side) {
//   side = side ? `?side=${side}`: '';
//   return request('/masa/' + id + '/join' + side, { method: 'POST' }, true);
// }

// export function withdraw(id) {
//   return request('/masa/' + id + '/withdraw', { method: 'POST' }, true);
// }

},{"../../http":137}],170:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderMasasList = renderMasasList;
exports.renderMasaList = renderMasaList;
exports.renderFooter = renderFooter;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _utils = require('../../utils');

var _TabNavigation = require('../shared/TabNavigation');

var _TabNavigation2 = _interopRequireDefault(_TabNavigation);

var _TabView = require('../shared/TabView');

var _TabView2 = _interopRequireDefault(_TabView);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TABS = [{
  label: 'Açık'
}, {
  label: 'Oynanan'
}, {
  label: 'Biten'
}];

function onMasaTap(e) {
  var el = helper.getLI(e);
  var ds = el.dataset;
  if (el && ds.id) {
    _router2.default.set('/masa/' + ds.id);
  }
}

function renderMasasList(ctrl) {
  if (!ctrl.masas) return null;

  var tabsContent = [ctrl.masas['created'], ctrl.masas['started'], ctrl.masas['finished']];

  return [(0, _hyperscript2.default)('div.tabs-nav-header.subHeader', (0, _hyperscript2.default)(_TabNavigation2.default, {
    buttons: TABS,
    selectedIndex: ctrl.currentTab,
    onTabChange: ctrl.onTabChange
  }), (0, _hyperscript2.default)('div.main_header_drop_shadow')), (0, _hyperscript2.default)(_TabView2.default, {
    className: 'masaTabsWrapper',
    selectedIndex: ctrl.currentTab,
    content: tabsContent,
    renderer: renderMasaList,
    onTabChange: ctrl.onTabChange
  })];
}

function renderMasaList(list) {
  return (0, _hyperscript2.default)('ul.native_scroller.masaList', {
    oncreate: helper.ontapXY(onMasaTap, undefined, helper.getLI)
  }, list.map(renderMasaListItem));
}

function renderMasaListItem(masa, index) {
  var mode = masa.rated ? (0, _i18n2.default)('rated') : (0, _i18n2.default)('casual');
  var variant = (0, _utils.capitalize)(masa.variant.short);
  var evenOrOdd = index % 2 === 0 ? ' even ' : ' odd ';
  var scores = masa.scores;
  var rounds = masa.rounds;

  return (0, _hyperscript2.default)(
    'li',
    { key: masa.id,
      className: 'list_item masa_item' + evenOrOdd,
      'data-id': masa.id
    },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaListName' },
      (0, _hyperscript2.default)(
        'div',
        { className: 'fullName' },
        masa.fullName
      ),
      (0, _hyperscript2.default)(
        'small',
        { className: 'infos' },
        variant,
        ' ',
        mode,
        ' \u2022 ',
        scores ? scores + ' ' + (0, _i18n2.default)('points') : (0, _i18n2.default)('rounds', rounds)
      )
    ),
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaListTime' },
      (0, _hyperscript2.default)(
        'small',
        { className: 'nbUsers withIcon', 'data-icon': 'r' },
        masa.nbPlayers
      )
    )
  );
}

function renderFooter() {
  return (0, _hyperscript2.default)(
    'div',
    { className: 'actions_bar' },
    (0, _hyperscript2.default)(
      'button',
      { key: 'createMasa', className: 'action_create_button' },
      (0, _hyperscript2.default)('span', { className: 'fa fa-plus-circle' }),
      (0, _i18n2.default)('createANewMasa')
    )
  );
}

},{"../../i18n":138,"../../router":144,"../../utils":208,"../helper":156,"../shared/TabNavigation":182,"../shared/TabView":183,"mithril/hyperscript":113}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backdropCloseHandler = exports.mainMenuCtrl = exports.profileMenuOpen = undefined;
exports.route = route;
exports.popup = popup;

var _stream = require('mithril/stream');

var _stream2 = _interopRequireDefault(_stream);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _SideMenuCtrl = require('../shared/sideMenu/SideMenuCtrl');

var _SideMenuCtrl2 = _interopRequireDefault(_SideMenuCtrl);

var _helper = require('../helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var profileMenuOpen = exports.profileMenuOpen = (0, _stream2.default)(false);

function onMenuOpen() {}

function onMenuClose() {}

var mainMenuCtrl = exports.mainMenuCtrl = new _SideMenuCtrl2.default('left', 'side_menu', 'menu-close-overlay', onMenuOpen, onMenuClose);

function route(route) {
  return function () {
    return mainMenuCtrl.close().then(function () {
      return _router2.default.set(route);
    });
  };
}

function popup(action) {
  return function () {
    return mainMenuCtrl.close().then(function () {
      action();
      (0, _redraw2.default)();
    });
  };
}

var backdropCloseHandler = exports.backdropCloseHandler = (0, _helper.ontap)(function () {
  mainMenuCtrl.close();
});

var menu = {};

/* properties */
menu.isOpen = false;
// menu.headerOpen = m.prop(false);

menu.route = function (route) {
  return function () {
    return menu.close().then(_mithril2.default.route.bind(null, route));
  };
};

menu.popup = function (action) {
  return function () {
    return menu.close().then(function () {
      action();
      _mithril2.default.redraw();
    });
  };
};

menu.toggle = function () {
  if (menu.isOpen) menu.close();else menu.open();
};

menu.open = function () {
  _backbutton2.default.stack.push(menu.close);
  menu.isOpen = true;
};

menu.willClose = false;
menu.close = function (fromBB) {
  var sideMenu = document.getElementById('side_menu');

  if (menu.willClose || !sideMenu) return Promise.resolve(null);

  menu.willClose = true;
  if (fromBB !== 'backbutton' && menu.isOpen) _backbutton2.default.stack.pop();
  _mithril2.default.redraw.strategy('none');
  return (0, _zanimo2.default)(sideMenu, 'transform', 'translate3d(-100%,0,0', 250, 'ease-out').then(function () {
    menu.headerOpen(false);
    menu.isOpen = false;
    menu.willClose = false;
    _mithril2.default.redraw();
  }).catch(function (err) {
    console.error(err);
    menu.headerOpen(false);
    menu.isOpen = false;
    menu.willClose = false;
    _mithril2.default.redraw();
  });
};

menu.toggleHeader = function () {
  return menu.headerOpen() ? menu.headerOpen(false) : menu.headerOpen(true);
};

exports.default = menu;

},{"../../backbutton":135,"../../router":144,"../../utils/redraw":210,"../helper":156,"../shared/sideMenu/SideMenuCtrl":199,"mithril":114,"mithril/stream":121,"zanimo":131}],172:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _loginModal = require('../loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _utils = require('../../utils');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _ = require('.');

var menu = _interopRequireWildcard(_);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  onbeforeupdate: function onbeforeupdate() {
    return menu.mainMenuCtrl.isOpen;
  },
  view: function view() {
    var user = _session2.default.get();

    return h(
      'aside',
      { id: 'side_menu' },
      renderHeader(user),
      h(
        'div',
        { className: 'native_scroller side_menu_scroller' },
        user && menu.profileMenuOpen() ? renderProfileActions(user) : renderLinks(user)
      )
    );
  }
};


function renderHeader(user) {
  var profileLink = user ? menu.route('/@/' + user.id) : _utils.noop;

  return h(
    'header',
    { className: 'side_menu_header' },
    (0, _utils.hasNetwork)() && !user ? h(
      'button',
      { className: 'signInButton', oncreate: helper.ontapXY(_loginModal2.default.open) },
      (0, _i18n2.default)('signIn')
    ) : null,
    user ? h(
      'h2',
      { className: 'username', oncreate: helper.ontapXY(profileLink) },
      user.username
    ) : null
  );
}

function slidesInUp(el, isUpdate, context) {
  if (!isUpdate) {
    el.style.transform = 'translate3d(-100%, 0, 0)';
    // force reflow back
    context.lol = el.offsetHeight;
    (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out');
  }
}

function renderLinks(user) {

  return h(
    'ul',
    { className: 'side_links',
      oncreate: helper.ontapXY(onLinkTap, undefined, helper.getLI) },
    h(
      'li',
      { className: 'side_link', 'data-route': '/' },
      h('span', { className: 'fa fa-home' }),
      (0, _i18n2.default)('home')
    ),
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'sep_link', key: 'sep_link_online' },
      (0, _i18n2.default)('playOnline')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-popup': 'createAGame' },
      h('span', { className: 'fa fa-plus-circle' }),
      (0, _i18n2.default)('createAGame')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/masas' },
      h('span', { className: 'fa fa-trophy' }),
      (0, _i18n2.default)('masas')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/players' },
      h('span', { className: 'fa fa-at' }),
      (0, _i18n2.default)('players')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/ranking' },
      h('span', { className: 'fa fa-cubes' }),
      (0, _i18n2.default)('leaderboard')
    ) : null,
    h('li', { className: 'hr' }),
    h(
      'li',
      { className: 'side_link', 'data-route': '/settings' },
      h('span', { className: 'fa fa-cog' }),
      (0, _i18n2.default)('settings')
    )
  );
}

function renderProfileActions(user) {
  return h(
    'ul',
    { className: 'side_links profileActions' },
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(menu.route('/@/' + user.id)) },
      h('span', { 'data-icon': 'r' }),
      (0, _i18n2.default)('profile')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(menu.route('/settings/preferences')) },
      h('span', { 'data-icon': '%' }),
      (0, _i18n2.default)('preferences')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(function () {
          _session2.default.logout();
          menu.headerOpen(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

var popupActionMap = {
  'createAGame': function createAGame() {
    return _newGameForm2.default.openRealtime();
  }
};

function onLinkTap(e) {
  var el = helper.getLI(e);
  var ds = el.dataset;
  if (el && ds.route) {
    menu.route(ds.route)();
  } else if (el && ds.popup) {
    menu.popup(popupActionMap[ds.popup])();
  }
}

// OLD

function renderProfileActionsOLD(user) {
  return h(
    'ul',
    { className: 'side_links profileActions' },
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(menu.route('/@/' + user.id)) },
      h('span', { className: 'fa fa-user' }),
      (0, _i18n2.default)('profile')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(menu.route('/settings/preferences')) },
      h('span', { 'data-icon': '%' }),
      (0, _i18n2.default)('preferences')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(function () {
          _session2.default.logout();
          menu.profileMenuOpen(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

function renderMenu() {
  var user = _session2.default.get();
  return h(
    'div',
    { className: 'native_scroller' },
    renderHeader(user),
    user && menu.headerOpen() ? renderProfileActions(user) : renderLinks(user)
  );
}

},{".":171,"../../i18n":138,"../../session":146,"../../utils":208,"../helper":156,"../loginModal":161,"../newGameForm":173,"mithril/hyperscript":113,"zanimo":131}],173:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderQuickSetup = renderQuickSetup;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _setup = require('../oyunkeyf/setup');

var _popup = require('./shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _form = require('./shared/form');

var _form2 = _interopRequireDefault(_form);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _xhr = require('../xhr');

var xhr = _interopRequireWildcard(_xhr);

var _lobby = require('./lobby');

var _lobby2 = _interopRequireDefault(_lobby);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;

var humanSetup = _settings2.default.gameSetup.human;

exports.default = {
  open: open,
  close: close,
  openRealtime: function openRealtime() {
    open();
  },
  view: function view() {
    return (0, _popup2.default)('new_game_form_popup game_form_popup', undefined, renderContent, isOpen, close);
  }
};


function open() {
  _router2.default.backbutton.stack.push(close);
  isOpen = true;
}

function close(fromBB) {
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

function renderContent() {
  var conf = humanSetup;

  return (0, _hyperscript2.default)('div', [(0, _hyperscript2.default)('div.newGame-preset_switch', [renderCustomSetup('human', conf, conf.availableVariants)])]);
}

function renderCustomSetup(formName, settingsObj, variants) {
  var generalFieldset = [(0, _hyperscript2.default)('div.select_input', {
    key: formName + 'variant'
  }, _form2.default.renderSelect('variant', formName + 'variant', variants, settingsObj.variant))];

  var modes = [['casual', '0'], ['rated', '1']];

  generalFieldset.push((0, _hyperscript2.default)('div.select_input', {
    key: formName + 'mode'
  }, _form2.default.renderSelect('mode', formName + 'mode', modes, settingsObj.mode)));

  var timeFieldset = [];

  timeFieldset.push((0, _hyperscript2.default)('div.select_input.inline', {
    key: formName + 'round'
  }, _form2.default.renderSelect('rounds', formName + 'rounds', _settings2.default.gameSetup.availableRounds, settingsObj.rounds, false)));

  return (0, _hyperscript2.default)('form.game_form', {
    key: 'customSetup',
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      close();
      goSeek((0, _setup.humanSetupFromSettings)(settingsObj));
    }
  }, [(0, _hyperscript2.default)('fieldset', generalFieldset), (0, _hyperscript2.default)('fieldset', timeFieldset), (0, _hyperscript2.default)('div.popupActionWrapper', [(0, _hyperscript2.default)('button[data-icon=E][type=submit].popupAction', (0, _i18n2.default)('createAGame'))])]);
}

function renderQuickSetup(onCustom) {
  return (0, _hyperscript2.default)('div.newGame-pools', { key: 'quickSetup' }, (0, _hyperscript2.default)('div.newGame-pool', {
    key: 'pool-custom',
    oncreate: helper.ontap(onCustom)
  }, (0, _hyperscript2.default)('div.newGame-custom', 'Özel')));
}

function goSeek(conf) {
  close();

  _lobby2.default.startSeeking(conf);
}

// export function renderQuickSetup() {
//   return h('div.newGame-pools', { key: 'quickSetup' },
//            xhr.cachedPools.map(p => renderPool(p))
//           );
// }

// function renderPool(p) {
//   return h('div.newGame-pool', {
//     key: 'pool-' + p.id,
//     oncreate: helper.ontap(() => {
//       console.log('oncreate');
//     })
//   }, [h('div.newGame-rounds', p.id),
//       h('div.newGame-perf', p.perf)
//      ]);
// }

// const newGameForm = {};

// newGameForm.isOpen = false;

// newGameForm.open = function() {
//   backbutton.stack.push(newGameForm.close);
//   newGameForm.isOpen = true;
// };

// newGameForm.close = function(fromBB) {
//   if (fromBB !== 'backbutton' && newGameForm.isOpen) backbutton.stack.pop();
//   newGameForm.isOpen = false;
// };

// newGameForm.openRealtime = function() {
//   newGameForm.open();
// };

// function seekHumanGame() {
//   newGameForm.close();
//   lobby.startSeeking();
// }

// function renderForm(formName, action, settingsObj, variants) {
//   var generalFieldset = [
//     m('div.select_input', {
//       key: formName + 'variant'
//     }, [
//       formWidgets.renderSelect('variant', formName + ' variant', variants, settingsObj.variant)
//     ])
//   ];


//   // Human only
//   if (settingsObj.mode) {
//     var modes = (session.isConnected()) ? [
//       ['casual', '0'],
//       ['rated', '1']
//     ] : [ ['casual', '0'] ];

//     generalFieldset.push(m('div.select_input', {
//       key: formName + 'mode'
//     }, [
//       formWidgets.renderSelect('mode', formName + 'mode', modes, settingsObj.mode)
//     ]));

//     if (session.isConnected() && settingsObj.mode() === '0') {
//       generalFieldset.push(
//         formWidgets.renderCheckbox(i18n('membersOnly'), 'membersOnly', settingsObj.membersOnly));
//     }
//   }

//   // both human
//   var roundFieldset = [
//     // m('div.select_input', {
//     //   key: formName + 'rounds'
//     // }, [
//     //   formWidgets.renderSelect('round', formName + 'rounds', roundModes, settingsObj.roundMode)
//     // ])
//   ];

//   if (true) {
//     roundFieldset.push(
//       m('div.select_input', {
//         key: formName + 'rounds'
//       }, [
//         formWidgets.renderSelect('rounds', formName + 'round',
//                                  settings.gameSetup.availableRounds, settingsObj.rounds, false)
//       ])
//     );
//   }

//   return m('form#new_game_form.game_form', {
//     onsubmit: function(e) {
//       e.preventDefault();
//       if (!settings.gameSetup.isRoundValid(settingsObj)) return;
//       newGameForm.close();
//       action();
//     }
//   }, [
//     m('fieldset', [
//     ]),
//     m('fieldset', generalFieldset),
//     m('fieldset#round', roundFieldset),
//     m('button[data-icon=E][type=submit].newGameButton', i18n('createAGame'))
//   ]);
// }

// newGameForm.view = function() {
//   function form() {
//     return renderForm(
//       'human',
//       seekHumanGame,
//       settings.gameSetup.human,
//       settings.gameSetup.human.availableVariants);
// };

//   return popupWidget(
//     'new_game_form_popup game_form_popup',
//     null,
//     form,
//     newGameForm.isOpen,
//     newGameForm.close
//   );
// };

// export default newGameForm;

},{"../backbutton":135,"../i18n":138,"../oyunkeyf/setup":142,"../router":144,"../session":146,"../settings":147,"../xhr":213,"./helper":156,"./lobby":160,"./shared/form":186,"./shared/popup":190,"mithril":114,"mithril/hyperscript":113}],174:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _playersCtrl = require('./playersCtrl');

var _playersCtrl2 = _interopRequireDefault(_playersCtrl);

var _playersView = require('./playersView');

var _playersView2 = _interopRequireDefault(_playersView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _playersCtrl2.default,
  view: _playersView2.default
};

},{"./playersCtrl":176,"./playersView":177}],175:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onlinePlayers = onlinePlayers;

var _http = require('../../http');

function onlinePlayers() {
  return (0, _http.request)('/player/online', {}, true);
}

},{"../../http":137}],176:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _playerXhr = require('./playerXhr');

var xhr = _interopRequireWildcard(_playerXhr);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  _socket2.default.createDefault();

  var players = _mithril2.default.prop([]);

  xhr.onlinePlayers().then(players, function (err) {
    return utils.handleXhrError(err);
  });

  return {
    players: players,
    goToProfile: function goToProfile(u) {
      _mithril2.default.route('/@/' + u);
    },

    onunload: function onunload() {}
  };
}

},{"../../socket":149,"../../utils":208,"./playerXhr":175,"mithril":114}],177:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _common = require('../shared/common');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function view(ctrl) {

  var headerCtrl = header.bind(null, ctrl);
  var bodyCtrl = body.bind(null, ctrl);

  return _layout2.default.free(headerCtrl, bodyCtrl, null);
}

function header(ctrl) {
  return (0, _helper2.default)(
    'nav',
    null,
    (0, _common.menuButton)(),
    (0, _helper2.default)(
      'h1',
      null,
      (0, _i18n2.default)('players')
    ),
    (0, _helper2.default)(
      'div',
      { className: 'buttons' },
      (0, _helper2.default)('button', { className: 'main_header_button', key: 'searchPlayers', 'data-icon': 'y' })
    )
  );
}

function body(ctrl) {
  return (0, _helper2.default)(
    'ul',
    { className: 'playersSuggestion native_scroller_page' },
    ctrl.players().map(renderPlayer)
  );
}

function renderPlayer(user) {
  // find best perf
  var perf = Object.keys(user.perfs).reduce(function (prev, curr) {
    if (!prev) return curr;
    if (user.perfs[prev].rating < user.perfs[curr].rating) return curr;else return prev;
  });

  return (0, _helper2.default)(
    'li',
    { className: 'list_item playerSuggestion nav', config: _helper2.default.ontouchY(function () {
        return _mithril2.default.route('/@/' + user.id);
      }) },
    (0, _common.userStatus)(user),
    (0, _helper2.default)(
      'span',
      { className: 'rating', 'data-icon': utils.gameIcon(perf) },
      user.perfs[perf].rating
    )
  );
}

},{"../../i18n":138,"../../utils":208,"../helper":156,"../layout":159,"../shared/common":185,"mithril":114,"mithril/hyperscript":113}],178:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _form = require('../shared/form');

var _form2 = _interopRequireDefault(_form);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  controller: function controller() {
    _socket2.default.createDefault();
  },
  view: function view() {
    var header = utils.partialf(_common.header, null, (0, _common.backButton)((0, _i18n2.default)('settings')));

    return _layout2.default.free(header, renderBody);
  }
};


function renderBody() {
  return (0, _mithril2.default)('div', {
    style: { width: '100%', height: '100%' }
  }, [(0, _mithril2.default)('ul.settings_list.general.native_scroller.page', [(0, _mithril2.default)('li.list_item.nav', {
    key: 'lang',
    config: _helper2.default.ontouchY(utils.f(_mithril2.default.route, '/settings/lang'))
  }, (0, _i18n2.default)('language')), (0, _mithril2.default)('li.list_item.settingsChoicesInline', {
    key: 'backgroundTheme'
  }, [(0, _mithril2.default)('label', (0, _i18n2.default)('background')), (0, _mithril2.default)('fieldset', [(0, _mithril2.default)('div.nice-radio', _form2.default.renderRadio((0, _i18n2.default)('dark'), 'bgTheme', 'dark', _settings2.default.general.theme.background() === 'dark', function (e) {
    _settings2.default.general.theme.background(e.target.value);
    _layout2.default.onBackgroundChange(e.target.value);
  })), (0, _mithril2.default)('div.nice-radio', _form2.default.renderRadio((0, _i18n2.default)('light'), 'bgTheme', 'light', _settings2.default.general.theme.background() === 'light', function (e) {
    _settings2.default.general.theme.background(e.target.value);
    _layout2.default.onBackgroundChange(e.target.value);
  }))])])]), window.oyunkeyf.version ? (0, _mithril2.default)('section.app_version', 'v' + window.oyunkeyf.version) : null]);
}

},{"../../i18n":138,"../../settings":147,"../../socket":149,"../../utils":208,"../helper":156,"../layout":159,"../shared/common":185,"../shared/form":186,"mithril":114}],179:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _form = require('../shared/form');

var _form2 = _interopRequireDefault(_form);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _xhr = require('../../xhr');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  controller: function controller() {
    var langs = _mithril2.default.prop([]);
    (0, _i18n.getAvailableLanguages)().then(langs);

    return {
      langs: langs
    };
  },
  view: function view(ctrl) {
    var header = utils.partialf(_common.header, null, (0, _common.backButton)((0, _i18n2.default)('language')));

    function renderLang(l) {
      return h(
        'li',
        { className: 'list_item' },
        _form2.default.renderRadio(l[1], 'lang', l[0], _settings2.default.general.lang() === l[0], function (e) {
          _settings2.default.general.lang(e.target.value);
          (0, _xhr.setServerLang)(e.target.value);
          (0, _i18n.loadFromSettings)();
        })
      );
    }

    function renderBody() {
      return h(
        'ul',
        { className: 'native_scroller page settings_list radio_list' },
        ctrl.langs().map(function (l) {
          return renderLang(l);
        })
      );
    }
    return _layout2.default.free(header, renderBody);
  }
};

},{"../../i18n":138,"../../settings":147,"../../utils":208,"../../xhr":213,"../layout":159,"../shared/common":185,"../shared/form":186,"mithril":114,"mithril/hyperscript":113}],180:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    var okeyground = vnode.attrs.okeyground;


    this.wrapperOnCreate = function (_ref) {
      var dom = _ref.dom;
    };

    this.boardOnCreate = function (_ref2) {
      var dom = _ref2.dom;

      okeyground.attach(dom);
    };

    this.boardOnRemove = function () {
      okeyground.detach();
    };
  },
  view: function view(vnode) {
    var bounds = vnode.attrs.bounds;


    var boardClass = ['display_board'].join(' ');

    var wrapperClass = 'game_board_wrapper';

    var wrapperStyle = bounds ? {
      height: bounds.height + 'px',
      width: bounds.width + 'px'
    } : {};

    return h(
      'section',
      { oncreate: this.wrapperOnCreate, className: wrapperClass, style: wrapperStyle },
      h('div', { className: boardClass,
        oncreate: this.boardOnCreate,
        onremove: this.boardOnRemove })
    );
  }
};

// function renderTopMenu() {
//   return (
//     <div class="display_menu">
//       {menuButton()}
//     </div>
//   );
// }

// function renderPlayerInfo(ctrl, player, position) {
//   const wrapperClass = helper.classSet({
//     'playerInfos': true,
//   }) + ` ${position}`;

//   const playerName = player.ai ?
//                      i18n('aiBot', player.ai) :
//                      utils.playerName(player);
//   const playerOnGame = (player.onGame || player.ai ?
//                         <span className="ongame yes" data-icon="3"/> :
//                         <span className="ongame no" data-icon="0"/>
//   );

//   const togglePopup = ctrl.toggleUserPopup.bind(ctrl, position, player.user);
//   const vConf = helper.ontouch(togglePopup);

//   const runningSide = ctrl.isClockRunning() ? ctrl.data.game.player : null;
//   const running = ctrl.data.game.player === player.side;

//   const opens = ctrl.data.game.oscores ? ctrl.data.game.oscores[player.side] : null;
//   const opensHint = opens ? (opens.series ? 'openedSeries' : 'openedPairs') : null;
//   const opensClass = "opens" + ((opens && opens.new) ? " new" : "");

//   return (
//     <div className={wrapperClass} config={vConf}>
//       <div class="wrap_info">
//         {opens ?
//          <div class={opensClass}>
//            {(opens.series ? opens.series : opens.pairs)}
//            {' '}
//            {i18n(opensHint).split(' ')[0]}
//          </div>: null
//         }
//       </div>
//       <div class="wrap_user">
//         <h2 className="playerUser">
//           {playerName}
//           {playerOnGame}
//         </h2>
//         { (ctrl.clock && running) ?
//           renderClock(ctrl.clock, player.side, runningSide, position) : null
//         }
//       </div>
//     </div>
//   );
// }

// export default function(
//   ctrl,
//   okeygroundCtrl,
//   bounds,
//   isPortrait,
//   wrapperClasses) {
//     const data = ctrl.data;

//     const boardClass = [
//       'display_board',
//     ].join(' ');

//     const key = 'board' + (isPortrait ? 'portrait' : 'landscape');
//     let wrapperClass = 'game_board_wrapper';

//     if (wrapperClasses) {
//       wrapperClass += ' ' + wrapperClasses;
//     }

//     const wrapperStyle = bounds ? {
//       height: bounds.height + 'px',
//       width: bounds.width + 'px'
//     } : {};


//     function wrapperConfig(el, isUpdate) {
//       if (!isUpdate) {
//       }
//     }

//     function boardConfig(el, isUpdate) {
//       if (!isUpdate) {
//         if (!bounds) {
//         }
//         okeyground.render(el, okeygroundCtrl);
//       }
//     }

//     okeygroundCtrl.data.topHooks = [
//       // renderTopMenu(),
//       renderPlayerInfo(ctrl, data.opponentUp, 'top'),
//       renderPlayerInfo(ctrl, data.opponentLeft, 'left'),
//       renderPlayerInfo(ctrl, data.player, 'bottom'),
//       renderPlayerInfo(ctrl, data.opponentRight, 'right')
//     ];


//     return (
//       <section className={wrapperClass} config={wrapperConfig}
//                style={wrapperStyle} key={key}>
//         <div className={boardClass} config={boardConfig} />
//       </section>
//     );
// }

},{"../../settings":147,"../../utils/redraw":210,"mithril/hyperscript":113}],181:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(_ref) {
    var attrs = _ref.attrs;


    var title = 'gameApi.title(data)';

    return (0, _hyperscript2.default)('div.main_header_title', {}, [(0, _hyperscript2.default)('h1.header-gameTitle', [(0, _hyperscript2.default)('span', title)])]);
  }
};

},{"mithril/hyperscript":113}],182:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    this.onTap = function (e) {
      var el = helper.getButton(e);
      var i = void 0;
      if (el && (i = el.dataset.index)) {
        attrs.onTabChange(Number(i));
      }
    };
  },
  view: function view(vnode) {
    var _vnode$attrs = vnode.attrs,
        buttons = _vnode$attrs.buttons,
        selectedIndex = _vnode$attrs.selectedIndex,
        noIndicator = _vnode$attrs.noIndicator,
        wrapperClass = _vnode$attrs.wrapperClass;


    var iWidth = 100 / buttons.length;
    var shift = selectedIndex * (iWidth * buttons.length);

    var indicatorStyle = {
      width: iWidth + '%',
      transform: 'translateX(' + shift + '%)'
    };

    var buttonStyle = {
      width: iWidth + '%'
    };

    function renderTab(b, i) {
      var className = ['tab-button', selectedIndex === i ? 'selected' : '', b.className].join(' ');
      return h(
        'button',
        { 'data-index': i, className: className, style: buttonStyle },
        b.label,
        b.chip !== undefined ? h(
          'span',
          { className: 'chip' },
          b.chip
        ) : null
      );
    }
    return h(
      'div',
      { className: 'tabs-navigation' + (wrapperClass ? ' ' + wrapperClass : ''),
        oncreate: helper.ontap(this.onTap) },
      buttons.map(renderTab),
      noIndicator ? null : h('div', { className: 'tabIndicator', style: 'indicatorStyle' })
    );
  }
};

},{"../helper":156,"mithril/hyperscript":113}],183:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _helper = require('../helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oncreate: function oncreate(_ref) {
    var attrs = _ref.attrs,
        dom = _ref.dom;
  },
  view: function view(_ref2) {
    var attrs = _ref2.attrs;

    var curIndex = attrs.selectedIndex;
    var vw = (0, _helper.viewportDim)().vw;
    var width = attrs.content.length * 100;
    var shift = -(curIndex * vw);

    var style = {
      width: width + 'vw',
      transform: 'translateX(' + shift + 'px)'
    };

    return (0, _hyperscript2.default)('div.tabs-view-wrapper', (0, _hyperscript2.default)('div.tabs-view', {
      style: style,
      className: attrs.className
    }, attrs.content.map(function (_, index) {
      return (0, _hyperscript2.default)('div.tab-content', {
        'data-index': index,
        className: curIndex === index ? 'current' : ''
      }, curIndex === index ? (0, _hyperscript2.default)(Tab, _extends({ index: index }, attrs)) : null);
    })));
  }
};


var Tab = {
  onbeforeupdate: function onbeforeupdate(_ref3, _ref4) {
    var attrs = _ref3.attrs;
    var oldattrs = _ref4.attrs;

    return attrs.content[attrs.index] !== oldattrs.content[oldattrs.index];
  },
  view: function view(_ref5) {
    var attrs = _ref5.attrs;

    return attrs.renderer(attrs.content[attrs.index], attrs.index);
  }
};

},{"../helper":156,"mithril/hyperscript":113}],184:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(_, args) {
    var boardClass = ['display_board', args.variant ? args.variant.key : ''].join(' ');

    function boardConf(el, isUpdate, context) {
      var config = makeConfig(args);
      if (context.ground) {
        context.ground.set(config);
      } else {
        // TODO try to avoid that
        if (!config.bounds) {
          // console.log('no board bounds');
          // config.bounds = el.getBoundingClientRect();
        }
        context.ground = (0, _okeygroundMobile2.default)(el, config);
      }
    }
    return h('div', { className: boardClass, config: boardConf });
  }
};


function makeConfig(args) {
  var fen = args.fen,
      orientation = args.orientation,
      bounds = args.bounds;

  var conf = {
    viewOnly: true,
    minimalDom: true,
    fen: fen
  };

  // if (bounds) conf.bounds = bounds;

  return conf;
}

},{"mithril/hyperscript":113,"okeyground-mobile":1}],185:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.menuButton = menuButton;
exports.headerBtns = headerBtns;
exports.dropShadowHeader = dropShadowHeader;
exports.connectingDropShadowHeader = connectingDropShadowHeader;
exports.backButton = backButton;
exports.gamesButton = gamesButton;
exports.header = header;
exports.viewOnlyBoardContent = viewOnlyBoardContent;
exports.empty = empty;
exports.userStatus = userStatus;

var _menu = require('../menu');

var menu = _interopRequireWildcard(_menu);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _gamesMenu = require('../gamesMenu');

var _gamesMenu2 = _interopRequireDefault(_gamesMenu);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _icons = require('./icons');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function menuButton() {
  return h('button.fa.fa-navicon.main_header_button.menu_button', {
    key: 'main-menu',
    oncreate: helper.ontap(menu.mainMenuCtrl.toggle)
  });
}

function headerBtns() {

  if (utils.hasNetwork() && _session2.default.isConnected()) {
    return h('div', { key: 'buttons', className: 'buttons' });
  } else {
    return h('div', { key: 'buttons', className: 'buttons' });
  }
}

function dropShadowHeader(title, leftButton) {

  return [h('nav', [leftButton ? leftButton : menuButton(), title ? h(
    'div',
    { className: 'main_header_title', key: 'title' },
    title
  ) : null, headerBtns()]), h('div.main_header_drop_shadow')];
}

function connectingDropShadowHeader(title) {
  return [h('nav', [menuButton(), h('div.main_header_title.reconnecting', {
    className: title ? 'withTitle' : '',
    key: 'connecting-title'
  }), title ? h('div.main_header_title', { key: 'title' }, title) : null, headerBtns()]), h('div.main_header_drop_shadow')];
}

function backButton(title) {
  return h('div.back_button', { key: 'default-history-backbutton' }, [h('button', { oncreate: helper.ontap(_router2.default.backHistory) }, _icons.backArrow), title !== undefined ? typeof title === 'string' ? h('div.main_header_title', title) : title : null]);
}

// export function menuButton() {
//   return (
//       <button key="main-menu" className="fa fa-navicon main_header_button menu_button" config={helper.ontouch(menu.toggle)}>
//     </button>
//   );
// }

// export function backButton(title) {
//   return (
//       <button key="default-history-backbutton" className="back_button main_header_button" config={helper.ontouch(utils.backHistory)}>
//       <span className="fa fa-arrow-left"/>
//       {title ? <div className="title">{title}</div> : null }
//     </button>
//   );
// }

function gamesButton() {
  var key = void 0,
      action = void 0;

  key = 'games-menu';

  if (_session2.default.nowPlaying().length) {
    key = 'games-menu';
    action = _gamesMenu2.default.open;
  } else {
    key = 'new-game-form';
    action = _newGameForm2.default.open;
  }

  var className = ['main_header_button', 'game_menu_button', !utils.hasNetwork() ? 'invisible' : ''].join(' ');

  var longAction = function longAction() {
    return window.plugins.toast.show(i18n('nbGamesInPlay', _session2.default.nowPlaying().length), 'short', 'top');
  };

  return h('button', { key: key, className: className, config: helper.ontouch(action, longAction) });
}

// export function headerBtns() {
//   return (
//     <div key="buttons" className="buttons">
//       {gamesButton()}
//     </div>
//   );
// }

function header(title, leftButton) {
  return h(
    'nav',
    null,
    leftButton ? leftButton : menuButton(),
    title ? h(
      'h1',
      { key: 'title' },
      title
    ) : null,
    headerBtns()
  );
}

function viewOnlyBoardContent() {
  var isPortrait = false;
  var _vw$vh = { vw: 10, vh: 10 },
      vw = _vw$vh.vw,
      vh = _vw$vh.vh;

  var boardStyle = isPortrait ? { width: vw + 'px', height: vw + 'px' } : {};
  var boardKey = 'viewonlyboard';
  var className = 'board_wrapper';
  var board = h(
    'section',
    { key: boardKey, className: className, style: boardStyle },
    m.component(ViewOnlyBoard)
  );
  return [board];
}

function empty() {
  return [];
}

function userStatus(user) {
  var status = user.online ? 'online' : 'offline';
  return h(
    'div',
    { className: 'user' },
    h('span', { className: 'userStatus ' + status, 'data-icon': 'r' }),
    user.username
  );
}

},{"../../router":144,"../../session":146,"../../utils":208,"../gamesMenu":153,"../helper":156,"../menu":171,"../newGameForm":173,"./icons":187,"mithril/hyperscript":113}],186:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  renderSelect: function renderSelect(label, name, options, settingsProp, isDisabled, onChangeCallback) {
    var prop = settingsProp();
    return [(0, _hyperscript2.default)('label', {
      'for': 'select_' + name
    }, (0, _i18n2.default)(label)), (0, _hyperscript2.default)('select', {
      id: 'select_' + name,
      disabled: isDisabled,
      onchange: function onchange(e) {
        var val = e.target.value;
        settingsProp(val);
        if (onChangeCallback) onChangeCallback(val);
        setTimeout(_redraw2.default, 10);
      }
    }, options.map(function (e) {
      return renderOption(e[0], e[1], prop, e[2], e[3]);
    }))];
  }
};


function renderOption(label, value, prop, labelArg, labelArg2) {
  var l = labelArg && labelArg2 ? (0, _i18n2.default)(label, labelArg, labelArg2) : labelArg ? (0, _i18n2.default)(label, labelArg) : (0, _i18n2.default)(label);
  return (0, _hyperscript2.default)('option', {
    key: value,
    value: value,
    selected: prop === value
  }, l);
}

// import i18n from '../../i18n';
// import m from 'mithril';

// function renderOption(label, value, storedValue, labelArg, labelArg2) {
//   return m('option', {
//     value: value,
//     selected: storedValue === value
//   }, i18n(label, labelArg, labelArg2));
// }

// export default {
//   renderRadio: function(label, name, value, checked, onchange) {
//     var id = name + '_' + value;
//     return [
//       m('input.radio[type=radio]', {
//         name,
//         id,
//         className: value,
//         value,
//         checked,
//         onchange
//       }),
//       m('label', {
//         'for': id
//       }, i18n(label))
//     ];
//   },

//   renderSelect: function(label, name, options, settingsProp, isDisabled, onChangeCallback) {
//     var storedValue = settingsProp();
//     return [
//       m('label', {
//         'for': 'select_' + name
//       }, i18n(label)),
//       m('select', {
//         id: 'select_' + name,
//         disabled: isDisabled,
//         config: function(el, isUpdate, context) {
//           if (!isUpdate) {
//             var onChange = function(e) {
//               settingsProp(e.target.value);
//               if (onChangeCallback) onChangeCallback(e.target.value);
//               setTimeout(function() {
//                 m.redraw();
//               }, 10);
//             };
//             el.addEventListener('change', onChange, false);
//             context.onunload = () => {
//               el.removeEventListener('change', onChange, false);
//             };
//           }
//         }
//       }, options.map(function(e) {
//         return renderOption(e[0], e[1], storedValue, e[2], e[3]);
//       }))
//     ];
//   },
//   renderCheckbox: function(label, name, settingsProp, callback, disabled) {
//     var isOn = settingsProp();
//     return m('div.check_container', {
//       className: disabled ? 'disabled': ''
//     }, [
//       m('label', {
//         'for': name
//       }, label),
//       m('input[type=checkbox]', {
//         name: name,
//         disabled,
//         checked: isOn,
//         onchange: function() {
//           const newVal = !isOn;
//           settingsProp(newVal);
//           if (callback) callback(newVal);
//         }
//       })
//     ]);
//   }
// };

},{"../../i18n":138,"../../utils/redraw":210,"../helper":156,"mithril/hyperscript":113}],187:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require("mithril/hyperscript");

var backArrow = exports.backArrow = h(
  "div",
  { className: "svg_icon" },
  h(
    "div",
    { className: "svg_icon_inner" },
    h(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24" },
      h("path", { d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" })
    )
  )
);

var closeIcon = exports.closeIcon = h(
  "div",
  { className: "svg_icon" },
  h(
    "div",
    { className: "svg_icon_inner" },
    h(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24" },
      h("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" })
    )
  )
);

},{"mithril/hyperscript":113}],188:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit() {},
  view: function view(_ref) {
    var attrs = _ref.attrs,
        children = _ref.children;
    var header = attrs.header;


    return (0, _hyperscript2.default)('main#page', {}, [
    // h('header.main_header.board', header),
    (0, _hyperscript2.default)('div.content_round', children)]);
  }
};

},{"mithril/hyperscript":113}],189:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (key, name, perf, user) {
  var options = { className: 'profilePerf', 'data-icon': (0, _utils.gameIcon)(key) };

  if (variantPerfAvailable(key, perf)) {
    options.className += ' nav';
    options.config = _helper2.default.ontouchY(goToVariantPerf(user, key));
  }

  return (0, _mithril2.default)('div', options, [(0, _mithril2.default)('span.name', name), (0, _mithril2.default)('div.rating', [perf.rating, _helper2.default.progress(perf.prog), (0, _mithril2.default)('span.nb', '/ ' + perf.games)])]);
};

var _utils = require('../../utils');

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function goToVariantPerf(user, key) {
  return function () {
    return _mithril2.default.route('/@/${user.id}/${key}/perf');
  };
}

function variantPerfAvailable(key, perf) {
  return perf.games > 0;
}

},{"../../utils":208,"../helper":156,"mithril":114}],190:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var h = require('mithril/hyperscript');

exports.default = popup;

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function popup(classes, headerF, contentF, isShowing, closef) {

  if (!isShowing) return null;

  var defaultClasses = {
    overlay_popup: true,
    native_scroller: true
  };

  var className = void 0;

  if ((typeof classes === 'undefined' ? 'undefined' : _typeof(classes)) === 'object') {
    className = helper.classSet(Object.assign({}, defaultClasses, classes));
  } else if (typeof classes === 'string') {
    className = helper.classSet(defaultClasses) + ' ' + classes;
  } else {
    throw new Error('First popup argument must be either a string or an object');
  }

  var contentClass = helper.classSet({
    'popup_content': true,
    'noheader': !headerF
  });

  return h(
    'div',
    { key: String(contentF), className: 'overlay_popup_wrapper fade-in',
      onbeforemove: function onbeforemove(vnode) {
        vnode.dom.classList.add('fading_out');
        return new Promise(function (resolve) {
          setTimeout(resolve, 500);
        });
      } },
    h('div', { className: 'popup_overlay_close',
      oncreate: closef ? helper.ontap(closef) : utils.noop }),
    h(
      'div',
      { className: className },
      headerF ? h(
        'header',
        null,
        headerF()
      ) : null,
      h(
        'div',
        { className: contentClass },
        contentF()
      )
    )
  );
}

// function styleConf(el) {
//   const vh = helper.viewportDim().vh;
//   const h = el.getBoundingClientRect().height;
//   const top = (vh - h) / 2;
//   // el.style.top = top + 'px';
// }

// export default function(classes, headerF, contentF, isShowing, closeF) {
//   if (!isShowing) return null;

//   const defaultClasses = {
//     overlay_popup: true,
//     native_scroller: true
//   };

//   let className;

//   if (typeof classes === 'object') {
//     className = helper.classSet(Object.assign({}, defaultClasses, classes));
//   } else if (typeof classes === 'string') {
//     className = helper.classSet(defaultClasses) + ' ' + classes;
//   } else
//     throw new Error('First popup argument must be either string or an object');

//   return (
//     <div className="overlay_popup_wrapper">
//       <div className="popup_overlay_close"
//            config={closeF ? helper.ontouch(helper.fadesOut(closeF, '.overlay_popup_wrapper')) : utils.noop } />
//       <div className={className} config={styleConf}>
//         {headerF ? <header>{headerF()}</header> : null }
//         <div className="popup_content">
//           {contentF()}
//         </div>
//       </div>
//     </div>
//   );
// }

},{"../../utils":208,"../helper":156,"mithril/hyperscript":113}],191:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = OnlineRound;

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _ground = require('./ground');

var _ground2 = _interopRequireDefault(_ground);

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _socketHandler = require('./socketHandler');

var _socketHandler2 = _interopRequireDefault(_socketHandler);

var _ClockCtrl = require('./clock/ClockCtrl');

var _ClockCtrl2 = _interopRequireDefault(_ClockCtrl);

var _roundXhr = require('./roundXhr');

var xhr = _interopRequireWildcard(_roundXhr);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = _okeygroundMobile2.default.util;
var wrapGroup = util.wrapGroup,
    wrapPiece = util.wrapPiece,
    wrapDrop = util.wrapDrop,
    partial = util.partial;
function OnlineRound(id, cfg) {
  var _this = this;

  var setData = function setData(cfg) {
    _this.data = cfg;
  };

  this.onMove = function (key, piece) {
    if (key === _okeygroundMobile2.default.move.drawMiddle) {
      _this.sendMove(key);
    }
    if (key === _okeygroundMobile2.default.move.discard) {
      _this.vm.hasPlayedDiscard = true;
    }
  };

  this.onUserMove = function (key, move) {
    // TODO: why?
    if (key === _okeygroundMobile2.default.move.leaveTaken) {
      return;
    }
    _this.sendMove(key, move);
  };

  this.sendMove = function (key) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var move = args;
    args.key = key;

    _socket2.default.send('move', move, {
      ackable: true
    });
  };

  this.apiMove = function (o) {
    var d = _this.data,
        playing = _game2.default.isPlayerPlaying(d);

    d.game.turns = o.ply;
    d.game.player = _game2.default.sideByPly(o.ply);
    d.possibleMoves = d.player.side === d.game.player ? o.dests : [];
    if (true) {
      if (o.isMove) {
        if (o.drawmiddle) {
          _this.okeyground.apiMove(o.key, wrapPiece(o.drawmiddle.piece));
        } else if (o.discard) {
          if (!_this.vm.hasPlayedDiscard) {
            _this.okeyground.apiMove(o.key, wrapPiece(o.discard.piece));
          } else {}
          _this.vm.hasPlayedDiscard = false;
        } else if (o.opens) {
          _this.okeyground.apiMove(o.key, wrapGroup(o.opens.group));
        } else if (o.drop) {
          _this.okeyground.apiMove(o.key, wrapDrop(o.drop.piece, o.drop.pos));
        } else if (o.key === _okeygroundMobile2.default.move.collectOpen) {
          _this.restoreFen(o.fen, _okeygroundMobile2.default.move.collectOpen);
        } else if (o.key === _okeygroundMobile2.default.move.leaveTaken) {
          _this.okeyground.apiMove(o.key, wrapPiece(o.leavetaken.piece));
        } else {
          _this.okeyground.apiMove(o.key);
        }
      }

      _this.okeyground.set({
        turnSide: d.game.player,
        movable: {
          dests: playing ? d.possibleMoves : []
        }
      });
    }

    if (o.clock) {
      var c = o.clock;
      if (_this.clock) _this.clock.setClock(d, o.clock.east, o.clock.west, o.clock.south, o.clock.north);
    }

    (0, _redraw2.default)();
  };

  this.outoftime = (0, _throttle2.default)(function () {
    _socket2.default.send('outoftime', _this.data.game.player);
  }, 500);

  this.endWithData = function (scores) {
    xhr.reload(_this).then(_this.onReload);
  };

  this.onReload = function (rCfg) {
    setData(rCfg);

    if (!_game2.default.playable(_this.data)) {
      _this.showActions();
      (0, _redraw2.default)();
    }
  };

  this.showActions = function () {
    _router2.default.backbutton.stack.push(_this.hideActions);
    _this.vm.showingActions = true;
  };

  this.hideActions = function (fromBB) {
    if (fromBB !== 'backbutton' && _this.vm.showingActions) _router2.default.backbutton.stack.pop();
    _this.vm.showingActions = false;
  };

  this.id = id;
  setData(cfg);

  this.vm = {
    scoresheetInfo: {}
  };

  this.okeyground = _ground2.default.make(this.data, this.onUserMove, this.onMove);

  this.clock = this.data.clock ? new _ClockCtrl2.default(this.data, {
    onFlag: this.outoftime
  }) : null;

  if (this.clock) {
    var tickNow = function tickNow() {
      _this.clock && _this.clock.tick();
      if (_game2.default.playable(_this.data)) _this.clockTimeoutId = setTimeout(tickNow, 100);
    };
    this.clockTimeoutId = setTimeout(tickNow, 100);
  }

  _socket2.default.createGame(this.data.url.socket, this.data.player.version, (0, _socketHandler2.default)(this), this.data.url.round);

  this.unload = function () {
    clearTimeout(_this.clockTimeoutId);
  };

  this.leaveTaken = function () {
    _this.sendMove(_okeygroundMobile2.default.move.leaveTaken);
  };

  this.openSeries = function () {
    _this.okeyground.playOpenSeries();
  };

  this.openPairs = function () {
    _this.okeyground.playOpenPairs();
  };

  this.sortPairs = function () {
    _this.okeyground.sortPairs();
  };

  this.sortSeries = function () {
    _this.okeyground.sortSeries();
  };

  this.leaveTaken = function () {
    _this.sendMove(_okeygroundMobile2.default.move.leaveTaken);
  };

  this.collectOpen = function () {
    _this.sendMove(_okeygroundMobile2.default.move.collectOpen);
  };

  this.restoreFen = function (fen, hint) {
    _this.okeyground.set({
      fen: fen,
      animationHint: hint
    });
  };

  if (!_game2.default.playable(this.data)) {
    this.showActions();
  }
  (0, _redraw2.default)();
}

},{"../../../oyunkeyf/game":140,"../../../router":144,"../../../socket":149,"../../../utils/redraw":210,"./clock/ClockCtrl":192,"./ground":194,"./roundXhr":195,"./socketHandler":196,"lodash/throttle":109,"okeyground-mobile":1}],192:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ClockCtrl;

var _game = require('../../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ClockCtrl(d, opts) {
  var _this = this;

  this.setClock = function (d, east, west, south, north) {
    var isClockRunning = _game2.default.playable(d) && (d.game.turns >= 4 || d.clock && d.clock.running);

    _this.times = {
      east: east * 1000,
      west: west * 1000,
      north: north * 1000,
      south: south * 1000,
      activeSide: isClockRunning ? d.game.player : undefined,
      lastUpdate: performance.now()
    };
  };

  this.opts = opts;

  var cdata = d.clock;

  this.emergMs = cdata.emerg; // 1000 * Math.min(60, Math.max(10, cdata.emerg * .125));

  this.setClock(d, cdata.sides.east, cdata.sides.west, cdata.sides.south, cdata.sides.north);

  this.elements = {
    east: null,
    west: null,
    south: null,
    north: null
  };

  this.tick = function () {
    var side = _this.times.activeSide;
    if (!side) return;

    var now = performance.now();
    var millis = _this.times[side] - _this.elapsed(now);
    if (millis <= 0) _this.opts.onFlag();else _this.updateElement(side, millis);
  };

  this.updateElement = function (side, millis) {
    var el = _this.elements[side];
    if (el) {
      var width = Math.max(0, Math.min(100, millis / 30000 * 100)) + '%';
      el.style.width = width;
      if (millis < _this.emergMs * 4 * 1000) el.classList.add('emerg');else el.classList.remove('emerg');
    }
  };

  this.elapsed = function () {
    var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
    return Math.max(0, now - _this.times.lastUpdate);
  };

  this.millisOf = function (side) {
    return _this.times.activeSide === side ? Math.max(0, _this.times[side] - _this.elapsed()) : _this.times[side];
  };

  this.isRunning = function () {
    return _this.times.activeSide !== undefined;
  };
}

},{"../../../../oyunkeyf/game":140}],193:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;
    var ctrl = attrs.ctrl,
        side = attrs.side;


    this.clockOnCreate = function (_ref2) {
      var dom = _ref2.dom;

      ctrl.elements[side] = dom;
      ctrl.updateElement(side, ctrl.millisOf(side));
    };
    this.clockOnUpdate = function (_ref3) {
      var dom = _ref3.dom;

      ctrl.elements[side] = dom;
      ctrl.updateElement(side, ctrl.millisOf(side));
    };
  },
  view: function view(_ref4) {
    var attrs = _ref4.attrs;


    return (0, _hyperscript2.default)('div', { className: 'bar' }, [(0, _hyperscript2.default)('span', {
      className: 'bar2',
      oncreate: this.clockOnCreate,
      onupdate: this.clockOnUpdate
    })]);
  }
};

},{"mithril/hyperscript":113}],194:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function makeConfig(data) {
  var fen = data.game.fen;

  return {
    fen: fen,
    turnSide: data.game.player,
    povSide: data.player.side,
    spectator: data.player.spectator,
    withTore: !!data.game.variant.key.match(/duzokey/),
    movable: {
      free: false,
      board: _game2.default.isPlayerPlaying(data),
      dests: _game2.default.isPlayerPlaying(data) ? data.possibleMoves : []
    }
  };
}

function make(data, userMove, onMove) {
  var config = makeConfig(data);
  config.movable.events = {
    after: userMove
  };
  config.events = {
    move: onMove
  };

  return new _okeygroundMobile2.default(config);
}

function end(ground) {
  ground.stop();
}

exports.default = {
  make: make,
  end: end
};

},{"../../../oyunkeyf/game":140,"okeyground-mobile":1}],195:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reload = reload;

var _http = require('../../../http');

function reload(ctrl) {
  return (0, _http.fetchJSON)(ctrl.data.url.round);
}

},{"../../../http":137}],196:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ctrl) {
  function reload(o) {}

  var handlers = {
    crowd: function crowd(o) {
      ['east', 'west', 'north', 'south'].forEach(function (side) {
        _game2.default.setOnGame(ctrl.data, side, o[side]);
      });
      (0, _redraw2.default)();
    },
    move: function move(o) {
      o.isMove = true;
      ctrl.apiMove(o);
    },
    end: function end(scores) {
      ctrl.data.game.scores = scores.result;
      _ground2.default.end(ctrl.okeyground);
      ctrl.endWithData(scores);
    }
  };

  return handlers;
};

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _ground = require('./ground');

var _ground2 = _interopRequireDefault(_ground);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"../../../oyunkeyf/game":140,"../../../utils/redraw":210,"./ground":194}],197:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _router = require('../../../../router');

var _router2 = _interopRequireDefault(_router);

var _helper = require('../../../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  resign: function resign(ctrl) {
    return h('button', {
      key: 'resign',
      className: 'resign',
      'data-icon': 'b',
      oncreate: helper.ontap(ctrl.resign)
    }, (0, _i18n2.default)('resign'));
  },
  returnToMasa: function returnToMasa(ctrl) {
    function handler() {
      ctrl.hideActions();
      var url = '/masa/' + ctrl.data.game.masaId;
      _router2.default.set(url, true);
    }
    return h(
      'button',
      { key: 'returnToMasa', oncreate: helper.ontap(handler) },
      h('span', { className: 'fa fa-throphy' }),
      (0, _i18n2.default)('backToMasa')
    );
  },
  openSeries: function openSeries(ctrl) {
    var className = "open-series";
    return h(
      'button',
      { className: className, key: 'openSeries',
        oncreate: helper.ontap(ctrl.openSeries) },
      (0, _i18n2.default)('openSeries')
    );
  },
  openPairs: function openPairs(ctrl) {
    var className = "open-pairs";
    return h(
      'button',
      { className: className, key: 'openPairs',
        oncreate: helper.ontap(ctrl.openPairs) },
      (0, _i18n2.default)('openPairs')
    );
  },
  sortPairs: function sortPairs(ctrl) {
    var className = "sort-series";
    return h(
      'button',
      { className: className, key: 'sortSeries',
        oncreate: helper.ontap(ctrl.sortPairs) },
      (0, _i18n2.default)('sortPairs')
    );
  },
  sortSeries: function sortSeries(ctrl) {
    var className = "sort-pairs";
    return h(
      'button',
      { className: className, key: 'sortSeries',
        oncreate: helper.ontap(ctrl.sortSeries) },
      (0, _i18n2.default)('sortSeries')
    );
  },
  collectOpen: function collectOpen(ctrl) {
    var className = "collect-open";
    return h(
      'button',
      { className: className, key: 'collectOpen',
        oncreate: helper.ontap(ctrl.collectOpen) },
      (0, _i18n2.default)('collectOpen')
    );
  },
  leaveTaken: function leaveTaken(ctrl) {
    var className = "leave-taken";
    return h(
      'button',
      { className: className, key: 'leaveTaken',
        oncreate: helper.ontap(ctrl.leaveTaken) },
      (0, _i18n2.default)('leaveTaken')
    );
  }
};

},{"../../../../i18n":138,"../../../../router":144,"../../../helper":156,"mithril/hyperscript":113}],198:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = view;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _layout = require('../../../layout');

var _layout2 = _interopRequireDefault(_layout);

var _socket = require('../../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _helper = require('../../../helper');

var helper = _interopRequireWildcard(_helper);

var _player = require('../../../../oyunkeyf/player');

var playerApi = _interopRequireWildcard(_player);

var _game = require('../../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _status = require('../../../../oyunkeyf/status');

var _status2 = _interopRequireDefault(_status);

var _popup = require('../../../shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _Board = require('../../../shared/Board');

var _Board2 = _interopRequireDefault(_Board);

var _GameTitle = require('../../../shared/GameTitle');

var _GameTitle2 = _interopRequireDefault(_GameTitle);

var _button = require('./button');

var _button2 = _interopRequireDefault(_button);

var _clockView = require('../clock/clockView');

var _clockView2 = _interopRequireDefault(_clockView);

var _common = require('../../../shared/common');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function view(ctrl) {

  return _layout2.default.board(renderHeader(ctrl), renderContent(ctrl), overlay(ctrl));
}

function overlay(ctrl) {
  return [renderGamePopup(ctrl)];
}

function renderGameRunningActions(ctrl) {
  var gameControls = _button2.default.resign(ctrl);

  return (0, _hyperscript2.default)(
    'div',
    { className: 'game_controls' },
    gameControls
  );
}

function renderGameEndedActions(ctrl) {
  var result = _game2.default.result(ctrl.data);
  var resultDom = _status2.default.aborted(ctrl.data) ? [] : [(0, _hyperscript2.default)('strong', result), (0, _hyperscript2.default)('br')];

  var buttons = void 0;
  var masaId = ctrl.data.game.masaId;
  if (masaId) {
    buttons = [_button2.default.returnToMasa(ctrl)];
  }

  return (0, _hyperscript2.default)(
    'div',
    { className: 'game_controls' },
    (0, _hyperscript2.default)(
      'div',
      { className: 'control buttons' },
      buttons
    )
  );
}

function renderStatus(ctrl) {
  var result = _game2.default.result(ctrl.data);
  var winner = _game2.default.getPlayer(ctrl.data, ctrl.data.game.winner);
  var status = ctrl.data.game.status.name;

  return (_status2.default.aborted(ctrl.data) ? [] : [(0, _hyperscript2.default)('strong', result), (0, _hyperscript2.default)('br')]).concat([(0, _hyperscript2.default)('em.resultStatus', status)]);
}

function renderGamePopup(ctrl) {
  var header = !_game2.default.playable(ctrl.data) ? function () {
    return renderStatus(ctrl);
  } : undefined;

  return (0, _popup2.default)('player_controls', header, function () {
    return _game2.default.playable(ctrl.data) ? renderGameRunningActions(ctrl) : renderGameEndedActions(ctrl);
  }, ctrl.vm.showingActions, ctrl.hideActions);
}

function renderHeader(ctrl) {
  var children = void 0;

  children = [(0, _common.menuButton)(), renderTitle(ctrl)];

  children.push((0, _common.headerBtns)());

  return (0, _hyperscript2.default)('nav', {
    className: _socket2.default.isConnected() ? '' : 'reconnecting'
  }, children);
}

function renderTitle(ctrl) {
  var data = ctrl.data;
  var masa = ctrl.data.masa;

  return (0, _hyperscript2.default)(_GameTitle2.default, {
    key: 'playing-title',
    data: ctrl.data
  });
}

function renderContent(ctrl) {
  var player = renderPlayTable(ctrl, ctrl.data.player, 'player');
  var opponentLeft = renderPlayTable(ctrl, ctrl.data.opponentLeft, 'opponentLeft');
  var opponentRight = renderPlayTable(ctrl, ctrl.data.opponentRight, 'opponentRight');
  var opponentUp = renderPlayTable(ctrl, ctrl.data.opponentUp, 'opponentUp');

  //  const bounds = helper.getBoardBounds(helper.viewportDim());

  var board = (0, _hyperscript2.default)(_Board2.default, {
    variant: ctrl.data.game.variant.key,
    okeyground: ctrl.okeyground
    //    bounds
  });

  return _hyperscript2.default.fragment({}, [renderMenuActionsBar(ctrl), renderGameActionsBarRight(ctrl), player, opponentLeft, opponentRight, opponentUp, board]);
}

function renderGameActionsBarRight(ctrl) {
  var myTurn = _game2.default.isPlayerTurn(ctrl.data);

  var canOpenSeries = ctrl.okeyground.canOpenSeries();
  var canOpenPairs = ctrl.okeyground.canOpenPairs();
  var canLeaveTaken = ctrl.okeyground.canLeaveTaken();

  var canCollectOpen = ctrl.okeyground.canCollectOpen();

  return (0, _hyperscript2.default)(
    'section',
    { className: 'game_actions_bar right' },
    canLeaveTaken ? _button2.default.leaveTaken(ctrl) : null,
    canOpenPairs ? _button2.default.openPairs(ctrl) : _button2.default.sortPairs(ctrl),
    canOpenSeries ? _button2.default.openSeries(ctrl) : _button2.default.sortSeries(ctrl),
    canCollectOpen ? _button2.default.collectOpen(ctrl) : null
  );
}

function renderMenuActionsBar(ctrl) {
  var gmClass = ['fa', 'fa-ellipsis-v'].join(' ');

  var gmButton = (0, _hyperscript2.default)('button', { className: gmClass, key: 'gameMenu', oncreate: helper.ontap(ctrl.showActions) });

  return (0, _hyperscript2.default)(
    'section',
    { className: 'menu_actions_bar' },
    (0, _common.backButton)(),
    gmButton
  );
}

function renderPlayTable(ctrl, player, position) {

  var classN = 'playTable ' + position;

  return (0, _hyperscript2.default)(
    'section',
    { className: classN },
    renderAntagonistInfo(ctrl, player, position)
  );
}

function renderAntagonistInfo(ctrl, player, position) {
  // const runningSide = ctrl.isClockRunning() ? ctrl.data.game.player : undefined;
  var running = ctrl.data.game.player === player.side;
  var user = player.user;
  var playerName = playerApi.playerName(player);

  return (0, _hyperscript2.default)(
    'div',
    { className: 'antagonistInfos' },
    (0, _hyperscript2.default)(
      'h2',
      { className: 'antagonistUser' },
      (0, _hyperscript2.default)('span', { className: 'fa fa-circle status ' + (player.ai || player.onGame ? 'ongame' : 'offgame') }),
      playerName
    ),
    running ? renderClock(ctrl.clock, player.side) : null
  );
}

function renderClock(ctrl, side, runningSide) {
  return (0, _hyperscript2.default)(_clockView2.default, {
    ctrl: ctrl,
    side: side,
    runningSide: runningSide
  });
}

},{"../../../../i18n":138,"../../../../oyunkeyf/game":140,"../../../../oyunkeyf/player":141,"../../../../oyunkeyf/status":143,"../../../../socket":149,"../../../helper":156,"../../../layout":159,"../../../shared/Board":180,"../../../shared/GameTitle":181,"../../../shared/common":185,"../../../shared/popup":190,"../clock/clockView":193,"./button":197,"mithril/hyperscript":113}],199:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SideMenuCtrl;

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _ = require('.');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SideMenuCtrl(side, menuID, backdropID, onOpen, onClose) {
  var _this = this;

  this.isOpen = false;

  this.side = side;
  this.menuID = menuID;
  this.backdropID = backdropID;
  this.onOpen = onOpen;
  this.onClose = onClose;

  this.open = function () {
    _this.isOpen = true;
    _router2.default.backbutton.stack.push(_this.close);
    var el = document.getElementById(_this.menuID);
    var bd = document.getElementById(_this.backdropID);
    if (_this.onOpen) _this.onOpen();
    return Promise.all([(0, _zanimo2.default)(bd, 'visibility', 'visible', 0), (0, _zanimo2.default)(bd, 'opacity', _.BACKDROP_OPACITY, 250, 'linear'), (0, _zanimo2.default)(el, 'visibility', 'visible', 0), (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out')]).then(_redraw2.default).catch(console.log.bind(console));
  };

  this.close = function (fromBB) {
    if (fromBB !== 'backbutton' && _this.isOpen) _router2.default.backbutton.stack.pop();
    _this.isOpen = false;
    var el = document.getElementById(_this.menuID);
    var bd = document.getElementById(_this.backdropID);
    if (_this.onClose) _this.onClose();
    return Promise.all([(0, _zanimo2.default)(bd, 'opacity', 0, 250, 'linear'), (0, _zanimo2.default)(el, 'transform', _this.closeTranslate(), 250, 'ease-out')]).then(function () {
      Promise.all([(0, _zanimo2.default)(el, 'visibility', 'hidden', 0), (0, _zanimo2.default)(bd, 'visibility', 'hidden', 0)]);
    }).catch(console.log.bind(console));
  };

  this.toggle = function () {
    if (_this.isOpen) _this.close();else _this.open();
  };

  this.closeTranslate = function () {
    return _this.side === 'left' ? 'translate3d(-100%,0,0)' : 'translate3d(100%,0,0)';
  };
};

},{".":200,"../../../router":144,"../../../utils/redraw":210,"zanimo":131}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var BACKDROP_OPACITY = exports.BACKDROP_OPACITY = 0.7;

},{}],201:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _socket = require('../socket');

var _socket2 = _interopRequireDefault(_socket);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _loginModal = require('./loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _icons = require('./shared/icons');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;
var loading = false;

var formError = null;

exports.default = {
  open: open,
  close: close,
  view: function view() {
    if (!isOpen) return null;

    return (0, _hyperscript2.default)('div.modal#signupModal', { oncreate: helper.slidesInUp }, [(0, _hyperscript2.default)('header', [(0, _hyperscript2.default)('button.modal_close', {
      oncreate: helper.ontap(helper.slidesOutDown(close, 'signupModal'))
    }, _icons.closeIcon), (0, _hyperscript2.default)('h2', (0, _i18n2.default)('signUp'))]), (0, _hyperscript2.default)('div#signupModalContent.modal_content', {
      className: loading ? 'loading' : ''
    }, renderForm())]);
  }
};


function renderForm() {
  return [(0, _hyperscript2.default)('form.login', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      return submit(e.target);
    }
  }, [(0, _hyperscript2.default)('div.field', [formError && formError.username ? (0, _hyperscript2.default)('div.form-error', formError.username[0]) : null, (0, _hyperscript2.default)('input#pseudo[type=text]', {
    className: formError && formError.username ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('username'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: false,
    required: true,
    onfocus: scrollToTop
  })]), (0, _hyperscript2.default)('div.field', [formError && formError.email ? (0, _hyperscript2.default)('div.form-error', formError.email[0]) : null, (0, _hyperscript2.default)('input#email[type=email]', {
    onfocus: scrollToTop,
    className: formError && formError.email ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('email'),
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: false,
    required: true
  })]), (0, _hyperscript2.default)('div.field', [formError && formError.password ? (0, _hyperscript2.default)('div.form-error', formError.password[0]) : null, (0, _hyperscript2.default)('input#password[type=password]', {
    onfocus: scrollToTop,
    className: formError && formError.password ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('password'),
    required: true
  })]), (0, _hyperscript2.default)('div.submit', [(0, _hyperscript2.default)('button.submitButton[data-icon=F]', (0, _i18n2.default)('signUp'))])])];
}

function scrollToTop(e) {
  setTimeout(function () {
    var el = e.target;
    el.scrollIntoView(true);
  }, 300);
}

function submit(form) {
  var login = form[0].value.trim();
  var email = form[1].value.trim();
  var pass = form[2].value.trim();
  if (!login || !email || !pass) return;
  window.Keyboard.hide();
  loading = true;
  formError = null;
  (0, _redraw2.default)();
  _session2.default.signup(login, email, pass).then(function (d) {
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    _socket2.default.reconnectCurrent();
    (0, _redraw2.default)();
    _loginModal2.default.close();
    close();
  }).catch(function (error) {
    if (isSubmitError(error)) {
      loading = false;
      formError = error.body.error;
      (0, _redraw2.default)();
    } else {
      handleXhrError(error);
    }
  });
}

function isSubmitError(err) {
  return err.body.error !== undefined;
}

function open() {
  _router2.default.backbutton.stack.push(helper.slidesOutDown(close, 'signupModal'));
  formError = null;
  isOpen = true;
}

function close(fromBB) {
  window.Keyboard.hide();
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

// const signupModal = {};

// var isOpen = false;

// function submit(form) {
//   var login = form[0].value.trim();
//   var email = form[1].value.trim();
//   var pass = form[2].value.trim();
//   if (!login || !email || !pass) return false;
//   window.cordova.plugins.Keyboard.close();
//   return session.signup(login, email, pass).then(function() {
//     signupModal.close();
//     loginModal.close();
//     window.plugins.toast.show(i18n('loginSuccessfull'), 'short', 'center');
//   }, function(error) {
//     var data = error.response;
//     if (data.error.username) {
//       window.plugins.toast.show(data.error.username[0], 'short', 'center');
//     } else if (data.error.password) {
//       window.plugins.toast.show(data.error.password[0], 'short', 'center');
//     }
//   });
// }

// signupModal.open = function() {
//   backbutton.stack.push(helper.slidesOutDown(signupModal.close, 'signupModal'));
//   isOpen = true;
// };

// signupModal.close = function(fromBB) {
//   window.cordova.plugins.Keyboard.close();
//   if (fromBB !== 'backbutton' && isOpen) backbutton.stack.pop();
//   isOpen = false;
// };

// signupModal.view = function() {
//   if (!isOpen) return null;

//   return m('div.modal#signupModal', { config: helper.slidesInUp }, [
//     m('header', [
//       m('button.modal_close[data-icon=L]', {
//         config: helper.ontouch(helper.slidesOutDown(signupModal.close, 'signupModal'))
//       }),
//       m('h2', i18n('signUp'))
//     ]),
//     m('div.modal_content', [
//       m('p.signupWarning.withIcon[data-icon=!]', [
//         i18n('computersAreNotAllowedToPlay')
//       ]),
//       m('p.tosWarning', [
//         i18n('byRegisteringYouAgreeToBeBoundByOur'),
//         m('a', {
//         }, i18n('termsOfService')), '.'
//       ]),
//       m('form.login', {
//         onsubmit: function(e) {
//           e.preventDefault();
//           return submit(e.target);
//         }
//       }, [
//         m('input#pseudo[type=text]', {
//           placeholder: i18n('username'),
//           autocomplete: 'off',
//           autocapitalize: 'off',
//           autocorrect: 'off',
//           spellcheck: 'false',
//           required: true
//         }),
//         m('input#email[type=email]', {
//           placeholder: i18n('email'),
//           autocomplete: 'off',
//           autocapitalize: 'off',
//           autocorrect: 'off',
//           spellcheck: 'false',
//           required: true
//         }),
//         m('input#password[type=password]', {
//           placeholder: i18n('password'),
//           required: true
//         }),
//         m('button.fat', i18n('signUp'))
//       ])
//     ])
//   ]);
// };

// export default signupModal;

},{"../backbutton":135,"../i18n":138,"../router":144,"../session":146,"../socket":149,"../utils/redraw":210,"./helper":156,"./loginModal":161,"./shared/icons":187,"mithril/hyperscript":113}],202:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _userCtrl = require('./userCtrl');

var _userCtrl2 = _interopRequireDefault(_userCtrl);

var _userView = require('./userView');

var _userView2 = _interopRequireDefault(_userView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _userCtrl2.default,
  view: _userView2.default
};

},{"./userCtrl":203,"./userView":204}],203:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _userXhr = require('./userXhr');

var xhr = _interopRequireWildcard(_userXhr);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  _socket2.default.createDefault();

  var user = _mithril2.default.prop();

  xhr.user(_mithril2.default.route.param('id')).then(user, function (error) {
    utils.handleXhrError(error);
    _mithril2.default.route('/');
  }).then(_session2.default.refresh);

  return {
    user: user,
    isMe: function isMe() {
      return _session2.default.getUserId() === user().id;
    }
  };
}

},{"../../session":146,"../../socket":149,"../../utils":208,"../helper":156,"./userXhr":205,"mithril":114}],204:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _perf = require('../shared/perf');

var _perf2 = _interopRequireDefault(_perf);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import userPerfs from '../../oyunkeyf/perfs';
function view(ctrl) {
  var user = ctrl.user();

  if (!user) return null;

  function header() {
    var title = user.username;
    return (0, _common.header)(null, (0, _common.backButton)(title));
  }

  function profile() {
    // TODO
    // stats
    // ratings
    // actions
    return h(
      'div',
      { id: 'userProfile', className: 'native_scroller page' },
      renderStatus(user),
      renderProfile(user),
      renderRatings(user),
      renderActions(ctrl)
    );
  }

  return _layout2.default.free(header, profile);
}

function renderStatus(user) {
  var status = user.online ? 'online' : 'offline';
  return h(
    'section',
    { className: 'onlineStatus' },
    h('span', { className: 'userStatus ' + status, 'data-icon': 'r' }),
    (0, _i18n2.default)(status)
  );
}

function renderProfile(user) {
  if (!user.profile) return null;

  var fullName = '';
  if (user.profile.firstName) fullName += user.profile.firstName;
  if (user.profile.lastName) fullName += (user.profile.firstName ? ' ' : '') + user.profile.lastName;
  // const country = countries[user.profile.country];
  var location = user.profile.location;
  var memberSince = (0, _i18n2.default)('memberSince') + ' ' + window.moment(user.createdAt).format('LL');
  var seenAt = user.seenAt ? (0, _i18n2.default)('lastLogin') + ' ' + window.moment(user.seenAt).calendar() : null;

  return h(
    'section',
    { classname: 'profile' },
    fullName ? h(
      'h3',
      { className: 'fullname' },
      fullName
    ) : null,
    user.profile.bio ? h(
      'p',
      { className: 'profileBio' },
      user.profile.bio
    ) : null,
    h(
      'div',
      { className: 'userInfos' },
      user.language ? h(
        'p',
        { className: 'language withIcon' },
        h(
          'span',
          { className: 'fa fa-comment-o' },
          getLanguageNativeName(user.language)
        )
      ) : null,
      h(
        'p',
        { className: 'location' },
        location
      ),
      h(
        'p',
        { className: 'memberSince' },
        memberSince
      ),
      seenAt ? h(
        'p',
        { className: 'lastSeen' },
        seenAt
      ) : null
    )
  );
}

function renderRatings(user) {
  function isShowing(p) {
    return ['yuzbir', 'duzokey'].indexOf(p.key) !== -1 || p.perf.games > 0;
  }

  return h(
    'section',
    { id: 'userProfileRatings', className: 'perfs' },
    '// ',
    userPerfs(user).filter(isShowing).map(function (p) {
      return (0, _perf2.default)(p.key, p.name, p.perf, user);
    })
  );
}

function renderActions(ctrl) {
  var user = ctrl.user();
  return h(
    'section',
    { id: 'userProfileActions', 'class': 'noPadding' },
    h(
      'div',
      { className: 'list_item_nav',
        config: _helper2.default.ontouchY(ctrl.goToGames),
        key: 'view_all_games' },
      (0, _i18n2.default)('viewAllNbGames', user.count.all)
    )
  );
}

},{"../../i18n":138,"../../session":146,"../helper":156,"../layout":159,"../shared/common":185,"../shared/perf":189,"mithril/hyperscript":113}],205:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.user = user;

var _http = require('../../http');

function user(id) {
  var url = '/api/user/' + id;
  return (0, _http.request)(url, {}, true);
}

},{"../../http":137}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForeground = isForeground;
exports.setForeground = setForeground;
exports.setBackground = setBackground;
var foreground = true;

function isForeground() {
  return foreground;
}

function setForeground() {
  foreground = true;
}

function setBackground() {
  foreground = false;
}

},{}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.batchRequestAnimationFrame = batchRequestAnimationFrame;
var callbacks = new Set();
var batching = false;

function batchRequestAnimationFrame(callback) {
  callbacks.add(callback);
  if (!batching) {
    batching = true;
    requestAnimationFrame(function (ts) {
      var batch = callbacks;
      batching = false;
      callbacks = new Set();
      batch.forEach(function (f) {
        return f(ts);
      });
    });
  }
}

},{}],208:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.oyunkeyfSri = undefined;
exports.autoredraw = autoredraw;
exports.noop = noop;
exports.handleXhrError = handleXhrError;
exports.loadLocalJsonFile = loadLocalJsonFile;
exports.currentSri = currentSri;
exports.newSri = newSri;
exports.tellWorker = tellWorker;
exports.askWorker = askWorker;
exports.hasNetwork = hasNetwork;
exports.partialf = partialf;
exports.f = f;
exports.playerName = playerName;
exports.aiName = aiName;
exports.backHistory = backHistory;
exports.setViewSlideDirection = setViewSlideDirection;
exports.getViewSlideDirection = getViewSlideDirection;
exports.getBoardBounds = getBoardBounds;
exports.gameIcon = gameIcon;
exports.formatMasaDuration = formatMasaDuration;
exports.pad = pad;
exports.capitalize = capitalize;
exports.safeStringToNum = safeStringToNum;

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _redraw = require('./redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function autoredraw(action) {
  var res = action();
  (0, _redraw2.default)();
  return res;
}

function noop() {}

function handleXhrError(error) {
  var status = error.status;
  var data = error.body;
  var message = void 0;

  if (!status || status === 0) {
    message = 'oyunkeyfIsUnreachable';
  } else if (status === 401) {
    message = 'unauthorizedError';
  } else if (status === 404) {
    message = 'resourceNotFoundError';
  } else if (status === 503) {
    message = 'oyunkeyfIsUnavailableError';
  } else {
    message = 'Error.';
  }

  message = (0, _i18n2.default)(message);

  if (typeof data === 'string') {
    message += ' ' + data;
  } else if (typeof data.error === 'string') {
    message += ' ' + (0, _i18n2.default)(data.global[0]);
  }
  window.plugins.toast.show(message, 'short', 'center');
}

function loadLocalJsonFile(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.overrideMimeType('application/json');
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 0 || xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject(xhr);
        }
      }
    };
    xhr.send(null);
  });
}

var sri = void 0;

function currentSri() {
  return sri || newSri();
}

function newSri() {
  sri = Math.random().toString(36).substring(2).slice(0, 10);
  return sri;
}

var oyunkeyfSri = exports.oyunkeyfSri = Math.random().toString(36).substring(2);

function tellWorker(worker, topic, payload) {
  if (payload !== undefined) {
    worker.postMessage({ topic: topic, payload: payload });
  } else {
    worker.postMessage({ topic: topic });
  }
}

function askWorker(worker, msg, callback) {
  return new Promise(function (resolve) {
    function listen(e) {
      if (e.data.topic === msg.topic) {
        worker.removeEventListener('message', listen);
        if (callback) {
          callback(e.data.payload);
        } else {
          resolve(e.data.payload);
        }
      }
    }
    worker.addEventListener('message', listen);
    worker.postMessage(msg);
  });
}

function hasNetwork() {
  return window.navigator.connection.type !== Connection.NONE;
}

// export function handleXhrError(error) {
//   var {response: data, status} = error;
//   if (!hasNetwork()) {
//     window.plugins.toast.show(i18n('noInternetConnection'), 'short', 'center');
//   } else {
//     let message;
//     if (!status || status === 0) {
//       message = 'oyunkeyfIsUnreachable';
//     } else if (status === 401) {
//       message = 'unauthorizedError';
//     } else if (status === 404) {
//       message = 'resourceNotFoundError';
//     } else if (status === 503) {
//       message = 'oyunkeyfIsUnavailableError';
//     } else if (status >= 500) {
//       message = 'serverError';
//     } else {
//       message = 'Error.';
//     }

//     message = i18n(message);

//     if (typeof data === 'string') {
//       message += ` ${data}`;
//     } else if (data.global && data.global.constructor === Array) {
//       message += ` ${data.global[0]}`;
//     } else if (typeof data.error === 'string') {
//       message += ` ${data.error}`;
//     }

//     window.plugins.toast.show(message, 'short', 'center');
//   }
// }

function partialApply(fn, args) {
  return fn.bind.apply(fn, [null].concat(args));
}

function partialf() {
  return partialApply(arguments[0], Array.prototype.slice.call(arguments, 1));
}

function f() {
  var args = arguments,
      fn = arguments[0];
  return function () {
    fn.apply(fn, Array.prototype.slice.call(args, 1));
  };
}

function playerName(player, withRating) {
  if (player.username || player.user) {
    var name = player.username || player.user.username;
    return name;
  }
  if (player.ai) {
    return aiName(player.ai);
  }

  if (player.side) {
    return (0, _i18n2.default)(player.side);
  }

  return (0, _i18n2.default)('anonymous');
}

function aiName(level) {
  return (0, _i18n2.default)('aiBot', level);
}

function backHistory() {
  setViewSlideDirection('bwd');
  if (window.navigator.app && window.navigator.app.backHistory) {
    window.navigator.app.backHistory();
  } else window.history.go(-1);
}

// simple way to determine views animation direction
var viewSlideDirection = 'fwd';
function setViewSlideDirection(d) {
  viewSlideDirection = d;
}
function getViewSlideDirection() {
  return viewSlideDirection;
}

function getBoardBounds(viewportDim, isPortrait, isIpadLike, mode) {
  var vh = viewportDim.vh,
      vw = viewportDim.vw;

  var top = 50;

  if (isPortrait) {
    // const contentHeight = vh - 50;
    // const pTop = 50 + (mode === 'game' ? ((contentHeight - vw - 40) / 2) : 0);
    var contentHeight = vh;
    var pTop = 0;
    return {
      top: pTop,
      right: vw,
      bottom: pTop + vw,
      left: 0,
      width: vw,
      height: vw
    };
  } else {
    // const lSide = vh - top;
    var lSide = vh - 5;
    var lWidth = vw - 5; // lSide * (4/3);
    var spaceCenter = vw - lWidth;
    return {
      top: top,
      right: lSide,
      bottom: top + lSide,
      left: spaceCenter / 2,
      width: lWidth,
      height: lSide
    };
  }
}

// export function autoredraw(action) {
//   m.startComputation();
//   try {
//     return action();
//   } finally {
//     m.endComputation();
//   }
// }

var perfIconsMap = {
  yuzbir: 'T',
  duzokey: '+'
};

function gameIcon(perf) {
  return perfIconsMap[perf] || '8';
}

function formatMasaDuration(rounds, scores) {
  return rounds ? rounds + (0, _i18n2.default)('hands') : scores + (0, _i18n2.default)('scores')[0];
}

function pad(num, size) {
  var s = num + '';
  while (s.length < size) {
    s = '0' + s;
  }return s;
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function safeStringToNum(s) {
  var n = Number(s);
  return isNaN(n) ? undefined : n;
}

},{"../i18n":138,"./redraw":210}],209:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.buildQueryString = buildQueryString;
// from https://github.com/Gozala/querystring

function stringifyPrimitive(v) {
  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
}

function buildQueryString(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}

},{}],210:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.redrawSync = undefined;
exports.default = redraw;

var _signals = require('../signals');

var _signals2 = _interopRequireDefault(_signals);

var _batchRAF = require('./batchRAF');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var redrawSync = exports.redrawSync = _signals2.default.redraw.dispatch;

function redraw() {
  // console.trace();
  (0, _batchRAF.batchRequestAnimationFrame)(redrawSync);
}

},{"../signals":148,"./batchRAF":207}],211:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keepAwake = keepAwake;
exports.allowSleepAgain = allowSleepAgain;
var IDLE_TIMER_DELAY = 15 * 60 * 1000;
var SLEEP_DELAY = 60 * 60 * 1000;

var sleepAgainTimeoutId = void 0;
var cancelTimer = void 0;

function keepAwake() {
  window.plugins.insomnia.keepAwake();
  if (cancelTimer !== undefined) {
    cancelTimer();
  }
  cancelTimer = idleTimer(IDLE_TIMER_DELAY, function () {
    sleepAgainTimeoutId = setTimeout(function () {
      window.plugins.insomnia.allowSleepAgain();
    }, SLEEP_DELAY);
  }, function () {
    clearTimeout(sleepAgainTimeoutId);
  });
}

function allowSleepAgain() {
  if (cancelTimer !== undefined) {
    cancelTimer();
    cancelTimer = undefined;
  }
  window.plugins.insomnia.allowSleepAgain();
}

function idleTimer(delay, onIdle, onWakeUp) {
  var events = ['touchstart'];
  var listening = false;
  var active = true;
  var lastSeenActive = Date.now();
  var intervalID = void 0;
  var onActivity = function onActivity() {
    if (!active) {
      // console.log('Wake up')
      onWakeUp();
    }
    active = true;
    lastSeenActive = Date.now();
    stopListening();
  };
  var startListening = function startListening() {
    if (!listening) {
      events.forEach(function (e) {
        document.addEventListener(e, onActivity);
      });
      listening = true;
    }
  };
  var stopListening = function stopListening() {
    if (listening) {
      events.forEach(function (e) {
        document.removeEventListener(e, onActivity);
      });
      listening = false;
    }
  };
  var cancel = function cancel() {
    clearInterval(intervalID);
    stopListening();
  };
  intervalID = setInterval(function () {
    if (active && Date.now() - lastSeenActive > delay) {
      // console.log('Idle mode')
      onIdle();
      active = false;
    }
    startListening();
  }, 30 * 1000);

  return cancel;
}

},{}],212:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tellWorker = tellWorker;
exports.askWorker = askWorker;
function tellWorker(worker, topic, payload) {
  if (payload !== undefined) {
    worker.postMessage({ topic: topic, payload: payload });
  } else {
    worker.postMessage({ topic: topic });
  }
}

function askWorker(worker, msg) {
  return new Promise(function (resolve, reject) {
    function listen(e) {
      if (e.data.topic === msg.topic && (msg.reqid === undefined || e.data.reqid === msg.reqid)) {
        worker.removeEventListener('message', listen);
        resolve(e.data.payload);
      } else if (e.data.topic === 'error' && e.data.payload.callerTopic === msg.topic && (msg.reqid === undefined || e.data.reqid === msg.reqid)) {
        worker.removeEventListener('message', listen);
        reject(e.data.payload.error);
      }
    }
    worker.addEventListener('message', listen);
    worker.postMessage(msg);
  });
}

},{}],213:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.game = game;
exports.seekGame = seekGame;
exports.setServerLang = setServerLang;

var _http = require('./http');

var _utils = require('./utils');

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// export let cachedPools = [];

// export function newGame() {
//   const config = settings.gameSetup.human;

//   const data = {
//     variant: config.variant(),
//     rounds: config.rounds(),
//     mode: session.isConnected() ? config.mode() : '0',
//     membersOnly: session.isConnected() ? config.membersOnly() : false
//   };

//   return request('/masa/new', {
//     method: 'POST',
//     data
//   }, true);
// }

// export function lobby(feedback) {
//   return request('/', null, feedback);
// }

// export function game(id, background) {
//   var url = '/' + id;
//   return request(url, { background }, true);
// }

function game(id) {
  var url = '/' + id;
  return (0, _http.fetchJSON)(url);
}

function seekGame(setup) {
  var rest = _objectWithoutProperties(setup, []);

  var body = void 0;

  body = JSON.stringify(_extends({}, rest));

  return (0, _http.fetchJSON)('/masa/new', {
    method: 'POST',
    body: body
  }, true);
}

function setServerLang(lang) {
  if (_session2.default.isConnected()) {
    // return request('/translation/select', {
    //   method: 'POST',
    //   data: { lang }
    // });
    return Promise.resolve();
  } else {
    return Promise.resolve();
  }
}

},{"./http":137,"./session":146,"./settings":147,"./utils":208}]},{},[139])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9va2V5Z3JvdW5kL2J1aWxkL25vZGVfbW9kdWxlcy9va2V5Z3JvdW5kLW1vYmlsZS9idWlsZC9va2V5Z3JvdW5kLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2NvbnZlcnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qc29uIiwibm9kZV9tb2R1bGVzL2NvbG9yLXN0cmluZy9jb2xvci1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29sb3IvY29sb3IuanMiLCJub2RlX21vZHVsZXMvaXNjcm9sbC9idWlsZC9pc2Nyb2xsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJhbmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVJhbmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbm93LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90aHJvdHRsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvaHlwZXJzY3JpcHQuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9taXRocmlsLmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL2ZyYWdtZW50LmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL2h5cGVyc2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci90cnVzdC5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci92bm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3N0cmVhbS9zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcS9xLmpzIiwibm9kZV9tb2R1bGVzL3FhbmltYXRpb25mcmFtZS9zcmMvcWFuaW1hdGlvbmZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL3JsaXRlLXJvdXRlci9ybGl0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxzL2Rpc3Qvc2lnbmFscy5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3ZlbmRvci1wcmVmaXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvemFuaW1vL3NyYy9aYW5pbW8uanMiLCJub2RlX21vZHVsZXMvemFuaW1vL3NyYy9ub3JtYWxpemUtdGltaW5nLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3phbmltby9zcmMvbm9ybWFsaXplLXRyYW5zZm9ybS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy96YW5pbW8vc3JjL3RyYW5zaXRpb24tc2hvcnRoYW5kLXByb3BlcnR5LmpzIiwic3JjL2JhY2tidXR0b24uanMiLCJzcmMvY29uZmlnLmpzIiwic3JjL2h0dHAuanMiLCJzcmMvaTE4bi5qcyIsInNyYy9tYWluLmpzIiwic3JjL295dW5rZXlmL2dhbWUuanMiLCJzcmMvb3l1bmtleWYvcGxheWVyLmpzIiwic3JjL295dW5rZXlmL3NldHVwLmpzIiwic3JjL295dW5rZXlmL3N0YXR1cy5qcyIsInNyYy9yb3V0ZXIuanMiLCJzcmMvcm91dGVzLmpzIiwic3JjL3Nlc3Npb24uanMiLCJzcmMvc2V0dGluZ3MuanMiLCJzcmMvc2lnbmFscy5qcyIsInNyYy9zb2NrZXQuanMiLCJzcmMvc3Bpbm5lci5qcyIsInNyYy9zdG9yYWdlLmpzIiwic3JjL3VpL2dhbWUvaW5kZXguanMiLCJzcmMvdWkvZ2FtZXNNZW51LmpzIiwic3JjL3VpL2hlbHBlci9hbmltYXRvci5qcyIsInNyYy91aS9oZWxwZXIvYnV0dG9uLmpzIiwic3JjL3VpL2hlbHBlci9pbmRleC5qcyIsInNyYy91aS9ob21lL2hvbWVWaWV3LmpzIiwic3JjL3VpL2hvbWUvaW5kZXguanMiLCJzcmMvdWkvbGF5b3V0LmpzIiwic3JjL3VpL2xvYmJ5LmpzIiwic3JjL3VpL2xvZ2luTW9kYWwuanMiLCJzcmMvdWkvbWFzYS9NYXNhc0xpc3RDdHJsLmpzIiwic3JjL3VpL21hc2EvZGV0YWlsL01hc2FDdHJsLmpzIiwic3JjL3VpL21hc2EvZGV0YWlsL2luZGV4LmpzIiwic3JjL3VpL21hc2EvZGV0YWlsL21hc2FWaWV3LmpzIiwic3JjL3VpL21hc2EvZGV0YWlsL3NvY2tldEhhbmRsZXIuanMiLCJzcmMvdWkvbWFzYS9mYXEuanMiLCJzcmMvdWkvbWFzYS9pbmRleC5qcyIsInNyYy91aS9tYXNhL21hc2FYaHIuanMiLCJzcmMvdWkvbWFzYS9tYXNhc0xpc3RWaWV3LmpzIiwic3JjL3VpL21lbnUvaW5kZXguanMiLCJzcmMvdWkvbWVudS9tZW51Vmlldy5qcyIsInNyYy91aS9uZXdHYW1lRm9ybS5qcyIsInNyYy91aS9wbGF5ZXJzL2luZGV4LmpzIiwic3JjL3VpL3BsYXllcnMvcGxheWVyWGhyLmpzIiwic3JjL3VpL3BsYXllcnMvcGxheWVyc0N0cmwuanMiLCJzcmMvdWkvcGxheWVycy9wbGF5ZXJzVmlldy5qcyIsInNyYy91aS9zZXR0aW5ncy9pbmRleC5qcyIsInNyYy91aS9zZXR0aW5ncy9sYW5nLmpzeCIsInNyYy91aS9zaGFyZWQvQm9hcmQuanMiLCJzcmMvdWkvc2hhcmVkL0dhbWVUaXRsZS5qcyIsInNyYy91aS9zaGFyZWQvVGFiTmF2aWdhdGlvbi5qcyIsInNyYy91aS9zaGFyZWQvVGFiVmlldy5qcyIsInNyYy91aS9zaGFyZWQvVmlld09ubHlCb2FyZC5qcyIsInNyYy91aS9zaGFyZWQvY29tbW9uLmpzIiwic3JjL3VpL3NoYXJlZC9mb3JtLmpzIiwic3JjL3VpL3NoYXJlZC9pY29ucy5qcyIsInNyYy91aS9zaGFyZWQvbGF5b3V0L01haW5Cb2FyZC5qcyIsInNyYy91aS9zaGFyZWQvcGVyZi5qcyIsInNyYy91aS9zaGFyZWQvcG9wdXAuanMiLCJzcmMvdWkvc2hhcmVkL3JvdW5kL09ubGluZVJvdW5kLmpzIiwic3JjL3VpL3NoYXJlZC9yb3VuZC9jbG9jay9DbG9ja0N0cmwuanMiLCJzcmMvdWkvc2hhcmVkL3JvdW5kL2Nsb2NrL2Nsb2NrVmlldy5qcyIsInNyYy91aS9zaGFyZWQvcm91bmQvZ3JvdW5kLmpzIiwic3JjL3VpL3NoYXJlZC9yb3VuZC9yb3VuZFhoci5qcyIsInNyYy91aS9zaGFyZWQvcm91bmQvc29ja2V0SGFuZGxlci5qcyIsInNyYy91aS9zaGFyZWQvcm91bmQvdmlldy9idXR0b24uanMiLCJzcmMvdWkvc2hhcmVkL3JvdW5kL3ZpZXcvcm91bmRWaWV3LmpzIiwic3JjL3VpL3NoYXJlZC9zaWRlTWVudS9TaWRlTWVudUN0cmwuanMiLCJzcmMvdWkvc2hhcmVkL3NpZGVNZW51L2luZGV4LmpzIiwic3JjL3VpL3NpZ251cE1vZGFsLmpzIiwic3JjL3VpL3VzZXIvaW5kZXguanMiLCJzcmMvdWkvdXNlci91c2VyQ3RybC5qcyIsInNyYy91aS91c2VyL3VzZXJWaWV3LmpzIiwic3JjL3VpL3VzZXIvdXNlclhoci5qcyIsInNyYy91dGlscy9hcHBNb2RlLmpzIiwic3JjL3V0aWxzL2JhdGNoUkFGLmpzIiwic3JjL3V0aWxzL2luZGV4LmpzIiwic3JjL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzIiwic3JjL3V0aWxzL3JlZHJhdy5qcyIsInNyYy91dGlscy9zbGVlcC5qcyIsInNyYy91dGlscy93b3JrZXIuanMiLCJzcmMveGhyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3h1Q0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDellBLElBQUksU0FBSjs7a0JBRWU7QUFDYixNQURhLGtCQUNOO0FBQ0wsUUFBSSxhQUFhLFNBQVMsc0JBQVQsQ0FBZ0MsZUFBaEMsRUFBaUQsTUFBakQsR0FBMEQsQ0FBM0UsRUFBOEU7QUFDNUUsYUFBTyxLQUFQO0FBQ0Q7O0FB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QUFlLEtBQXRCO0FBQ0Q7QUFDRjtBQUNELFdBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsTUFBbkM7QUFDQSxXQUFPLFdBQVAsQ0FBbUIsR0FBbkI7QUFDRCxHQWJNLENBQVA7QUFjRDs7Ozs7Ozs7Ozs7UUNTZSxJLEdBQUEsSTtRQUtBLFEsR0FBQSxRO1FBYUEsYSxHQUFBLGE7O0FBbERoQjs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7OztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsSUFBVCxDQUFjLEVBQWQsRUFBa0I7QUFDdkIsTUFBSSxNQUFNLE1BQU0sRUFBaEI7QUFDQSxTQUFPLHFCQUFVLEdBQVYsQ0FBUDtBQUNEOztBQUVNLFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QjtBQUFBLE1BQ25CLElBRG1CLDRCQUNWLEtBRFU7O0FBRzlCLE1BQUksYUFBSjs7QUFFQSxTQUFPLEtBQUssU0FBTCxjQUFvQixJQUFwQixFQUFQOztBQUVBLFNBQU8scUJBQVUsV0FBVixFQUF1QjtBQUM1QixZQUFRLE1BRG9CO0FBRTVCO0FBRjRCLEdBQXZCLEVBR0osSUFISSxDQUFQO0FBSUQ7O0FBRU0sU0FBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCO0FBQ2xDLE1BQUksa0JBQVEsV0FBUixFQUFKLEVBQTJCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBTyxRQUFRLE9BQVIsRUFBUDtBQUNELEdBTkQsTUFNTztBQUNMLFdBQU8sUUFBUSxPQUFSLEVBQVA7QUFDRDtBQUNGIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgdDt0PVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyx0Lk9rZXlncm91bmQ9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBhKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCF1JiZsKXJldHVybiBsKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGQ9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBkLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZH12YXIgcz1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwocy5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIGEobnx8ZSl9LHMscy5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9Zm9yKHZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsbz0wO288ci5sZW5ndGg7bysrKWEocltvXSk7cmV0dXJuIGF9cmV0dXJuIGV9KCkoezE6W2Z1bmN0aW9uKGUsdCxuKXshZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe2lmKFwib2JqZWN0XCIhPT1hKGUpKXJldHVybiB0O2Zvcih2YXIgciBpbiB0KVwib2JqZWN0XCI9PT1hKGVbcl0pJiZcIm9iamVjdFwiPT09YSh0W3JdKT9lW3JdPW4oZVtyXSx0W3JdKTplW3JdPXRbcl07cmV0dXJuIGV9ZnVuY3Rpb24gcihlLHQscil7dmFyIG89clswXSx1PXIubGVuZ3RoOyhlfHxcIm9iamVjdFwiIT09YShvKSkmJihvPXt9KTtmb3IodmFyIGw9MDtsPHU7KytsKXt2YXIgZD1yW2xdLHM9YShkKTtpZihcIm9iamVjdFwiPT09cylmb3IodmFyIGMgaW4gZClpZihcIl9fcHJvdG9fX1wiIT09Yyl7dmFyIGY9ZT9pLmNsb25lKGRbY10pOmRbY107dD9vW2NdPW4ob1tjXSxmKTpvW2NdPWZ9fXJldHVybiBvfWZ1bmN0aW9uIGEoZSl7cmV0dXJue30udG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKS50b0xvd2VyQ2FzZSgpfXZhciBpPWZ1bmN0aW9uKGUpe3JldHVybiByKGU9PT0hMCwhMSxhcmd1bWVudHMpfSxvPVwibWVyZ2VcIjtpLnJlY3Vyc2l2ZT1mdW5jdGlvbihlKXtyZXR1cm4gcihlPT09ITAsITAsYXJndW1lbnRzKX0saS5jbG9uZT1mdW5jdGlvbihlKXt2YXIgdCxuLHI9ZSxvPWEoZSk7aWYoXCJhcnJheVwiPT09bylmb3Iocj1bXSxuPWUubGVuZ3RoLHQ9MDt0PG47Kyt0KXJbdF09aS5jbG9uZShlW3RdKTtlbHNlIGlmKFwib2JqZWN0XCI9PT1vKXtyPXt9O2Zvcih0IGluIGUpclt0XT1pLmNsb25lKGVbdF0pfXJldHVybiByfSxlP3QuZXhwb3J0cz1pOndpbmRvd1tvXT1pfShcIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmXCJvYmplY3RcIj09dHlwZW9mIHQuZXhwb3J0cyYmdC5leHBvcnRzKX0se31dLDI6W2Z1bmN0aW9uKHQsbixyKXshZnVuY3Rpb24odCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT1yKHQpO1widW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cmJmEuZGVwcyh7ZG9jdW1lbnQ6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P2RvY3VtZW50Ont9LGxvY2F0aW9uOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBsb2NhdGlvbj9sb2NhdGlvbjp7fSxjbGVhclRpbWVvdXQ6Y2xlYXJUaW1lb3V0LHNldFRpbWVvdXQ6c2V0VGltZW91dH0pLFwib2JqZWN0XCI9PXR5cGVvZiBuJiZudWxsIT1uJiZuLmV4cG9ydHM/bi5leHBvcnRzPWE6XCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZS5hbWQ/ZShmdW5jdGlvbigpe3JldHVybiBhfSk6dC5tPWF9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnRoaXMsZnVuY3Rpb24gYShlLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZX1mdW5jdGlvbiByKGUpe3JldHVyblwiW29iamVjdCBPYmplY3RdXCI9PT1LZS5jYWxsKGUpfWZ1bmN0aW9uIGkoZSl7cmV0dXJuXCJbb2JqZWN0IFN0cmluZ11cIj09PUtlLmNhbGwoZSl9ZnVuY3Rpb24gbygpe31mdW5jdGlvbiB1KGUpe3hlPWUuZG9jdW1lbnQsU2U9ZS5sb2NhdGlvbixNZT1lLmNhbmNlbEFuaW1hdGlvbkZyYW1lfHxlLmNsZWFyVGltZW91dCxFZT1lLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZS5zZXRUaW1lb3V0fWZ1bmN0aW9uIGwoZSx0KXtmb3IodmFyIG4scj1bXSxhPS8oPzooXnwjfFxcLikoW14jXFwuXFxbXFxdXSspKXwoXFxbKC4rPykoPzpcXHMqPVxccyooXCJ8J3wpKCg/OlxcXFxbXCInXFxdXXwuKSo/KVxcNSk/XFxdKS9nO249YS5leGVjKHQpOylpZihcIlwiPT09blsxXSYmblsyXSllLnRhZz1uWzJdO2Vsc2UgaWYoXCIjXCI9PT1uWzFdKWUuYXR0cnMuaWQ9blsyXTtlbHNlIGlmKFwiLlwiPT09blsxXSlyLnB1c2goblsyXSk7ZWxzZSBpZihcIltcIj09PW5bM10uY2hhckF0KDApKXt2YXIgaT1uWzZdO2kmJihpPWkucmVwbGFjZSgvXFxcXChbXCInXSkvZyxcIiQxXCIpKSxcImNsYXNzXCI9PT1uWzRdP3IucHVzaChpKTplLmF0dHJzW25bNF1dPWl8fCEwfXJldHVybiByfWZ1bmN0aW9uIGQoZSx0KXt2YXIgbj10P2Uuc2xpY2UoMSk6ZTtyZXR1cm4gMT09PW4ubGVuZ3RoJiZUZShuWzBdKT9uWzBdOm59ZnVuY3Rpb24gcyhlLHQsbil7dmFyIHI9XCJjbGFzc1wiaW4gdD9cImNsYXNzXCI6XCJjbGFzc05hbWVcIjtmb3IodmFyIGEgaW4gdClDZS5jYWxsKHQsYSkmJihhPT09ciYmbnVsbCE9dFthXSYmXCJcIiE9PXRbYV0/KG4ucHVzaCh0W2FdKSxlW2FdPVwiXCIpOmVbYV09dFthXSk7bi5sZW5ndGgmJihlW3JdPW4uam9pbihcIiBcIikpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIGE9W10sbz0xLHU9YXJndW1lbnRzLmxlbmd0aDtvPHU7bysrKWFbby0xXT1hcmd1bWVudHNbb107aWYoZSYmbihlLnZpZXcpKXJldHVybiBhZShlLGEpO2lmKCFpKGUpKXRocm93IG5ldyBFcnJvcihcInNlbGVjdG9yIGluIG0oc2VsZWN0b3IsIGF0dHJzLCBjaGlsZHJlbikgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO3ZhciBjPW51bGwhPXQmJnIodCkmJiEoXCJ0YWdcImluIHR8fFwidmlld1wiaW4gdHx8XCJzdWJ0cmVlXCJpbiB0KSxmPWM/dDp7fSxwPXt0YWc6XCJkaXZcIixhdHRyczp7fSxjaGlsZHJlbjpkKGEsYyl9O3JldHVybiBzKHAuYXR0cnMsZixsKHAsZSkpLHB9ZnVuY3Rpb24gZihlLHQpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGgmJiF0KGVbbl0sbisrKTspO31mdW5jdGlvbiBwKGUsdCl7ZihlLGZ1bmN0aW9uKGUsbil7cmV0dXJuKGU9ZSYmZS5hdHRycykmJm51bGwhPWUua2V5JiZ0KGUsbil9KX1mdW5jdGlvbiB2KGUpe3RyeXtpZihcImJvb2xlYW5cIiE9dHlwZW9mIGUmJm51bGwhPWUmJm51bGwhPWUudG9TdHJpbmcoKSlyZXR1cm4gZX1jYXRjaCh0KXt9cmV0dXJuXCJcIn1mdW5jdGlvbiBtKGUsdCxuLHIpe3RyeXtoKGUsdCxuKSx0Lm5vZGVWYWx1ZT1yfWNhdGNoKGEpe319ZnVuY3Rpb24gZyhlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKylUZShlW3RdKSYmKGU9ZS5jb25jYXQuYXBwbHkoW10sZSksdC0tKTtyZXR1cm4gZX1mdW5jdGlvbiBoKGUsdCxuKXtlLmluc2VydEJlZm9yZSh0LGUuY2hpbGROb2Rlc1tuXXx8bnVsbCl9ZnVuY3Rpb24geShlLHQsbixyKXtwKGUsZnVuY3Rpb24oZSxyKXt0W2U9ZS5rZXldPXRbZV0/e2FjdGlvbjpqZSxpbmRleDpyLGZyb206dFtlXS5pbmRleCxlbGVtZW50Om4ubm9kZXNbdFtlXS5pbmRleF18fHhlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIil9OnthY3Rpb246QmUsaW5kZXg6cn19KTt2YXIgYT1bXTtmb3IodmFyIGkgaW4gdClDZS5jYWxsKHQsaSkmJmEucHVzaCh0W2ldKTt2YXIgbz1hLnNvcnQocSksdT1uZXcgQXJyYXkobi5sZW5ndGgpO3JldHVybiB1Lm5vZGVzPW4ubm9kZXMuc2xpY2UoKSxmKG8sZnVuY3Rpb24odCl7dmFyIGE9dC5pbmRleDtpZih0LmFjdGlvbj09PURlJiYoVihuW2FdLm5vZGVzLG5bYV0pLHUuc3BsaWNlKGEsMSkpLHQuYWN0aW9uPT09QmUpe3ZhciBpPXhlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5rZXk9ZVthXS5hdHRycy5rZXksaChyLGksYSksdS5zcGxpY2UoYSwwLHthdHRyczp7a2V5OmVbYV0uYXR0cnMua2V5fSxub2RlczpbaV19KSx1Lm5vZGVzW2FdPWl9aWYodC5hY3Rpb249PT1qZSl7dmFyIG89dC5lbGVtZW50LGw9ci5jaGlsZE5vZGVzW2FdO2whPT1vJiZudWxsIT09byYmci5pbnNlcnRCZWZvcmUobyxsfHxudWxsKSx1W2FdPW5bdC5mcm9tXSx1Lm5vZGVzW2FdPW99fSksdX1mdW5jdGlvbiB3KGUsdCxuLHIpe3ZhciBhPWUubGVuZ3RoIT09dC5sZW5ndGg7cmV0dXJuIGF8fHAoZSxmdW5jdGlvbihlLG4pe3ZhciByPXRbbl07cmV0dXJuIGE9ciYmci5hdHRycyYmci5hdHRycy5rZXkhPT1lLmtleX0pLGE/eShlLG4sdCxyKTp0fWZ1bmN0aW9uIGIoZSx0LG4pe2YoZSxmdW5jdGlvbihlLHIpe251bGwhPXRbcl0mJm4ucHVzaC5hcHBseShuLHRbcl0ubm9kZXMpfSksZih0Lm5vZGVzLGZ1bmN0aW9uKGUscil7bnVsbCE9ZS5wYXJlbnROb2RlJiZuLmluZGV4T2YoZSk8MCYmVihbZV0sW3Rbcl1dKX0pLGUubGVuZ3RoPHQubGVuZ3RoJiYodC5sZW5ndGg9ZS5sZW5ndGgpLHQubm9kZXM9bn1mdW5jdGlvbiBQKGUpe3ZhciB0PTA7cChlLGZ1bmN0aW9uKCl7cmV0dXJuIGYoZSxmdW5jdGlvbihlKXsoZT1lJiZlLmF0dHJzKSYmbnVsbD09ZS5rZXkmJihlLmtleT1cIl9fbWl0aHJpbF9fXCIrdCsrKX0pLDF9KX1mdW5jdGlvbiBrKGUsdCxuKXtyZXR1cm4gZS50YWchPT10LnRhZ3x8KG4uc29ydCgpLmpvaW4oKSE9PU9iamVjdC5rZXlzKHQuYXR0cnMpLnNvcnQoKS5qb2luKCl8fChlLmF0dHJzLmlkIT09dC5hdHRycy5pZHx8KGUuYXR0cnMua2V5IT09dC5hdHRycy5rZXl8fChcImFsbFwiPT09Yy5yZWRyYXcuc3RyYXRlZ3koKT8hdC5jb25maWdDb250ZXh0fHx0LmNvbmZpZ0NvbnRleHQucmV0YWluIT09ITA6XCJkaWZmXCI9PT1jLnJlZHJhdy5zdHJhdGVneSgpJiYodC5jb25maWdDb250ZXh0JiZ0LmNvbmZpZ0NvbnRleHQucmV0YWluPT09ITEpKSkpKX1mdW5jdGlvbiBPKGUsdCxyKXtrKGUsdCxyKSYmKHQubm9kZXMubGVuZ3RoJiZWKHQubm9kZXMpLHQuY29uZmlnQ29udGV4dCYmbih0LmNvbmZpZ0NvbnRleHQub251bmxvYWQpJiZ0LmNvbmZpZ0NvbnRleHQub251bmxvYWQoKSx0LmNvbnRyb2xsZXJzJiZmKHQuY29udHJvbGxlcnMsZnVuY3Rpb24oZSl7ZS5vbnVubG9hZCYmZS5vbnVubG9hZCh7cHJldmVudERlZmF1bHQ6b30pfSkpfWZ1bmN0aW9uIHgoZSx0KXtyZXR1cm4gZS5hdHRycy54bWxucz9lLmF0dHJzLnhtbG5zOlwic3ZnXCI9PT1lLnRhZz9cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI6XCJtYXRoXCI9PT1lLnRhZz9cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjp0fWZ1bmN0aW9uIFMoZSx0LG4pe24ubGVuZ3RoJiYoZS52aWV3cz10LGUuY29udHJvbGxlcnM9bixmKG4sZnVuY3Rpb24oZSl7aWYoZS5vbnVubG9hZCYmZS5vbnVubG9hZC4kb2xkJiYoZS5vbnVubG9hZD1lLm9udW5sb2FkLiRvbGQpLFJlJiZlLm9udW5sb2FkKXt2YXIgdD1lLm9udW5sb2FkO2Uub251bmxvYWQ9ZnVuY3Rpb24oKXt9LGUub251bmxvYWQuJG9sZD10fX0pKX1mdW5jdGlvbiBFKGUsdCxyLGEsaSl7aWYobih0LmF0dHJzLmNvbmZpZykpe3ZhciBvPWkuY29uZmlnQ29udGV4dD1pLmNvbmZpZ0NvbnRleHR8fHt9O2UucHVzaChmdW5jdGlvbigpe3JldHVybiB0LmF0dHJzLmNvbmZpZy5jYWxsKHQsciwhYSxvLGkpfSl9fWZ1bmN0aW9uIE0oZSxuLHIsYSxpLG8sdSxsKXt2YXIgZD1lLm5vZGVzWzBdO3JldHVybiBhJiZKKGQsbi50YWcsbi5hdHRycyxlLmF0dHJzLGkpLGUuY2hpbGRyZW49VShkLG4udGFnLHQsdCxuLmNoaWxkcmVuLGUuY2hpbGRyZW4sITEsMCxuLmF0dHJzLmNvbnRlbnRlZGl0YWJsZT9kOnIsaSx1KSxlLm5vZGVzLmludGFjdD0hMCxsLmxlbmd0aCYmKGUudmlld3M9byxlLmNvbnRyb2xsZXJzPWwpLGR9ZnVuY3Rpb24gQyhlLHQsbil7dmFyIHI7ZS4kdHJ1c3RlZD9yPWVlKHQsbixlKToocj1beGUuY3JlYXRlVGV4dE5vZGUoZSldLHQubm9kZU5hbWUgaW4gQWV8fGgodCxyWzBdLG4pKTt2YXIgYTtyZXR1cm4gYT1cInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9uZXcgZS5jb25zdHJ1Y3RvcihlKTplLGEubm9kZXM9cixhfWZ1bmN0aW9uIEsoZSx0LG4scixhLGkpe3ZhciBvPXQubm9kZXM7cmV0dXJuIHImJnI9PT14ZS5hY3RpdmVFbGVtZW50JiZlPT09dHx8KGUuJHRydXN0ZWQ/KFYobyx0KSxvPWVlKG4sYSxlKSk6XCJ0ZXh0YXJlYVwiPT09aT9uLnZhbHVlPWU6cj8oci5pbm5lckhUTUw9ZSxvPVtdLnNsaWNlLmNhbGwoci5jaGlsZE5vZGVzKSk6KCgxPT09b1swXS5ub2RlVHlwZXx8by5sZW5ndGg+MXx8b1swXS5ub2RlVmFsdWUudHJpbSYmIW9bMF0ubm9kZVZhbHVlLnRyaW0oKSkmJihWKHQubm9kZXMsdCksbz1beGUuY3JlYXRlVGV4dE5vZGUoZSldKSxtKG4sb1swXSxhLGUpKSksdD1uZXcgZS5jb25zdHJ1Y3RvcihlKSx0Lm5vZGVzPW8sdC4kdHJ1c3RlZD1lLiR0cnVzdGVkLHR9ZnVuY3Rpb24gVChlLHQsbixyLGEsaSxvKXtyZXR1cm4gZS5ub2Rlcy5sZW5ndGg/ZS52YWx1ZU9mKCkhPT10LnZhbHVlT2YoKXx8YT9LKHQsZSxyLGksbixvKTooZS5ub2Rlcy5pbnRhY3Q9ITAsZSk6Qyh0LHIsbil9ZnVuY3Rpb24gQShlKXtyZXR1cm4gZS4kdHJ1c3RlZD9lLm5vZGVzLmxlbmd0aDpUZShlKT9lLmxlbmd0aDoxfWZ1bmN0aW9uIEQoZSxuLHIsYSxpLG8sdSxsLGQpe2U9ZyhlKTt2YXIgcz1bXSxjPW4ubGVuZ3RoPT09ZS5sZW5ndGgsZj0wLHY9e30sbT0hMTtwKG4sZnVuY3Rpb24oZSx0KXttPSEwLHZbblt0XS5hdHRycy5rZXldPXthY3Rpb246RGUsaW5kZXg6dH19KSxQKGUpLG0mJihuPXcoZSxuLHYscikpO2Zvcih2YXIgaD0wLHk9MCxrPWUubGVuZ3RoO3k8azt5Kyspe3ZhciBPPVUocixpLG4sYSxlW3ldLG5baF0sbyxhK2Z8fGYsdSxsLGQpO08hPT10JiYoYz1jJiZPLm5vZGVzLmludGFjdCxmKz1BKE8pLG5baCsrXT1PKX1yZXR1cm4gY3x8YihlLG4scyksbn1mdW5jdGlvbiBCKGUsdCxuLHIsYSl7aWYobnVsbCE9dCl7aWYoS2UuY2FsbCh0KT09PUtlLmNhbGwoZSkpcmV0dXJuIHQ7aWYoYSYmYS5ub2Rlcyl7dmFyIGk9bi1yLG89aSsoVGUoZSk/ZTp0Lm5vZGVzKS5sZW5ndGg7VihhLm5vZGVzLnNsaWNlKGksbyksYS5zbGljZShpLG8pKX1lbHNlIHQubm9kZXMmJlYodC5ub2Rlcyx0KX1yZXR1cm4gdD1uZXcgZS5jb25zdHJ1Y3Rvcix0LnRhZyYmKHQ9e30pLHQubm9kZXM9W10sdH1mdW5jdGlvbiBqKGUsdCl7cmV0dXJuIGUuYXR0cnMuaXM/bnVsbD09dD94ZS5jcmVhdGVFbGVtZW50KGUudGFnLGUuYXR0cnMuaXMpOnhlLmNyZWF0ZUVsZW1lbnROUyh0LGUudGFnLGUuYXR0cnMuaXMpOm51bGw9PXQ/eGUuY3JlYXRlRWxlbWVudChlLnRhZyk6eGUuY3JlYXRlRWxlbWVudE5TKHQsZS50YWcpfWZ1bmN0aW9uIFIoZSx0LG4scil7cmV0dXJuIHI/Sih0LGUudGFnLGUuYXR0cnMse30sbik6ZS5hdHRyc31mdW5jdGlvbiBMKGUsbixyLGEsaSxvKXtyZXR1cm4gbnVsbCE9ZS5jaGlsZHJlbiYmZS5jaGlsZHJlbi5sZW5ndGg+MD9VKG4sZS50YWcsdCx0LGUuY2hpbGRyZW4sci5jaGlsZHJlbiwhMCwwLGUuYXR0cnMuY29udGVudGVkaXRhYmxlP246YSxpLG8pOmUuY2hpbGRyZW59ZnVuY3Rpb24gRyhlLHQsbixyLGEsaSxvKXt2YXIgdT17dGFnOmUudGFnLGF0dHJzOnQsY2hpbGRyZW46bixub2Rlczpbcl19O3JldHVybiBTKHUsaSxvKSx1LmNoaWxkcmVuJiYhdS5jaGlsZHJlbi5ub2RlcyYmKHUuY2hpbGRyZW4ubm9kZXM9W10pLHV9ZnVuY3Rpb24gRihlLHQscixhKXt2YXIgaTtyZXR1cm4gaT1cImRpZmZcIj09PWMucmVkcmF3LnN0cmF0ZWd5KCkmJmU/ZS5pbmRleE9mKHQpOi0xLGk+LTE/cltpXTpuKGEpP25ldyBhOnt9fWZ1bmN0aW9uIE4oZSx0LG4scil7bnVsbCE9ci5vbnVubG9hZCYmR2UubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmhhbmRsZXJ9KS5pbmRleE9mKHIub251bmxvYWQpPDAmJkdlLnB1c2goe2NvbnRyb2xsZXI6cixoYW5kbGVyOnIub251bmxvYWR9KSxlLnB1c2gobiksdC5wdXNoKHIpfWZ1bmN0aW9uIF8oZSx0LG4scixhLGkpe3ZhciBvPUYobi52aWV3cyx0LHIsZS5jb250cm9sbGVyKSx1PWUmJmUuYXR0cnMmJmUuYXR0cnMua2V5O3JldHVybiBlPTA9PT1SZXx8RmV8fHImJnIuaW5kZXhPZihvKT4tMT9lLnZpZXcobyk6e3RhZzpcInBsYWNlaG9sZGVyXCJ9LFwicmV0YWluXCI9PT1lLnN1YnRyZWU/ZTooZS5hdHRycz1lLmF0dHJzfHx7fSxlLmF0dHJzLmtleT11LE4oaSxhLHQsbyksZSl9ZnVuY3Rpb24gSShlLHQsbixyKXtmb3IodmFyIGE9dCYmdC5jb250cm9sbGVycztudWxsIT1lLnZpZXc7KWU9XyhlLGUudmlldy4kb3JpZ2luYWx8fGUudmlldyx0LGEscixuKTtyZXR1cm4gZX1mdW5jdGlvbiBIKGUsdCxuLHIsYSxvLHUsbCl7dmFyIGQ9W10scz1bXTtpZihlPUkoZSx0LGQscyksXCJyZXRhaW5cIj09PWUuc3VidHJlZSlyZXR1cm4gdDtpZighZS50YWcmJnMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCB0ZW1wbGF0ZSBtdXN0IHJldHVybiBhIHZpcnR1YWwgZWxlbWVudCwgbm90IGFuIGFycmF5LCBzdHJpbmcsIGV0Yy5cIik7ZS5hdHRycz1lLmF0dHJzfHx7fSx0LmF0dHJzPXQuYXR0cnN8fHt9O3ZhciBjPU9iamVjdC5rZXlzKGUuYXR0cnMpLGY9Yy5sZW5ndGg+KFwia2V5XCJpbiBlLmF0dHJzPzE6MCk7aWYoTyhlLHQsYyksaShlLnRhZykpe3ZhciBwPTA9PT10Lm5vZGVzLmxlbmd0aDt1PXgoZSx1KTt2YXIgdjtpZihwKXt2PWooZSx1KTt2YXIgbT1SKGUsdix1LGYpO2gocix2LGEpO3ZhciBnPUwoZSx2LHQsbix1LGwpO3Q9RyhlLG0sZyx2LHUsZCxzKX1lbHNlIHY9TSh0LGUsbixmLHUsZCxsLHMpO3JldHVyblwic2VsZWN0XCI9PT1lLnRhZyYmXCJ2YWx1ZVwiaW4gZS5hdHRycyYmSih2LGUudGFnLHt2YWx1ZTplLmF0dHJzLnZhbHVlfSx7fSx1KSxwfHxvIT09ITB8fG51bGw9PXZ8fGgocix2LGEpLEUobCxlLHYscCx0KSx0fX1mdW5jdGlvbiBVKGUsdCxhLGksbyx1LGwsZCxzLGMsZil7cmV0dXJuIG89dihvKSxcInJldGFpblwiPT09by5zdWJ0cmVlP3U6KHU9QihvLHUsZCxpLGEpLFRlKG8pP0Qobyx1LGUsZCx0LGwscyxjLGYpOm51bGwhPW8mJnIobyk/SChvLHUscyxlLGQsbCxjLGYpOm4obyk/dTpUKHUsbyxkLGUsbCxzLHQpKX1mdW5jdGlvbiBxKGUsdCl7cmV0dXJuIGUuYWN0aW9uLXQuYWN0aW9ufHxlLmluZGV4LXQuaW5kZXh9ZnVuY3Rpb24gWChlLHQsbil7bj09PXQmJihlLnN0eWxlPVwiXCIsbj17fSk7Zm9yKHZhciByIGluIHQpQ2UuY2FsbCh0LHIpJiYobnVsbCE9biYmbltyXT09PXRbcl18fChlLnN0eWxlW3JdPXRbcl0pKTtmb3IociBpbiBuKUNlLmNhbGwobixyKSYmKENlLmNhbGwodCxyKXx8KGUuc3R5bGVbcl09XCJcIikpfWZ1bmN0aW9uIHooZSx0LGEsaSxvLHUpe2lmKFwiY29uZmlnXCI9PT10fHxcImtleVwiPT09dClyZXR1cm4hMDtpZihuKGEpJiZcIm9uXCI9PT10LnNsaWNlKDAsMikpZVt0XT10ZShhLGUpO2Vsc2UgaWYoXCJzdHlsZVwiPT09dCYmbnVsbCE9YSYmcihhKSlYKGUsYSxpKTtlbHNlIGlmKG51bGwhPXUpXCJocmVmXCI9PT10P2Uuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXCJocmVmXCIsYSk6ZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIj09PXQ/XCJjbGFzc1wiOnQsYSk7ZWxzZSBpZih0IGluIGUmJiFOZVt0XSl0cnl7KFwiaW5wdXRcIiE9PW8mJiFlLmlzQ29udGVudEVkaXRhYmxlfHxlW3RdIT1hKSYmKGVbdF09YSl9Y2F0Y2gobCl7ZS5zZXRBdHRyaWJ1dGUodCxhKX1lbHNlIHRyeXtlLnNldEF0dHJpYnV0ZSh0LGEpfWNhdGNoKGwpe319ZnVuY3Rpb24gJChlLHQsbixyLGEsaSxvKXtpZih0IGluIGEmJnI9PT1uJiZcIm9iamVjdFwiIT10eXBlb2YgbiYmeGUuYWN0aXZlRWxlbWVudCE9PWUpXCJ2YWx1ZVwiPT09dCYmXCJpbnB1dFwiPT09aSYmZS52YWx1ZSE9biYmKGUudmFsdWU9bik7ZWxzZXthW3RdPW47dHJ5e3JldHVybiB6KGUsdCxuLHIsaSxvKX1jYXRjaCh1KXtpZih1Lm1lc3NhZ2UuaW5kZXhPZihcIkludmFsaWQgYXJndW1lbnRcIik8MCl0aHJvdyB1fX19ZnVuY3Rpb24gSihlLHQsbixyLGEpe2Zvcih2YXIgaSBpbiBuKSFDZS5jYWxsKG4saSl8fCEkKGUsaSxuW2ldLHJbaV0scix0LGEpO3JldHVybiByfWZ1bmN0aW9uIFYoZSx0KXtmb3IodmFyIG49ZS5sZW5ndGgtMTtuPi0xO24tLSlpZihlW25dJiZlW25dLnBhcmVudE5vZGUpe3RyeXtlW25dLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZVtuXSl9Y2F0Y2gocil7fXQ9W10uY29uY2F0KHQpLHRbbl0mJlkodFtuXSl9ZS5sZW5ndGgmJihlLmxlbmd0aD0wKX1mdW5jdGlvbiBZKGUpe2UuY29uZmlnQ29udGV4dCYmbihlLmNvbmZpZ0NvbnRleHQub251bmxvYWQpJiYoZS5jb25maWdDb250ZXh0Lm9udW5sb2FkKCksZS5jb25maWdDb250ZXh0Lm9udW5sb2FkPW51bGwpLGUuY29udHJvbGxlcnMmJmYoZS5jb250cm9sbGVycyxmdW5jdGlvbihlKXtuKGUub251bmxvYWQpJiZlLm9udW5sb2FkKHtwcmV2ZW50RGVmYXVsdDpvfSl9KSxlLmNoaWxkcmVuJiYoVGUoZS5jaGlsZHJlbik/ZihlLmNoaWxkcmVuLFkpOmUuY2hpbGRyZW4udGFnJiZZKGUuY2hpbGRyZW4pKX1mdW5jdGlvbiBRKGUsdCl7dHJ5e2UuYXBwZW5kQ2hpbGQoeGUuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQodCkpfWNhdGNoKG4pe2UuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsdCksVyhlKX19ZnVuY3Rpb24gVyhlKXtpZihcIlNDUklQVFwiPT09ZS50YWdOYW1lKWUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoWihlKSxlKTtlbHNle3ZhciB0PWUuY2hpbGROb2RlcztpZih0JiZ0Lmxlbmd0aClmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylXKHRbbl0pfXJldHVybiBlfWZ1bmN0aW9uIFooZSl7Zm9yKHZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksbj1lLmF0dHJpYnV0ZXMscj0wO3I8bi5sZW5ndGg7cisrKXQuc2V0QXR0cmlidXRlKG5bcl0ubmFtZSxuW3JdLnZhbHVlKTtyZXR1cm4gdC50ZXh0PWUuaW5uZXJIVE1MLHR9ZnVuY3Rpb24gZWUoZSx0LG4pe3ZhciByPWUuY2hpbGROb2Rlc1t0XTtpZihyKXt2YXIgYT0xIT09ci5ub2RlVHlwZSxpPXhlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO2E/KGUuaW5zZXJ0QmVmb3JlKGkscnx8bnVsbCksaS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLG4pLGUucmVtb3ZlQ2hpbGQoaSkpOnIuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIixuKX1lbHNlIFEoZSxuKTtmb3IodmFyIG89W107ZS5jaGlsZE5vZGVzW3RdIT09cjspby5wdXNoKGUuY2hpbGROb2Rlc1t0XSksdCsrO3JldHVybiBvfWZ1bmN0aW9uIHRlKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4pe249bnx8ZXZlbnQsYy5yZWRyYXcuc3RyYXRlZ3koXCJkaWZmXCIpLGMuc3RhcnRDb21wdXRhdGlvbigpO3RyeXtyZXR1cm4gZS5jYWxsKHQsbil9ZmluYWxseXtsZSgpfX19ZnVuY3Rpb24gbmUoZSl7dmFyIHQ9SWUuaW5kZXhPZihlKTtyZXR1cm4gdDwwP0llLnB1c2goZSktMTp0fWZ1bmN0aW9uIHJlKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCYmKGU9YXJndW1lbnRzWzBdKSxlfXJldHVybiB0LnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiBlJiZuKGUudG9KU09OKT9lLnRvSlNPTigpOmV9LHR9ZnVuY3Rpb24gYWUoZSx0KXtmdW5jdGlvbiBuKCl7cmV0dXJuKGUuY29udHJvbGxlcnx8bykuYXBwbHkodGhpcyx0KXx8dGhpc31mdW5jdGlvbiByKG4pe2Zvcih2YXIgcj1bbl0uY29uY2F0KHQpLGE9MTthPGFyZ3VtZW50cy5sZW5ndGg7YSsrKXIucHVzaChhcmd1bWVudHNbYV0pO3JldHVybiBlLnZpZXcuYXBwbHkoZSxyKX1lLmNvbnRyb2xsZXImJihuLnByb3RvdHlwZT1lLmNvbnRyb2xsZXIucHJvdG90eXBlKSxyLiRvcmlnaW5hbD1lLnZpZXc7dmFyIGE9e2NvbnRyb2xsZXI6bix2aWV3OnJ9O3JldHVybiB0WzBdJiZudWxsIT10WzBdLmtleSYmKGEuYXR0cnM9e2tleTp0WzBdLmtleX0pLGF9ZnVuY3Rpb24gaWUoZSx0LG4scil7aWYoIXIpe2MucmVkcmF3LnN0cmF0ZWd5KFwiYWxsXCIpLGMuc3RhcnRDb21wdXRhdGlvbigpLHFlW25dPXQ7dmFyIGE7YT1VZT1lP2U6ZT17Y29udHJvbGxlcjpvfTt2YXIgaT1uZXcoZS5jb250cm9sbGVyfHxvKTtyZXR1cm4gYT09PVVlJiYoemVbbl09aSxYZVtuXT1lKSxsZSgpLG51bGw9PT1lJiZvZSh0LG4pLHplW25dfW51bGw9PWUmJm9lKHQsbiksWmUmJihXZT1aZSl9ZnVuY3Rpb24gb2UoZSx0KXtxZS5zcGxpY2UodCwxKSx6ZS5zcGxpY2UodCwxKSxYZS5zcGxpY2UodCwxKSxtZShlKSxJZS5zcGxpY2UobmUoZSksMSksR2U9W119ZnVuY3Rpb24gdWUoKXtWZSYmKFZlKCksVmU9bnVsbCksZihxZSxmdW5jdGlvbihlLHQpe3ZhciBuPVhlW3RdO2lmKHplW3RdKXt2YXIgcj1bemVbdF1dO2MucmVuZGVyKGUsbi52aWV3P24udmlldyh6ZVt0XSxyKTpcIlwiKX19KSxZZSYmKFllKCksWWU9bnVsbCksJGU9bnVsbCxKZT1uZXcgRGF0ZSxjLnJlZHJhdy5zdHJhdGVneShcImRpZmZcIil9ZnVuY3Rpb24gbGUoKXtcIm5vbmVcIj09PWMucmVkcmF3LnN0cmF0ZWd5KCk/KFJlLS0sYy5yZWRyYXcuc3RyYXRlZ3koXCJkaWZmXCIpKTpjLmVuZENvbXB1dGF0aW9uKCl9ZnVuY3Rpb24gZGUoZSl7cmV0dXJuIGUuc2xpY2UobnRbYy5yb3V0ZS5tb2RlXS5sZW5ndGgpfWZ1bmN0aW9uIHNlKGUsdCxuKXt0dD17fTt2YXIgcj1uLmluZGV4T2YoXCI/XCIpO3IhPT0tMSYmKHR0PXZlKG4uc3Vic3RyKHIrMSxuLmxlbmd0aCkpLG49bi5zdWJzdHIoMCxyKSk7dmFyIGE9T2JqZWN0LmtleXModCksaT1hLmluZGV4T2Yobik7aWYoaSE9PS0xKXJldHVybiBjLm1vdW50KGUsdFthW2ldXSksITA7Zm9yKHZhciBvIGluIHQpaWYoQ2UuY2FsbCh0LG8pKXtpZihvPT09bilyZXR1cm4gYy5tb3VudChlLHRbb10pLCEwO3ZhciB1PW5ldyBSZWdFeHAoXCJeXCIrby5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZyxcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csXCIoW15cXFxcL10rKVwiKStcIi8/JFwiKTtpZih1LnRlc3QobikpcmV0dXJuIG4ucmVwbGFjZSh1LGZ1bmN0aW9uKCl7dmFyIG49by5tYXRjaCgvOlteXFwvXSsvZyl8fFtdLHI9W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSwtMik7ZihuLGZ1bmN0aW9uKGUsdCl7dHRbZS5yZXBsYWNlKC86fFxcLi9nLFwiXCIpXT1kZWNvZGVVUklDb21wb25lbnQoclt0XSl9KSxjLm1vdW50KGUsdFtvXSl9KSwhMH19ZnVuY3Rpb24gY2UoZSl7aWYoZT1lfHxldmVudCwhKGUuY3RybEtleXx8ZS5tZXRhS2V5fHxlLnNoaWZ0S2V5fHwyPT09ZS53aGljaCkpe2UucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOmUucmV0dXJuVmFsdWU9ITE7dmFyIHQsbj1lLmN1cnJlbnRUYXJnZXR8fGUuc3JjRWxlbWVudDtmb3IodD1cInBhdGhuYW1lXCI9PT1jLnJvdXRlLm1vZGUmJm4uc2VhcmNoP3ZlKG4uc2VhcmNoLnNsaWNlKDEpKTp7fTtuJiYhL2EvaS50ZXN0KG4ubm9kZU5hbWUpOyluPW4ucGFyZW50Tm9kZTtSZT0wLGMucm91dGUobltjLnJvdXRlLm1vZGVdLnNsaWNlKG50W2Mucm91dGUubW9kZV0ubGVuZ3RoKSx0KX19ZnVuY3Rpb24gZmUoKXtcImhhc2hcIiE9PWMucm91dGUubW9kZSYmU2UuaGFzaD9TZS5oYXNoPVNlLmhhc2g6ZS5zY3JvbGxUbygwLDApfWZ1bmN0aW9uIHBlKGUsbil7dmFyIGE9e30saT1bXTtmb3IodmFyIG8gaW4gZSlpZihDZS5jYWxsKGUsbykpe3ZhciB1PW4/bitcIltcIitvK1wiXVwiOm8sbD1lW29dO2lmKG51bGw9PT1sKWkucHVzaChlbmNvZGVVUklDb21wb25lbnQodSkpO2Vsc2UgaWYocihsKSlpLnB1c2gocGUobCx1KSk7ZWxzZSBpZihUZShsKSl7dmFyIGQ9W107YVt1XT1hW3VdfHx7fSxmKGwsZnVuY3Rpb24oZSl7YVt1XVtlXXx8KGFbdV1bZV09ITAsZC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1KStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoZSkpKX0pLGkucHVzaChkLmpvaW4oXCImXCIpKX1lbHNlIGwhPT10JiZpLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHUpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChsKSl9cmV0dXJuIGkuam9pbihcIiZcIil9ZnVuY3Rpb24gdmUoZSl7aWYoXCJcIj09PWV8fG51bGw9PWUpcmV0dXJue307XCI/XCI9PT1lLmNoYXJBdCgwKSYmKGU9ZS5zbGljZSgxKSk7dmFyIHQ9ZS5zcGxpdChcIiZcIiksbj17fTtyZXR1cm4gZih0LGZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCI9XCIpLHI9ZGVjb2RlVVJJQ29tcG9uZW50KHRbMF0pLGE9Mj09PXQubGVuZ3RoP2RlY29kZVVSSUNvbXBvbmVudCh0WzFdKTpudWxsO251bGwhPW5bcl0/KFRlKG5bcl0pfHwobltyXT1bbltyXV0pLG5bcl0ucHVzaChhKSk6bltyXT1hfSksbn1mdW5jdGlvbiBtZShlKXt2YXIgbj1uZShlKTtWKGUuY2hpbGROb2RlcyxIZVtuXSksSGVbbl09dH1mdW5jdGlvbiBnZShlLHQpe3ZhciBuPWMucHJvcCh0KTtyZXR1cm4gZS50aGVuKG4pLG4udGhlbj1mdW5jdGlvbihuLHIpe3JldHVybiBnZShlLnRoZW4obixyKSx0KX0sbltcImNhdGNoXCJdPW4udGhlbi5iaW5kKG51bGwsbnVsbCksbn1mdW5jdGlvbiBoZShlLHQpe2Z1bmN0aW9uIGEoZSl7bD1lfHxsdCxzLm1hcChmdW5jdGlvbihlKXtsPT09dXQ/ZS5yZXNvbHZlKGQpOmUucmVqZWN0KGQpfSl9ZnVuY3Rpb24gaShlLHQsYSxpKXtpZigobnVsbCE9ZCYmcihkKXx8bihkKSkmJm4oZSkpdHJ5e3ZhciBvPTA7ZS5jYWxsKGQsZnVuY3Rpb24oZSl7bysrfHwoZD1lLHQoKSl9LGZ1bmN0aW9uKGUpe28rK3x8KGQ9ZSxhKCkpfSl9Y2F0Y2godSl7Yy5kZWZlcnJlZC5vbmVycm9yKHUpLGQ9dSxhKCl9ZWxzZSBpKCl9ZnVuY3Rpb24gbygpe3ZhciByO3RyeXtyPWQmJmQudGhlbn1jYXRjaChzKXtyZXR1cm4gYy5kZWZlcnJlZC5vbmVycm9yKHMpLGQ9cyxsPW90LG8oKX1sPT09b3QmJmMuZGVmZXJyZWQub25lcnJvcihkKSxpKHIsZnVuY3Rpb24oKXtsPWl0LG8oKX0sZnVuY3Rpb24oKXtsPW90LG8oKX0sZnVuY3Rpb24oKXt0cnl7bD09PWl0JiZuKGUpP2Q9ZShkKTpsPT09b3QmJm4odCkmJihkPXQoZCksbD1pdCl9Y2F0Y2gobyl7cmV0dXJuIGMuZGVmZXJyZWQub25lcnJvcihvKSxkPW8sYSgpfWQ9PT11PyhkPVR5cGVFcnJvcigpLGEoKSk6aShyLGZ1bmN0aW9uKCl7YSh1dCl9LGEsZnVuY3Rpb24oKXthKGw9PT1pdCYmdXQpfSl9KX12YXIgdT10aGlzLGw9MCxkPTAscz1bXTt1LnByb21pc2U9e30sdS5yZXNvbHZlPWZ1bmN0aW9uKGUpe3JldHVybiBsfHwoZD1lLGw9aXQsbygpKSx1fSx1LnJlamVjdD1mdW5jdGlvbihlKXtyZXR1cm4gbHx8KGQ9ZSxsPW90LG8oKSksdX0sdS5wcm9taXNlLnRoZW49ZnVuY3Rpb24oZSx0KXt2YXIgbj1uZXcgaGUoZSx0KTtyZXR1cm4gbD09PXV0P24ucmVzb2x2ZShkKTpsPT09bHQ/bi5yZWplY3QoZCk6cy5wdXNoKG4pLG4ucHJvbWlzZX19ZnVuY3Rpb24geWUoZSl7cmV0dXJuIGV9ZnVuY3Rpb24gd2Uobil7dmFyIHI9bi5jYWxsYmFja05hbWV8fFwibWl0aHJpbF9jYWxsYmFja19cIisobmV3IERhdGUpLmdldFRpbWUoKStcIl9cIitNYXRoLnJvdW5kKDFlMTYqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpLGE9eGUuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtlW3JdPWZ1bmN0aW9uKGkpe2EucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSxuLm9ubG9hZCh7dHlwZTpcImxvYWRcIix0YXJnZXQ6e3Jlc3BvbnNlVGV4dDppfX0pLGVbcl09dH0sYS5vbmVycm9yPWZ1bmN0aW9uKCl7cmV0dXJuIGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSxuLm9uZXJyb3Ioe3R5cGU6XCJlcnJvclwiLHRhcmdldDp7c3RhdHVzOjUwMCxyZXNwb25zZVRleHQ6SlNPTi5zdHJpbmdpZnkoe2Vycm9yOlwiRXJyb3IgbWFraW5nIGpzb25wIHJlcXVlc3RcIn0pfX0pLGVbcl09dCwhMX0sYS5vbmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sYS5zcmM9bi51cmwrKG4udXJsLmluZGV4T2YoXCI/XCIpPjA/XCImXCI6XCI/XCIpKyhuLmNhbGxiYWNrS2V5P24uY2FsbGJhY2tLZXk6XCJjYWxsYmFja1wiKStcIj1cIityK1wiJlwiK3BlKG4uZGF0YXx8e30pLHhlLmJvZHkuYXBwZW5kQ2hpbGQoYSl9ZnVuY3Rpb24gYmUodCl7dmFyIGE9bmV3IGUuWE1MSHR0cFJlcXVlc3Q7aWYoYS5vcGVuKHQubWV0aG9kLHQudXJsLCEwLHQudXNlcix0LnBhc3N3b3JkKSxhLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpezQ9PT1hLnJlYWR5U3RhdGUmJihhLnN0YXR1cz49MjAwJiZhLnN0YXR1czwzMDA/dC5vbmxvYWQoe3R5cGU6XCJsb2FkXCIsdGFyZ2V0OmF9KTp0Lm9uZXJyb3Ioe3R5cGU6XCJlcnJvclwiLHRhcmdldDphfSkpfSx0LnNlcmlhbGl6ZT09PUpTT04uc3RyaW5naWZ5JiZ0LmRhdGEmJlwiR0VUXCIhPT10Lm1ldGhvZCYmYS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpLHQuZGVzZXJpYWxpemU9PT1KU09OLnBhcnNlJiZhLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIixcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKSxyKHQuaGVhZGVycykpZm9yKHZhciBvIGluIHQuaGVhZGVycylDZS5jYWxsKHQuaGVhZGVycyxvKSYmYS5zZXRSZXF1ZXN0SGVhZGVyKG8sdC5oZWFkZXJzW29dKTtpZihuKHQuY29uZmlnKSl7dmFyIHU9dC5jb25maWcoYSx0KTtudWxsIT11JiYoYT11KX12YXIgbD1cIkdFVFwiIT09dC5tZXRob2QmJnQuZGF0YT90LmRhdGE6XCJcIjtpZihsJiYhaShsKSYmbC5jb25zdHJ1Y3RvciE9PWUuRm9ybURhdGEpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBkYXRhIHNob3VsZCBiZSBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgRm9ybURhdGEuIENoZWNrIHRoZSBgc2VyaWFsaXplYCBvcHRpb24gaW4gYG0ucmVxdWVzdGBcIik7cmV0dXJuIGEuc2VuZChsKSxhfWZ1bmN0aW9uIFBlKGUpe3JldHVybiBlLmRhdGFUeXBlJiZcImpzb25wXCI9PT1lLmRhdGFUeXBlLnRvTG93ZXJDYXNlKCk/d2UoZSk6YmUoZSl9ZnVuY3Rpb24ga2UoZSx0LG4pe2lmKFwiR0VUXCI9PT1lLm1ldGhvZCYmXCJqc29ucFwiIT09ZS5kYXRhVHlwZSl7dmFyIHI9ZS51cmwuaW5kZXhPZihcIj9cIik8MD9cIj9cIjpcIiZcIixhPXBlKHQpO2UudXJsKz1hP3IrYTpcIlwifWVsc2UgZS5kYXRhPW4odCl9ZnVuY3Rpb24gT2UoZSx0KXtyZXR1cm4gdCYmKGU9ZS5yZXBsYWNlKC86W2Etel1cXHcrL2dpLGZ1bmN0aW9uKGUpe3ZhciBuPWUuc2xpY2UoMSkscj10W25dfHxlO3JldHVybiBkZWxldGUgdFtuXSxyfSkpLGV9Yy52ZXJzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuXCJ2MC4yLjhcIn07dmFyIHhlLFNlLEVlLE1lLENlPXt9Lmhhc093blByb3BlcnR5LEtlPXt9LnRvU3RyaW5nLFRlPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PUtlLmNhbGwoZSl9LEFlPXtBUkVBOjEsQkFTRToxLEJSOjEsQ09MOjEsQ09NTUFORDoxLEVNQkVEOjEsSFI6MSxJTUc6MSxJTlBVVDoxLEtFWUdFTjoxLExJTks6MSxNRVRBOjEsUEFSQU06MSxTT1VSQ0U6MSxUUkFDSzoxLFdCUjoxfTtjLmRlcHM9ZnVuY3Rpb24odCl7cmV0dXJuIHUoZT10fHx3aW5kb3cpLGV9LGMuZGVwcy5mYWN0b3J5PWMuZmFjdG9yeT1hLGMuZGVwcyhlKTt2YXIgRGU9MSxCZT0yLGplPTMsUmU9MDtjLnN0YXJ0Q29tcHV0YXRpb249ZnVuY3Rpb24oKXtSZSsrfSxjLmVuZENvbXB1dGF0aW9uPWZ1bmN0aW9uKCl7UmU+MT9SZS0tOihSZT0wLGMucmVkcmF3KCkpfTt2YXIgTGUsR2U9W10sRmU9ITEsTmU9e2xpc3Q6MSxzdHlsZToxLGZvcm06MSx0eXBlOjEsd2lkdGg6MSxoZWlnaHQ6MX0sX2U9e2FwcGVuZENoaWxkOmZ1bmN0aW9uKGUpe0xlPT09dCYmKExlPXhlLmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpKSx4ZS5kb2N1bWVudEVsZW1lbnQmJnhlLmRvY3VtZW50RWxlbWVudCE9PWU/eGUucmVwbGFjZUNoaWxkKGUseGUuZG9jdW1lbnRFbGVtZW50KTp4ZS5hcHBlbmRDaGlsZChlKSx0aGlzLmNoaWxkTm9kZXM9eGUuY2hpbGROb2Rlc30saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGUpe3RoaXMuYXBwZW5kQ2hpbGQoZSl9LGNoaWxkTm9kZXM6W119LEllPVtdLEhlPXt9O2MucmVuZGVyPWZ1bmN0aW9uKGUsbixyKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIik7dmFyIGEsaT1bXSxvPW5lKGUpLHU9ZT09PXhlO2E9dXx8ZT09PXhlLmRvY3VtZW50RWxlbWVudD9fZTplLHUmJlwiaHRtbFwiIT09bi50YWcmJihuPXt0YWc6XCJodG1sXCIsYXR0cnM6e30sY2hpbGRyZW46bn0pLEhlW29dPT09dCYmVihhLmNoaWxkTm9kZXMpLHI9PT0hMCYmbWUoZSksSGVbb109VShhLG51bGwsdCx0LG4sSGVbb10sITEsMCxudWxsLHQsaSksZihpLGZ1bmN0aW9uKGUpe2UoKX0pfSxjLnRydXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlPW5ldyBTdHJpbmcoZSksZS4kdHJ1c3RlZD0hMCxlfSxjLnByb3A9ZnVuY3Rpb24oZSl7cmV0dXJuKG51bGwhPWUmJihyKGUpfHxuKGUpKXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJmUgaW5zdGFuY2VvZiBQcm9taXNlKSYmbihlLnRoZW4pP2dlKGUpOnJlKGUpfTt2YXIgVWUscWU9W10sWGU9W10semU9W10sJGU9bnVsbCxKZT0wLFZlPW51bGwsWWU9bnVsbCxRZT0xNjtjLmNvbXBvbmVudD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuLTFdPWFyZ3VtZW50c1tuXTtyZXR1cm4gYWUoZSx0KX07dmFyIFdlLFplO2MubW91bnQ9Yy5tb2R1bGU9ZnVuY3Rpb24oZSx0KXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIik7dmFyIHI9cWUuaW5kZXhPZihlKTtyPDAmJihyPXFlLmxlbmd0aCk7dmFyIGE9ITEsaT17cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXthPSEwLFZlPVllPW51bGx9fTtyZXR1cm4gZihHZSxmdW5jdGlvbihlKXtlLmhhbmRsZXIuY2FsbChlLmNvbnRyb2xsZXIsaSksZS5jb250cm9sbGVyLm9udW5sb2FkPW51bGx9KSxhP2YoR2UsZnVuY3Rpb24oZSl7ZS5jb250cm9sbGVyLm9udW5sb2FkPWUuaGFuZGxlcn0pOkdlPVtdLHplW3JdJiZuKHplW3JdLm9udW5sb2FkKSYmemVbcl0ub251bmxvYWQoaSksaWUodCxlLHIsYSl9O3ZhciBldD0hMTtjLnJlZHJhdz1mdW5jdGlvbih0KXtpZighZXQpe2V0PSEwLHQmJihGZT0hMCk7dHJ5eyRlJiYhdD8oRWU9PT1lLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8bmV3IERhdGUtSmU+UWUpJiYoJGU+MCYmTWUoJGUpLCRlPUVlKHVlLFFlKSk6KHVlKCksJGU9RWUoZnVuY3Rpb24oKXskZT1udWxsfSxRZSkpfWZpbmFsbHl7ZXQ9RmU9ITF9fX0sYy5yZWRyYXcuc3RyYXRlZ3k9Yy5wcm9wKCksYy53aXRoQXR0cj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGZ1bmN0aW9uKHIpe3I9cnx8d2luZG93LmV2ZW50O3ZhciBhPXIuY3VycmVudFRhcmdldHx8dGhpcyxpPW58fHRoaXMsbz1lIGluIGE/YVtlXTphLmdldEF0dHJpYnV0ZShlKTt0LmNhbGwoaSxvKX19O3ZhciB0dCxudD17cGF0aG5hbWU6XCJcIixoYXNoOlwiI1wiLHNlYXJjaDpcIj9cIn0scnQ9byxhdD0hMTtjLnJvdXRlPWZ1bmN0aW9uKHQsbixyLGEpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBXZTtpZigzPT09YXJndW1lbnRzLmxlbmd0aCYmaShuKSl7cnQ9ZnVuY3Rpb24oZSl7dmFyIGE9V2U9ZGUoZSk7aWYoIXNlKHQscixhKSl7aWYoYXQpdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBkZWZhdWx0IHJvdXRlIG1hdGNoZXMgb25lIG9mIHRoZSByb3V0ZXMgZGVmaW5lZCBpbiBtLnJvdXRlXCIpO2F0PSEwLGMucm91dGUobiwhMCksYXQ9ITF9fTt2YXIgbz1cImhhc2hcIj09PWMucm91dGUubW9kZT9cIm9uaGFzaGNoYW5nZVwiOlwib25wb3BzdGF0ZVwiO3JldHVybiBlW29dPWZ1bmN0aW9uKCl7dmFyIGU9U2VbYy5yb3V0ZS5tb2RlXTtcInBhdGhuYW1lXCI9PT1jLnJvdXRlLm1vZGUmJihlKz1TZS5zZWFyY2gpLFdlIT09ZGUoZSkmJnJ0KGUpfSxWZT1mZSx2b2lkIGVbb10oKX1pZih0LmFkZEV2ZW50TGlzdGVuZXJ8fHQuYXR0YWNoRXZlbnQpe3ZhciB1PVwicGF0aG5hbWVcIiE9PWMucm91dGUubW9kZT9TZS5wYXRobmFtZTpcIlwiO3JldHVybiB0LmhyZWY9dStudFtjLnJvdXRlLm1vZGVdK2EuYXR0cnMuaHJlZix2b2lkKHQuYWRkRXZlbnRMaXN0ZW5lcj8odC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIixjZSksdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixjZSkpOih0LmRldGFjaEV2ZW50KFwib25jbGlja1wiLGNlKSx0LmF0dGFjaEV2ZW50KFwib25jbGlja1wiLGNlKSkpfWlmKGkodCkpe1plPVdlLFdlPXQ7dmFyIGwsZD1ufHx7fSxzPVdlLmluZGV4T2YoXCI/XCIpO2w9cz4tMT92ZShXZS5zbGljZShzKzEpKTp7fTtmb3IodmFyIGYgaW4gZClDZS5jYWxsKGQsZikmJihsW2ZdPWRbZl0pO3ZhciBwLHY9cGUobCk7cD1zPi0xP1dlLnNsaWNlKDAscyk6V2UsdiYmKFdlPXArKHAuaW5kZXhPZihcIj9cIik9PT0tMT9cIj9cIjpcIiZcIikrdik7dmFyIG09KDM9PT1hcmd1bWVudHMubGVuZ3RoP3I6bik9PT0hMHx8WmU9PT1XZTtpZihlLmhpc3RvcnkucHVzaFN0YXRlKXt2YXIgZz1tP1wicmVwbGFjZVN0YXRlXCI6XCJwdXNoU3RhdGVcIjtWZT1mZSxZZT1mdW5jdGlvbigpe3RyeXtlLmhpc3RvcnlbZ10obnVsbCx4ZS50aXRsZSxudFtjLnJvdXRlLm1vZGVdK1dlKX1jYXRjaCh0KXtTZVtjLnJvdXRlLm1vZGVdPVdlfX0scnQobnRbYy5yb3V0ZS5tb2RlXStXZSl9ZWxzZSBTZVtjLnJvdXRlLm1vZGVdPVdlLHJ0KG50W2Mucm91dGUubW9kZV0rV2UpO1plPW51bGx9fSxjLnJvdXRlLnBhcmFtPWZ1bmN0aW9uKGUpe2lmKCF0dCl0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBjYWxsIG0ucm91dGUoZWxlbWVudCwgZGVmYXVsdFJvdXRlLCByb3V0ZXMpIGJlZm9yZSBjYWxsaW5nIG0ucm91dGUucGFyYW0oKVwiKTtyZXR1cm4gZT90dFtlXTp0dH0sYy5yb3V0ZS5tb2RlPVwic2VhcmNoXCIsYy5yb3V0ZS5idWlsZFF1ZXJ5U3RyaW5nPXBlLGMucm91dGUucGFyc2VRdWVyeVN0cmluZz12ZSxjLmRlZmVycmVkPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IGhlO3JldHVybiBlLnByb21pc2U9Z2UoZS5wcm9taXNlKSxlfTt2YXIgaXQ9MSxvdD0yLHV0PTMsbHQ9NDtyZXR1cm4gYy5kZWZlcnJlZC5vbmVycm9yPWZ1bmN0aW9uKGUpe2lmKFwiW29iamVjdCBFcnJvcl1cIj09PUtlLmNhbGwoZSkmJiEvIEVycm9yLy50ZXN0KGUuY29uc3RydWN0b3IudG9TdHJpbmcoKSkpdGhyb3cgUmU9MCxlfSxjLnN5bmM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHQpe3JldHVybiBmdW5jdGlvbihvKXtyZXR1cm4gYVtlXT1vLHR8fChpPVwicmVqZWN0XCIpLDA9PT0tLXImJihuLnByb21pc2UoYSksbltpXShhKSksb319dmFyIG49Yy5kZWZlcnJlZCgpLHI9ZS5sZW5ndGgsYT1bXSxpPVwicmVzb2x2ZVwiO3JldHVybiBlLmxlbmd0aD4wP2YoZSxmdW5jdGlvbihlLG4pe2UudGhlbih0KG4sITApLHQobiwhMSkpfSk6bi5yZXNvbHZlKFtdKSxuLnByb21pc2V9LGMucmVxdWVzdD1mdW5jdGlvbihlKXtlLmJhY2tncm91bmQhPT0hMCYmYy5zdGFydENvbXB1dGF0aW9uKCk7dmFyIHQsbixyLGE9bmV3IGhlLGk9ZS5kYXRhVHlwZSYmXCJqc29ucFwiPT09ZS5kYXRhVHlwZS50b0xvd2VyQ2FzZSgpO3JldHVybiBpPyh0PWUuc2VyaWFsaXplPW49ZS5kZXNlcmlhbGl6ZT15ZSxyPWZ1bmN0aW9uKGUpe3JldHVybiBlLnJlc3BvbnNlVGV4dH0pOih0PWUuc2VyaWFsaXplPWUuc2VyaWFsaXplfHxKU09OLnN0cmluZ2lmeSxuPWUuZGVzZXJpYWxpemU9ZS5kZXNlcmlhbGl6ZXx8SlNPTi5wYXJzZSxyPWUuZXh0cmFjdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVzcG9uc2VUZXh0Lmxlbmd0aHx8biE9PUpTT04ucGFyc2U/ZS5yZXNwb25zZVRleHQ6bnVsbH0pLGUubWV0aG9kPShlLm1ldGhvZHx8XCJHRVRcIikudG9VcHBlckNhc2UoKSxlLnVybD1PZShlLnVybCxlLmRhdGEpLGtlKGUsZS5kYXRhLHQpLGUub25sb2FkPWUub25lcnJvcj1mdW5jdGlvbih0KXt0cnl7dD10fHxldmVudDt2YXIgaT1uKHIodC50YXJnZXQsZSkpO1wibG9hZFwiPT09dC50eXBlPyhlLnVud3JhcFN1Y2Nlc3MmJihpPWUudW53cmFwU3VjY2VzcyhpLHQudGFyZ2V0KSksVGUoaSkmJmUudHlwZT9mKGksZnVuY3Rpb24odCxuKXtpW25dPW5ldyBlLnR5cGUodCl9KTplLnR5cGUmJihpPW5ldyBlLnR5cGUoaSkpLGEucmVzb2x2ZShpKSk6KGUudW53cmFwRXJyb3ImJihpPWUudW53cmFwRXJyb3IoaSx0LnRhcmdldCkpLGEucmVqZWN0KGkpKX1jYXRjaChvKXthLnJlamVjdChvKSxjLmRlZmVycmVkLm9uZXJyb3Iobyl9ZmluYWxseXtlLmJhY2tncm91bmQhPT0hMCYmYy5lbmRDb21wdXRhdGlvbigpfX0sUGUoZSksYS5wcm9taXNlPWdlKGEucHJvbWlzZSxlLmluaXRpYWxWYWx1ZSksYS5wcm9taXNlfSxjfSl9LHt9XSwzOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0KXt2YXIgbj0uNyplLndpZHRoLHI9LjcqZS5oZWlnaHQsYT1wW1wiZGVmYXVsdFwiXS5taW5pS2V5MnBvcyh0KSxpPVthWzBdKihuL3BbXCJkZWZhdWx0XCJdLm1pbmlDb2x1bW5zKSxhWzFdKihyL3BbXCJkZWZhdWx0XCJdLm1pbmlSb3dzKV07cmV0dXJuIGl9ZnVuY3Rpb24gaShlLHQsbil7dmFyIHI9cFtcImRlZmF1bHRcIl0ua2V5MnBvcyhuKSxhPVtyWzBdKihlLndpZHRoL3BbXCJkZWZhdWx0XCJdLmNvbHVtbnMpLHJbMV0qZS5oZWlnaHQqLjVdLGk9W2UubGVmdC10LmxlZnQsZS50b3AtdC50b3BdO3JldHVybltpWzBdK2FbMF0saVsxXSthWzFdXX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuW2VbMF0tdFswXSxlWzFdLXRbMV1dfWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4gdFswXX1mdW5jdGlvbiBsKGUsdCxuKXtyZXR1cm57a2V5OmUsZGlzdGFuY2U6bixjb2xvcjp0LmNvbG9yLG51bWJlcjp0Lm51bWJlcn19ZnVuY3Rpb24gZChlLHQpe3ZhciBuLHIsZCxzLGM9dC5hbmltYXRpb24uY3VycmVudCxmPXBbXCJkZWZhdWx0XCJdLmZpbmRQb3YodC5wb3ZTaWRlLHQudHVyblNpZGUpLG09cFtcImRlZmF1bHRcIl0udmVjdG9yQnlQb3YoZiksZz0odC5ib3VuZHMoKSx0LnRvcEJvdW5kcygpKSxoPXQuYm9hcmRCb3VuZHMoKSx5PWgud2lkdGgsdz0oaC5oZWlnaHQsZy53aWR0aCksYj1nLmhlaWdodCxQPS4wNjI1Kncsaz0uMTQqYixPPS4wNjI1KnkseD17fSxTPVtdLEU9e30sTT17fSxDPXBbXCJkZWZhdWx0XCJdLmRpc2NhcmRCeVBvdihmKSxLPXBbXCJkZWZhdWx0XCJdLmRyYXdCeVBvdihmKSxUPXBbXCJkZWZhdWx0XCJdLnRvcEtleTJwb3MoSyksQT1wW1wiZGVmYXVsdFwiXS50b3BLZXkycG9zKEMpLEQ9W3cqbVswXSxiKm1bMV0rKFwidXBcIj09PWY/LWs6XCJsZWZ0XCI9PT1mPy1rLzI6MCldLEI9WzEyKlAsYi1rXSxqPVtQKkFbMF0saypBWzFdXSxSPVtQKlRbMF0saypUWzFdXSxMPVsxKlAsMSprXSxHPVtdLEY9W10sTj1bXSxfPVtdO2ZvcihuPTA7bjxwW1wiZGVmYXVsdFwiXS5hbGxBbGxvd2VkQm9hcmRLZXlzLmxlbmd0aDtuKyspe3I9cFtcImRlZmF1bHRcIl0uYWxsQWxsb3dlZEJvYXJkS2V5c1tuXSxkPXQucGllY2VzW3JdLHM9ZS5waWVjZXNbcl07dmFyIEk9aShoLGcscik7IWQmJnM/Ry5wdXNoKGwocixzLEkpKTpkJiYhcyYmRi5wdXNoKGwocixkLEkpKX1mb3Iobj0wO248cFtcImRlZmF1bHRcIl0ubWluaUFsbEtleXMubGVuZ3RoO24rKyl7cj1wW1wiZGVmYXVsdFwiXS5taW5pQWxsS2V5c1tuXSxkPXQub3BlbnMubGF5b3V0P3Qub3BlbnMubGF5b3V0LmxheW91dFtyXTpudWxsLHM9ZS5vcGVucy5sYXlvdXQ/ZS5vcGVucy5sYXlvdXQubGF5b3V0W3JdOm51bGw7dmFyIEg9YShnLHIpO2QmJiFzP18ucHVzaChsKHIsZCxIKSk6IWQmJnMmJk4ucHVzaChsKHIscyxIKSl9dmFyIFUscSxYO3JldHVyblwiZG93blwiIT09Znx8dC5zcGVjdGF0b3I/Yy5oaW50PT09dltcImRlZmF1bHRcIl0uZHJhd01pZGRsZT8oVT1bMTIqUCxiXSxxPUQsWD1bcVswXS1VWzBdLHFbMV0tVVsxXV0seFtwW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF09W1gsWCwhMF0pOmMuaGludD09PXZbXCJkZWZhdWx0XCJdLmRpc2NhcmQ/KFU9W1AqQVswXSxrKkFbMV1dLHE9RCxYPVtxWzBdLVVbMF0scVsxXS1VWzFdXSx4W0NdPVtYLFhdKTpjLmhpbnQ9PT12W1wiZGVmYXVsdFwiXS5kcmF3TGVmdD8oVT1bUCpUWzBdLGsqVFsxXV0scT1ELFg9W3FbMF0tVVswXSxxWzFdLVVbMV1dLHhbdltcImRlZmF1bHRcIl0uZHJhd0xlZnQrS109W1gsWCwhMF0sTS5waWVjZT1lLmRpc2NhcmRzW0tdKTpjLmhpbnQ9PT12W1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuPyhVPVtQKlRbMF0saypUWzFdXSxxPUQsWD1bcVswXS1VWzBdLHFbMV0tVVsxXV0seFtLXT1bWCxYXSk6Yy5oaW50PT09dltcImRlZmF1bHRcIl0ub3BlblNlcmllcz9fLmZvckVhY2goZnVuY3Rpb24oZSx0KXtxPUQscT1vKHEsTCkscT1vKHEsZS5kaXN0YW5jZSksVT1bMCwwXSxYPVtxWzBdLVVbMF0scVsxXS1VWzFdXSx4W2Uua2V5XT1bWCxYXSxFW2Uua2V5XT1bMS43NSwxLjc1XX0pOmMuaGludD09PXZbXCJkZWZhdWx0XCJdLmNvbGxlY3RPcGVuJiZOLmZvckVhY2goZnVuY3Rpb24oZSx0KXtxPUQscT1vKHEsTCkscT1vKHEsZS5kaXN0YW5jZSksVT1bMCwwXSxYPVtxWzBdLVVbMF0scVsxXS1VWzFdXSx4W2Uua2V5XT1bWCxYLCEwXSxNW2Uua2V5XT1lfSk6Yy5oaW50PT09dltcImRlZmF1bHRcIl0uZHJhd01pZGRsZSYmRlswXT8ocj1GWzBdLmtleSxVPUZbMF0uZGlzdGFuY2UsVT1vKFUsQikscT1bMCwwXSxYPVtxWzBdLVVbMF0scVsxXS1VWzFdXSx4W3JdPVtYLFhdKTpjLmhpbnQ9PT12W1wiZGVmYXVsdFwiXS5kaXNjYXJkJiZHWzBdPyhxPUdbMF0uZGlzdGFuY2UscT1vKHEsaiksVT1bMCwwXSxYPVtxWzBdLVVbMF0scVsxXS1VWzFdXSx4W0NdPVtYLFhdKTpjLmhpbnQ9PT12W1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuP0dbMF0/KHE9R1swXS5kaXN0YW5jZSxxPW8ocSxSKSxVPVswLDBdLFg9W3FbMF0tVVswXSxxWzFdLVVbMV1dLHhbS109W1gsWF0pOihVPVtQKlRbMF0saypUWzFdXSxxPUQsWD1bcVswXS1VWzBdLHFbMV0tVVsxXV0seFtLXT1bWCxYXSk6Yy5oaW50PT09dltcImRlZmF1bHRcIl0ub3BlblNlcmllcyYmXy5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7dmFyIG49dShlLEcuZmlsdGVyKHBbXCJkZWZhdWx0XCJdLnBhcnRpYWwocFtcImRlZmF1bHRcIl0ucGllY2VFcXVhbCxlKSkpO0cuc3BsaWNlKEcuaW5kZXhPZihuKSwxKSxuJiYocT1uLmRpc3RhbmNlLHE9byhuLmRpc3RhbmNlLFtPLDBdKSxxPW8ocSxMKSxxPW8ocSxlLmRpc3RhbmNlKSxVPVswLDBdLFg9W3FbMF0tVVswXSxxWzFdLVVbMV1dLHhbZS5rZXldPVtYLFhdLEVbZS5rZXldPVsxLjc1LDEuNzVdKX0pLHthbmltczp4LGZhZGluZ3M6UyxzY2FsZXM6RSxleHRyYTpNfX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIE1hdGgucm91bmQoZSp0KS90fWZ1bmN0aW9uIGMoZSl7aWYoZS5hbmltYXRpb24uY3VycmVudC5zdGFydCl7dmFyIHQ9MS0oKG5ldyBEYXRlKS5nZXRUaW1lKCktZS5hbmltYXRpb24uY3VycmVudC5zdGFydCkvZS5hbmltYXRpb24uY3VycmVudC5kdXJhdGlvbjtpZih0PD0wKWUuYW5pbWF0aW9uLmN1cnJlbnQ9e30sZS5yZW5kZXIoKTtlbHNle3ZhciBuLHI9bS5lYXNlSW5PdXRDdWJpYyh0KTtmb3IodmFyIGEgaW4gZS5hbmltYXRpb24uY3VycmVudC5hbmltcyluPWUuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXNbYV0sblsxXT1bcyhuWzBdWzBdKnIsMTApLHMoblswXVsxXSpyLDEwKV0sblsyXSYmKG5bMV09W25bMF1bMF0tblsxXVswXSxuWzBdWzFdLW5bMV1bMV1dKTt2YXIgaTtmb3IoaSBpbiBlLmFuaW1hdGlvbi5jdXJyZW50LmZhZGluZ3MpZS5hbmltYXRpb25zLmN1cnJlbnQuZmFkaW5nc1tpXS5vcGFjaXR5PXMociwxMDApO2ZvcihpIGluIGUuYW5pbWF0aW9uLmN1cnJlbnQuc2NhbGVzKW49ZS5hbmltYXRpb24uY3VycmVudC5zY2FsZXNbaV0sblswXT0xK3MoLjcqciwxMCksblsxXT0xK3MoLjcqciwxMCk7ZS5yZW5kZXIoKSxwW1wiZGVmYXVsdFwiXS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtjKGUpfSl9fX1mdW5jdGlvbiBmKGUsdCl7dmFyIG4scj17cGllY2VzOnt9LG9wZW5zOnt9LG1pZGRsZXM6e30sZGlzY2FyZHM6e319O2ZvcihuIGluIHQucGllY2VzKXQucGllY2VzW25dJiYoci5waWVjZXNbbl09e2NvbG9yOnQucGllY2VzW25dLmNvbG9yLG51bWJlcjp0LnBpZWNlc1tuXS5udW1iZXJ9KTtmb3IobiBpbiB0LmRpc2NhcmRzKXQuZGlzY2FyZHNbbl0mJnQuZGlzY2FyZHNbbl1bMF0mJihyLmRpc2NhcmRzW25dPXtjb2xvcjp0LmRpc2NhcmRzW25dWzBdLmNvbG9yLG51bWJlcjp0LmRpc2NhcmRzW25dWzBdLm51bWJlcn0pO2lmKHQub3BlbnMubGF5b3V0KXt2YXIgYTtyLm9wZW5zLmxheW91dD17bGF5b3V0Ont9fTtmb3IobiBpbiB0Lm9wZW5zLmxheW91dC5sYXlvdXQpYT10Lm9wZW5zLmxheW91dC5sYXlvdXRbbl0sci5vcGVucy5sYXlvdXQubGF5b3V0W25dPXtjb2xvcjphLmNvbG9yLG51bWJlcjphLm51bWJlcn19dmFyIGk9ZSgpLG89ZChyLHQpO2lmKE9iamVjdC5rZXlzKG8uYW5pbXMpLmxlbmd0aD4wfHxvLmZhZGluZ3MubGVuZ3RoPjApe3ZhciB1PXQuYW5pbWF0aW9uLmN1cnJlbnQuc3RhcnQ7dC5hbmltYXRpb24uY3VycmVudD17c3RhcnQ6KG5ldyBEYXRlKS5nZXRUaW1lKCksZHVyYXRpb246dC5hbmltYXRpb24uZHVyYXRpb24sYW5pbXM6by5hbmltcyxmYWRpbmdzOm8uZmFkaW5ncyxzY2FsZXM6by5zY2FsZXMsZXh0cmE6by5leHRyYX0sdXx8Yyh0KX1lbHNlIHQucmVuZGVyUkFGKCk7cmV0dXJuIGl9dmFyIHA9cihlKFwiLi91dGlsXCIpKSx2PXIoZShcIi4vbW92ZVwiKSksbT17ZWFzZUluT3V0Q3ViaWM6ZnVuY3Rpb24oZSl7cmV0dXJuIGU8LjU/NCplKmUqZTooZS0xKSooMiplLTIpKigyKmUtMikrMX19O3QuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPVt0XS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApKTtpZih0LmFuaW1hdGlvbi5lbmFibGVkKXJldHVybiBmKHBbXCJkZWZhdWx0XCJdLnBhcnRpYWxBcHBseShlLG4pLHQpO3ZhciByPWUuYXBwbHkobnVsbCxuKTtyZXR1cm4gdC5yZW5kZXJSQUYoKSxyfX19LHtcIi4vbW92ZVwiOjEyLFwiLi91dGlsXCI6MTd9XSw0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fXZhciBhPXIoZShcIm1pdGhyaWxcIikpLGk9cihlKFwiLi92aWV3XCIpKSxvPXIoZShcIi4vYm9hcmRcIikpO3QuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm57c2V0OmUuc2V0LGdldFBpZWNlR3JvdXBzOmZ1bmN0aW9uKCl7cmV0dXJuIG9bXCJkZWZhdWx0XCJdLmdldFBpZWNlR3JvdXBzKGUuZGF0YSl9LGF0dGFjaDpmdW5jdGlvbih0KXthW1wiZGVmYXVsdFwiXS5yZW5kZXIodCwoMCxpW1wiZGVmYXVsdFwiXSkoZSksITApfSxkZXRhY2g6ZnVuY3Rpb24oKXt9LHNvcnRQYWlyczplLnNvcnRQYWlycyxzb3J0U2VyaWVzOmUuc29ydFNlcmllcyxhcGlNb3ZlOmUuYXBpTW92ZSxhcGlEcmF3TWlkZGxlRW5kOmUuYXBpRHJhd01pZGRsZUVuZCxwbGF5T3BlblNlcmllczplLnBsYXlPcGVuU2VyaWVzLHBsYXlPcGVuUGFpcnM6ZS5wbGF5T3BlblBhaXJzLHBsYXlMZWF2ZVRha2VuOmUucGxheUxlYXZlVGFrZW4sY2FuT3BlblNlcmllczplLmNhbk9wZW5TZXJpZXMsY2FuT3BlblBhaXJzOmUuY2FuT3BlblBhaXJzLGNhbkNvbGxlY3RPcGVuOmUuY2FuQ29sbGVjdE9wZW4sY2FuTGVhdmVUYWtlbjplLmNhbkxlYXZlVGFrZW4sc3RvcDplLnN0b3AsZ2V0UGllY2VHcm91cFNlcmllczplLmdldFBpZWNlR3JvdXBTZXJpZXMsZ2V0UGllY2VHcm91cFBhaXJzOmUuZ2V0UGllY2VHcm91cFBhaXJzLGdldEZlbjplLmdldEZlbn19fSx7XCIuL2JvYXJkXCI6NSxcIi4vdmlld1wiOjE4LG1pdGhyaWw6Mn1dLDU6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gaShlLHQpe3JldHVybiBsKGUpfHx1KGUsdCl8fG8oKX1mdW5jdGlvbiBvKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9ZnVuY3Rpb24gdShlLHQpe3ZhciBuPVtdLHI9ITAsYT0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBvLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShvPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChvLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtyPSEwKTt9Y2F0Y2gobCl7YT0hMCxpPWx9ZmluYWxseXt0cnl7cnx8bnVsbD09dVtcInJldHVyblwiXXx8dVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYoYSl0aHJvdyBpfX1yZXR1cm4gbn1mdW5jdGlvbiBsKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9ZnVuY3Rpb24gZChlKXtpZihGKGUpKXt2YXIgdD1lLm1pZGRsZXNbbmVbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxuPWVlKGUpO2lmKG49bi5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIGllW1wiZGVmYXVsdFwiXS5zZXJpZXMobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSksdCl9KSxuLmxlbmd0aD4wKXt2YXIgcj1ZKG4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pKTtyZXR1cm4gbShlLG4pLHVlKG5lW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIscmVbXCJkZWZhdWx0XCJdLm9wZW5TZXJpZXMsb2UocikpKSxlLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9cmVbXCJkZWZhdWx0XCJdLm9wZW5TZXJpZXMsITB9fXJldHVybiExfWZ1bmN0aW9uIHMoZSl7aWYoTihlKSl7dmFyIHQ9ZS5taWRkbGVzW25lW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0sbj1lZShlKTtpZihuPW4uZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiBpZVtcImRlZmF1bHRcIl0ucGFpcnMobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSksdCl9KSxuLmxlbmd0aD4wKXt2YXIgcj1ZKG4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pKTtyZXR1cm4gdihlLG4pLHVlKG5lW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIscmVbXCJkZWZhdWx0XCJdLm9wZW5QYWlycyxvZShyKSkpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1yZVtcImRlZmF1bHRcIl0ub3BlblNlcmllcywhMH19cmV0dXJuITF9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiB0PWFlW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UodCkucGllY2UsISghXyhlKXx8IU8oZSx0KSkmJih1ZShuZVtcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLHJlW1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuKSksZS5hbmltYXRpb24uY3VycmVudC5oaW50PXJlW1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuLCEwKX1mdW5jdGlvbiBmKGUsdCl7dmFyIG49bmVbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50O3coZSxuKSxwKGUsdCl9ZnVuY3Rpb24gcChlLHQpe1wic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1hZVtcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHQpLnBpZWNlKSxlLm1pZGRsZUhvbGRlci5waWVjZT10LGcoZSl9ZnVuY3Rpb24gdihlLHQpe3ZhciBuPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pLHI9WShuKTt1ZShuZVtcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLHJlW1wiZGVmYXVsdFwiXS5vcGVuUGFpcnMsb2UocikpKSx0LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBkZWxldGUgZS5waWVjZXNbdF19KX0pO3ZhciBhPWUub3BlbnMucGFpcnMuY29uY2F0KG4pO2Uub3BlbnMucGFpcnM9YSxlLm9wZW5zLnJlbGF5b3V0KGUpfWZ1bmN0aW9uIG0oZSx0KXt2YXIgbj10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSl9KSxyPVkobik7dWUobmVbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxyZVtcImRlZmF1bHRcIl0ub3BlblNlcmllcyxvZShyKSkpLHQuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSBlLnBpZWNlc1t0XX0pfSk7dmFyIGE9ZS5vcGVucy5zZXJpZXMuY29uY2F0KG4pO2Uub3BlbnMuc2VyaWVzPWEsZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBnKGUpe3ZhciB0PWUubWlkZGxlSG9sZGVyLmtleSxuPWUubWlkZGxlSG9sZGVyLnBpZWNlO3QmJm4mJihlLnBpZWNlc1t0XT1uLGUubGFzdE1vdmU9W25lW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0sZS5taWRkbGVIb2xkZXIuY3VycmVudD0hMSxlLm1pZGRsZUhvbGRlci5rZXk9bnVsbCxlLm1pZGRsZUhvbGRlci5waWVjZT1udWxsKX1mdW5jdGlvbiBoKGUsdCxuKXt2YXIgcj1YKGUsdCk7aWYoci5sZW5ndGg+MCl7dmFyIGE9clswXS5tYXAoZnVuY3Rpb24odCxhKXt2YXIgaT1yWzBdLmxlbmd0aC1hLTEsbz1uZVtcImRlZmF1bHRcIl0uZGVjQm9hcmRLZXkobiwyKmkpO3JldHVyblt0LG8sZS5waWVjZXNbdF1dfSksbz1hLmV2ZXJ5KGZ1bmN0aW9uKHQpe3ZhciBuPWkodCwzKSxyPShuWzBdLG5bMV0pO25bMl07cmV0dXJuIG5lW1wiZGVmYXVsdFwiXS5pc0FsbEFsbG93ZWRCb2FyZEtleShyKSYmW3IsbmVbXCJkZWZhdWx0XCJdLmRlY0JvYXJkS2V5KHIsLTEpXS5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4hZS5waWVjZXNbdF18fGEuZmlsdGVyKGZ1bmN0aW9uKGUpe3ZhciBuPWkoZSwzKSxyPW5bMF07blsxXSxuWzJdO3JldHVybiByPT09dH0pLmxlbmd0aD4wfSl9KTtyZXR1cm4hIW8mJihhLm1hcChmdW5jdGlvbih0KXt2YXIgbj1pKHQsMykscj1uWzBdLGE9blsxXSxvPW5bMl07cmV0dXJuIGRlbGV0ZSBlLnBpZWNlc1tyXSxbcixhLG9dfSkubWFwKGZ1bmN0aW9uKHQpe3ZhciBuPWkodCwzKSxyPShuWzBdLG5bMV0pLGE9blsyXTtlLnBpZWNlc1tyXT1hfSksITApfXJldHVybiExfWZ1bmN0aW9uIHkoZSx0LG4pe2lmKHQ9PT1ufHwhZS5waWVjZXNbdF0pcmV0dXJuITE7dmFyIHI9ZS5waWVjZXNbbl07cmV0dXJuIGUucGllY2VzW25dPWUucGllY2VzW3RdLGUucGllY2VzW3RdPXIsITB9ZnVuY3Rpb24gdyhlLHQpe2UubWlkZGxlc1tuZVtcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdLS0sZS5taWRkbGVIb2xkZXIuY3VycmVudD0hMDt2YXIgbj16KGUpO3JldHVybiBlLm1pZGRsZUhvbGRlci5rZXk9biwhMH1mdW5jdGlvbiBiKGUsdCxuKXtpZighbnx8ZS5waWVjZXNbbl0pe3ZhciByPXooZSk7bj1yfXJldHVybiB1ZShuZVtcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLHJlW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlRW5kKSksZS5taWRkbGVIb2xkZXIua2V5PW4sZyhlKSwhMH1mdW5jdGlvbiBQKGUsdCl7cmV0dXJuIHVlKG5lW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUscmVbXCJkZWZhdWx0XCJdLmRyYXdNaWRkbGUpKSxlLm1pZGRsZXNbbmVbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50XS0tLGUubWlkZGxlSG9sZGVyLmN1cnJlbnQ9ITAsITB9ZnVuY3Rpb24gayhlLHQsbil7cmV0dXJuIWUucGllY2VzW25dJiYodWUobmVbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxyZVtcImRlZmF1bHRcIl0uZHJhd0xlZnQpKSxlLnBpZWNlc1tuXT1lLmRpc2NhcmRzW25lW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1sxXV1bMF0sZS5kaXNjYXJkc1tuZVtcImRlZmF1bHRcIl0uZGlzY2FyZHNbMV1dLnNoaWZ0KCksXG4hMCl9ZnVuY3Rpb24gTyhlLHQpe3ZhciBuPSQoZSx0KTtpZighbilyZXR1cm4hMTt1ZShuZVtcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLHJlW1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuKSk7dmFyIHI9bmVbXCJkZWZhdWx0XCJdLmZpbmRQb3YoZS5wb3ZTaWRlLGUudHVyblNpZGUpO3JldHVybiBkZWxldGUgZS5waWVjZXNbbl0sZS5kaXNjYXJkc1tuZVtcImRlZmF1bHRcIl0uZHJhd0J5UG92KHIpXS51bnNoaWZ0KHQpLCEwfWZ1bmN0aW9uIHgoZSx0LG4pe2lmKG4mJm5lW1wiZGVmYXVsdFwiXS5pc0JvYXJkS2V5KHQpJiZuZVtcImRlZmF1bHRcIl0uaXNCb2FyZEtleShuKSYmQihlLHQsbikpe2lmKGgoZSx0LG4pKXJldHVybiEwO2lmKHkoZSx0LG4pKXJldHVybiEwfX1mdW5jdGlvbiBTKGUsdCl7aWYobmVbXCJkZWZhdWx0XCJdLmlzTWlkZGxlS2V5KHQpJiZSKGUsdCkpcmV0dXJuIFAoZSx0KSwhMH1mdW5jdGlvbiBFKGUsdCxuKXtpZihuZVtcImRlZmF1bHRcIl0uaXNNaWRkbGVLZXkodCkmJkwoZSx0KSlyZXR1cm4gYihlLHQsbiksITB9ZnVuY3Rpb24gTShlLHQsbil7aWYobiYmbmVbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkobikmJm5lW1wiZGVmYXVsdFwiXS5pc0RyYXdMZWZ0S2V5KHQpJiZHKGUsdCxuKSYmayhlLHQsbikpcmV0dXJuIHVlKG5lW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIscmVbXCJkZWZhdWx0XCJdLmRyYXdMZWZ0KSksITB9ZnVuY3Rpb24gQyhlLHQsbil7bnx8KG5lW1wiZGVmYXVsdFwiXS5pc01pZGRsZUtleSh0KT9TKGUsdCkmJlQoZSx0KTpuZVtcImRlZmF1bHRcIl0uaXNEcmF3TGVmdEtleSh0KSYmRyhlKSYmVChlLHQpKX1mdW5jdGlvbiBLKGUsdCl7ZS5zZWxlY3RlZD8odD9lLnNlbGVjdGVkIT09dCYmKHgoZSxlLnNlbGVjdGVkLHQpfHxNKGUsZS5zZWxlY3RlZCx0KXx8RShlLGUuc2VsZWN0ZWQsdCkpOkUoZSxlLnNlbGVjdGVkLHQpLFQoZSxudWxsKSk6RChlLHQpJiZUKGUsdCl9ZnVuY3Rpb24gVChlLHQpe2lmKGUuc2VsZWN0ZWQ9dCx0JiZuZVtcImRlZmF1bHRcIl0uaXNCb2FyZEtleSh0KSlpZihxKGUsdCkpe3ZhciBuPWUubWlkZGxlc1tuZVtcImRlZmF1bHRcIl0uZ29zdGVyZ2VdO2Uub3BlbmFibGUuZGVzdHM9aWVbXCJkZWZhdWx0XCJdLmNvbXB1dGUoZS5vcGVucyxlLnBpZWNlc1t0XSxuKX1lbHNlIGUub3BlbmFibGUuZGVzdHM9W107ZWxzZSBlLm9wZW5hYmxlLmRlc3RzPVtdfWZ1bmN0aW9uIEEoZSl7cmV0dXJuIGUucG92U2lkZT09PWUudHVyblNpZGV9ZnVuY3Rpb24gRChlLHQpe3ZhciBuPWUucGllY2VzW3RdO3JldHVybiBuJiZlLm1vdmFibGUuYm9hcmR9ZnVuY3Rpb24gQihlLHQsbil7cmV0dXJuIHQhPW4mJkQoZSx0KX1mdW5jdGlvbiBqKGUpe3JldHVybiBBKGUpfWZ1bmN0aW9uIFIoZSx0KXtyZXR1cm4gaihlKSYmIWUubWlkZGxlSG9sZGVyLmN1cnJlbnQmJm5lW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLHJlW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlKX1mdW5jdGlvbiBMKGUpe3JldHVybiBlLm1pZGRsZUhvbGRlci5jdXJyZW50fWZ1bmN0aW9uIEcoZSx0LG4pe3JldHVybiBqKGUpJiYhTChlKSYmbmVbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMscmVbXCJkZWZhdWx0XCJdLmRyYXdMZWZ0KX1mdW5jdGlvbiBGKGUpe3JldHVybiBBKGUpJiZuZVtcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxyZVtcImRlZmF1bHRcIl0ub3BlblNlcmllcyl9ZnVuY3Rpb24gTihlKXtyZXR1cm4gQShlKSYmbmVbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMscmVbXCJkZWZhdWx0XCJdLm9wZW5QYWlycyl9ZnVuY3Rpb24gXyhlKXtyZXR1cm4gQShlKSYmbmVbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMscmVbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW4pfWZ1bmN0aW9uIEkoZSl7cmV0dXJuIEEoZSkmJm5lW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLHJlW1wiZGVmYXVsdFwiXS5jb2xsZWN0T3Blbil9ZnVuY3Rpb24gSChlKXtLKGUsbnVsbCl9ZnVuY3Rpb24gVShlKXtlLm1vdmFibGUuc2lkZT1udWxsLGUubW92YWJsZS5kZXN0cz1bXSxlLm9wZW5hYmxlLmRlc3RzPVtdLGUubW92YWJsZS5ib2FyZD0hMSxIKGUpfWZ1bmN0aW9uIHEoZSx0KXt2YXIgbj1lLnBpZWNlc1t0XTtyZXR1cm4hKCFufHxlLnBvdlNpZGUhPT1lLnR1cm5TaWRlKX1mdW5jdGlvbiBYKGUsdCl7dmFyIG49ZS5taWRkbGVzW25lW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0scj1lZShlKTtyZXR1cm4gcj1yLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZVtlLmxlbmd0aC0xXT09PXR9KSxyPXIuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBpZVtcImRlZmF1bHRcIl0uc2VyaWVzKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnBpZWNlc1t0XX0pLG4pfHxpZVtcImRlZmF1bHRcIl0ucGFpcnModC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSksbil9KX1mdW5jdGlvbiB6KGUpe3ZhciB0PW5lW1wiZGVmYXVsdFwiXS5hbGxBbGxvd2VkQm9hcmRLZXlzLnNsaWNlKDEpLG49bmVbXCJkZWZhdWx0XCJdLmFsbEFsbG93ZWRCb2FyZEtleXMuc2xpY2UoMikscj1uZVtcImRlZmF1bHRcIl0uYWxsQWxsb3dlZEJvYXJkS2V5cy5tYXAoZnVuY3Rpb24oZSxyKXtyZXR1cm5bZSx0W3JdLG5bcl1dfSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3ZhciBuPWkodCwzKSxyPW5bMF0sYT1uWzFdLG89blsyXTtyZXR1cm4gciYmYSYmbyYmIWUucGllY2VzW3JdJiYhZS5waWVjZXNbYV0mJiFlLnBpZWNlc1tvXX0pO3JldHVybiByW3IubGVuZ3RoLTFdWzFdfWZ1bmN0aW9uICQoZSx0KXtyZXR1cm4gbmVbXCJkZWZhdWx0XCJdLmFsbEFsbG93ZWRCb2FyZEtleXMuZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiBlLnBpZWNlc1tuXSYmbmVbXCJkZWZhdWx0XCJdLnBpZWNlRXF1YWwoZS5waWVjZXNbbl0sdCl9KVswXX1mdW5jdGlvbiBKKGUsdCxuLHIpe3ZhciBhPVYoZSx0LG4pO2lmKCFhKXJldHVybiBhO3ZhciBpPW5lW1wiZGVmYXVsdFwiXS5kZWNCb2FyZEtleShhKTtyZXR1cm4gaSE9PXImJmUucGllY2VzW2ldJiYoYT1pKSxuZVtcImRlZmF1bHRcIl0ubm90QWxsb3dlZEJvYXJkS2V5cy5pbmRleE9mKGEpIT09LTE/bnVsbDphfWZ1bmN0aW9uIFYoZSx0LG4pe2lmKG58fGUuYm91bmRzKXtuPW58fGUuYm91bmRzKCk7dmFyIHI9TWF0aC5mbG9vcihuZVtcImRlZmF1bHRcIl0uY29sdW1ucyooKHRbMF0tbi5sZWZ0KS9uLndpZHRoKSksYT1NYXRoLmZsb29yKG5lW1wiZGVmYXVsdFwiXS5yb3dzKigodFsxXS1uLnRvcCkvbi5oZWlnaHQpKTtyZXR1cm4gYT49MCYmYTxuZVtcImRlZmF1bHRcIl0ucm93cyYmcj49MCYmcjxuZVtcImRlZmF1bHRcIl0uY29sdW1ucz9uZVtcImRlZmF1bHRcIl0ucG9zMmtleShbcixhXSk6dm9pZCAwfX1mdW5jdGlvbiBZKGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUua2V5fSkuam9pbihcIlwiKX0pLmpvaW4oXCIgXCIpfWZ1bmN0aW9uIFEoZSl7dmFyIHQ9ZS5taWRkbGVzW25lW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0sbj1lLndpdGhUb3JlLHI9WihlKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGllW1wiZGVmYXVsdFwiXS5zZXJpZXMoZSx0LG4pfSk7cmV0dXJuIFkocil9ZnVuY3Rpb24gVyhlKXt2YXIgdD1lLm1pZGRsZXNbbmVbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxuPVooZSkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBpZVtcImRlZmF1bHRcIl0ucGFpcnMoZSx0KX0pO3JldHVybiBZKG4pfWZ1bmN0aW9uIFooZSl7cmV0dXJuIGVlKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSl9KX1mdW5jdGlvbiBlZShlKXt2YXIgdD1uZVtcImRlZmF1bHRcIl0ucG9zMmtleShbbmVbXCJkZWZhdWx0XCJdLmNvbHVtbnMtMSwwXSksbj1uZVtcImRlZmF1bHRcIl0uYWxsS2V5cy5zbGljZSgxKSxyPW5lW1wiZGVmYXVsdFwiXS5hbGxLZXlzLm1hcChmdW5jdGlvbihlLHQpe3JldHVybltlLG5bdF1dfSkucmVkdWNlKGZ1bmN0aW9uKG4scil7dmFyIGE9aShuLDIpLG89YVswXSx1PWFbMV0sbD1pKHIsMiksZD1sWzBdLHM9bFsxXTtyZXR1cm4gZS5waWVjZXNbZF0mJm8ucHVzaChkKSwoZCYmIWUucGllY2VzW2RdJiZzJiYhZS5waWVjZXNbc118fGQ9PT10KSYmMCE9PW8ubGVuZ3RoJiYodS5wdXNoKG8pLG89W10pLFtvLHVdfSxbW10sW11dKSxhPWkociwyKSxvPWFbMF0sdT1hWzFdO3JldHVybiAwIT09by5sZW5ndGgmJnUucHVzaChvKSx1fXZhciB0ZSxuZT1yKGUoXCIuL3V0aWxcIikpLHJlPXIoZShcIi4vbW92ZVwiKSksYWU9cihlKFwiLi9waWVjZXNcIikpLGllPXIoZShcIi4vb3BlblwiKSksb2U9bmVbXCJkZWZhdWx0XCJdLndyYXBHcm91cCx1ZT1uZVtcImRlZmF1bHRcIl0uY2FsbFVzZXJGdW5jdGlvbjt0LmV4cG9ydHM9KHRlPXtwbGF5T3BlblNlcmllczpkLHBsYXlPcGVuUGFpcnM6cyxwbGF5TGVhdmVUYWtlbjpjLGFwaURyYXdNaWRkbGVFbmQ6cH0sYSh0ZSxcImFwaURyYXdNaWRkbGVFbmRcIixwKSxhKHRlLFwiYXBpRm9yY2VEcmF3TWlkZGxlRW5kXCIsZiksYSh0ZSxcImFwaUZvcmNlRHJhd01pZGRsZUVuZFwiLGYpLGEodGUsXCJ1c2VyTW92ZVwiLHgpLGEodGUsXCJ1c2VyRHJhd0xlZnRcIixNKSxhKHRlLFwidXNlckJlZ2luRHJhd01pZGRsZVwiLFMpLGEodGUsXCJ1c2VyRW5kRHJhd01pZGRsZVwiLEUpLGEodGUsXCJzZWxlY3RTcXVhcmVcIixLKSxhKHRlLFwic2VsZWN0VG9wXCIsQyksYSh0ZSxcInNldFNlbGVjdGVkXCIsVCksYSh0ZSxcImNhbk9wZW5TZXJpZXNcIixGKSxhKHRlLFwiY2FuT3BlblBhaXJzXCIsTiksYSh0ZSxcImNhbkxlYXZlVGFrZW5cIixfKSxhKHRlLFwiY2FuQ29sbGVjdE9wZW5cIixJKSxhKHRlLFwic3RvcFwiLFUpLGEodGUsXCJjYW5jZWxNb3ZlXCIsSCksYSh0ZSxcImlzRHJvcHBhYmxlT3BlbnNcIixxKSxhKHRlLFwiZmluZEJvYXJkRHJhZ0dyb3VwXCIsWCksYSh0ZSxcImdldEtleUF0RG9tUG9zXCIsViksYSh0ZSxcImdldEtleUF0RG9tUG9zT25QaWVjZVwiLEopLGEodGUsXCJnZXRQaWVjZUdyb3Vwc1wiLFopLGEodGUsXCJnZXRQaWVjZUdyb3VwU2VyaWVzXCIsUSksYSh0ZSxcImdldFBpZWNlR3JvdXBQYWlyc1wiLFcpLHRlKX0se1wiLi9tb3ZlXCI6MTIsXCIuL29wZW5cIjoxMyxcIi4vcGllY2VzXCI6MTQsXCIuL3V0aWxcIjoxN31dLDY6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19dmFyIGE9cihlKFwibWVyZ2VcIikpLGk9cihlKFwiLi9waWVjZXNcIikpO3QuZXhwb3J0cz1mdW5jdGlvbihlLHQpe2lmKHQpaWYoYVtcImRlZmF1bHRcIl0ucmVjdXJzaXZlKGUsdCksZS5mZW4pe2Uuc3BlY3RhdG9yJiYoZS5mZW49ZS5wb3ZTaWRlWzBdK2UuZmVuLnNsaWNlKDEpKSxlLmFuaW1hdGlvbkhpbnQ/KGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1lLmFuaW1hdGlvbkhpbnQsZGVsZXRlIGUuYW5pbWF0aW9uSGludCk6ZS5hbmltYXRpb24uY3VycmVudC5oaW50PVwiXCI7dmFyIG49aVtcImRlZmF1bHRcIl0ucmVhZChlLmZlbik7ZS5waWVjZXM9bi5waWVjZXMsZS5kaXNjYXJkcz1uLmRpc2NhcmRzLGUub3BlbnM9bi5vcGVucyxlLm1pZGRsZXM9bi5taWRkbGVzLGRlbGV0ZSBlLmZlbn1lbHNlIGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1cIlwifX0se1wiLi9waWVjZXNcIjoxNCxtZXJnZToxfV0sNzpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX12YXIgYT1yKGUoXCIuL3RhYmxlXCIpKSxpPXIoZShcIi4vYm9hcmRcIikpLG89cihlKFwiLi9zb3J0ZXJcIikpLHU9cihlKFwiLi9kYXRhXCIpKSxsPXIoZShcIi4vY29uZmlndXJlXCIpKSxkPXIoZShcIi4vdXRpbFwiKSkscz1yKGUoXCIuL2FuaW1cIikpLGM9cihlKFwiLi9kcmFnXCIpKSxmPXIoZShcIi4vcGllY2VzXCIpKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLmRhdGE9KDAsdVtcImRlZmF1bHRcIl0pKGUpLHRoaXMuZGF0YS5mbGlwUGllY2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3QmJiF0aGlzLmZsaXBwYWJsZS5jdXJyZW50Lm9yaWcmJih0aGlzLmZsaXBwYWJsZS5jdXJyZW50PXtvcmlnOmV9LHRoaXMucmVuZGVyUkFGKCksc2V0VGltZW91dChmdW5jdGlvbigpe24uZmxpcHBhYmxlLmN1cnJlbnQuZmxpcD0hMCxuLnJlbmRlclJBRigpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LmZsaXA9IXQuZmxpcCxuLmZsaXBwYWJsZS5jdXJyZW50PXt9LG4ucmVuZGVyUkFGKCl9LDYwMCl9LDEwKSl9LmJpbmQodGhpcy5kYXRhKSx0aGlzLmdldEZlbj1mdW5jdGlvbigpe3JldHVybiBmW1wiZGVmYXVsdFwiXS53cml0ZSh0LmRhdGEucGllY2VzKX0sdGhpcy5nZXRQaWVjZUdyb3VwU2VyaWVzPWZ1bmN0aW9uKCl7cmV0dXJuIGlbXCJkZWZhdWx0XCJdLmdldFBpZWNlR3JvdXBTZXJpZXModC5kYXRhKX0sdGhpcy5nZXRQaWVjZUdyb3VwUGFpcnM9ZnVuY3Rpb24oKXtyZXR1cm4gaVtcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFBhaXJzKHQuZGF0YSl9LHRoaXMuc2V0PSgwLHNbXCJkZWZhdWx0XCJdKShsW1wiZGVmYXVsdFwiXSx0aGlzLmRhdGEpLHRoaXMuYXBpTW92ZT0oMCxzW1wiZGVmYXVsdFwiXSkoYVtcImRlZmF1bHRcIl0uYXBpTW92ZSx0aGlzLmRhdGEpLHRoaXMuYXBpRHJhd01pZGRsZUVuZD0oMCxzW1wiZGVmYXVsdFwiXSkoaVtcImRlZmF1bHRcIl0uYXBpRHJhd01pZGRsZUVuZCx0aGlzLmRhdGEpLHRoaXMucGxheU9wZW5TZXJpZXM9KDAsc1tcImRlZmF1bHRcIl0pKGlbXCJkZWZhdWx0XCJdLnBsYXlPcGVuU2VyaWVzLHRoaXMuZGF0YSksdGhpcy5wbGF5T3BlblBhaXJzPSgwLHNbXCJkZWZhdWx0XCJdKShpW1wiZGVmYXVsdFwiXS5wbGF5T3BlblBhaXJzLHRoaXMuZGF0YSksdGhpcy5wbGF5TGVhdmVUYWtlbj0oMCxzW1wiZGVmYXVsdFwiXSkoaVtcImRlZmF1bHRcIl0ucGxheUxlYXZlVGFrZW4sdGhpcy5kYXRhKSx0aGlzLnNvcnRQYWlycz0oMCxzW1wiZGVmYXVsdFwiXSkob1tcImRlZmF1bHRcIl0uc29ydFBhaXJzLHRoaXMuZGF0YSksdGhpcy5zb3J0U2VyaWVzPSgwLHNbXCJkZWZhdWx0XCJdKShvW1wiZGVmYXVsdFwiXS5zb3J0U2VyaWVzLHRoaXMuZGF0YSksdGhpcy5jYW5MZWF2ZVRha2VuPWRbXCJkZWZhdWx0XCJdLnBhcnRpYWwoaVtcImRlZmF1bHRcIl0uY2FuTGVhdmVUYWtlbix0aGlzLmRhdGEpLHRoaXMuY2FuQ29sbGVjdE9wZW49ZFtcImRlZmF1bHRcIl0ucGFydGlhbChpW1wiZGVmYXVsdFwiXS5jYW5Db2xsZWN0T3Blbix0aGlzLmRhdGEpLHRoaXMuY2FuT3BlblNlcmllcz1kW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGlbXCJkZWZhdWx0XCJdLmNhbk9wZW5TZXJpZXMsdGhpcy5kYXRhKSx0aGlzLmNhbk9wZW5QYWlycz1kW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGlbXCJkZWZhdWx0XCJdLmNhbk9wZW5QYWlycyx0aGlzLmRhdGEpLHRoaXMuc3RvcD0oMCxzW1wiZGVmYXVsdFwiXSkoZnVuY3Rpb24oZSl7aVtcImRlZmF1bHRcIl0uc3RvcChlKSxjW1wiZGVmYXVsdFwiXS5jYW5jZWwoZSl9LHRoaXMuZGF0YSksdGhpcy5vbnVubG9hZD1mdW5jdGlvbigpe319fSx7XCIuL2FuaW1cIjozLFwiLi9ib2FyZFwiOjUsXCIuL2NvbmZpZ3VyZVwiOjYsXCIuL2RhdGFcIjo4LFwiLi9kcmFnXCI6OSxcIi4vcGllY2VzXCI6MTQsXCIuL3NvcnRlclwiOjE1LFwiLi90YWJsZVwiOjE2LFwiLi91dGlsXCI6MTd9XSw4OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fXZhciBhPShyKGUoXCJtZXJnZVwiKSkscihlKFwiLi9waWVjZXNcIikpKSxpPXIoZShcIi4vY29uZmlndXJlXCIpKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9e3BvdlNpZGU6XCJlYXN0XCIsdHVyblNpZGU6XCJlYXN0XCIsbGFzdE1vdmU6bnVsbCx3aXRoVG9yZTohMSxwaWVjZXM6YVtcImRlZmF1bHRcIl0ucmVhZEJvYXJkKGFbXCJkZWZhdWx0XCJdLm1peGVkKSxkaXNjYXJkczphW1wiZGVmYXVsdFwiXS5yZWFkRGlzY2FyZHMoYVtcImRlZmF1bHRcIl0uaW5pdGlhbERpc2NhcmRzLFwiZWFzdFwiKSxvcGVuczphW1wiZGVmYXVsdFwiXS5yZWFkT3Blbkdyb3VwcyhhW1wiZGVmYXVsdFwiXS5pbml0aWFsT3Blbkdyb3VwcyksbWlkZGxlczphW1wiZGVmYXVsdFwiXS5yZWFkTWlkZGxlcyhhW1wiZGVmYXVsdFwiXS5pbml0aWFsTWlkZGxlcyksc2VsZWN0ZWQ6bnVsbCxtaWRkbGVIb2xkZXI6e2N1cnJlbnQ6ITEsa2V5Om51bGwscGllY2U6bnVsbH0sdmlld09ubHk6ITEsYW5pbWF0aW9uOntlbmFibGVkOiEwLGR1cmF0aW9uOjUwMCxjdXJyZW50Ont9fSxkcmFnZ2FibGU6e2VuYWJsZWQ6ITAsZGlzdGFuY2U6MyxjdXJyZW50Ont9fSxtb3ZhYmxlOntib2FyZDohMCxmcmVlOiEwLGV2ZW50czp7YWZ0ZXI6ZnVuY3Rpb24oZSx0KXt9fX0sZmxpcHBhYmxlOntlbmFibGVkOiEwLGN1cnJlbnQ6e319LG9wZW5hYmxlOntkZXN0czpbXX0sZXZlbnRzOnttb3ZlOmZ1bmN0aW9uKGUsdCl7fX19O3JldHVybigwLGlbXCJkZWZhdWx0XCJdKSh0LGV8fHt9KSx0fX0se1wiLi9jb25maWd1cmVcIjo2LFwiLi9waWVjZXNcIjoxNCxtZXJnZToxfV0sOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUsdCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106cFtcImRlZmF1bHRcIl0ucm93cyxhPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTpwW1wiZGVmYXVsdFwiXS5jb2x1bW5zO3JldHVybntsZWZ0OnQubGVmdCt0LndpZHRoKm5bMF0vYSx0b3A6dC50b3ArdC5oZWlnaHQqblsxXS9yLHdpZHRoOnQud2lkdGgvYSxoZWlnaHQ6dC5oZWlnaHQvcn19ZnVuY3Rpb24gaShlLHQpe2lmKCh2b2lkIDA9PT10LmJ1dHRvbnx8MD09PXQuYnV0dG9uKSYmKHQuc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLCFlLnZpZXdPbmx5KSl7cz10LnRhcmdldDt2YXIgbj1lLnNlbGVjdGVkLHI9cFtcImRlZmF1bHRcIl0uZXZlbnRQb3NpdGlvbih0KSxpPWUuYm9hcmRCb3VuZHMoKSx1PWUub3BlbnNCb3VuZHMoKSxsPWUudG9wQm91bmRzKCksZD1jW1wiZGVmYXVsdFwiXS5nZXRLZXlBdERvbVBvc09uUGllY2UoZSxyLGkpO2NbXCJkZWZhdWx0XCJdLnNlbGVjdFNxdWFyZShlLGQpLGR8fChkPWZbXCJkZWZhdWx0XCJdLmdldERyYXdLZXlBdERvbVBvcyhlLHIsbCkpJiZjW1wiZGVmYXVsdFwiXS5zZWxlY3RUb3AoZSxkLG4pLCFkJiZuJiYoKGQ9ZltcImRlZmF1bHRcIl0uZ2V0T3BlbnNLZXlBdERvbVBvcyhlLHIsdSkpP2ZbXCJkZWZhdWx0XCJdLmRyb3BPcGVucyhlLG4sZCk6KGQ9ZltcImRlZmF1bHRcIl0uZ2V0RGlzY2FyZEtleUF0RG9tUG9zKGUscixsKSkmJmZbXCJkZWZhdWx0XCJdLmRyb3BUb3AoZSxuLGQpKTt2YXIgdj1lLnNlbGVjdGVkPT09ZDtpZih2JiZmW1wiZGVmYXVsdFwiXS5pc0RyYWdnYWJsZShlLGQpKXt2YXIgbT1wW1wiZGVmYXVsdFwiXS5pc0JvYXJkS2V5KGQpP2EoZSxpLHBbXCJkZWZhdWx0XCJdLmtleTJwb3MoZCkpOmEoZSxsLHBbXCJkZWZhdWx0XCJdLnRvcEtleTJwb3MoZCkscFtcImRlZmF1bHRcIl0udG9wUm93cyxwW1wiZGVmYXVsdFwiXS50b3BDb2x1bW5zKSxnPWNbXCJkZWZhdWx0XCJdLmZpbmRCb2FyZERyYWdHcm91cChlLGQpWzBdO2UuZHJhZ2dhYmxlLmN1cnJlbnQ9e2RyYWdHcm91cDpnLG9yaWc6ZCxyZWw6cixlcG9zOnIscG9zOlswLDBdLGRlYzpbclswXS0obS5sZWZ0K20ud2lkdGgvMiksclsxXS0obS50b3ArbS5oZWlnaHQvMildLGJvYXJkQm91bmRzOmksb3BlbnNCb3VuZHM6dSx0b3BCb3VuZHM6bCxzdGFydGVkOiExfX1vKGUpfX1mdW5jdGlvbiBvKGUpe3BbXCJkZWZhdWx0XCJdLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe3ZhciB0PWUuZHJhZ2dhYmxlLmN1cnJlbnQ7dC5vcmlnJiYoIXQuc3RhcnRlZCYmcFtcImRlZmF1bHRcIl0uZGlzdGFuY2UodC5lcG9zLHQucmVsKT49ZS5kcmFnZ2FibGUuZGlzdGFuY2UmJih0LnN0YXJ0ZWQ9ITApLHQuc3RhcnRlZCYmKHQucG9zPVt0LmVwb3NbMF0tdC5yZWxbMF0sdC5lcG9zWzFdLXQucmVsWzFdXSx0Lm92ZXI9Y1tcImRlZmF1bHRcIl0uZ2V0S2V5QXREb21Qb3NPblBpZWNlKGUsdC5lcG9zLHQuYm9hcmRCb3VuZHMsdC5vcmlnKSwhdC5vdmVyJiZwW1wiZGVmYXVsdFwiXS5pc0JvYXJkS2V5KHQub3JpZykmJih0Lm92ZXI9ZltcImRlZmF1bHRcIl0uZ2V0T3BlbnNLZXlBdERvbVBvcyhlLHQuZXBvcyx0Lm9wZW5zQm91bmRzKXx8ZltcImRlZmF1bHRcIl0uZ2V0RGlzY2FyZEtleUF0RG9tUG9zKGUsdC5lcG9zLHQudG9wQm91bmRzKSkpKSxlLnJlbmRlcigpLHQub3JpZyYmbyhlKX0pfWZ1bmN0aW9uIHUoZSx0KXtlLmRyYWdnYWJsZS5jdXJyZW50Lm9yaWcmJihlLmRyYWdnYWJsZS5jdXJyZW50LmVwb3M9cFtcImRlZmF1bHRcIl0uZXZlbnRQb3NpdGlvbih0KSl9ZnVuY3Rpb24gbChlLHQpe3ZhciBuPWUuZHJhZ2dhYmxlLHI9bi5jdXJyZW50P24uY3VycmVudC5vcmlnOm51bGw7aWYocil7dmFyIGE9bi5jdXJyZW50Lm92ZXI7bi5jdXJyZW50LnN0YXJ0ZWQmJihjW1wiZGVmYXVsdFwiXS5zZXRTZWxlY3RlZChlLG51bGwpLGNbXCJkZWZhdWx0XCJdLnVzZXJNb3ZlKGUscixhKXx8ZltcImRlZmF1bHRcIl0uZHJvcE9wZW5zKGUscixhKXx8ZltcImRlZmF1bHRcIl0uZHJvcFRvcChlLHIsYSl8fGNbXCJkZWZhdWx0XCJdLnVzZXJEcmF3TGVmdChlLHIsYSl8fGNbXCJkZWZhdWx0XCJdLnVzZXJFbmREcmF3TWlkZGxlKGUscixhKSksbi5jdXJyZW50PXt9fX1mdW5jdGlvbiBkKGUpe2UuZHJhZ2dhYmxlLmN1cnJlbnQub3JpZyYmKGUuZHJhZ2dhYmxlLmN1cnJlbnQ9e30sY1tcImRlZmF1bHRcIl0uc2VsZWN0U3F1YXJlKGUsbnVsbCkpfXZhciBzLGM9cihlKFwiLi9ib2FyZFwiKSksZj1yKGUoXCIuL3RhYmxlXCIpKSxwPXIoZShcIi4vdXRpbFwiKSk7dC5leHBvcnRzPXtzdGFydDppLG1vdmU6dSxlbmQ6bCxjYW5jZWw6ZH19LHtcIi4vYm9hcmRcIjo1LFwiLi90YWJsZVwiOjE2LFwiLi91dGlsXCI6MTd9XSwxMDpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUsdCl7dC5zdG9wUHJvcGFnYXRpb24oKSx0LnByZXZlbnREZWZhdWx0KCksdVtcImRlZmF1bHRcIl0uY2FuY2VsTW92ZShlKTt2YXIgbj1sW1wiZGVmYXVsdFwiXS5ldmVudFBvc2l0aW9uKHQpLHI9ZS5ib2FyZEJvdW5kcygpLGE9dVtcImRlZmF1bHRcIl0uZ2V0S2V5QXREb21Qb3NPblBpZWNlKGUsbixyKSxpPWUucGllY2VzW2FdO2UuZmxpcFBpZWNlKGEsaSl9ZnVuY3Rpb24gaShlLHQpe31mdW5jdGlvbiBvKGUsdCl7fXZhciB1PXIoZShcIi4vYm9hcmRcIikpLGw9cihlKFwiLi91dGlsXCIpKTt0LmV4cG9ydHM9e3N0YXJ0OmEsbW92ZTppLGVuZDpvfX0se1wiLi9ib2FyZFwiOjUsXCIuL3V0aWxcIjoxN31dLDExOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSl7dmFyIHQ9bmV3IGlbXCJkZWZhdWx0XCJdKGUpO3JldHVybigwLGxbXCJkZWZhdWx0XCJdKSh0KX12YXIgaT1yKGUoXCIuL2N0cmxcIikpLG89cihlKFwiLi91dGlsXCIpKSx1PXIoZShcIi4vbW92ZVwiKSksbD1yKGUoXCIuL2FwaVwiKSksZD1yKGUoXCIuL2FuaW1cIikpLHM9cihlKFwiLi9kcmFnXCIpKTt0LmV4cG9ydHM9YSx0LmV4cG9ydHMuY29udHJvbGxlcj1pW1wiZGVmYXVsdFwiXSx0LmV4cG9ydHMudXRpbD1vW1wiZGVmYXVsdFwiXSx0LmV4cG9ydHMubW92ZT11W1wiZGVmYXVsdFwiXSx0LmV4cG9ydHMuYW5pbT1kW1wiZGVmYXVsdFwiXSx0LmV4cG9ydHMuZHJhZz1zW1wiZGVmYXVsdFwiXX0se1wiLi9hbmltXCI6MyxcIi4vYXBpXCI6NCxcIi4vY3RybFwiOjcsXCIuL2RyYWdcIjo5LFwiLi9tb3ZlXCI6MTIsXCIuL3V0aWxcIjoxN31dLDEyOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9XCJkbVwiLGE9XCJkbFwiLGk9XCJkZFwiLG89XCJsdFwiLHU9XCJzc1wiLGw9XCJvc1wiLGQ9XCJvcFwiLHM9XCJjb1wiLGM9XCJkb3NcIixmPVwiZG9wXCIscD1cImRkc1wiLHY9XCJkZHBcIixtPVwibFwiLGc9XCJyXCIsaD1cInBcIjt0LmV4cG9ydHM9e2RyYXdNaWRkbGU6cixkcmF3TGVmdDphLGRpc2NhcmQ6aSxsZWF2ZVRha2VuOm8sc2lnbjp1LG9wZW5TZXJpZXM6bCxvcGVuUGFpcnM6ZCxjb2xsZWN0T3BlbjpzLGRyb3BPcGVuU2VyaWVzOmMsZHJvcE9wZW5QYWlyczpmLGRyb3BMZWZ0Om0sZHJvcFJpZ2h0OmcsZHJvcFJlcGxhY2U6aCxkaXNjYXJkRW5kU2VyaWVzOnAsZGlzY2FyZEVuZFBhaXJzOnZ9fSx7fV0sMTM6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlLHQpe3JldHVybiB1KGUpfHxvKGUsdCl8fGkoKX1mdW5jdGlvbiBpKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9ZnVuY3Rpb24gbyhlLHQpe3ZhciBuPVtdLHI9ITAsYT0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBvLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShvPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChvLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtyPSEwKTt9Y2F0Y2gobCl7YT0hMCxpPWx9ZmluYWxseXt0cnl7cnx8bnVsbD09dVtcInJldHVyblwiXXx8dVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYoYSl0aHJvdyBpfX1yZXR1cm4gbn1mdW5jdGlvbiB1KGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9ZnVuY3Rpb24gbChlLHQpe3JldHVybiBlLmxlbmd0aD09PXQubGVuZ3RoJiZlLmV2ZXJ5KGZ1bmN0aW9uKGUsbil7cmV0dXJuIGU9PT10W25dfSl9ZnVuY3Rpb24gZChlLHQpe3JldHVybiB0LmV2ZXJ5KGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQuY29sb3I9PT1lW25dfSl9ZnVuY3Rpb24gcyhlLHQpe2lmKGUubGVuZ3RoPDMpcmV0dXJuITE7dmFyIG49ZS5sZW5ndGgscj1lWzBdLmNvbG9yLGE9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUua2V5fSksaT1hLnNsaWNlKDApLnJldmVyc2UoKSxvPXdbXCJkZWZhdWx0XCJdLnNlcmllc0J5Q29sb3Iocik7dCYmKG89by5zbGljZSgwKSxvLnB1c2gob1swXSkpO2Zvcih2YXIgdT0wO3U8PW8ubGVuZ3RoLW47dSsrKXt2YXIgZD1vLnNsaWNlKHUsdStuKTtpZihsKGQsYSl8bChkLGkpKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9ZS5sZW5ndGgsbj1lWzBdLm51bWJlcjtyZXR1cm4hISgzPT09dHw0PT09dCkmJighIWUuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIGUubnVtYmVyPT09bn0pJiZiLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIGQodC5zbGljZSgwLGUubGVuZ3RoKSxlKX0pKX1mdW5jdGlvbiBmKGUsdCl7dmFyIG49d1tcImRlZmF1bHRcIl0ubWFrZVBpZWNlKHQuYyx0Lm4pO3JldHVybiBuLmlzRmFrZT0hMCx3W1wiZGVmYXVsdFwiXS5waWVjZUZha2UoZSk/bjplfWZ1bmN0aW9uIHAoZSx0KXtyZXR1cm4hZS5pc0Zha2UmJmUua2V5PT09dC5rZXl9ZnVuY3Rpb24gdihlLHQpe2Z1bmN0aW9uIG4oZSx0KXtyZXR1cm4gZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaW5kZXhPZihlKTwwfSl9ZnVuY3Rpb24gcihlLHQpe3JldHVybiBlLmtleT09PXQua2V5fWZ1bmN0aW9uIGkoZSx0KXt2YXIgcj1bXCJyXCIsXCJnXCIsXCJiXCIsXCJsXCJdLGE9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIXAoZSx0KX0pLGk9bihyLGEubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmN9KSk7aWYoaS5sZW5ndGg8MSlyZXR1cm4gZTtpZihhLmxlbmd0aDwxKXJldHVybiBlO2lmKCEoYS5sZW5ndGg8ZS5sZW5ndGgpKXJldHVybiBlO3ZhciBvPWlbMF0sdT1hWzBdLm4sbD13W1wiZGVmYXVsdFwiXS5tYWtlUGllY2Uobyx1KTtyZXR1cm4gYS5wdXNoKGwpLGF9ZnVuY3Rpb24gbyhlLHQpe3ZhciBuO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gZTtpZihlLmxlbmd0aDwzKXJldHVybiBlO3ZhciBpPWEoZSwzKSx1PWlbMF0sbD1pWzFdLGQ9aVsyXSxzPVt1LGwsZF07aWYobj1lLnNsaWNlKDMsZS5sZW5ndGgpLHAodSx0KSlyKHdbXCJkZWZhdWx0XCJdLnBpZWNlVXAobCksZCk/cz1bd1tcImRlZmF1bHRcIl0ucGllY2VEb3duKGwpLGwsZF06cih3W1wiZGVmYXVsdFwiXS5waWVjZURvd24obCksZCkmJihzPVt3W1wiZGVmYXVsdFwiXS5waWVjZVVwKGwpLGwsZF0pO2Vsc2UgaWYocChsLHQpKXIod1tcImRlZmF1bHRcIl0ucGllY2VVcCh3W1wiZGVmYXVsdFwiXS5waWVjZVVwKHUpKSxkKT9zPVt1LHdbXCJkZWZhdWx0XCJdLnBpZWNlVXAodSksZF06cih3W1wiZGVmYXVsdFwiXS5waWVjZURvd24od1tcImRlZmF1bHRcIl0ucGllY2VEb3duKHUpKSxkKSYmKHM9W3Usd1tcImRlZmF1bHRcIl0ucGllY2VEb3duKHUpLGRdKTtlbHNle2lmKCFwKGQsdCkpcmV0dXJuIG49byhlLnNsaWNlKDEsZS5sZW5ndGgpLHQpLG4udW5zaGlmdChlWzBdKSxuO3Iod1tcImRlZmF1bHRcIl0ucGllY2VVcCh1KSxsKT9zPVt1LGwsd1tcImRlZmF1bHRcIl0ucGllY2VVcChsKV06cih3W1wiZGVmYXVsdFwiXS5waWVjZURvd24odSksbCkmJihzPVt1LGwsd1tcImRlZmF1bHRcIl0ucGllY2VEb3duKGwpXSl9cmV0dXJuIHMuY29uY2F0KG4pfWZ1bmN0aW9uIHUoZSx0KXtpZigyIT1lLmxlbmd0aClyZXR1cm4gZTt2YXIgbj1hKGUsMikscj1uWzBdLGk9blsxXTtyZXR1cm4gcChyLHQpP1tpLGldOnAoaSx0KT9bcixyXTplfWlmKGUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBwKGUsdCl9KS5sZW5ndGg+MSlyZXR1cm4gZTtpZihlLmxlbmd0aDwzKXJldHVybiB1KGUsdCk7dmFyIGw9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIXAoZSx0KX0pO3JldHVybiBsLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlLm49PT1sWzBdLm59KT9pKGUsdCk6bC5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZS5jPT09bFswXS5jfSk/byhlLHQpOmV9ZnVuY3Rpb24gbShlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0scj13W1wiZGVmYXVsdFwiXS5waWVjZVVwKHQpLGE9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGYoZSxyKX0pLGk9dihhLHIpO3JldHVybiBzKGksbil8YyhpKX1mdW5jdGlvbiBnKGUsdCl7aWYoMiE9PWUubGVuZ3RoKXJldHVybiExO3ZhciBuPXdbXCJkZWZhdWx0XCJdLnBpZWNlVXAodCkscj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZihlLG4pfSksaT12KHIsbiksbz1hKGksMiksdT1vWzBdLGw9b1sxXTtyZXR1cm4gdS5rZXk9PT1sLmtleX1mdW5jdGlvbiBoKGUsdCxuKXt2YXIgcj1bXSxhPXdbXCJkZWZhdWx0XCJdLnBpZWNlVXAobik7cmV0dXJuIHQ9Zih0LGEpLGUuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oaSxvKXt2YXIgdT1pLnNsaWNlKDApLGw9aS5zbGljZSgwKTt1LnNwbGljZSgwLDAsdCksbC5zcGxpY2UoaS5sZW5ndGgsMCx0KSxtKHUsbikmJnIucHVzaCh3W1wiZGVmYXVsdFwiXS5nZXRPcGVuU2VyaWVLZXlGcm9tR3JvdXBJbmRleChlLG8sMCkpLG0obCxuKSYmci5wdXNoKHdbXCJkZWZhdWx0XCJdLmdldE9wZW5TZXJpZUtleUZyb21Hcm91cEluZGV4KGUsbyxpLmxlbmd0aCsxKSk7dmFyIGQ9aS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHAoZSxhKT90OmV9KTtpZihtKGQsbikpe3ZhciBzO2kuZm9yRWFjaChmdW5jdGlvbihlLHQpe3AoZSxhKSYmKHM9dCl9KSxyLnB1c2god1tcImRlZmF1bHRcIl0uZ2V0T3BlblNlcmllS2V5RnJvbUdyb3VwSW5kZXgoZSxvLHMrMSkpfX0pLGUucGFpcnMuZm9yRWFjaChmdW5jdGlvbihpLG8pe3ZhciB1PWkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwKGUsYSk/dDplfSk7aWYoZyh1LG4pKXt2YXIgbD15KGksYSk7ci5wdXNoKHdbXCJkZWZhdWx0XCJdLmdldE9wZW5QYWlyS2V5RnJvbUdyb3VwSW5kZXgoZSxvLGwpKX19KSxyfWZ1bmN0aW9uIHkoZSx0KXt2YXIgbjtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUscil7cChlLHQpJiYobj1yKX0pLG59T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbltcImRlZmF1bHRcIl09dm9pZCAwO3ZhciB3PXIoZShcIi4vcGllY2VzXCIpKSxiPWZ1bmN0aW9uKCl7dmFyIGU9d1tcImRlZmF1bHRcIl0uY29sb3JzLHQ9W107Zm9yKHZhciBuIGluIGUpZm9yKHZhciByIGluIGUpZm9yKHZhciBhIGluIGUpZm9yKHZhciBpIGluIGUpbiE9PXImJm4hPT1hJiZuIT09aSYmciE9PWEmJnIhPT1pJiZhIT09aSYmdC5wdXNoKFtlW25dLGVbcl0sZVthXSxlW2ldXSk7cmV0dXJuIHR9KCksUD17Y29tcHV0ZTpoLHNlcmllczptLHBhaXJzOmcsZmluZE9rZXlJbmRleDp5fTtuW1wiZGVmYXVsdFwiXT1QfSx7XCIuL3BpZWNlc1wiOjE0fV0sMTQ6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlLHQpe3JldHVybiB1KGUpfHxvKGUsdCl8fGkoKX1mdW5jdGlvbiBpKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9ZnVuY3Rpb24gbyhlLHQpe3ZhciBuPVtdLHI9ITAsYT0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBvLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShvPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChvLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtyPSEwKTt9Y2F0Y2gobCl7YT0hMCxpPWx9ZmluYWxseXt0cnl7cnx8bnVsbD09dVtcInJldHVyblwiXXx8dVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYoYSl0aHJvdyBpfX1yZXR1cm4gbn1mdW5jdGlvbiB1KGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9ZnVuY3Rpb24gbChlKXt2YXIgdD1bXTtmb3IodmFyIG4gaW4gQil0LnB1c2goRShlLG4pLmtleSk7cmV0dXJuIHR9ZnVuY3Rpb24gZChlKXt2YXIgdD17MDowLDE6MSwyOjIsMzozLDQ6NCw1OjUsNjo2LDc6Nyw4OjgsOTo5fSxuPXRbZVswXV0scj10W2VbMV1dO3JldHVybiB2b2lkIDA9PT1yP3ZvaWQgMD09PW4/e2xlZnQ6ZS5zbGljZSgxKX06e251bWJlcjpuLGxlZnQ6ZS5zbGljZSgxKX06e251bWJlcjoxMCpuK3IsbGVmdDplLnNsaWNlKDIpfX1mdW5jdGlvbiBzKGUpe3ZhciB0PS8oW2x8cnxwXSkoXFxkXFxkPykvLG49ZS5tYXRjaCh0KSxyPW5bMV0sYT1wYXJzZUludChuWzJdKTtyZXR1cm57dHlwZTpyLGdyb3VwSW5kZXg6YX19ZnVuY3Rpb24gYyhlKXt2YXIgdD1lWzBdLG49ZVsxXSxyPWVbMl0sYT0yO3JldHVybiBEW3RdPyhCW24rcl0mJihuKz1yLGE9Mykse3BpZWNlOkUodCxuKSxsZWZ0OmUuc2xpY2UoYSl9KTp7bGVmdDplLnNsaWNlKDEpfX1mdW5jdGlvbiBmKGUpe3ZhciB0PVtdLG49W107Zm9yKGUrPVwiXFxuXCI7ZS5sZW5ndGg+MDspe3ZhciByPWMoZSk7ci5waWVjZT9uLnB1c2goci5waWVjZSk6KG4ubGVuZ3RoPjAmJnQucHVzaChuKSxuPVtdKSxlPXIubGVmdH1yZXR1cm4gdH1mdW5jdGlvbiBwKGUpe2Zvcih2YXIgdD1bXSxuPTA7ZS5sZW5ndGg+MDspe3ZhciByPWMoZSk7ci5waWVjZSYmKHRbbl09ci5waWVjZSksbisrLGU9ci5sZWZ0fXJldHVybiB0fWZ1bmN0aW9uIHYoZSl7dmFyIHQ9e307ZT1wKGUpO2Zvcih2YXIgbj0wLHI9MDtyPGUubGVuZ3RoO3IrKyl7aWYoZVtyXSl7Zm9yKDtuPDEwMCYmIUFbXCJkZWZhdWx0XCJdLmlzQWxsb3dlZEJvYXJkS2V5KEFbXCJkZWZhdWx0XCJdLmVuY29kZUtleShuLFwiYlwiKSk7KW4rKzt0W0FbXCJkZWZhdWx0XCJdLmVuY29kZUtleShuLFwiYlwiKV09ZVtyXSxuKyt9bisrfXJldHVybiB0fWZ1bmN0aW9uIG0oZSx0KXtlPWUuc3BsaXQoXCIgXCIpO3ZhciBuPXt9O3JldHVybiBBW1wiZGVmYXVsdFwiXS5hbGxTaWRlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIEFbXCJkZWZhdWx0XCJdLmZpbmRQb3YodCxlKX0pLmZvckVhY2goZnVuY3Rpb24odCxyKXt2YXIgYT1wKGVbcl18fFwiXCIpO25bQVtcImRlZmF1bHRcIl0uZGlzY2FyZEJ5UG92KHQpXT1hfSksbn1mdW5jdGlvbiBnKGUpe3ZhciB0PWUuc3BsaXQoXCIvXCIpLG49YSh0LDIpLHI9blswXSxpPW5bMV07cj1mKHIpLGk9ZihpKTt2YXIgbz1oKHIsaSk7cmV0dXJue3NlcmllczpyLHBhaXJzOmksbGF5b3V0Om8scmVsYXlvdXQ6ZnVuY3Rpb24oZSl7ZS5vcGVucy5sYXlvdXQ9aChlLm9wZW5zLnNlcmllcyxlLm9wZW5zLnBhaXJzKX19fWZ1bmN0aW9uIGgoZSx0KXt2YXIgbixyLGEsaSxvLHU9e30sbD17c2VyaWVzOnt9LHBhaXJzOnt9fSxkPVtdLHM9MDtmb3Iobj0wO248ZS5sZW5ndGg7bisrKXt2YXIgYz1lW25dO2k9KGRbc118fDEpLTEsbz1zLGwuc2VyaWVzW0FbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFtpLG9dKV09bjtmb3IodmFyIGY9MDtmPGMubGVuZ3RoO2YrKylhPWRbc118fDEscj1BW1wiZGVmYXVsdFwiXS5taW5pUG9zMmtleShbYSxzXSksdVtyXT1jW2ZdLGRbc109YSsxO2Rbc10rPTIscysrLHM+PUFbXCJkZWZhdWx0XCJdLm1pbmlSb3dzJiYocz0wKX1mb3IoZD1bXSxuPTAsZj0wLHI9MCxhPTAscz0wLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHA9dFtuXTtmb3IoaT0oZFtzXXx8QVtcImRlZmF1bHRcIl0ubWluaUNvbHVtbnMtMSktMSxvPXMsbC5wYWlyc1tBW1wiZGVmYXVsdFwiXS5taW5pUG9zMmtleShbaSxvXSldPW4sZj1wLmxlbmd0aC0xO2Y+PTA7Zi0tKWE9ZFtzXXx8QVtcImRlZmF1bHRcIl0ubWluaUNvbHVtbnMtMSxyPUFbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFthLHNdKSx1W3JdPXBbZl0sZFtzXT1hLTE7ZFtzXS09MSxzKysscz49QVtcImRlZmF1bHRcIl0ubWluaVJvd3MmJihzPTApfXJldHVybntsYXlvdXQ6dSxncm91cE1hcDpsfX1mdW5jdGlvbiB5KGUsdCxuKXtmb3IodmFyIHIgaW4gZSlpZihlW3JdPT09dCl7dmFyIGk9QVtcImRlZmF1bHRcIl0ubWluaUtleTJwb3Mociksbz1hKGksMiksdT1vWzBdLGw9b1sxXSxkPVt1K24sbF07cmV0dXJuIEFbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KGQpfX1mdW5jdGlvbiB3KGUsdCxuKXt2YXIgcj1lLmxheW91dC5ncm91cE1hcC5wYWlycztyZXR1cm4geShyLHQsbil9ZnVuY3Rpb24gYihlLHQsbil7dmFyIHI9ZS5sYXlvdXQuZ3JvdXBNYXAuc2VyaWVzO3JldHVybiB5KHIsdCxuKX1mdW5jdGlvbiBQKGUsdCl7dmFyIG49ZS5vcGVucyxyPW4uc2VyaWVzLGk9bi5sYXlvdXQuZ3JvdXBNYXAsbz1hKHQsMiksdT1vWzBdLGw9b1sxXTtmb3IodmFyIGQgaW4gaS5zZXJpZXMpe3ZhciBzPWkuc2VyaWVzW2RdLGM9cltzXSxmPUFbXCJkZWZhdWx0XCJdLm1pbmlLZXkycG9zKGQpLHA9YShmLDIpLHY9cFswXSxtPXBbMV0sZz11LXY7aWYoIShnPDB8fGc+Yy5sZW5ndGgrMXx8bCE9bSkpcmV0dXJuW3MsZ119fWZ1bmN0aW9uIGsoZSx0KXt2YXIgbj1lLm9wZW5zLHI9bi5wYWlycyxpPW4ubGF5b3V0Lmdyb3VwTWFwLG89YSh0LDIpLHU9b1swXSxsPW9bMV07Zm9yKHZhciBkIGluIGkucGFpcnMpe3ZhciBzPWkucGFpcnNbZF0sYz0ocltzXSxBW1wiZGVmYXVsdFwiXS5taW5pS2V5MnBvcyhkKSksZj1hKGMsMikscD1mWzBdLHY9ZlsxXSxtPXUtcDtpZighKG08MHx8bT4xfHxsIT12KSlyZXR1cm5bcyxtXX19ZnVuY3Rpb24gTyhlKXt2YXIgdD17fSxuPWQoZSk7cmV0dXJuIHRbQVtcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdPW4ubnVtYmVyLG49YyhuLmxlZnQpLHRbQVtcImRlZmF1bHRcIl0uZ29zdGVyZ2VdPW4ucGllY2UsdH1mdW5jdGlvbiB4KGUpe2U9ZS5zcGxpdChcIi9cIik7dmFyIHQ9MixuPTMscj00LGE9MSxpPTAsbz17ZTpcImVhc3RcIix3Olwid2VzdFwiLG46XCJub3J0aFwiLHM6XCJzb3V0aFwifVtlW2ldXTtyZXR1cm57cGllY2VzOnYoZVt0XSksZGlzY2FyZHM6bShlW25dLG8pLG9wZW5zOmcoW2Vbcl0sZVtyKzFdXS5qb2luKFwiL1wiKSksbWlkZGxlczpPKGVbYV0pfX1mdW5jdGlvbiBTKGUpe3ZhciB0PUFbXCJkZWZhdWx0XCJdLmFsbEtleXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLmtleXx8XCIgXCJ9KS5qb2luKFwiXCIpO3JldHVybiB0LnJlcGxhY2UoLyhbXlxcc10pXFxzL2csXCIkMVwiKX1mdW5jdGlvbiBFKGUsdCl7cmV0dXJue2NvbG9yOkRbZV0sbnVtYmVyOkJbdF0sYzplLG46cGFyc2VJbnQodCksa2V5OmUrdH19ZnVuY3Rpb24gTShlKXt2YXIgdD1lLmMsbj1lLm4lMTMrMTtyZXR1cm4gRSh0LG4pfWZ1bmN0aW9uIEMoZSl7dmFyIHQ9ZS5jLG49KGUubisxMSklMTMrMTtyZXR1cm4gRSh0LG4pfWZ1bmN0aW9uIEsoZSl7cmV0dXJuXCJmYWtlXCI9PT1lLmNvbG9yfWZ1bmN0aW9uIFQoZSl7cmV0dXJuIGUubGVuZ3RoPjAmJjE0PT09ZS5tYXRjaChqKS5sZW5ndGh9dmFyIEE9cihlKFwiLi91dGlsXCIpKSxEPXtiOlwiYmx1ZVwiLHI6XCJyZWRcIixnOlwiZ3JlZW5cIixsOlwiYmxhY2tcIixmOlwiZmFrZVwifSxCPXsxOlwib25lXCIsMjpcInR3b1wiLDM6XCJ0aHJlZVwiLDQ6XCJmb3VyXCIsNTpcImZpdmVcIiw2Olwic2l4XCIsNzpcInNldmVuXCIsODpcImVpZ2h0XCIsOTpcIm5pbmVcIiwxMDpcInRlblwiLDExOlwiZWxldmVuXCIsMTI6XCJ0d2VsdmVcIiwxMzpcInRoaXJ0ZWVuXCJ9LGo9L1tmfHJ8bHxifGddXFxkXFxkPy9nLFI9ZnVuY3Rpb24oKXt2YXIgZT17fTtmb3IodmFyIHQgaW4gRCllW0RbdF1dPWwodCk7cmV0dXJuIGV9KCksTD1mdW5jdGlvbihlKXtyZXR1cm4gUltlXX0sRz1cImc3cjdiN2w3IGc4cjhiOGw4IGcxM3IxM2IxM2wxMyBsMTIgcjZyNXI0cjEycjEzIGc5ZzhnMTMgZzYgbDhsN2wxMlwiLEY9XCJyMWcxbDFiMSByMmcybDJiMiByM2czbDNiMyByNGc0bDRiNCByMTNnMTNsMTNiMTMgcjFnMWwxYjFcIixOPVwicjFyMiByM3I0cjVyNnI3cjhyOXIxMHIxMXIxMnIxM2wxbDJsM2w0bDVsNmw3ICAgZzFnMiAgbDNcIixfPVwiMjBsM1wiLEk9XCJiMSAgcjFyMiBnMVwiLEg9XCJyOGw4YjhcXG5iMWIyYjNcXG5iOWIxMGIxMWIxMlxcbmwxM3IxM2IxM1xcbnIxMmIxMmcxMlxcbnI3cjhyOXIxMFxcbmcxMGcxMWcxMlxcbmw2YjZyNlxcbmw5bDEwbDExXFxuYjdsN3I3ZzdcXG5yMTNsMTNiMTNnMTNcXG5sMTByMTBiMTBnMTBcXG5sNnI2ZzZcXG5sMWIxZzFcXG4vcjFyMVxcbmcxZzFcXG5nMmcyXFxuZzNnM1xcbmc0ZzRcXG5nNWc1XFxuZzZnNlxcbmc3ZzdcXG5nOGc4XFxuZzlnOVxcbmcxMGcxMFxcbmcxMWcxMVxcbmcxMmcxMlxcblxcblwiO3QuZXhwb3J0cz17dmFsaWREdXpPa2V5R3JvdXBGZW46VCxpbml0aWFsOk4scmFpbmJvdzpGLG1peGVkOkcsd3JpdGU6UyxyZWFkOngscmVhZERyb3BQb3M6cyxyZWFkUGllY2U6YyxyZWFkQm9hcmQ6dixpbml0aWFsTWlkZGxlczpfLGluaXRpYWxEaXNjYXJkczpJLGluaXRpYWxPcGVuR3JvdXBzOkgscmVhZE1pZGRsZXM6TyxyZWFkRGlzY2FyZHM6bSxyZWFkUGllY2VHcm91cDpmLHJlYWRPcGVuR3JvdXBzOmcsbGF5b3V0T3BlbnM6aCxzZXJpZXNCeUNvbG9yOkwsbWFrZVBpZWNlOkUscGllY2VVcDpNLHBpZWNlRG93bjpDLHBpZWNlRmFrZTpLLGNvbG9yczpELGdldE9wZW5TZXJpZUtleUZyb21Hcm91cEluZGV4OmIsZ2V0T3BlblBhaXJLZXlGcm9tR3JvdXBJbmRleDp3LGdldE9wZW5TZXJpZUZyb21Qb3M6UCxnZXRPcGVuUGFpckZyb21Qb3M6a319LHtcIi4vdXRpbFwiOjE3fV0sMTU6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlKXtyZXR1cm4gdShlKXx8byhlKXx8aSgpfWZ1bmN0aW9uIGkoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2VcIil9ZnVuY3Rpb24gbyhlKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXJldHVybiBBcnJheS5mcm9tKGUpfWZ1bmN0aW9uIHUoZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAsbj1uZXcgQXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKW5bdF09ZVt0XTtyZXR1cm4gbn19ZnVuY3Rpb24gbChlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gZChlKXtmdW5jdGlvbiB0KGUsbixyKXtmb3IodmFyIGkgaW4gcil7dmFyIG89cltpXTtpZihpIT09biYmby5jPT09ZS5jKXtpZigxPT09by5uJiYyPT09ZS5uKXJldHVybltsKHt9LGksbyldO2lmKDEzPT09by5uJiYxPT09ZS5ufHxvLm49PT1lLm4tMSlyZXR1cm5bbCh7fSxpLG8pXS5jb25jYXQoYSh0KG8saSxyKSkpfX1yZXR1cm5bXX1mdW5jdGlvbiBuKGUsdCxyKXtmb3IodmFyIGkgaW4gcil7dmFyIG89cltpXTtpZihpIT09dCYmby5jPT09ZS5jKXtpZigxPT09by5uJiYxMz09PWUubilyZXR1cm5bbCh7fSxpLG8pXTtpZihvLm49PT1lLm4rMSlyZXR1cm5bbCh7fSxpLG8pXS5jb25jYXQoYShuKG8saSxyKSkpfX1yZXR1cm5bXX1mdW5jdGlvbiByKGUsdCxuKXt2YXIgcj17fTtmb3IodmFyIGEgaW4gbil7dmFyIGk9blthXTthIT09dCYmaS5uPT09ZS5uJiZpLmMhPT1lLmMmJihyW2kuY109bCh7fSxhLGkpKX1yZXR1cm4gT2JqZWN0LnZhbHVlcyhyKX1mdW5jdGlvbiBpKGUpe3ZhciBhPXt9O2Zvcih2YXIgaSBpbiBlKXt2YXIgbz1lW2ldO28mJihhW2ldPXtkb3duczp0KG8saSxlKSx1cHM6bihvLGksZSksc2FtZTpyKG8saSxlKX0pfXZhciB1PXt0eXBlOm51bGwsa2V5Om51bGwsdmFsdWU6MH07Zm9yKHZhciBkIGluIGEpe3ZhciBzPWFbZF07W1wiZG93bnNcIixcInVwc1wiLFwic2FtZVwiXS5tYXAoZnVuY3Rpb24oZSl7c1tlXS5sZW5ndGg+PXUudmFsdWUmJih1LnR5cGU9ZSx1LmtleT1kLHUudmFsdWU9c1tlXS5sZW5ndGgpfSl9dmFyIGM9YVt1LmtleV1bdS50eXBlXTtyZXR1cm5cImRvd25zXCI9PT11LnR5cGU/Yy51bnNoaWZ0KGwoe30sdS5rZXksZVt1LmtleV0pKTpjLnVuc2hpZnQobCh7fSx1LmtleSxlW3Uua2V5XSkpLGN9Zm9yKHZhciBvIGluIGUucGllY2VzKWUucGllY2VzW29dfHxkZWxldGUgZS5waWVjZXNbb107dmFyIHU9T2JqZWN0LmFzc2lnbih7fSxlLnBpZWNlcyk7Zm9yKG8gaW4gZS5waWVjZXMpZS5waWVjZXNbb109dm9pZCAwLGRlbGV0ZSBlLnBpZWNlc1tvXTtmb3IodmFyIGQ9MTtPYmplY3Qua2V5cyh1KS5sZW5ndGg+MDspe3ZhciBzPWkodSksYz1zLmxlbmd0aDtkPWZbXCJkZWZhdWx0XCJdLm5leHRJdGVyYXRvckZvckdyb3VwKGQsYykscy5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7Zm9yKHZhciByIGluIHQpe3ZhciBhPXRbcl07ZS5waWVjZXNbZltcImRlZmF1bHRcIl0uaXRlcmF0b3IyS2V5KGQrMipuKV09YSx1W3JdPXZvaWQgMCxkZWxldGUgdVtyXX19KSxkKz0yKmMrMX1jb25zb2xlLmxvZyhlLnBpZWNlcyl9ZnVuY3Rpb24gcyhlKXt2YXIgdD17fTtmb3IodmFyIG4gaW4gZS5waWVjZXMpe3ZhciByPWUucGllY2VzW25dO3ImJih0W3Iua2V5XT90W3Iua2V5XSsrOnRbci5rZXldPTEsZGVsZXRlIGUucGllY2VzW25dKX12YXIgYT0xO2Zvcih2YXIgaSBpbiB0KXt2YXIgbz10W2ldO2E9ZltcImRlZmF1bHRcIl0ubmV4dEl0ZXJhdG9yRm9yR3JvdXAoYSxvKTtmb3IodmFyIHU9MDt1PG87dSsrKWUucGllY2VzW2ZbXCJkZWZhdWx0XCJdLml0ZXJhdG9yMktleShhKzIqdSldPWNbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShpKS5waWVjZTthKz0yKm8rMX19dmFyIGM9cihlKFwiLi9waWVjZXNcIikpLGY9cihlKFwiLi91dGlsXCIpKTt0LmV4cG9ydHM9e3NvcnRQYWlyczpzLHNvcnRTZXJpZXM6ZH19LHtcIi4vcGllY2VzXCI6MTQsXCIuL3V0aWxcIjoxN31dLDE2OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm4gdShlKXx8byhlLHQpfHxpKCl9ZnVuY3Rpb24gaSgpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfWZ1bmN0aW9uIG8oZSx0KXt2YXIgbj1bXSxyPSEwLGE9ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgbyx1PWVbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0obz11Lm5leHQoKSkuZG9uZSkmJihuLnB1c2goby52YWx1ZSksIXR8fG4ubGVuZ3RoIT09dCk7cj0hMCk7fWNhdGNoKGwpe2E9ITAsaT1sfWZpbmFsbHl7dHJ5e3J8fG51bGw9PXVbXCJyZXR1cm5cIl18fHVbXCJyZXR1cm5cIl0oKX1maW5hbGx5e2lmKGEpdGhyb3cgaX19cmV0dXJuIG59ZnVuY3Rpb24gdShlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfWZ1bmN0aW9uIGwoZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30scj1uLnBpZWNlLGE9bi5ncm91cCxpPW4ucG9zLG89UltcImRlZmF1bHRcIl0uZmluZFBvdihlLnBvdlNpZGUsZS50dXJuU2lkZSk7aWYoZS50dXJuU2lkZSE9PWUucG92U2lkZXx8ZS5zcGVjdGF0b3Ipc3dpdGNoKHQpe2Nhc2UgTFtcImRlZmF1bHRcIl0uZHJhd01pZGRsZTp2KGUpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1MW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlO2JyZWFrO2Nhc2UgTFtcImRlZmF1bHRcIl0uZHJhd0xlZnQ6bShlLFJbXCJkZWZhdWx0XCJdLmRyYXdCeVBvdihvKSksZS5hbmltYXRpb24uY3VycmVudC5oaW50PUxbXCJkZWZhdWx0XCJdLmRyYXdMZWZ0O2JyZWFrO2Nhc2UgTFtcImRlZmF1bHRcIl0uZGlzY2FyZDpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxwKGUsUltcImRlZmF1bHRcIl0uZGlzY2FyZEJ5UG92KG8pLHIpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1MW1wiZGVmYXVsdFwiXS5kaXNjYXJkO2JyZWFrO2Nhc2UgTFtcImRlZmF1bHRcIl0ubGVhdmVUYWtlbjpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxnKGUsUltcImRlZmF1bHRcIl0uZHJhd0J5UG92KG8pLHIpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1MW1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuO2JyZWFrO2Nhc2UgTFtcImRlZmF1bHRcIl0ub3BlblNlcmllczphPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZUdyb3VwKGEpLGMoZSxhKSxlLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9TFtcImRlZmF1bHRcIl0ub3BlblNlcmllczticmVhaztjYXNlIExbXCJkZWZhdWx0XCJdLm9wZW5QYWlyczphPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZUdyb3VwKGEpLGYoZSxhKSxlLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9TFtcImRlZmF1bHRcIl0ub3BlblNlcmllczticmVhaztjYXNlIExbXCJkZWZhdWx0XCJdLmRyb3BPcGVuU2VyaWVzOnI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLGk9R1tcImRlZmF1bHRcIl0ucmVhZERyb3BQb3MoaSksZChlLHIsaSk7YnJlYWs7Y2FzZSBMW1wiZGVmYXVsdFwiXS5kcm9wT3BlblBhaXJzOnI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLGk9R1tcImRlZmF1bHRcIl0ucmVhZERyb3BQb3MoaSkscyhlLHIsaSk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKFwidW5rbm93biBtb3ZlXCIpfWVsc2UgaWYoZS5zcGVjdGF0b3IpdD09PUxbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW4mJihyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxnKGUsUltcImRlZmF1bHRcIl0uZHJhd0J5UG92KG8pLHIpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1MW1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuKTtlbHNlIHN3aXRjaCh0KXtjYXNlIExbXCJkZWZhdWx0XCJdLmRpc2NhcmQ6cj1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UocikucGllY2UsdyhlLHIsUltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMl0pLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1MW1wiZGVmYXVsdFwiXS5kaXNjYXJkO2JyZWFrO2Nhc2UgTFtcImRlZmF1bHRcIl0uZHJhd01pZGRsZTpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxlLm1pZGRsZUhvbGRlci5jdXJyZW50P05bXCJkZWZhdWx0XCJdLmFwaURyYXdNaWRkbGVFbmQoZSxyKTpOW1wiZGVmYXVsdFwiXS5hcGlGb3JjZURyYXdNaWRkbGVFbmQoZSxyKSxlLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9TFtcImRlZmF1bHRcIl0uZHJhd01pZGRsZTticmVhaztjYXNlIExbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW46TltcImRlZmF1bHRcIl0ucGxheUxlYXZlVGFrZW4oZSxyKX19ZnVuY3Rpb24gZChlLHQsbil7dmFyIHI9bi50eXBlLGE9bi5ncm91cEluZGV4LGk9ZS5vcGVucy5zZXJpZXNbYV0sbz1yIT09TFtcImRlZmF1bHRcIl0uZHJvcFJlcGxhY2U/MDoxLHU9MDtpZihyPT09TFtcImRlZmF1bHRcIl0uZHJvcExlZnQpdT0wO2Vsc2UgaWYocj09PUxbXCJkZWZhdWx0XCJdLmRyb3BSaWdodCl1PWkubGVuZ3RoKzE7ZWxzZXt2YXIgbD1HW1wiZGVmYXVsdFwiXS5waWVjZVVwKGUubWlkZGxlc1tSW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0pO3U9RltcImRlZmF1bHRcIl0uZmluZE9rZXlJbmRleChpLGwpKzF9aS5zcGxpY2UodS1vLG8sdCksZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBzKGUsdCxuKXt2YXIgcj1uLmdyb3VwSW5kZXgsYT1lLm9wZW5zLnBhaXJzW3JdLGk9R1tcImRlZmF1bHRcIl0ucGllY2VVcChlLm1pZGRsZXNbUltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdKSxvPUZbXCJkZWZhdWx0XCJdLmZpbmRPa2V5SW5kZXgoYSxpKTthLnNwbGljZShvLDEsdCksZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBjKGUsdCl7dmFyIG49dCxyPWUub3BlbnMuc2VyaWVzLmNvbmNhdChuKTtlLm9wZW5zLnNlcmllcz1yLGUub3BlbnMucmVsYXlvdXQoZSl9ZnVuY3Rpb24gZihlLHQpe3ZhciBuPXQscj1lLm9wZW5zLnBhaXJzLmNvbmNhdChuKTtlLm9wZW5zLnBhaXJzPXIsZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBwKGUsdCxuKXtyZXR1cm4gZS5kaXNjYXJkc1t0XS51bnNoaWZ0KG4pLGUubGFzdE1vdmU9W3RdLCEwfWZ1bmN0aW9uIHYoZSl7cmV0dXJuIGUubWlkZGxlc1tSW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0tLSxlLmxhc3RNb3ZlPVtSW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0sITB9ZnVuY3Rpb24gbShlLHQpe3JldHVybiBlLmRpc2NhcmRzW3RdLnNoaWZ0KCksITB9ZnVuY3Rpb24gZyhlLHQsbil7cmV0dXJuIGUuZGlzY2FyZHNbdF0udW5zaGlmdChuKSwhMH1mdW5jdGlvbiBoKGUsdCxuLHIpe2lmKCFlLnBpZWNlc1t0XXx8IXIpcmV0dXJuITE7dmFyIGk9ZS5waWVjZXNbdF07VShSW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsTFtcImRlZmF1bHRcIl0uZHJvcE9wZW5TZXJpZXMsSShpLmtleSkpKTt2YXIgbz1hKHIsMiksdT1vWzBdLGw9b1sxXSxkPWUub3BlbnMuc2VyaWVzW3VdLHM9TyhkLGwpLGM9cyE9PUxbXCJkZWZhdWx0XCJdLmRyb3BSZXBsYWNlPzA6MTtpZihkLnNwbGljZShsLWMsYyxpKSxlLm9wZW5zLnJlbGF5b3V0KGUpLGRlbGV0ZSBlLnBpZWNlc1t0XSxzPT09TFtcImRlZmF1bHRcIl0uZHJvcFJlcGxhY2Upe3ZhciBmPUdbXCJkZWZhdWx0XCJdLnBpZWNlVXAoZS5taWRkbGVzW1JbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSk7ZS5waWVjZXNbdF09Zn1yZXR1cm4hMH1mdW5jdGlvbiB5KGUsdCxuLHIpe2lmKCFlLnBpZWNlc1t0XXx8IXIpcmV0dXJuITE7dmFyIGk9ZS5waWVjZXNbdF07VShSW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsTFtcImRlZmF1bHRcIl0uZHJvcE9wZW5QYWlycyxJKGkua2V5KSkpO3ZhciBvPWEociwyKSx1PW9bMF0sbD1vWzFdLGQ9ZS5vcGVucy5wYWlyc1t1XTtkLnNwbGljZShsLDEsaSksZS5vcGVucy5yZWxheW91dChlKSxkZWxldGUgZS5waWVjZXNbdF07dmFyIHM9R1tcImRlZmF1bHRcIl0ucGllY2VVcChlLm1pZGRsZXNbUltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdKTtyZXR1cm4gZS5waWVjZXNbdF09cywhMH1mdW5jdGlvbiB3KGUsdCxuKXtmb3IodmFyIHIgaW4gZS5waWVjZXMpe3ZhciBhPWUucGllY2VzW3JdO2lmKGEmJlJbXCJkZWZhdWx0XCJdLnBpZWNlRXF1YWwodCxhKSlyZXR1cm4gYihlLHIsbiksITB9cmV0dXJuITF9ZnVuY3Rpb24gYihlLHQsbil7dmFyIHI9ZS5waWVjZXNbdF07cmV0dXJuISFyJiYoVShSW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsTFtcImRlZmF1bHRcIl0uZGlzY2FyZCxJKHIua2V5KSkpLGUuZGlzY2FyZHNbbl0udW5zaGlmdChlLnBpZWNlc1t0XSksZGVsZXRlIGUucGllY2VzW3RdLGUubGFzdE1vdmU9W25dLCEwKX1mdW5jdGlvbiBQKGUsdCl7dmFyIG49ZS5waWVjZXNbdF07cmV0dXJuISFuJiYoISFSW1wiZGVmYXVsdFwiXS5waWVjZUVxdWFsKG4sZS5taWRkbGVzW1JbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSkmJihVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxMW1wiZGVmYXVsdFwiXS5zaWduLEkobi5rZXkpKSksITApKX1mdW5jdGlvbiBrKGUsdCl7dmFyIG49ZS5waWVjZXNbdF07aWYoIW4pcmV0dXJuITE7ZGVsZXRlIGUucGllY2VzW3RdO3ZhciByPShHW1wiZGVmYXVsdFwiXS53cml0ZShlLnBpZWNlcyksTltcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFNlcmllcyhlKSksYT1OW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwUGFpcnMoZSk7aWYoR1tcImRlZmF1bHRcIl0udmFsaWREdXpPa2V5R3JvdXBGZW4ocikpVShSW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsTFtcImRlZmF1bHRcIl0uZGlzY2FyZEVuZFNlcmllcyxIKHIpKSk7ZWxzZXtpZighR1tcImRlZmF1bHRcIl0udmFsaWREdXpPa2V5R3JvdXBGZW4oYSkpcmV0dXJuIGUucGllY2VzW3RdPW4sITE7VShSW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsTFtcImRlZmF1bHRcIl0uZGlzY2FyZEVuZFBhaXJzLEgoYSkpKX1yZXR1cm4hMH1mdW5jdGlvbiBPKGUsdCl7cmV0dXJuIDA9PT10P0xbXCJkZWZhdWx0XCJdLmRyb3BMZWZ0OnQ9PT1lLmxlbmd0aCsxP0xbXCJkZWZhdWx0XCJdLmRyb3BSaWdodDpMW1wiZGVmYXVsdFwiXS5kcm9wUmVwbGFjZX1mdW5jdGlvbiB4KGUsdCxuKXtpZihuJiZSW1wiZGVmYXVsdFwiXS5pc09wZW5zS2V5KG4pJiZUKGUsdCxuKSl7dmFyIHIsaSxvLHUsbCxkPWUucGllY2VzW3RdLHM9R1tcImRlZmF1bHRcIl0uZ2V0T3BlblNlcmllRnJvbVBvcyhlLFJbXCJkZWZhdWx0XCJdLm1pbmlLZXkycG9zKG4pKTtpZihzKXt2YXIgYz1hKHMsMik7cj1jWzBdLGk9Y1sxXSxvPWUub3BlbnMuc2VyaWVzW3JdLHU9TyhvLGkpLGw9dStyfWlmKGgoZSx0LG4scykpcmV0dXJuIFUoUltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLExbXCJkZWZhdWx0XCJdLmRyb3BPcGVuU2VyaWVzLF8oZC5rZXksbCkpKSwhMDt2YXIgZj1HW1wiZGVmYXVsdFwiXS5nZXRPcGVuUGFpckZyb21Qb3MoZSxSW1wiZGVmYXVsdFwiXS5taW5pS2V5MnBvcyhuKSk7aWYoZil7dmFyIHA9YShmLDIpO3I9cFswXSxpPXBbMV0sbz1lLm9wZW5zLnBhaXJzW3JdLHU9TyhvLGkpLGw9dStyfWlmKHkoZSx0LG4sZikpcmV0dXJuIFUoUltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLExbXCJkZWZhdWx0XCJdLmRyb3BPcGVuUGFpcnMsXyhkLmtleSxsKSkpLCEwfXJldHVybiExfWZ1bmN0aW9uIFMoZSx0LG4pe3ZhciByPWUucGllY2VzW3RdO2lmKG4mJm49PT1SW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1syXSl7aWYoQShlLHQsbikmJmIoZSx0LG4pKXJldHVybiBVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixMW1wiZGVmYXVsdFwiXS5kaXNjYXJkLEkoci5rZXkpKSksITB9ZWxzZSBpZihuPT09UltcImRlZmF1bHRcIl0uZ29zdGVyZ2Upe2lmKEIoZSx0KSYmUChlLHQpKXJldHVybiBVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixMW1wiZGVmYXVsdFwiXS5zaWduLEkoci5rZXkpKSksITA7aWYoRChlLHQpJiZrKGUsdCkpe3ZhciBhPShHW1wiZGVmYXVsdFwiXS53cml0ZShlLnBpZWNlcyksTltcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFNlcmllcyhlKSksaT1OW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwUGFpcnMoZSk7cmV0dXJuIEdbXCJkZWZhdWx0XCJdLnZhbGlkRHV6T2tleUdyb3VwRmVuKGEpP1UoUltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLExbXCJkZWZhdWx0XCJdLmRpc2NhcmRFbmRTZXJpZXMsSChhKSkpOkdbXCJkZWZhdWx0XCJdLnZhbGlkRHV6T2tleUdyb3VwRmVuKGkpJiZVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixMW1wiZGVmYXVsdFwiXS5kaXNjYXJkRW5kUGFpcnMsSChpKSkpLCEwfX1yZXR1cm4hMX1mdW5jdGlvbiBFKGUsdCl7TShlLHQpfWZ1bmN0aW9uIE0oZSx0KXtlLnNlbGVjdGVkPXR9ZnVuY3Rpb24gQyhlLHQpe3JldHVybiBSW1wiZGVmYXVsdFwiXS5pc01pZGRsZUtleSh0KXx8UltcImRlZmF1bHRcIl0uaXNEcmF3TGVmdEtleSh0KT9lLnBvdlNpZGU9PT1lLnR1cm5TaWRlOlJbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodCl9ZnVuY3Rpb24gSyhlKXtyZXR1cm4gZS5wb3ZTaWRlPT09ZS50dXJuU2lkZX1mdW5jdGlvbiBUKGUsdCxuKXt2YXIgcj1lLm1pZGRsZXNbUltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdO3JldHVybiBOW1wiZGVmYXVsdFwiXS5pc0Ryb3BwYWJsZU9wZW5zKGUsdCkmJlJbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodCkmJlJbXCJkZWZhdWx0XCJdLmlzT3BlbnNLZXkobikmJlJbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMsTFtcImRlZmF1bHRcIl0uZHJvcE9wZW5TZXJpZXMpJiZSW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLExbXCJkZWZhdWx0XCJdLmRyb3BPcGVuUGFpcnMpJiZSW1wiZGVmYXVsdFwiXS5jb250YWluc1goRltcImRlZmF1bHRcIl0uY29tcHV0ZShlLm9wZW5zLGUucGllY2VzW3RdLHIpLG4pfWZ1bmN0aW9uIEEoZSx0LG4pe3JldHVybiBLKGUpJiZSW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLExbXCJkZWZhdWx0XCJdLmRpc2NhcmQpfWZ1bmN0aW9uIEQoZSx0KXtyZXR1cm4gSyhlKSYmUltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxMW1wiZGVmYXVsdFwiXS5kaXNjYXJkRW5kU2VyaWVzKX1mdW5jdGlvbiBCKGUsdCl7cmV0dXJuIEsoZSkmJlJbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMsTFtcImRlZmF1bHRcIl0uc2hvd1NpZ24pfWZ1bmN0aW9uIGooZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlJbXCJkZWZhdWx0XCJdLnRvcENvbHVtbnMsbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06UltcImRlZmF1bHRcIl0udG9wUm93cztyZXR1cm4gZnVuY3Rpb24ocixhLGkpe2lmKGl8fHIuYm91bmRzKXtpPWl8fHIuYm91bmRzKCk7dmFyIG89TWF0aC5mbG9vcih0KigoYVswXS1pLmxlZnQpL2kud2lkdGgpKSx1PU1hdGguZmxvb3IobiooKGFbMV0taS50b3ApL2kuaGVpZ2h0KSk7cmV0dXJuIHU+PTAmJnU8biYmbz49MCYmbzx0P2UodSxvKTp2b2lkIDB9fX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIFI9cihlKFwiLi91dGlsXCIpKSxMPXIoZShcIi4vbW92ZVwiKSksRz1yKGUoXCIuL3BpZWNlc1wiKSksRj1yKGUoXCIuL29wZW5cIikpLE49cihlKFwiLi9ib2FyZFwiKSksXz1SW1wiZGVmYXVsdFwiXS53cmFwRHJvcCxJPVJbXCJkZWZhdWx0XCJdLndyYXBQaWVjZSxIPVJbXCJkZWZhdWx0XCJdLndyYXBHcm91cCxVPVJbXCJkZWZhdWx0XCJdLmNhbGxVc2VyRnVuY3Rpb24scT1qKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIFJbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFt0LGVdKX0sUltcImRlZmF1bHRcIl0ubWluaUNvbHVtbnMsUltcImRlZmF1bHRcIl0ubWluaVJvd3MpLFg9aihmdW5jdGlvbihlLHQpe2lmKGU9PT1SW1wiZGVmYXVsdFwiXS50b3BSb3dzLTEpe2lmKDA9PT10KXJldHVybiBSW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1sxXTtpZih0PT09UltcImRlZmF1bHRcIl0udG9wQ29sdW1ucy00KXJldHVybiBSW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudH19KSx6PWooZnVuY3Rpb24oZSx0KXtpZihlPT09UltcImRlZmF1bHRcIl0udG9wUm93cy0xKXtpZih0PT09UltcImRlZmF1bHRcIl0udG9wQ29sdW1ucy0xKXJldHVybiBSW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1syXTtpZih0PT09UltcImRlZmF1bHRcIl0udG9wQ29sdW1ucy0zKXJldHVybiBSW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZX19KSwkPXthcGlNb3ZlOmwsc2VsZWN0VG9wOkUsZHJvcFRvcDpTLGRyb3BPcGVuczp4LGlzRHJhZ2dhYmxlOkMsZ2V0RHJhd0tleUF0RG9tUG9zOlgsXG5nZXREaXNjYXJkS2V5QXREb21Qb3M6eixnZXRPcGVuc0tleUF0RG9tUG9zOnF9O25bXCJkZWZhdWx0XCJdPSR9LHtcIi4vYm9hcmRcIjo1LFwiLi9tb3ZlXCI6MTIsXCIuL29wZW5cIjoxMyxcIi4vcGllY2VzXCI6MTQsXCIuL3V0aWxcIjoxN31dLDE3OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLHQpe3JldHVybiBfW2VdW3RdfWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm4gZS5jb2xvcj09PXQuY29sb3ImJmUubnVtYmVyPT09dC5udW1iZXJ9ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgbj1bXSxyPTA7cjxlO3IrKylmb3IodmFyIGE9MDthPHQ7YSsrKW4ucHVzaChbYSxyXSk7cmV0dXJuIG59ZnVuY3Rpb24gbyhlLHQpe3JldHVybiB0K2V9ZnVuY3Rpb24gdShlLHQpe3JldHVybiBwYXJzZUludChlLnNsaWNlKDEpKX1mdW5jdGlvbiBsKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxO3JldHVybiBvKHUoZSktdCxXKX1mdW5jdGlvbiBkKGUpe3JldHVybiBlWzBdPT09V31mdW5jdGlvbiBzKGUpe3JldHVybiBlWzBdPT09Wn1mdW5jdGlvbiBjKGUpe3JldHVybiBlPT09Sn1mdW5jdGlvbiBmKGUpe3JldHVybiBlPT09JFsxXX1mdW5jdGlvbiBwKGUpe3ZhciB0PWVbMV0qQitlWzBdO3JldHVybiBvKHQsVyl9ZnVuY3Rpb24gdihlKXtyZXR1cm4gZT11KGUpLFtlJUIsTWF0aC5mbG9vcihlL0IpXX1mdW5jdGlvbiBtKGUpe3JldHVybiBvKGUsVyl9ZnVuY3Rpb24gZyhlLHQpe2Z1bmN0aW9uIG4oZSl7dmFyIHQ9TWF0aC5mbG9vcihlL0IpLG49ZSVCO3JldHVybltuLHRdfWZ1bmN0aW9uIHIoZSl7cmV0dXJuIGVbMV0qQitlWzBdfXZhciBhPW4oZSksaT1uKGUrMip0KTtyZXR1cm4gYVsxXSE9PWlbMV0/cihbMSwxXSk6KDE9PT1hWzFdJiYwPT09YVswXSYmKGFbMF09MSkscihhKSl9ZnVuY3Rpb24gaChlKXtyZXR1cm4gWVtlXX1mdW5jdGlvbiB5KGUpe3ZhciB0PWVbMV0qRytlWzBdO3JldHVybiBvKHQsWil9ZnVuY3Rpb24gdyhlKXtyZXR1cm4gZT11KGUpLFtlJUcsTWF0aC5mbG9vcihlL0cpXX1mdW5jdGlvbiBiKGUpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBlKWVbbl0mJnQucHVzaChuKTtyZXR1cm4gdC5qb2luKFwiIFwiKX1mdW5jdGlvbiBQKGUsdCl7cmV0dXJuIGUmJmUuaW5kZXhPZih0KSE9PS0xfWZ1bmN0aW9uIGsoZSl7cmV0dXJuIGUudG91Y2hlcz9bZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFgsZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFldOltlLmNsaWVudFgsZS5jbGllbnRZXX1mdW5jdGlvbiBPKGUsdCl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlWzBdLXRbMF0sMikrTWF0aC5wb3coZVsxXS10WzFdLDIpKX1mdW5jdGlvbiB4KCl7cmV0dXJuXCJ0cmFuc2Zvcm1cImluIGRvY3VtZW50LmJvZHkuc3R5bGU/XCJ0cmFuc2Zvcm1cIjpcIndlYmtpdFRyYW5zZm9ybVwiaW4gZG9jdW1lbnQuYm9keS5zdHlsZT9cIndlYmtpdFRyYW5zZm9ybVwiOlwibW96VHJhbnNmb3JtXCJpbiBkb2N1bWVudC5ib2R5LnN0eWxlP1wibW96VHJhbnNmb3JtXCI6XCJvVHJhbnNmb3JtXCJpbiBkb2N1bWVudC5ib2R5LnN0eWxlP1wib1RyYW5zZm9ybVwiOlwibXNUcmFuc2Zvcm1cIn1mdW5jdGlvbiBTKCl7cmV0dXJuIER8fChEPXgoKSksRH1mdW5jdGlvbiBFKGUpe3JldHVyblwidHJhbnNsYXRlKFwiK2VbMF0rXCJweCxcIitlWzFdK1wicHgpXCJ9ZnVuY3Rpb24gTShlLHQpe3JldHVybiBlLmJpbmQuYXBwbHkoZSxbbnVsbF0uY29uY2F0KHQpKX1mdW5jdGlvbiBDKCl7cmV0dXJuIE0oYXJndW1lbnRzWzBdLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSl9ZnVuY3Rpb24gSyhlKXtyZXR1cm4gMj09PWUuYnV0dG9uc3x8Mj09PWUuYnV0dG9ufWZ1bmN0aW9uIFQoZSl7dmFyIHQsbj1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10JiYodD1lKCkpLHR9O3JldHVybiBuLmNsZWFyPWZ1bmN0aW9uKCl7dD12b2lkIDB9LG59ZnVuY3Rpb24gQShlKXtzZXRUaW1lb3V0KGUsMSl9dmFyIEQsQj0zMixqPTIsUj0xNixMPTcsRz0yMCxGPTgsTj1bXCJlYXN0XCIsXCJ3ZXN0XCIsXCJub3J0aFwiLFwic291dGhcIl0sXz17ZWFzdDp7ZWFzdDpcImRvd25cIix3ZXN0OlwidXBcIixub3J0aDpcInJpZ2h0XCIsc291dGg6XCJsZWZ0XCJ9LHdlc3Q6e2Vhc3Q6XCJ1cFwiLHdlc3Q6XCJkb3duXCIsbm9ydGg6XCJsZWZ0XCIsc291dGg6XCJyaWdodFwifSxub3J0aDp7ZWFzdDpcImxlZnRcIix3ZXN0OlwicmlnaHRcIixub3J0aDpcImRvd25cIixzb3V0aDpcInVwXCJ9LHNvdXRoOntlYXN0OlwicmlnaHRcIix3ZXN0OlwibGVmdFwiLG5vcnRoOlwidXBcIixzb3V0aDpcImRvd25cIn19LEk9e3VwOjAsbGVmdDoxLGRvd246MixyaWdodDozfSxIPXt1cDozLGxlZnQ6MCxkb3duOjEscmlnaHQ6Mn0sVT17dXA6Wy41LDBdLGxlZnQ6WzAsLjVdLHJpZ2h0OlsxLC41XSxkb3duOlsuNSwxXX0scT1mdW5jdGlvbihlKXtyZXR1cm4gVVtlXX0sWD1mdW5jdGlvbihlKXtyZXR1cm4gJFtJW2VdXX0sej1mdW5jdGlvbihlKXtyZXR1cm4gJFtIW2VdXX0sJD1bXCJkdXBcIixcImRsZWZ0XCIsXCJkZG93blwiLFwiZHJpZ2h0XCJdLEo9XCJtbWlkZGxlQ291bnRcIixWPVwibWdvc3RlcmdlXCIsWT17ZHVwOlswLDBdLGRsZWZ0OlswLEwtMV0sZGRvd246W1ItMSxMLTFdLGRyaWdodDpbUi0xLDBdLG1taWRkbGVDb3VudDpbUi00LEwtMV0sbWdvc3RlcmdlOltSLTMsTC0xXX0sUT17Y29sb3I6XCJlbXB0eVwiLG51bWJlcjoxfSxXPVwiYlwiLFo9XCJvXCIsZWU9aShqLEIpLHRlPWkoRixHKSxuZT1bWzAsMF0sWzMwLDBdLFszMSwwXSxbMzIsMF0sWzYyLDBdLFs2MywwXV0ubWFwKHApLHJlPWZ1bmN0aW9uKGUpe3JldHVybiBuZS5pbmRleE9mKGUpPT09LTF9LGFlPWVlLm1hcChwKSxpZT1hZS5maWx0ZXIocmUpLG9lPWZ1bmN0aW9uKGUpe3JldHVybiBpZS5pbmRleE9mKGUpIT09LTF9LHVlPXRlLm1hcCh5KSxsZT1mdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307cmV0dXJuIHQucGllY2U9ZSx0fSxkZT1mdW5jdGlvbihlKXtyZXR1cm57Z3JvdXA6ZX19LHNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3BpZWNlOmUscG9zOnR9fTt0LmV4cG9ydHM9e3RvcENvbHVtbnM6Uix0b3BSb3dzOkwsY29sdW1uczpCLHJvd3M6aixlbXB0eVBpZWNlOlEscGllY2VFcXVhbDphLGFsbFNpZGVzOk4sYWxsUG9zOmVlLGFsbEtleXM6YWUsdG9wS2V5MnBvczpoLHBvczJrZXk6cCxrZXkycG9zOnYsaXRlcmF0b3IyS2V5Om0sbmV4dEl0ZXJhdG9yRm9yR3JvdXA6ZyxtaW5pQ29sdW1uczpHLG1pbmlSb3dzOkYsbWluaUFsbFBvczp0ZSxtaW5pQWxsS2V5czp1ZSxtaW5pUG9zMmtleTp5LG1pbmlLZXkycG9zOncsZW5jb2RlS2V5Om8sZGVjQm9hcmRLZXk6bCxub3RBbGxvd2VkQm9hcmRLZXlzOm5lLGlzQWxsb3dlZEJvYXJkS2V5OnJlLGlzQWxsQWxsb3dlZEJvYXJkS2V5Om9lLGFsbEFsbG93ZWRCb2FyZEtleXM6aWUsaXNCb2FyZEtleTpkLGlzT3BlbnNLZXk6cyxpc01pZGRsZUtleTpjLGlzRHJhd0xlZnRLZXk6ZixmaW5kUG92OnIsdmVjdG9yQnlQb3Y6cSxkcmF3QnlQb3Y6eixkaXNjYXJkQnlQb3Y6WCxkaXNjYXJkczokLG1pZGRsZUNvdW50OkosZ29zdGVyZ2U6VixjbGFzc1NldDpiLGNvbnRhaW5zWDpQLGV2ZW50UG9zaXRpb246ayxkaXN0YW5jZTpPLHRyYW5zZm9ybVByb3A6Uyx0cmFuc2xhdGU6RSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6KHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5zZXRUaW1lb3V0KS5iaW5kKHdpbmRvdykscGFydGlhbEFwcGx5Ok0scGFydGlhbDpDLGlzUmlnaHRCdXR0b246SyxtZW1vOlQsd3JhcFBpZWNlOmxlLHdyYXBHcm91cDpkZSx3cmFwRHJvcDpzZSxjYWxsVXNlckZ1bmN0aW9uOkF9fSx7fV0sMTg6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5jb2xvcitcIiBcIitlLm51bWJlcn1mdW5jdGlvbiBpKGUpe3JldHVybntsZWZ0OmVbMF0qKDEwMC9UW1wiZGVmYXVsdFwiXS5jb2x1bW5zKStcIiVcIix0b3A6ZVsxXSooMTAwL1RbXCJkZWZhdWx0XCJdLnJvd3MpK1wiJVwifX1mdW5jdGlvbiBvKGUpe3JldHVybntsZWZ0OmVbMF0qKDEwMC9UW1wiZGVmYXVsdFwiXS5taW5pQ29sdW1ucykrXCIlXCIsdG9wOmVbMV0qKDEwMC9UW1wiZGVmYXVsdFwiXS5taW5pUm93cykrXCIlXCJ9fWZ1bmN0aW9uIHUoZSx0LG4scil7dmFyIGk9KGUuZGF0YSx7a2V5Om4sc3R5bGU6byh0KSxcImNsYXNzXCI6YShyKStcIiBtaW5pXCJ9KTtpZihlLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXMpe3ZhciB1PWUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltc1tuXSxsPWUuZGF0YS5hbmltYXRpb24uY3VycmVudC5zY2FsZXNbbl07dSYmKGlbXCJjbGFzc1wiXSs9XCIgYW5pbWF0aW5nXCIsaS5zdHlsZVtUW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldPVRbXCJkZWZhdWx0XCJdLnRyYW5zbGF0ZSh1WzFdKSxsJiYoaS5zdHlsZVtUW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldKz1cIiBzY2FsZShcIi5jb25jYXQobFswXSxcIiwgXCIpLmNvbmNhdChsWzFdLFwiKVwiKSxpLnN0eWxlLnRyYW5zZm9ybU9yaWdpbj1cImNlbnRlclwiKSl9cmV0dXJue3RhZzpcInBpZWNlXCIsYXR0cnM6aX19ZnVuY3Rpb24gbChlLHQsbil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10mJmFyZ3VtZW50c1szXSxpPWUuZGF0YSxvPVRbXCJkZWZhdWx0XCJdLmNsYXNzU2V0KHtzZWxlY3RlZDppLnNlbGVjdGVkPT09dCxcImxhc3QtbW92ZVwiOmkubGFzdE1vdmUmJlRbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChpLmxhc3RNb3ZlLHQpfSksdT17c3R5bGU6e30sXCJjbGFzc1wiOlthKG4pLHQsb10uam9pbihcIiBcIiksXCJkYXRhLW1pZGRsZS1jb3VudFwiOmUuZGF0YS5taWRkbGVzW3RdfSxsPWUuZGF0YS5kcmFnZ2FibGUuY3VycmVudDtpZihyJiZsLm9yaWc9PT10KXUuc3R5bGVbVFtcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1UW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoW2wucG9zWzBdK2wuZGVjWzBdLGwucG9zWzFdK2wuZGVjWzFdXSksdVtcImNsYXNzXCJdKz1cIiBkcmFnZ2luZ1wiO2Vsc2UgaWYoIXImJmUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltcyl7dmFyIGQ9ZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW3RdO2QmJih1W1wiY2xhc3NcIl0rPVwiIGFuaW1hdGluZ1wiLHUuc3R5bGVbVFtcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1UW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoZFsxXSkpfXJldHVybnt0YWc6XCJwaWVjZVwiLGF0dHJzOnV9fWZ1bmN0aW9uIGQoZSx0LG4scil7dmFyIGk9IShhcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XSl8fGFyZ3VtZW50c1s0XSxvPWFyZ3VtZW50cy5sZW5ndGg+NSYmdm9pZCAwIT09YXJndW1lbnRzWzVdP2FyZ3VtZW50c1s1XTp0LHU9ZS5kYXRhLGw9VFtcImRlZmF1bHRcIl0uY2xhc3NTZXQoe3NlbGVjdGVkOnUuc2VsZWN0ZWQ9PT10fSksZD17c3R5bGU6e30sXCJjbGFzc1wiOlthKG4pLHQsbF0uam9pbihcIiBcIil9O3ImJihkW1wiY2xhc3NcIl0rPVwiIFwiK3IpO3ZhciBzPWUuZGF0YS5kcmFnZ2FibGUuY3VycmVudDtpZihpJiZzLm9yaWc9PT10KWQuc3R5bGVbVFtcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1UW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoW3MucG9zWzBdK3MuZGVjWzBdLHMucG9zWzFdK3MuZGVjWzFdXSksZFtcImNsYXNzXCJdKz1cIiBkcmFnZ2luZ1wiO2Vsc2UgaWYoaSYmZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zKXt2YXIgYz1lLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXNbb107YyYmKGRbXCJjbGFzc1wiXSs9XCIgYW5pbWF0aW5nXCIsZC5zdHlsZVtUW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldPVRbXCJkZWZhdWx0XCJdLnRyYW5zbGF0ZShjWzFdKSl9cmV0dXJue3RhZzpcInBpZWNlXCIsYXR0cnM6ZH19ZnVuY3Rpb24gcyhlLHQsbil7dmFyIHI9KGUuZGF0YSxUW1wiZGVmYXVsdFwiXS5jbGFzc1NldCh7XCJwaWVjZS1ob2xkZXJcIjohMH0pKSxhPXtzdHlsZTp7fSxcImNsYXNzXCI6W3QscixuXS5qb2luKFwiIFwiKX07cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOmF9fWZ1bmN0aW9uIGMoZSx0LG4scil7dmFyIGE9XCJmbGlwcGVyXCIrKG4/XCIgaG92ZXJcIjpcIlwiKStcIiBcIityLGk9e3RvcDowLGxlZnQ6MH0sbz1lLmF0dHJzLnN0eWxlO2UuYXR0cnMuc3R5bGU9aSx0LmF0dHJzLnN0eWxlPWk7dmFyIHU9e1wiY2xhc3NcIjphLHN0eWxlOm99O3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp1LGNoaWxkcmVuOlt7dGFnOlwiZGl2XCIsYXR0cnM6e1wiY2xhc3NcIjpcImZyb250XCJ9LGNoaWxkcmVuOltlXX0se3RhZzpcImRpdlwiLGF0dHJzOntcImNsYXNzXCI6XCJiYWNrXCJ9LGNoaWxkcmVuOlt0XX1dfX1mdW5jdGlvbiBmKGUsdCxuLHIsbyl7dmFyIHU9ZS5kYXRhLGw9VFtcImRlZmF1bHRcIl0uY2xhc3NTZXQoe3NlbGVjdGVkOnUuc2VsZWN0ZWQ9PT1ufSksZD17a2V5Om4sc3R5bGU6aSh0KSxcImNsYXNzXCI6W2EociksbF0uam9pbihcIiBcIil9O28mJihkW1wiY2xhc3NcIl0rPVwiIFwiK28pO3ZhciBzPWUuZGF0YS5kcmFnZ2FibGUuY3VycmVudDtpZihzLmRyYWdHcm91cCYmcy5kcmFnR3JvdXAuaW5kZXhPZihuKSE9PS0xPyhkLnN0eWxlW1RbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV09VFtcImRlZmF1bHRcIl0udHJhbnNsYXRlKFtzLnBvc1swXStzLmRlY1swXSxzLnBvc1sxXStzLmRlY1sxXV0pLGRbXCJjbGFzc1wiXSs9XCIgZ3JvdXAgZHJhZ2dpbmdcIik6cy5vcmlnPT09biYmKHMub3ZlciYmVFtcImRlZmF1bHRcIl0uaXNPcGVuc0tleShzLm92ZXIpJiYoZC5zdHlsZS53aWR0aD1zLm9wZW5zQm91bmRzLndpZHRoL1RbXCJkZWZhdWx0XCJdLm1pbmlDb2x1bW5zK1wicHhcIixkLnN0eWxlLmhlaWdodD1zLm9wZW5zQm91bmRzLmhlaWdodC9UW1wiZGVmYXVsdFwiXS5taW5pUm93cytcInB4XCIpLGQuc3R5bGVbVFtcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1UW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoW3MucG9zWzBdK3MuZGVjWzBdLHMucG9zWzFdK3MuZGVjWzFdXSksZFtcImNsYXNzXCJdKz1cIiBkcmFnZ2luZ1wiKSxlLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXMpe3ZhciBjPWUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltc1tuXTtjJiYoZFtcImNsYXNzXCJdKz1cIiBhbmltYXRpbmdcIixkLnN0eWxlW1RbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV09VFtcImRlZmF1bHRcIl0udHJhbnNsYXRlKGNbMV0pKX1yZXR1cm57dGFnOlwicGllY2VcIixhdHRyczpkfX1mdW5jdGlvbiBwKGUsdCxuKXtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e1wiY2xhc3NcIjplK1wiIG9jIFwiK259fX1mdW5jdGlvbiB2KGUsdCxuKXtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e3N0eWxlOm8obiksXCJjbGFzc1wiOmUrXCIgb2NcIn19fWZ1bmN0aW9uIG0oZSx0LG4pe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7c3R5bGU6aShuKSxcImNsYXNzXCI6ZX19fWZ1bmN0aW9uIGcoZSl7ZnVuY3Rpb24gdChlKXtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e1wiY2xhc3NcIjpcIndvb2QgXCIrZX19fXZhciBuLHI9ZS5kYXRhLGE9VFtcImRlZmF1bHRcIl0uYWxsUG9zLGk9W107aS5wdXNoKHQoXCJsZWZ0XCIpLHQoXCJyaWdodFwiKSk7Zm9yKHZhciBvPTA7bzxhLmxlbmd0aDtvKyspe3ZhciB1PVRbXCJkZWZhdWx0XCJdLnBvczJrZXkoYVtvXSksbD1yLnBpZWNlc1t1XTtpZihsKXt2YXIgZD1mKGUsYVtvXSx1LGwpO2lmKHIuZmxpcHBhYmxlLmN1cnJlbnQub3JpZz09PXUpe3ZhciBzLHAsdj1yLmZsaXBwYWJsZS5jdXJyZW50LmZsaXAsZz1mKGUsYVtvXSx1LFRbXCJkZWZhdWx0XCJdLmVtcHR5UGllY2UpO2wuZmxpcD8ocz1nLHA9ZCk6KHM9ZCxwPWcpLGkucHVzaChjKHMscCx2KSl9ZWxzZSBsLmZsaXAmJihkPWYoZSxhW29dLHUsVFtcImRlZmF1bHRcIl0uZW1wdHlQaWVjZSkpLGkucHVzaChkKX1yLmRyYWdnYWJsZS5jdXJyZW50Lm92ZXI9PT11JiYobj1tKFwiZHJhZy1vdmVyXCIsZSxhW29dKSl9cmV0dXJuIHIubWlkZGxlSG9sZGVyLmtleSYmaS5wdXNoKGYoZSxUW1wiZGVmYXVsdFwiXS5rZXkycG9zKHIubWlkZGxlSG9sZGVyLmtleSksci5taWRkbGVIb2xkZXIua2V5LFRbXCJkZWZhdWx0XCJdLmVtcHR5UGllY2UsXCJsb2FkaW5nXCIpKSxuJiZpLnB1c2gobikse3RhZzpcImRpdlwiLGF0dHJzOntjb25maWc6ZnVuY3Rpb24odCxuLHIpe258fChlLmRhdGEuYm9hcmRCb3VuZHM9VFtcImRlZmF1bHRcIl0ubWVtbyh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdC5iaW5kKHQpKSl9LFwiY2xhc3NcIjpcIm9nLWJvYXJkXCJ9LGNoaWxkcmVuOml9fWZ1bmN0aW9uIGgoZSx0KXtmb3IodmFyIG49ZS5kYXRhLHI9VFtcImRlZmF1bHRcIl0ubWluaUFsbFBvcyxhPVtdLGk9W10sbz0wO288ci5sZW5ndGg7bysrKXt2YXIgbD1UW1wiZGVmYXVsdFwiXS5taW5pUG9zMmtleShyW29dKSxkPXRbbF07aWYoZCYmYS5wdXNoKHUoZSxyW29dLGwsZCkpLGUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltcyl7dmFyIHM9ZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW2xdO2Q9ZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmV4dHJhW2xdLHMmJmQmJmEucHVzaCh1KGUscltvXSxsLGQpKX12YXIgYz1UW1wiZGVmYXVsdFwiXS5jbGFzc1NldCh7XCJkcmFnLW92ZXJcIjpuLmRyYWdnYWJsZS5jdXJyZW50Lm92ZXI9PT1sLFwibW92ZS1kZXN0XCI6VFtcImRlZmF1bHRcIl0uY29udGFpbnNYKG4ub3BlbmFibGUuZGVzdHMsbCl9KTtcIlwiIT09YyYmaS5wdXNoKHYoYyxlLHJbb10pKX1yZXR1cm4gYS5wdXNoKGkpLGF9ZnVuY3Rpb24geShlKXt2YXIgdD1lLmRhdGEsbj1oKGUsdC5vcGVucy5sYXlvdXQubGF5b3V0KTtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e2NvbmZpZzpmdW5jdGlvbih0LG4scil7bnx8KGUuZGF0YS5vcGVuc0JvdW5kcz1UW1wiZGVmYXVsdFwiXS5tZW1vKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQodCkpKX0sXCJjbGFzc1wiOlwib2ctb3BlbnNcIn0sY2hpbGRyZW46bn19ZnVuY3Rpb24gdyhlKXt2YXIgdD1lLmRhdGEsbj1bXSxyPVtdO2Zvcih2YXIgYSBpbiB0LmRpc2NhcmRzKXt2YXIgaT10LmRpc2NhcmRzW2FdWzBdLG89VFtcImRlZmF1bHRcIl0uY2xhc3NTZXQoe1wiZHJhZy1vdmVyXCI6dC5kcmFnZ2FibGUuY3VycmVudC5vdmVyPT09YSxcIm1vdmUtZGVzdFwiOlwiZGRvd25cIj09PWEmJnQuc2VsZWN0ZWQmJlRbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodC5zZWxlY3RlZCkmJlRbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWCh0Lm1vdmFibGUuZGVzdHMsQVtcImRlZmF1bHRcIl0uZGlzY2FyZCksXCJsYXN0LW1vdmVcIjp0Lmxhc3RNb3ZlJiZUW1wiZGVmYXVsdFwiXS5jb250YWluc1godC5sYXN0TW92ZSxhKX0pO2lmKGkpe3QuZGlzY2FyZHNbYV1bMV0mJnIucHVzaChkKGUsYSx0LmRpc2NhcmRzW2FdWzFdLFwiZmFrZVwiLCExKSksci5wdXNoKGQoZSxhLGksbykpO3ZhciB1PUFbXCJkZWZhdWx0XCJdLmRyYXdMZWZ0K2EsbD0hIWUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltcyYmZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW3VdO2lmKGwpe3ZhciBjPWUuZGF0YS5hbmltYXRpb24uY3VycmVudC5leHRyYS5waWVjZTtyLnB1c2goZChlLGEsYyxvLCEwLHUpKX19ZWxzZSBuLnB1c2gocyhlLGEsbykpfXJldHVybiBuLnB1c2gociksbn1mdW5jdGlvbiBiKGUpe3ZhciB0PWUuZGF0YSxuPVtdLHI9dC5taWRkbGVIb2xkZXIucGllY2V8fFRbXCJkZWZhdWx0XCJdLmVtcHR5UGllY2U7aWYobi5wdXNoKGQoZSxUW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZSx0Lm1pZGRsZXNbVFtcImRlZmF1bHRcIl0uZ29zdGVyZ2VdKSksbi5wdXNoKGwoZSxUW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudCxUW1wiZGVmYXVsdFwiXS5lbXB0eVBpZWNlKSksVFtcImRlZmF1bHRcIl0uaXNNaWRkbGVLZXkodC5kcmFnZ2FibGUuY3VycmVudC5vcmlnKXx8dC5hbmltYXRpb24uY3VycmVudC5hbmltcyYmdC5hbmltYXRpb24uY3VycmVudC5hbmltc1tUW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0pe3ZhciBhPWwoZSxUW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudCxyLCEwKTtuLnB1c2goYSl9cmV0dXJuIHQuZHJhZ2dhYmxlLmN1cnJlbnQub3Zlcj09PVRbXCJkZWZhdWx0XCJdLmdvc3RlcmdlJiZuLnB1c2gocChcImRyYWctb3ZlclwiLGUsVFtcImRlZmF1bHRcIl0uZ29zdGVyZ2UpKSxufWZ1bmN0aW9uIFAoZSl7dmFyIHQ9W10sbj1lLmRhdGEudG9wSG9va3M7cmV0dXJuIG4mJnQucHVzaChuKSx0fWZ1bmN0aW9uIGsoZSl7dmFyIHQ9W2IoZSksdyhlKSx5KGUpLFAoZSldO3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7Y29uZmlnOmZ1bmN0aW9uKHQsbixyKXtufHwoZS5kYXRhLnRvcEJvdW5kcz1UW1wiZGVmYXVsdFwiXS5tZW1vKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQodCkpKX0sXCJjbGFzc1wiOlwib2ctdG9wXCJ9LGNoaWxkcmVuOnR9fWZ1bmN0aW9uIE8oZSl7cmV0dXJuW2soZSksZyhlKV19ZnVuY3Rpb24geChlLHQsbil7cmV0dXJuIGZ1bmN0aW9uKHIpe1RbXCJkZWZhdWx0XCJdLmlzUmlnaHRCdXR0b24ocik/bihlLHIpOmUudmlld09ubHl8fHQoZSxyKX19ZnVuY3Rpb24gUyhlLHQsbil7dmFyIHI9ZS5kYXRhLGE9eChyLENbXCJkZWZhdWx0XCJdLnN0YXJ0LEtbXCJkZWZhdWx0XCJdLnN0YXJ0KSxpPXgocixDW1wiZGVmYXVsdFwiXS5tb3ZlLEtbXCJkZWZhdWx0XCJdLm1vdmUpLG89eChyLENbXCJkZWZhdWx0XCJdLmVuZCxLW1wiZGVmYXVsdFwiXS5lbmQpLHU9W1widG91Y2hzdGFydFwiLFwibW91c2Vkb3duXCJdLGw9W1widG91Y2htb3ZlXCIsXCJtb3VzZW1vdmVcIl0sZD1bXCJ0b3VjaGVuZFwiLFwibW91c2V1cFwiXTt1LmZvckVhY2goZnVuY3Rpb24oZSl7dC5hZGRFdmVudExpc3RlbmVyKGUsYSl9KSxsLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlLGkpfSksZC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZSxvKX0pLG4ub251bmxvYWQ9ZnVuY3Rpb24oKXt1LmZvckVhY2goZnVuY3Rpb24oZSl7dC5yZW1vdmVFdmVudExpc3RlbmVyKGUsYSl9KSxsLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLGkpfSksZC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxvKX0pfX1mdW5jdGlvbiBFKGUpe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7XCJjbGFzc1wiOlwib2ctdGFibGVcIixjb25maWc6ZnVuY3Rpb24odCxuLHIpe258fChlLmRhdGEudmlld09ubHl8fFMoZSx0LHIpLGUuZGF0YS5yZW5kZXI9ZnVuY3Rpb24oKXtNW1wiZGVmYXVsdFwiXS5yZW5kZXIodCxPKGUpKX0sZS5kYXRhLnJlbmRlclJBRj1mdW5jdGlvbigpe1RbXCJkZWZhdWx0XCJdLnJlcXVlc3RBbmltYXRpb25GcmFtZShlLmRhdGEucmVuZGVyKX0sZS5kYXRhLmJvdW5kcz1UW1wiZGVmYXVsdFwiXS5tZW1vKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQodCkpLGUuZGF0YS5lbGVtZW50PXQsZS5kYXRhLnJlbmRlcigpKX19LGNoaWxkcmVuOltdfX12YXIgTT1yKGUoXCJtaXRocmlsXCIpKSxDPXIoZShcIi4vZHJhZ1wiKSksSz1yKGUoXCIuL2RyYXdcIikpLFQ9cihlKFwiLi91dGlsXCIpKSxBPXIoZShcIi4vbW92ZVwiKSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7Y29uZmlnOmZ1bmN0aW9uKHQsbil7bnx8KHQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsZnVuY3Rpb24oZSl7cmV0dXJuIGUucHJldmVudERlZmF1bHQoKSwhMX0pLFtcIm9uc2Nyb2xsXCIsXCJvbnJlc2l6ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBuPXdpbmRvd1t0XTt3aW5kb3dbdF09ZnVuY3Rpb24oKXtuJiZuKCksZS5kYXRhLmJvdW5kcy5jbGVhcigpLGUuZGF0YS5ib2FyZEJvdW5kcy5jbGVhcigpLGUuZGF0YS5vcGVuc0JvdW5kcy5jbGVhcigpLGUuZGF0YS50b3BCb3VuZHMuY2xlYXIoKX19KSl9LFwiY2xhc3NcIjpbXCJvZy10YWJsZS13cmFwXCJdLmpvaW4oXCIgXCIpfSxjaGlsZHJlbjpbRShlKV19fX0se1wiLi9kcmFnXCI6OSxcIi4vZHJhd1wiOjEwLFwiLi9tb3ZlXCI6MTIsXCIuL3V0aWxcIjoxNyxtaXRocmlsOjJ9XX0se30sWzExXSkoMTEpfSk7IiwiLyogTUlUIGxpY2Vuc2UgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJnYjJoc2w6IHJnYjJoc2wsXG4gIHJnYjJoc3Y6IHJnYjJoc3YsXG4gIHJnYjJod2I6IHJnYjJod2IsXG4gIHJnYjJjbXlrOiByZ2IyY215ayxcbiAgcmdiMmtleXdvcmQ6IHJnYjJrZXl3b3JkLFxuICByZ2IyeHl6OiByZ2IyeHl6LFxuICByZ2IybGFiOiByZ2IybGFiLFxuICByZ2IybGNoOiByZ2IybGNoLFxuXG4gIGhzbDJyZ2I6IGhzbDJyZ2IsXG4gIGhzbDJoc3Y6IGhzbDJoc3YsXG4gIGhzbDJod2I6IGhzbDJod2IsXG4gIGhzbDJjbXlrOiBoc2wyY215ayxcbiAgaHNsMmtleXdvcmQ6IGhzbDJrZXl3b3JkLFxuXG4gIGhzdjJyZ2I6IGhzdjJyZ2IsXG4gIGhzdjJoc2w6IGhzdjJoc2wsXG4gIGhzdjJod2I6IGhzdjJod2IsXG4gIGhzdjJjbXlrOiBoc3YyY215ayxcbiAgaHN2MmtleXdvcmQ6IGhzdjJrZXl3b3JkLFxuXG4gIGh3YjJyZ2I6IGh3YjJyZ2IsXG4gIGh3YjJoc2w6IGh3YjJoc2wsXG4gIGh3YjJoc3Y6IGh3YjJoc3YsXG4gIGh3YjJjbXlrOiBod2IyY215ayxcbiAgaHdiMmtleXdvcmQ6IGh3YjJrZXl3b3JkLFxuXG4gIGNteWsycmdiOiBjbXlrMnJnYixcbiAgY215azJoc2w6IGNteWsyaHNsLFxuICBjbXlrMmhzdjogY215azJoc3YsXG4gIGNteWsyaHdiOiBjbXlrMmh3YixcbiAgY215azJrZXl3b3JkOiBjbXlrMmtleXdvcmQsXG5cbiAga2V5d29yZDJyZ2I6IGtleXdvcmQycmdiLFxuICBrZXl3b3JkMmhzbDoga2V5d29yZDJoc2wsXG4gIGtleXdvcmQyaHN2OiBrZXl3b3JkMmhzdixcbiAga2V5d29yZDJod2I6IGtleXdvcmQyaHdiLFxuICBrZXl3b3JkMmNteWs6IGtleXdvcmQyY215ayxcbiAga2V5d29yZDJsYWI6IGtleXdvcmQybGFiLFxuICBrZXl3b3JkMnh5ejoga2V5d29yZDJ4eXosXG5cbiAgeHl6MnJnYjogeHl6MnJnYixcbiAgeHl6MmxhYjogeHl6MmxhYixcbiAgeHl6MmxjaDogeHl6MmxjaCxcblxuICBsYWIyeHl6OiBsYWIyeHl6LFxuICBsYWIycmdiOiBsYWIycmdiLFxuICBsYWIybGNoOiBsYWIybGNoLFxuXG4gIGxjaDJsYWI6IGxjaDJsYWIsXG4gIGxjaDJ4eXo6IGxjaDJ4eXosXG4gIGxjaDJyZ2I6IGxjaDJyZ2Jcbn1cblxuXG5mdW5jdGlvbiByZ2IyaHNsKHJnYikge1xuICB2YXIgciA9IHJnYlswXS8yNTUsXG4gICAgICBnID0gcmdiWzFdLzI1NSxcbiAgICAgIGIgPSByZ2JbMl0vMjU1LFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgbDtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBoID0gMDtcbiAgZWxzZSBpZiAociA9PSBtYXgpXG4gICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoZyA9PSBtYXgpXG4gICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGIgPT0gbWF4KVxuICAgIGggPSA0ICsgKHIgLSBnKS8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgbCA9IChtaW4gKyBtYXgpIC8gMjtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBzID0gMDtcbiAgZWxzZSBpZiAobCA8PSAwLjUpXG4gICAgcyA9IGRlbHRhIC8gKG1heCArIG1pbik7XG4gIGVsc2VcbiAgICBzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cbiAgcmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmhzdihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgIGgsIHMsIHY7XG5cbiAgaWYgKG1heCA9PSAwKVxuICAgIHMgPSAwO1xuICBlbHNlXG4gICAgcyA9IChkZWx0YS9tYXggKiAxMDAwKS8xMDtcblxuICBpZiAobWF4ID09IG1pbilcbiAgICBoID0gMDtcbiAgZWxzZSBpZiAociA9PSBtYXgpXG4gICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoZyA9PSBtYXgpXG4gICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGIgPT0gbWF4KVxuICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXG4gIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cbiAgaWYgKGggPCAwKVxuICAgIGggKz0gMzYwO1xuXG4gIHYgPSAoKG1heCAvIDI1NSkgKiAxMDAwKSAvIDEwO1xuXG4gIHJldHVybiBbaCwgcywgdl07XG59XG5cbmZ1bmN0aW9uIHJnYjJod2IocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLFxuICAgICAgZyA9IHJnYlsxXSxcbiAgICAgIGIgPSByZ2JbMl0sXG4gICAgICBoID0gcmdiMmhzbChyZ2IpWzBdLFxuICAgICAgdyA9IDEvMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpLFxuICAgICAgYiA9IDEgLSAxLzI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuICByZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyY215ayhyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0gLyAyNTUsXG4gICAgICBnID0gcmdiWzFdIC8gMjU1LFxuICAgICAgYiA9IHJnYlsyXSAvIDI1NSxcbiAgICAgIGMsIG0sIHksIGs7XG5cbiAgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuICBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICByZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2Iya2V5d29yZChyZ2IpIHtcbiAgcmV0dXJuIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShyZ2IpXTtcbn1cblxuZnVuY3Rpb24gcmdiMnh5eihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0gLyAyNTUsXG4gICAgICBnID0gcmdiWzFdIC8gMjU1LFxuICAgICAgYiA9IHJnYlsyXSAvIDI1NTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAociAvIDEyLjkyKTtcbiAgZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGcgLyAxMi45Mik7XG4gIGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChiIC8gMTIuOTIpO1xuXG4gIHZhciB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuICB2YXIgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcbiAgdmFyIHogPSAociAqIDAuMDE5MykgKyAoZyAqIDAuMTE5MikgKyAoYiAqIDAuOTUwNSk7XG5cbiAgcmV0dXJuIFt4ICogMTAwLCB5ICoxMDAsIHogKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IybGFiKHJnYikge1xuICB2YXIgeHl6ID0gcmdiMnh5eihyZ2IpLFxuICAgICAgICB4ID0geHl6WzBdLFxuICAgICAgICB5ID0geHl6WzFdLFxuICAgICAgICB6ID0geHl6WzJdLFxuICAgICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gcmdiMmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHJnYjJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wycmdiKGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSAvIDM2MCxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgdDEsIHQyLCB0MywgcmdiLCB2YWw7XG5cbiAgaWYgKHMgPT0gMCkge1xuICAgIHZhbCA9IGwgKiAyNTU7XG4gICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcbiAgfVxuXG4gIGlmIChsIDwgMC41KVxuICAgIHQyID0gbCAqICgxICsgcyk7XG4gIGVsc2VcbiAgICB0MiA9IGwgKyBzIC0gbCAqIHM7XG4gIHQxID0gMiAqIGwgLSB0MjtcblxuICByZ2IgPSBbMCwgMCwgMF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdDMgPSBoICsgMSAvIDMgKiAtIChpIC0gMSk7XG4gICAgdDMgPCAwICYmIHQzKys7XG4gICAgdDMgPiAxICYmIHQzLS07XG5cbiAgICBpZiAoNiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuICAgIGVsc2UgaWYgKDIgKiB0MyA8IDEpXG4gICAgICB2YWwgPSB0MjtcbiAgICBlbHNlIGlmICgzICogdDMgPCAyKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuICAgIGVsc2VcbiAgICAgIHZhbCA9IHQxO1xuXG4gICAgcmdiW2ldID0gdmFsICogMjU1O1xuICB9XG5cbiAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gaHNsMmhzdihoc2wpIHtcbiAgdmFyIGggPSBoc2xbMF0sXG4gICAgICBzID0gaHNsWzFdIC8gMTAwLFxuICAgICAgbCA9IGhzbFsyXSAvIDEwMCxcbiAgICAgIHN2LCB2O1xuXG4gIGlmKGwgPT09IDApIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gZG8gY2FsYyBvbiBibGFja1xuICAgICAgLy8gYWxzbyBhdm9pZHMgZGl2aWRlIGJ5IDAgZXJyb3JcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICBsICo9IDI7XG4gIHMgKj0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHYgPSAobCArIHMpIC8gMjtcbiAgc3YgPSAoMiAqIHMpIC8gKGwgKyBzKTtcbiAgcmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzbDJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHNsMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGhzbDJyZ2IoYXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIGhzdjJyZ2IoaHN2KSB7XG4gIHZhciBoID0gaHN2WzBdIC8gNjAsXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG5cbiAgdmFyIGYgPSBoIC0gTWF0aC5mbG9vcihoKSxcbiAgICAgIHAgPSAyNTUgKiB2ICogKDEgLSBzKSxcbiAgICAgIHEgPSAyNTUgKiB2ICogKDEgLSAocyAqIGYpKSxcbiAgICAgIHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKSxcbiAgICAgIHYgPSAyNTUgKiB2O1xuXG4gIHN3aXRjaChoaSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBbdiwgdCwgcF07XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFtxLCB2LCBwXTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gW3AsIHYsIHRdO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBbcCwgcSwgdl07XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFt0LCBwLCB2XTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gW3YsIHAsIHFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhzdjJoc2woaHN2KSB7XG4gIHZhciBoID0gaHN2WzBdLFxuICAgICAgcyA9IGhzdlsxXSAvIDEwMCxcbiAgICAgIHYgPSBoc3ZbMl0gLyAxMDAsXG4gICAgICBzbCwgbDtcblxuICBsID0gKDIgLSBzKSAqIHY7XG4gIHNsID0gcyAqIHY7XG4gIHNsIC89IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuICBzbCA9IHNsIHx8IDA7XG4gIGwgLz0gMjtcbiAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIGhzdjJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3Yihoc3YycmdiKGFyZ3MpKVxufVxuXG5mdW5jdGlvbiBoc3YyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc3YycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHN2MmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHN2MnJnYihhcmdzKSk7XG59XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuZnVuY3Rpb24gaHdiMnJnYihod2IpIHtcbiAgdmFyIGggPSBod2JbMF0gLyAzNjAsXG4gICAgICB3aCA9IGh3YlsxXSAvIDEwMCxcbiAgICAgIGJsID0gaHdiWzJdIC8gMTAwLFxuICAgICAgcmF0aW8gPSB3aCArIGJsLFxuICAgICAgaSwgdiwgZiwgbjtcblxuICAvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG4gIGlmIChyYXRpbyA+IDEpIHtcbiAgICB3aCAvPSByYXRpbztcbiAgICBibCAvPSByYXRpbztcbiAgfVxuXG4gIGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcbiAgdiA9IDEgLSBibDtcbiAgZiA9IDYgKiBoIC0gaTtcbiAgaWYgKChpICYgMHgwMSkgIT0gMCkge1xuICAgIGYgPSAxIC0gZjtcbiAgfVxuICBuID0gd2ggKyBmICogKHYgLSB3aCk7ICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG4gIHN3aXRjaCAoaSkge1xuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuICAgIGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuICAgIGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuICAgIGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gaHdiMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2IyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2Iya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJyZ2IoY215aykge1xuICB2YXIgYyA9IGNteWtbMF0gLyAxMDAsXG4gICAgICBtID0gY215a1sxXSAvIDEwMCxcbiAgICAgIHkgPSBjbXlrWzJdIC8gMTAwLFxuICAgICAgayA9IGNteWtbM10gLyAxMDAsXG4gICAgICByLCBnLCBiO1xuXG4gIHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcbiAgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuICBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIGNteWsyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3YihjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChjbXlrMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24geHl6MnJnYih4eXopIHtcbiAgdmFyIHggPSB4eXpbMF0gLyAxMDAsXG4gICAgICB5ID0geHl6WzFdIC8gMTAwLFxuICAgICAgeiA9IHh5elsyXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuICBnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcbiAgYiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cbiAgLy8gYXNzdW1lIHNSR0JcbiAgciA9IHIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IHIgPSAociAqIDEyLjkyKTtcblxuICBnID0gZyA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogZyA9IChnICogMTIuOTIpO1xuXG4gIGIgPSBiID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBiID0gKGIgKiAxMi45Mik7XG5cbiAgciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcbiAgZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcbiAgYiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiB4eXoybGFiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSxcbiAgICAgIHkgPSB4eXpbMV0sXG4gICAgICB6ID0geHl6WzJdLFxuICAgICAgbCwgYSwgYjtcblxuICB4IC89IDk1LjA0NztcbiAgeSAvPSAxMDA7XG4gIHogLz0gMTA4Ljg4MztcblxuICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMS8zKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcbiAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEvMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG4gIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxLzMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG4gIGwgPSAoMTE2ICogeSkgLSAxNjtcbiAgYSA9IDUwMCAqICh4IC0geSk7XG4gIGIgPSAyMDAgKiAoeSAtIHopO1xuXG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIHh5ejJsY2goYXJncykge1xuICByZXR1cm4gbGFiMmxjaCh4eXoybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eihsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIHgsIHksIHosIHkyO1xuXG4gIGlmIChsIDw9IDgpIHtcbiAgICB5ID0gKGwgKiAxMDApIC8gOTAzLjM7XG4gICAgeTIgPSAoNy43ODcgKiAoeSAvIDEwMCkpICsgKDE2IC8gMTE2KTtcbiAgfSBlbHNlIHtcbiAgICB5ID0gMTAwICogTWF0aC5wb3coKGwgKyAxNikgLyAxMTYsIDMpO1xuICAgIHkyID0gTWF0aC5wb3coeSAvIDEwMCwgMS8zKTtcbiAgfVxuXG4gIHggPSB4IC8gOTUuMDQ3IDw9IDAuMDA4ODU2ID8geCA9ICg5NS4wNDcgKiAoKGEgLyA1MDApICsgeTIgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDk1LjA0NyAqIE1hdGgucG93KChhIC8gNTAwKSArIHkyLCAzKTtcblxuICB6ID0geiAvIDEwOC44ODMgPD0gMC4wMDg4NTkgPyB6ID0gKDEwOC44ODMgKiAoeTIgLSAoYiAvIDIwMCkgLSAoMTYgLyAxMTYpKSkgLyA3Ljc4NyA6IDEwOC44ODMgKiBNYXRoLnBvdyh5MiAtIChiIC8gMjAwKSwgMyk7XG5cbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cblxuZnVuY3Rpb24gbGFiMmxjaChsYWIpIHtcbiAgdmFyIGwgPSBsYWJbMF0sXG4gICAgICBhID0gbGFiWzFdLFxuICAgICAgYiA9IGxhYlsyXSxcbiAgICAgIGhyLCBoLCBjO1xuXG4gIGhyID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMzYwO1xuICB9XG4gIGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gIHJldHVybiBbbCwgYywgaF07XG59XG5cbmZ1bmN0aW9uIGxhYjJyZ2IoYXJncykge1xuICByZXR1cm4geHl6MnJnYihsYWIyeHl6KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMmxhYihsY2gpIHtcbiAgdmFyIGwgPSBsY2hbMF0sXG4gICAgICBjID0gbGNoWzFdLFxuICAgICAgaCA9IGxjaFsyXSxcbiAgICAgIGEsIGIsIGhyO1xuXG4gIGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuICBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgYiA9IGMgKiBNYXRoLnNpbihocik7XG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIGxjaDJ4eXooYXJncykge1xuICByZXR1cm4gbGFiMnh5eihsY2gybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gbGNoMnJnYihhcmdzKSB7XG4gIHJldHVybiBsYWIycmdiKGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMnJnYihrZXl3b3JkKSB7XG4gIHJldHVybiBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3Yoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJsYWIoYXJncykge1xuICByZXR1cm4gcmdiMmxhYihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyeHl6KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJ4eXooa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG52YXIgY3NzS2V5d29yZHMgPSB7XG4gIGFsaWNlYmx1ZTogIFsyNDAsMjQ4LDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwyMzUsMjE1XSxcbiAgYXF1YTogWzAsMjU1LDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsMjU1LDIxMl0sXG4gIGF6dXJlOiAgWzI0MCwyNTUsMjU1XSxcbiAgYmVpZ2U6ICBbMjQ1LDI0NSwyMjBdLFxuICBiaXNxdWU6IFsyNTUsMjI4LDE5Nl0sXG4gIGJsYWNrOiAgWzAsMCwwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsMjM1LDIwNV0sXG4gIGJsdWU6IFswLDAsMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCw0MywyMjZdLFxuICBicm93bjogIFsxNjUsNDIsNDJdLFxuICBidXJseXdvb2Q6ICBbMjIyLDE4NCwxMzVdLFxuICBjYWRldGJsdWU6ICBbOTUsMTU4LDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsMjU1LDBdLFxuICBjaG9jb2xhdGU6ICBbMjEwLDEwNSwzMF0sXG4gIGNvcmFsOiAgWzI1NSwxMjcsODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwxNDksMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsMjQ4LDIyMF0sXG4gIGNyaW1zb246ICBbMjIwLDIwLDYwXSxcbiAgY3lhbjogWzAsMjU1LDI1NV0sXG4gIGRhcmtibHVlOiBbMCwwLDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwxMzksMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogIFsxODQsMTM0LDExXSxcbiAgZGFya2dyYXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtncmVlbjogIFswLDEwMCwwXSxcbiAgZGFya2dyZXk6IFsxNjksMTY5LDE2OV0sXG4gIGRhcmtraGFraTogIFsxODksMTgzLDEwN10sXG4gIGRhcmttYWdlbnRhOiAgWzEzOSwwLDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsMTA3LDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwxNDAsMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsNTAsMjA0XSxcbiAgZGFya3JlZDogIFsxMzksMCwwXSxcbiAgZGFya3NhbG1vbjogWzIzMywxNTAsMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLDE4OCwxNDNdLFxuICBkYXJrc2xhdGVibHVlOiAgWzcyLDYxLDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6ICBbNDcsNzksNzldLFxuICBkYXJrc2xhdGVncmV5OiAgWzQ3LDc5LDc5XSxcbiAgZGFya3R1cnF1b2lzZTogIFswLDIwNiwyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LDAsMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsMjAsMTQ3XSxcbiAgZGVlcHNreWJsdWU6ICBbMCwxOTEsMjU1XSxcbiAgZGltZ3JheTogIFsxMDUsMTA1LDEwNV0sXG4gIGRpbWdyZXk6ICBbMTA1LDEwNSwxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsMTQ0LDI1NV0sXG4gIGZpcmVicmljazogIFsxNzgsMzQsMzRdLFxuICBmbG9yYWx3aGl0ZTogIFsyNTUsMjUwLDI0MF0sXG4gIGZvcmVzdGdyZWVuOiAgWzM0LDEzOSwzNF0sXG4gIGZ1Y2hzaWE6ICBbMjU1LDAsMjU1XSxcbiAgZ2FpbnNib3JvOiAgWzIyMCwyMjAsMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwyNDgsMjU1XSxcbiAgZ29sZDogWzI1NSwyMTUsMF0sXG4gIGdvbGRlbnJvZDogIFsyMTgsMTY1LDMyXSxcbiAgZ3JheTogWzEyOCwxMjgsMTI4XSxcbiAgZ3JlZW46ICBbMCwxMjgsMF0sXG4gIGdyZWVueWVsbG93OiAgWzE3MywyNTUsNDddLFxuICBncmV5OiBbMTI4LDEyOCwxMjhdLFxuICBob25leWRldzogWzI0MCwyNTUsMjQwXSxcbiAgaG90cGluazogIFsyNTUsMTA1LDE4MF0sXG4gIGluZGlhbnJlZDogIFsyMDUsOTIsOTJdLFxuICBpbmRpZ286IFs3NSwwLDEzMF0sXG4gIGl2b3J5OiAgWzI1NSwyNTUsMjQwXSxcbiAga2hha2k6ICBbMjQwLDIzMCwxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwyMzAsMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogIFsyNTUsMjQwLDI0NV0sXG4gIGxhd25ncmVlbjogIFsxMjQsMjUyLDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsMjUwLDIwNV0sXG4gIGxpZ2h0Ymx1ZTogIFsxNzMsMjE2LDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsMTI4LDEyOF0sXG4gIGxpZ2h0Y3lhbjogIFsyMjQsMjU1LDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLDI1MCwyMTBdLFxuICBsaWdodGdyYXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LDIzOCwxNDRdLFxuICBsaWdodGdyZXk6ICBbMjExLDIxMSwyMTFdLFxuICBsaWdodHBpbms6ICBbMjU1LDE4MiwxOTNdLFxuICBsaWdodHNhbG1vbjogIFsyNTUsMTYwLDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46ICBbMzIsMTc4LDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwyMDYsMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LDEzNiwxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwxOTYsMjIyXSxcbiAgbGlnaHR5ZWxsb3c6ICBbMjU1LDI1NSwyMjRdLFxuICBsaW1lOiBbMCwyNTUsMF0sXG4gIGxpbWVncmVlbjogIFs1MCwyMDUsNTBdLFxuICBsaW5lbjogIFsyNTAsMjQwLDIzMF0sXG4gIG1hZ2VudGE6ICBbMjU1LDAsMjU1XSxcbiAgbWFyb29uOiBbMTI4LDAsMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsMjA1LDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLDAsMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LDg1LDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywxMTIsMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwxNzksMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiAgWzEyMywxMDQsMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46ICBbMCwyNTAsMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiAgWzcyLDIwOSwyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6ICBbMTk5LDIxLDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LDI1LDExMl0sXG4gIG1pbnRjcmVhbTogIFsyNDUsMjU1LDI1MF0sXG4gIG1pc3R5cm9zZTogIFsyNTUsMjI4LDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LDIyOCwxODFdLFxuICBuYXZham93aGl0ZTogIFsyNTUsMjIyLDE3M10sXG4gIG5hdnk6IFswLDAsMTI4XSxcbiAgb2xkbGFjZTogIFsyNTMsMjQ1LDIzMF0sXG4gIG9saXZlOiAgWzEyOCwxMjgsMF0sXG4gIG9saXZlZHJhYjogIFsxMDcsMTQyLDM1XSxcbiAgb3JhbmdlOiBbMjU1LDE2NSwwXSxcbiAgb3JhbmdlcmVkOiAgWzI1NSw2OSwwXSxcbiAgb3JjaGlkOiBbMjE4LDExMiwyMTRdLFxuICBwYWxlZ29sZGVucm9kOiAgWzIzOCwyMzIsMTcwXSxcbiAgcGFsZWdyZWVuOiAgWzE1MiwyNTEsMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogIFsxNzUsMjM4LDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6ICBbMjE5LDExMiwxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LDIzOSwyMTNdLFxuICBwZWFjaHB1ZmY6ICBbMjU1LDIxOCwxODVdLFxuICBwZXJ1OiBbMjA1LDEzMyw2M10sXG4gIHBpbms6IFsyNTUsMTkyLDIwM10sXG4gIHBsdW06IFsyMjEsMTYwLDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsMjI0LDIzMF0sXG4gIHB1cnBsZTogWzEyOCwwLDEyOF0sXG4gIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICByZWQ6ICBbMjU1LDAsMF0sXG4gIHJvc3licm93bjogIFsxODgsMTQzLDE0M10sXG4gIHJveWFsYmx1ZTogIFs2NSwxMDUsMjI1XSxcbiAgc2FkZGxlYnJvd246ICBbMTM5LDY5LDE5XSxcbiAgc2FsbW9uOiBbMjUwLDEyOCwxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LDE2NCw5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsMTM5LDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsMjQ1LDIzOF0sXG4gIHNpZW5uYTogWzE2MCw4Miw0NV0sXG4gIHNpbHZlcjogWzE5MiwxOTIsMTkyXSxcbiAgc2t5Ymx1ZTogIFsxMzUsMjA2LDIzNV0sXG4gIHNsYXRlYmx1ZTogIFsxMDYsOTAsMjA1XSxcbiAgc2xhdGVncmF5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc2xhdGVncmV5OiAgWzExMiwxMjgsMTQ0XSxcbiAgc25vdzogWzI1NSwyNTAsMjUwXSxcbiAgc3ByaW5nZ3JlZW46ICBbMCwyNTUsMTI3XSxcbiAgc3RlZWxibHVlOiAgWzcwLDEzMCwxODBdLFxuICB0YW46ICBbMjEwLDE4MCwxNDBdLFxuICB0ZWFsOiBbMCwxMjgsMTI4XSxcbiAgdGhpc3RsZTogIFsyMTYsMTkxLDIxNl0sXG4gIHRvbWF0bzogWzI1NSw5OSw3MV0sXG4gIHR1cnF1b2lzZTogIFs2NCwyMjQsMjA4XSxcbiAgdmlvbGV0OiBbMjM4LDEzMCwyMzhdLFxuICB3aGVhdDogIFsyNDUsMjIyLDE3OV0sXG4gIHdoaXRlOiAgWzI1NSwyNTUsMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwyNDUsMjQ1XSxcbiAgeWVsbG93OiBbMjU1LDI1NSwwXSxcbiAgeWVsbG93Z3JlZW46ICBbMTU0LDIwNSw1MF1cbn07XG5cbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAodmFyIGtleSBpbiBjc3NLZXl3b3Jkcykge1xuICByZXZlcnNlS2V5d29yZHNbSlNPTi5zdHJpbmdpZnkoY3NzS2V5d29yZHNba2V5XSldID0ga2V5O1xufVxuIiwidmFyIGNvbnZlcnNpb25zID0gcmVxdWlyZShcIi4vY29udmVyc2lvbnNcIik7XG5cbnZhciBjb252ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IENvbnZlcnRlcigpO1xufVxuXG5mb3IgKHZhciBmdW5jIGluIGNvbnZlcnNpb25zKSB7XG4gIC8vIGV4cG9ydCBSYXcgdmVyc2lvbnNcbiAgY29udmVydFtmdW5jICsgXCJSYXdcIl0gPSAgKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBhY2NlcHQgYXJyYXkgb3IgcGxhaW4gYXJnc1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICB9XG4gIH0pKGZ1bmMpO1xuXG4gIHZhciBwYWlyID0gLyhcXHcrKTIoXFx3KykvLmV4ZWMoZnVuYyksXG4gICAgICBmcm9tID0gcGFpclsxXSxcbiAgICAgIHRvID0gcGFpclsyXTtcblxuICAvLyBleHBvcnQgcmdiMmhzbCBhbmQgW1wicmdiXCJdW1wiaHNsXCJdXG4gIGNvbnZlcnRbZnJvbV0gPSBjb252ZXJ0W2Zyb21dIHx8IHt9O1xuXG4gIGNvbnZlcnRbZnJvbV1bdG9dID0gY29udmVydFtmdW5jXSA9IChmdW5jdGlvbihmdW5jKSB7IFxuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBcbiAgICAgIHZhciB2YWwgPSBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiB8fCB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHZhbDsgLy8ga2V5d29yZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgdmFsW2ldID0gTWF0aC5yb3VuZCh2YWxbaV0pO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pKGZ1bmMpO1xufVxuXG5cbi8qIENvbnZlcnRlciBkb2VzIGxhenkgY29udmVyc2lvbiBhbmQgY2FjaGluZyAqL1xudmFyIENvbnZlcnRlciA9IGZ1bmN0aW9uKCkge1xuICAgdGhpcy5jb252cyA9IHt9O1xufTtcblxuLyogRWl0aGVyIGdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlIG9yXG4gIHNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBkZXBlbmRpbmcgb24gYXJncyAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5yb3V0ZVNwYWNlID0gZnVuY3Rpb24oc3BhY2UsIGFyZ3MpIHtcbiAgIHZhciB2YWx1ZXMgPSBhcmdzWzBdO1xuICAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjb2xvci5yZ2IoKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcbiAgIH1cbiAgIC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7ICAgICAgICBcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWx1ZXMpO1xufTtcbiAgXG4vKiBTZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgaW52YWxpZGF0aW5nIGNhY2hlICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlLCB2YWx1ZXMpIHtcbiAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgIHRoaXMuY29udnMgPSB7fTtcbiAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFsdWVzO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiBHZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZS4gSWYgdGhlcmUncyBhbHJlYWR5XG4gIGEgY29udmVyc2lvbiBmb3IgdGhlIHNwYWNlLCBmZXRjaCBpdCwgb3RoZXJ3aXNlXG4gIGNvbXB1dGUgaXQgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UpIHtcbiAgIHZhciB2YWxzID0gdGhpcy5jb252c1tzcGFjZV07XG4gICBpZiAoIXZhbHMpIHtcbiAgICAgIHZhciBmc3BhY2UgPSB0aGlzLnNwYWNlLFxuICAgICAgICAgIGZyb20gPSB0aGlzLmNvbnZzW2ZzcGFjZV07XG4gICAgICB2YWxzID0gY29udmVydFtmc3BhY2VdW3NwYWNlXShmcm9tKTtcblxuICAgICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWxzO1xuICAgfVxuICByZXR1cm4gdmFscztcbn07XG5cbltcInJnYlwiLCBcImhzbFwiLCBcImhzdlwiLCBcImNteWtcIiwgXCJrZXl3b3JkXCJdLmZvckVhY2goZnVuY3Rpb24oc3BhY2UpIHtcbiAgIENvbnZlcnRlci5wcm90b3R5cGVbc3BhY2VdID0gZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMucm91dGVTcGFjZShzcGFjZSwgYXJndW1lbnRzKTtcbiAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7IiwibW9kdWxlLmV4cG9ydHM9e1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufSIsIi8qIE1JVCBsaWNlbnNlICovXG52YXIgY29sb3JOYW1lcyA9IHJlcXVpcmUoJ2NvbG9yLW5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICBnZXRSZ2JhOiBnZXRSZ2JhLFxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcbiAgIGdldFJnYjogZ2V0UmdiLFxuICAgZ2V0SHNsOiBnZXRIc2wsXG4gICBnZXRId2I6IGdldEh3YixcbiAgIGdldEFscGhhOiBnZXRBbHBoYSxcblxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXG4gICByZ2JTdHJpbmc6IHJnYlN0cmluZyxcbiAgIHJnYmFTdHJpbmc6IHJnYmFTdHJpbmcsXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxuICAgcGVyY2VudGFTdHJpbmc6IHBlcmNlbnRhU3RyaW5nLFxuICAgaHNsU3RyaW5nOiBoc2xTdHJpbmcsXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxuICAgaHdiU3RyaW5nOiBod2JTdHJpbmcsXG4gICBrZXl3b3JkOiBrZXl3b3JkXG59XG5cbmZ1bmN0aW9uIGdldFJnYmEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGFiYnIgPSAgL14jKFthLWZBLUYwLTldezN9KSQvLFxuICAgICAgIGhleCA9ICAvXiMoW2EtZkEtRjAtOV17Nn0pJC8sXG4gICAgICAgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFtcXGRcXC5dKylcXHMqKT9cXCkkLyxcbiAgICAgICBwZXIgPSAvXnJnYmE/XFwoXFxzKihbXFxkXFwuXSspXFwlXFxzKixcXHMqKFtcXGRcXC5dKylcXCVcXHMqLFxccyooW1xcZFxcLl0rKVxcJVxccyooPzosXFxzKihbXFxkXFwuXSspXFxzKik/XFwpJC8sXG4gICAgICAga2V5d29yZCA9IC8oXFxEKykvO1xuXG4gICB2YXIgcmdiID0gWzAsIDAsIDBdLFxuICAgICAgIGEgPSAxLFxuICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKGFiYnIpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGhleCkpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcbiAgICAgIGlmIChtYXRjaFsxXSA9PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICByZ2IgPSBjb2xvck5hbWVzW21hdGNoWzFdXTtcbiAgICAgIGlmICghcmdiKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICB9XG5cbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZ2JbaV0gPSBzY2FsZShyZ2JbaV0sIDAsIDI1NSk7XG4gICB9XG4gICBpZiAoIWEgJiYgYSAhPSAwKSB7XG4gICAgICBhID0gMTtcbiAgIH1cbiAgIGVsc2Uge1xuICAgICAgYSA9IHNjYWxlKGEsIDAsIDEpO1xuICAgfVxuICAgcmdiWzNdID0gYTtcbiAgIHJldHVybiByZ2I7XG59XG5cbmZ1bmN0aW9uIGdldEhzbGEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGhzbCA9IC9eaHNsYT9cXChcXHMqKFxcZCspKD86ZGVnKT9cXHMqLFxccyooW1xcZFxcLl0rKSVcXHMqLFxccyooW1xcZFxcLl0rKSVcXHMqKD86LFxccyooW1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgcyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGwgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFs0XSkgfHwgMSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHMsIGwsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRId2Ioc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGh3YiA9IC9eaHdiXFwoXFxzKihcXGQrKSg/OmRlZyk/XFxzKixcXHMqKFtcXGRcXC5dKyklXFxzKixcXHMqKFtcXGRcXC5dKyklXFxzKig/OixcXHMqKFtcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGh3Yik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHcgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBiID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbNF0pIHx8IDEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCB3LCBiLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmdiKHN0cmluZykge1xuICAgdmFyIHJnYmEgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICByZXR1cm4gcmdiYSAmJiByZ2JhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRIc2woc3RyaW5nKSB7XG4gIHZhciBoc2xhID0gZ2V0SHNsYShzdHJpbmcpO1xuICByZXR1cm4gaHNsYSAmJiBoc2xhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbHBoYShzdHJpbmcpIHtcbiAgIHZhciB2YWxzID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgaWYgKHZhbHMpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEhzbGEoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHdiKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxufVxuXG4vLyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBoZXhTdHJpbmcocmdiKSB7XG4gICByZXR1cm4gXCIjXCIgKyBoZXhEb3VibGUocmdiWzBdKSArIGhleERvdWJsZShyZ2JbMV0pXG4gICAgICAgICAgICAgICsgaGV4RG91YmxlKHJnYlsyXSk7XG59XG5cbmZ1bmN0aW9uIHJnYlN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYihcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAocmdiYVszXSAhPT0gdW5kZWZpbmVkID8gcmdiYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXVxuICAgICAgICAgICArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcbiAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSwgXCIgKyAoYWxwaGEgfHwgcmdiYVszXSB8fCAxKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKGhzbGFbM10gJiYgaHNsYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2woXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHNsYVszXSAhPT0gdW5kZWZpbmVkID8gaHNsYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsYShcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUsIFwiXG4gICAgICAgICAgICsgYWxwaGEgKyBcIilcIjtcbn1cblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmZ1bmN0aW9uIGh3YlN0cmluZyhod2IsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHdiWzNdICE9PSB1bmRlZmluZWQgPyBod2JbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImh3YihcIiArIGh3YlswXSArIFwiLCBcIiArIGh3YlsxXSArIFwiJSwgXCIgKyBod2JbMl0gKyBcIiVcIlxuICAgICAgICAgICArIChhbHBoYSAhPT0gdW5kZWZpbmVkICYmIGFscGhhICE9PSAxID8gXCIsIFwiICsgYWxwaGEgOiBcIlwiKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIHNjYWxlKG51bSwgbWluLCBtYXgpIHtcbiAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG51bSksIG1heCk7XG59XG5cbmZ1bmN0aW9uIGhleERvdWJsZShudW0pIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIChzdHIubGVuZ3RoIDwgMikgPyBcIjBcIiArIHN0ciA6IHN0cjtcbn1cblxuXG4vL2NyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWVzKSB7XG4gICByZXZlcnNlTmFtZXNbY29sb3JOYW1lc1tuYW1lXV0gPSBuYW1lO1xufSIsIi8qIE1JVCBsaWNlbnNlICovXG52YXIgY29udmVydCA9IHJlcXVpcmUoXCJjb2xvci1jb252ZXJ0XCIpLFxuICAgIHN0cmluZyA9IHJlcXVpcmUoXCJjb2xvci1zdHJpbmdcIik7XG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uKGNzc1N0cmluZykge1xuICBpZiAoY3NzU3RyaW5nIGluc3RhbmNlb2YgQ29sb3IpIHJldHVybiBjc3NTdHJpbmc7XG4gIGlmICghICh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSByZXR1cm4gbmV3IENvbG9yKGNzc1N0cmluZyk7XG5cbiAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgcmdiOiBbMCwgMCwgMF0sXG4gICAgICBoc2w6IFswLCAwLCAwXSxcbiAgICAgIGhzdjogWzAsIDAsIDBdLFxuICAgICAgaHdiOiBbMCwgMCwgMF0sXG4gICAgICBjbXlrOiBbMCwgMCwgMCwgMF0sXG4gICAgICBhbHBoYTogMVxuICAgfVxuXG4gICAvLyBwYXJzZSBDb2xvcigpIGFyZ3VtZW50XG4gICBpZiAodHlwZW9mIGNzc1N0cmluZyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgdmFscyA9IHN0cmluZy5nZXRSZ2JhKGNzc1N0cmluZyk7XG4gICAgICBpZiAodmFscykge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJyZ2JcIiwgdmFscyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHZhbHMgPSBzdHJpbmcuZ2V0SHNsYShjc3NTdHJpbmcpKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcImhzbFwiLCB2YWxzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFscyA9IHN0cmluZy5nZXRId2IoY3NzU3RyaW5nKSkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJod2JcIiwgdmFscyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gc3RyaW5nIFxcXCJcIiArIGNzc1N0cmluZyArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKHR5cGVvZiBjc3NTdHJpbmcgPT0gXCJvYmplY3RcIikge1xuICAgICAgdmFyIHZhbHMgPSBjc3NTdHJpbmc7XG4gICAgICBpZih2YWxzW1wiclwiXSAhPT0gdW5kZWZpbmVkIHx8IHZhbHNbXCJyZWRcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJyZ2JcIiwgdmFscylcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFsc1tcImxcIl0gIT09IHVuZGVmaW5lZCB8fCB2YWxzW1wibGlnaHRuZXNzXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHNsXCIsIHZhbHMpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKHZhbHNbXCJ2XCJdICE9PSB1bmRlZmluZWQgfHwgdmFsc1tcInZhbHVlXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHN2XCIsIHZhbHMpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKHZhbHNbXCJ3XCJdICE9PSB1bmRlZmluZWQgfHwgdmFsc1tcIndoaXRlbmVzc1wiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcImh3YlwiLCB2YWxzKVxuICAgICAgfVxuICAgICAgZWxzZSBpZih2YWxzW1wiY1wiXSAhPT0gdW5kZWZpbmVkIHx8IHZhbHNbXCJjeWFuXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiY215a1wiLCB2YWxzKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIG9iamVjdCBcIiArIEpTT04uc3RyaW5naWZ5KGNzc1N0cmluZykpO1xuICAgICAgfVxuICAgfVxufVxuXG5Db2xvci5wcm90b3R5cGUgPSB7XG4gICByZ2I6IGZ1bmN0aW9uICh2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTcGFjZShcInJnYlwiLCBhcmd1bWVudHMpO1xuICAgfSxcbiAgIGhzbDogZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3BhY2UoXCJoc2xcIiwgYXJndW1lbnRzKTtcbiAgIH0sXG4gICBoc3Y6IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNwYWNlKFwiaHN2XCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuICAgaHdiOiBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTcGFjZShcImh3YlwiLCBhcmd1bWVudHMpO1xuICAgfSxcbiAgIGNteWs6IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNwYWNlKFwiY215a1wiLCBhcmd1bWVudHMpO1xuICAgfSxcblxuICAgcmdiQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLnJnYjtcbiAgIH0sXG4gICBoc2xBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMuaHNsO1xuICAgfSxcbiAgIGhzdkFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5oc3Y7XG4gICB9LFxuICAgaHdiQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudmFsdWVzLmFscGhhICE9PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5od2IuY29uY2F0KFt0aGlzLnZhbHVlcy5hbHBoYV0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMuaHdiO1xuICAgfSxcbiAgIGNteWtBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMuY215aztcbiAgIH0sXG4gICByZ2JhQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcbiAgICAgIHJldHVybiByZ2IuY29uY2F0KFt0aGlzLnZhbHVlcy5hbHBoYV0pO1xuICAgfSxcbiAgIGhzbGFBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuICAgICAgcmV0dXJuIGhzbC5jb25jYXQoW3RoaXMudmFsdWVzLmFscGhhXSk7XG4gICB9LFxuICAgYWxwaGE6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMuYWxwaGE7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImFscGhhXCIsIHZhbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIHJlZDogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwicmdiXCIsIDAsIHZhbCk7XG4gICB9LFxuICAgZ3JlZW46IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcInJnYlwiLCAxLCB2YWwpO1xuICAgfSxcbiAgIGJsdWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcInJnYlwiLCAyLCB2YWwpO1xuICAgfSxcbiAgIGh1ZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwiaHNsXCIsIDAsIHZhbCk7XG4gICB9LFxuICAgc2F0dXJhdGlvbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwiaHNsXCIsIDEsIHZhbCk7XG4gICB9LFxuICAgbGlnaHRuZXNzOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc2xcIiwgMiwgdmFsKTtcbiAgIH0sXG4gICBzYXR1cmF0aW9udjogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwiaHN2XCIsIDEsIHZhbCk7XG4gICB9LFxuICAgd2hpdGVuZXNzOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJod2JcIiwgMSwgdmFsKTtcbiAgIH0sXG4gICBibGFja25lc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImh3YlwiLCAyLCB2YWwpO1xuICAgfSxcbiAgIHZhbHVlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc3ZcIiwgMiwgdmFsKTtcbiAgIH0sXG4gICBjeWFuOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJjbXlrXCIsIDAsIHZhbCk7XG4gICB9LFxuICAgbWFnZW50YTogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwiY215a1wiLCAxLCB2YWwpO1xuICAgfSxcbiAgIHllbGxvdzogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwiY215a1wiLCAyLCB2YWwpO1xuICAgfSxcbiAgIGJsYWNrOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJjbXlrXCIsIDMsIHZhbCk7XG4gICB9LFxuXG4gICBoZXhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5oZXhTdHJpbmcodGhpcy52YWx1ZXMucmdiKTtcbiAgIH0sXG4gICByZ2JTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5yZ2JTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgcmdiYVN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJnYmFTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgcGVyY2VudFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnBlcmNlbnRTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgaHNsU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcuaHNsU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuICAgfSxcbiAgIGhzbGFTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5oc2xhU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuICAgfSxcbiAgIGh3YlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmh3YlN0cmluZyh0aGlzLnZhbHVlcy5od2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICBrZXl3b3JkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcua2V5d29yZCh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG5cbiAgIHJnYk51bWJlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHRoaXMudmFsdWVzLnJnYlswXSA8PCAxNikgfCAodGhpcy52YWx1ZXMucmdiWzFdIDw8IDgpIHwgdGhpcy52YWx1ZXMucmdiWzJdO1xuICAgfSxcblxuICAgbHVtaW5vc2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI3JlbGF0aXZlbHVtaW5hbmNlZGVmXG4gICAgICB2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuICAgICAgdmFyIGx1bSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBjaGFuID0gcmdiW2ldIC8gMjU1O1xuICAgICAgICAgbHVtW2ldID0gKGNoYW4gPD0gMC4wMzkyOCkgPyBjaGFuIC8gMTIuOTJcbiAgICAgICAgICAgICAgICAgIDogTWF0aC5wb3coKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpXG4gICAgICB9XG4gICAgICByZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuICAgfSxcblxuICAgY29udHJhc3Q6IGZ1bmN0aW9uKGNvbG9yMikge1xuICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuICAgICAgdmFyIGx1bTEgPSB0aGlzLmx1bWlub3NpdHkoKTtcbiAgICAgIHZhciBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcbiAgICAgIGlmIChsdW0xID4gbHVtMikge1xuICAgICAgICAgcmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuICAgfSxcblxuICAgbGV2ZWw6IGZ1bmN0aW9uKGNvbG9yMikge1xuICAgICB2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcbiAgICAgcmV0dXJuIChjb250cmFzdFJhdGlvID49IDcuMSlcbiAgICAgICA/ICdBQUEnXG4gICAgICAgOiAoY29udHJhc3RSYXRpbyA+PSA0LjUpXG4gICAgICAgID8gJ0FBJ1xuICAgICAgICA6ICcnO1xuICAgfSxcblxuICAgZGFyazogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBZSVEgZXF1YXRpb24gZnJvbSBodHRwOi8vMjR3YXlzLm9yZy8yMDEwL2NhbGN1bGF0aW5nLWNvbG9yLWNvbnRyYXN0XG4gICAgICB2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiLFxuICAgICAgICAgIHlpcSA9IChyZ2JbMF0gKiAyOTkgKyByZ2JbMV0gKiA1ODcgKyByZ2JbMl0gKiAxMTQpIC8gMTAwMDtcbiAgIFx0cmV0dXJuIHlpcSA8IDEyODtcbiAgIH0sXG5cbiAgIGxpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5kYXJrKCk7XG4gICB9LFxuXG4gICBuZWdhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJnYiA9IFtdXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gMjU1IC0gdGhpcy52YWx1ZXMucmdiW2ldO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJyZ2JcIiwgcmdiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgbGlnaHRlbjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMudmFsdWVzLmhzbFsyXSArPSB0aGlzLnZhbHVlcy5oc2xbMl0gKiByYXRpbztcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHNsXCIsIHRoaXMudmFsdWVzLmhzbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIGRhcmtlbjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMudmFsdWVzLmhzbFsyXSAtPSB0aGlzLnZhbHVlcy5oc2xbMl0gKiByYXRpbztcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHNsXCIsIHRoaXMudmFsdWVzLmhzbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIHNhdHVyYXRlOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzFdICs9IHRoaXMudmFsdWVzLmhzbFsxXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgZGVzYXR1cmF0ZTogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMudmFsdWVzLmhzbFsxXSAtPSB0aGlzLnZhbHVlcy5oc2xbMV0gKiByYXRpbztcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHNsXCIsIHRoaXMudmFsdWVzLmhzbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIHdoaXRlbjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMudmFsdWVzLmh3YlsxXSArPSB0aGlzLnZhbHVlcy5od2JbMV0gKiByYXRpbztcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHdiXCIsIHRoaXMudmFsdWVzLmh3Yik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIGJsYWNrZW46IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICB0aGlzLnZhbHVlcy5od2JbMl0gKz0gdGhpcy52YWx1ZXMuaHdiWzJdICogcmF0aW87XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImh3YlwiLCB0aGlzLnZhbHVlcy5od2IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICBncmV5c2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG4gICAgICB2YXIgdmFsID0gcmdiWzBdICogMC4zICsgcmdiWzFdICogMC41OSArIHJnYlsyXSAqIDAuMTE7XG4gICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCBbdmFsLCB2YWwsIHZhbF0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICBjbGVhcmVyOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJhbHBoYVwiLCB0aGlzLnZhbHVlcy5hbHBoYSAtICh0aGlzLnZhbHVlcy5hbHBoYSAqIHJhdGlvKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIG9wYXF1ZXI6IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImFscGhhXCIsIHRoaXMudmFsdWVzLmFscGhhICsgKHRoaXMudmFsdWVzLmFscGhhICogcmF0aW8pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgcm90YXRlOiBmdW5jdGlvbihkZWdyZWVzKSB7XG4gICAgICB2YXIgaHVlID0gdGhpcy52YWx1ZXMuaHNsWzBdO1xuICAgICAgaHVlID0gKGh1ZSArIGRlZ3JlZXMpICUgMzYwO1xuICAgICAgaHVlID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcbiAgICAgIHRoaXMudmFsdWVzLmhzbFswXSA9IGh1ZTtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHNsXCIsIHRoaXMudmFsdWVzLmhzbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIG1peDogZnVuY3Rpb24oY29sb3IyLCB3ZWlnaHQpIHtcbiAgICAgIHdlaWdodCA9IDEgLSAod2VpZ2h0ID09IG51bGwgPyAwLjUgOiB3ZWlnaHQpO1xuXG4gICAgICAvLyBhbGdvcml0aG0gZnJvbSBTYXNzJ3MgbWl4KCkuIFJhdGlvIG9mIGZpcnN0IGNvbG9yIGluIG1peCBpc1xuICAgICAgLy8gZGV0ZXJtaW5lZCBieSB0aGUgYWxwaGFzIG9mIGJvdGggY29sb3JzIGFuZCB0aGUgd2VpZ2h0XG4gICAgICB2YXIgdDEgPSB3ZWlnaHQgKiAyIC0gMSxcbiAgICAgICAgICBkID0gdGhpcy5hbHBoYSgpIC0gY29sb3IyLmFscGhhKCk7XG5cbiAgICAgIHZhciB3ZWlnaHQxID0gKCgodDEgKiBkID09IC0xKSA/IHQxIDogKHQxICsgZCkgLyAoMSArIHQxICogZCkpICsgMSkgLyAyO1xuICAgICAgdmFyIHdlaWdodDIgPSAxIC0gd2VpZ2h0MTtcblxuICAgICAgdmFyIHJnYiA9IHRoaXMucmdiQXJyYXkoKTtcbiAgICAgIHZhciByZ2IyID0gY29sb3IyLnJnYkFycmF5KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSByZ2JbaV0gKiB3ZWlnaHQxICsgcmdiMltpXSAqIHdlaWdodDI7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCByZ2IpO1xuXG4gICAgICB2YXIgYWxwaGEgPSB0aGlzLmFscGhhKCkgKiB3ZWlnaHQgKyBjb2xvcjIuYWxwaGEoKSAqICgxIC0gd2VpZ2h0KTtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiYWxwaGFcIiwgYWxwaGEpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiB0aGlzLnJnYigpO1xuICAgfSxcblxuICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMucmdiKCkpO1xuICAgfVxufVxuXG5cbkNvbG9yLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSkge1xuICAgdmFyIHZhbHMgPSB7fTtcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHNbc3BhY2VbaV1dID0gdGhpcy52YWx1ZXNbc3BhY2VdW2ldO1xuICAgfVxuICAgaWYgKHRoaXMudmFsdWVzLmFscGhhICE9IDEpIHtcbiAgICAgIHZhbHNbXCJhXCJdID0gdGhpcy52YWx1ZXMuYWxwaGE7XG4gICB9XG4gICAvLyB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMC40fVxuICAgcmV0dXJuIHZhbHM7XG59XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSwgdmFscykge1xuICAgdmFyIHNwYWNlcyA9IHtcbiAgICAgIFwicmdiXCI6IFtcInJlZFwiLCBcImdyZWVuXCIsIFwiYmx1ZVwiXSxcbiAgICAgIFwiaHNsXCI6IFtcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJsaWdodG5lc3NcIl0sXG4gICAgICBcImhzdlwiOiBbXCJodWVcIiwgXCJzYXR1cmF0aW9uXCIsIFwidmFsdWVcIl0sXG4gICAgICBcImh3YlwiOiBbXCJodWVcIiwgXCJ3aGl0ZW5lc3NcIiwgXCJibGFja25lc3NcIl0sXG4gICAgICBcImNteWtcIjogW1wiY3lhblwiLCBcIm1hZ2VudGFcIiwgXCJ5ZWxsb3dcIiwgXCJibGFja1wiXVxuICAgfTtcblxuICAgdmFyIG1heGVzID0ge1xuICAgICAgXCJyZ2JcIjogWzI1NSwgMjU1LCAyNTVdLFxuICAgICAgXCJoc2xcIjogWzM2MCwgMTAwLCAxMDBdLFxuICAgICAgXCJoc3ZcIjogWzM2MCwgMTAwLCAxMDBdLFxuICAgICAgXCJod2JcIjogWzM2MCwgMTAwLCAxMDBdLFxuICAgICAgXCJjbXlrXCI6IFsxMDAsIDEwMCwgMTAwLCAxMDBdXG4gICB9O1xuXG4gICB2YXIgYWxwaGEgPSAxO1xuICAgaWYgKHNwYWNlID09IFwiYWxwaGFcIikge1xuICAgICAgYWxwaGEgPSB2YWxzO1xuICAgfVxuICAgZWxzZSBpZiAodmFscy5sZW5ndGgpIHtcbiAgICAgIC8vIFsxMCwgMTAsIDEwXVxuICAgICAgdGhpcy52YWx1ZXNbc3BhY2VdID0gdmFscy5zbGljZSgwLCBzcGFjZS5sZW5ndGgpO1xuICAgICAgYWxwaGEgPSB2YWxzW3NwYWNlLmxlbmd0aF07XG4gICB9XG4gICBlbHNlIGlmICh2YWxzW3NwYWNlWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB7cjogMTAsIGc6IDEwLCBiOiAxMH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tzcGFjZVtpXV07XG4gICAgICB9XG4gICAgICBhbHBoYSA9IHZhbHMuYTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHNbc3BhY2VzW3NwYWNlXVswXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8ge3JlZDogMTAsIGdyZWVuOiAxMCwgYmx1ZTogMTB9XG4gICAgICB2YXIgY2hhbnMgPSBzcGFjZXNbc3BhY2VdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW2NoYW5zW2ldXTtcbiAgICAgIH1cbiAgICAgIGFscGhhID0gdmFscy5hbHBoYTtcbiAgIH1cbiAgIHRoaXMudmFsdWVzLmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGFscGhhICE9PSB1bmRlZmluZWQgPyBhbHBoYSA6IHRoaXMudmFsdWVzLmFscGhhKSApKTtcbiAgIGlmIChzcGFjZSA9PSBcImFscGhhXCIpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgLy8gY2FwIHZhbHVlcyBvZiB0aGUgc3BhY2UgcHJpb3IgY29udmVydGluZyBhbGwgdmFsdWVzXG4gICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FwcGVkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4ZXNbc3BhY2VdW2ldLCB0aGlzLnZhbHVlc1tzcGFjZV1baV0pKTtcbiAgICAgIHRoaXMudmFsdWVzW3NwYWNlXVtpXSA9IE1hdGgucm91bmQoY2FwcGVkKTtcbiAgIH1cblxuICAgLy8gY29udmVydCB0byBhbGwgdGhlIG90aGVyIGNvbG9yIHNwYWNlc1xuICAgZm9yICh2YXIgc25hbWUgaW4gc3BhY2VzKSB7XG4gICAgICBpZiAoc25hbWUgIT0gc3BhY2UpIHtcbiAgICAgICAgIHRoaXMudmFsdWVzW3NuYW1lXSA9IGNvbnZlcnRbc3BhY2VdW3NuYW1lXSh0aGlzLnZhbHVlc1tzcGFjZV0pXG4gICAgICB9XG5cbiAgICAgIC8vIGNhcCB2YWx1ZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc25hbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBjYXBwZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhlc1tzbmFtZV1baV0sIHRoaXMudmFsdWVzW3NuYW1lXVtpXSkpO1xuICAgICAgICAgdGhpcy52YWx1ZXNbc25hbWVdW2ldID0gTWF0aC5yb3VuZChjYXBwZWQpO1xuICAgICAgfVxuICAgfVxuICAgcmV0dXJuIHRydWU7XG59XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRTcGFjZSA9IGZ1bmN0aW9uKHNwYWNlLCBhcmdzKSB7XG4gICB2YXIgdmFscyA9IGFyZ3NbMF07XG4gICBpZiAodmFscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjb2xvci5yZ2IoKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcbiAgIH1cbiAgIC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuICAgaWYgKHR5cGVvZiB2YWxzID09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgIH1cbiAgIHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWxzKTtcbiAgIHJldHVybiB0aGlzO1xufVxuXG5Db2xvci5wcm90b3R5cGUuc2V0Q2hhbm5lbCA9IGZ1bmN0aW9uKHNwYWNlLCBpbmRleCwgdmFsKSB7XG4gICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJlZCgpXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXNbc3BhY2VdW2luZGV4XTtcbiAgIH1cbiAgIC8vIGNvbG9yLnJlZCgxMDApXG4gICB0aGlzLnZhbHVlc1tzcGFjZV1baW5kZXhdID0gdmFsO1xuICAgdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHRoaXMudmFsdWVzW3NwYWNlXSk7XG4gICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcbiIsIi8qISBpU2Nyb2xsIHY1LjIuMCB+IChjKSAyMDA4LTIwMTYgTWF0dGVvIFNwaW5lbGxpIH4gaHR0cDovL2N1YmlxLm9yZy9saWNlbnNlICovXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIE1hdGgpIHtcbnZhciByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXHR8fFxuXHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHR8fFxuXHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVx0XHR8fFxuXHRmdW5jdGlvbiAoY2FsbGJhY2spIHsgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7IH07XG5cbnZhciB1dGlscyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBtZSA9IHt9O1xuXG5cdHZhciBfZWxlbWVudFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cdHZhciBfdmVuZG9yID0gKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmVuZG9ycyA9IFsndCcsICd3ZWJraXRUJywgJ01velQnLCAnbXNUJywgJ09UJ10sXG5cdFx0XHR0cmFuc2Zvcm0sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB2ZW5kb3JzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdHRyYW5zZm9ybSA9IHZlbmRvcnNbaV0gKyAncmFuc2Zvcm0nO1xuXHRcdFx0aWYgKCB0cmFuc2Zvcm0gaW4gX2VsZW1lbnRTdHlsZSApIHJldHVybiB2ZW5kb3JzW2ldLnN1YnN0cigwLCB2ZW5kb3JzW2ldLmxlbmd0aC0xKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pKCk7XG5cblx0ZnVuY3Rpb24gX3ByZWZpeFN0eWxlIChzdHlsZSkge1xuXHRcdGlmICggX3ZlbmRvciA9PT0gZmFsc2UgKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKCBfdmVuZG9yID09PSAnJyApIHJldHVybiBzdHlsZTtcblx0XHRyZXR1cm4gX3ZlbmRvciArIHN0eWxlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3R5bGUuc3Vic3RyKDEpO1xuXHR9XG5cblx0bWUuZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uIGdldFRpbWUgKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG5cblx0bWUuZXh0ZW5kID0gZnVuY3Rpb24gKHRhcmdldCwgb2JqKSB7XG5cdFx0Zm9yICggdmFyIGkgaW4gb2JqICkge1xuXHRcdFx0dGFyZ2V0W2ldID0gb2JqW2ldO1xuXHRcdH1cblx0fTtcblxuXHRtZS5hZGRFdmVudCA9IGZ1bmN0aW9uIChlbCwgdHlwZSwgZm4sIGNhcHR1cmUpIHtcblx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCAhIWNhcHR1cmUpO1xuXHR9O1xuXG5cdG1lLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuXHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sICEhY2FwdHVyZSk7XG5cdH07XG5cblx0bWUucHJlZml4UG9pbnRlckV2ZW50ID0gZnVuY3Rpb24gKHBvaW50ZXJFdmVudCkge1xuXHRcdHJldHVybiB3aW5kb3cuTVNQb2ludGVyRXZlbnQgP1xuXHRcdFx0J01TUG9pbnRlcicgKyBwb2ludGVyRXZlbnQuY2hhckF0KDcpLnRvVXBwZXJDYXNlKCkgKyBwb2ludGVyRXZlbnQuc3Vic3RyKDgpOlxuXHRcdFx0cG9pbnRlckV2ZW50O1xuXHR9O1xuXG5cdG1lLm1vbWVudHVtID0gZnVuY3Rpb24gKGN1cnJlbnQsIHN0YXJ0LCB0aW1lLCBsb3dlck1hcmdpbiwgd3JhcHBlclNpemUsIGRlY2VsZXJhdGlvbikge1xuXHRcdHZhciBkaXN0YW5jZSA9IGN1cnJlbnQgLSBzdGFydCxcblx0XHRcdHNwZWVkID0gTWF0aC5hYnMoZGlzdGFuY2UpIC8gdGltZSxcblx0XHRcdGRlc3RpbmF0aW9uLFxuXHRcdFx0ZHVyYXRpb247XG5cblx0XHRkZWNlbGVyYXRpb24gPSBkZWNlbGVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDAuMDAwNiA6IGRlY2VsZXJhdGlvbjtcblxuXHRcdGRlc3RpbmF0aW9uID0gY3VycmVudCArICggc3BlZWQgKiBzcGVlZCApIC8gKCAyICogZGVjZWxlcmF0aW9uICkgKiAoIGRpc3RhbmNlIDwgMCA/IC0xIDogMSApO1xuXHRcdGR1cmF0aW9uID0gc3BlZWQgLyBkZWNlbGVyYXRpb247XG5cblx0XHRpZiAoIGRlc3RpbmF0aW9uIDwgbG93ZXJNYXJnaW4gKSB7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IHdyYXBwZXJTaXplID8gbG93ZXJNYXJnaW4gLSAoIHdyYXBwZXJTaXplIC8gMi41ICogKCBzcGVlZCAvIDggKSApIDogbG93ZXJNYXJnaW47XG5cdFx0XHRkaXN0YW5jZSA9IE1hdGguYWJzKGRlc3RpbmF0aW9uIC0gY3VycmVudCk7XG5cdFx0XHRkdXJhdGlvbiA9IGRpc3RhbmNlIC8gc3BlZWQ7XG5cdFx0fSBlbHNlIGlmICggZGVzdGluYXRpb24gPiAwICkge1xuXHRcdFx0ZGVzdGluYXRpb24gPSB3cmFwcGVyU2l6ZSA/IHdyYXBwZXJTaXplIC8gMi41ICogKCBzcGVlZCAvIDggKSA6IDA7XG5cdFx0XHRkaXN0YW5jZSA9IE1hdGguYWJzKGN1cnJlbnQpICsgZGVzdGluYXRpb247XG5cdFx0XHRkdXJhdGlvbiA9IGRpc3RhbmNlIC8gc3BlZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlc3RpbmF0aW9uOiBNYXRoLnJvdW5kKGRlc3RpbmF0aW9uKSxcblx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvblxuXHRcdH07XG5cdH07XG5cblx0dmFyIF90cmFuc2Zvcm0gPSBfcHJlZml4U3R5bGUoJ3RyYW5zZm9ybScpO1xuXG5cdG1lLmV4dGVuZChtZSwge1xuXHRcdGhhc1RyYW5zZm9ybTogX3RyYW5zZm9ybSAhPT0gZmFsc2UsXG5cdFx0aGFzUGVyc3BlY3RpdmU6IF9wcmVmaXhTdHlsZSgncGVyc3BlY3RpdmUnKSBpbiBfZWxlbWVudFN0eWxlLFxuXHRcdGhhc1RvdWNoOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3csXG5cdFx0aGFzUG9pbnRlcjogISEod2luZG93LlBvaW50ZXJFdmVudCB8fCB3aW5kb3cuTVNQb2ludGVyRXZlbnQpLCAvLyBJRTEwIGlzIHByZWZpeGVkXG5cdFx0aGFzVHJhbnNpdGlvbjogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uJykgaW4gX2VsZW1lbnRTdHlsZVxuXHR9KTtcblxuXHQvKlxuXHRUaGlzIHNob3VsZCBmaW5kIGFsbCBBbmRyb2lkIGJyb3dzZXJzIGxvd2VyIHRoYW4gYnVpbGQgNTM1LjE5IChib3RoIHN0b2NrIGJyb3dzZXIgYW5kIHdlYnZpZXcpXG5cdC0gZ2FsYXh5IFMyIGlzIG9rXG4gICAgLSAyLjMuNiA6IGBBcHBsZVdlYktpdC81MzMuMSAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTMzLjFgXG4gICAgLSA0LjAuNCA6IGBBcHBsZVdlYktpdC81MzQuMzAgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBNb2JpbGUgU2FmYXJpLzUzNC4zMGBcbiAgIC0gZ2FsYXh5IFMzIGlzIGJhZEFuZHJvaWQgKHN0b2NrIGJyb3dlciwgd2VidmlldylcbiAgICAgYEFwcGxlV2ViS2l0LzUzNC4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM0LjMwYFxuICAgLSBnYWxheHkgUzQgaXMgYmFkQW5kcm9pZCAoc3RvY2sgYnJvd2VyLCB3ZWJ2aWV3KVxuICAgICBgQXBwbGVXZWJLaXQvNTM0LjMwIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzQuMzBgXG4gICAtIGdhbGF4eSBTNSBpcyBPS1xuICAgICBgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYgKENocm9tZS8pYFxuICAgLSBnYWxheHkgUzYgaXMgT0tcbiAgICAgYEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IChDaHJvbWUvKWBcbiAgKi9cblx0bWUuaXNCYWRBbmRyb2lkID0gKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcHBWZXJzaW9uID0gd2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uO1xuXHRcdC8vIEFuZHJvaWQgYnJvd3NlciBpcyBub3QgYSBjaHJvbWUgYnJvd3Nlci5cblx0XHRpZiAoL0FuZHJvaWQvLnRlc3QoYXBwVmVyc2lvbikgJiYgISgvQ2hyb21lXFwvXFxkLy50ZXN0KGFwcFZlcnNpb24pKSkge1xuXHRcdFx0dmFyIHNhZmFyaVZlcnNpb24gPSBhcHBWZXJzaW9uLm1hdGNoKC9TYWZhcmlcXC8oXFxkKy5cXGQpLyk7XG5cdFx0XHRpZihzYWZhcmlWZXJzaW9uICYmIHR5cGVvZiBzYWZhcmlWZXJzaW9uID09PSBcIm9iamVjdFwiICYmIHNhZmFyaVZlcnNpb24ubGVuZ3RoID49IDIpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQoc2FmYXJpVmVyc2lvblsxXSkgPCA1MzUuMTk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSkoKTtcblxuXHRtZS5leHRlbmQobWUuc3R5bGUgPSB7fSwge1xuXHRcdHRyYW5zZm9ybTogX3RyYW5zZm9ybSxcblx0XHR0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJyksXG5cdFx0dHJhbnNpdGlvbkR1cmF0aW9uOiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25EdXJhdGlvbicpLFxuXHRcdHRyYW5zaXRpb25EZWxheTogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uRGVsYXknKSxcblx0XHR0cmFuc2Zvcm1PcmlnaW46IF9wcmVmaXhTdHlsZSgndHJhbnNmb3JtT3JpZ2luJylcblx0fSk7XG5cblx0bWUuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGMgKyBcIihcXFxcc3wkKVwiKTtcblx0XHRyZXR1cm4gcmUudGVzdChlLmNsYXNzTmFtZSk7XG5cdH07XG5cblx0bWUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdGlmICggbWUuaGFzQ2xhc3MoZSwgYykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG5ld2NsYXNzID0gZS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcblx0XHRuZXdjbGFzcy5wdXNoKGMpO1xuXHRcdGUuY2xhc3NOYW1lID0gbmV3Y2xhc3Muam9pbignICcpO1xuXHR9O1xuXG5cdG1lLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGUsIGMpIHtcblx0XHRpZiAoICFtZS5oYXNDbGFzcyhlLCBjKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjICsgXCIoXFxcXHN8JClcIiwgJ2cnKTtcblx0XHRlLmNsYXNzTmFtZSA9IGUuY2xhc3NOYW1lLnJlcGxhY2UocmUsICcgJyk7XG5cdH07XG5cblx0bWUub2Zmc2V0ID0gZnVuY3Rpb24gKGVsKSB7XG5cdFx0dmFyIGxlZnQgPSAtZWwub2Zmc2V0TGVmdCxcblx0XHRcdHRvcCA9IC1lbC5vZmZzZXRUb3A7XG5cblx0XHQvLyBqc2hpbnQgLVcwODRcblx0XHR3aGlsZSAoZWwgPSBlbC5vZmZzZXRQYXJlbnQpIHtcblx0XHRcdGxlZnQgLT0gZWwub2Zmc2V0TGVmdDtcblx0XHRcdHRvcCAtPSBlbC5vZmZzZXRUb3A7XG5cdFx0fVxuXHRcdC8vIGpzaGludCArVzA4NFxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IGxlZnQsXG5cdFx0XHR0b3A6IHRvcFxuXHRcdH07XG5cdH07XG5cblx0bWUucHJldmVudERlZmF1bHRFeGNlcHRpb24gPSBmdW5jdGlvbiAoZWwsIGV4Y2VwdGlvbnMpIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBleGNlcHRpb25zICkge1xuXHRcdFx0aWYgKCBleGNlcHRpb25zW2ldLnRlc3QoZWxbaV0pICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0bWUuZXh0ZW5kKG1lLmV2ZW50VHlwZSA9IHt9LCB7XG5cdFx0dG91Y2hzdGFydDogMSxcblx0XHR0b3VjaG1vdmU6IDEsXG5cdFx0dG91Y2hlbmQ6IDEsXG5cblx0XHRtb3VzZWRvd246IDIsXG5cdFx0bW91c2Vtb3ZlOiAyLFxuXHRcdG1vdXNldXA6IDIsXG5cblx0XHRwb2ludGVyZG93bjogMyxcblx0XHRwb2ludGVybW92ZTogMyxcblx0XHRwb2ludGVydXA6IDMsXG5cblx0XHRNU1BvaW50ZXJEb3duOiAzLFxuXHRcdE1TUG9pbnRlck1vdmU6IDMsXG5cdFx0TVNQb2ludGVyVXA6IDNcblx0fSk7XG5cblx0bWUuZXh0ZW5kKG1lLmVhc2UgPSB7fSwge1xuXHRcdHF1YWRyYXRpYzoge1xuXHRcdFx0c3R5bGU6ICdjdWJpYy1iZXppZXIoMC4yNSwgMC40NiwgMC40NSwgMC45NCknLFxuXHRcdFx0Zm46IGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRcdHJldHVybiBrICogKCAyIC0gayApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y2lyY3VsYXI6IHtcblx0XHRcdHN0eWxlOiAnY3ViaWMtYmV6aWVyKDAuMSwgMC41NywgMC4xLCAxKScsXHQvLyBOb3QgcHJvcGVybHkgXCJjaXJjdWxhclwiIGJ1dCB0aGlzIGxvb2tzIGJldHRlciwgaXQgc2hvdWxkIGJlICgwLjA3NSwgMC44MiwgMC4xNjUsIDEpXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydCggMSAtICggLS1rICogayApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRiYWNrOiB7XG5cdFx0XHRzdHlsZTogJ2N1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIsIDEuMjc1KScsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0dmFyIGIgPSA0O1xuXHRcdFx0XHRyZXR1cm4gKCBrID0gayAtIDEgKSAqIGsgKiAoICggYiArIDEgKSAqIGsgKyBiICkgKyAxO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Ym91bmNlOiB7XG5cdFx0XHRzdHlsZTogJycsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0aWYgKCAoIGsgLz0gMSApIDwgKCAxIC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiBrICogaztcblx0XHRcdFx0fSBlbHNlIGlmICggayA8ICggMiAvIDIuNzUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMS41IC8gMi43NSApICkgKiBrICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmICggayA8ICggMi41IC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjI1IC8gMi43NSApICkgKiBrICsgMC45Mzc1O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjYyNSAvIDIuNzUgKSApICogayArIDAuOTg0Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbGFzdGljOiB7XG5cdFx0XHRzdHlsZTogJycsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0dmFyIGYgPSAwLjIyLFxuXHRcdFx0XHRcdGUgPSAwLjQ7XG5cblx0XHRcdFx0aWYgKCBrID09PSAwICkgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHRpZiAoIGsgPT0gMSApIHsgcmV0dXJuIDE7IH1cblxuXHRcdFx0XHRyZXR1cm4gKCBlICogTWF0aC5wb3coIDIsIC0gMTAgKiBrICkgKiBNYXRoLnNpbiggKCBrIC0gZiAvIDQgKSAqICggMiAqIE1hdGguUEkgKSAvIGYgKSArIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdG1lLnRhcCA9IGZ1bmN0aW9uIChlLCBldmVudE5hbWUpIHtcblx0XHR2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblx0XHRldi5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKTtcblx0XHRldi5wYWdlWCA9IGUucGFnZVg7XG5cdFx0ZXYucGFnZVkgPSBlLnBhZ2VZO1xuXHRcdGUudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuXHR9O1xuXG5cdG1lLmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQsXG5cdFx0XHRldjtcblxuXHRcdGlmICggISgvKFNFTEVDVHxJTlBVVHxURVhUQVJFQSkvaSkudGVzdCh0YXJnZXQudGFnTmFtZSkgKSB7XG5cdFx0XHRldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdFx0ZXYuaW5pdE1vdXNlRXZlbnQoJ2NsaWNrJywgdHJ1ZSwgdHJ1ZSwgZS52aWV3LCAxLFxuXHRcdFx0XHR0YXJnZXQuc2NyZWVuWCwgdGFyZ2V0LnNjcmVlblksIHRhcmdldC5jbGllbnRYLCB0YXJnZXQuY2xpZW50WSxcblx0XHRcdFx0ZS5jdHJsS2V5LCBlLmFsdEtleSwgZS5zaGlmdEtleSwgZS5tZXRhS2V5LFxuXHRcdFx0XHQwLCBudWxsKTtcblxuXHRcdFx0ZXYuX2NvbnN0cnVjdGVkID0gdHJ1ZTtcblx0XHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG1lO1xufSkoKTtcbmZ1bmN0aW9uIElTY3JvbGwgKGVsLCBvcHRpb25zKSB7XG5cdHRoaXMud3JhcHBlciA9IHR5cGVvZiBlbCA9PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpIDogZWw7XG5cdHRoaXMuc2Nyb2xsZXIgPSB0aGlzLndyYXBwZXIuY2hpbGRyZW5bMF07XG5cdHRoaXMuc2Nyb2xsZXJTdHlsZSA9IHRoaXMuc2Nyb2xsZXIuc3R5bGU7XHRcdC8vIGNhY2hlIHN0eWxlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcblxuXHR0aGlzLm9wdGlvbnMgPSB7XG5cblx0XHRyZXNpemVTY3JvbGxiYXJzOiB0cnVlLFxuXG5cdFx0bW91c2VXaGVlbFNwZWVkOiAyMCxcblxuXHRcdHNuYXBUaHJlc2hvbGQ6IDAuMzM0LFxuXG4vLyBJTlNFUlQgUE9JTlQ6IE9QVElPTlNcblx0XHRkaXNhYmxlUG9pbnRlciA6ICF1dGlscy5oYXNQb2ludGVyLFxuXHRcdGRpc2FibGVUb3VjaCA6IHV0aWxzLmhhc1BvaW50ZXIgfHwgIXV0aWxzLmhhc1RvdWNoLFxuXHRcdGRpc2FibGVNb3VzZSA6IHV0aWxzLmhhc1BvaW50ZXIgfHwgdXRpbHMuaGFzVG91Y2gsXG5cdFx0c3RhcnRYOiAwLFxuXHRcdHN0YXJ0WTogMCxcblx0XHRzY3JvbGxZOiB0cnVlLFxuXHRcdGRpcmVjdGlvbkxvY2tUaHJlc2hvbGQ6IDUsXG5cdFx0bW9tZW50dW06IHRydWUsXG5cblx0XHRib3VuY2U6IHRydWUsXG5cdFx0Ym91bmNlVGltZTogNjAwLFxuXHRcdGJvdW5jZUVhc2luZzogJycsXG5cblx0XHRwcmV2ZW50RGVmYXVsdDogdHJ1ZSxcblx0XHRwcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbjogeyB0YWdOYW1lOiAvXihJTlBVVHxURVhUQVJFQXxCVVRUT058U0VMRUNUKSQvIH0sXG5cblx0XHRIV0NvbXBvc2l0aW5nOiB0cnVlLFxuXHRcdHVzZVRyYW5zaXRpb246IHRydWUsXG5cdFx0dXNlVHJhbnNmb3JtOiB0cnVlLFxuXHRcdGJpbmRUb1dyYXBwZXI6IHR5cGVvZiB3aW5kb3cub25tb3VzZWRvd24gPT09IFwidW5kZWZpbmVkXCJcblx0fTtcblxuXHRmb3IgKCB2YXIgaSBpbiBvcHRpb25zICkge1xuXHRcdHRoaXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0aW9uc1xuXHR0aGlzLnRyYW5zbGF0ZVogPSB0aGlzLm9wdGlvbnMuSFdDb21wb3NpdGluZyAmJiB1dGlscy5oYXNQZXJzcGVjdGl2ZSA/ICcgdHJhbnNsYXRlWigwKScgOiAnJztcblxuXHR0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiA9IHV0aWxzLmhhc1RyYW5zaXRpb24gJiYgdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb247XG5cdHRoaXMub3B0aW9ucy51c2VUcmFuc2Zvcm0gPSB1dGlscy5oYXNUcmFuc2Zvcm0gJiYgdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybTtcblxuXHR0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09PSB0cnVlID8gJ3ZlcnRpY2FsJyA6IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoO1xuXHR0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgPSAhdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggJiYgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0O1xuXG5cdC8vIElmIHlvdSB3YW50IGV2ZW50UGFzc3Rocm91Z2ggSSBoYXZlIHRvIGxvY2sgb25lIG9mIHRoZSBheGVzXG5cdHRoaXMub3B0aW9ucy5zY3JvbGxZID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ3ZlcnRpY2FsJyA/IGZhbHNlIDogdGhpcy5vcHRpb25zLnNjcm9sbFk7XG5cdHRoaXMub3B0aW9ucy5zY3JvbGxYID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ2hvcml6b250YWwnID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2Nyb2xsWDtcblxuXHQvLyBXaXRoIGV2ZW50UGFzc3Rocm91Z2ggd2UgYWxzbyBuZWVkIGxvY2tEaXJlY3Rpb24gbWVjaGFuaXNtXG5cdHRoaXMub3B0aW9ucy5mcmVlU2Nyb2xsID0gdGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgJiYgIXRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoO1xuXHR0aGlzLm9wdGlvbnMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID8gMCA6IHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkO1xuXG5cdHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmcgPSB0eXBlb2YgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyA9PSAnc3RyaW5nJyA/IHV0aWxzLmVhc2VbdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZ10gfHwgdXRpbHMuZWFzZS5jaXJjdWxhciA6IHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmc7XG5cblx0dGhpcy5vcHRpb25zLnJlc2l6ZVBvbGxpbmcgPSB0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyA9PT0gdW5kZWZpbmVkID8gNjAgOiB0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZztcblxuXHRpZiAoIHRoaXMub3B0aW9ucy50YXAgPT09IHRydWUgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnRhcCA9ICd0YXAnO1xuXHR9XG5cblx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rU2Nyb2xsYmFycyA9PSAnc2NhbGUnICkge1xuXHRcdHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uID0gZmFsc2U7XG5cdH1cblxuXHR0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb24gPyAtMSA6IDE7XG5cbi8vIElOU0VSVCBQT0lOVDogTk9STUFMSVpBVElPTlxuXG5cdC8vIFNvbWUgZGVmYXVsdHNcblx0dGhpcy54ID0gMDtcblx0dGhpcy55ID0gMDtcblx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0dGhpcy5fZXZlbnRzID0ge307XG5cbi8vIElOU0VSVCBQT0lOVDogREVGQVVMVFNcblxuXHR0aGlzLl9pbml0KCk7XG5cdHRoaXMucmVmcmVzaCgpO1xuXG5cdHRoaXMuc2Nyb2xsVG8odGhpcy5vcHRpb25zLnN0YXJ0WCwgdGhpcy5vcHRpb25zLnN0YXJ0WSk7XG5cdHRoaXMuZW5hYmxlKCk7XG59XG5cbklTY3JvbGwucHJvdG90eXBlID0ge1xuXHR2ZXJzaW9uOiAnNS4yLjAnLFxuXG5cdF9pbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faW5pdEV2ZW50cygpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyB8fCB0aGlzLm9wdGlvbnMuaW5kaWNhdG9ycyApIHtcblx0XHRcdHRoaXMuX2luaXRJbmRpY2F0b3JzKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubW91c2VXaGVlbCApIHtcblx0XHRcdHRoaXMuX2luaXRXaGVlbCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnNuYXAgKSB7XG5cdFx0XHR0aGlzLl9pbml0U25hcCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzICkge1xuXHRcdFx0dGhpcy5faW5pdEtleXMoKTtcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX2luaXRcblxuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0RXZlbnRzKHRydWUpO1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuIFx0XHR0aGlzLnJlc2l6ZVRpbWVvdXQgPSBudWxsO1xuXHRcdHRoaXMuX2V4ZWNFdmVudCgnZGVzdHJveScpO1xuXHR9LFxuXG5cdF90cmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggZS50YXJnZXQgIT0gdGhpcy5zY3JvbGxlciB8fCAhdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSgpO1xuXHRcdGlmICggIXRoaXMucmVzZXRQb3NpdGlvbih0aGlzLm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblx0fSxcblxuXHRfc3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gUmVhY3QgdG8gbGVmdCBtb3VzZSBidXR0b24gb25seVxuXHRcdGlmICggdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT0gMSApIHtcblx0XHQgIC8vIGZvciBidXR0b24gcHJvcGVydHlcblx0XHQgIC8vIGh0dHA6Ly91bml4cGFwYS5jb20vanMvbW91c2UuaHRtbFxuXHRcdCAgdmFyIGJ1dHRvbjtcblx0ICAgIGlmICghZS53aGljaCkge1xuXHQgICAgICAvKiBJRSBjYXNlICovXG5cdCAgICAgIGJ1dHRvbiA9IChlLmJ1dHRvbiA8IDIpID8gMCA6XG5cdCAgICAgICAgICAgICAgICgoZS5idXR0b24gPT0gNCkgPyAxIDogMik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvKiBBbGwgb3RoZXJzICovXG5cdCAgICAgIGJ1dHRvbiA9IGUuYnV0dG9uO1xuXHQgICAgfVxuXHRcdFx0aWYgKCBidXR0b24gIT09IDAgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgKHRoaXMuaW5pdGlhdGVkICYmIHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdICE9PSB0aGlzLmluaXRpYXRlZCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgJiYgIXV0aWxzLmlzQmFkQW5kcm9pZCAmJiAhdXRpbHMucHJldmVudERlZmF1bHRFeGNlcHRpb24oZS50YXJnZXQsIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbikgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvaW50ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcblx0XHRcdHBvcztcblxuXHRcdHRoaXMuaW5pdGlhdGVkXHQ9IHV0aWxzLmV2ZW50VHlwZVtlLnR5cGVdO1xuXHRcdHRoaXMubW92ZWRcdFx0PSBmYWxzZTtcblx0XHR0aGlzLmRpc3RYXHRcdD0gMDtcblx0XHR0aGlzLmRpc3RZXHRcdD0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWSA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAwO1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRoaXMuaXNJblRyYW5zaXRpb24gKSB7XG5cdFx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSgpO1xuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IGZhbHNlO1xuXHRcdFx0cG9zID0gdGhpcy5nZXRDb21wdXRlZFBvc2l0aW9uKCk7XG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoTWF0aC5yb3VuZChwb3MueCksIE1hdGgucm91bmQocG9zLnkpKTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fSBlbHNlIGlmICggIXRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRoaXMuaXNBbmltYXRpbmcgKSB7XG5cdFx0XHR0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RhcnRYICAgID0gdGhpcy54O1xuXHRcdHRoaXMuc3RhcnRZICAgID0gdGhpcy55O1xuXHRcdHRoaXMuYWJzU3RhcnRYID0gdGhpcy54O1xuXHRcdHRoaXMuYWJzU3RhcnRZID0gdGhpcy55O1xuXHRcdHRoaXMucG9pbnRYICAgID0gcG9pbnQucGFnZVg7XG5cdFx0dGhpcy5wb2ludFkgICAgPSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuX2V4ZWNFdmVudCgnYmVmb3JlU2Nyb2xsU3RhcnQnKTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ICkge1x0Ly8gaW5jcmVhc2VzIHBlcmZvcm1hbmNlIG9uIEFuZHJvaWQ/IFRPRE86IGNoZWNrIVxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHZhciBwb2ludFx0XHQ9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG5cdFx0XHRkZWx0YVhcdFx0PSBwb2ludC5wYWdlWCAtIHRoaXMucG9pbnRYLFxuXHRcdFx0ZGVsdGFZXHRcdD0gcG9pbnQucGFnZVkgLSB0aGlzLnBvaW50WSxcblx0XHRcdHRpbWVzdGFtcFx0PSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0YWJzRGlzdFgsIGFic0Rpc3RZO1xuXG5cdFx0dGhpcy5wb2ludFhcdFx0PSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLnBvaW50WVx0XHQ9IHBvaW50LnBhZ2VZO1xuXG5cdFx0dGhpcy5kaXN0WFx0XHQrPSBkZWx0YVg7XG5cdFx0dGhpcy5kaXN0WVx0XHQrPSBkZWx0YVk7XG5cdFx0YWJzRGlzdFhcdFx0PSBNYXRoLmFicyh0aGlzLmRpc3RYKTtcblx0XHRhYnNEaXN0WVx0XHQ9IE1hdGguYWJzKHRoaXMuZGlzdFkpO1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBtb3ZlIGF0IGxlYXN0IDEwIHBpeGVscyBmb3IgdGhlIHNjcm9sbGluZyB0byBpbml0aWF0ZVxuXHRcdGlmICggdGltZXN0YW1wIC0gdGhpcy5lbmRUaW1lID4gMzAwICYmIChhYnNEaXN0WCA8IDEwICYmIGFic0Rpc3RZIDwgMTApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHlvdSBhcmUgc2Nyb2xsaW5nIGluIG9uZSBkaXJlY3Rpb24gbG9jayB0aGUgb3RoZXJcblx0XHRpZiAoICF0aGlzLmRpcmVjdGlvbkxvY2tlZCAmJiAhdGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgKSB7XG5cdFx0XHRpZiAoIGFic0Rpc3RYID4gYWJzRGlzdFkgKyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZCApIHtcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25Mb2NrZWQgPSAnaCc7XHRcdC8vIGxvY2sgaG9yaXpvbnRhbGx5XG5cdFx0XHR9IGVsc2UgaWYgKCBhYnNEaXN0WSA+PSBhYnNEaXN0WCArIHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkICkge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICd2JztcdFx0Ly8gbG9jayB2ZXJ0aWNhbGx5XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICduJztcdFx0Ly8gbm8gbG9ja1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5kaXJlY3Rpb25Mb2NrZWQgPT0gJ2gnICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgKSB7XG5cdFx0XHRcdHRoaXMuaW5pdGlhdGVkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGFZID0gMDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmRpcmVjdGlvbkxvY2tlZCA9PSAndicgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICdob3Jpem9udGFsJyApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ3ZlcnRpY2FsJyApIHtcblx0XHRcdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YVggPSAwO1xuXHRcdH1cblxuXHRcdGRlbHRhWCA9IHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IGRlbHRhWCA6IDA7XG5cdFx0ZGVsdGFZID0gdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCA/IGRlbHRhWSA6IDA7XG5cblx0XHRuZXdYID0gdGhpcy54ICsgZGVsdGFYO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBkZWx0YVk7XG5cblx0XHQvLyBTbG93IGRvd24gaWYgb3V0c2lkZSBvZiB0aGUgYm91bmRhcmllc1xuXHRcdGlmICggbmV3WCA+IDAgfHwgbmV3WCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdG5ld1ggPSB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy54ICsgZGVsdGFYIC8gMyA6IG5ld1ggPiAwID8gMCA6IHRoaXMubWF4U2Nyb2xsWDtcblx0XHR9XG5cdFx0aWYgKCBuZXdZID4gMCB8fCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLnkgKyBkZWx0YVkgLyAzIDogbmV3WSA+IDAgPyAwIDogdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IGRlbHRhWCA+IDAgPyAtMSA6IGRlbHRhWCA8IDAgPyAxIDogMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSBkZWx0YVkgPiAwID8gLTEgOiBkZWx0YVkgPCAwID8gMSA6IDA7XG5cblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxTdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubW92ZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy5fdHJhbnNsYXRlKG5ld1gsIG5ld1kpO1xuXG4vKiBSRVBMQUNFIFNUQVJUOiBfbW92ZSAqL1xuXG5cdFx0aWYgKCB0aW1lc3RhbXAgLSB0aGlzLnN0YXJ0VGltZSA+IDMwMCApIHtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gdGltZXN0YW1wO1xuXHRcdFx0dGhpcy5zdGFydFggPSB0aGlzLng7XG5cdFx0XHR0aGlzLnN0YXJ0WSA9IHRoaXMueTtcblx0XHR9XG5cbi8qIFJFUExBQ0UgRU5EOiBfbW92ZSAqL1xuXG5cdH0sXG5cblx0X2VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgfHwgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0ICYmICF1dGlscy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbihlLnRhcmdldCwgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnQgPSBlLmNoYW5nZWRUb3VjaGVzID8gZS5jaGFuZ2VkVG91Y2hlc1swXSA6IGUsXG5cdFx0XHRtb21lbnR1bVgsXG5cdFx0XHRtb21lbnR1bVksXG5cdFx0XHRkdXJhdGlvbiA9IHV0aWxzLmdldFRpbWUoKSAtIHRoaXMuc3RhcnRUaW1lLFxuXHRcdFx0bmV3WCA9IE1hdGgucm91bmQodGhpcy54KSxcblx0XHRcdG5ld1kgPSBNYXRoLnJvdW5kKHRoaXMueSksXG5cdFx0XHRkaXN0YW5jZVggPSBNYXRoLmFicyhuZXdYIC0gdGhpcy5zdGFydFgpLFxuXHRcdFx0ZGlzdGFuY2VZID0gTWF0aC5hYnMobmV3WSAtIHRoaXMuc3RhcnRZKSxcblx0XHRcdHRpbWUgPSAwLFxuXHRcdFx0ZWFzaW5nID0gJyc7XG5cblx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gMDtcblx0XHR0aGlzLmluaXRpYXRlZCA9IDA7XG5cdFx0dGhpcy5lbmRUaW1lID0gdXRpbHMuZ2V0VGltZSgpO1xuXG5cdFx0Ly8gcmVzZXQgaWYgd2UgYXJlIG91dHNpZGUgb2YgdGhlIGJvdW5kYXJpZXNcblx0XHRpZiAoIHRoaXMucmVzZXRQb3NpdGlvbih0aGlzLm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxUbyhuZXdYLCBuZXdZKTtcdC8vIGVuc3VyZXMgdGhhdCB0aGUgbGFzdCBwb3NpdGlvbiBpcyByb3VuZGVkXG5cblx0XHQvLyB3ZSBzY3JvbGxlZCBsZXNzIHRoYW4gMTAgcGl4ZWxzXG5cdFx0aWYgKCAhdGhpcy5tb3ZlZCApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnRhcCApIHtcblx0XHRcdFx0dXRpbHMudGFwKGUsIHRoaXMub3B0aW9ucy50YXApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5jbGljayApIHtcblx0XHRcdFx0dXRpbHMuY2xpY2soZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsQ2FuY2VsJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9ldmVudHMuZmxpY2sgJiYgZHVyYXRpb24gPCAyMDAgJiYgZGlzdGFuY2VYIDwgMTAwICYmIGRpc3RhbmNlWSA8IDEwMCApIHtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnZmxpY2snKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBzdGFydCBtb21lbnR1bSBhbmltYXRpb24gaWYgbmVlZGVkXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubW9tZW50dW0gJiYgZHVyYXRpb24gPCAzMDAgKSB7XG5cdFx0XHRtb21lbnR1bVggPSB0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgPyB1dGlscy5tb21lbnR1bSh0aGlzLngsIHRoaXMuc3RhcnRYLCBkdXJhdGlvbiwgdGhpcy5tYXhTY3JvbGxYLCB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy53cmFwcGVyV2lkdGggOiAwLCB0aGlzLm9wdGlvbnMuZGVjZWxlcmF0aW9uKSA6IHsgZGVzdGluYXRpb246IG5ld1gsIGR1cmF0aW9uOiAwIH07XG5cdFx0XHRtb21lbnR1bVkgPSB0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsID8gdXRpbHMubW9tZW50dW0odGhpcy55LCB0aGlzLnN0YXJ0WSwgZHVyYXRpb24sIHRoaXMubWF4U2Nyb2xsWSwgdGhpcy5vcHRpb25zLmJvdW5jZSA/IHRoaXMud3JhcHBlckhlaWdodCA6IDAsIHRoaXMub3B0aW9ucy5kZWNlbGVyYXRpb24pIDogeyBkZXN0aW5hdGlvbjogbmV3WSwgZHVyYXRpb246IDAgfTtcblx0XHRcdG5ld1ggPSBtb21lbnR1bVguZGVzdGluYXRpb247XG5cdFx0XHRuZXdZID0gbW9tZW50dW1ZLmRlc3RpbmF0aW9uO1xuXHRcdFx0dGltZSA9IE1hdGgubWF4KG1vbWVudHVtWC5kdXJhdGlvbiwgbW9tZW50dW1ZLmR1cmF0aW9uKTtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSAxO1xuXHRcdH1cblxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHZhciBzbmFwID0gdGhpcy5fbmVhcmVzdFNuYXAobmV3WCwgbmV3WSk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQYWdlID0gc25hcDtcblx0XHRcdHRpbWUgPSB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnMobmV3WCAtIHNuYXAueCksIDEwMDApLFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnMobmV3WSAtIHNuYXAueSksIDEwMDApXG5cdFx0XHRcdFx0KSwgMzAwKTtcblx0XHRcdG5ld1ggPSBzbmFwLng7XG5cdFx0XHRuZXdZID0gc25hcC55O1xuXG5cdFx0XHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHRcdFx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0XHRcdGVhc2luZyA9IHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmc7XG5cdFx0fVxuXG4vLyBJTlNFUlQgUE9JTlQ6IF9lbmRcblxuXHRcdGlmICggbmV3WCAhPSB0aGlzLnggfHwgbmV3WSAhPSB0aGlzLnkgKSB7XG5cdFx0XHQvLyBjaGFuZ2UgZWFzaW5nIGZ1bmN0aW9uIHdoZW4gc2Nyb2xsZXIgZ29lcyBvdXQgb2YgdGhlIGJvdW5kYXJpZXNcblx0XHRcdGlmICggbmV3WCA+IDAgfHwgbmV3WCA8IHRoaXMubWF4U2Nyb2xsWCB8fCBuZXdZID4gMCB8fCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0XHRlYXNpbmcgPSB1dGlscy5lYXNlLnF1YWRyYXRpYztcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zY3JvbGxUbyhuZXdYLCBuZXdZLCB0aW1lLCBlYXNpbmcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdH0sXG5cblx0X3Jlc2l6ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuXG5cdFx0dGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0LnJlZnJlc2goKTtcblx0XHR9LCB0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyk7XG5cdH0sXG5cblx0cmVzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR2YXIgeCA9IHRoaXMueCxcblx0XHRcdHkgPSB0aGlzLnk7XG5cblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXG5cdFx0aWYgKCAhdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsIHx8IHRoaXMueCA+IDAgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHR4ID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuaGFzVmVydGljYWxTY3JvbGwgfHwgdGhpcy55ID4gMCApIHtcblx0XHRcdHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMueSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdHkgPSB0aGlzLm1heFNjcm9sbFk7XG5cdFx0fVxuXG5cdFx0aWYgKCB4ID09IHRoaXMueCAmJiB5ID09IHRoaXMueSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKHgsIHksIHRpbWUsIHRoaXMub3B0aW9ucy5ib3VuY2VFYXNpbmcpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZiA9IHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQ7XHRcdC8vIEZvcmNlIHJlZmxvd1xuXG5cdFx0dGhpcy53cmFwcGVyV2lkdGhcdD0gdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoO1xuXHRcdHRoaXMud3JhcHBlckhlaWdodFx0PSB0aGlzLndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuXG4vKiBSRVBMQUNFIFNUQVJUOiByZWZyZXNoICovXG5cblx0XHR0aGlzLnNjcm9sbGVyV2lkdGhcdD0gdGhpcy5zY3JvbGxlci5vZmZzZXRXaWR0aDtcblx0XHR0aGlzLnNjcm9sbGVySGVpZ2h0XHQ9IHRoaXMuc2Nyb2xsZXIub2Zmc2V0SGVpZ2h0O1xuXG5cdFx0dGhpcy5tYXhTY3JvbGxYXHRcdD0gdGhpcy53cmFwcGVyV2lkdGggLSB0aGlzLnNjcm9sbGVyV2lkdGg7XG5cdFx0dGhpcy5tYXhTY3JvbGxZXHRcdD0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5zY3JvbGxlckhlaWdodDtcblxuLyogUkVQTEFDRSBFTkQ6IHJlZnJlc2ggKi9cblxuXHRcdHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbFx0PSB0aGlzLm9wdGlvbnMuc2Nyb2xsWCAmJiB0aGlzLm1heFNjcm9sbFggPCAwO1xuXHRcdHRoaXMuaGFzVmVydGljYWxTY3JvbGxcdFx0PSB0aGlzLm9wdGlvbnMuc2Nyb2xsWSAmJiB0aGlzLm1heFNjcm9sbFkgPCAwO1xuXG5cdFx0aWYgKCAhdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICkge1xuXHRcdFx0dGhpcy5tYXhTY3JvbGxYID0gMDtcblx0XHRcdHRoaXMuc2Nyb2xsZXJXaWR0aCA9IHRoaXMud3JhcHBlcldpZHRoO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR0aGlzLm1heFNjcm9sbFkgPSAwO1xuXHRcdFx0dGhpcy5zY3JvbGxlckhlaWdodCA9IHRoaXMud3JhcHBlckhlaWdodDtcblx0XHR9XG5cblx0XHR0aGlzLmVuZFRpbWUgPSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblxuXHRcdHRoaXMud3JhcHBlck9mZnNldCA9IHV0aWxzLm9mZnNldCh0aGlzLndyYXBwZXIpO1xuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdyZWZyZXNoJyk7XG5cblx0XHR0aGlzLnJlc2V0UG9zaXRpb24oKTtcblxuLy8gSU5TRVJUIFBPSU5UOiBfcmVmcmVzaFxuXG5cdH0sXG5cblx0b246IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuXHRcdGlmICggIXRoaXMuX2V2ZW50c1t0eXBlXSApIHtcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xuXHRcdH1cblxuXHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGZuKTtcblx0fSxcblxuXHRvZmY6IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuXHRcdGlmICggIXRoaXMuX2V2ZW50c1t0eXBlXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLl9ldmVudHNbdHlwZV0uaW5kZXhPZihmbik7XG5cblx0XHRpZiAoIGluZGV4ID4gLTEgKSB7XG5cdFx0XHR0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH0sXG5cblx0X2V4ZWNFdmVudDogZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRpZiAoICF0aGlzLl9ldmVudHNbdHlwZV0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG5cblx0XHRpZiAoICFsICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXVtpXS5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdH1cblx0fSxcblxuXHRzY3JvbGxCeTogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdHggPSB0aGlzLnggKyB4O1xuXHRcdHkgPSB0aGlzLnkgKyB5O1xuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cblx0XHR0aGlzLnNjcm9sbFRvKHgsIHksIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0c2Nyb2xsVG86IGZ1bmN0aW9uICh4LCB5LCB0aW1lLCBlYXNpbmcpIHtcblx0XHRlYXNpbmcgPSBlYXNpbmcgfHwgdXRpbHMuZWFzZS5jaXJjdWxhcjtcblxuXHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiB0aW1lID4gMDtcblx0XHR2YXIgdHJhbnNpdGlvblR5cGUgPSB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbiAmJiBlYXNpbmcuc3R5bGU7XG5cdFx0aWYgKCAhdGltZSB8fCB0cmFuc2l0aW9uVHlwZSApIHtcblx0XHRcdFx0aWYodHJhbnNpdGlvblR5cGUpIHtcblx0XHRcdFx0XHR0aGlzLl90cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24oZWFzaW5nLnN0eWxlKTtcblx0XHRcdFx0XHR0aGlzLl90cmFuc2l0aW9uVGltZSh0aW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0dGhpcy5fdHJhbnNsYXRlKHgsIHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9hbmltYXRlKHgsIHksIHRpbWUsIGVhc2luZy5mbik7XG5cdFx0fVxuXHR9LFxuXG5cdHNjcm9sbFRvRWxlbWVudDogZnVuY3Rpb24gKGVsLCB0aW1lLCBvZmZzZXRYLCBvZmZzZXRZLCBlYXNpbmcpIHtcblx0XHRlbCA9IGVsLm5vZGVUeXBlID8gZWwgOiB0aGlzLnNjcm9sbGVyLnF1ZXJ5U2VsZWN0b3IoZWwpO1xuXG5cdFx0aWYgKCAhZWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHBvcyA9IHV0aWxzLm9mZnNldChlbCk7XG5cblx0XHRwb3MubGVmdCAtPSB0aGlzLndyYXBwZXJPZmZzZXQubGVmdDtcblx0XHRwb3MudG9wICAtPSB0aGlzLndyYXBwZXJPZmZzZXQudG9wO1xuXG5cdFx0Ly8gaWYgb2Zmc2V0WC9ZIGFyZSB0cnVlIHdlIGNlbnRlciB0aGUgZWxlbWVudCB0byB0aGUgc2NyZWVuXG5cdFx0aWYgKCBvZmZzZXRYID09PSB0cnVlICkge1xuXHRcdFx0b2Zmc2V0WCA9IE1hdGgucm91bmQoZWwub2Zmc2V0V2lkdGggLyAyIC0gdGhpcy53cmFwcGVyLm9mZnNldFdpZHRoIC8gMik7XG5cdFx0fVxuXHRcdGlmICggb2Zmc2V0WSA9PT0gdHJ1ZSApIHtcblx0XHRcdG9mZnNldFkgPSBNYXRoLnJvdW5kKGVsLm9mZnNldEhlaWdodCAvIDIgLSB0aGlzLndyYXBwZXIub2Zmc2V0SGVpZ2h0IC8gMik7XG5cdFx0fVxuXG5cdFx0cG9zLmxlZnQgLT0gb2Zmc2V0WCB8fCAwO1xuXHRcdHBvcy50b3AgIC09IG9mZnNldFkgfHwgMDtcblxuXHRcdHBvcy5sZWZ0ID0gcG9zLmxlZnQgPiAwID8gMCA6IHBvcy5sZWZ0IDwgdGhpcy5tYXhTY3JvbGxYID8gdGhpcy5tYXhTY3JvbGxYIDogcG9zLmxlZnQ7XG5cdFx0cG9zLnRvcCAgPSBwb3MudG9wICA+IDAgPyAwIDogcG9zLnRvcCAgPCB0aGlzLm1heFNjcm9sbFkgPyB0aGlzLm1heFNjcm9sbFkgOiBwb3MudG9wO1xuXG5cdFx0dGltZSA9IHRpbWUgPT09IHVuZGVmaW5lZCB8fCB0aW1lID09PSBudWxsIHx8IHRpbWUgPT09ICdhdXRvJyA/IE1hdGgubWF4KE1hdGguYWJzKHRoaXMueC1wb3MubGVmdCksIE1hdGguYWJzKHRoaXMueS1wb3MudG9wKSkgOiB0aW1lO1xuXG5cdFx0dGhpcy5zY3JvbGxUbyhwb3MubGVmdCwgcG9zLnRvcCwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRfdHJhbnNpdGlvblRpbWU6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblxuXHRcdHZhciBkdXJhdGlvblByb3AgPSB1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb247XG5cdFx0dGhpcy5zY3JvbGxlclN0eWxlW2R1cmF0aW9uUHJvcF0gPSB0aW1lICsgJ21zJztcblxuXHRcdGlmICggIXRpbWUgJiYgdXRpbHMuaXNCYWRBbmRyb2lkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlW2R1cmF0aW9uUHJvcF0gPSAnMC4wMDAxbXMnO1xuXHRcdFx0Ly8gcmVtb3ZlIDAuMDAwMW1zXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRyQUYoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYuc2Nyb2xsZXJTdHlsZVtkdXJhdGlvblByb3BdID09PSAnMC4wMDAxbXMnKSB7XG5cdFx0XHRcdFx0c2VsZi5zY3JvbGxlclN0eWxlW2R1cmF0aW9uUHJvcF0gPSAnMHMnO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblxuXHRcdGlmICggdGhpcy5pbmRpY2F0b3JzICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udHJhbnNpdGlvblRpbWUodGltZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cbi8vIElOU0VSVCBQT0lOVDogX3RyYW5zaXRpb25UaW1lXG5cblx0fSxcblxuXHRfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBmdW5jdGlvbiAoZWFzaW5nKSB7XG5cdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbl0gPSBlYXNpbmc7XG5cblxuXHRcdGlmICggdGhpcy5pbmRpY2F0b3JzICkge1xuXHRcdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uKGVhc2luZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cbi8vIElOU0VSVCBQT0lOVDogX3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvblxuXG5cdH0sXG5cblx0X3RyYW5zbGF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy51c2VUcmFuc2Zvcm0gKSB7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IF90cmFuc2xhdGUgKi9cblxuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0gPSAndHJhbnNsYXRlKCcgKyB4ICsgJ3B4LCcgKyB5ICsgJ3B4KScgKyB0aGlzLnRyYW5zbGF0ZVo7XG5cbi8qIFJFUExBQ0UgRU5EOiBfdHJhbnNsYXRlICovXG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IE1hdGgucm91bmQoeCk7XG5cdFx0XHR5ID0gTWF0aC5yb3VuZCh5KTtcblx0XHRcdHRoaXMuc2Nyb2xsZXJTdHlsZS5sZWZ0ID0geCArICdweCc7XG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGUudG9wID0geSArICdweCc7XG5cdFx0fVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cblx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLmluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JzW2ldLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0fVxuXHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNsYXRlXG5cblx0fSxcblxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKHJlbW92ZSkge1xuXHRcdHZhciBldmVudFR5cGUgPSByZW1vdmUgPyB1dGlscy5yZW1vdmVFdmVudCA6IHV0aWxzLmFkZEV2ZW50LFxuXHRcdFx0dGFyZ2V0ID0gdGhpcy5vcHRpb25zLmJpbmRUb1dyYXBwZXIgPyB0aGlzLndyYXBwZXIgOiB3aW5kb3c7XG5cblx0XHRldmVudFR5cGUod2luZG93LCAnb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzKTtcblx0XHRldmVudFR5cGUod2luZG93LCAncmVzaXplJywgdGhpcyk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5jbGljayApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICdjbGljaycsIHRoaXMsIHRydWUpO1xuXHRcdH1cblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlTW91c2UgKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCAnbW91c2Vkb3duJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAnbW91c2VjYW5jZWwnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZXVwJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCB1dGlscy5oYXNQb2ludGVyICYmICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBvaW50ZXIgKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJkb3duJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmNhbmNlbCcpLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmICggdXRpbHMuaGFzVG91Y2ggJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlVG91Y2ggKSB7XG5cdFx0XHRldmVudFR5cGUodGhpcy53cmFwcGVyLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ3RvdWNoY2FuY2VsJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2hlbmQnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ3RyYW5zaXRpb25lbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ29UcmFuc2l0aW9uRW5kJywgdGhpcyk7XG5cdFx0ZXZlbnRUeXBlKHRoaXMuc2Nyb2xsZXIsICdNU1RyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0fSxcblxuXHRnZXRDb21wdXRlZFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuc2Nyb2xsZXIsIG51bGwpLFxuXHRcdFx0eCwgeTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeFt1dGlscy5zdHlsZS50cmFuc2Zvcm1dLnNwbGl0KCcpJylbMF0uc3BsaXQoJywgJyk7XG5cdFx0XHR4ID0gKyhtYXRyaXhbMTJdIHx8IG1hdHJpeFs0XSk7XG5cdFx0XHR5ID0gKyhtYXRyaXhbMTNdIHx8IG1hdHJpeFs1XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSArbWF0cml4LmxlZnQucmVwbGFjZSgvW14tXFxkLl0vZywgJycpO1xuXHRcdFx0eSA9ICttYXRyaXgudG9wLnJlcGxhY2UoL1teLVxcZC5dL2csICcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyB4OiB4LCB5OiB5IH07XG5cdH0sXG5cdF9pbml0SW5kaWNhdG9yczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpbnRlcmFjdGl2ZSA9IHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZVNjcm9sbGJhcnMsXG5cdFx0XHRjdXN0b21TdHlsZSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyAhPSAnc3RyaW5nJyxcblx0XHRcdGluZGljYXRvcnMgPSBbXSxcblx0XHRcdGluZGljYXRvcjtcblxuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdHRoaXMuaW5kaWNhdG9ycyA9IFtdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyApIHtcblx0XHRcdC8vIFZlcnRpY2FsIHNjcm9sbGJhclxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2Nyb2xsWSApIHtcblx0XHRcdFx0aW5kaWNhdG9yID0ge1xuXHRcdFx0XHRcdGVsOiBjcmVhdGVEZWZhdWx0U2Nyb2xsYmFyKCd2JywgaW50ZXJhY3RpdmUsIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzKSxcblx0XHRcdFx0XHRpbnRlcmFjdGl2ZTogaW50ZXJhY3RpdmUsXG5cdFx0XHRcdFx0ZGVmYXVsdFNjcm9sbGJhcnM6IHRydWUsXG5cdFx0XHRcdFx0Y3VzdG9tU3R5bGU6IGN1c3RvbVN0eWxlLFxuXHRcdFx0XHRcdHJlc2l6ZTogdGhpcy5vcHRpb25zLnJlc2l6ZVNjcm9sbGJhcnMsXG5cdFx0XHRcdFx0c2hyaW5rOiB0aGlzLm9wdGlvbnMuc2hyaW5rU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRmYWRlOiB0aGlzLm9wdGlvbnMuZmFkZVNjcm9sbGJhcnMsXG5cdFx0XHRcdFx0bGlzdGVuWDogZmFsc2Vcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yLmVsKTtcblx0XHRcdFx0aW5kaWNhdG9ycy5wdXNoKGluZGljYXRvcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvcml6b250YWwgc2Nyb2xsYmFyXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxYICkge1xuXHRcdFx0XHRpbmRpY2F0b3IgPSB7XG5cdFx0XHRcdFx0ZWw6IGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIoJ2gnLCBpbnRlcmFjdGl2ZSwgdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMpLFxuXHRcdFx0XHRcdGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZSxcblx0XHRcdFx0XHRkZWZhdWx0U2Nyb2xsYmFyczogdHJ1ZSxcblx0XHRcdFx0XHRjdXN0b21TdHlsZTogY3VzdG9tU3R5bGUsXG5cdFx0XHRcdFx0cmVzaXplOiB0aGlzLm9wdGlvbnMucmVzaXplU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRzaHJpbms6IHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGZhZGU6IHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRsaXN0ZW5ZOiBmYWxzZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IuZWwpO1xuXHRcdFx0XHRpbmRpY2F0b3JzLnB1c2goaW5kaWNhdG9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzICkge1xuXHRcdFx0Ly8gVE9ETzogY2hlY2sgY29uY2F0IGNvbXBhdGliaWxpdHlcblx0XHRcdGluZGljYXRvcnMgPSBpbmRpY2F0b3JzLmNvbmNhdCh0aGlzLm9wdGlvbnMuaW5kaWNhdG9ycyk7XG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSBpbmRpY2F0b3JzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9ycy5wdXNoKCBuZXcgSW5kaWNhdG9yKHRoaXMsIGluZGljYXRvcnNbaV0pICk7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogY2hlY2sgaWYgd2UgY2FuIHVzZSBhcnJheS5tYXAgKHdpZGUgY29tcGF0aWJpbGl0eSBhbmQgcGVyZm9ybWFuY2UgaXNzdWVzKVxuXHRcdGZ1bmN0aW9uIF9pbmRpY2F0b3JzTWFwIChmbikge1xuXHRcdFx0aWYgKHRoYXQuaW5kaWNhdG9ycykge1xuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IHRoYXQuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGF0LmluZGljYXRvcnNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZmFkZVNjcm9sbGJhcnMgKSB7XG5cdFx0XHR0aGlzLm9uKCdzY3JvbGxFbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbignc2Nyb2xsQ2FuY2VsJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMub24oJ3Njcm9sbFN0YXJ0JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKDEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLm9uKCdiZWZvcmVTY3JvbGxTdGFydCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgxLCB0cnVlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblxuXHRcdHRoaXMub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRkZWxldGUgdGhpcy5pbmRpY2F0b3JzO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9pbml0V2hlZWw6IGZ1bmN0aW9uICgpIHtcblx0XHR1dGlscy5hZGRFdmVudCh0aGlzLndyYXBwZXIsICd3aGVlbCcsIHRoaXMpO1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ21vdXNld2hlZWwnLCB0aGlzKTtcblx0XHR1dGlscy5hZGRFdmVudCh0aGlzLndyYXBwZXIsICdET01Nb3VzZVNjcm9sbCcsIHRoaXMpO1xuXG5cdFx0dGhpcy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLndoZWVsVGltZW91dCk7XG5cdFx0XHR0aGlzLndoZWVsVGltZW91dCA9IG51bGw7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICd3aGVlbCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy53cmFwcGVyLCAnbW91c2V3aGVlbCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy53cmFwcGVyLCAnRE9NTW91c2VTY3JvbGwnLCB0aGlzKTtcblx0XHR9KTtcblx0fSxcblxuXHRfd2hlZWw6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHZhciB3aGVlbERlbHRhWCwgd2hlZWxEZWx0YVksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHRpZiAoIHRoaXMud2hlZWxUaW1lb3V0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGF0Ll9leGVjRXZlbnQoJ3Njcm9sbFN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gRXhlY3V0ZSB0aGUgc2Nyb2xsRW5kIGV2ZW50IGFmdGVyIDQwMG1zIHRoZSB3aGVlbCBzdG9wcGVkIHNjcm9sbGluZ1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLndoZWVsVGltZW91dCk7XG5cdFx0dGhpcy53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmKCF0aGF0Lm9wdGlvbnMuc25hcCkge1xuXHRcdFx0XHR0aGF0Ll9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdFx0fVxuXHRcdFx0dGhhdC53aGVlbFRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cdFx0fSwgNDAwKTtcblxuXHRcdGlmICggJ2RlbHRhWCcgaW4gZSApIHtcblx0XHRcdGlmIChlLmRlbHRhTW9kZSA9PT0gMSkge1xuXHRcdFx0XHR3aGVlbERlbHRhWCA9IC1lLmRlbHRhWCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0XHRcdHdoZWVsRGVsdGFZID0gLWUuZGVsdGFZICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoZWVsRGVsdGFYID0gLWUuZGVsdGFYO1xuXHRcdFx0XHR3aGVlbERlbHRhWSA9IC1lLmRlbHRhWTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCAnd2hlZWxEZWx0YVgnIGluIGUgKSB7XG5cdFx0XHR3aGVlbERlbHRhWCA9IGUud2hlZWxEZWx0YVggLyAxMjAgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdFx0d2hlZWxEZWx0YVkgPSBlLndoZWVsRGVsdGFZIC8gMTIwICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHR9IGVsc2UgaWYgKCAnd2hlZWxEZWx0YScgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gd2hlZWxEZWx0YVkgPSBlLndoZWVsRGVsdGEgLyAxMjAgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdH0gZWxzZSBpZiAoICdkZXRhaWwnIGluIGUgKSB7XG5cdFx0XHR3aGVlbERlbHRhWCA9IHdoZWVsRGVsdGFZID0gLWUuZGV0YWlsIC8gMyAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR3aGVlbERlbHRhWCAqPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb247XG5cdFx0d2hlZWxEZWx0YVkgKj0gdGhpcy5vcHRpb25zLmludmVydFdoZWVsRGlyZWN0aW9uO1xuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gd2hlZWxEZWx0YVk7XG5cdFx0XHR3aGVlbERlbHRhWSA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdG5ld1ggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYO1xuXHRcdFx0bmV3WSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHRcdGlmICggd2hlZWxEZWx0YVggPiAwICkge1xuXHRcdFx0XHRuZXdYLS07XG5cdFx0XHR9IGVsc2UgaWYgKCB3aGVlbERlbHRhWCA8IDAgKSB7XG5cdFx0XHRcdG5ld1grKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aGVlbERlbHRhWSA+IDAgKSB7XG5cdFx0XHRcdG5ld1ktLTtcblx0XHRcdH0gZWxzZSBpZiAoIHdoZWVsRGVsdGFZIDwgMCApIHtcblx0XHRcdFx0bmV3WSsrO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmdvVG9QYWdlKG5ld1gsIG5ld1kpO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bmV3WCA9IHRoaXMueCArIE1hdGgucm91bmQodGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsID8gd2hlZWxEZWx0YVggOiAwKTtcblx0XHRuZXdZID0gdGhpcy55ICsgTWF0aC5yb3VuZCh0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsID8gd2hlZWxEZWx0YVkgOiAwKTtcblxuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IHdoZWVsRGVsdGFYID4gMCA/IC0xIDogd2hlZWxEZWx0YVggPCAwID8gMSA6IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gd2hlZWxEZWx0YVkgPiAwID8gLTEgOiB3aGVlbERlbHRhWSA8IDAgPyAxIDogMDtcblxuXHRcdGlmICggbmV3WCA+IDAgKSB7XG5cdFx0XHRuZXdYID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0bmV3WCA9IHRoaXMubWF4U2Nyb2xsWDtcblx0XHR9XG5cblx0XHRpZiAoIG5ld1kgPiAwICkge1xuXHRcdFx0bmV3WSA9IDA7XG5cdFx0fSBlbHNlIGlmICggbmV3WSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdG5ld1kgPSB0aGlzLm1heFNjcm9sbFk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxUbyhuZXdYLCBuZXdZLCAwKTtcblxuLy8gSU5TRVJUIFBPSU5UOiBfd2hlZWxcblx0fSxcblxuXHRfaW5pdFNuYXA6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmN1cnJlbnRQYWdlID0ge307XG5cblx0XHRpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuc25hcCA9PSAnc3RyaW5nJyApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zbmFwID0gdGhpcy5zY3JvbGxlci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5zbmFwKTtcblx0XHR9XG5cblx0XHR0aGlzLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGkgPSAwLCBsLFxuXHRcdFx0XHRtID0gMCwgbixcblx0XHRcdFx0Y3gsIGN5LFxuXHRcdFx0XHR4ID0gMCwgeSxcblx0XHRcdFx0c3RlcFggPSB0aGlzLm9wdGlvbnMuc25hcFN0ZXBYIHx8IHRoaXMud3JhcHBlcldpZHRoLFxuXHRcdFx0XHRzdGVwWSA9IHRoaXMub3B0aW9ucy5zbmFwU3RlcFkgfHwgdGhpcy53cmFwcGVySGVpZ2h0LFxuXHRcdFx0XHRlbDtcblxuXHRcdFx0dGhpcy5wYWdlcyA9IFtdO1xuXG5cdFx0XHRpZiAoICF0aGlzLndyYXBwZXJXaWR0aCB8fCAhdGhpcy53cmFwcGVySGVpZ2h0IHx8ICF0aGlzLnNjcm9sbGVyV2lkdGggfHwgIXRoaXMuc2Nyb2xsZXJIZWlnaHQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc25hcCA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0Y3ggPSBNYXRoLnJvdW5kKCBzdGVwWCAvIDIgKTtcblx0XHRcdFx0Y3kgPSBNYXRoLnJvdW5kKCBzdGVwWSAvIDIgKTtcblxuXHRcdFx0XHR3aGlsZSAoIHggPiAtdGhpcy5zY3JvbGxlcldpZHRoICkge1xuXHRcdFx0XHRcdHRoaXMucGFnZXNbaV0gPSBbXTtcblx0XHRcdFx0XHRsID0gMDtcblx0XHRcdFx0XHR5ID0gMDtcblxuXHRcdFx0XHRcdHdoaWxlICggeSA+IC10aGlzLnNjcm9sbGVySGVpZ2h0ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5wYWdlc1tpXVtsXSA9IHtcblx0XHRcdFx0XHRcdFx0eDogTWF0aC5tYXgoeCwgdGhpcy5tYXhTY3JvbGxYKSxcblx0XHRcdFx0XHRcdFx0eTogTWF0aC5tYXgoeSwgdGhpcy5tYXhTY3JvbGxZKSxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHN0ZXBYLFxuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHN0ZXBZLFxuXHRcdFx0XHRcdFx0XHRjeDogeCAtIGN4LFxuXHRcdFx0XHRcdFx0XHRjeTogeSAtIGN5XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHR5IC09IHN0ZXBZO1xuXHRcdFx0XHRcdFx0bCsrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHggLT0gc3RlcFg7XG5cdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbCA9IHRoaXMub3B0aW9ucy5zbmFwO1xuXHRcdFx0XHRsID0gZWwubGVuZ3RoO1xuXHRcdFx0XHRuID0gLTE7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggaSA9PT0gMCB8fCBlbFtpXS5vZmZzZXRMZWZ0IDw9IGVsW2ktMV0ub2Zmc2V0TGVmdCApIHtcblx0XHRcdFx0XHRcdG0gPSAwO1xuXHRcdFx0XHRcdFx0bisrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggIXRoaXMucGFnZXNbbV0gKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBhZ2VzW21dID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eCA9IE1hdGgubWF4KC1lbFtpXS5vZmZzZXRMZWZ0LCB0aGlzLm1heFNjcm9sbFgpO1xuXHRcdFx0XHRcdHkgPSBNYXRoLm1heCgtZWxbaV0ub2Zmc2V0VG9wLCB0aGlzLm1heFNjcm9sbFkpO1xuXHRcdFx0XHRcdGN4ID0geCAtIE1hdGgucm91bmQoZWxbaV0ub2Zmc2V0V2lkdGggLyAyKTtcblx0XHRcdFx0XHRjeSA9IHkgLSBNYXRoLnJvdW5kKGVsW2ldLm9mZnNldEhlaWdodCAvIDIpO1xuXG5cdFx0XHRcdFx0dGhpcy5wYWdlc1ttXVtuXSA9IHtcblx0XHRcdFx0XHRcdHg6IHgsXG5cdFx0XHRcdFx0XHR5OiB5LFxuXHRcdFx0XHRcdFx0d2lkdGg6IGVsW2ldLm9mZnNldFdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBlbFtpXS5vZmZzZXRIZWlnaHQsXG5cdFx0XHRcdFx0XHRjeDogY3gsXG5cdFx0XHRcdFx0XHRjeTogY3lcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKCB4ID4gdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0XHRcdFx0bSsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmdvVG9QYWdlKHRoaXMuY3VycmVudFBhZ2UucGFnZVggfHwgMCwgdGhpcy5jdXJyZW50UGFnZS5wYWdlWSB8fCAwLCAwKTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNuYXAgdGhyZXNob2xkIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc25hcFRocmVzaG9sZCAlIDEgPT09IDAgKSB7XG5cdFx0XHRcdHRoaXMuc25hcFRocmVzaG9sZFggPSB0aGlzLm9wdGlvbnMuc25hcFRocmVzaG9sZDtcblx0XHRcdFx0dGhpcy5zbmFwVGhyZXNob2xkWSA9IHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zbmFwVGhyZXNob2xkWCA9IE1hdGgucm91bmQodGhpcy5wYWdlc1t0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYXVt0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZXS53aWR0aCAqIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkKTtcblx0XHRcdFx0dGhpcy5zbmFwVGhyZXNob2xkWSA9IE1hdGgucm91bmQodGhpcy5wYWdlc1t0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYXVt0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZXS5oZWlnaHQgKiB0aGlzLm9wdGlvbnMuc25hcFRocmVzaG9sZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLm9uKCdmbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB0aW1lID0gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdFx0XHRNYXRoLm1heChcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMueCAtIHRoaXMuc3RhcnRYKSwgMTAwMCksXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnkgLSB0aGlzLnN0YXJ0WSksIDEwMDApXG5cdFx0XHRcdFx0KSwgMzAwKTtcblxuXHRcdFx0dGhpcy5nb1RvUGFnZShcblx0XHRcdFx0dGhpcy5jdXJyZW50UGFnZS5wYWdlWCArIHRoaXMuZGlyZWN0aW9uWCxcblx0XHRcdFx0dGhpcy5jdXJyZW50UGFnZS5wYWdlWSArIHRoaXMuZGlyZWN0aW9uWSxcblx0XHRcdFx0dGltZVxuXHRcdFx0KTtcblx0XHR9KTtcblx0fSxcblxuXHRfbmVhcmVzdFNuYXA6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0aWYgKCAhdGhpcy5wYWdlcy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB4OiAwLCB5OiAwLCBwYWdlWDogMCwgcGFnZVk6IDAgfTtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsID0gdGhpcy5wYWdlcy5sZW5ndGgsXG5cdFx0XHRtID0gMDtcblxuXHRcdC8vIENoZWNrIGlmIHdlIGV4Y2VlZGVkIHRoZSBzbmFwIHRocmVzaG9sZFxuXHRcdGlmICggTWF0aC5hYnMoeCAtIHRoaXMuYWJzU3RhcnRYKSA8IHRoaXMuc25hcFRocmVzaG9sZFggJiZcblx0XHRcdE1hdGguYWJzKHkgLSB0aGlzLmFic1N0YXJ0WSkgPCB0aGlzLnNuYXBUaHJlc2hvbGRZICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudFBhZ2U7XG5cdFx0fVxuXG5cdFx0aWYgKCB4ID4gMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHR4ID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblxuXHRcdGlmICggeSA+IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB5IDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRpZiAoIHggPj0gdGhpcy5wYWdlc1tpXVswXS5jeCApIHtcblx0XHRcdFx0eCA9IHRoaXMucGFnZXNbaV1bMF0ueDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bCA9IHRoaXMucGFnZXNbaV0ubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBtIDwgbDsgbSsrICkge1xuXHRcdFx0aWYgKCB5ID49IHRoaXMucGFnZXNbMF1bbV0uY3kgKSB7XG5cdFx0XHRcdHkgPSB0aGlzLnBhZ2VzWzBdW21dLnk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggaSA9PSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYICkge1xuXHRcdFx0aSArPSB0aGlzLmRpcmVjdGlvblg7XG5cblx0XHRcdGlmICggaSA8IDAgKSB7XG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0fSBlbHNlIGlmICggaSA+PSB0aGlzLnBhZ2VzLmxlbmd0aCApIHtcblx0XHRcdFx0aSA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTtcblx0XHRcdH1cblxuXHRcdFx0eCA9IHRoaXMucGFnZXNbaV1bMF0ueDtcblx0XHR9XG5cblx0XHRpZiAoIG0gPT0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWSApIHtcblx0XHRcdG0gKz0gdGhpcy5kaXJlY3Rpb25ZO1xuXG5cdFx0XHRpZiAoIG0gPCAwICkge1xuXHRcdFx0XHRtID0gMDtcblx0XHRcdH0gZWxzZSBpZiAoIG0gPj0gdGhpcy5wYWdlc1swXS5sZW5ndGggKSB7XG5cdFx0XHRcdG0gPSB0aGlzLnBhZ2VzWzBdLmxlbmd0aCAtIDE7XG5cdFx0XHR9XG5cblx0XHRcdHkgPSB0aGlzLnBhZ2VzWzBdW21dLnk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdFx0cGFnZVg6IGksXG5cdFx0XHRwYWdlWTogbVxuXHRcdH07XG5cdH0sXG5cblx0Z29Ub1BhZ2U6IGZ1bmN0aW9uICh4LCB5LCB0aW1lLCBlYXNpbmcpIHtcblx0XHRlYXNpbmcgPSBlYXNpbmcgfHwgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblxuXHRcdGlmICggeCA+PSB0aGlzLnBhZ2VzLmxlbmd0aCApIHtcblx0XHRcdHggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmICggeCA8IDAgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIHkgPj0gdGhpcy5wYWdlc1t4XS5sZW5ndGggKSB7XG5cdFx0XHR5ID0gdGhpcy5wYWdlc1t4XS5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSBpZiAoIHkgPCAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fVxuXG5cdFx0dmFyIHBvc1ggPSB0aGlzLnBhZ2VzW3hdW3ldLngsXG5cdFx0XHRwb3NZID0gdGhpcy5wYWdlc1t4XVt5XS55O1xuXG5cdFx0dGltZSA9IHRpbWUgPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRNYXRoLm1heChcblx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnMocG9zWCAtIHRoaXMueCksIDEwMDApLFxuXHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhwb3NZIC0gdGhpcy55KSwgMTAwMClcblx0XHRcdCksIDMwMCkgOiB0aW1lO1xuXG5cdFx0dGhpcy5jdXJyZW50UGFnZSA9IHtcblx0XHRcdHg6IHBvc1gsXG5cdFx0XHR5OiBwb3NZLFxuXHRcdFx0cGFnZVg6IHgsXG5cdFx0XHRwYWdlWTogeVxuXHRcdH07XG5cblx0XHR0aGlzLnNjcm9sbFRvKHBvc1gsIHBvc1ksIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0bmV4dDogZnVuY3Rpb24gKHRpbWUsIGVhc2luZykge1xuXHRcdHZhciB4ID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCxcblx0XHRcdHkgPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZO1xuXG5cdFx0eCsrO1xuXG5cdFx0aWYgKCB4ID49IHRoaXMucGFnZXMubGVuZ3RoICYmIHRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHRcdHkrKztcblx0XHR9XG5cblx0XHR0aGlzLmdvVG9QYWdlKHgsIHksIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0cHJldjogZnVuY3Rpb24gKHRpbWUsIGVhc2luZykge1xuXHRcdHZhciB4ID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCxcblx0XHRcdHkgPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZO1xuXG5cdFx0eC0tO1xuXG5cdFx0aWYgKCB4IDwgMCAmJiB0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0XHR5LS07XG5cdFx0fVxuXG5cdFx0dGhpcy5nb1RvUGFnZSh4LCB5LCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdF9pbml0S2V5czogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBkZWZhdWx0IGtleSBiaW5kaW5nc1xuXHRcdHZhciBrZXlzID0ge1xuXHRcdFx0cGFnZVVwOiAzMyxcblx0XHRcdHBhZ2VEb3duOiAzNCxcblx0XHRcdGVuZDogMzUsXG5cdFx0XHRob21lOiAzNixcblx0XHRcdGxlZnQ6IDM3LFxuXHRcdFx0dXA6IDM4LFxuXHRcdFx0cmlnaHQ6IDM5LFxuXHRcdFx0ZG93bjogNDBcblx0XHR9O1xuXHRcdHZhciBpO1xuXG5cdFx0Ly8gaWYgeW91IGdpdmUgbWUgY2hhcmFjdGVycyBJIGdpdmUgeW91IGtleWNvZGVcblx0XHRpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgPT0gJ29iamVjdCcgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldID09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHRoaXMub3B0aW9ucy5rZXlCaW5kaW5nc1tpXSA9IHRoaXMub3B0aW9ucy5rZXlCaW5kaW5nc1tpXS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcHRpb25zLmtleUJpbmRpbmdzID0ge307XG5cdFx0fVxuXG5cdFx0Zm9yICggaSBpbiBrZXlzICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldID0gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldIHx8IGtleXNbaV07XG5cdFx0fVxuXG5cdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAna2V5ZG93bicsIHRoaXMpO1xuXG5cdFx0dGhpcy5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ2tleWRvd24nLCB0aGlzKTtcblx0XHR9KTtcblx0fSxcblxuXHRfa2V5OiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc25hcCA9IHRoaXMub3B0aW9ucy5zbmFwLFx0Ly8gd2UgYXJlIHVzaW5nIHRoaXMgYWxvdCwgYmV0dGVyIHRvIGNhY2hlIGl0XG5cdFx0XHRuZXdYID0gc25hcCA/IHRoaXMuY3VycmVudFBhZ2UucGFnZVggOiB0aGlzLngsXG5cdFx0XHRuZXdZID0gc25hcCA/IHRoaXMuY3VycmVudFBhZ2UucGFnZVkgOiB0aGlzLnksXG5cdFx0XHRub3cgPSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRwcmV2VGltZSA9IHRoaXMua2V5VGltZSB8fCAwLFxuXHRcdFx0YWNjZWxlcmF0aW9uID0gMC4yNTAsXG5cdFx0XHRwb3M7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRoaXMuaXNJblRyYW5zaXRpb24gKSB7XG5cdFx0XHRwb3MgPSB0aGlzLmdldENvbXB1dGVkUG9zaXRpb24oKTtcblxuXHRcdFx0dGhpcy5fdHJhbnNsYXRlKE1hdGgucm91bmQocG9zLngpLCBNYXRoLnJvdW5kKHBvcy55KSk7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSBub3cgLSBwcmV2VGltZSA8IDIwMCA/IE1hdGgubWluKHRoaXMua2V5QWNjZWxlcmF0aW9uICsgYWNjZWxlcmF0aW9uLCA1MCkgOiAwO1xuXG5cdFx0c3dpdGNoICggZS5rZXlDb2RlICkge1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucGFnZVVwOlxuXHRcdFx0XHRpZiAoIHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCAmJiAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdFx0XHRuZXdYICs9IHNuYXAgPyAxIDogdGhpcy53cmFwcGVyV2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3WSArPSBzbmFwID8gMSA6IHRoaXMud3JhcHBlckhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLnBhZ2VEb3duOlxuXHRcdFx0XHRpZiAoIHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCAmJiAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdFx0XHRuZXdYIC09IHNuYXAgPyAxIDogdGhpcy53cmFwcGVyV2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3WSAtPSBzbmFwID8gMSA6IHRoaXMud3JhcHBlckhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmVuZDpcblx0XHRcdFx0bmV3WCA9IHNuYXAgPyB0aGlzLnBhZ2VzLmxlbmd0aC0xIDogdGhpcy5tYXhTY3JvbGxYO1xuXHRcdFx0XHRuZXdZID0gc25hcCA/IHRoaXMucGFnZXNbMF0ubGVuZ3RoLTEgOiB0aGlzLm1heFNjcm9sbFk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MuaG9tZTpcblx0XHRcdFx0bmV3WCA9IDA7XG5cdFx0XHRcdG5ld1kgPSAwO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmxlZnQ6XG5cdFx0XHRcdG5ld1ggKz0gc25hcCA/IC0xIDogNSArIHRoaXMua2V5QWNjZWxlcmF0aW9uPj4wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLnVwOlxuXHRcdFx0XHRuZXdZICs9IHNuYXAgPyAxIDogNSArIHRoaXMua2V5QWNjZWxlcmF0aW9uPj4wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLnJpZ2h0OlxuXHRcdFx0XHRuZXdYIC09IHNuYXAgPyAtMSA6IDUgKyB0aGlzLmtleUFjY2VsZXJhdGlvbj4+MDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5kb3duOlxuXHRcdFx0XHRuZXdZIC09IHNuYXAgPyAxIDogNSArIHRoaXMua2V5QWNjZWxlcmF0aW9uPj4wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHNuYXAgKSB7XG5cdFx0XHR0aGlzLmdvVG9QYWdlKG5ld1gsIG5ld1kpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WCA+IDAgKSB7XG5cdFx0XHRuZXdYID0gMDtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0bmV3WCA9IHRoaXMubWF4U2Nyb2xsWDtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIG5ld1kgPiAwICkge1xuXHRcdFx0bmV3WSA9IDA7XG5cdFx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IDA7XG5cdFx0fSBlbHNlIGlmICggbmV3WSA8IHRoaXMubWF4U2Nyb2xsWSApIHtcblx0XHRcdG5ld1kgPSB0aGlzLm1heFNjcm9sbFk7XG5cdFx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IDA7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxUbyhuZXdYLCBuZXdZLCAwKTtcblxuXHRcdHRoaXMua2V5VGltZSA9IG5vdztcblx0fSxcblxuXHRfYW5pbWF0ZTogZnVuY3Rpb24gKGRlc3RYLCBkZXN0WSwgZHVyYXRpb24sIGVhc2luZ0ZuKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0c3RhcnRYID0gdGhpcy54LFxuXHRcdFx0c3RhcnRZID0gdGhpcy55LFxuXHRcdFx0c3RhcnRUaW1lID0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0ZGVzdFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcblxuXHRcdGZ1bmN0aW9uIHN0ZXAgKCkge1xuXHRcdFx0dmFyIG5vdyA9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdFx0bmV3WCwgbmV3WSxcblx0XHRcdFx0ZWFzaW5nO1xuXG5cdFx0XHRpZiAoIG5vdyA+PSBkZXN0VGltZSApIHtcblx0XHRcdFx0dGhhdC5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGF0Ll90cmFuc2xhdGUoZGVzdFgsIGRlc3RZKTtcblxuXHRcdFx0XHRpZiAoICF0aGF0LnJlc2V0UG9zaXRpb24odGhhdC5vcHRpb25zLmJvdW5jZVRpbWUpICkge1xuXHRcdFx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG5vdyA9ICggbm93IC0gc3RhcnRUaW1lICkgLyBkdXJhdGlvbjtcblx0XHRcdGVhc2luZyA9IGVhc2luZ0ZuKG5vdyk7XG5cdFx0XHRuZXdYID0gKCBkZXN0WCAtIHN0YXJ0WCApICogZWFzaW5nICsgc3RhcnRYO1xuXHRcdFx0bmV3WSA9ICggZGVzdFkgLSBzdGFydFkgKSAqIGVhc2luZyArIHN0YXJ0WTtcblx0XHRcdHRoYXQuX3RyYW5zbGF0ZShuZXdYLCBuZXdZKTtcblxuXHRcdFx0aWYgKCB0aGF0LmlzQW5pbWF0aW5nICkge1xuXHRcdFx0XHRyQUYoc3RlcCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XG5cdFx0c3RlcCgpO1xuXHR9LFxuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRzd2l0Y2ggKCBlLnR5cGUgKSB7XG5cdFx0XHRjYXNlICd0b3VjaHN0YXJ0Jzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJkb3duJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckRvd24nOlxuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0dGhpcy5fc3RhcnQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJtb3ZlJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlck1vdmUnOlxuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0dGhpcy5fbW92ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRjYXNlICdwb2ludGVydXAnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyVXAnOlxuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRjYXNlICd0b3VjaGNhbmNlbCc6XG5cdFx0XHRjYXNlICdwb2ludGVyY2FuY2VsJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckNhbmNlbCc6XG5cdFx0XHRjYXNlICdtb3VzZWNhbmNlbCc6XG5cdFx0XHRcdHRoaXMuX2VuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdvcmllbnRhdGlvbmNoYW5nZSc6XG5cdFx0XHRjYXNlICdyZXNpemUnOlxuXHRcdFx0XHR0aGlzLl9yZXNpemUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0cmFuc2l0aW9uZW5kJzpcblx0XHRcdGNhc2UgJ3dlYmtpdFRyYW5zaXRpb25FbmQnOlxuXHRcdFx0Y2FzZSAnb1RyYW5zaXRpb25FbmQnOlxuXHRcdFx0Y2FzZSAnTVNUcmFuc2l0aW9uRW5kJzpcblx0XHRcdFx0dGhpcy5fdHJhbnNpdGlvbkVuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd3aGVlbCc6XG5cdFx0XHRjYXNlICdET01Nb3VzZVNjcm9sbCc6XG5cdFx0XHRjYXNlICdtb3VzZXdoZWVsJzpcblx0XHRcdFx0dGhpcy5fd2hlZWwoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAna2V5ZG93bic6XG5cdFx0XHRcdHRoaXMuX2tleShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjbGljayc6XG5cdFx0XHRcdGlmICggdGhpcy5lbmFibGVkICYmICFlLl9jb25zdHJ1Y3RlZCApIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0U2Nyb2xsYmFyIChkaXJlY3Rpb24sIGludGVyYWN0aXZlLCB0eXBlKSB7XG5cdHZhciBzY3JvbGxiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0XHRpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuXHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5Jztcblx0XHRpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9ICctd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDAuNSk7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuOSk7Ym9yZGVyLXJhZGl1czozcHgnO1xuXHR9XG5cblx0aW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdpU2Nyb2xsSW5kaWNhdG9yJztcblxuXHRpZiAoIGRpcmVjdGlvbiA9PSAnaCcgKSB7XG5cdFx0aWYgKCB0eXBlID09PSB0cnVlICkge1xuXHRcdFx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgKz0gJztoZWlnaHQ6N3B4O2xlZnQ6MnB4O3JpZ2h0OjJweDtib3R0b206MCc7XG5cdFx0XHRpbmRpY2F0b3Iuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHRcdH1cblx0XHRzY3JvbGxiYXIuY2xhc3NOYW1lID0gJ2lTY3JvbGxIb3Jpem9udGFsU2Nyb2xsYmFyJztcblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO3dpZHRoOjdweDtib3R0b206MnB4O3RvcDoycHg7cmlnaHQ6MXB4Jztcblx0XHRcdGluZGljYXRvci5zdHlsZS53aWR0aCA9ICcxMDAlJztcblx0XHR9XG5cdFx0c2Nyb2xsYmFyLmNsYXNzTmFtZSA9ICdpU2Nyb2xsVmVydGljYWxTY3JvbGxiYXInO1xuXHR9XG5cblx0c2Nyb2xsYmFyLnN0eWxlLmNzc1RleHQgKz0gJztvdmVyZmxvdzpoaWRkZW4nO1xuXG5cdGlmICggIWludGVyYWN0aXZlICkge1xuXHRcdHNjcm9sbGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXHR9XG5cblx0c2Nyb2xsYmFyLmFwcGVuZENoaWxkKGluZGljYXRvcik7XG5cblx0cmV0dXJuIHNjcm9sbGJhcjtcbn1cblxuZnVuY3Rpb24gSW5kaWNhdG9yIChzY3JvbGxlciwgb3B0aW9ucykge1xuXHR0aGlzLndyYXBwZXIgPSB0eXBlb2Ygb3B0aW9ucy5lbCA9PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5lbCkgOiBvcHRpb25zLmVsO1xuXHR0aGlzLndyYXBwZXJTdHlsZSA9IHRoaXMud3JhcHBlci5zdHlsZTtcblx0dGhpcy5pbmRpY2F0b3IgPSB0aGlzLndyYXBwZXIuY2hpbGRyZW5bMF07XG5cdHRoaXMuaW5kaWNhdG9yU3R5bGUgPSB0aGlzLmluZGljYXRvci5zdHlsZTtcblx0dGhpcy5zY3JvbGxlciA9IHNjcm9sbGVyO1xuXG5cdHRoaXMub3B0aW9ucyA9IHtcblx0XHRsaXN0ZW5YOiB0cnVlLFxuXHRcdGxpc3Rlblk6IHRydWUsXG5cdFx0aW50ZXJhY3RpdmU6IGZhbHNlLFxuXHRcdHJlc2l6ZTogdHJ1ZSxcblx0XHRkZWZhdWx0U2Nyb2xsYmFyczogZmFsc2UsXG5cdFx0c2hyaW5rOiBmYWxzZSxcblx0XHRmYWRlOiBmYWxzZSxcblx0XHRzcGVlZFJhdGlvWDogMCxcblx0XHRzcGVlZFJhdGlvWTogMFxuXHR9O1xuXG5cdGZvciAoIHZhciBpIGluIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0fVxuXG5cdHRoaXMuc2l6ZVJhdGlvWCA9IDE7XG5cdHRoaXMuc2l6ZVJhdGlvWSA9IDE7XG5cdHRoaXMubWF4UG9zWCA9IDA7XG5cdHRoaXMubWF4UG9zWSA9IDA7XG5cblx0aWYgKCB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUgKSB7XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVUb3VjaCApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMuaW5kaWNhdG9yLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAndG91Y2hlbmQnLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVQb2ludGVyICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZU1vdXNlICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsICdtb3VzZWRvd24nLCB0aGlzKTtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlICkge1xuXHRcdHRoaXMud3JhcHBlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0gPSB0aGlzLnNjcm9sbGVyLnRyYW5zbGF0ZVo7XG5cdFx0dmFyIGR1cmF0aW9uUHJvcCA9IHV0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbjtcblx0XHR0aGlzLndyYXBwZXJTdHlsZVtkdXJhdGlvblByb3BdID0gdXRpbHMuaXNCYWRBbmRyb2lkID8gJzAuMDAwMW1zJyA6ICcwbXMnO1xuXHRcdC8vIHJlbW92ZSAwLjAwMDFtc1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZih1dGlscy5pc0JhZEFuZHJvaWQpIHtcblx0XHRcdHJBRihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi53cmFwcGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9PT0gJzAuMDAwMW1zJykge1xuXHRcdFx0XHRcdHNlbGYud3JhcHBlclN0eWxlW2R1cmF0aW9uUHJvcF0gPSAnMHMnO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpcy53cmFwcGVyU3R5bGUub3BhY2l0eSA9ICcwJztcblx0fVxufVxuXG5JbmRpY2F0b3IucHJvdG90eXBlID0ge1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRzd2l0Y2ggKCBlLnR5cGUgKSB7XG5cdFx0XHRjYXNlICd0b3VjaHN0YXJ0Jzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJkb3duJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckRvd24nOlxuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0dGhpcy5fc3RhcnQoZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAndG91Y2htb3ZlJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJtb3ZlJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlck1vdmUnOlxuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0dGhpcy5fbW92ZShlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaGVuZCc6XG5cdFx0XHRjYXNlICdwb2ludGVydXAnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyVXAnOlxuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRjYXNlICd0b3VjaGNhbmNlbCc6XG5cdFx0XHRjYXNlICdwb2ludGVyY2FuY2VsJzpcblx0XHRcdGNhc2UgJ01TUG9pbnRlckNhbmNlbCc6XG5cdFx0XHRjYXNlICdtb3VzZWNhbmNlbCc6XG5cdFx0XHRcdHRoaXMuX2VuZChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyApIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmZhZGVUaW1lb3V0KTtcblx0XHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSApIHtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMuaW5kaWNhdG9yLCAndG91Y2hzdGFydCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy5pbmRpY2F0b3IsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLmluZGljYXRvciwgJ21vdXNlZG93bicsIHRoaXMpO1xuXG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJ1cCcpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kZWZhdWx0U2Nyb2xsYmFycyApIHtcblx0XHRcdHRoaXMud3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMud3JhcHBlcik7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lKCk7XG5cblx0XHR0aGlzLmluaXRpYXRlZCA9IHRydWU7XG5cdFx0dGhpcy5tb3ZlZCA9IGZhbHNlO1xuXHRcdHRoaXMubGFzdFBvaW50WFx0PSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLmxhc3RQb2ludFlcdD0gcG9pbnQucGFnZVk7XG5cblx0XHR0aGlzLnN0YXJ0VGltZVx0PSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVRvdWNoICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlUG9pbnRlciApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVNb3VzZSApIHtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnYmVmb3JlU2Nyb2xsU3RhcnQnKTtcblx0fSxcblxuXHRfbW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0ZGVsdGFYLCBkZWx0YVksXG5cdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0dGltZXN0YW1wID0gdXRpbHMuZ2V0VGltZSgpO1xuXG5cdFx0aWYgKCAhdGhpcy5tb3ZlZCApIHtcblx0XHRcdHRoaXMuc2Nyb2xsZXIuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdmVkID0gdHJ1ZTtcblxuXHRcdGRlbHRhWCA9IHBvaW50LnBhZ2VYIC0gdGhpcy5sYXN0UG9pbnRYO1xuXHRcdHRoaXMubGFzdFBvaW50WCA9IHBvaW50LnBhZ2VYO1xuXG5cdFx0ZGVsdGFZID0gcG9pbnQucGFnZVkgLSB0aGlzLmxhc3RQb2ludFk7XG5cdFx0dGhpcy5sYXN0UG9pbnRZID0gcG9pbnQucGFnZVk7XG5cblx0XHRuZXdYID0gdGhpcy54ICsgZGVsdGFYO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBkZWx0YVk7XG5cblx0XHR0aGlzLl9wb3MobmV3WCwgbmV3WSk7XG5cbi8vIElOU0VSVCBQT0lOVDogaW5kaWNhdG9yLl9tb3ZlXG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fSxcblxuXHRfZW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuaW5pdGlhdGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuaW5pdGlhdGVkID0gZmFsc2U7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVybW92ZScpLCB0aGlzKTtcblx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csICdtb3VzZW1vdmUnLCB0aGlzKTtcblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5vcHRpb25zLnNuYXAgKSB7XG5cdFx0XHR2YXIgc25hcCA9IHRoaXMuc2Nyb2xsZXIuX25lYXJlc3RTbmFwKHRoaXMuc2Nyb2xsZXIueCwgdGhpcy5zY3JvbGxlci55KTtcblxuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy5zY3JvbGxlci54IC0gc25hcC54KSwgMTAwMCksXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnNjcm9sbGVyLnkgLSBzbmFwLnkpLCAxMDAwKVxuXHRcdFx0XHRcdCksIDMwMCk7XG5cblx0XHRcdGlmICggdGhpcy5zY3JvbGxlci54ICE9IHNuYXAueCB8fCB0aGlzLnNjcm9sbGVyLnkgIT0gc25hcC55ICkge1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLmRpcmVjdGlvblggPSAwO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLmRpcmVjdGlvblkgPSAwO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLmN1cnJlbnRQYWdlID0gc25hcDtcblx0XHRcdFx0dGhpcy5zY3JvbGxlci5zY3JvbGxUbyhzbmFwLngsIHNuYXAueSwgdGltZSwgdGhpcy5zY3JvbGxlci5vcHRpb25zLmJvdW5jZUVhc2luZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHR9XG5cdH0sXG5cblx0dHJhbnNpdGlvblRpbWU6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblx0XHR2YXIgZHVyYXRpb25Qcm9wID0gdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uO1xuXHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbZHVyYXRpb25Qcm9wXSA9IHRpbWUgKyAnbXMnO1xuXG5cdFx0aWYgKCAhdGltZSAmJiB1dGlscy5pc0JhZEFuZHJvaWQgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlW2R1cmF0aW9uUHJvcF0gPSAnMC4wMDAxbXMnO1xuXHRcdFx0Ly8gcmVtb3ZlIDAuMDAwMW1zXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRyQUYoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYuaW5kaWNhdG9yU3R5bGVbZHVyYXRpb25Qcm9wXSA9PT0gJzAuMDAwMW1zJykge1xuXHRcdFx0XHRcdHNlbGYuaW5kaWNhdG9yU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwcyc7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHR0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uIChlYXNpbmcpIHtcblx0XHR0aGlzLmluZGljYXRvclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbl0gPSBlYXNpbmc7XG5cdH0sXG5cblx0cmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMudHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggJiYgIXRoaXMub3B0aW9ucy5saXN0ZW5ZICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5kaXNwbGF5ID0gdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWSAmJiAhdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc1ZlcnRpY2FsU2Nyb2xsID8gJ2Jsb2NrJyA6ICdub25lJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5kaXNwbGF5ID0gdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsIHx8IHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5oYXNIb3Jpem9udGFsU2Nyb2xsICYmIHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR1dGlscy5hZGRDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsQm90aFNjcm9sbGJhcnMnKTtcblx0XHRcdHV0aWxzLnJlbW92ZUNsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxMb25lU2Nyb2xsYmFyJyk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICYmIHRoaXMub3B0aW9ucy5jdXN0b21TdHlsZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUucmlnaHQgPSAnOHB4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUuYm90dG9tID0gJzhweCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dXRpbHMucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbEJvdGhTY3JvbGxiYXJzJyk7XG5cdFx0XHR1dGlscy5hZGRDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsTG9uZVNjcm9sbGJhcicpO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5kZWZhdWx0U2Nyb2xsYmFycyAmJiB0aGlzLm9wdGlvbnMuY3VzdG9tU3R5bGUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblggKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLnJpZ2h0ID0gJzJweCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVyLnN0eWxlLmJvdHRvbSA9ICcycHgnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHIgPSB0aGlzLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1x0Ly8gZm9yY2UgcmVmcmVzaFxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdHRoaXMud3JhcHBlcldpZHRoID0gdGhpcy53cmFwcGVyLmNsaWVudFdpZHRoO1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMucmVzaXplICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcldpZHRoID0gTWF0aC5tYXgoTWF0aC5yb3VuZCh0aGlzLndyYXBwZXJXaWR0aCAqIHRoaXMud3JhcHBlcldpZHRoIC8gKHRoaXMuc2Nyb2xsZXIuc2Nyb2xsZXJXaWR0aCB8fCB0aGlzLndyYXBwZXJXaWR0aCB8fCAxKSksIDgpO1xuXHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLndpZHRoID0gdGhpcy5pbmRpY2F0b3JXaWR0aCArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvcldpZHRoID0gdGhpcy5pbmRpY2F0b3IuY2xpZW50V2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWCA9IHRoaXMud3JhcHBlcldpZHRoIC0gdGhpcy5pbmRpY2F0b3JXaWR0aDtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdjbGlwJyApIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVggPSAtdGhpcy5pbmRpY2F0b3JXaWR0aCArIDg7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlYID0gdGhpcy53cmFwcGVyV2lkdGggLSA4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVggPSAwO1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WCA9IHRoaXMubWF4UG9zWDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zaXplUmF0aW9YID0gdGhpcy5vcHRpb25zLnNwZWVkUmF0aW9YIHx8ICh0aGlzLnNjcm9sbGVyLm1heFNjcm9sbFggJiYgKHRoaXMubWF4UG9zWCAvIHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWCkpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmxpc3RlblkgKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJIZWlnaHQgPSB0aGlzLndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMucmVzaXplICkge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvckhlaWdodCA9IE1hdGgubWF4KE1hdGgucm91bmQodGhpcy53cmFwcGVySGVpZ2h0ICogdGhpcy53cmFwcGVySGVpZ2h0IC8gKHRoaXMuc2Nyb2xsZXIuc2Nyb2xsZXJIZWlnaHQgfHwgdGhpcy53cmFwcGVySGVpZ2h0IHx8IDEpKSwgOCk7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuaGVpZ2h0ID0gdGhpcy5pbmRpY2F0b3JIZWlnaHQgKyAncHgnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JIZWlnaHQgPSB0aGlzLmluZGljYXRvci5jbGllbnRIZWlnaHQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWSA9IHRoaXMud3JhcHBlckhlaWdodCAtIHRoaXMuaW5kaWNhdG9ySGVpZ2h0O1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ2NsaXAnICkge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WSA9IC10aGlzLmluZGljYXRvckhlaWdodCArIDg7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gODtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlZID0gMDtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVkgPSB0aGlzLm1heFBvc1k7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4UG9zWSA9IHRoaXMud3JhcHBlckhlaWdodCAtIHRoaXMuaW5kaWNhdG9ySGVpZ2h0O1xuXHRcdFx0dGhpcy5zaXplUmF0aW9ZID0gdGhpcy5vcHRpb25zLnNwZWVkUmF0aW9ZIHx8ICh0aGlzLnNjcm9sbGVyLm1heFNjcm9sbFkgJiYgKHRoaXMubWF4UG9zWSAvIHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWSkpO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlUG9zaXRpb24oKTtcblx0fSxcblxuXHR1cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB4ID0gdGhpcy5vcHRpb25zLmxpc3RlblggJiYgTWF0aC5yb3VuZCh0aGlzLnNpemVSYXRpb1ggKiB0aGlzLnNjcm9sbGVyLngpIHx8IDAsXG5cdFx0XHR5ID0gdGhpcy5vcHRpb25zLmxpc3RlblkgJiYgTWF0aC5yb3VuZCh0aGlzLnNpemVSYXRpb1kgKiB0aGlzLnNjcm9sbGVyLnkpIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuaWdub3JlQm91bmRhcmllcyApIHtcblx0XHRcdGlmICggeCA8IHRoaXMubWluQm91bmRhcnlYICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyApIHtcblx0XHRcdFx0XHR0aGlzLndpZHRoID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JXaWR0aCArIHgsIDgpO1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR4ID0gdGhpcy5taW5Cb3VuZGFyeVg7XG5cdFx0XHR9IGVsc2UgaWYgKCB4ID4gdGhpcy5tYXhCb3VuZGFyeVggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLmluZGljYXRvcldpZHRoIC0gKHggLSB0aGlzLm1heFBvc1gpLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG5cdFx0XHRcdFx0eCA9IHRoaXMubWF4UG9zWCArIHRoaXMuaW5kaWNhdG9yV2lkdGggLSB0aGlzLndpZHRoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHggPSB0aGlzLm1heEJvdW5kYXJ5WDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICYmIHRoaXMud2lkdGggIT0gdGhpcy5pbmRpY2F0b3JXaWR0aCApIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuaW5kaWNhdG9yV2lkdGg7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB5IDwgdGhpcy5taW5Cb3VuZGFyeVkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JIZWlnaHQgKyB5ICogMywgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHRcdH1cblx0XHRcdFx0eSA9IHRoaXMubWluQm91bmRhcnlZO1xuXHRcdFx0fSBlbHNlIGlmICggeSA+IHRoaXMubWF4Qm91bmRhcnlZICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyApIHtcblx0XHRcdFx0XHR0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaW5kaWNhdG9ySGVpZ2h0IC0gKHkgLSB0aGlzLm1heFBvc1kpICogMywgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHRcdFx0eSA9IHRoaXMubWF4UG9zWSArIHRoaXMuaW5kaWNhdG9ySGVpZ2h0IC0gdGhpcy5oZWlnaHQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSA9IHRoaXMubWF4Qm91bmRhcnlZO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgJiYgdGhpcy5oZWlnaHQgIT0gdGhpcy5pbmRpY2F0b3JIZWlnaHQgKSB7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdGlmICggdGhpcy5zY3JvbGxlci5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyArIHRoaXMuc2Nyb2xsZXIudHJhbnNsYXRlWjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5sZWZ0ID0geCArICdweCc7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLnRvcCA9IHkgKyAncHgnO1xuXHRcdH1cblx0fSxcblxuXHRfcG9zOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggeCA8IDAgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB4ID4gdGhpcy5tYXhQb3NYICkge1xuXHRcdFx0eCA9IHRoaXMubWF4UG9zWDtcblx0XHR9XG5cblx0XHRpZiAoIHkgPCAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggeSA+IHRoaXMubWF4UG9zWSApIHtcblx0XHRcdHkgPSB0aGlzLm1heFBvc1k7XG5cdFx0fVxuXG5cdFx0eCA9IHRoaXMub3B0aW9ucy5saXN0ZW5YID8gTWF0aC5yb3VuZCh4IC8gdGhpcy5zaXplUmF0aW9YKSA6IHRoaXMuc2Nyb2xsZXIueDtcblx0XHR5ID0gdGhpcy5vcHRpb25zLmxpc3RlblkgPyBNYXRoLnJvdW5kKHkgLyB0aGlzLnNpemVSYXRpb1kpIDogdGhpcy5zY3JvbGxlci55O1xuXG5cdFx0dGhpcy5zY3JvbGxlci5zY3JvbGxUbyh4LCB5KTtcblx0fSxcblxuXHRmYWRlOiBmdW5jdGlvbiAodmFsLCBob2xkKSB7XG5cdFx0aWYgKCBob2xkICYmICF0aGlzLnZpc2libGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZmFkZVRpbWVvdXQpO1xuXHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBudWxsO1xuXG5cdFx0dmFyIHRpbWUgPSB2YWwgPyAyNTAgOiA1MDAsXG5cdFx0XHRkZWxheSA9IHZhbCA/IDAgOiAzMDA7XG5cblx0XHR2YWwgPSB2YWwgPyAnMScgOiAnMCc7XG5cblx0XHR0aGlzLndyYXBwZXJTdHlsZVt1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb25dID0gdGltZSArICdtcyc7XG5cblx0XHR0aGlzLmZhZGVUaW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0dGhpcy53cmFwcGVyU3R5bGUub3BhY2l0eSA9IHZhbDtcblx0XHRcdHRoaXMudmlzaWJsZSA9ICt2YWw7XG5cdFx0fSkuYmluZCh0aGlzLCB2YWwpLCBkZWxheSk7XG5cdH1cbn07XG5cbklTY3JvbGwudXRpbHMgPSB1dGlscztcblxuaWYgKCB0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IElTY3JvbGw7XG59IGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgICAgZGVmaW5lKCBmdW5jdGlvbiAoKSB7IHJldHVybiBJU2Nyb2xsOyB9ICk7XG59IGVsc2Uge1xuXHR3aW5kb3cuSVNjcm9sbCA9IElTY3JvbGw7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsIE1hdGgpO1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gKiBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHN0ZXA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmFuZ2U7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGJhc2VSYW5nZSA9IHJlcXVpcmUoJy4vX2Jhc2VSYW5nZScpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKSxcbiAgICB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJhbmdlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBub3cgPSByZXF1aXJlKCcuL25vdycpLFxuICAgIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nXG4gICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICA6IHRpbWVXYWl0aW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgYmFzZUlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Jhc2VJc1R5cGVkQXJyYXknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcbiIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIiwidmFyIGNyZWF0ZVJhbmdlID0gcmVxdWlyZSgnLi9fY3JlYXRlUmFuZ2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICpcbiAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmFuZ2UoNCk7XG4gKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAqXG4gKiBfLnJhbmdlKC00KTtcbiAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICpcbiAqIF8ucmFuZ2UoMSwgNSk7XG4gKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAqXG4gKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gKlxuICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA0LCAwKTtcbiAqIC8vID0+IFsxLCAxLCAxXVxuICpcbiAqIF8ucmFuZ2UoMCk7XG4gKiAvLyA9PiBbXVxuICovXG52YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJy4vZGVib3VuY2UnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZTtcbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9GaW5pdGU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGh5cGVyc2NyaXB0ID0gcmVxdWlyZShcIi4vcmVuZGVyL2h5cGVyc2NyaXB0XCIpXG5cbmh5cGVyc2NyaXB0LnRydXN0ID0gcmVxdWlyZShcIi4vcmVuZGVyL3RydXN0XCIpXG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IHJlcXVpcmUoXCIuL3JlbmRlci9mcmFnbWVudFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGVyc2NyaXB0XG4iLCI7KGZ1bmN0aW9uKCkge1xuXCJ1c2Ugc3RyaWN0XCJcbmZ1bmN0aW9uIFZub2RlKHRhZywga2V5LCBhdHRyczAsIGNoaWxkcmVuLCB0ZXh0LCBkb20pIHtcblx0cmV0dXJuIHt0YWc6IHRhZywga2V5OiBrZXksIGF0dHJzOiBhdHRyczAsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dDogdGV4dCwgZG9tOiBkb20sIGRvbVNpemU6IHVuZGVmaW5lZCwgc3RhdGU6IHVuZGVmaW5lZCwgX3N0YXRlOiB1bmRlZmluZWQsIGV2ZW50czogdW5kZWZpbmVkLCBpbnN0YW5jZTogdW5kZWZpbmVkLCBza2lwOiBmYWxzZX1cbn1cblZub2RlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBWbm9kZShcIltcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKG5vZGUpLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0aWYgKG5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIFZub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9kZSA9PT0gZmFsc2UgPyBcIlwiIDogbm9kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdHJldHVybiBub2RlXG59XG5Wbm9kZS5ub3JtYWxpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZHJlbltpXSA9IFZub2RlLm5vcm1hbGl6ZShjaGlsZHJlbltpXSlcblx0fVxuXHRyZXR1cm4gY2hpbGRyZW5cbn1cbnZhciBzZWxlY3RvclBhcnNlciA9IC8oPzooXnwjfFxcLikoW14jXFwuXFxbXFxdXSspKXwoXFxbKC4rPykoPzpcXHMqPVxccyooXCJ8J3wpKCg/OlxcXFxbXCInXFxdXXwuKSo/KVxcNSk/XFxdKS9nXG52YXIgc2VsZWN0b3JDYWNoZSA9IHt9XG52YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHlcbmZ1bmN0aW9uIGlzRW1wdHkob2JqZWN0KSB7XG5cdGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChoYXNPd24uY2FsbChvYmplY3QsIGtleSkpIHJldHVybiBmYWxzZVxuXHRyZXR1cm4gdHJ1ZVxufVxuZnVuY3Rpb24gY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG5cdHZhciBtYXRjaCwgdGFnID0gXCJkaXZcIiwgY2xhc3NlcyA9IFtdLCBhdHRycyA9IHt9XG5cdHdoaWxlIChtYXRjaCA9IHNlbGVjdG9yUGFyc2VyLmV4ZWMoc2VsZWN0b3IpKSB7XG5cdFx0dmFyIHR5cGUgPSBtYXRjaFsxXSwgdmFsdWUgPSBtYXRjaFsyXVxuXHRcdGlmICh0eXBlID09PSBcIlwiICYmIHZhbHVlICE9PSBcIlwiKSB0YWcgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiI1wiKSBhdHRycy5pZCA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIuXCIpIGNsYXNzZXMucHVzaCh2YWx1ZSlcblx0XHRlbHNlIGlmIChtYXRjaFszXVswXSA9PT0gXCJbXCIpIHtcblx0XHRcdHZhciBhdHRyVmFsdWUgPSBtYXRjaFs2XVxuXHRcdFx0aWYgKGF0dHJWYWx1ZSkgYXR0clZhbHVlID0gYXR0clZhbHVlLnJlcGxhY2UoL1xcXFwoW1wiJ10pL2csIFwiJDFcIikucmVwbGFjZSgvXFxcXFxcXFwvZywgXCJcXFxcXCIpXG5cdFx0XHRpZiAobWF0Y2hbNF0gPT09IFwiY2xhc3NcIikgY2xhc3Nlcy5wdXNoKGF0dHJWYWx1ZSlcblx0XHRcdGVsc2UgYXR0cnNbbWF0Y2hbNF1dID0gYXR0clZhbHVlID09PSBcIlwiID8gYXR0clZhbHVlIDogYXR0clZhbHVlIHx8IHRydWVcblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzZXMubGVuZ3RoID4gMCkgYXR0cnMuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKVxuXHRyZXR1cm4gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gPSB7dGFnOiB0YWcsIGF0dHJzOiBhdHRyc31cbn1cbmZ1bmN0aW9uIGV4ZWNTZWxlY3RvcihzdGF0ZSwgYXR0cnMsIGNoaWxkcmVuKSB7XG5cdHZhciBoYXNBdHRycyA9IGZhbHNlLCBjaGlsZExpc3QsIHRleHRcblx0dmFyIGNsYXNzTmFtZSA9IGF0dHJzLmNsYXNzTmFtZSB8fCBhdHRycy5jbGFzc1xuXHRpZiAoIWlzRW1wdHkoc3RhdGUuYXR0cnMpICYmICFpc0VtcHR5KGF0dHJzKSkge1xuXHRcdHZhciBuZXdBdHRycyA9IHt9XG5cdFx0Zm9yKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSkge1xuXHRcdFx0XHRuZXdBdHRyc1trZXldID0gYXR0cnNba2V5XVxuXHRcdFx0fVxuXHRcdH1cblx0XHRhdHRycyA9IG5ld0F0dHJzXG5cdH1cblx0Zm9yICh2YXIga2V5IGluIHN0YXRlLmF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKHN0YXRlLmF0dHJzLCBrZXkpKSB7XG5cdFx0XHRhdHRyc1trZXldID0gc3RhdGUuYXR0cnNba2V5XVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoYXR0cnMuY2xhc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXR0cnMuY2xhc3MgPSB1bmRlZmluZWRcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuXHRcdH1cblx0XHRpZiAoc3RhdGUuYXR0cnMuY2xhc3NOYW1lICE9IG51bGwpIHtcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IHN0YXRlLmF0dHJzLmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lXG5cdFx0fVxuXHR9XG5cdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSAmJiBrZXkgIT09IFwia2V5XCIpIHtcblx0XHRcdGhhc0F0dHJzID0gdHJ1ZVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSAhPSBudWxsICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCIjXCIpIHtcblx0XHR0ZXh0ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0fSBlbHNlIHtcblx0XHRjaGlsZExpc3QgPSBjaGlsZHJlblxuXHR9XG5cdHJldHVybiBWbm9kZShzdGF0ZS50YWcsIGF0dHJzLmtleSwgaGFzQXR0cnMgPyBhdHRycyA6IHVuZGVmaW5lZCwgY2hpbGRMaXN0LCB0ZXh0KVxufVxuZnVuY3Rpb24gaHlwZXJzY3JpcHQoc2VsZWN0b3IpIHtcblx0Ly8gQmVjYXVzZSBzbG9wcHkgbW9kZSBzdWNrc1xuXHR2YXIgYXR0cnMgPSBhcmd1bWVudHNbMV0sIHN0YXJ0ID0gMiwgY2hpbGRyZW5cblx0aWYgKHNlbGVjdG9yID09IG51bGwgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxlY3Rvci52aWV3ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR0aHJvdyBFcnJvcihcIlRoZSBzZWxlY3RvciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGNvbXBvbmVudC5cIik7XG5cdH1cblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHZhciBjYWNoZWQgPSBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSB8fCBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpXG5cdH1cblx0aWYgKGF0dHJzID09IG51bGwpIHtcblx0XHRhdHRycyA9IHt9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJzLnRhZyAhPSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHRcdHN0YXJ0ID0gMVxuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSBzdGFydCArIDEpIHtcblx0XHRjaGlsZHJlbiA9IGFyZ3VtZW50c1tzdGFydF1cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSBjaGlsZHJlbiA9IFtjaGlsZHJlbl1cblx0fSBlbHNlIHtcblx0XHRjaGlsZHJlbiA9IFtdXG5cdFx0d2hpbGUgKHN0YXJ0IDwgYXJndW1lbnRzLmxlbmd0aCkgY2hpbGRyZW4ucHVzaChhcmd1bWVudHNbc3RhcnQrK10pXG5cdH1cblx0dmFyIG5vcm1hbGl6ZWQgPSBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbilcblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBleGVjU2VsZWN0b3IoY2FjaGVkLCBhdHRycywgbm9ybWFsaXplZClcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gVm5vZGUoc2VsZWN0b3IsIGF0dHJzLmtleSwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH1cbn1cbmh5cGVyc2NyaXB0LnRydXN0ID0gZnVuY3Rpb24oaHRtbCkge1xuXHRpZiAoaHRtbCA9PSBudWxsKSBodG1sID0gXCJcIlxuXHRyZXR1cm4gVm5vZGUoXCI8XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBodG1sLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbmh5cGVyc2NyaXB0LmZyYWdtZW50ID0gZnVuY3Rpb24oYXR0cnMxLCBjaGlsZHJlbikge1xuXHRyZXR1cm4gVm5vZGUoXCJbXCIsIGF0dHJzMS5rZXksIGF0dHJzMSwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbnZhciBtID0gaHlwZXJzY3JpcHRcbi8qKiBAY29uc3RydWN0b3IgKi9cbnZhciBQcm9taXNlUG9seWZpbGwgPSBmdW5jdGlvbihleGVjdXRvcikge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGBuZXdgXCIpXG5cdGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKVxuXHR2YXIgc2VsZiA9IHRoaXMsIHJlc29sdmVycyA9IFtdLCByZWplY3RvcnMgPSBbXSwgcmVzb2x2ZUN1cnJlbnQgPSBoYW5kbGVyKHJlc29sdmVycywgdHJ1ZSksIHJlamVjdEN1cnJlbnQgPSBoYW5kbGVyKHJlamVjdG9ycywgZmFsc2UpXG5cdHZhciBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlID0ge3Jlc29sdmVyczogcmVzb2x2ZXJzLCByZWplY3RvcnM6IHJlamVjdG9yc31cblx0dmFyIGNhbGxBc3luYyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gaGFuZGxlcihsaXN0LCBzaG91bGRBYnNvcmIpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXhlY3V0ZSh2YWx1ZSkge1xuXHRcdFx0dmFyIHRoZW5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChzaG91bGRBYnNvcmIgJiYgdmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgKHRoZW4gPSB2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCB3LyBpdHNlbGZcIilcblx0XHRcdFx0XHRleGVjdXRlT25jZSh0aGVuLmJpbmQodmFsdWUpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxBc3luYyhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICghc2hvdWxkQWJzb3JiICYmIGxpc3QubGVuZ3RoID09PSAwKSBjb25zb2xlLmVycm9yKFwiUG9zc2libGUgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOlwiLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgbGlzdFtpXSh2YWx1ZSlcblx0XHRcdFx0XHRcdHJlc29sdmVycy5sZW5ndGggPSAwLCByZWplY3RvcnMubGVuZ3RoID0gMFxuXHRcdFx0XHRcdFx0aW5zdGFuY2Uuc3RhdGUgPSBzaG91bGRBYnNvcmJcblx0XHRcdFx0XHRcdGluc3RhbmNlLnJldHJ5ID0gZnVuY3Rpb24oKSB7ZXhlY3V0ZSh2YWx1ZSl9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0Q3VycmVudChlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBleGVjdXRlT25jZSh0aGVuKSB7XG5cdFx0dmFyIHJ1bnMgPSAwXG5cdFx0ZnVuY3Rpb24gcnVuKGZuKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHJ1bnMrKyA+IDApIHJldHVyblxuXHRcdFx0XHRmbih2YWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIG9uZXJyb3IgPSBydW4ocmVqZWN0Q3VycmVudClcblx0XHR0cnkge3RoZW4ocnVuKHJlc29sdmVDdXJyZW50KSwgb25lcnJvcil9IGNhdGNoIChlKSB7b25lcnJvcihlKX1cblx0fVxuXHRleGVjdXRlT25jZShleGVjdXRvcilcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGlvbikge1xuXHR2YXIgc2VsZiA9IHRoaXMsIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2Vcblx0ZnVuY3Rpb24gaGFuZGxlKGNhbGxiYWNrLCBsaXN0LCBuZXh0LCBzdGF0ZSkge1xuXHRcdGxpc3QucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSBuZXh0KHZhbHVlKVxuXHRcdFx0ZWxzZSB0cnkge3Jlc29sdmVOZXh0KGNhbGxiYWNrKHZhbHVlKSl9IGNhdGNoIChlKSB7aWYgKHJlamVjdE5leHQpIHJlamVjdE5leHQoZSl9XG5cdFx0fSlcblx0XHRpZiAodHlwZW9mIGluc3RhbmNlLnJldHJ5ID09PSBcImZ1bmN0aW9uXCIgJiYgc3RhdGUgPT09IGluc3RhbmNlLnN0YXRlKSBpbnN0YW5jZS5yZXRyeSgpXG5cdH1cblx0dmFyIHJlc29sdmVOZXh0LCByZWplY3ROZXh0XG5cdHZhciBwcm9taXNlID0gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZXNvbHZlTmV4dCA9IHJlc29sdmUsIHJlamVjdE5leHQgPSByZWplY3R9KVxuXHRoYW5kbGUob25GdWxmaWxsZWQsIGluc3RhbmNlLnJlc29sdmVycywgcmVzb2x2ZU5leHQsIHRydWUpLCBoYW5kbGUob25SZWplY3Rpb24sIGluc3RhbmNlLnJlamVjdG9ycywgcmVqZWN0TmV4dCwgZmFsc2UpXG5cdHJldHVybiBwcm9taXNlXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcblx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbilcbn1cblByb21pc2VQb2x5ZmlsbC5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSByZXR1cm4gdmFsdWVcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSkge3Jlc29sdmUodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZWplY3QodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5hbGwgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHZhciB0b3RhbCA9IGxpc3QubGVuZ3RoLCBjb3VudCA9IDAsIHZhbHVlcyA9IFtdXG5cdFx0aWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKVxuXHRcdGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQoZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRmdW5jdGlvbiBjb25zdW1lKHZhbHVlKSB7XG5cdFx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSB0b3RhbCkgcmVzb2x2ZSh2YWx1ZXMpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxpc3RbaV0gIT0gbnVsbCAmJiAodHlwZW9mIGxpc3RbaV0gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGxpc3RbaV0gPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mIGxpc3RbaV0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0bGlzdFtpXS50aGVuKGNvbnN1bWUsIHJlamVjdClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGNvbnN1bWUobGlzdFtpXSlcblx0XHRcdH0pKGkpXG5cdFx0fVxuXHR9KVxufVxuUHJvbWlzZVBvbHlmaWxsLnJhY2UgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGlzdFtpXS50aGVuKHJlc29sdmUsIHJlamVjdClcblx0XHR9XG5cdH0pXG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRpZiAodHlwZW9mIHdpbmRvdy5Qcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSB3aW5kb3cuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR2YXIgUHJvbWlzZVBvbHlmaWxsID0gd2luZG93LlByb21pc2Vcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRpZiAodHlwZW9mIGdsb2JhbC5Qcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSBnbG9iYWwuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR2YXIgUHJvbWlzZVBvbHlmaWxsID0gZ2xvYmFsLlByb21pc2Vcbn0gZWxzZSB7XG59XG52YXIgYnVpbGRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHJldHVybiBcIlwiXG5cdHZhciBhcmdzID0gW11cblx0Zm9yICh2YXIga2V5MCBpbiBvYmplY3QpIHtcblx0XHRkZXN0cnVjdHVyZShrZXkwLCBvYmplY3Rba2V5MF0pXG5cdH1cblx0cmV0dXJuIGFyZ3Muam9pbihcIiZcIilcblx0ZnVuY3Rpb24gZGVzdHJ1Y3R1cmUoa2V5MCwgdmFsdWUpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRkZXN0cnVjdHVyZShrZXkwICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGFyZ3MucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5MCkgKyAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gXCJcIiA/IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IFwiXCIpKVxuXHR9XG59XG52YXIgRklMRV9QUk9UT0NPTF9SRUdFWCA9IG5ldyBSZWdFeHAoXCJeZmlsZTovL1wiLCBcImlcIilcbnZhciBfOCA9IGZ1bmN0aW9uKCR3aW5kb3csIFByb21pc2UpIHtcblx0dmFyIGNhbGxiYWNrQ291bnQgPSAwXG5cdHZhciBvbmNvbXBsZXRpb25cblx0ZnVuY3Rpb24gc2V0Q29tcGxldGlvbkNhbGxiYWNrKGNhbGxiYWNrKSB7b25jb21wbGV0aW9uID0gY2FsbGJhY2t9XG5cdGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcblx0XHR2YXIgY291bnQgPSAwXG5cdFx0ZnVuY3Rpb24gY29tcGxldGUoKSB7aWYgKC0tY291bnQgPT09IDAgJiYgdHlwZW9mIG9uY29tcGxldGlvbiA9PT0gXCJmdW5jdGlvblwiKSBvbmNvbXBsZXRpb24oKX1cblx0XHRyZXR1cm4gZnVuY3Rpb24gZmluYWxpemUocHJvbWlzZTApIHtcblx0XHRcdHZhciB0aGVuMCA9IHByb21pc2UwLnRoZW5cblx0XHRcdHByb21pc2UwLnRoZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHR2YXIgbmV4dCA9IHRoZW4wLmFwcGx5KHByb21pc2UwLCBhcmd1bWVudHMpXG5cdFx0XHRcdG5leHQudGhlbihjb21wbGV0ZSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGNvbXBsZXRlKClcblx0XHRcdFx0XHRpZiAoY291bnQgPT09IDApIHRocm93IGVcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuIGZpbmFsaXplKG5leHQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTBcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmdzID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgdXJsID0gYXJnc1xuXHRcdFx0YXJncyA9IGV4dHJhIHx8IHt9XG5cdFx0XHRpZiAoYXJncy51cmwgPT0gbnVsbCkgYXJncy51cmwgPSB1cmxcblx0XHR9XG5cdFx0cmV0dXJuIGFyZ3Ncblx0fVxuXHRmdW5jdGlvbiByZXF1ZXN0KGFyZ3MsIGV4dHJhKSB7XG5cdFx0dmFyIGZpbmFsaXplID0gZmluYWxpemVyKClcblx0XHRhcmdzID0gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKVxuXHRcdHZhciBwcm9taXNlMCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0aWYgKGFyZ3MubWV0aG9kID09IG51bGwpIGFyZ3MubWV0aG9kID0gXCJHRVRcIlxuXHRcdFx0YXJncy5tZXRob2QgPSBhcmdzLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG5cdFx0XHR2YXIgdXNlQm9keSA9IChhcmdzLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBhcmdzLm1ldGhvZCA9PT0gXCJUUkFDRVwiKSA/IGZhbHNlIDogKHR5cGVvZiBhcmdzLnVzZUJvZHkgPT09IFwiYm9vbGVhblwiID8gYXJncy51c2VCb2R5IDogdHJ1ZSlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5zZXJpYWxpemUgIT09IFwiZnVuY3Rpb25cIikgYXJncy5zZXJpYWxpemUgPSB0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJncy5kYXRhIGluc3RhbmNlb2YgRm9ybURhdGEgPyBmdW5jdGlvbih2YWx1ZSkge3JldHVybiB2YWx1ZX0gOiBKU09OLnN0cmluZ2lmeVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmRlc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmV4dHJhY3QgIT09IFwiZnVuY3Rpb25cIikgYXJncy5leHRyYWN0ID0gZXh0cmFjdFxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0aWYgKHVzZUJvZHkpIGFyZ3MuZGF0YSA9IGFyZ3Muc2VyaWFsaXplKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgYXJncy51cmwgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0dmFyIHhociA9IG5ldyAkd2luZG93LlhNTEh0dHBSZXF1ZXN0KCksXG5cdFx0XHRcdGFib3J0ZWQgPSBmYWxzZSxcblx0XHRcdFx0X2Fib3J0ID0geGhyLmFib3J0XG5cdFx0XHR4aHIuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWVcblx0XHRcdFx0X2Fib3J0LmNhbGwoeGhyKVxuXHRcdFx0fVxuXHRcdFx0eGhyLm9wZW4oYXJncy5tZXRob2QsIGFyZ3MudXJsLCB0eXBlb2YgYXJncy5hc3luYyA9PT0gXCJib29sZWFuXCIgPyBhcmdzLmFzeW5jIDogdHJ1ZSwgdHlwZW9mIGFyZ3MudXNlciA9PT0gXCJzdHJpbmdcIiA/IGFyZ3MudXNlciA6IHVuZGVmaW5lZCwgdHlwZW9mIGFyZ3MucGFzc3dvcmQgPT09IFwic3RyaW5nXCIgPyBhcmdzLnBhc3N3b3JkIDogdW5kZWZpbmVkKVxuXHRcdFx0aWYgKGFyZ3Muc2VyaWFsaXplID09PSBKU09OLnN0cmluZ2lmeSAmJiB1c2VCb2R5ICYmICEoYXJncy5oZWFkZXJzICYmIGFyZ3MuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShcIkNvbnRlbnQtVHlwZVwiKSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy5kZXNlcmlhbGl6ZSA9PT0gZGVzZXJpYWxpemUgJiYgIShhcmdzLmhlYWRlcnMgJiYgYXJncy5oZWFkZXJzLmhhc093blByb3BlcnR5KFwiQWNjZXB0XCIpKSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBnZXROYW1lU3BhY2Uodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMgJiYgdm5vZGUuYXR0cnMueG1sbnMgfHwgbmFtZVNwYWNlW3Zub2RlLnRhZ11cblx0fVxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2gxID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2gxWzFdXSB8fCBcImRpdlwiXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50MSlcblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRlbHNlIGlmICh2bm9kZXMgPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoLCB2bm9kZXMpXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLmxlbmd0aCA9PT0gdm5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXNVbmtleWVkID0gZmFsc2Vcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgb2xkW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGlzVW5rZXllZCA9IHZub2Rlc1tpXS5rZXkgPT0gbnVsbCAmJiBvbGRbaV0ua2V5ID09IG51bGxcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1Vua2V5ZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZFtpXSA9PT0gdm5vZGVzW2ldKSBjb250aW51ZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAob2xkW2ldID09IG51bGwgJiYgdm5vZGVzW2ldICE9IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZXNbaV0sIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodm5vZGVzW2ldID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgaSwgaSArIDEsIHZub2Rlcylcblx0XHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZFtpXSwgdm5vZGVzW2ldLCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjeWNsaW5nID0gcmVjeWNsaW5nIHx8IGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcylcblx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBvbGQucG9vbFxuXHRcdFx0XHRvbGQgPSBvbGQuY29uY2F0KG9sZC5wb29sKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZTAgbXVsdGlwbGUgY2hpbGRyZW5cblx0XHRcdFx0dm5vZGUudGV4dCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH1cblx0XHR1cGRhdGVBdHRycyh2bm9kZSwgb2xkLmF0dHJzLCB2bm9kZS5hdHRycywgbnMpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdH1cblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0aWYgKG9sZC5pbnN0YW5jZSA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQuaW5zdGFuY2UsIHZub2RlLmluc3RhbmNlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSwgbnVsbClcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKSB7XG5cdFx0aWYgKG9sZC5wb29sICE9IG51bGwgJiYgTWF0aC5hYnMob2xkLnBvb2wubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkgPD0gTWF0aC5hYnMob2xkLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpKSB7XG5cdFx0XHR2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRbMF0gJiYgb2xkWzBdLmNoaWxkcmVuICYmIG9sZFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHBvb2xDaGlsZHJlbkxlbmd0aCA9IG9sZC5wb29sWzBdICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgdm5vZGVzQ2hpbGRyZW5MZW5ndGggPSB2bm9kZXNbMF0gJiYgdm5vZGVzWzBdLmNoaWxkcmVuICYmIHZub2Rlc1swXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0aWYgKE1hdGguYWJzKHBvb2xDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSA8PSBNYXRoLmFicyhvbGRDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBlbmQpIHtcblx0XHR2YXIgbWFwID0ge30sIGkgPSAwXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5MiA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5MiAhPSBudWxsKSBtYXBba2V5Ml0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQwICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQwID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50MCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXHRmdW5jdGlvbiBzZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50MCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0XHRcdHdoaWxlICgtLWNvdW50MCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSBvbnJlbW92ZSh2bm9kZS5pbnN0YW5jZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9hdHRyczJcblx0ZnVuY3Rpb24gc2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0c2V0QXR0cih2bm9kZSwga2V5MiwgbnVsbCwgYXR0cnMyW2tleTJdLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QXR0cih2bm9kZSwga2V5Miwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkyID09PSBcImtleVwiIHx8IGtleTIgPT09IFwiaXNcIiB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkyKSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5Mi5pbmRleE9mKFwiOlwiKVxuXHRcdGlmIChuc0xhc3RJbmRleCA+IC0xICYmIGtleTIuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkyLnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgPT09IFwic3R5bGVcIikgdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyIGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleTIpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkyID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQwID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDApIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlMSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yMCB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5Ml0gPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHQvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiByZXR1cm4gbnVsbCBpbiBJRSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvYWN0aXZlRWxlbWVudFxuXHRcdGlmIChhY3RpdmUgIT0gbnVsbCAmJiAkZG9jLmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZSkgYWN0aXZlLmZvY3VzKClcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdH1cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XG5cdC8vNjBmcHMgdHJhbnNsYXRlcyB0byAxNi42bXMsIHJvdW5kIGl0IGRvd24gc2luY2Ugc2V0VGltZW91dCByZXF1aXJlcyBpbnRcblx0dmFyIHRpbWUgPSAxNlxuXHR2YXIgbGFzdCA9IDAsIHBlbmRpbmcgPSBudWxsXG5cdHZhciB0aW1lb3V0ID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dFxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KClcblx0XHRpZiAobGFzdCA9PT0gMCB8fCBub3cgLSBsYXN0ID49IHRpbWUpIHtcblx0XHRcdGxhc3QgPSBub3dcblx0XHRcdGNhbGxiYWNrKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHRcdFx0cGVuZGluZyA9IHRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrKClcblx0XHRcdFx0bGFzdCA9IERhdGUubm93KClcblx0XHRcdH0sIHRpbWUgLSAobm93IC0gbGFzdCkpXG5cdFx0fVxuXHR9XG59XG52YXIgXzExID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgcmVuZGVyU2VydmljZSA9IGNvcmVSZW5kZXJlcigkd2luZG93KVxuXHRyZW5kZXJTZXJ2aWNlLnNldEV2ZW50Q2FsbGJhY2soZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLnJlZHJhdyA9PT0gZmFsc2UpIGUucmVkcmF3ID0gdW5kZWZpbmVkXG5cdFx0ZWxzZSByZWRyYXcoKVxuXHR9KVxuXHR2YXIgY2FsbGJhY2tzID0gW11cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKGtleTEsIGNhbGxiYWNrKSB7XG5cdFx0dW5zdWJzY3JpYmUoa2V5MSlcblx0XHRjYWxsYmFja3MucHVzaChrZXkxLCB0aHJvdHRsZShjYWxsYmFjaykpXG5cdH1cblx0ZnVuY3Rpb24gdW5zdWJzY3JpYmUoa2V5MSkge1xuXHRcdHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGtleTEpXG5cdFx0aWYgKGluZGV4ID4gLTEpIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDIpXG5cdH1cblx0ZnVuY3Rpb24gcmVkcmF3KCkge1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRjYWxsYmFja3NbaV0oKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4ge3N1YnNjcmliZTogc3Vic2NyaWJlLCB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUsIHJlZHJhdzogcmVkcmF3LCByZW5kZXI6IHJlbmRlclNlcnZpY2UucmVuZGVyfVxufVxudmFyIHJlZHJhd1NlcnZpY2UgPSBfMTEod2luZG93KVxucmVxdWVzdFNlcnZpY2Uuc2V0Q29tcGxldGlvbkNhbGxiYWNrKHJlZHJhd1NlcnZpY2UucmVkcmF3KVxudmFyIF8xNiA9IGZ1bmN0aW9uKHJlZHJhd1NlcnZpY2UwKSB7XG5cdHJldHVybiBmdW5jdGlvbihyb290LCBjb21wb25lbnQpIHtcblx0XHRpZiAoY29tcG9uZW50ID09PSBudWxsKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgW10pXG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC51bnN1YnNjcmliZShyb290KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChjb21wb25lbnQudmlldyA9PSBudWxsICYmIHR5cGVvZiBjb21wb25lbnQgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwibS5tb3VudChlbGVtZW50LCBjb21wb25lbnQpIGV4cGVjdHMgYSBjb21wb25lbnQsIG5vdCBhIHZub2RlXCIpXG5cdFx0XG5cdFx0dmFyIHJ1bjAgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBWbm9kZShjb21wb25lbnQpKVxuXHRcdH1cblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMClcblx0XHRyZWRyYXdTZXJ2aWNlMC5yZWRyYXcoKVxuXHR9XG59XG5tLm1vdW50ID0gXzE2KHJlZHJhd1NlcnZpY2UpXG52YXIgUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxudmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0aWYgKHN0cmluZyA9PT0gXCJcIiB8fCBzdHJpbmcgPT0gbnVsbCkgcmV0dXJuIHt9XG5cdGlmIChzdHJpbmcuY2hhckF0KDApID09PSBcIj9cIikgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDEpXG5cdHZhciBlbnRyaWVzID0gc3RyaW5nLnNwbGl0KFwiJlwiKSwgZGF0YTAgPSB7fSwgY291bnRlcnMgPSB7fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZW50cnkgPSBlbnRyaWVzW2ldLnNwbGl0KFwiPVwiKVxuXHRcdHZhciBrZXk1ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzBdKVxuXHRcdHZhciB2YWx1ZSA9IGVudHJ5Lmxlbmd0aCA9PT0gMiA/IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVsxXSkgOiBcIlwiXG5cdFx0aWYgKHZhbHVlID09PSBcInRydWVcIikgdmFsdWUgPSB0cnVlXG5cdFx0ZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikgdmFsdWUgPSBmYWxzZVxuXHRcdHZhciBsZXZlbHMgPSBrZXk1LnNwbGl0KC9cXF1cXFs/fFxcWy8pXG5cdFx0dmFyIGN1cnNvciA9IGRhdGEwXG5cdFx0aWYgKGtleTUuaW5kZXhPZihcIltcIikgPiAtMSkgbGV2ZWxzLnBvcCgpXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1tqXSwgbmV4dExldmVsID0gbGV2ZWxzW2ogKyAxXVxuXHRcdFx0dmFyIGlzTnVtYmVyID0gbmV4dExldmVsID09IFwiXCIgfHwgIWlzTmFOKHBhcnNlSW50KG5leHRMZXZlbCwgMTApKVxuXHRcdFx0dmFyIGlzVmFsdWUgPSBqID09PSBsZXZlbHMubGVuZ3RoIC0gMVxuXHRcdFx0aWYgKGxldmVsID09PSBcIlwiKSB7XG5cdFx0XHRcdHZhciBrZXk1ID0gbGV2ZWxzLnNsaWNlKDAsIGopLmpvaW4oKVxuXHRcdFx0XHRpZiAoY291bnRlcnNba2V5NV0gPT0gbnVsbCkgY291bnRlcnNba2V5NV0gPSAwXG5cdFx0XHRcdGxldmVsID0gY291bnRlcnNba2V5NV0rK1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnNvcltsZXZlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRjdXJzb3JbbGV2ZWxdID0gaXNWYWx1ZSA/IHZhbHVlIDogaXNOdW1iZXIgPyBbXSA6IHt9XG5cdFx0XHR9XG5cdFx0XHRjdXJzb3IgPSBjdXJzb3JbbGV2ZWxdXG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhMFxufVxudmFyIGNvcmVSb3V0ZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IHR5cGVvZiAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID09PSBcImZ1bmN0aW9uXCJcblx0dmFyIGNhbGxBc3luYzAgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZTEoZnJhZ21lbnQwKSB7XG5cdFx0dmFyIGRhdGEgPSAkd2luZG93LmxvY2F0aW9uW2ZyYWdtZW50MF0ucmVwbGFjZSgvKD86JVthLWY4OV1bYS1mMC05XSkrL2dpbSwgZGVjb2RlVVJJQ29tcG9uZW50KVxuXHRcdGlmIChmcmFnbWVudDAgPT09IFwicGF0aG5hbWVcIiAmJiBkYXRhWzBdICE9PSBcIi9cIikgZGF0YSA9IFwiL1wiICsgZGF0YVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0dmFyIGFzeW5jSWRcblx0ZnVuY3Rpb24gZGVib3VuY2VBc3luYyhjYWxsYmFjazApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoYXN5bmNJZCAhPSBudWxsKSByZXR1cm5cblx0XHRcdGFzeW5jSWQgPSBjYWxsQXN5bmMwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhc3luY0lkID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjazAoKVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpIHtcblx0XHR2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIilcblx0XHR2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKVxuXHRcdHZhciBwYXRoRW5kID0gcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgcXVlcnlFbmQgPSBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0XHR2YXIgcXVlcnlQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEsIHF1ZXJ5RW5kKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gcXVlcnlQYXJhbXMpIHF1ZXJ5RGF0YVtrZXk0XSA9IHF1ZXJ5UGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdGlmIChoYXNoSW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIGhhc2hQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UoaGFzaEluZGV4ICsgMSkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGhhc2hQYXJhbXMpIGhhc2hEYXRhW2tleTRdID0gaGFzaFBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aC5zbGljZSgwLCBwYXRoRW5kKVxuXHR9XG5cdHZhciByb3V0ZXIgPSB7cHJlZml4OiBcIiMhXCJ9XG5cdHJvdXRlci5nZXRQYXRoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR5cGUyID0gcm91dGVyLnByZWZpeC5jaGFyQXQoMClcblx0XHRzd2l0Y2ggKHR5cGUyKSB7XG5cdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gbm9ybWFsaXplMShcImhhc2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRjYXNlIFwiP1wiOiByZXR1cm4gbm9ybWFsaXplMShcInNlYXJjaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIG5vcm1hbGl6ZTEoXCJwYXRobmFtZVwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwic2VhcmNoXCIpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHR9XG5cdH1cblx0cm91dGVyLnNldFBhdGggPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0dmFyIHF1ZXJ5RGF0YSA9IHt9LCBoYXNoRGF0YSA9IHt9XG5cdFx0cGF0aCA9IHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKVxuXHRcdGlmIChkYXRhICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTQgaW4gZGF0YSkgcXVlcnlEYXRhW2tleTRdID0gZGF0YVtrZXk0XVxuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvOihbXlxcL10rKS9nLCBmdW5jdGlvbihtYXRjaDIsIHRva2VuKSB7XG5cdFx0XHRcdGRlbGV0ZSBxdWVyeURhdGFbdG9rZW5dXG5cdFx0XHRcdHJldHVybiBkYXRhW3Rva2VuXVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0dmFyIHF1ZXJ5ID0gYnVpbGRRdWVyeVN0cmluZyhxdWVyeURhdGEpXG5cdFx0aWYgKHF1ZXJ5KSBwYXRoICs9IFwiP1wiICsgcXVlcnlcblx0XHR2YXIgaGFzaCA9IGJ1aWxkUXVlcnlTdHJpbmcoaGFzaERhdGEpXG5cdFx0aWYgKGhhc2gpIHBhdGggKz0gXCIjXCIgKyBoYXNoXG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBvcHRpb25zID8gb3B0aW9ucy5zdGF0ZSA6IG51bGxcblx0XHRcdHZhciB0aXRsZSA9IG9wdGlvbnMgPyBvcHRpb25zLnRpdGxlIDogbnVsbFxuXHRcdFx0JHdpbmRvdy5vbnBvcHN0YXRlKClcblx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkgJHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdFx0ZWxzZSAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0fVxuXHRcdGVsc2UgJHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcm91dGVyLnByZWZpeCArIHBhdGhcblx0fVxuXHRyb3V0ZXIuZGVmaW5lUm91dGVzID0gZnVuY3Rpb24ocm91dGVzLCByZXNvbHZlLCByZWplY3QpIHtcblx0XHRmdW5jdGlvbiByZXNvbHZlUm91dGUoKSB7XG5cdFx0XHR2YXIgcGF0aCA9IHJvdXRlci5nZXRQYXRoKClcblx0XHRcdHZhciBwYXJhbXMgPSB7fVxuXHRcdFx0dmFyIHBhdGhuYW1lID0gcGFyc2VQYXRoKHBhdGgsIHBhcmFtcywgcGFyYW1zKVxuXHRcdFx0dmFyIHN0YXRlID0gJHdpbmRvdy5oaXN0b3J5LnN0YXRlXG5cdFx0XHRpZiAoc3RhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBrIGluIHN0YXRlKSBwYXJhbXNba10gPSBzdGF0ZVtrXVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgcm91dGUwIGluIHJvdXRlcykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoXCJeXCIgKyByb3V0ZTAucmVwbGFjZSgvOlteXFwvXSs/XFwuezN9L2csIFwiKC4qPylcIikucmVwbGFjZSgvOlteXFwvXSsvZywgXCIoW15cXFxcL10rKVwiKSArIFwiXFwvPyRcIilcblx0XHRcdFx0aWYgKG1hdGNoZXIudGVzdChwYXRobmFtZSkpIHtcblx0XHRcdFx0XHRwYXRobmFtZS5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGtleXMgPSByb3V0ZTAubWF0Y2goLzpbXlxcL10rL2cpIHx8IFtdXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEsIC0yKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHBhcmFtc1trZXlzW2ldLnJlcGxhY2UoLzp8XFwuL2csIFwiXCIpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaV0pXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJvdXRlc1tyb3V0ZTBdLCBwYXJhbXMsIHBhdGgsIHJvdXRlMClcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWplY3QocGF0aCwgcGFyYW1zKVxuXHRcdH1cblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpICR3aW5kb3cub25wb3BzdGF0ZSA9IGRlYm91bmNlQXN5bmMocmVzb2x2ZVJvdXRlKVxuXHRcdGVsc2UgaWYgKHJvdXRlci5wcmVmaXguY2hhckF0KDApID09PSBcIiNcIikgJHdpbmRvdy5vbmhhc2hjaGFuZ2UgPSByZXNvbHZlUm91dGVcblx0XHRyZXNvbHZlUm91dGUoKVxuXHR9XG5cdHJldHVybiByb3V0ZXJcbn1cbnZhciBfMjAgPSBmdW5jdGlvbigkd2luZG93LCByZWRyYXdTZXJ2aWNlMCkge1xuXHR2YXIgcm91dGVTZXJ2aWNlID0gY29yZVJvdXRlcigkd2luZG93KVxuXHR2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbih2KSB7cmV0dXJuIHZ9XG5cdHZhciByZW5kZXIxLCBjb21wb25lbnQsIGF0dHJzMywgY3VycmVudFBhdGgsIGxhc3RVcGRhdGVcblx0dmFyIHJvdXRlID0gZnVuY3Rpb24ocm9vdCwgZGVmYXVsdFJvdXRlLCByb3V0ZXMpIHtcblx0XHRpZiAocm9vdCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCB0byBgbS5yb3V0ZWAgaXMgbm90IHVuZGVmaW5lZFwiKVxuXHRcdHZhciBydW4xID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAocmVuZGVyMSAhPSBudWxsKSByZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgcmVuZGVyMShWbm9kZShjb21wb25lbnQsIGF0dHJzMy5rZXksIGF0dHJzMykpKVxuXHRcdH1cblx0XHR2YXIgYmFpbCA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdGlmIChwYXRoICE9PSBkZWZhdWx0Um91dGUpIHJvdXRlU2VydmljZS5zZXRQYXRoKGRlZmF1bHRSb3V0ZSwgbnVsbCwge3JlcGxhY2U6IHRydWV9KVxuXHRcdFx0ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBkZWZhdWx0IHJvdXRlIFwiICsgZGVmYXVsdFJvdXRlKVxuXHRcdH1cblx0XHRyb3V0ZVNlcnZpY2UuZGVmaW5lUm91dGVzKHJvdXRlcywgZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBwYXRoKSB7XG5cdFx0XHR2YXIgdXBkYXRlID0gbGFzdFVwZGF0ZSA9IGZ1bmN0aW9uKHJvdXRlUmVzb2x2ZXIsIGNvbXApIHtcblx0XHRcdFx0aWYgKHVwZGF0ZSAhPT0gbGFzdFVwZGF0ZSkgcmV0dXJuXG5cdFx0XHRcdGNvbXBvbmVudCA9IGNvbXAgIT0gbnVsbCAmJiAodHlwZW9mIGNvbXAudmlldyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBjb21wID09PSBcImZ1bmN0aW9uXCIpPyBjb21wIDogXCJkaXZcIlxuXHRcdFx0XHRhdHRyczMgPSBwYXJhbXMsIGN1cnJlbnRQYXRoID0gcGF0aCwgbGFzdFVwZGF0ZSA9IG51bGxcblx0XHRcdFx0cmVuZGVyMSA9IChyb3V0ZVJlc29sdmVyLnJlbmRlciB8fCBpZGVudGl0eSkuYmluZChyb3V0ZVJlc29sdmVyKVxuXHRcdFx0XHRydW4xKClcblx0XHRcdH1cblx0XHRcdGlmIChwYXlsb2FkLnZpZXcgfHwgdHlwZW9mIHBheWxvYWQgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlKHt9LCBwYXlsb2FkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChwYXlsb2FkLm9ubWF0Y2gpIHtcblx0XHRcdFx0XHRQcm9taXNlLnJlc29sdmUocGF5bG9hZC5vbm1hdGNoKHBhcmFtcywgcGF0aCkpLnRoZW4oZnVuY3Rpb24ocmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZShwYXlsb2FkLCByZXNvbHZlZClcblx0XHRcdFx0XHR9LCBiYWlsKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdXBkYXRlKHBheWxvYWQsIFwiZGl2XCIpXG5cdFx0XHR9XG5cdFx0fSwgYmFpbClcblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMSlcblx0fVxuXHRyb3V0ZS5zZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0aWYgKGxhc3RVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblx0XHRcdG9wdGlvbnMucmVwbGFjZSA9IHRydWVcblx0XHR9XG5cdFx0bGFzdFVwZGF0ZSA9IG51bGxcblx0XHRyb3V0ZVNlcnZpY2Uuc2V0UGF0aChwYXRoLCBkYXRhLCBvcHRpb25zKVxuXHR9XG5cdHJvdXRlLmdldCA9IGZ1bmN0aW9uKCkge3JldHVybiBjdXJyZW50UGF0aH1cblx0cm91dGUucHJlZml4ID0gZnVuY3Rpb24ocHJlZml4MCkge3JvdXRlU2VydmljZS5wcmVmaXggPSBwcmVmaXgwfVxuXHRyb3V0ZS5saW5rID0gZnVuY3Rpb24odm5vZGUxKSB7XG5cdFx0dm5vZGUxLmRvbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHJvdXRlU2VydmljZS5wcmVmaXggKyB2bm9kZTEuYXR0cnMuaHJlZilcblx0XHR2bm9kZTEuZG9tLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDIpIHJldHVyblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHR2YXIgaHJlZiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuXHRcdFx0aWYgKGhyZWYuaW5kZXhPZihyb3V0ZVNlcnZpY2UucHJlZml4KSA9PT0gMCkgaHJlZiA9IGhyZWYuc2xpY2Uocm91dGVTZXJ2aWNlLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRyb3V0ZS5zZXQoaHJlZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdHJvdXRlLnBhcmFtID0gZnVuY3Rpb24oa2V5Mykge1xuXHRcdGlmKHR5cGVvZiBhdHRyczMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGtleTMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBhdHRyczNba2V5M11cblx0XHRyZXR1cm4gYXR0cnMzXG5cdH1cblx0cmV0dXJuIHJvdXRlXG59XG5tLnJvdXRlID0gXzIwKHdpbmRvdywgcmVkcmF3U2VydmljZSlcbm0ud2l0aEF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSwgY2FsbGJhY2sxLCBjb250ZXh0KSB7XG5cdHJldHVybiBmdW5jdGlvbihlKSB7XG5cdFx0Y2FsbGJhY2sxLmNhbGwoY29udGV4dCB8fCB0aGlzLCBhdHRyTmFtZSBpbiBlLmN1cnJlbnRUYXJnZXQgPyBlLmN1cnJlbnRUYXJnZXRbYXR0ck5hbWVdIDogZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpXG5cdH1cbn1cbnZhciBfMjggPSBjb3JlUmVuZGVyZXIod2luZG93KVxubS5yZW5kZXIgPSBfMjgucmVuZGVyXG5tLnJlZHJhdyA9IHJlZHJhd1NlcnZpY2UucmVkcmF3XG5tLnJlcXVlc3QgPSByZXF1ZXN0U2VydmljZS5yZXF1ZXN0XG5tLmpzb25wID0gcmVxdWVzdFNlcnZpY2UuanNvbnBcbm0ucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmdcbm0uYnVpbGRRdWVyeVN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmdcbm0udmVyc2lvbiA9IFwiMS4xLjZcIlxubS52bm9kZSA9IFZub2RlXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IG1cbmVsc2Ugd2luZG93Lm0gPSBtXG59KCkpOyIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVuZGVyL3JlbmRlclwiKSh3aW5kb3cpXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgVm5vZGUgPSByZXF1aXJlKFwiLi4vcmVuZGVyL3Zub2RlXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXR0cnMsIGNoaWxkcmVuKSB7XG5cdHJldHVybiBWbm9kZShcIltcIiwgYXR0cnMua2V5LCBhdHRycywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxudmFyIHNlbGVjdG9yUGFyc2VyID0gLyg/OihefCN8XFwuKShbXiNcXC5cXFtcXF1dKykpfChcXFsoLis/KSg/Olxccyo9XFxzKihcInwnfCkoKD86XFxcXFtcIidcXF1dfC4pKj8pXFw1KT9cXF0pL2dcbnZhciBzZWxlY3RvckNhY2hlID0ge31cbnZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuXHRmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBpZiAoaGFzT3duLmNhbGwob2JqZWN0LCBrZXkpKSByZXR1cm4gZmFsc2Vcblx0cmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG5cdHZhciBtYXRjaCwgdGFnID0gXCJkaXZcIiwgY2xhc3NlcyA9IFtdLCBhdHRycyA9IHt9XG5cdHdoaWxlIChtYXRjaCA9IHNlbGVjdG9yUGFyc2VyLmV4ZWMoc2VsZWN0b3IpKSB7XG5cdFx0dmFyIHR5cGUgPSBtYXRjaFsxXSwgdmFsdWUgPSBtYXRjaFsyXVxuXHRcdGlmICh0eXBlID09PSBcIlwiICYmIHZhbHVlICE9PSBcIlwiKSB0YWcgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiI1wiKSBhdHRycy5pZCA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIuXCIpIGNsYXNzZXMucHVzaCh2YWx1ZSlcblx0XHRlbHNlIGlmIChtYXRjaFszXVswXSA9PT0gXCJbXCIpIHtcblx0XHRcdHZhciBhdHRyVmFsdWUgPSBtYXRjaFs2XVxuXHRcdFx0aWYgKGF0dHJWYWx1ZSkgYXR0clZhbHVlID0gYXR0clZhbHVlLnJlcGxhY2UoL1xcXFwoW1wiJ10pL2csIFwiJDFcIikucmVwbGFjZSgvXFxcXFxcXFwvZywgXCJcXFxcXCIpXG5cdFx0XHRpZiAobWF0Y2hbNF0gPT09IFwiY2xhc3NcIikgY2xhc3Nlcy5wdXNoKGF0dHJWYWx1ZSlcblx0XHRcdGVsc2UgYXR0cnNbbWF0Y2hbNF1dID0gYXR0clZhbHVlID09PSBcIlwiID8gYXR0clZhbHVlIDogYXR0clZhbHVlIHx8IHRydWVcblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzZXMubGVuZ3RoID4gMCkgYXR0cnMuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKVxuXHRyZXR1cm4gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gPSB7dGFnOiB0YWcsIGF0dHJzOiBhdHRyc31cbn1cblxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cblx0aWYgKCFpc0VtcHR5KHN0YXRlLmF0dHJzKSAmJiAhaXNFbXB0eShhdHRycykpIHtcblx0XHR2YXIgbmV3QXR0cnMgPSB7fVxuXG5cdFx0Zm9yKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSkge1xuXHRcdFx0XHRuZXdBdHRyc1trZXldID0gYXR0cnNba2V5XVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGF0dHJzID0gbmV3QXR0cnNcblx0fVxuXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblxuXHRpZiAoY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoYXR0cnMuY2xhc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXR0cnMuY2xhc3MgPSB1bmRlZmluZWRcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuXHRcdH1cblxuXHRcdGlmIChzdGF0ZS5hdHRycy5jbGFzc05hbWUgIT0gbnVsbCkge1xuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gc3RhdGUuYXR0cnMuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWVcblx0XHR9XG5cdH1cblxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cblx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSAhPSBudWxsICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCIjXCIpIHtcblx0XHR0ZXh0ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0fSBlbHNlIHtcblx0XHRjaGlsZExpc3QgPSBjaGlsZHJlblxuXHR9XG5cblx0cmV0dXJuIFZub2RlKHN0YXRlLnRhZywgYXR0cnMua2V5LCBoYXNBdHRycyA/IGF0dHJzIDogdW5kZWZpbmVkLCBjaGlsZExpc3QsIHRleHQpXG59XG5cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cblx0aWYgKHNlbGVjdG9yID09IG51bGwgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxlY3Rvci52aWV3ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR0aHJvdyBFcnJvcihcIlRoZSBzZWxlY3RvciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGNvbXBvbmVudC5cIik7XG5cdH1cblxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dmFyIGNhY2hlZCA9IHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdIHx8IGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcilcblx0fVxuXG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSBzdGFydCArIDEpIHtcblx0XHRjaGlsZHJlbiA9IGFyZ3VtZW50c1tzdGFydF1cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSBjaGlsZHJlbiA9IFtjaGlsZHJlbl1cblx0fSBlbHNlIHtcblx0XHRjaGlsZHJlbiA9IFtdXG5cdFx0d2hpbGUgKHN0YXJ0IDwgYXJndW1lbnRzLmxlbmd0aCkgY2hpbGRyZW4ucHVzaChhcmd1bWVudHNbc3RhcnQrK10pXG5cdH1cblxuXHR2YXIgbm9ybWFsaXplZCA9IFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKVxuXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwZXJzY3JpcHRcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciAkZG9jID0gJHdpbmRvdy5kb2N1bWVudFxuXHR2YXIgJGVtcHR5RnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXG5cdHZhciBuYW1lU3BhY2UgPSB7XG5cdFx0c3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG5cdFx0bWF0aDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCJcblx0fVxuXG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXG5cdGZ1bmN0aW9uIGdldE5hbWVTcGFjZSh2bm9kZSkge1xuXHRcdHJldHVybiB2bm9kZS5hdHRycyAmJiB2bm9kZS5hdHRycy54bWxucyB8fCBuYW1lU3BhY2Vbdm5vZGUudGFnXVxuXHR9XG5cblx0Ly9jcmVhdGVcblx0ZnVuY3Rpb24gY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAodHlwZW9mIHRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHN3aXRjaCAodGFnKSB7XG5cdFx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiPFwiOiByZXR1cm4gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIltcIjogcmV0dXJuIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGRlZmF1bHQ6IHJldHVybiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2bm9kZS5kb20gPSAkZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLmNoaWxkcmVuKVxuXHRcdGluc2VydE5vZGUocGFyZW50LCB2bm9kZS5kb20sIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2hbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXG5cdFx0dGVtcC5pbm5lckhUTUwgPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IHRlbXAuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSB0ZW1wLmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHR2YXIgY2hpbGRcblx0XHR3aGlsZSAoY2hpbGQgPSB0ZW1wLmZpcnN0Q2hpbGQpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0Y3JlYXRlTm9kZXMoZnJhZ21lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gZnJhZ21lbnQuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdHZhciBhdHRycyA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMgJiYgYXR0cnMuaXNcblxuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBucyA/XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpIDpcblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50KHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50KHRhZylcblx0XHR2bm9kZS5kb20gPSBlbGVtZW50XG5cblx0XHRpZiAoYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzLCBucylcblx0XHR9XG5cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXG5cdC8vdXBkYXRlXG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLCB2bm9kZXMsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGlmIChvbGQgPT09IHZub2RlcyB8fCBvbGQgPT0gbnVsbCAmJiB2bm9kZXMgPT0gbnVsbCkgcmV0dXJuXG5cdFx0ZWxzZSBpZiAob2xkID09IG51bGwpIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCAwLCB2bm9kZXMubGVuZ3RoLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cblx0XHRcdHZhciBvbGRTdGFydCA9IDAsIHN0YXJ0ID0gMCwgb2xkRW5kID0gb2xkLmxlbmd0aCAtIDEsIGVuZCA9IHZub2Rlcy5sZW5ndGggLSAxLCBtYXBcblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZFN0YXJ0XSwgdiA9IHZub2Rlc1tzdGFydF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZFN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRTdGFydCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0b2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF1cblx0XHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0XHRpZiAocmVjeWNsaW5nIHx8IHN0YXJ0IDwgZW5kKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0b2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdLCB2ID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGlmIChvLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG8uZG9tXG5cdFx0XHRcdFx0b2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCFtYXApIG1hcCA9IGdldEtleU1hcChvbGQsIG9sZEVuZClcblx0XHRcdFx0XHRpZiAodiAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHR2YXIgb2xkSW5kZXggPSBtYXBbdi5rZXldXG5cdFx0XHRcdFx0XHRpZiAob2xkSW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbW92YWJsZSA9IG9sZFtvbGRJbmRleF1cblx0XHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEluZGV4ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG1vdmFibGUsIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobW92YWJsZSksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRvbGRbb2xkSW5kZXhdLnNraXAgPSB0cnVlXG5cdFx0XHRcdFx0XHRcdGlmIChtb3ZhYmxlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG1vdmFibGUuZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRvbSA9IGNyZWF0ZU5vZGUocGFyZW50LCB2LCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRuZXh0U2libGluZyA9IGRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbmQgPCBzdGFydCkgYnJlYWtcblx0XHRcdH1cblx0XHRcdGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kICsgMSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdHJlbW92ZU5vZGVzKG9sZCwgb2xkU3RhcnQsIG9sZEVuZCArIDEsIHZub2Rlcylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTm9kZShwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdHZhciBvbGRUYWcgPSBvbGQudGFnLCB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAob2xkVGFnID09PSB0YWcpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gb2xkLnN0YXRlXG5cdFx0XHR2bm9kZS5fc3RhdGUgPSBvbGQuX3N0YXRlXG5cdFx0XHR2bm9kZS5ldmVudHMgPSBvbGQuZXZlbnRzXG5cdFx0XHRpZiAoIXJlY3ljbGluZyAmJiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkpIHJldHVyblxuXHRcdFx0aWYgKHR5cGVvZiBvbGRUYWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRcdFx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoIChvbGRUYWcpIHtcblx0XHRcdFx0XHRjYXNlIFwiI1wiOiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCI8XCI6IHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBuZXh0U2libGluZyk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIltcIjogdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpOyBicmVha1xuXHRcdFx0XHRcdGRlZmF1bHQ6IHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLCBudWxsKVxuXHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuLnRvU3RyaW5nKCkgIT09IHZub2RlLmNoaWxkcmVuLnRvU3RyaW5nKCkpIHtcblx0XHRcdG9sZC5kb20ubm9kZVZhbHVlID0gdm5vZGUuY2hpbGRyZW5cblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4gIT09IHZub2RlLmNoaWxkcmVuKSB7XG5cdFx0XHR0b0ZyYWdtZW50KG9sZClcblx0XHRcdGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHRcdGVsc2Ugdm5vZGUuZG9tID0gb2xkLmRvbSwgdm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHR1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHR2YXIgZG9tU2l6ZSA9IDAsIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSBudWxsXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuZG9tICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAodm5vZGUuZG9tID09IG51bGwpIHZub2RlLmRvbSA9IGNoaWxkLmRvbVxuXHRcdFx0XHRcdGRvbVNpemUgKz0gY2hpbGQuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkb21TaXplICE9PSAxKSB2bm9kZS5kb21TaXplID0gZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZSBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkgPSB2bm9kZS5rZXlcblx0XHRcdFx0aWYgKGtleSAhPSBudWxsKSBtYXBba2V5XSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQgPSB2bm9kZS5kb21TaXplXG5cdFx0aWYgKGNvdW50ICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQpIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0ZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGRvbSwgZnJhZ21lbnQuZmlyc3RDaGlsZClcblx0XHRcdH1cblx0XHRcdHJldHVybiBmcmFnbWVudFxuXHRcdH1cblx0XHRlbHNlIHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBnZXROZXh0U2libGluZyh2bm9kZXMsIGksIG5leHRTaWJsaW5nKSB7XG5cdFx0Zm9yICg7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiB2bm9kZXNbaV0uZG9tICE9IG51bGwpIHJldHVybiB2bm9kZXNbaV0uZG9tXG5cdFx0fVxuXHRcdHJldHVybiBuZXh0U2libGluZ1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblxuXHQvL3JlbW92ZVxuXHRmdW5jdGlvbiByZW1vdmVOb2Rlcyh2bm9kZXMsIHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUuc2tpcCkgdm5vZGUuc2tpcCA9IGZhbHNlXG5cdFx0XHRcdGVsc2UgcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dClcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dCkge1xuXHRcdHZhciBleHBlY3RlZCA9IDEsIGNhbGxlZCA9IDBcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGludWF0aW9uKClcblx0XHRmdW5jdGlvbiBjb250aW51YXRpb24oKSB7XG5cdFx0XHRpZiAoKytjYWxsZWQgPT09IGV4cGVjdGVkKSB7XG5cdFx0XHRcdG9ucmVtb3ZlKHZub2RlKVxuXHRcdFx0XHRpZiAodm5vZGUuZG9tKSB7XG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQpIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00oZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTSh2bm9kZS5kb20pXG5cdFx0XHRcdFx0aWYgKGNvbnRleHQgIT0gbnVsbCAmJiB2bm9kZS5kb21TaXplID09IG51bGwgJiYgIWhhc0ludGVncmF0aW9uTWV0aG9kcyh2bm9kZS5hdHRycykgJiYgdHlwZW9mIHZub2RlLnRhZyA9PT0gXCJzdHJpbmdcIikgeyAvL1RPRE8gdGVzdCBjdXN0b20gZWxlbWVudHNcblx0XHRcdFx0XHRcdGlmICghY29udGV4dC5wb29sKSBjb250ZXh0LnBvb2wgPSBbdm5vZGVdXG5cdFx0XHRcdFx0XHRlbHNlIGNvbnRleHQucG9vbC5wdXNoKHZub2RlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlRnJvbURPTShub2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZVxuXHRcdGlmIChwYXJlbnQgIT0gbnVsbCkgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpXG5cdH1cblx0ZnVuY3Rpb24gb25yZW1vdmUodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLmF0dHJzLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpZiAodHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwpIG9ucmVtb3ZlKGNoaWxkKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly9hdHRyc1xuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMsIG5zKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXksIG51bGwsIGF0dHJzW2tleV0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXksIG9sZCwgdmFsdWUsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHRpZiAoa2V5ID09PSBcImtleVwiIHx8IGtleSA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleSkpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNMaWZlY3ljbGVNZXRob2Qoa2V5KSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5LmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5LnN1YnN0cigwLCBuc0xhc3RJbmRleCkgPT09IFwieGxpbmtcIikge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwga2V5LnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXlbMF0gPT09IFwib1wiICYmIGtleVsxXSA9PT0gXCJuXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXksIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleSBpbiBlbGVtZW50ICYmICFpc0F0dHJpYnV0ZShrZXkpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkgPT09IFwidmFsdWVcIikge1xuXHRcdFx0XHR2YXIgbm9ybWFsaXplZCA9IFwiXCIgKyB2YWx1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG5cdFx0XHRcdC8vc2V0dGluZyBpbnB1dFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSBieSB0eXBpbmcgb24gZm9jdXNlZCBlbGVtZW50IG1vdmVzIGN1cnNvciB0byBlbmQgaW4gQ2hyb21lXG5cdFx0XHRcdGlmICgodm5vZGUudGFnID09PSBcImlucHV0XCIgfHwgdm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vc2V0dGluZyBvcHRpb25bdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYgb2xkICE9IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkKSByZXR1cm5cblx0XHRcdH1cblx0XHRcdC8vIElmIHlvdSBhc3NpZ24gYW4gaW5wdXQgdHlwZSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5ID09PSBcInR5cGVcIikge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5XSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG5cdFx0XHRcdGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXksIHZhbHVlKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRMYXRlQXR0cnModm5vZGUpIHtcblx0XHR2YXIgYXR0cnMgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRycykgc2V0QXR0cih2bm9kZSwgXCJ2YWx1ZVwiLCBudWxsLCBhdHRycy52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMuc2VsZWN0ZWRJbmRleCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyh2bm9kZSwgb2xkLCBhdHRycywgbnMpIHtcblx0XHRpZiAoYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleSwgb2xkICYmIG9sZFtrZXldLCBhdHRyc1trZXldLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb2xkKSB7XG5cdFx0XHRcdGlmIChhdHRycyA9PSBudWxsIHx8ICEoa2V5IGluIGF0dHJzKSkge1xuXHRcdFx0XHRcdGlmIChrZXkgPT09IFwiY2xhc3NOYW1lXCIpIGtleSA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXlbMF0gPT09IFwib1wiICYmIGtleVsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleSkpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXksIHVuZGVmaW5lZClcblx0XHRcdFx0XHRlbHNlIGlmIChrZXkgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXG5cdC8vc3R5bGVcblx0ZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCBzdHlsZSkge1xuXHRcdGlmIChvbGQgPT09IHN0eWxlKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiLCBvbGQgPSBudWxsXG5cdFx0aWYgKHN0eWxlID09IG51bGwpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRlbHNlIGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZCA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5XSA9IHN0eWxlW2tleV1cblx0XHRcdH1cblx0XHRcdGlmIChvbGQgIT0gbnVsbCAmJiB0eXBlb2Ygb2xkICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleV0gPSBcIlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXksIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkgaW4gZWxlbWVudCkgZWxlbWVudFtrZXldID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5XSA9PT0gY2FsbGJhY2spIHJldHVyblxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXldICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXldLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5XSA9IGNhbGxiYWNrXG5cdFx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXldLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXIoZG9tLCB2bm9kZXMpIHtcblx0XHRpZiAoIWRvbSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCBiZWluZyBwYXNzZWQgdG8gbS5yb3V0ZS9tLm1vdW50L20ucmVuZGVyIGlzIG5vdCB1bmRlZmluZWQuXCIpXG5cdFx0dmFyIGhvb2tzID0gW11cblx0XHR2YXIgYWN0aXZlID0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGRvbS5uYW1lc3BhY2VVUklcblxuXHRcdC8vIEZpcnN0IHRpbWUgcmVuZGVyaW5nIGludG8gYSBub2RlIGNsZWFycyBpdCBvdXRcblx0XHRpZiAoZG9tLnZub2RlcyA9PSBudWxsKSBkb20udGV4dENvbnRlbnQgPSBcIlwiXG5cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodm5vZGVzKSkgdm5vZGVzID0gW3Zub2Rlc11cblx0XHR1cGRhdGVOb2Rlcyhkb20sIGRvbS52bm9kZXMsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlcyksIGZhbHNlLCBob29rcywgbnVsbCwgbmFtZXNwYWNlID09PSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZSlcblx0XHRkb20udm5vZGVzID0gdm5vZGVzXG5cdFx0Ly8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gcmV0dXJuIG51bGwgaW4gSUUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2FjdGl2ZUVsZW1lbnRcblx0XHRpZiAoYWN0aXZlICE9IG51bGwgJiYgJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykgaG9va3NbaV0oKVxuXHR9XG5cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihodG1sKSB7XG5cdGlmIChodG1sID09IG51bGwpIGh0bWwgPSBcIlwiXG5cdHJldHVybiBWbm9kZShcIjxcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGh0bWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gVm5vZGUodGFnLCBrZXksIGF0dHJzLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dDogdGV4dCwgZG9tOiBkb20sIGRvbVNpemU6IHVuZGVmaW5lZCwgc3RhdGU6IHVuZGVmaW5lZCwgX3N0YXRlOiB1bmRlZmluZWQsIGV2ZW50czogdW5kZWZpbmVkLCBpbnN0YW5jZTogdW5kZWZpbmVkLCBza2lwOiBmYWxzZX1cbn1cblZub2RlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBWbm9kZShcIltcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKG5vZGUpLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0aWYgKG5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIFZub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9kZSA9PT0gZmFsc2UgPyBcIlwiIDogbm9kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdHJldHVybiBub2RlXG59XG5Wbm9kZS5ub3JtYWxpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZHJlbltpXSA9IFZub2RlLm5vcm1hbGl6ZShjaGlsZHJlbltpXSlcblx0fVxuXHRyZXR1cm4gY2hpbGRyZW5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWbm9kZVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zdHJlYW0vc3RyZWFtXCIpXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBndWlkID0gMCwgSEFMVCA9IHt9XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW0oKSB7XG5cdGZ1bmN0aW9uIHN0cmVhbSgpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSBIQUxUKSB1cGRhdGVTdHJlYW0oc3RyZWFtLCBhcmd1bWVudHNbMF0pXG5cdFx0cmV0dXJuIHN0cmVhbS5fc3RhdGUudmFsdWVcblx0fVxuXHRpbml0U3RyZWFtKHN0cmVhbSlcblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSBIQUxUKSB1cGRhdGVTdHJlYW0oc3RyZWFtLCBhcmd1bWVudHNbMF0pXG5cblx0cmV0dXJuIHN0cmVhbVxufVxuZnVuY3Rpb24gaW5pdFN0cmVhbShzdHJlYW0pIHtcblx0c3RyZWFtLmNvbnN0cnVjdG9yID0gY3JlYXRlU3RyZWFtXG5cdHN0cmVhbS5fc3RhdGUgPSB7aWQ6IGd1aWQrKywgdmFsdWU6IHVuZGVmaW5lZCwgc3RhdGU6IDAsIGRlcml2ZTogdW5kZWZpbmVkLCByZWNvdmVyOiB1bmRlZmluZWQsIGRlcHM6IHt9LCBwYXJlbnRzOiBbXSwgZW5kU3RyZWFtOiB1bmRlZmluZWQsIHVucmVnaXN0ZXI6IHVuZGVmaW5lZH1cblx0c3RyZWFtLm1hcCA9IHN0cmVhbVtcImZhbnRhc3ktbGFuZC9tYXBcIl0gPSBtYXAsIHN0cmVhbVtcImZhbnRhc3ktbGFuZC9hcFwiXSA9IGFwLCBzdHJlYW1bXCJmYW50YXN5LWxhbmQvb2ZcIl0gPSBjcmVhdGVTdHJlYW1cblx0c3RyZWFtLnZhbHVlT2YgPSB2YWx1ZU9mLCBzdHJlYW0udG9KU09OID0gdG9KU09OLCBzdHJlYW0udG9TdHJpbmcgPSB2YWx1ZU9mXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyZWFtLCB7XG5cdFx0ZW5kOiB7Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghc3RyZWFtLl9zdGF0ZS5lbmRTdHJlYW0pIHtcblx0XHRcdFx0dmFyIGVuZFN0cmVhbSA9IGNyZWF0ZVN0cmVhbSgpXG5cdFx0XHRcdGVuZFN0cmVhbS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdHVucmVnaXN0ZXJTdHJlYW0oc3RyZWFtKVxuXHRcdFx0XHRcdFx0ZW5kU3RyZWFtLl9zdGF0ZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24oKXt1bnJlZ2lzdGVyU3RyZWFtKGVuZFN0cmVhbSl9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRzdHJlYW0uX3N0YXRlLmVuZFN0cmVhbSA9IGVuZFN0cmVhbVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cmVhbS5fc3RhdGUuZW5kU3RyZWFtXG5cdFx0fX1cblx0fSlcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0cmVhbShzdHJlYW0sIHZhbHVlKSB7XG5cdHVwZGF0ZVN0YXRlKHN0cmVhbSwgdmFsdWUpXG5cdGZvciAodmFyIGlkIGluIHN0cmVhbS5fc3RhdGUuZGVwcykgdXBkYXRlRGVwZW5kZW5jeShzdHJlYW0uX3N0YXRlLmRlcHNbaWRdLCBmYWxzZSlcblx0aWYgKHN0cmVhbS5fc3RhdGUudW5yZWdpc3RlciAhPSBudWxsKSBzdHJlYW0uX3N0YXRlLnVucmVnaXN0ZXIoKVxuXHRmaW5hbGl6ZShzdHJlYW0pXG59XG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShzdHJlYW0sIHZhbHVlKSB7XG5cdHN0cmVhbS5fc3RhdGUudmFsdWUgPSB2YWx1ZVxuXHRzdHJlYW0uX3N0YXRlLmNoYW5nZWQgPSB0cnVlXG5cdGlmIChzdHJlYW0uX3N0YXRlLnN0YXRlICE9PSAyKSBzdHJlYW0uX3N0YXRlLnN0YXRlID0gMVxufVxuZnVuY3Rpb24gdXBkYXRlRGVwZW5kZW5jeShzdHJlYW0sIG11c3RTeW5jKSB7XG5cdHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGUsIHBhcmVudHMgPSBzdGF0ZS5wYXJlbnRzXG5cdGlmIChwYXJlbnRzLmxlbmd0aCA+IDAgJiYgcGFyZW50cy5ldmVyeShhY3RpdmUpICYmIChtdXN0U3luYyB8fCBwYXJlbnRzLnNvbWUoY2hhbmdlZCkpKSB7XG5cdFx0dmFyIHZhbHVlID0gc3RyZWFtLl9zdGF0ZS5kZXJpdmUoKVxuXHRcdGlmICh2YWx1ZSA9PT0gSEFMVCkgcmV0dXJuIGZhbHNlXG5cdFx0dXBkYXRlU3RhdGUoc3RyZWFtLCB2YWx1ZSlcblx0fVxufVxuZnVuY3Rpb24gZmluYWxpemUoc3RyZWFtKSB7XG5cdHN0cmVhbS5fc3RhdGUuY2hhbmdlZCA9IGZhbHNlXG5cdGZvciAodmFyIGlkIGluIHN0cmVhbS5fc3RhdGUuZGVwcykgc3RyZWFtLl9zdGF0ZS5kZXBzW2lkXS5fc3RhdGUuY2hhbmdlZCA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbWJpbmUoZm4sIHN0cmVhbXMpIHtcblx0aWYgKCFzdHJlYW1zLmV2ZXJ5KHZhbGlkKSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoYXQgZWFjaCBpdGVtIHBhc3NlZCB0byBzdHJlYW0uY29tYmluZS9zdHJlYW0ubWVyZ2UgaXMgYSBzdHJlYW1cIilcblx0cmV0dXJuIGluaXREZXBlbmRlbmN5KGNyZWF0ZVN0cmVhbSgpLCBzdHJlYW1zLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgc3RyZWFtcy5jb25jYXQoW3N0cmVhbXMuZmlsdGVyKGNoYW5nZWQpXSkpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGluaXREZXBlbmRlbmN5KGRlcCwgc3RyZWFtcywgZGVyaXZlKSB7XG5cdHZhciBzdGF0ZSA9IGRlcC5fc3RhdGVcblx0c3RhdGUuZGVyaXZlID0gZGVyaXZlXG5cdHN0YXRlLnBhcmVudHMgPSBzdHJlYW1zLmZpbHRlcihub3RFbmRlZClcblxuXHRyZWdpc3RlckRlcGVuZGVuY3koZGVwLCBzdGF0ZS5wYXJlbnRzKVxuXHR1cGRhdGVEZXBlbmRlbmN5KGRlcCwgdHJ1ZSlcblxuXHRyZXR1cm4gZGVwXG59XG5mdW5jdGlvbiByZWdpc3RlckRlcGVuZGVuY3koc3RyZWFtLCBwYXJlbnRzKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHBhcmVudHNbaV0uX3N0YXRlLmRlcHNbc3RyZWFtLl9zdGF0ZS5pZF0gPSBzdHJlYW1cblx0XHRyZWdpc3RlckRlcGVuZGVuY3koc3RyZWFtLCBwYXJlbnRzW2ldLl9zdGF0ZS5wYXJlbnRzKVxuXHR9XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyU3RyZWFtKHN0cmVhbSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0cmVhbS5fc3RhdGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBwYXJlbnQgPSBzdHJlYW0uX3N0YXRlLnBhcmVudHNbaV1cblx0XHRkZWxldGUgcGFyZW50Ll9zdGF0ZS5kZXBzW3N0cmVhbS5fc3RhdGUuaWRdXG5cdH1cblx0Zm9yICh2YXIgaWQgaW4gc3RyZWFtLl9zdGF0ZS5kZXBzKSB7XG5cdFx0dmFyIGRlcGVuZGVudCA9IHN0cmVhbS5fc3RhdGUuZGVwc1tpZF1cblx0XHR2YXIgaW5kZXggPSBkZXBlbmRlbnQuX3N0YXRlLnBhcmVudHMuaW5kZXhPZihzdHJlYW0pXG5cdFx0aWYgKGluZGV4ID4gLTEpIGRlcGVuZGVudC5fc3RhdGUucGFyZW50cy5zcGxpY2UoaW5kZXgsIDEpXG5cdH1cblx0c3RyZWFtLl9zdGF0ZS5zdGF0ZSA9IDIgLy9lbmRlZFxuXHRzdHJlYW0uX3N0YXRlLmRlcHMgPSB7fVxufVxuXG5mdW5jdGlvbiBtYXAoZm4pIHtyZXR1cm4gY29tYmluZShmdW5jdGlvbihzdHJlYW0pIHtyZXR1cm4gZm4oc3RyZWFtKCkpfSwgW3RoaXNdKX1cbmZ1bmN0aW9uIGFwKHN0cmVhbSkge3JldHVybiBjb21iaW5lKGZ1bmN0aW9uKHMxLCBzMikge3JldHVybiBzMSgpKHMyKCkpfSwgW3N0cmVhbSwgdGhpc10pfVxuZnVuY3Rpb24gdmFsdWVPZigpIHtyZXR1cm4gdGhpcy5fc3RhdGUudmFsdWV9XG5mdW5jdGlvbiB0b0pTT04oKSB7cmV0dXJuIHRoaXMuX3N0YXRlLnZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHRoaXMuX3N0YXRlLnZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fc3RhdGUudmFsdWUudG9KU09OKCkgOiB0aGlzLl9zdGF0ZS52YWx1ZX1cblxuZnVuY3Rpb24gdmFsaWQoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUgfVxuZnVuY3Rpb24gYWN0aXZlKHN0cmVhbSkge3JldHVybiBzdHJlYW0uX3N0YXRlLnN0YXRlID09PSAxfVxuZnVuY3Rpb24gY2hhbmdlZChzdHJlYW0pIHtyZXR1cm4gc3RyZWFtLl9zdGF0ZS5jaGFuZ2VkfVxuZnVuY3Rpb24gbm90RW5kZWQoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUuc3RhdGUgIT09IDJ9XG5cbmZ1bmN0aW9uIG1lcmdlKHN0cmVhbXMpIHtcblx0cmV0dXJuIGNvbWJpbmUoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHN0cmVhbXMubWFwKGZ1bmN0aW9uKHMpIHtyZXR1cm4gcygpfSlcblx0fSwgc3RyZWFtcylcbn1cblxuZnVuY3Rpb24gc2NhbihyZWR1Y2VyLCBzZWVkLCBzdHJlYW0pIHtcblx0dmFyIG5ld1N0cmVhbSA9IGNvbWJpbmUoZnVuY3Rpb24gKHMpIHtcblx0XHRyZXR1cm4gc2VlZCA9IHJlZHVjZXIoc2VlZCwgcy5fc3RhdGUudmFsdWUpXG5cdH0sIFtzdHJlYW1dKVxuXG5cdGlmIChuZXdTdHJlYW0uX3N0YXRlLnN0YXRlID09PSAwKSBuZXdTdHJlYW0oc2VlZClcblxuXHRyZXR1cm4gbmV3U3RyZWFtXG59XG5cbmZ1bmN0aW9uIHNjYW5NZXJnZSh0dXBsZXMsIHNlZWQpIHtcblx0dmFyIHN0cmVhbXMgPSB0dXBsZXMubWFwKGZ1bmN0aW9uKHR1cGxlKSB7XG5cdFx0dmFyIHN0cmVhbSA9IHR1cGxlWzBdXG5cdFx0aWYgKHN0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDApIHN0cmVhbSh1bmRlZmluZWQpXG5cdFx0cmV0dXJuIHN0cmVhbVxuXHR9KVxuXG5cdHZhciBuZXdTdHJlYW0gPSBjb21iaW5lKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGFuZ2VkID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuXG5cdFx0c3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbSwgaWR4KSB7XG5cdFx0XHRpZiAoY2hhbmdlZC5pbmRleE9mKHN0cmVhbSkgPiAtMSkge1xuXHRcdFx0XHRzZWVkID0gdHVwbGVzW2lkeF1bMV0oc2VlZCwgc3RyZWFtLl9zdGF0ZS52YWx1ZSlcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0cmV0dXJuIHNlZWRcblx0fSwgc3RyZWFtcylcblxuXHRyZXR1cm4gbmV3U3RyZWFtXG59XG5cbmNyZWF0ZVN0cmVhbVtcImZhbnRhc3ktbGFuZC9vZlwiXSA9IGNyZWF0ZVN0cmVhbVxuY3JlYXRlU3RyZWFtLm1lcmdlID0gbWVyZ2VcbmNyZWF0ZVN0cmVhbS5jb21iaW5lID0gY29tYmluZVxuY3JlYXRlU3RyZWFtLnNjYW4gPSBzY2FuXG5jcmVhdGVTdHJlYW0uc2Nhbk1lcmdlID0gc2Nhbk1lcmdlXG5jcmVhdGVTdHJlYW0uSEFMVCA9IEhBTFRcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBjcmVhdGVTdHJlYW1cbmVsc2UgaWYgKHR5cGVvZiB3aW5kb3cubSA9PT0gXCJmdW5jdGlvblwiICYmICEoXCJzdHJlYW1cIiBpbiB3aW5kb3cubSkpIHdpbmRvdy5tLnN0cmVhbSA9IGNyZWF0ZVN0cmVhbVxuZWxzZSB3aW5kb3cubSA9IHtzdHJlYW0gOiBjcmVhdGVTdHJlYW19XG5cbn0oKSk7XG4iLCIvLyEgbW9tZW50LmpzXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICAgICAgbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBhcmdzWzBdID0geSArIDQwMDtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMgKHdzLCBuKSB7XG4gICAgICAgIHJldHVybiB3cy5zbGljZShuLCA3KS5jb25jYXQod3Muc2xpY2UoMCwgbikpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWyhtICYmIG0gIT09IHRydWUgJiYgdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpKSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgcmV0dXJuIChtID09PSB0cnVlKSA/IHNoaWZ0V2Vla2RheXMod2Vla2RheXMsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB3ZWVrZGF5c1ttLmRheSgpXSA6IHdlZWtkYXlzO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAvL3dhcm4gdXNlciBpZiBhcmd1bWVudHMgYXJlIHBhc3NlZCBidXQgdGhlIGxvY2FsZSBjb3VsZCBub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTG9jYWxlICcgKyBrZXkgKyAgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShjb25maWcucGFyZW50TG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCB0bXBMb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIGV4cGVjdGVkV2Vla2RheSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVEMgPyBjb25maWcuX2QuZ2V0VVRDRGF5KCkgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5KSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgdmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG9ic09mZnNldHMgPSB7XG4gICAgICAgIFVUOiAwLFxuICAgICAgICBHTVQ6IDAsXG4gICAgICAgIEVEVDogLTQgKiA2MCxcbiAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgIENTVDogLTYgKiA2MCxcbiAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgIFBEVDogLTcgKiA2MCxcbiAgICAgICAgUFNUOiAtOCAqIDYwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIobG9jYWxGcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKGxvY2FsVG8sIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzOyBicmVhazsgLy8gMTAwMFxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6IG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZTtcbiAgICAgICAgdmFyIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgICAgICB2YXIgem9uZSA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICAgICAgdmFyIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIE1TX1BFUl9TRUNPTkQgPSAxMDAwO1xuICAgIHZhciBNU19QRVJfTUlOVVRFID0gNjAgKiBNU19QRVJfU0VDT05EO1xuICAgIHZhciBNU19QRVJfSE9VUiA9IDYwICogTVNfUEVSX01JTlVURTtcbiAgICB2YXIgTVNfUEVSXzQwMF9ZRUFSUyA9ICgzNjUgKiA0MDAgKyA5NykgKiAyNCAqIE1TX1BFUl9IT1VSO1xuXG4gICAgLy8gYWN0dWFsIG1vZHVsbyAtIGhhbmRsZXMgbmVnYXRpdmUgbnVtYmVycyAoZm9yIGRhdGVzIGJlZm9yZSAxOTcwKTpcbiAgICBmdW5jdGlvbiBtb2QkMShkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gKGRpdmlkZW5kICUgZGl2aXNvciArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSAtIHRoaXMubW9udGgoKSAlIDMsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksIE1TX1BFUl9IT1VSKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB2YXIgdGltZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCkgKyAxLCAwLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSAtIHRoaXMubW9udGgoKSAlIDMgKyAzLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDcpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9IT1VSIC0gbW9kJDEodGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksIE1TX1BFUl9IT1VSKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9NSU5VVEUgLSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9TRUNPTkQgLSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICBwcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xuICAgIHByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBwcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBwcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuICAgIHByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOiAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOiAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNRdWFydGVycyAgICAgPSBtYWtlQXMoJ1EnKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGNsb25lJDEgKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgICAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcbiAgICAgICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IHltU2lnbiArIE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBobXNTaWduICsgaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xuICAgIHByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBwcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIHByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgcHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIHByb3RvJDIuYXNRdWFydGVycyAgICAgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG4gICAgcHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lICAgICAgICAgID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG4gICAgcHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBwcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgcHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI0LjAnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuICAgIGhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICBob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgIGhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcbiAgICBob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIGhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuICAgIGhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xuICAgIGhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuICAgIGhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgICAgIFRJTUU6ICdISDptbScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMiBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL3Jhdy9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIFdpdGggcGFydHMgYnkgVHlsZXIgQ2xvc2VcbiAqIENvcHlyaWdodCAyMDA3LTIwMDkgVHlsZXIgQ2xvc2UgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgWCBsaWNlbnNlIGZvdW5kXG4gKiBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWxcbiAqIEZvcmtlZCBhdCByZWZfc2VuZC5qcyB2ZXJzaW9uOiAyMDA5LTA1LTExXG4gKlxuICogV2l0aCBwYXJ0cyBieSBNYXJrIE1pbGxlclxuICogQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVGhpcyBmaWxlIHdpbGwgZnVuY3Rpb24gcHJvcGVybHkgYXMgYSA8c2NyaXB0PiB0YWcsIG9yIGEgbW9kdWxlXG4gICAgLy8gdXNpbmcgQ29tbW9uSlMgYW5kIE5vZGVKUyBvciBSZXF1aXJlSlMgbW9kdWxlIGZvcm1hdHMuICBJblxuICAgIC8vIENvbW1vbi9Ob2RlL1JlcXVpcmVKUywgdGhlIG1vZHVsZSBleHBvcnRzIHRoZSBRIEFQSSBhbmQgd2hlblxuICAgIC8vIGV4ZWN1dGVkIGFzIGEgc2ltcGxlIDxzY3JpcHQ+LCBpdCBjcmVhdGVzIGEgUSBnbG9iYWwgaW5zdGVhZC5cblxuICAgIC8vIE1vbnRhZ2UgUmVxdWlyZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9vdHN0cmFwKFwicHJvbWlzZVwiLCBkZWZpbml0aW9uKTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2VsZi5RID0gZGVmaW5pdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCB3YXMgbm90IGFudGljaWFwdGVkIGJ5IFEuIFBsZWFzZSBmaWxlIGEgYnVnLlwiKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB2YXIgdGFzayA9IGhlYWQudGFzaztcbiAgICAgICAgICAgIGhlYWQudGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBzeW5jaHJvbm91c2x5IHRvIGludGVycnVwdCBmbHVzaGluZyFcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgaW4gbmV4dCBldmVudCB0byBhdm9pZCB0aWNrIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBuZXh0VGljayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHRhaWwgPSB0YWlsLm5leHQgPSB7XG4gICAgICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICAgICAgZG9tYWluOiBpc05vZGVKUyAmJiBwcm9jZXNzLmRvbWFpbixcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICAgIC8vIE5vZGUuanMgYmVmb3JlIDAuOS4gTm90ZSB0aGF0IHNvbWUgZmFrZS1Ob2RlIGVudmlyb25tZW50cywgbGlrZSB0aGVcbiAgICAgICAgLy8gTW9jaGEgdGVzdCBydW5uZXIsIGludHJvZHVjZSBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2AuXG4gICAgICAgIGlzTm9kZUpTID0gdHJ1ZTtcblxuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gSW4gSUUxMCwgTm9kZS5qcyAwLjkrLCBvciBodHRwczovL2dpdGh1Yi5jb20vTm9ibGVKUy9zZXRJbW1lZGlhdGVcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gc2V0SW1tZWRpYXRlLmJpbmQod2luZG93LCBmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIC8vIEF0IGxlYXN0IFNhZmFyaSBWZXJzaW9uIDYuMC41ICg4NTM2LjMwLjEpIGludGVybWl0dGVudGx5IGNhbm5vdCBjcmVhdGVcbiAgICAgICAgLy8gd29ya2luZyBtZXNzYWdlIHBvcnRzIHRoZSBmaXJzdCB0aW1lIGEgcGFnZSBsb2Fkcy5cbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHJlcXVlc3RQb3J0VGljaztcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdFBvcnRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT3BlcmEgcmVxdWlyZXMgdXMgdG8gcHJvdmlkZSBhIG1lc3NhZ2UgcGF5bG9hZCwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSB1c2UgaXQuXG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgcmVxdWVzdFBvcnRUaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGQgYnJvd3NlcnNcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFRpY2s7XG59KSgpO1xuXG4vLyBBdHRlbXB0IHRvIG1ha2UgZ2VuZXJpY3Mgc2FmZSBpbiB0aGUgZmFjZSBvZiBkb3duc3RyZWFtXG4vLyBtb2RpZmljYXRpb25zLlxuLy8gVGhlcmUgaXMgbm8gc2l0dWF0aW9uIHdoZXJlIHRoaXMgaXMgbmVjZXNzYXJ5LlxuLy8gSWYgeW91IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsIHRoZXNlIHByaW1vcmRpYWxzIG5lZWQgdG8gYmVcbi8vIGRlZXBseSBmcm96ZW4gYW55d2F5LCBhbmQgaWYgeW91IGRvbuKAmXQgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSxcbi8vIHRoaXMgaXMganVzdCBwbGFpbiBwYXJhbm9pZC5cbi8vIEhvd2V2ZXIsIHRoaXMgKiptaWdodCoqIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemUgb2Zcbi8vIHRoZSBtaW5pZmllZCBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KClcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIGxvbmcgc3RhY2sgdHJhY2VzXG5cbnZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIjtcblxuZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUVxuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYHByb21pc2VgLiBTZWUgIzU3LlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgcHJvbWlzZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2sgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2suaW5kZXhPZihTVEFDS19KVU1QX1NFUEFSQVRPUikgPT09IC0xXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjaykge1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8vIGVuYWJsZSBsb25nIHN0YWNrcyBpZiBRX0RFQlVHIGlzIHNldFxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuUV9ERUJVRykge1xuICAgIFEubG9uZ1N0YWNrU3VwcG9ydCA9IHRydWU7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHtwcm9taXNlLCByZXNvbHZlLCByZWplY3R9IG9iamVjdC5cbiAqXG4gKiBgcmVzb2x2ZWAgaXMgYSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBhIG1vcmUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZVxuICogcHJvbWlzZS4gVG8gZnVsZmlsbCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGFueSB2YWx1ZSB0aGF0IGlzXG4gKiBub3QgYSB0aGVuYWJsZS4gVG8gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYSByZWplY3RlZFxuICogdGhlbmFibGUsIG9yIGludm9rZSBgcmVqZWN0YCB3aXRoIHRoZSByZWFzb24gZGlyZWN0bHkuIFRvIHJlc29sdmUgdGhlXG4gKiBwcm9taXNlIHRvIGFub3RoZXIgdGhlbmFibGUsIHRodXMgcHV0dGluZyBpdCBpbiB0aGUgc2FtZSBzdGF0ZSwgaW52b2tlXG4gKiBgcmVzb2x2ZWAgd2l0aCB0aGF0IG90aGVyIHRoZW5hYmxlLlxuICovXG5RLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICAvLyBpZiBcIm1lc3NhZ2VzXCIgaXMgYW4gXCJBcnJheVwiLCB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSBwcm9taXNlIGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiByZXNvbHZlZC4gIElmIGl0IGlzIFwidW5kZWZpbmVkXCIsIGl0IGhhcyBiZWVuIHJlc29sdmVkLiAgRWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIG1lc3NhZ2VzIGFycmF5IGlzIGl0c2VsZiBhbiBhcnJheSBvZiBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXNvbHZlZCBwcm9taXNlLiAgV2UgY29lcmNlIHRoZSByZXNvbHV0aW9uIHZhbHVlIHRvIGFcbiAgICAvLyBwcm9taXNlIHVzaW5nIHRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gYmVjYXVzZSBpdCBoYW5kbGVzIGJvdGggZnVsbHlcbiAgICAvLyBub24tdGhlbmFibGUgdmFsdWVzIGFuZCBvdGhlciB0aGVuYWJsZXMgZ3JhY2VmdWxseS5cbiAgICB2YXIgbWVzc2FnZXMgPSBbXSwgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSwgcmVzb2x2ZWRQcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gb2JqZWN0X2NyZWF0ZShkZWZlci5wcm90b3R5cGUpO1xuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgb3BlcmFuZHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goYXJncyk7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwid2hlblwiICYmIG9wZXJhbmRzWzFdKSB7IC8vIHByb2dyZXNzIG9wZXJhbmRcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVycy5wdXNoKG9wZXJhbmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyZXJWYWx1ZSA9IG5lYXJlcihyZXNvbHZlZFByb21pc2UpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKG5lYXJlclZhbHVlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmVhcmVyVmFsdWU7IC8vIHNob3J0ZW4gY2hhaW5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVyVmFsdWU7XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBlbmRpbmdcIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFByb21pc2UuaW5zcGVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvbid0IHRyeSB0byB1c2UgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCBvciB0cmFuc2ZlciB0aGVcbiAgICAgICAgICAgIC8vIGFjY2Vzc29yIGFyb3VuZDsgdGhhdCBjYXVzZXMgbWVtb3J5IGxlYWtzIGFzIHBlciBHSC0xMTEuIEp1c3RcbiAgICAgICAgICAgIC8vIHJlaWZ5IHRoZSBzdGFjayB0cmFjZSBhcyBhIHN0cmluZyBBU0FQLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUsIGN1dCBvZmYgdGhlIGZpcnN0IGxpbmU7IGl0J3MgYWx3YXlzIGp1c3RcbiAgICAgICAgICAgIC8vIFwiW29iamVjdCBQcm9taXNlXVxcblwiLCBhcyBwZXIgdGhlIGB0b1N0cmluZ2AuXG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuXG4gICAgICAgIGFycmF5X3JlZHVjZShtZXNzYWdlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLlByb21pc2UgPSBwcm9taXNlOyAvLyBFUzZcblEucHJvbWlzZSA9IHByb21pc2U7XG5mdW5jdGlvbiBwcm9taXNlKHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5wcm9taXNlLnJhY2UgPSByYWNlOyAvLyBFUzZcbnByb21pc2UuYWxsID0gYWxsOyAvLyBFUzZcbnByb21pc2UucmVqZWN0ID0gcmVqZWN0OyAvLyBFUzZcbnByb21pc2UucmVzb2x2ZSA9IFE7IC8vIEVTNlxuXG4vLyBYWFggZXhwZXJpbWVudGFsLiAgVGhpcyBtZXRob2QgaXMgYSB3YXkgdG8gZGVub3RlIHRoYXQgYSBsb2NhbCB2YWx1ZSBpc1xuLy8gc2VyaWFsaXphYmxlIGFuZCBzaG91bGQgYmUgaW1tZWRpYXRlbHkgZGlzcGF0Y2hlZCB0byBhIHJlbW90ZSB1cG9uIHJlcXVlc3QsXG4vLyBpbnN0ZWFkIG9mIHBhc3NpbmcgYSByZWZlcmVuY2UuXG5RLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucGFzc0J5Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0d28gcHJvbWlzZXMgZXZlbnR1YWxseSBmdWxmaWxsIHRvIHRoZSBzYW1lIHZhbHVlLCBwcm9taXNlcyB0aGF0IHZhbHVlLFxuICogYnV0IG90aGVyd2lzZSByZWplY3RzLlxuICogQHBhcmFtIHgge0FueSp9XG4gKiBAcGFyYW0geSB7QW55Kn1cbiAqIEByZXR1cm5zIHtBbnkqfSBhIHByb21pc2UgZm9yIHggYW5kIHkgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGJ1dCBhIHJlamVjdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqL1xuUS5qb2luID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gUSh4KS5qb2luKHkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgcmV0dXJuIFEoW3RoaXMsIHRoYXRdKS5zcHJlYWQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFwiPT09XCIgc2hvdWxkIGJlIE9iamVjdC5pcyBvciBlcXVpdlxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBqb2luOiBub3QgdGhlIHNhbWU6IFwiICsgeCArIFwiIFwiICsgeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBmaXJzdCBvZiBhbiBhcnJheSBvZiBwcm9taXNlcyB0byBiZWNvbWUgc2V0dGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIHNldHRsZWRcbiAqL1xuUS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoYW5zd2VyUHMpIHtcbiAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHRoaXMgb25jZSB3ZSBjYW4gYXNzdW1lIGF0IGxlYXN0IEVTNVxuICAgICAgICAvLyBhbnN3ZXJQcy5mb3JFYWNoKGZ1bmN0aW9uKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgZG9uZSA9IGZhbHNlOyAgIC8vIGVuc3VyZSB0aGUgdW50cnVzdGVkIHByb21pc2UgbWFrZXMgYXQgbW9zdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2FsbCB0byBvbmUgb2YgdGhlIGNhbGxiYWNrc1xuXG4gICAgZnVuY3Rpb24gX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0ZWQoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGV4Y2VwdGlvbiwgc2VsZik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZChleGNlcHRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFeGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcHJvZ3Jlc3NlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2dyZXNzZWQgPT09IFwiZnVuY3Rpb25cIiA/IHByb2dyZXNzZWQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5RLnRhcCA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRhcChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdvcmtzIGFsbW9zdCBsaWtlIFwiZmluYWxseVwiLCBidXQgbm90IGNhbGxlZCBmb3IgcmVqZWN0aW9ucy5cbiAqIE9yaWdpbmFsIHJlc29sdXRpb24gdmFsdWUgaXMgcGFzc2VkIHRocm91Z2ggY2FsbGJhY2sgdW5hZmZlY3RlZC5cbiAqIENhbGxiYWNrIG1heSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBhd2FpdGVkIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7US5Qcm9taXNlfVxuICogQGV4YW1wbGVcbiAqIGRvU29tZXRoaW5nKClcbiAqICAgLnRoZW4oLi4uKVxuICogICAudGFwKGNvbnNvbGUubG9nKVxuICogICAudGhlbiguLi4pO1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKHZhbHVlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuXG5RLmlzUHJvbWlzZUFsaWtlID0gaXNQcm9taXNlQWxpa2U7XG5mdW5jdGlvbiBpc1Byb21pc2VBbGlrZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwZW5kaW5nIHByb21pc2UsIG1lYW5pbmcgbm90XG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gKi9cblEuaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xuZnVuY3Rpb24gaXNQZW5kaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbHVlIG9yIGZ1bGZpbGxlZFxuICogcHJvbWlzZS5cbiAqL1xuUS5pc0Z1bGZpbGxlZCA9IGlzRnVsZmlsbGVkO1xuZnVuY3Rpb24gaXNGdWxmaWxsZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuICFpc1Byb21pc2Uob2JqZWN0KSB8fCBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cblEuaXNSZWplY3RlZCA9IGlzUmVqZWN0ZWQ7XG5mdW5jdGlvbiBpc1JlamVjdGVkKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59O1xuXG4vLy8vIEJFR0lOIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLy8gVGhpcyBwcm9taXNlIGxpYnJhcnkgY29uc3VtZXMgZXhjZXB0aW9ucyB0aHJvd24gaW4gaGFuZGxlcnMgc28gdGhleSBjYW4gYmVcbi8vIGhhbmRsZWQgYnkgYSBzdWJzZXF1ZW50IHByb21pc2UuICBUaGUgZXhjZXB0aW9ucyBnZXQgYWRkZWQgdG8gdGhpcyBhcnJheSB3aGVuXG4vLyB0aGV5IGFyZSBjcmVhdGVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZXkgYXJlIGhhbmRsZWQuICBOb3RlIHRoYXQgaW4gRVM2IG9yXG4vLyBzaGltbWVkIGVudmlyb25tZW50cywgdGhpcyB3b3VsZCBuYXR1cmFsbHkgYmUgYSBgU2V0YC5cbnZhciB1bmhhbmRsZWRSZWFzb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdCwgMSk7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICB9XG59XG5cblEucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zID0gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zO1xuXG5RLmdldFVuaGFuZGxlZFJlYXNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gdGhhdCBjb25zdW1lcnMgY2FuJ3QgaW50ZXJmZXJlIHdpdGggb3VyIGludGVybmFsIHN0YXRlLlxuICAgIHJldHVybiB1bmhhbmRsZWRSZWFzb25zLnNsaWNlKCk7XG59O1xuXG5RLnN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8qKlxuICogQW5ub3RhdGVzIGFuIG9iamVjdCBzdWNoIHRoYXQgaXQgd2lsbCBuZXZlciBiZVxuICogdHJhbnNmZXJyZWQgYXdheSBmcm9tIHRoaXMgcHJvY2VzcyBvdmVyIGFueSBwcm9taXNlXG4gKiBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBwcm9taXNlIGEgd3JhcHBpbmcgb2YgdGhhdCBvYmplY3QgdGhhdFxuICogYWRkaXRpb25hbGx5IHJlc3BvbmRzIHRvIHRoZSBcImlzRGVmXCIgbWVzc2FnZVxuICogd2l0aG91dCBhIHJlamVjdGlvbi5cbiAqL1xuUS5tYXN0ZXIgPSBtYXN0ZXI7XG5mdW5jdGlvbiBtYXN0ZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcImlzRGVmXCI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2sob3AsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFEob2JqZWN0KS5pbnNwZWN0KCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gc3ByZWFkO1xuZnVuY3Rpb24gc3ByZWFkKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnNwcmVhZChmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkLmFwcGx5KHZvaWQgMCwgYXJyYXkpO1xuICAgIH0sIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuICBBbHRob3VnaCBnZW5lcmF0b3JzIGFyZSBvbmx5IHBhcnRcbiAqIG9mIHRoZSBuZXdlc3QgRUNNQVNjcmlwdCA2IGRyYWZ0cywgdGhpcyBjb2RlIGRvZXMgbm90IGNhdXNlIHN5bnRheFxuICogZXJyb3JzIGluIG9sZGVyIGVuZ2luZXMuICBUaGlzIGNvZGUgc2hvdWxkIGNvbnRpbnVlIHRvIHdvcmsgYW5kIHdpbGxcbiAqIGluIGZhY3QgaW1wcm92ZSBvdmVyIHRpbWUgYXMgdGhlIGxhbmd1YWdlIGltcHJvdmVzLlxuICpcbiAqIEVTNiBnZW5lcmF0b3JzIGFyZSBjdXJyZW50bHkgcGFydCBvZiBWOCB2ZXJzaW9uIDMuMTkgd2l0aCB0aGVcbiAqIC0taGFybW9ueS1nZW5lcmF0b3JzIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiAgU3BpZGVyTW9ua2V5IGhhcyBoYWQgdGhlbVxuICogZm9yIGxvbmdlciwgYnV0IHVuZGVyIGFuIG9sZGVyIFB5dGhvbi1pbnNwaXJlZCBmb3JtLiAgVGhpcyBmdW5jdGlvblxuICogd29ya3Mgb24gYm90aCBraW5kcyBvZiBnZW5lcmF0b3JzLlxuICpcbiAqIERlY29yYXRlcyBhIGdlbmVyYXRvciBmdW5jdGlvbiBzdWNoIHRoYXQ6XG4gKiAgLSBpdCBtYXkgeWllbGQgcHJvbWlzZXNcbiAqICAtIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHdoZW4gdGhhdCBwcm9taXNlIGlzIGZ1bGZpbGxlZFxuICogIC0gdGhlIHZhbHVlIG9mIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpbGwgYmUgdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogIC0gaXQgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgKHdoZW4gdGhlIGdlbmVyYXRvclxuICogICAgc3RvcHMgaXRlcmF0aW5nKVxuICogIC0gdGhlIGRlY29yYXRlZCBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogICAgb2YgdGhlIGdlbmVyYXRvciBvciB0aGUgZmlyc3QgcmVqZWN0ZWQgcHJvbWlzZSBhbW9uZyB0aG9zZVxuICogICAgeWllbGRlZC5cbiAqICAtIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgZ2VuZXJhdG9yLCBpdCBwcm9wYWdhdGVzIHRocm91Z2hcbiAqICAgIGV2ZXJ5IGZvbGxvd2luZyB5aWVsZCB1bnRpbCBpdCBpcyBjYXVnaHQsIG9yIHVudGlsIGl0IGVzY2FwZXNcbiAqICAgIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gYWx0b2dldGhlciwgYW5kIGlzIHRyYW5zbGF0ZWQgaW50byBhXG4gKiAgICByZWplY3Rpb24gZm9yIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgZ2VuZXJhdG9yLlxuICovXG5RLmFzeW5jID0gYXN5bmM7XG5mdW5jdGlvbiBhc3luYyhtYWtlR2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwic2VuZFwiLCBhcmcgaXMgYSB2YWx1ZVxuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJ0aHJvd1wiLCBhcmcgaXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlcih2ZXJiLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuICAgICAgICAgICAgLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbiAgICAgICAgICAgIC8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbiAgICAgICAgICAgIC8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhpcyBibG9jay5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdG9wSXRlcmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRVM2IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNwaWRlck1vbmtleSBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGNhc2Ugd2hlbiBTTSBkb2VzIEVTNiBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBRKGV4Y2VwdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IG1ha2VHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcIm5leHRcIik7XG4gICAgICAgIHZhciBlcnJiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcInRocm93XCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzcGF3biBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIGFzeW5jIHRoYXQgaW1tZWRpYXRlbHlcbiAqIGNhbGxzIHRoZSBnZW5lcmF0b3IgYW5kIGFsc28gZW5kcyB0aGUgcHJvbWlzZSBjaGFpbiwgc28gdGhhdCBhbnlcbiAqIHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIGZvcndhcmRlZCB0byB0aGUgZXJyb3JcbiAqIGhhbmRsZXIuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBleHRyZW1lbHkgY29tbW9uIHRvIHJ1blxuICogZ2VuZXJhdG9ycyBhdCB0aGUgdG9wLWxldmVsIHRvIHdvcmsgd2l0aCBsaWJyYXJpZXMuXG4gKi9cblEuc3Bhd24gPSBzcGF3bjtcbmZ1bmN0aW9uIHNwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRLmRvbmUoUS5hc3luYyhtYWtlR2VuZXJhdG9yKSgpKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGludGVyZmFjZSBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG4vKipcbiAqIFRocm93cyBhIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB0byBzdG9wIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3IuXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgYSBzdG9wLWdhcCBtZWFzdXJlIHRvIHN1cHBvcnQgZ2VuZXJhdG9yIHJldHVyblxuICogdmFsdWVzIGluIG9sZGVyIEZpcmVmb3gvU3BpZGVyTW9ua2V5LiAgSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEVTNlxuICogZ2VuZXJhdG9ycyBsaWtlIENocm9taXVtIDI5LCBqdXN0IHVzZSBcInJldHVyblwiIGluIHlvdXIgZ2VuZXJhdG9yXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoZSBzdXJyb3VuZGluZyBnZW5lcmF0b3JcbiAqIEB0aHJvd3MgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHdpdGggdGhlIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIEVTNiBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiogKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICByZXR1cm4gZm9vICsgYmFyO1xuICogfSlcbiAqIC8vIE9sZGVyIFNwaWRlck1vbmtleSBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIFEucmV0dXJuKGZvbyArIGJhcik7XG4gKiB9KVxuICovXG5RW1wicmV0dXJuXCJdID0gX3JldHVybjtcbmZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgUVJldHVyblZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IHByb21pc2VkO1xuZnVuY3Rpb24gcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkKFt0aGlzLCBhbGwoYXJndW1lbnRzKV0sIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogc2VuZHMgYSBtZXNzYWdlIHRvIGEgdmFsdWUgaW4gYSBmdXR1cmUgdHVyblxuICogQHBhcmFtIG9iamVjdCogdGhlIHJlY2lwaWVudFxuICogQHBhcmFtIG9wIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIG9wZXJhdGlvbiwgZS5nLiwgXCJ3aGVuXCIsXG4gKiBAcGFyYW0gYXJncyBmdXJ0aGVyIGFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgcmVzdWx0IHtQcm9taXNlfSBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5RLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5mdW5jdGlvbiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChvcCwgYXJncyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKG9wLCBhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGRlZmVycmVkLnJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBnZXRcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlXG4gKi9cblEuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHZhbHVlICAgICBuZXcgdmFsdWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBkZWxldGVcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLmRlbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gdmFsdWUgICAgIGEgdmFsdWUgdG8gcG9zdCwgdHlwaWNhbGx5IGFuIGFycmF5IG9mXG4gKiAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gYXJndW1lbnRzIGZvciBwcm9taXNlcyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgIGFyZSB1bHRpbWF0ZWx5IGJhY2tlZCB3aXRoIGByZXNvbHZlYCB2YWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgIGFzIG9wcG9zZWQgdG8gdGhvc2UgYmFja2VkIHdpdGggVVJMc1xuICogICAgICAgICAgICAgICAgICB3aGVyZWluIHRoZSBwb3N0ZWQgdmFsdWUgY2FuIGJlIGFueVxuICogICAgICAgICAgICAgICAgICBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuLy8gYm91bmQgbG9jYWxseSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgb3RoZXIgbWV0aG9kc1xuUS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBpbnZvY2F0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5RLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEuaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblByb21pc2UucHJvdG90eXBlLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXJncyAgICAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZhcHBseSA9IGZ1bmN0aW9uIChvYmplY3QsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RW1widHJ5XCJdID1cblEuZmNhbGwgPSBmdW5jdGlvbiAob2JqZWN0IC8qIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzKV0pO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24sIHRyYW5zZm9ybWluZyByZXR1cm4gdmFsdWVzIGludG8gYSBmdWxmaWxsZWRcbiAqIHByb21pc2UgYW5kIHRocm93biBlcnJvcnMgaW50byBhIHJlamVjdGVkIG9uZS5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmJpbmQgPSBmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuZmJpbmQgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBuYW1lcyBvZiB0aGUgb3duZWQgcHJvcGVydGllcyBvZiBhIHByb21pc2VkXG4gKiBvYmplY3QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBrZXlzIG9mIHRoZSBldmVudHVhbGx5IHNldHRsZWQgb2JqZWN0XG4gKi9cblEua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZlxuICogdGhlIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG4vLyBCeSBNYXJrIE1pbGxlclxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46Y29uY3VycmVuY3kmcmV2PTEzMDg3NzY1MjEjYWxsZnVsZmlsbGVkXG5RLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIGNvdW50RG93biA9IDA7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvbWlzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgICAgICAoc25hcHNob3QgPSBwcm9taXNlLmluc3BlY3QoKSkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHNuYXBzaG90LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK2NvdW50RG93bjtcbiAgICAgICAgICAgICAgICB3aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnREb3duID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoeyBpbmRleDogaW5kZXgsIHZhbHVlOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIGlmIChjb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyB0byBiZSBzZXR0bGVkLCBlaXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZC4gIFRoaXMgaXMgZGlzdGluY3QgZnJvbSBgYWxsYCBzaW5jZSB0aGF0IHdvdWxkIHN0b3BcbiAqIHdhaXRpbmcgYXQgdGhlIGZpcnN0IHJlamVjdGlvbi4gIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gKiBgYWxsUmVzb2x2ZWRgIHdpbGwgbmV2ZXIgYmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0gcHJvbWlzZXMgYSBwcm9taXNlIGZvciBhbiBhcnJheSAob3IgYW4gYXJyYXkpIG9mIHByb21pc2VzXG4gKiAob3IgdmFsdWVzKVxuICogQHJldHVybiBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHByb21pc2VzXG4gKi9cblEuYWxsUmVzb2x2ZWQgPSBkZXByZWNhdGUoYWxsUmVzb2x2ZWQsIFwiYWxsUmVzb2x2ZWRcIiwgXCJhbGxTZXR0bGVkXCIpO1xuZnVuY3Rpb24gYWxsUmVzb2x2ZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHByb21pc2VzID0gYXJyYXlfbWFwKHByb21pc2VzLCBRKTtcbiAgICAgICAgcmV0dXJuIHdoZW4oYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGVuKHByb21pc2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbFJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGxSZXNvbHZlZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQHNlZSBQcm9taXNlI2FsbFNldHRsZWRcbiAqL1xuUS5hbGxTZXR0bGVkID0gYWxsU2V0dGxlZDtcbmZ1bmN0aW9uIGFsbFNldHRsZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gUShwcm9taXNlcykuYWxsU2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGVpciBzdGF0ZXMgKGFzXG4gKiByZXR1cm5lZCBieSBgaW5zcGVjdGApIHdoZW4gdGhleSBoYXZlIGFsbCBzZXR0bGVkLlxuICogQHBhcmFtIHtBcnJheVtBbnkqXX0gdmFsdWVzIGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIHtBcnJheVtTdGF0ZV19IGFuIGFycmF5IG9mIHN0YXRlcyBmb3IgdGhlIHJlc3BlY3RpdmUgdmFsdWVzLlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxTZXR0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiBhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFEocHJvbWlzZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZWdhcmRsZXNzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmluc3BlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVnYXJkbGVzcywgcmVnYXJkbGVzcyk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIGZhaWx1cmUgb2YgYSBwcm9taXNlLCBnaXZpbmcgYW4gb3BvcnR1bml0eSB0byByZWNvdmVyXG4gKiB3aXRoIGEgY2FsbGJhY2suICBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICogcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpZiB0aGVcbiAqIGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2tcbiAqL1xuUS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9iamVjdCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgbGlzdGVuZXIgdGhhdCBjYW4gcmVzcG9uZCB0byBwcm9ncmVzcyBub3RpZmljYXRpb25zIGZyb20gYVxuICogcHJvbWlzZSdzIG9yaWdpbmF0aW5nIGRlZmVycmVkLiBUaGlzIGxpc3RlbmVyIHJlY2VpdmVzIHRoZSBleGFjdCBhcmd1bWVudHNcbiAqIHBhc3NlZCB0byBgYGRlZmVycmVkLm5vdGlmeWBgLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIHJlY2VpdmUgYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm5zIHRoZSBnaXZlbiBwcm9taXNlLCB1bmNoYW5nZWRcbiAqL1xuUS5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZnVuY3Rpb24gcHJvZ3Jlc3Mob2JqZWN0LCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhbiBvcHBvcnR1bml0eSB0byBvYnNlcnZlIHRoZSBzZXR0bGluZyBvZiBhIHByb21pc2UsXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIG9yIHJlamVjdGVkLiAgRm9yd2FyZHNcbiAqIHRoZSByZXNvbHV0aW9uIHRvIHRoZSByZXR1cm5lZCBwcm9taXNlIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGRvbmUuXG4gKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIHByb21pc2UgdG8gZGVmZXIgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gb2JzZXJ2ZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW5cbiAqIHByb21pc2UsIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2Ugd2hlblxuICogYGBmaW5gYCBpcyBkb25lLlxuICovXG5RLmZpbiA9IC8vIFhYWCBsZWdhY3lcblFbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpW1wiZmluYWxseVwiXShjYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maW4gPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRPRE8gYXR0ZW1wdCB0byByZWN5Y2xlIHRoZSByZWplY3Rpb24gd2l0aCBcInRoaXNcIi5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGEgY2hhaW4gb2YgcHJvbWlzZXMsIGZvcmNpbmcgcmVqZWN0aW9ucyB0byBiZVxuICogdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgYXQgdGhlIGVuZCBvZiBhIGNoYWluIG9mIHByb21pc2VzXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cblEuZG9uZSA9IGZ1bmN0aW9uIChvYmplY3QsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kb25lKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBmb3J3YXJkIHRvIGEgZnV0dXJlIHR1cm4gc28gdGhhdCBgYHdoZW5gYFxuICAgICAgICAvLyBkb2VzIG5vdCBjYXRjaCBpdCBhbmQgdHVybiBpdCBpbnRvIGEgcmVqZWN0aW9uLlxuICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBgbmV4dFRpY2tgaW5nIHZpYSBhbiB1bm5lY2Vzc2FyeSBgd2hlbmAuXG4gICAgdmFyIHByb21pc2UgPSBmdWxmaWxsZWQgfHwgcmVqZWN0ZWQgfHwgcHJvZ3Jlc3MgP1xuICAgICAgICB0aGlzLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIDpcbiAgICAgICAgdGhpcztcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3IgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbih2b2lkIDAsIG9uVW5oYW5kbGVkRXJyb3IpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kcyB0aW1lb3V0XG4gKiBAcGFyYW0ge0FueSp9IGN1c3RvbSBlcnJvciBtZXNzYWdlIG9yIEVycm9yIG9iamVjdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGlmIGl0IGlzXG4gKiBmdWxmaWxsZWQgYmVmb3JlIHRoZSB0aW1lb3V0LCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gKi9cblEudGltZW91dCA9IGZ1bmN0aW9uIChvYmplY3QsIG1zLCBlcnJvcikge1xuICAgIHJldHVybiBRKG9iamVjdCkudGltZW91dChtcywgZXJyb3IpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgZXJyb3IpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlcnJvciB8fCBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yIHx8IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgbXMgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgfSwgbXMpO1xuXG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfSwgZGVmZXJyZWQubm90aWZ5KTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGdpdmVuIHZhbHVlIChvciBwcm9taXNlZCB2YWx1ZSksIHNvbWVcbiAqIG1pbGxpc2Vjb25kcyBhZnRlciBpdCByZXNvbHZlZC4gUGFzc2VzIHJlamVjdGlvbnMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgYWZ0ZXIgbWlsbGlzZWNvbmRzXG4gKiB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlLlxuICogSWYgdGhlIGdpdmVuIHByb21pc2UgcmVqZWN0cywgdGhhdCBpcyBwYXNzZWQgaW1tZWRpYXRlbHkuXG4gKi9cblEuZGVsYXkgPSBmdW5jdGlvbiAob2JqZWN0LCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lb3V0ID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBRKG9iamVjdCkuZGVsYXkodGltZW91dCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBhcyBhbiBhcnJheSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqICAgICAgUS5uZmFwcGx5KEZTLnJlYWRGaWxlLCBbX19maWxlbmFtZV0pXG4gKiAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiAgICAgIH0pXG4gKlxuICovXG5RLm5mYXBwbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGluZGl2aWR1YWxseSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZjYWxsKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKVxuICogLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqIH0pXG4gKlxuICovXG5RLm5mY2FsbCA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBOb2RlSlMgY29udGludWF0aW9uIHBhc3NpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudFxuICogdmVyc2lvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZiaW5kKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKShcInV0Zi04XCIpXG4gKiAudGhlbihjb25zb2xlLmxvZylcbiAqIC5kb25lKClcbiAqL1xuUS5uZmJpbmQgPVxuUS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBRKGNhbGxiYWNrKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYmluZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLmRlbm9kZWlmeS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuUS5uYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3AgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBRKGJvdW5kKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5iaW5kID0gZnVuY3Rpb24gKC8qdGhpc3AsIC4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEubmJpbmQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjayB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWQgY2FsbGJhY2suXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5ucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5wb3N0KG5hbWUsIGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5ucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyB8fCBbXSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrLCBmb3J3YXJkaW5nIHRoZSBnaXZlbiB2YXJpYWRpYyBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZFxuICogY2FsbGJhY2sgYXJndW1lbnQuXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0gLi4uYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2sgd2lsbFxuICogYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5RLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblEubmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUHJvbWlzZS5wcm90b3R5cGUubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUHJvbWlzZS5wcm90b3R5cGUubmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIElmIGEgZnVuY3Rpb24gd291bGQgbGlrZSB0byBzdXBwb3J0IGJvdGggTm9kZSBjb250aW51YXRpb24tcGFzc2luZy1zdHlsZSBhbmRcbiAqIHByb21pc2UtcmV0dXJuaW5nLXN0eWxlLCBpdCBjYW4gZW5kIGl0cyBpbnRlcm5hbCBwcm9taXNlIGNoYWluIHdpdGhcbiAqIGBub2RlaWZ5KG5vZGViYWNrKWAsIGZvcndhcmRpbmcgdGhlIG9wdGlvbmFsIG5vZGViYWNrIGFyZ3VtZW50LiAgSWYgdGhlIHVzZXJcbiAqIGVsZWN0cyB0byB1c2UgYSBub2RlYmFjaywgdGhlIHJlc3VsdCB3aWxsIGJlIHNlbnQgdGhlcmUuICBJZiB0aGV5IGRvIG5vdFxuICogcGFzcyBhIG5vZGViYWNrLCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IHByb21pc2UuXG4gKiBAcGFyYW0gb2JqZWN0IGEgcmVzdWx0IChvciBhIHByb21pc2UgZm9yIGEgcmVzdWx0KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbm9kZWJhY2sgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyBlaXRoZXIgdGhlIHByb21pc2Ugb3Igbm90aGluZ1xuICovXG5RLm5vZGVpZnkgPSBub2RlaWZ5O1xuZnVuY3Rpb24gbm9kZWlmeShvYmplY3QsIG5vZGViYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ub2RlaWZ5KG5vZGViYWNrKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaykge1xuICAgIGlmIChub2RlYmFjaykge1xuICAgICAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcbiIsIi8qXG4gKiBRYW5pbWF0aW9uZnJhbWUuanMgLSBQcm9taXNpZmllZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2l0aCBRXG4gKi9cbi8qanNsaW50IG5ld2NhcDogdHJ1ZSAqL1xuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5RYW5pbWF0aW9uRnJhbWUgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSkoZnVuY3Rpb24gKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBJbXBvcnQgUVxuICB2YXIgUSA9IHdpbmRvdy5RIHx8IHJlcXVpcmUoXCJxXCIpO1xuXG4gIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbFxuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgfTtcbiAgfSkoKTtcblxuICAvLyBRYW5pbWF0aW9uRnJhbWUoZjogZnVuY3Rpb24pID0+IHByb21pc2UgY29udGFpbmluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIGZcbiAgLy8gLS0tXG4gIC8vXG4gIHZhciBRYW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBkID0gUS5kZWZlcigpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkLnJlc29sdmUoZigpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZC5yZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gUWFuaW1hdGlvbkZyYW1lO1xufSk7XG4iLCIvLyBUaGlzIGxpYnJhcnkgc3RhcnRlZCBhcyBhbiBleHBlcmltZW50IHRvIHNlZSBob3cgc21hbGwgSSBjb3VsZCBtYWtlXG4vLyBhIGZ1bmN0aW9uYWwgcm91dGVyLiBJdCBoYXMgc2luY2UgYmVlbiBvcHRpbWl6ZWQgKGFuZCB0aHVzIGdyb3duKS5cbi8vIFRoZSByZWR1bmRhbmN5IGFuZCBpbmVsZWdhbmNlIGhlcmUgaXMgZm9yIHRoZSBzYWtlIG9mIGVpdGhlciBzaXplXG4vLyBvciBzcGVlZC5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICB2YXIgZGVmaW5lID0gcm9vdC5kZWZpbmU7XG5cbiAgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdybGl0ZScsIFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuUmxpdGUgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJvdXRlcyA9IHt9LFxuICAgICAgICBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmdW5jdGlvbiBub29wKHMpIHsgcmV0dXJuIHM7IH1cblxuICAgIGZ1bmN0aW9uIHNhbml0aXplKHVybCkge1xuICAgICAgfnVybC5pbmRleE9mKCcvPycpICYmICh1cmwgPSB1cmwucmVwbGFjZSgnLz8nLCAnPycpKTtcbiAgICAgIHVybFswXSA9PSAnLycgJiYgKHVybCA9IHVybC5zbGljZSgxKSk7XG4gICAgICB1cmxbdXJsLmxlbmd0aCAtIDFdID09ICcvJyAmJiAodXJsID0gdXJsLnNsaWNlKDAsIC0xKSk7XG5cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1VybCh1cmwsIGVzYykge1xuICAgICAgdmFyIHBpZWNlcyA9IHVybC5zcGxpdCgnLycpLFxuICAgICAgICAgIHJ1bGVzID0gcm91dGVzLFxuICAgICAgICAgIHBhcmFtcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggJiYgcnVsZXM7ICsraSkge1xuICAgICAgICB2YXIgcGllY2UgPSBlc2MocGllY2VzW2ldKTtcbiAgICAgICAgcnVsZXMgPSBydWxlc1twaWVjZS50b0xvd2VyQ2FzZSgpXSB8fCBydWxlc1snOiddO1xuICAgICAgICBydWxlcyAmJiBydWxlc1snfiddICYmIChwYXJhbXNbcnVsZXNbJ34nXV0gPSBwaWVjZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydWxlcyAmJiB7XG4gICAgICAgIGNiOiBydWxlc1snQCddLFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUXVlcnkodXJsLCBjdHgsIGVzYykge1xuICAgICAgaWYgKHVybCAmJiBjdHguY2IpIHtcbiAgICAgICAgdmFyIGhhc2ggPSB1cmwuaW5kZXhPZignIycpLFxuICAgICAgICAgICAgcXVlcnkgPSAoaGFzaCA8IDAgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaCkpLnNwbGl0KCcmJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBuYW1lVmFsdWUgPSBxdWVyeVtpXS5zcGxpdCgnPScpO1xuXG4gICAgICAgICAgY3R4LnBhcmFtc1tuYW1lVmFsdWVbMF1dID0gZXNjKG5hbWVWYWx1ZVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29rdXAodXJsKSB7XG4gICAgICB2YXIgcXVlcnlTcGxpdCA9IHNhbml0aXplKHVybCkuc3BsaXQoJz8nKSxcbiAgICAgICAgICBlc2MgPSB+dXJsLmluZGV4T2YoJyUnKSA/IGRlY29kZSA6IG5vb3A7XG5cbiAgICAgIHJldHVybiBwcm9jZXNzUXVlcnkocXVlcnlTcGxpdFsxXSwgcHJvY2Vzc1VybChxdWVyeVNwbGl0WzBdLCBlc2MpIHx8IHt9LCBlc2MpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uKHJvdXRlLCBoYW5kbGVyKSB7XG5cbiAgICAgICAgdmFyIHBpZWNlcyA9IHJvdXRlLnNwbGl0KCcvJyksXG4gICAgICAgICAgICBydWxlcyA9IHJvdXRlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBwaWVjZSA9IHBpZWNlc1tpXSxcbiAgICAgICAgICAgICAgbmFtZSA9IHBpZWNlWzBdID09ICc6JyA/ICc6JyA6IHBpZWNlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBydWxlcyA9IHJ1bGVzW25hbWVdIHx8IChydWxlc1tuYW1lXSA9IHt9KTtcblxuICAgICAgICAgIG5hbWUgPT0gJzonICYmIChydWxlc1snfiddID0gcGllY2Uuc2xpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcnVsZXNbJ0AnXSA9IGhhbmRsZXI7XG4gICAgICB9LFxuXG4gICAgICBleGlzdHM6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuICEhbG9va3VwKHVybCkuY2I7XG4gICAgICB9LFxuXG4gICAgICBsb29rdXA6IGxvb2t1cCxcblxuICAgICAgcnVuOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cCh1cmwpO1xuXG4gICAgICAgIHJlc3VsdC5jYiAmJiByZXN1bHQuY2Ioe1xuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIHBhcmFtczogcmVzdWx0LnBhcmFtc1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gISFyZXN1bHQuY2I7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pKTtcbiIsIi8qanNsaW50IG9uZXZhcjp0cnVlLCB1bmRlZjp0cnVlLCBuZXdjYXA6dHJ1ZSwgcmVnZXhwOnRydWUsIGJpdHdpc2U6dHJ1ZSwgbWF4ZXJyOjUwLCBpbmRlbnQ6NCwgd2hpdGU6ZmFsc2UsIG5vbWVuOmZhbHNlLCBwbHVzcGx1czpmYWxzZSAqL1xuLypnbG9iYWwgZGVmaW5lOmZhbHNlLCByZXF1aXJlOmZhbHNlLCBleHBvcnRzOmZhbHNlLCBtb2R1bGU6ZmFsc2UsIHNpZ25hbHM6ZmFsc2UgKi9cblxuLyoqIEBsaWNlbnNlXG4gKiBKUyBTaWduYWxzIDxodHRwOi8vbWlsbGVybWVkZWlyb3MuZ2l0aHViLmNvbS9qcy1zaWduYWxzLz5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQXV0aG9yOiBNaWxsZXIgTWVkZWlyb3NcbiAqIFZlcnNpb246IDEuMC4wIC0gQnVpbGQ6IDI2OCAoMjAxMi8xMS8yOSAwNTo0OCBQTSlcbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKXtcblxuICAgIC8vIFNpZ25hbEJpbmRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGJpbmRpbmcgYmV0d2VlbiBhIFNpZ25hbCBhbmQgYSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgKiA8YnIgLz4tIDxzdHJvbmc+VGhpcyBpcyBhbiBpbnRlcm5hbCBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkbid0IGJlIGNhbGxlZCBieSByZWd1bGFyIHVzZXJzLjwvc3Ryb25nPlxuICAgICAqIDxiciAvPi0gaW5zcGlyZWQgYnkgSm9hIEViZXJ0IEFTMyBTaWduYWxCaW5kaW5nIGFuZCBSb2JlcnQgUGVubmVyJ3MgU2xvdCBjbGFzc2VzLlxuICAgICAqIEBhdXRob3IgTWlsbGVyIE1lZGVpcm9zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGludGVybmFsXG4gICAgICogQG5hbWUgU2lnbmFsQmluZGluZ1xuICAgICAqIEBwYXJhbSB7U2lnbmFsfSBzaWduYWwgUmVmZXJlbmNlIHRvIFNpZ25hbCBvYmplY3QgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgSGFuZGxlciBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2lnbmFsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlIElmIGJpbmRpbmcgc2hvdWxkIGJlIGV4ZWN1dGVkIGp1c3Qgb25jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpc3RlbmVyQ29udGV4dF0gQ29udGV4dCBvbiB3aGljaCBsaXN0ZW5lciB3aWxsIGJlIGV4ZWN1dGVkIChvYmplY3QgdGhhdCBzaG91bGQgcmVwcmVzZW50IHRoZSBgdGhpc2AgdmFyaWFibGUgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9uKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50IGxpc3RlbmVyLiAoZGVmYXVsdCA9IDApLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbEJpbmRpbmcoc2lnbmFsLCBsaXN0ZW5lciwgaXNPbmNlLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXIgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGJpbmRpbmcgc2hvdWxkIGJlIGV4ZWN1dGVkIGp1c3Qgb25jZS5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNPbmNlID0gaXNPbmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAgICAgKiBAbWVtYmVyT2YgU2lnbmFsQmluZGluZy5wcm90b3R5cGVcbiAgICAgICAgICogQG5hbWUgY29udGV4dFxuICAgICAgICAgKiBAdHlwZSBPYmplY3R8dW5kZWZpbmVkfG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGxpc3RlbmVyQ29udGV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIFNpZ25hbCBvYmplY3QgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICAgICAqIEB0eXBlIFNpZ25hbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2lnbmFsID0gc2lnbmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW5lciBwcmlvcml0eVxuICAgICAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcbiAgICB9XG5cbiAgICBTaWduYWxCaW5kaW5nLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYmluZGluZyBpcyBhY3RpdmUgYW5kIHNob3VsZCBiZSBleGVjdXRlZC5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlIDogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBwYXJhbWV0ZXJzIHBhc3NlZCB0byBsaXN0ZW5lciBkdXJpbmcgYFNpZ25hbC5kaXNwYXRjaGAgYW5kIGBTaWduYWxCaW5kaW5nLmV4ZWN1dGVgLiAoY3VycmllZCBwYXJhbWV0ZXJzKVxuICAgICAgICAgKiBAdHlwZSBBcnJheXxudWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbXMgOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIGxpc3RlbmVyIHBhc3NpbmcgYXJiaXRyYXJ5IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIDxwPklmIGJpbmRpbmcgd2FzIGFkZGVkIHVzaW5nIGBTaWduYWwuYWRkT25jZSgpYCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHNpZ25hbCBkaXNwYXRjaCBxdWV1ZSwgdGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGZvciB0aGUgc2lnbmFsIGRpc3BhdGNoLjwvcD5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtc0Fycl0gQXJyYXkgb2YgcGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGxpc3RlbmVyXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHJldHVybmVkIGJ5IHRoZSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGV4ZWN1dGUgOiBmdW5jdGlvbiAocGFyYW1zQXJyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlclJldHVybiwgcGFyYW1zO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICEhdGhpcy5fbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcz8gdGhpcy5wYXJhbXMuY29uY2F0KHBhcmFtc0FycikgOiBwYXJhbXNBcnI7XG4gICAgICAgICAgICAgICAgaGFuZGxlclJldHVybiA9IHRoaXMuX2xpc3RlbmVyLmFwcGx5KHRoaXMuY29udGV4dCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJSZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGFjaCBiaW5kaW5nIGZyb20gc2lnbmFsLlxuICAgICAgICAgKiAtIGFsaWFzIHRvOiBteVNpZ25hbC5yZW1vdmUobXlCaW5kaW5nLmdldExpc3RlbmVyKCkpO1xuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwgb3IgYG51bGxgIGlmIGJpbmRpbmcgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZXRhY2ggOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0JvdW5kKCk/IHRoaXMuX3NpZ25hbC5yZW1vdmUodGhpcy5fbGlzdGVuZXIsIHRoaXMuY29udGV4dCkgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYmluZGluZyBpcyBzdGlsbCBib3VuZCB0byB0aGUgc2lnbmFsIGFuZCBoYXZlIGEgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpc0JvdW5kIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICghIXRoaXMuX3NpZ25hbCAmJiAhIXRoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgU2lnbmFsQmluZGluZyB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzT25jZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc09uY2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMaXN0ZW5lciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7U2lnbmFsfSBTaWduYWwgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaWduYWwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgaW5zdGFuY2UgcHJvcGVydGllc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2Rlc3Ryb3kgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2lnbmFsO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbU2lnbmFsQmluZGluZyBpc09uY2U6JyArIHRoaXMuX2lzT25jZSArJywgaXNCb3VuZDonKyB0aGlzLmlzQm91bmQoKSArJywgYWN0aXZlOicgKyB0aGlzLmFjdGl2ZSArICddJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4vKmdsb2JhbCBTaWduYWxCaW5kaW5nOmZhbHNlKi9cblxuICAgIC8vIFNpZ25hbCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lciwgZm5OYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2xpc3RlbmVyIGlzIGEgcmVxdWlyZWQgcGFyYW0gb2Yge2ZufSgpIGFuZCBzaG91bGQgYmUgYSBGdW5jdGlvbi4nLnJlcGxhY2UoJ3tmbn0nLCBmbk5hbWUpICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnQgYnJvYWRjYXN0ZXJcbiAgICAgKiA8YnIgLz4tIGluc3BpcmVkIGJ5IFJvYmVydCBQZW5uZXIncyBBUzMgU2lnbmFscy5cbiAgICAgKiBAbmFtZSBTaWduYWxcbiAgICAgKiBAYXV0aG9yIE1pbGxlciBNZWRlaXJvc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIEFycmF5LjxTaWduYWxCaW5kaW5nPlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5mb3JjZSBkaXNwYXRjaCB0byBhd2F5cyB3b3JrIG9uIHNhbWUgY29udGV4dCAoIzQ3KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgU2lnbmFsLnByb3RvdHlwZS5kaXNwYXRjaC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIFNpZ25hbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ25hbHMgVmVyc2lvbiBOdW1iZXJcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKi9cbiAgICAgICAgVkVSU0lPTiA6ICcxLjAuMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIFNpZ25hbCBzaG91bGQga2VlcCByZWNvcmQgb2YgcHJldmlvdXNseSBkaXNwYXRjaGVkIHBhcmFtZXRlcnMgYW5kXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgZXhlY3V0ZSBsaXN0ZW5lciBkdXJpbmcgYGFkZCgpYC9gYWRkT25jZSgpYCBpZiBTaWduYWwgd2FzXG4gICAgICAgICAqIGFscmVhZHkgZGlzcGF0Y2hlZCBiZWZvcmUuXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG1lbW9yaXplIDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zaG91bGRQcm9wYWdhdGUgOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBTaWduYWwgaXMgYWN0aXZlIGFuZCBzaG91bGQgYnJvYWRjYXN0IGV2ZW50cy5cbiAgICAgICAgICogPHA+PHN0cm9uZz5JTVBPUlRBTlQ6PC9zdHJvbmc+IFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBkdXJpbmcgYSBkaXNwYXRjaCB3aWxsIG9ubHkgYWZmZWN0IHRoZSBuZXh0IGRpc3BhdGNoLCBpZiB5b3Ugd2FudCB0byBzdG9wIHRoZSBwcm9wYWdhdGlvbiBvZiBhIHNpZ25hbCB1c2UgYGhhbHQoKWAgaW5zdGVhZC48L3A+XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZSA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlZ2lzdGVyTGlzdGVuZXIgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGlzT25jZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSkge1xuXG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gdGhpcy5faW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQpLFxuICAgICAgICAgICAgICAgIGJpbmRpbmc7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMuX2JpbmRpbmdzW3ByZXZJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuaXNPbmNlKCkgIT09IGlzT25jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgYWRkJysgKGlzT25jZT8gJycgOiAnT25jZScpICsnKCkgdGhlbiBhZGQnKyAoIWlzT25jZT8gJycgOiAnT25jZScpICsnKCkgdGhlIHNhbWUgbGlzdGVuZXIgd2l0aG91dCByZW1vdmluZyB0aGUgcmVsYXRpb25zaGlwIGZpcnN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IG5ldyBTaWduYWxCaW5kaW5nKHRoaXMsIGxpc3RlbmVyLCBpc09uY2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMubWVtb3JpemUgJiYgdGhpcy5fcHJldlBhcmFtcyl7XG4gICAgICAgICAgICAgICAgYmluZGluZy5leGVjdXRlKHRoaXMuX3ByZXZQYXJhbXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTaWduYWxCaW5kaW5nfSBiaW5kaW5nXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYWRkQmluZGluZyA6IGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAvL3NpbXBsaWZpZWQgaW5zZXJ0aW9uIHNvcnRcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICAgICAgZG8geyAtLW47IH0gd2hpbGUgKHRoaXMuX2JpbmRpbmdzW25dICYmIGJpbmRpbmcuX3ByaW9yaXR5IDw9IHRoaXMuX2JpbmRpbmdzW25dLl9wcmlvcml0eSk7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5ncy5zcGxpY2UobiArIDEsIDAsIGJpbmRpbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaW5kZXhPZkxpc3RlbmVyIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXI7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gdGhpcy5fYmluZGluZ3Nbbl07XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5fbGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIGN1ci5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgbGlzdGVuZXIgd2FzIGF0dGFjaGVkIHRvIFNpZ25hbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiBTaWduYWwgaGFzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBoYXMgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleE9mTGlzdGVuZXIobGlzdGVuZXIsIGNvbnRleHQpICE9PSAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgU2lnbmFsIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XSBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50IGxpc3RlbmVyLiBMaXN0ZW5lcnMgd2l0aCBoaWdoZXIgcHJpb3JpdHkgd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgbGlzdGVuZXJzIHdpdGggbG93ZXIgcHJpb3JpdHkuIExpc3RlbmVycyB3aXRoIHNhbWUgcHJpb3JpdHkgbGV2ZWwgd2lsbCBiZSBleGVjdXRlZCBhdCB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IHdlcmUgYWRkZWQuIChkZWZhdWx0ID0gMClcbiAgICAgICAgICogQHJldHVybiB7U2lnbmFsQmluZGluZ30gQW4gT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBiZXR3ZWVuIHRoZSBTaWduYWwgYW5kIGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAnYWRkJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgbGlzdGVuZXIgdG8gdGhlIHNpZ25hbCB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGFmdGVyIGZpcnN0IGV4ZWN1dGlvbiAod2lsbCBiZSBleGVjdXRlZCBvbmx5IG9uY2UpLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBTaWduYWwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0ZW5lckNvbnRleHRdIENvbnRleHQgb24gd2hpY2ggbGlzdGVuZXIgd2lsbCBiZSBleGVjdXRlZCAob2JqZWN0IHRoYXQgc2hvdWxkIHJlcHJlc2VudCB0aGUgYHRoaXNgIHZhcmlhYmxlIGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbikuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldIFRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuIExpc3RlbmVycyB3aXRoIGhpZ2hlciBwcmlvcml0eSB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBsaXN0ZW5lcnMgd2l0aCBsb3dlciBwcmlvcml0eS4gTGlzdGVuZXJzIHdpdGggc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgd2VyZSBhZGRlZC4gKGRlZmF1bHQgPSAwKVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfSBBbiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIGJldHdlZW4gdGhlIFNpZ25hbCBhbmQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRPbmNlIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAnYWRkT25jZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXIobGlzdGVuZXIsIHRydWUsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBzaW5nbGUgbGlzdGVuZXIgZnJvbSB0aGUgZGlzcGF0Y2ggcXVldWUuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEhhbmRsZXIgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBFeGVjdXRpb24gY29udGV4dCAoc2luY2UgeW91IGNhbiBhZGQgdGhlIHNhbWUgaGFuZGxlciBtdWx0aXBsZSB0aW1lcyBpZiBleGVjdXRpbmcgaW4gYSBkaWZmZXJlbnQgY29udGV4dCkuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBMaXN0ZW5lciBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAncmVtb3ZlJyk7XG5cbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5faW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzW2ldLl9kZXN0cm95KCk7IC8vbm8gcmVhc29uIHRvIGEgU2lnbmFsQmluZGluZyBleGlzdCBpZiBpdCBpc24ndCBhdHRhY2hlZCB0byBhIHNpZ25hbFxuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgU2lnbmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ3Nbbl0uX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGxpc3RlbmVycyBhdHRhY2hlZCB0byB0aGUgU2lnbmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TnVtTGlzdGVuZXJzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQsIGJsb2NraW5nIHRoZSBkaXNwYXRjaCB0byBuZXh0IGxpc3RlbmVycyBvbiB0aGUgcXVldWUuXG4gICAgICAgICAqIDxwPjxzdHJvbmc+SU1QT1JUQU5UOjwvc3Ryb25nPiBzaG91bGQgYmUgY2FsbGVkIG9ubHkgZHVyaW5nIHNpZ25hbCBkaXNwYXRjaCwgY2FsbGluZyBpdCBiZWZvcmUvYWZ0ZXIgZGlzcGF0Y2ggd29uJ3QgYWZmZWN0IHNpZ25hbCBicm9hZGNhc3QuPC9wPlxuICAgICAgICAgKiBAc2VlIFNpZ25hbC5wcm90b3R5cGUuZGlzYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgaGFsdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaC9Ccm9hZGNhc3QgU2lnbmFsIHRvIGFsbCBsaXN0ZW5lcnMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJhbXNdIFBhcmFtZXRlcnMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIGVhY2ggaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoIDogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXNBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYmluZGluZ3M7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1lbW9yaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IHBhcmFtc0FycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEgbikge1xuICAgICAgICAgICAgICAgIC8vc2hvdWxkIGNvbWUgYWZ0ZXIgbWVtb3JpemVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3Muc2xpY2UoKTsgLy9jbG9uZSBhcnJheSBpbiBjYXNlIGFkZC9yZW1vdmUgaXRlbXMgZHVyaW5nIGRpc3BhdGNoXG4gICAgICAgICAgICB0aGlzLl9zaG91bGRQcm9wYWdhdGUgPSB0cnVlOyAvL2luIGNhc2UgYGhhbHRgIHdhcyBjYWxsZWQgYmVmb3JlIGRpc3BhdGNoIG9yIGR1cmluZyB0aGUgcHJldmlvdXMgZGlzcGF0Y2guXG5cbiAgICAgICAgICAgIC8vZXhlY3V0ZSBhbGwgY2FsbGJhY2tzIHVudGlsIGVuZCBvZiB0aGUgbGlzdCBvciB1bnRpbCBhIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCBvciBzdG9wcyBwcm9wYWdhdGlvblxuICAgICAgICAgICAgLy9yZXZlcnNlIGxvb3Agc2luY2UgbGlzdGVuZXJzIHdpdGggaGlnaGVyIHByaW9yaXR5IHdpbGwgYmUgYWRkZWQgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgZG8geyBuLS07IH0gd2hpbGUgKGJpbmRpbmdzW25dICYmIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSAmJiBiaW5kaW5nc1tuXS5leGVjdXRlKHBhcmFtc0FycikgIT09IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yZ2V0IG1lbW9yaXplZCBhcmd1bWVudHMuXG4gICAgICAgICAqIEBzZWUgU2lnbmFsLm1lbW9yaXplXG4gICAgICAgICAqL1xuICAgICAgICBmb3JnZXQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbGwgYmluZGluZ3MgZnJvbSBzaWduYWwgYW5kIGRlc3Ryb3kgYW55IHJlZmVyZW5jZSB0byBleHRlcm5hbCBvYmplY3RzIChkZXN0cm95IFNpZ25hbCBvYmplY3QpLlxuICAgICAgICAgKiA8cD48c3Ryb25nPklNUE9SVEFOVDo8L3N0cm9uZz4gY2FsbGluZyBhbnkgbWV0aG9kIG9uIHRoZSBzaWduYWwgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkaXNwb3NlIHdpbGwgdGhyb3cgZXJyb3JzLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JpbmRpbmdzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ByZXZQYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnW1NpZ25hbCBhY3RpdmU6JysgdGhpcy5hY3RpdmUgKycgbnVtTGlzdGVuZXJzOicrIHRoaXMuZ2V0TnVtTGlzdGVuZXJzKCkgKyddJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgLy8gTmFtZXNwYWNlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIG5hbWVzcGFjZVxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbmFtZSBzaWduYWxzXG4gICAgICovXG4gICAgdmFyIHNpZ25hbHMgPSBTaWduYWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnQgYnJvYWRjYXN0ZXJcbiAgICAgKiBAc2VlIFNpZ25hbFxuICAgICAqL1xuICAgIC8vIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2VlICNnaC00NClcbiAgICBzaWduYWxzLlNpZ25hbCA9IFNpZ25hbDtcblxuXG5cbiAgICAvL2V4cG9ydHMgdG8gbXVsdGlwbGUgZW52aXJvbm1lbnRzXG4gICAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKXsgLy9BTURcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hbHM7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpeyAvL25vZGVcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzaWduYWxzO1xuICAgIH0gZWxzZSB7IC8vYnJvd3NlclxuICAgICAgICAvL3VzZSBzdHJpbmcgYmVjYXVzZSBvZiBHb29nbGUgY2xvc3VyZSBjb21waWxlciBBRFZBTkNFRF9NT0RFXG4gICAgICAgIC8qanNsaW50IHN1Yjp0cnVlICovXG4gICAgICAgIGdsb2JhbFsnc2lnbmFscyddID0gc2lnbmFscztcbiAgICB9XG5cbn0odGhpcykpO1xuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJykuc3R5bGUsXG4gICAgcHJlZml4ZXMgPSAnTyBtcyBNb3ogd2Via2l0Jy5zcGxpdCgnICcpLFxuICAgIGhhc1ByZWZpeCA9IC9eKG98bXN8bW96fHdlYmtpdCkvLFxuICAgIHVwcGVyID0gLyhbQS1aXSkvZyxcbiAgICBtZW1vID0ge307XG5cbmZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHJldHVybiAoa2V5IGluIG1lbW8pID8gbWVtb1trZXldIDogbWVtb1trZXldID0gcHJlZml4KGtleSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpeChrZXkpe1xuICAgIHZhciBjYXBpdGFsaXplZEtleSA9IGtleS5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbihzLCBtYXRjaCl7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSksXG4gICAgICAgIGkgPSBwcmVmaXhlcy5sZW5ndGgsXG4gICAgICAgIG5hbWU7XG5cbiAgICBpZiAoc3R5bGVbY2FwaXRhbGl6ZWRLZXldICE9PSB1bmRlZmluZWQpIHJldHVybiBjYXBpdGFsaXplZEtleTtcblxuICAgIGNhcGl0YWxpemVkS2V5ID0gY2FwaXRhbGl6ZShrZXkpO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBuYW1lID0gcHJlZml4ZXNbaV0gKyBjYXBpdGFsaXplZEtleTtcbiAgICAgICAgaWYgKHN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIHByZWZpeCAnICsga2V5KTtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpe1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cbmZ1bmN0aW9uIGRhc2hlZFByZWZpeChrZXkpe1xuICAgIHZhciBwcmVmaXhlZEtleSA9IGdldChrZXkpLFxuICAgICAgICB1cHBlciA9IC8oW0EtWl0pL2c7XG5cbiAgICBpZiAodXBwZXIudGVzdChwcmVmaXhlZEtleSkpIHtcbiAgICAgICAgcHJlZml4ZWRLZXkgPSAoaGFzUHJlZml4LnRlc3QocHJlZml4ZWRLZXkpID8gJy0nIDogJycpICsgcHJlZml4ZWRLZXkucmVwbGFjZSh1cHBlciwgJy0kMScpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXhlZEtleS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbm1vZHVsZS5leHBvcnRzLmRhc2ggPSBkYXNoZWRQcmVmaXg7XG4iLCIvLyBaYW5pbW8uanMgLSBQcm9taXNlIGJhc2VkIENTUzMgdHJhbnNpdGlvbnNcbi8vIChjKSAyMDExLTIwMTQgUGF1bCBQYW5zZXJyaWV1XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFEgPSByZXF1aXJlKCdxJyksXG4gICAgUWFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgncWFuaW1hdGlvbmZyYW1lJyksXG4gICAgcHJlZml4ID0gcmVxdWlyZSgndmVuZG9yLXByZWZpeCcpLFxuICAgIG5vcm1hbGl6ZVRyYW5zZm9ybVZhbHVlID0gcmVxdWlyZSgnLi4vc3JjL25vcm1hbGl6ZS10cmFuc2Zvcm0tdmFsdWUnKSxcbiAgICBzaG9ydGhhbmQgPSByZXF1aXJlKCcuLi9zcmMvdHJhbnNpdGlvbi1zaG9ydGhhbmQtcHJvcGVydHknKSxcbiAgICB0cmFuc2l0aW9uID0gcHJlZml4KCd0cmFuc2l0aW9uJyksXG4gICAgdHJhbnNpdGlvbmVuZCA9ICdXZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlID8gJ3dlYmtpdFRyYW5zaXRpb25FbmQnIDogJ3RyYW5zaXRpb25lbmQnLFxuXG4gICAgaXNET00gPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBlbCAmJiBlbC5ub2RlVHlwZTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYWRkVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChlbHQsIGF0dHIsIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nKSB7XG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBlbHQuc3R5bGVbdHJhbnNpdGlvbl07XG4gICAgICAgIGF0dHIgPSBwcmVmaXguZGFzaChhdHRyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgZWx0LnN0eWxlW3RyYW5zaXRpb25dID0gY3VycmVudFZhbHVlICsgXCIsIFwiICsgc2hvcnRoYW5kKGF0dHIsIGR1cmF0aW9uLCBlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlW3RyYW5zaXRpb25dID0gc2hvcnRoYW5kKGF0dHIsIGR1cmF0aW9uLCBlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsdC5zdHlsZVtwcmVmaXgoYXR0cildID0gdmFsdWU7XG4gICAgfSxcblxuICAgIHJlbW92ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoZWwsIGF0dHIpIHtcbiAgICAgICAgZWwuc3R5bGVbdHJhbnNpdGlvbl0gPSBlbC5zdHlsZVt0cmFuc2l0aW9uXVxuICAgICAgICAgICAgLnNwbGl0KCcsJykuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXQubWF0Y2goYXR0cik7XG4gICAgICAgICAgICB9KS5qb2luKCcsJyk7XG4gICAgfSxcblxuICAgIGFwcGx5Y3NzID0gZnVuY3Rpb24gKGVsLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gUWFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBlbC5zdHlsZVtwcmVmaXguZGFzaChhdHRyKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNzcyA9IGZ1bmN0aW9uIChlbCwgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgaWYoZWwuX3phbmltbyAmJiBlbC5femFuaW1vLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICBlbC5femFuaW1vW2F0dHJdLmRlZmVyLnJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJaYW5pbW8gdHJhbnNpdGlvbiB3aXRoIHRyYW5zZm9ybT1cIiArXG4gICAgICAgICAgICAgICAgZWwuX3phbmltb1thdHRyXS52YWx1ZSArXG4gICAgICAgICAgICAgICAgXCIgc3RvcHBlZCBieSB0cmFuc2Zvcm09XCIgKyB2YWx1ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBlbC5femFuaW1vW2F0dHJdLmNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5Y3NzKGVsLCBhdHRyLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGFuaW1hdGUgPSBmdW5jdGlvbiAoZWwsIGF0dHIsIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nKSB7XG4gICAgICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeC5kYXNoKGF0dHIpLFxuICAgICAgICAgICAgZCA9IFEuZGVmZXIoKSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBjYiA9IGZ1bmN0aW9uIChjbGVhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7IGNsZWFyVGltZW91dCh0aW1lb3V0KTsgdGltZW91dCA9IG51bGw7IH1cbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uKGVsLCBhdHRyKTtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25lbmQsIGNiVHJhbnNpdGlvbmVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyKSB7IGRlbGV0ZSBlbC5femFuaW1vW2F0dHJdOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2JUcmFuc2l0aW9uZW5kID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIGlmKHByZWZpeChldnQucHJvcGVydHlOYW1lKSA9PT0gcHJlZml4KHByZWZpeGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjYih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbmVuZCwgY2JUcmFuc2l0aW9uZW5kKTtcblxuICAgICAgICBRYW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbihlbCwgYXR0ciwgbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUodmFsdWUpLCBkdXJhdGlvbiwgZWFzaW5nKTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF3VmFsID0gZWwuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcmVmaXhlZCksXG4gICAgICAgICAgICAgICAgICAgIGRvbVZhbCA9IG5vcm1hbGl6ZVRyYW5zZm9ybVZhbHVlKHJhd1ZhbCksXG4gICAgICAgICAgICAgICAgICAgIGdpdmVuVmFsID0gbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbVZhbCA9PT0gZ2l2ZW5WYWwpIHsgZC5yZXNvbHZlKGVsKTsgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkLnJlamVjdCggbmV3IEVycm9yKFwiWmFuaW1vIHRyYW5zaXRpb246IHdpdGggXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYXR0ciArIFwiID0gXCIgKyBnaXZlblZhbCArIFwiLCBET00gdmFsdWU9XCIgKyBkb21WYWxcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZHVyYXRpb24gKyAyMCApO1xuXG4gICAgICAgICAgICBlbC5femFuaW1vID0gZWwuX3phbmltbyB8fCB7IH07XG4gICAgICAgICAgICBpZihlbC5femFuaW1vW2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgZWwuX3phbmltb1thdHRyXS5kZWZlci5yZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlphbmltbyB0cmFuc2l0aW9uIHdpdGggXCIgK1xuICAgICAgICAgICAgICAgICAgICBhdHRyICsgXCI9XCIgKyBlbC5femFuaW1vW2F0dHJdLnZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgXCIgc3RvcHBlZCBieSB0cmFuc2l0aW9uIHdpdGggXCIgKyBhdHRyICsgXCI9XCIgKyB2YWx1ZVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGVsLl96YW5pbW9bYXR0cl0uY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl96YW5pbW9bYXR0cl0gPSB7Y2I6IGNiLCB2YWx1ZTogdmFsdWUsIGRlZmVyOiBkfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgICB9O1xuXG4vKipcbiAqIFphbmltbyhlbCB8IHByb21pc2VbZWxdKVxuICogPiBSZXR1cm5zIGEgUHJvbWlzZSBvZiBlbC5cbiAqXG4gKiBaYW5pbW8oZWwgfCBwcm9taXNlW2VsXSwgYXR0ciwgdmFsdWUpXG4gKiA+IFNldHMgZWwuc3R5bGVbYXR0cl09dmFsdWUgYW5kIHJldHVybnMgdGhlIHByb21pc2Ugb2YgZWwuXG4gKlxuICogWmFuaW1vKGVsIHwgcHJvbWlzZVtlbF0sIGF0dHIsIHZhbHVlLCBkdXJhdGlvbiwgW2Vhc2luZ10pXG4gKiA+IFBlcmZvcm1zIGEgdHJhbnNpdGlvbi5cbiAqL1xudmFyIFphbmltbyA9IGZ1bmN0aW9uIChlbCwgYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgYXJpdHkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChhcml0eSA9PT0gMCB8fCBhcml0eSA9PT0gMiB8fCBhcml0eSA+IDUpIHtcbiAgICAgICAgcmV0dXJuIFEucmVqZWN0KG5ldyBFcnJvcihcIlphbmltbyBpbnZhbGlkIGFyZ3VtZW50c1wiKSk7XG4gICAgfVxuICAgIGlmIChRLmlzUHJvbWlzZShlbCkpIHtcbiAgICAgICAgcmV0dXJuIGVsLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIFphbmltby5hcHBseSh0aGlzLCBbdmFsXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaXNET00oZWwpKSB7XG4gICAgICAgIHJldHVybiBRLnJlamVjdChuZXcgRXJyb3IoXCJaYW5pbW8gcmVxdWlyZSBhbiBIVE1MRWxlbWVudCwgb3IgYSBwcm9taXNlIG9mIGFuIEhUTUxFbGVtZW50XCIpKTtcbiAgICB9XG4gICAgaWYgKGFyaXR5ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBRKGVsKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcHJlZml4LmRhc2goYXR0cik7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFEucmVqZWN0KG5ldyBFcnJvcihcIlphbmltbyB0cmFuc2l0aW9uOiBcIiArIGF0dHIgKyAnIGlzIG5vdCBzdXBwb3J0ZWQhJykpO1xuICAgIH07XG4gICAgaWYgKGFyaXR5ID09PSAzKSB7XG4gICAgICAgIHJldHVybiBjc3MoZWwsIGF0dHIsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYod2luZG93LmlzTmFOKHBhcnNlSW50KGR1cmF0aW9uLCAxMCkpKSB7XG4gICAgICAgIHJldHVybiBRLnJlamVjdChuZXcgRXJyb3IoXCJaYW5pbW8gdHJhbnNpdGlvbjogZHVyYXRpb24gbXVzdCBiZSBhbiBpbnRlZ2VyIVwiKSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRlKGVsLCBhdHRyLCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZyk7XG59O1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gd3JhcHBpbmcgYFphbmltbyhlbCwgLi4uKWAgYXMgYSBgZiguLi4pKGVsKWAgZm9yIGVhc3kgY2hhaW5pbmcgcHVycG9zZS5cbiAqL1xuWmFuaW1vLmYgPSBmdW5jdGlvbiAoYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gWmFuaW1vLmFwcGx5KHRoaXMsIFtlbF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBaYW5pbW87XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRjaFBhcmVudGhlc2lzID0gLyhcXCguKz9cXCkpL2csXG4gICAgc3BhY2UgPSAvICsvZyxcbiAgICBlbXB0eVN0cmluZyA9IFwiXCIsXG4gICAgd2hpdGVzcGFjZSA9IFwiIFwiLFxuXG4gICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHZhciBhcmdzID0gbWF0Y2guc3Vic3RyKDEsIG1hdGNoLmxlbmd0aC0yKS5zcGxpdChcIixcIiksXG4gICAgICAgICAgICByc3QgPSBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYXJnLnJlcGxhY2Uoc3BhY2UsIGVtcHR5U3RyaW5nKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgcnN0LmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAgdHlwZW9mIHQgPT09ICdzdHJpbmcnID8gdC5yZXBsYWNlKHNwYWNlLCB3aGl0ZXNwYWNlKS5yZXBsYWNlKG1hdGNoUGFyZW50aGVzaXMsIG5vcm1hbGl6ZSkgOiB0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbG9yID0gcmVxdWlyZSgnY29sb3InKSxcbiAgICBtYXRjaFBhcmVudGhlc2lzID0gLyhcXCguKz9cXCkpL2csXG4gICAgbWF0Y2hDb2xvcnMgPSAvKFxcYnJnYmFcXGJ8XFxiaHNsXFxifFxcYmhzbGFcXGIpKFxcKC4rP1xcKSkvZyxcbiAgICBzcGFjZSA9IC8gKy9nLFxuICAgIGVtcHR5U3RyaW5nID0gXCJcIixcbiAgICB3aGl0ZXNwYWNlID0gXCIgXCIsXG4gICAgemVyb3BpeGVsID0gL14wcHgkL2csXG4gICAgemVybyA9IFwiMFwiLFxuXG4gICAgbm9ybUFyZ3MgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5zdWJzdHIoMSwgbWF0Y2gubGVuZ3RoLTIpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICAgIHJzdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnJlcGxhY2Uoc3BhY2UsIGVtcHR5U3RyaW5nKS5yZXBsYWNlKHplcm9waXhlbCwgemVybyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgcnN0LmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfSxcblxuICAgIG5vcm1Db2xvcnMgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGMgPSBDb2xvcihtYXRjaCk7XG4gICAgICAgIGlmIChjLmFscGhhKCkgKSB7IGMuYWxwaGEoTWF0aC5yb3VuZChjLmFscGhhKCkgKiAxMCkgLyAxMCk7IH1cbiAgICAgICAgcmV0dXJuIGMucmdiU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5yZXBsYWNlKHNwYWNlLCB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgLnJlcGxhY2UobWF0Y2hDb2xvcnMsIG5vcm1Db2xvcnMpXG4gICAgICAgICAgICAucmVwbGFjZShtYXRjaFBhcmVudGhlc2lzLCBub3JtQXJncyk7XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGVtcHR5U3RyaW5nO1xuICAgIHJldHVybiB3aW5kb3cuaXNOYU4odmFsKSA/IG5vcm1hbGl6ZSh2YWwpIDogdmFsLnRvU3RyaW5nKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJlZml4ID0gcmVxdWlyZSgndmVuZG9yLXByZWZpeCcpLFxuICAgIG5vcm1hbGl6ZVRyYW5zZm9ybVZhbHVlID0gcmVxdWlyZSgnLi9ub3JtYWxpemUtdHJhbnNmb3JtLXZhbHVlJyksXG4gICAgbm9ybWFsaXplVGltaW5nRnVuY3Rpb24gPSByZXF1aXJlKCcuL25vcm1hbGl6ZS10aW1pbmctZnVuY3Rpb24nKSxcbiAgICB0cmFuc2l0aW9uID0gcHJlZml4LmRhc2goJ3RyYW5zaXRpb24nKSxcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHRlc3QgPSAnb3BhY2l0eSAxMDBtcyBsaW5lYXIgMHMnLFxuICAgIG5vcm1hbGl6ZWRUZXN0ID0gbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUodGVzdCksXG4gICAgc2hvcnRoYW5kID0gZnVuY3Rpb24gc2hvcnRoYW5kKHYsIGQsIHQpIHtcbiAgICAgICAgcmV0dXJuIHYgKyBcIiBcIiArIGQgKyBcIm1zIFwiICsgKHQgfHwgXCJsaW5lYXJcIik7XG4gICAgfTtcblxuZWwuc3R5bGVbdHJhbnNpdGlvbl0gPSBub3JtYWxpemVkVGVzdDtcblxuaWYobm9ybWFsaXplVHJhbnNmb3JtVmFsdWUoZWwuc3R5bGVbdHJhbnNpdGlvbl0pID09PSBub3JtYWxpemVkVGVzdCkge1xuICAgIHNob3J0aGFuZCA9IGZ1bmN0aW9uICh2LCBkLCB0KSB7XG4gICAgICAgIHJldHVybiB2ICsgXCIgXCIgKyBkICsgXCJtcyBcIiArIChub3JtYWxpemVUaW1pbmdGdW5jdGlvbih0KSB8fCBcImxpbmVhclwiKSArIFwiIDBzXCI7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydGhhbmQ7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICdsb2Rhc2gvaXNGdW5jdGlvbic7XG5pbXBvcnQgaTE4biBmcm9tICcuL2kxOG4nO1xuaW1wb3J0IHsgYmFja0hpc3RvcnkgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiYWNrYnV0dG9uKCkge1xuICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuICBpZiAoaXNGdW5jdGlvbihiKSkge1xuICAgIGIoJ2JhY2tidXR0b24nKTtcbiAgICBtLnJlZHJhdygpO1xuICB9IGVsc2UgaWYgKCEvXlxcLyQvLnRlc3QobS5yb3V0ZSgpKSkge1xuICAgIC8vIGlmIHBsYXlpbmcgYSBnYW1lIGFzIGFub24gYXNrIGZvciBjb25maXJtYXRpb25cbiAgICBpZiAoL15cXC9nYW1lXFwvW2EtekEtWjAtOV17MTJ9Ly50ZXN0KG0ucm91dGUoKSkpIHtcbiAgICAgIG5hdmlnYXRvci5ub3RpZmljYXRpb24uY29uZmlybShcbiAgICAgICAgaTE4bigndGhlcmVJc0FHYW1lSW5Qcm9ncmVzcycpLFxuICAgICAgICBpID0+IHsgaWYgKGk9PT0xKSBiYWNrSGlzdG9yeSgpOyB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrSGlzdG9yeSgpO1xuICAgIH1cbiAgfWVsc2Uge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgfVxufTtcblxuYmFja2J1dHRvbi5zdGFjayA9IHN0YWNrO1xuIiwiY29uc3QgZGVmYXVsdHMgPSB7XG4gIGFwaVZlcnNpb246IDEsXG4gIGZldGNoVGltZW91dE1zOiAxMDAwMFxufTtcblxuY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHdpbmRvdy5veXVua2V5Zik7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmZpZztcbiIsImltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xuaW1wb3J0IHNwaW5uZXIgZnJvbSAnLi9zcGlubmVyJztcbmltcG9ydCBnbG9iYWxDb25maWcgZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgYnVpbGRRdWVyeVN0cmluZyB9IGZyb20gJy4vdXRpbHMvcXVlcnlzdHJpbmcnO1xuaW1wb3J0IHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlJztcblxuZXhwb3J0IGNvbnN0IFNFU1NJT05fSURfS0VZID0gJ3Nlc3Npb25JZCc7XG5cbmNvbnN0IGJhc2VVcmwgPSBnbG9iYWxDb25maWcuYXBpRW5kUG9pbnQ7XG5cbmZ1bmN0aW9uIGFkZFF1ZXJ5U3RyaW5nKHVybCwgcXVlcnlTdHJpbmcpIHtcbiAgY29uc3QgcHJlZml4ID0gdXJsLmluZGV4T2YoJz8nKSA8IDAgPyAnPycgOiAnJic7XG4gIGxldCByZXMgPSB1cmwgKyBwcmVmaXggKyBxdWVyeVN0cmluZztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcmVxdWVzdCh1cmwsIHR5cGUsIG9wdHMsIGZlZWRiYWNrKSB7XG5cbiAgbGV0IHRpbWVvdXRJZDtcblxuICBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIGlmIChmZWVkYmFjaykgc3Bpbm5lci5zdG9wKCk7XG4gIH1cblxuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKG9wdHMucXVlcnkpO1xuICAgIGlmIChxdWVyeSAhPT0gJycpIHtcbiAgICAgIHVybCA9IGFkZFF1ZXJ5U3RyaW5nKHVybCwgcXVlcnkpO1xuICAgIH1cbiAgICBkZWxldGUgb3B0cy5xdWVyeTtcbiAgfVxuICBcbiAgY29uc3QgY2ZnID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi92bmQub3l1bmtleWYudicgKyBnbG9iYWxDb25maWcuYXBpVmVyc2lvbiArICcranNvbidcbiAgICB9XG4gIH07XG5cbiAgbWVyZ2UoY2ZnLCBvcHRzKTtcblxuICBjb25zdCBpbml0ID0ge1xuICAgIC4uLmNmZyxcbiAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGNmZy5oZWFkZXJzKVxuICB9O1xuXG4gIGlmICgoaW5pdC5tZXRob2QgPT09ICdQT1NUJyB8fCBpbml0Lm1ldGhvZCA9PT0gJ1BVVCcpICYmXG4gICAgICAhaW5pdC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykpIHtcbiAgICAoaW5pdC5oZWFkZXJzKS5hcHBlbmQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURi04Jyk7XG4gICAgaWYgKCFpbml0LmJvZHkpe1xuICAgICAgaW5pdC5ib2R5ID0gJ3t9JztcbiAgICB9XG4gIH1cblxuICBjb25zdCBzaWQgPSBzdG9yYWdlLmdldChTRVNTSU9OX0lEX0tFWSk7XG4gIGlmIChzaWQgIT09IG51bGwpIHtcbiAgICBpbml0LmhlYWRlcnMuYXBwZW5kKFNFU1NJT05fSURfS0VZLCBzaWQpO1xuICB9XG5cbiAgY29uc3QgZnVsbFVybCA9IHVybC5pbmRleE9mKCdodHRwJykgPiAtMSA/IHVybCA6IGJhc2VVcmwgKyB1cmw7XG5cbiAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dChcbiAgICAgICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dCcpKSxcbiAgICAgIGdsb2JhbENvbmZpZy5mZXRjaFRpbWVvdXRNc1xuICAgICk7XG4gIH0pO1xuXG4gIGNvbnN0IHJlc3BPclRpbWVvdXQgPSBQcm9taXNlLnJhY2UoW1xuICAgIGZldGNoKGZ1bGxVcmwsIGluaXQpLFxuICAgIHRpbWVvdXRQcm9taXNlXG4gIF0pO1xuXG4gIGlmIChmZWVkYmFjaykge1xuICAgIHNwaW5uZXIuc3BpbigpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXNwT3JUaW1lb3V0XG4gICAgICAudGhlbigocikgPT4ge1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIGlmIChyLm9rKSB7XG4gICAgICAgICAgcmVzb2x2ZShyW3R5cGVdKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIudGV4dCgpXG4gICAgICAgICAgICAudGhlbigoYm9keVRleHQpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgc3RhdHVzOiByLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04ucGFyc2UoYm9keVRleHQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgc3RhdHVzOiByLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHIuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yICcgKyBlcnIpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgIGJvZHk6IGVyci5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hKU09OKHVybCwgb3B0cywgZmVlZGJhY2sgPSBmYWxzZSkge1xuICByZXR1cm4gcmVxdWVzdCh1cmwsICdqc29uJywgb3B0cywgZmVlZGJhY2spO1xufVxuXG5leHBvcnQgY29uc3QgYXBpVmVyc2lvbiA9IDE7XG5cbi8vIGNvbnN0IGJhc2VVcmwgPSB3aW5kb3cub3l1bmtleWYuYXBpRW5kUG9pbnQ7XG5cbmZ1bmN0aW9uIG9uU3VjY2VzcyhkYXRhKSB7XG4gIHNwaW5uZXIuc3RvcCgpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gb25FcnJvcihkYXRhKSB7XG4gIHNwaW5uZXIuc3RvcCgpO1xuICB0aHJvdyBkYXRhO1xufVxuXG5mdW5jdGlvbiB4aHJDb25maWcoeGhyKSB7XG4gIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vdm5kLm95dW5rZXlmLnYnICsgYXBpVmVyc2lvbiArICcranNvbicpO1xuICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgeGhyLnRpbWVvdXQgPSA4MDAwO1xufVxuXG4vLyBjb252ZW5pZW50IHdyYXBwZXIgYXJvdW5kIG0ucmVxdWVzdFxuLy8gZXhwb3J0IGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRzLCBmZWVkYmFjaywgeGhyQ29uZikge1xuLy8gICB2YXIgY2ZnID0ge1xuLy8gICAgIHVybDogYmFzZVVybCArIHVybCxcbi8vICAgICBtZXRob2Q6ICdHRVQnLFxuLy8gICAgIGRhdGE6IHsgfSxcbi8vICAgICBjb25maWc6IHhockNvbmYgfHwgeGhyQ29uZmlnLFxuLy8gICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbih0ZXh0KSB7XG4vLyAgICAgICB0cnkge1xuLy8gICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbi8vICAgICAgIH0gY2F0Y2ggKGUpIHtcbi8vICAgICAgICAgdGhyb3cgeyByZXNwb25zZTogeyBlcnJvcjogJ0Nhbm5vdCByZWFkIGRhdGEgZnJvbSB0aGUgc2VydmVyJyB9fTtcbi8vICAgICAgIH1cbi8vICAgICB9LFxuLy8gICAgIHVud3JhcEVycm9yOiBmdW5jdGlvbihyZXNwb25zZSwgeGhyKSB7XG4vLyAgICAgICByZXR1cm4geyByZXNwb25zZSwgc3RhdHVzOiB4aHIuc3RhdHVzIH07XG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICBtZXJnZShjZmcsIG9wdHMpO1xuXG4vLyAgIGlmIChjZmcubWV0aG9kID09PSAnR0VUJykge1xuLy8gICAgIGNmZy5kYXRhLl8gPSBEYXRlLm5vdygpO1xuLy8gICB9XG5cbi8vICAgdmFyIHByb21pc2UgPSBtLnJlcXVlc3QoY2ZnKTtcblxuLy8gICBpZiAoZmVlZGJhY2spIHtcbi8vICAgICBzcGlubmVyLnNwaW4oZG9jdW1lbnQuYm9keSk7XG4vLyAgICAgcmV0dXJuIHByb21pc2UudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuLy8gICB9IGVsc2Uge1xuLy8gICAgIHJldHVybiBwcm9taXNlO1xuLy8gICB9XG4vLyB9IFxuIiwiaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgbG9hZExvY2FsSnNvbkZpbGUgfSBmcm9tICcuL3V0aWxzJztcblxuXG5jb25zdCBkZWZhdWx0Q29kZSA9ICd0cic7XG5cbmxldCBsYW5nID0gZGVmYXVsdENvZGU7XG5sZXQgbWVzc2FnZXMgPSB7fTtcblxuY29uc3QgdW50cmFuc2xhdGVkID0ge1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmcoKSB7XG4gIHJldHVybiBsYW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpMThuKGtleSwgLi4uYXJncykge1xuICB2YXIgc3RyID0gbWVzc2FnZXNba2V5XSB8fCB1bnRyYW5zbGF0ZWRba2V5XXx8IGtleTtcbiAgYXJncy5mb3JFYWNoKGEgPT4geyBzdHIgPSBzdHIucmVwbGFjZSgnJXMnLCBTdHJpbmcoYSkpOyB9KTtcbiAgXG4gIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUHJlZmVycmVkTGFuZ3VhZ2UoKSB7XG4gIGNvbnN0IGZyb21TZXR0aW5ncyA9IHNldHRpbmdzLmdlbmVyYWwubGFuZygpO1xuICBpZiAoZnJvbVNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGxvYWRMYW5ndWFnZShmcm9tU2V0dGluZ3MpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbi5nZXRQcmVmZXJyZWRMYW5ndWFnZShcbiAgICAgIGwgPT4gcmVzb2x2ZShsLnZhbHVlLnNwbGl0KCctJylbMF0pLFxuICAgICAgKCkgPT4gcmVzb2x2ZShkZWZhdWx0Q29kZSlcbiAgICApO1xuICB9KS50aGVuKChjb2RlKSA9PiB7XG4gICAgc2V0dGluZ3MuZ2VuZXJhbC5sYW5nKGNvZGUpO1xuICAgIHJldHVybiBjb2RlO1xuICB9KS50aGVuKGxvYWRGaWxlKVxuICAgIC50aGVuKGxvYWRNb21lbnRMb2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZExhbmd1YWdlKGxhbmcpIHtcbiAgcmV0dXJuIGxvYWRGaWxlKGxhbmcpXG4gICAgLnRoZW4obG9hZE1vbWVudExvY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRGaWxlKGNvZGUpIHtcbiAgcmV0dXJuIGxvYWRMb2NhbEpzb25GaWxlKCdpMThuLycgKyBjb2RlICsgJy5qc29uJylcbiAgICAudGhlbihkYXRhID0+IHtcbiAgICAgIGxhbmcgPSBjb2RlO1xuICAgICAgbWVzc2FnZXMgPSBkYXRhO1xuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgaWYgKGNvZGUgPT09IGRlZmF1bHRDb2RlKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGxvYWRGaWxlKGRlZmF1bHRDb2RlKTtcbiAgICB9KTtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGdldEF2YWlsYWJsZUxhbmd1YWdlcygpIHtcbi8vICAgcmV0dXJuIG0ucmVxdWVzdCh7XG4vLyAgICAgdXJsOiAnaTE4bi9yZWZzLmpzb24nLFxuLy8gICAgIG1ldGhvZDogJ0dFVCdcbi8vICAgfSkudGhlbihkYXRhID0+IHsgcmV0dXJuIGRhdGE7IH0sIGVycm9yID0+IHtcbi8vICAgICAvLyBzYW1lIHdvcmthcm91bmQgZm9yIGlPUyBhcyBhYm92ZVxuLy8gICAgIGlmIChlcnJvciAmJiBlcnJvclswXVswXSA9PT0gJ3RyJylcbi8vICAgICAgIHJldHVybiBlcnJvcjtcbi8vICAgICBlbHNlXG4vLyAgICAgICB0aHJvdyB7IGVycm9yOiAnQ2Fubm90IGxvYWQgbGFuZ3VhZ2VzJyB9O1xuLy8gICB9KTtcbi8vIH1cblxuXG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBsb2FkRnJvbVNldHRpbmdzKCkge1xuLy8gICByZXR1cm4gbG9hZEZpbGUoc2V0dGluZ3MuZ2VuZXJhbC5sYW5nKCkpLnRoZW4obG9hZE1vbWVudExvY2FsZSk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGxvYWRGaWxlKGNvZGUpIHtcbi8vICAgcmV0dXJuIG0ucmVxdWVzdCh7XG4vLyAgICAgdXJsOiAnaTE4bi8nICsgY29kZSArICcuanNvbicsXG4vLyAgICAgbWV0aG9kOiAnR0VUJyxcbi8vICAgICBkZXNlcmlhbGl6ZTogZnVuY3Rpb24odGV4dCkge1xuLy8gICAgICAgdHJ5IHtcbi8vICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4vLyAgICAgICB9IGNhdGNoIChlKSB7XG4vLyAgICAgICAgIHRocm93IHsgZXJyb3I6ICdMYW5nIG5vdCBhdmFpbGFibGUnIH07XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbi8vICAgICBtZXNzYWdlcyA9IGRhdGE7XG4vLyAgICAgcmV0dXJuIGNvZGU7XG4vLyAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4vLyAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaU9TOiBiZWNhdXNlIHhociBmb3IgbG9jYWwgZmlsZSBoYXMgYSAwIHN0YXR1cyBpdCB3aWxsXG4vLyAgICAgLy8gcmVqZWN0IHRoZSBwcm9taXNlIGFuZCBzdGlsbCBoYXZlIHRoZSByZXNwb25zZSBvYmplY3Rcbi8vICAgICBpZiAoZXJyb3IgJiYgZXJyb3IucGxheVdpdGhBRnJpZW5kKSB7XG4vLyAgICAgICBtZXNzYWdlcyA9IGVycm9yO1xuLy8gICAgICAgcmV0dXJuIGNvZGU7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIGlmIChjb2RlID09PSBkZWZhdWx0Q29kZSkgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbi8vICAgICAgIHJldHVybiBsb2FkRmlsZShkZWZhdWx0Q29kZSk7XG4vLyAgICAgfVxuLy8gICB9KTtcbi8vIH1cblxuZnVuY3Rpb24gbG9hZE1vbWVudExvY2FsZShjb2RlKSB7XG4gIGlmIChjb2RlICE9PSAnZW4nKSB7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSAnbW9tZW50L2xvY2FsZS8nICsgY29kZSArICcuanMnO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB3aW5kb3cubW9tZW50LmxvY2FsZShjb2RlKTtcbiAgcmV0dXJuIGNvZGU7XG59XG5cbiIsIi8qIGFwcGxpY2F0aW9uIGVudHJ5IHBvaW50ICovXG5cbi8vIGltcG9ydCAnLi9wb2x5ZmlsbHMnO1xuXG5cbi8vIGZvciBtb21lbnQgYSBnbG9iYWwgb2JqZWN0IG1ha2VzIGxvYWRpbmcgbG9jYWxlcyBlYXNpZXJcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbndpbmRvdy5tb21lbnQgPSBtb21lbnQ7XG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi9zZXNzaW9uJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgbG9hZFByZWZlcnJlZExhbmd1YWdlLCBlbnN1cmVMYW5nSXNBdmFpbGFibGUsIGxvYWRMYW5ndWFnZSB9IGZyb20gJy4vaTE4bic7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi94aHInO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4vdWkvaGVscGVyJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4vYmFja2J1dHRvbic7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4vc29ja2V0JztcbmltcG9ydCByb3V0ZXMgZnJvbSAnLi9yb3V0ZXMnO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuL3JvdXRlcic7XG5pbXBvcnQgeyBpc0ZvcmVncm91bmQsIHNldEZvcmVncm91bmQsIHNldEJhY2tncm91bmQgfSBmcm9tICcuL3V0aWxzL2FwcE1vZGUnO1xuXG5sZXQgZmlyc3RDb25uZWN0aW9uID0gdHJ1ZTtcblxuZnVuY3Rpb24gbWFpbigpIHtcbiAgcm91dGVzLmluaXQoKTtcbiAgLy8gY2FjaGUgdmlld3BvcnQgZGltc1xuICBoZWxwZXIudmlld3BvcnREaW0oKTtcblxuICAvLyBwdWxsIHNlc3Npb24gZGF0YSBvbmNlICh0byBsb2cgaW4gdXNlciBhdXRvbWF0aWNhbGx5IHRoYW5rcyB0byBjb29raWUpXG4gIC8vIGFuZCBhbHNvIGxpc3RlbiB0byBvbmxpbmUgZXZlbnQgaW4gY2FzZSBuZXR3b3JrIHdhcyBkaXNjb25uZWN0ZWQgYXQgYXBwXG4gIC8vIHN0YXJ0dXBcbiAgaWYgKHV0aWxzLmhhc05ldHdvcmsoKSkge1xuICAgIG9uT25saW5lKCk7XG4gIH1cblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBvbk9ubGluZSwgZmFsc2UpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgb25PZmZsaW5lLCBmYWxzZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc3VtZScsIG9uUmVzdW1lLCBmYWxzZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgb25QYXVzZSwgZmFsc2UpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgcm91dGVyLmJhY2tidXR0b24sIGZhbHNlKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgc29ja2V0LnRlcm1pbmF0ZSgpO1xuICB9KTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCBmYWxzZSk7XG5cbiAgaWYgKGNvcmRvdmEucGxhdGZvcm1JZCA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgd2luZG93LlN0YXR1c0Jhci5iYWNrZ3JvdW5kQ29sb3JCeUhleFN0cmluZygnIzE1MUExRScpO1xuICB9XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cubmF2aWdhdG9yLnNwbGFzaHNjcmVlbi5oaWRlKCk7XG4gICAgd2luZG93LlN0YXR1c0Jhci5oaWRlKCk7XG4gICAgLy8geGhyU3RhdHVzKCk7XG4gIH0sIDUwMCk7XG59XG5cbmZ1bmN0aW9uIG9uT25saW5lKCkge1xuICBpZiAoaXNGb3JlZ3JvdW5kKCkpIHtcbiAgICBpZiAoZmlyc3RDb25uZWN0aW9uKSB7XG4gICAgICBmaXJzdENvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIC8vIHhoci5zdGF0dXMoKTtcbiAgICAgIFxuICAgICAgc2Vzc2lvbi5yZW1lbWJlckxvZ2luKClcbiAgICAgICAgLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBzZXJ2ZXJMYW5nID0gdXNlci5sYW5ndWFnZSAmJiB1c2VyLmxhbmd1YWdlLnNwbGl0KCctJylbMF07XG4gICAgICAgICAgaWYgKHNlcnZlckxhbmcpIHtcbiAgICAgICAgICAgIGVuc3VyZUxhbmdJc0F2YWlsYWJsZShzZXJ2ZXJMYW5nKVxuICAgICAgICAgICAgICAudGhlbihsYW5nID0+IHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLmxhbmcobGFuZyk7XG4gICAgICAgICAgICAgICAgbG9hZExhbmd1YWdlKGxhbmcpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdGVkIGFzIGFub255bW91cycpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIHNlc3Npb24ucmVmcmVzaCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbk9mZmxpbmUoKSB7XG4gIGlmIChpc0ZvcmVncm91bmQoKSAmJiAhaGFzTmV0d29yaygpKSB7XG4gICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICByZWRyYXcoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgaGVscGVyLmNsZWFyQ2FjaGVkVmlld3BvcnREaW0oKTtcbiAgcmVkcmF3KCk7XG59XG5cbmZ1bmN0aW9uIG9uUmVzdW1lKCkge1xuICBzZXRGb3JlZ3JvdW5kKCk7XG4gIHNlc3Npb24ucmVmcmVzaCgpO1xuICBzb2NrZXQuY29ubmVjdCgpO1xuICByZWRyYXcoKTtcbn1cblxuZnVuY3Rpb24gb25QYXVzZSgpIHtcbiAgc2V0QmFja2dyb3VuZCgpO1xuICBzb2NrZXQuZGlzY29ubmVjdCgpO1xufVxuXG4vLyBmdW5jdGlvbiBoYW5kbGVFcnJvcihldmVudCwgc291cmNlLCBmaWxlbm8sIGNvbHVtTnVtYmVyKSB7XG4vLyAgIHZhciBkZXNjcmlwdGlvbiA9IGV2ZW50ICsgJyBhdCAnICsgc291cmNlICsgJyBbJyArIGZpbGVubyArICcsICcgKyBjb2x1bU51bWJlciArICddJztcbi8vIH1cblxuLy8gd2luZG93Lm9uZXJyb3IgPSBoYW5kbGVFcnJvcjtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiBsb2FkUHJlZmVycmVkTGFuZ3VhZ2UoKS50aGVuKG1haW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcbmltcG9ydCBzdGF0dXMgZnJvbSAnLi9zdGF0dXMnO1xuXG5mdW5jdGlvbiBwbGF5YWJsZShkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkIDwgc3RhdHVzLmlkcy5hYm9ydGVkO1xufVxuXG5mdW5jdGlvbiBpc1BsYXllclBsYXlpbmcoZGF0YSkge1xuICByZXR1cm4gcGxheWFibGUoZGF0YSkgJiYgIWRhdGEucGxheWVyLnNwZWN0YXRvcjtcbn1cblxuZnVuY3Rpb24gaXNQbGF5ZXJUdXJuKGRhdGEpIHtcbiAgcmV0dXJuIGlzUGxheWVyUGxheWluZyhkYXRhKSAmJiBkYXRhLmdhbWUucGxheWVyID09PSBkYXRhLnBsYXllci5zaWRlO1xufVxuXG5mdW5jdGlvbiBnZXRQbGF5ZXIoZGF0YSwgc2lkZSkge1xuICByZXR1cm4gWydwbGF5ZXInLCAnb3Bwb25lbnRMZWZ0JywgJ29wcG9uZW50UmlnaHQnLCAnb3Bwb25lbnRVcCddXG4gICAgLm1hcChrID0+IGRhdGFba10pXG4gICAgLmZpbHRlcihwbGF5ZXIgPT4gcGxheWVyLnNpZGUgPT09IHNpZGUpWzBdO1xufVxuXG5mdW5jdGlvbiByZXN1bHQoZGF0YSkge1xuICBpZiAoc3RhdHVzLmFib3J0ZWQoZGF0YSkpIHtcbiAgICByZXR1cm4gaTE4bignZ2FtZUFib3J0ZWQnKTtcbiAgfSBlbHNlIGlmIChzdGF0dXMuZmluaXNoZWQoZGF0YSkpIHtcbiAgICByZXR1cm4gaTE4bignZ2FtZUZpbmlzaGVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IHNpZGVzID0gW1wiZWFzdFwiLCBcIm5vcnRoXCIsIFwid2VzdFwiLCBcInNvdXRoXCJdO1xuXG5mdW5jdGlvbiBzaWRlQnlQbHkocGx5KSB7XG4gIHJldHVybiBzaWRlc1twbHkgJSA0XTtcbn1cblxuZnVuY3Rpb24gc2V0T25HYW1lKGRhdGEsIHNpZGUsIG9uR2FtZSkge1xuICB2YXIgcGxheWVyID0gZ2V0UGxheWVyKGRhdGEsIHNpZGUpO1xuICBwbGF5ZXIub25HYW1lID0gb25HYW1lO1xufVxuXG4vLyBmdW5jdGlvbiByb3VuZHNPclNjb3JlcyhnYW1lKSB7XG4vLyAgIGlmIChnYW1lLnJvdW5kcykge1xuLy8gICAgIHJldHVybiBkYXRhLlxuLy8gICB9IGVsc2UgaWYgKGRhdGEuc2NvcmVzKSB7XG4gICAgXG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgcmV0dXJuICcnO1xuLy8gICB9XG4vLyB9XG5cbmZ1bmN0aW9uIHRpdGxlKGRhdGEpIHtcbiAgdmFyIHRleHQ7XG4gIGlmIChpc1BsYXllclR1cm4oZGF0YSkpIHtcbiAgICB0ZXh0ID0gaTE4bigneW91clR1cm4nKTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0ID0gaTE4bignd2FpdGluZ0Zvck9wcG9uZW50Jyk7XG4gIH1cbiAgLy8gY29uc3QgdmFyaWFudCA9IGdldFZhcmlhbnQoZGF0YS5nYW1lLnZhcmlhbnQua2V5KTtcbiAgLy8gY29uc3QgbmFtZSA9IHZhcmlhbnQgPyAodmFyaWFudC5zaG9ydE5hbWUgfHwgdmFyaWFudC5uYW1lKSA6ICcnO1xuICByZXR1cm4gdGV4dDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc1BsYXllclBsYXlpbmcsXG4gIGlzUGxheWVyVHVybixcbiAgZ2V0UGxheWVyLFxuICBzaWRlQnlQbHksXG4gIHBsYXlhYmxlLFxuICBzZXRPbkdhbWUsXG4gIHRpdGxlLFxuICByZXN1bHRcbn07XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcblxuZXhwb3J0IGZ1bmN0aW9uIHBsYXllck5hbWUocGxheWVyKSB7XG4gIGlmIChwbGF5ZXIubmFtZSB8fCBwbGF5ZXIudXNlcm5hbWUgfHwgcGxheWVyLnVzZXIpIHtcbiAgICBsZXQgbmFtZSA9IHBsYXllci5uYW1lIHx8IHBsYXllci51c2VybmFtZSB8fCBwbGF5ZXIudXNlci51c2VybmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBpZiAocGxheWVyLmFpKSB7XG4gICAgcmV0dXJuIGFpTmFtZShwbGF5ZXIpO1xuICB9XG4gIHJldHVybiAnQW5vbnltb3VzJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFpTmFtZShwbGF5ZXIpIHtcbiAgcmV0dXJuIGkxOG4oJ2FpQm90JywgMSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaHVtYW5TZXR1cEZyb21TZXR0aW5ncyhzZXR0aW5nc09iaikge1xuICByZXR1cm4ge1xuICAgIG1vZGU6IHNldHRpbmdzT2JqLm1vZGUoKSxcbiAgICB2YXJpYW50OiBzZXR0aW5nc09iai52YXJpYW50KCksXG4gICAgcm91bmRzOiBzZXR0aW5nc09iai5yb3VuZHMoKVxuICB9O1xufVxuIiwiLy8gc2NhbGFva2V5L3NyYy9tYWluL3NjYWxhL1N0YXR1cy5zY2FsYVxuXG5pbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcblxuY29uc3QgaWRzID0ge1xuICBjcmVhdGVkOiAxMCxcbiAgc3RhcnRlZDogMjAsXG4gIGFib3J0ZWQ6IDI1LFxuICBtaWRkbGVFbmQ6IDMwLFxuICBub3JtYWxFbmQ6IDQwLFxuICB2YXJpYW50RW5kOiA3MFxufTtcblxuZnVuY3Rpb24gc3RhcnRlZChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkID49IGlkcy5zdGFydGVkO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hlZChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkID49IGlkcy5taWRkbGVFbmQ7XG59XG5cbmZ1bmN0aW9uIGFib3J0ZWQoZGF0YSkge1xuICByZXR1cm4gZGF0YS5nYW1lLnN0YXR1cy5pZCA9PT0gaWRzLmFib3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1pZGRsZUVuZChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkID09PSBpZHMubWlkZGxlRW5kO1xufVxuXG5cbmZ1bmN0aW9uIHBsYXlpbmcoZGF0YSkge1xuICByZXR1cm4gc3RhcnRlZChkYXRhKSAmJiAhZmluaXNoZWQoZGF0YSkgJiYgIWFib3J0ZWQoZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHRvTGFiZWwoc3RhdHVzLCB3aW5uZXIsIHZhcmlhbnQpIHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgY2FzZSAnc3RhcnRlZCc6XG4gICAgcmV0dXJuIGkxOG4oJ3BsYXlpbmdSaWdodE5vdycpO1xuICBjYXNlICdhYm9ydGVkJzpcbiAgICByZXR1cm4gaTE4bignZ2FtZUFib3J0ZWQnKTtcbiAgY2FzZSAnbWlkZGxlRW5kJzpcbiAgICByZXR1cm4gaTE4bignZ2FtZU1pZGRsZUZpbmlzaGVkJyk7XG4gIGNhc2UgJ25vcm1hbEVuZCc6XG4gICAgcmV0dXJuIGkxOG4oJ2dhbWVGaW5pc2hlZCcpO1xuICBjYXNlICd2YXJpYW50RW5kJzpcbiAgICByZXR1cm4gaTE4bignZ2FtZUZpbmlzaGVkJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWRzLFxuICBzdGFydGVkLFxuICBmaW5pc2hlZCxcbiAgYWJvcnRlZCxcbiAgcGxheWluZyxcbiAgbWlkZGxlRW5kLFxuICB0b0xhYmVsXG59O1xuIiwiaW1wb3J0IFJsaXRlIGZyb20gJ3JsaXRlLXJvdXRlcic7XG5pbXBvcnQgKiBhcyBSZW5kZXJTZXJ2aWNlIGZyb20gJ21pdGhyaWwvcmVuZGVyJztcbmltcG9ydCBWbm9kZSBmcm9tICdtaXRocmlsL3JlbmRlci92bm9kZSc7XG5pbXBvcnQgc2lnbmFscyBmcm9tICcuL3NpZ25hbHMnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuL3V0aWxzL3JlZHJhdyc7XG5cbmNvbnN0IHJvdXRlciA9IG5ldyBSbGl0ZSgpO1xuXG5sZXQgY3VycmVudFN0YXRlSWQgPSAwO1xubGV0IHZpZXdTbGlkZURpcmVjdGlvbiA9ICdmd2QnO1xuXG5sZXQgcHJldmlvdXNQYXRoID0gJy8nO1xuXG5jb25zdCB1aWQgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiAoKSA9PiBpZCsrO1xufSkoKTtcblxuY29uc3QgYmFja2J1dHRvbiA9ICgoKSA9PiB7XG4gIGNvbnN0IHggPSAoKSA9PiB7XG5cbiAgICBjb25zdCBiID0gKHguc3RhY2subGVuZ3RoID09PSAwKSA/bnVsbDp4LnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oYikpIHtcbiAgICAgIGIoJ2JhY2tidXR0b24nKTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH0gZWxzZSBpZiAoIS9eXFwvJC8udGVzdChnZXQoKSkpIHtcbiAgICAgIGJhY2tIaXN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgICB9XG4gICAgXG4gIH07XG5cbiAgeC5zdGFjayA9IFtdO1xuICBcbiAgcmV0dXJuIHg7XG59KSgpO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUm91dGVzKG1vdW50UG9pbnQsIHJvdXRlcykge1xuXG4gIGZvciAobGV0IHJvdXRlIGluIHJvdXRlcykge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlc1tyb3V0ZV07XG4gICAgcm91dGVyLmFkZChyb3V0ZSwgZnVuY3Rpb24gb25Sb3V0ZU1hdGNoKHsgcGFyYW1zIH0pIHtcbiAgICAgIGNvbnN0IFJvdXRlQ29tcG9uZW50ID0geyB2aWV3KCkge1xuICAgICAgICB2YXIgbm9kZSA9IFZub2RlKGNvbXBvbmVudCwgdW5kZWZpbmVkLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH19O1xuXG4gICAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgIFJlbmRlclNlcnZpY2UucmVuZGVyKG1vdW50UG9pbnQsIFZub2RlKFJvdXRlQ29tcG9uZW50KSk7XG4gICAgICB9XG5cbiAgICAgIHNpZ25hbHMucmVkcmF3LnJlbW92ZUFsbCgpO1xuICAgICAgc2lnbmFscy5yZWRyYXcuYWRkKHJlZHJhdyk7XG4gICAgICB0cnkge1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2lnbmFscy5yZWRyYXcucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgcHJvY2Vzc1F1ZXJ5c3RyaW5nKTtcbiAgcHJvY2Vzc1F1ZXJ5c3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NRdWVyeXN0cmluZyhlKSB7XG4gIGlmIChlICYmIGUuc3RhdGUpIHtcbiAgICBpZiAoZS5zdGF0ZS5pZCA8IGN1cnJlbnRTdGF0ZUlkKSB7XG4gICAgICB2aWV3U2xpZGVEaXJlY3Rpb24gPSAnYndkJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld1NsaWRlRGlyZWN0aW9uID0gJ2Z3ZCc7XG4gICAgfVxuICAgIGN1cnJlbnRTdGF0ZUlkID0gZS5zdGF0ZS5pZDtcbiAgfVxuICBwcmV2aW91c1BhdGggPSBnZXQoKTtcbiAgY29uc3QgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8ICc/PSc7XG4gIGNvbnN0IG1hdGNoZWQgPSByb3V0ZXIucnVuKHFzLnNsaWNlKDIpKTtcbiAgaWYgKCFtYXRjaGVkKSByb3V0ZXIucnVuKCcvJyk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnblN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZSA/XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgc3RhdGUpIDpcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zdGF0ZTtcblxuICAgIGlmIChwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShuZXdTdGF0ZSwgJycsICc/PScgKyBwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG5ld1N0YXRlLCAnJyk7XG4gICAgfVxuICB9IGNhdGNoKGUpIHsgY29uc29sZS5lcnJvcihlKTsgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlUGF0aChwYXRoKSB7XG4gIGFzc2lnblN0YXRlKHVuZGVmaW5lZCwgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGRvU2V0KHBhdGgsIHJlcGxhY2UgPSBmYWxzZSkge1xuICBiYWNrYnV0dG9uLnN0YWNrID0gW107XG4gIHByZXZpb3VzUGF0aCA9IGdldCgpO1xuICBpZiAocmVwbGFjZSkge1xuICAgIHJlcGxhY2VQYXRoKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0YXRlSWQgPSB1aWQoKTtcbiAgICBjdXJyZW50U3RhdGVJZCA9IHN0YXRlSWQ7XG4gICAgdmlld1NsaWRlRGlyZWN0aW9uID0gJ2Z3ZCc7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7IGlkOiBzdGF0ZUlkIH0sICcnLCAnPz0nICsgcGF0aCk7XG4gICAgfSBjYXRjaCAoZSkgeyBjb25zb2xlLmVycm9yKGUpOyB9XG4gIH1cbiAgY29uc3QgbWF0Y2hlZCA9IHJvdXRlci5ydW4ocGF0aCk7XG4gIGlmICghbWF0Y2hlZCkgcm91dGVyLnJ1bignLycpO1xufVxuXG5mdW5jdGlvbiBzZXQocGF0aCwgcmVwbGFjZSA9IGZhbHNlKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4gZG9TZXQocGF0aCwgcmVwbGFjZSksIDApO1xufVxuXG5mdW5jdGlvbiBnZXQoKSB7XG4gIGNvbnN0IHBhdGggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8ICc/PS8nO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhdGguc3Vic3RyaW5nKDIpKTtcbn1cblxuZnVuY3Rpb24gYmFja0hpc3RvcnkoKSB7XG4gIHdpbmRvdy5oaXN0b3J5LmdvKC0xKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXQsXG4gIHNldCxcbiAgYmFja2J1dHRvbixcbiAgYmFja0hpc3Rvcnlcbn07XG4iLCJpbXBvcnQgaG9tZSBmcm9tICcuL3VpL2hvbWUnO1xuaW1wb3J0IGdhbWUgZnJvbSAnLi91aS9nYW1lJztcbmltcG9ydCB1c2VyIGZyb20gJy4vdWkvdXNlcic7XG5pbXBvcnQgcGxheWVycyBmcm9tICcuL3VpL3BsYXllcnMnO1xuaW1wb3J0IG1hc2FEZXRhaWwgZnJvbSAnLi91aS9tYXNhL2RldGFpbCc7XG5pbXBvcnQgbWFzYSBmcm9tICcuL3VpL21hc2EnO1xuaW1wb3J0IHNldHRpbmdzVWkgZnJvbSAnLi91aS9zZXR0aW5ncyc7XG5pbXBvcnQgc2V0dGluZ3NMYW5nIGZyb20gJy4vdWkvc2V0dGluZ3MvbGFuZyc7XG5pbXBvcnQgeyBkZWZpbmVSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCgpIHtcbiAgICBkZWZpbmVSb3V0ZXMoZG9jdW1lbnQuYm9keSwge1xuICAgICAgJyc6IGhvbWUsXG4gICAgICAnQC86aWQnOiB1c2VyLFxuICAgICAgJ3BsYXllcnMnOiBwbGF5ZXJzLFxuICAgICAgJ2dhbWUvOmlkJzogZ2FtZSxcbiAgICAgICdtYXNhLzptYXNhSWQvZ2FtZS86aWQnOiBnYW1lLFxuICAgICAgJ21hc2FzJzogbWFzYSxcbiAgICAgICdtYXNhLzppZCc6IG1hc2FEZXRhaWwsXG4gICAgICAnc2V0dGluZ3MnOiBzZXR0aW5nc1VpLFxuICAgICAgJ3NldHRpbmdzL2xhbmcnOiBzZXR0aW5nc0xhbmcsXG4gICAgfSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBTRVNTSU9OX0lEX0tFWSwgZmV0Y2hKU09OIH0gZnJvbSAnLi9odHRwJztcbmltcG9ydCB7IGhhc05ldHdvcmssIGhhbmRsZVhockVycm9yIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgaTE4biBmcm9tICcuL2kxOG4nO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UnO1xuXG5sZXQgc2Vzc2lvbjtcblxuZnVuY3Rpb24gaXNDb25uZWN0ZWQoKSB7XG4gIHJldHVybiBzZXNzaW9uICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFNlc3Npb24oKSB7XG4gIHJldHVybiBzZXNzaW9uO1xufVxuXG5mdW5jdGlvbiBpc1Nlc3Npb24oZGF0YSkge1xuICByZXR1cm4gZGF0YS5pZCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzdG9yZVNlc3Npb24oZCkge1xuICBcbn1cblxuZnVuY3Rpb24gbG9naW4odXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9sb2dpbicsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB1c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkXG4gICAgfSlcbiAgfSwgdHJ1ZSlcbiAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGlzU2Vzc2lvbihkYXRhKSkge1xuICAgICAgICBzZXNzaW9uID0gZGF0YTtcbiAgICAgICAgaWYgKHNlc3Npb24uc2Vzc2lvbklkKSB7XG4gICAgICAgICAgc3RvcmFnZS5zZXQoU0VTU0lPTl9JRF9LRVksIHNlc3Npb24uc2Vzc2lvbklkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdG9yZVNlc3Npb24oZGF0YSk7XG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzaWdudXAodXNlcm5hbWUsIGVtYWlsLCBwYXNzd29yZCkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvc2lnbnVwJywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgZW1haWwsXG4gICAgICBwYXNzd29yZFxuICAgIH0pXG4gIH0sIHRydWUpXG4gICAgLnRoZW4oZCA9PiB7XG4gICAgICBpZiAoaXNTZXNzaW9uKGQpKSB7XG4gICAgICAgIHNlc3Npb24gPSBkO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zZXNzaW9uSWQpIHtcbiAgICAgICAgICBzdG9yYWdlLnNldChTRVNTSU9OX0lEX0tFWSwgc2Vzc2lvbi5zZXNzaW9uSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtZW1iZXJMb2dpbigpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL2FjY291bnQvaW5mbycpXG4gICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHNlc3Npb24gPSBkYXRhO1xuICAgICAgc3RvcmVTZXNzaW9uKGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9hY2NvdW50L2luZm8nLCB7IGNhY2hlOiAncmVsb2FkJyB9KVxuICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICBzZXNzaW9uID0gZGF0YTtcbiAgICAgIHN0b3JlU2Vzc2lvbihkYXRhKTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChzZXNzaW9uICE9PSB1bmRlZmluZWQgJiYgZXJyLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgIHNlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIG9uTG9nb3V0KCk7XG4gICAgICAgIHJlZHJhdygpO1xuICAgICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ3NpZ25lZE91dCcpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uTG9nb3V0KCkge1xuICBzdG9yYWdlLnJlbW92ZShTRVNTSU9OX0lEX0tFWSk7XG4gIHNpZ25hbHMuYWZ0ZXJMb2dvdXQuZGlzcGF0Y2goKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0Nvbm5lY3RlZCxcbiAgc2lnbnVwLFxuICBsb2dpbjogdGhyb3R0bGUobG9naW4sIDEwMDApLFxuICByZW1lbWJlckxvZ2luOiB0aHJvdHRsZShyZW1lbWJlckxvZ2luLCAxMDAwKSxcbiAgZ2V0OiBnZXRTZXNzaW9uLFxuICByZWZyZXNoOiB0aHJvdHRsZShyZWZyZXNoLCAxMDAwKVxufTtcblxuXG4iLCJpbXBvcnQgc3RvcmUgZnJvbSAnLi9zdG9yYWdlJztcbmltcG9ydCByYW5nZSBmcm9tICdsb2Rhc2gvcmFuZ2UnO1xuXG5mdW5jdGlvbiB0dXBsZU9mKHgpIHtcbiAgcmV0dXJuIFt4LnRvU3RyaW5nKCksIHgudG9TdHJpbmcoKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2VuZXJhbDoge1xuICAgIGxhbmc6IHN0b3JlLnByb3AoJ3NldHRpbmdzLmxhbmcnLCBudWxsKSxcbiAgICB0aGVtZToge1xuICAgICAgYmFja2dyb3VuZDogc3RvcmUucHJvcCgnc2V0dGluZ3MuYmdUaGVtZScsICdkYXJrJylcbiAgICB9XG4gIH0sXG4gIGdhbWU6IHtcbiAgICBzdXBwb3J0ZWRWYXJpYW50czogWydzdGFuZGFyZCcsICd5dXpiaXInLCAnZHV6b2tleSddXG4gIH0sXG4gIGdhbWVTZXR1cDoge1xuICAgIGF2YWlsYWJsZVJvdW5kczogWzEsIDUsIDEwLCAxNSwgMjAsIDI1LCAzMF0ubWFwKHR1cGxlT2YpLFxuICAgIGlzUm91bmRWYWxpZDogZnVuY3Rpb24oZ2FtZVNldHRpbmdzKSB7XG4gICAgICByZXR1cm4gZ2FtZVNldHRpbmdzLnJvdW5kcygpICE9PSAnMCc7XG4gICAgfSxcbiAgICBodW1hbjoge1xuICAgICAgYXZhaWxhYmxlVmFyaWFudHM6IFtcbiAgICAgICAgWycxMDEgT2tleScsICcxJ10sXG4gICAgICAgIFsnRMO8eiBPa2V5JywgJzMnXVxuICAgICAgXSxcbiAgICAgIHZhcmlhbnQ6IHN0b3JlLnByb3AoJ3NldHRpbmdzLmdhbWUuaHVtYW4udmFyaWFudCcsICcxJyksXG4gICAgICByb3VuZHM6IHN0b3JlLnByb3AoJ3NldHRpbmdzLmdhbWUuaHVtYW4ucm91bmRzJywgJzEnKSxcbiAgICAgIG1vZGU6IHN0b3JlLnByb3AoJ3NldHRpbmdzLmdhbWUuaHVtYW4ubW9kZScsICcwJyksXG4gICAgICBtZW1iZXJzT25seTogc3RvcmUucHJvcCgnc2V0dGluZ3MuZ2FtZS5odW1hbi5tZW1iZXJzT25seScsIGZhbHNlKVxuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IFNpZ25hbCB9IGZyb20gJ3NpZ25hbHMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICByZWRyYXc6IG5ldyBTaWduYWwoKSxcblxuICBhZnRlckxvZ2luOiBuZXcgU2lnbmFsKCksXG5cbiAgYWZ0ZXJMb2dvdXQ6IG5ldyBTaWduYWwoKSxcblxuICBzZXNzaW9uUmVzdG9yZWQ6IG5ldyBTaWduYWwoKVxuXG59O1xuIiwiaW1wb3J0IGdsb2JhbENvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZSc7XG5pbXBvcnQgeyBTRVNTSU9OX0lEX0tFWSB9IGZyb20gJy4vaHR0cCc7XG5pbXBvcnQgeyBuZXdTcmksIGF1dG9yZWRyYXcsIGhhc05ldHdvcmsgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGFza1dvcmtlciwgdGVsbFdvcmtlciB9IGZyb20gJy4vdXRpbHMvd29ya2VyJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4vc2Vzc2lvbic7XG5cblxuZnVuY3Rpb24gc2V0dXBDb25uZWN0aW9uKHNldHVwLCBzb2NrZXRIYW5kbGVycykge1xuICBjb25zdCBzaWQgPSBzdG9yYWdlLmdldChTRVNTSU9OX0lEX0tFWSk7XG4gIGlmIChzaWQgIT09IG51bGwpIHtcbiAgICBpZiAoc2V0dXAub3B0cy5wYXJhbXMpIHtcbiAgICAgIHNldHVwLm9wdHMucGFyYW1zW1NFU1NJT05fSURfS0VZXSA9IHNpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dXAub3B0cy5wYXJhbXMgPSB7XG4gICAgICAgIFtTRVNTSU9OX0lEX0tFWV06IHNpZFxuICAgICAgfTsgICAgICAgXG4gICAgfVxuICB9IGVsc2UgaWYgKHNldHVwLm9wdHMucGFyYW1zKSB7XG4gICAgZGVsZXRlIHNldHVwLm9wdHMucGFyYW1zLnNlc3Npb25JZDtcbiAgfVxuICBzZXR1cC5vcHRzLm9wdGlvbnMuaXNBdXRoID0gISFzaWQ7XG4gIHdvcmtlci5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgc3dpdGNoIChtc2cuZGF0YS50b3BpYykge1xuICAgIGNhc2UgJ29uT3Blbic6XG4gICAgICBpZiAoc29ja2V0SGFuZGxlcnMub25PcGVuKSBzb2NrZXRIYW5kbGVycy5vbk9wZW4oKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICBvbkRpc2Nvbm5lY3RlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgIG9uQ29ubmVjdGVkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvbkVycm9yJzpcbiAgICAgIGlmIChzb2NrZXRIYW5kbGVycy5vbkVycm9yKSBzb2NrZXRIYW5kbGVycy5vbkVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdoYW5kbGUnOlxuICAgICAgbGV0IGggPSBzb2NrZXRIYW5kbGVycy5ldmVudHNbbXNnLmRhdGEucGF5bG9hZC50XTtcbiAgICAgIGlmIChoKSBoKG1zZy5kYXRhLnBheWxvYWQuZCwgbXNnLmRhdGEucGF5bG9hZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgdGVsbFdvcmtlcih3b3JrZXIsICdjcmVhdGUnLCBzZXR1cCk7XG59XG5cbmZ1bmN0aW9uIG9uQ29ubmVjdGVkKCkge1xuICBpZiAoIWNvbm5lY3RlZFdTKSB7XG4gICAgY29ubmVjdGVkV1MgPSB0cnVlO1xuICAgIHJlZHJhdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uRGlzY29ubmVjdGVkKCkge1xuICBpZiAoY29ubmVjdGVkV1MpIHtcbiAgICBjb25uZWN0ZWRXUyA9IGZhbHNlO1xuICAgIHJlZHJhdygpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVjb25uZWN0Q3VycmVudCgpIHtcbiAgXG59XG5cbmxldCBjb25uZWN0ZWRXUyA9IGZhbHNlO1xuXG5jb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKCdsaWIvc29ja2V0V29ya2VyLmpzJyk7XG5jb25zdCBkZWZhdWx0SGFuZGxlcnMgPSB7XG4gIFxufTtcblxuZnVuY3Rpb24gY3JlYXRlTG9iYnkobmFtZSwgb25PcGVuLCBoYW5kbGVycykge1xuICBjb25zdCBzb2NrZXRIYW5kbGVycyA9IHtcbiAgICBvbk9wZW46ICgpID0+IHtcbiAgICAgIHNlc3Npb24ucmVmcmVzaCgpO1xuICAgICAgb25PcGVuKCk7XG4gICAgfSxcbiAgICBldmVudHM6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIYW5kbGVycywgaGFuZGxlcnMpXG4gIH07XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgbmFtZSxcbiAgICAgIGRlYnVnOiBnbG9iYWxDb25maWcubW9kZSA9PT0gJ2RldicsXG4gICAgICBwaW5nRGVsYXk6IDIwMDAsXG4gICAgICBzZW5kT25PcGVuOiBbXSxcbiAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldHVwID0ge1xuICAgIGNsaWVudElkOiBuZXdTcmkoKSxcbiAgICBzb2NrZXRFbmRQb2ludDogZ2xvYmFsQ29uZmlnLnNvY2tldEVuZFBvaW50LFxuICAgIHVybDogYC9sb2JieS9zb2NrZXQvdiR7Z2xvYmFsQ29uZmlnLmFwaVZlcnNpb259YCxcbiAgICBvcHRzXG4gIH07XG4gIHNldHVwQ29ubmVjdGlvbihzZXR1cCwgc29ja2V0SGFuZGxlcnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXNhKG1hc2FJZCwgdmVyc2lvbiwgaGFuZGxlcnMpIHtcbiAgbGV0IHVybCA9ICcvbWFzYS8nICsgbWFzYUlkICsgYC9zb2NrZXQvdiR7Z2xvYmFsQ29uZmlnLmFwaVZlcnNpb259YDtcbiAgY29uc3Qgc29ja2V0SGFuZGxlcnMgPSB7XG4gICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGFuZGxlcnMsIGhhbmRsZXJzKSxcbiAgICBvbk9wZW46IHNlc3Npb24uYmFja2dyb3VuZFJlZnJlc2hcbiAgfTtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBuYW1lOiAnbWFzYScsXG4gICAgICBkZWJ1ZzogZ2xvYmFsQ29uZmlnLm1vZGUgPT09ICdkZXYnLFxuICAgICAgcGluZ0RlbGF5OiAyMDAwLFxuICAgICAgcmVnaXN0ZXJlZEV2ZW50czogT2JqZWN0LmtleXMoc29ja2V0SGFuZGxlcnMuZXZlbnRzKVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXAgPSB7XG4gICAgY2xpZW50SWQ6IG5ld1NyaSgpLFxuICAgIHNvY2tldEVuZFBvaW50OiBnbG9iYWxDb25maWcuc29ja2V0RW5kUG9pbnQsXG4gICAgdXJsLFxuICAgIHZlcnNpb24sXG4gICAgb3B0c1xuICB9O1xuICBzZXR1cENvbm5lY3Rpb24oc2V0dXAsIHNvY2tldEhhbmRsZXJzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlR2FtZShcbiAgdXJsLFxuICB2ZXJzaW9uLFxuICBoYW5kbGVycyxcbiAgZ2FtZVVybCkge1xuICBjb25zdCBzb2NrZXRIYW5kbGVycyA9IHtcbiAgICBvbk9wZW46IHNlc3Npb24uYmFja2dyb3VuZFJlZnJlc2gsXG4gICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGFuZGxlcnMsIGhhbmRsZXJzKVxuICB9O1xuICBjb25zdCBvcHRzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIG5hbWU6ICdnYW1lJyxcbiAgICAgIGRlYnVnOiBnbG9iYWxDb25maWcubW9kZSA9PT0gJ2RldicsXG4gICAgICBzZW5kT25PcGVuOiBbXSxcbiAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldHVwID0ge1xuICAgIGNsaWVudElkOiBuZXdTcmkoKSxcbiAgICBzb2NrZXRFbmRQb2ludDogZ2xvYmFsQ29uZmlnLnNvY2tldEVuZFBvaW50LFxuICAgIHVybCxcbiAgICB2ZXJzaW9uLFxuICAgIG9wdHNcbiAgfTtcbiAgXG4gIHNldHVwQ29ubmVjdGlvbihzZXR1cCwgc29ja2V0SGFuZGxlcnMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNyZWF0ZUdhbWUsXG4gIGNyZWF0ZUxvYmJ5LFxuICBjcmVhdGVNYXNhLFxuICByZWNvbm5lY3RDdXJyZW50LFxuICBzZW5kOiAodCwgZGF0YSwgb3B0cykgPT4ge1xuICAgIHRlbGxXb3JrZXIod29ya2VyLCAnc2VuZCcsIFt0LCBkYXRhLCBvcHRzXSk7XG4gIH0sXG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiBjb25uZWN0ZWRXUztcbiAgfSxcbiAgY29ubmVjdCgpIHtcbiAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ2Nvbm5lY3QnKTtcbiAgfSxcbiAgZGVzdHJveSgpIHtcbiAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ2Rlc3Ryb3knKTtcbiAgfVxufTtcblxuXG4vLy8gT0xEXG5cblxuLy8gY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcignbGliL3NvY2tldFdvcmtlci5qcycpO1xuXG4vLyBsZXQgc29ja2V0SGFuZGxlcnM7XG4vLyBsZXQgZXJyb3JEZXRlY3RlZCA9IGZhbHNlO1xuLy8gbGV0IGNvbm5lY3RlZFdTID0gdHJ1ZTtcblxuLy8gbGV0IGFscmVhZHlXYXJuZWQgPSBmYWxzZTtcbi8vIGxldCByZWRyYXdPbkRpc2Nvbm5lY3RlZFRpbWVvdXRJRDtcbi8vIGxldCBwcm94eUZhaWxUaW1lb3V0SUQ7XG4vLyBjb25zdCBwcm94eUZhaWxNc2cgPSBcIk95dW5rZXlmIHN1bnVjdWxhcsSxbmEgYmHEn2xhbnTEsSBrb3B0dS4gUHJvYmxlbSBzw7xyZWtsaSB5YcWfYW7EsXlvcnNhIHByb3h5IHlhZGEgbmV0d29yaydsYSBpbGdpbGkgb2xhYmlsaXIuXCI7XG5cbi8vIGNvbnN0IGRlZmF1bHRIYW5kbGVycyA9IHtcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZUdhbWUodXJsLCB2ZXJzaW9uLCBoYW5kbGVycywgZ2FtZVVybCkge1xuLy8gICBlcnJvckRldGVjdGVkID0gZmFsc2U7XG4vLyAgIHNvY2tldEhhbmRsZXJzID0ge1xuLy8gICAgIG9uRXJyb3I6IGZ1bmN0aW9uKCkge1xuLy8gICAgICAgLy8gd2UgY2FuJ3QgZ2V0IHNvY2tldCBlcnJvciwgc28gd2Ugc2VuZCBhbiB4aHIgdG8gdGVzdCB3aGV0aGVyIHRoZVxuLy8gICAgICAgLy8gcmVqZWN0aW9uIGlzIGFuIGF1dGhvcml6YXRpb24gaXNzdWVcbi8vICAgICAgIGlmICghZXJyb3JEZXRlY3RlZCkge1xuLy8gICAgICAgICAvLyBqdXN0IHRvIGJlIHN1cmUgdGhhdCB3ZSBkb24ndCBzZW5kIGFuIHhociBldmVyeSBzZWNvbmQgd2hlbiB0aGVcbi8vICAgICAgICAgLy8gd2Vic29ja2V0IGlzIHRyeWluZyB0byByZWNvbm5lY3Rcbi8vICAgICAgICAgZXJyb3JEZXRlY3RlZCA9IHRydWU7XG4vLyAgICAgICAgIHhoci5nYW1lKGdhbWVVcmwuc3Vic3RyaW5nKDEpKS50aGVuKGZ1bmN0aW9uKCkge30sIGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcbi8vICAgICAgICAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bigndW5hdXRob3JpemVkRXJyb3InKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICAgICAgICAgICAgbS5yb3V0ZSgnLycpO1xuLy8gICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICB9XG4vLyAgICAgfSxcbi8vICAgICBldmVudHM6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIYW5kbGVycywgaGFuZGxlcnMpXG4vLyAgIH07XG5cbi8vICAgY29uc3Qgb3B0cyA9IHtcbi8vICAgICBvcHRpb25zOiB7XG4vLyAgICAgICBuYW1lOiAnZ2FtZScsXG4vLyAgICAgICBkZWJ1ZzogZmFsc2UsXG4vLyAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbi8vICAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4vLyAgICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbi8vICAgICB1cmwsXG4vLyAgICAgdmVyc2lvbixcbi8vICAgICBvcHRzXG4vLyAgIH0pO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiBjcmVhdGVNYXNhKG1hc2FJZCwgdmVyc2lvbiwgaGFuZGxlcnMpIHtcbi8vICAgbGV0IHVybCA9ICcvbWFzYS8nICsgbWFzYUlkICsgJy9zb2NrZXQvdjEnO1xuXG4vLyAgIHNvY2tldEhhbmRsZXJzID0ge1xuLy8gICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycylcbi8vICAgfTtcbi8vICAgY29uc3Qgb3B0cyA9IHtcbi8vICAgICBvcHRpb25zOiB7XG4vLyAgICAgICBuYW1lOiAnbWFzYScsXG4vLyAgICAgICBkZWJ1ZzogZmFsc2UsXG4vLyAgICAgICBwaW5nRGVsYXk6IDIwMDAsXG4vLyAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbi8vICAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4vLyAgICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbi8vICAgICB1cmwsXG4vLyAgICAgdmVyc2lvbixcbi8vICAgICBvcHRzXG4vLyAgIH0pO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiBjcmVhdGVNYXNhSG9tZShoYW5kbGVycykge1xuLy8gICBsZXQgdXJsID0gJy9zb2NrZXQnO1xuXG4vLyAgIHNvY2tldEhhbmRsZXJzID0ge1xuLy8gICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycylcbi8vICAgfTtcbi8vICAgY29uc3Qgb3B0cyA9IHtcbi8vICAgICBwYXJhbXM6IHsgZmxhZzogJ21hc2EnIH0sXG4vLyAgICAgb3B0aW9uczoge1xuLy8gICAgICAgbmFtZTogJ21hc2FIb21lJyxcbi8vICAgICAgIGRlYnVnOiBmYWxzZSxcbi8vICAgICAgIHBpbmdEZWxheTogMjAwMCxcbi8vICAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbi8vICAgICB9XG4vLyAgIH07XG4vLyAgIHRlbGxXb3JrZXIod29ya2VyLCAnY3JlYXRlJywge1xuLy8gICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbi8vICAgICBzb2NrZXRFbmRQb2ludDogd2luZG93Lm95dW5rZXlmLnNvY2tldEVuZFBvaW50LFxuLy8gICAgIHVybCxcbi8vICAgICB2ZXJzaW9uOiAwLFxuLy8gICAgIG9wdHNcbi8vICAgfSk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZUxvYmJ5KGxvYmJ5VmVyc2lvbiwgb25PcGVuLCBoYW5kbGVycykge1xuLy8gICBzb2NrZXRIYW5kbGVycyA9IHtcbi8vICAgICBvbk9wZW4sXG4vLyAgICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGFuZGxlcnMsIGhhbmRsZXJzKVxuLy8gICB9O1xuLy8gICBjb25zdCBvcHRzID0ge1xuLy8gICAgIG9wdGlvbnM6IHtcbi8vICAgICAgIG5hbWU6ICdsb2JieScsXG4vLyAgICAgICBkZWJ1ZzogZmFsc2UsXG4vLyAgICAgICBwaW5nRGVsYXk6IDIwMDAsXG4vLyAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbi8vICAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4vLyAgICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbi8vICAgICB1cmw6ICcvbG9iYnkvc29ja2V0L3YxJyxcbi8vICAgICB2ZXJzaW9uOiBsb2JieVZlcnNpb24sXG4vLyAgICAgb3B0c1xuLy8gICB9KTtcbi8vIH1cblxuXG4vLyBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0KCkge1xuLy8gICAvLyBkZWZhdWx0IHNvY2tldCBpcyB1c2VsZXNzIHdoZW4gYW5vbi4/XG4vLyAgIGlmIChoYXNOZXR3b3JrKCkpIHtcbi8vICAgICBzb2NrZXRIYW5kbGVycyA9IHtcbi8vICAgICAgIGV2ZW50czogZGVmYXVsdEhhbmRsZXJzXG4vLyAgICAgfTtcbi8vICAgICBjb25zdCBvcHRzID0ge1xuLy8gICAgICAgb3B0aW9uczoge1xuLy8gICAgICAgICBuYW1lOiAnZGVmYXVsdCcsXG4vLyAgICAgICAgIGRlYnVnOiBmYWxzZSxcbi8vICAgICAgICAgcGluZ0RlbGF5OiAyMDAwLFxuLy8gICAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4vLyAgICAgICB9XG4vLyAgICAgfTtcbi8vICAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbi8vICAgICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbi8vICAgICAgIHNvY2tldEVuZFBvaW50OiB3aW5kb3cub3l1bmtleWYuc29ja2V0RW5kUG9pbnQsXG4vLyAgICAgICB1cmw6ICcvc29ja2V0Jyxcbi8vICAgICAgIHZlcnNpb246IDAsXG4vLyAgICAgICBvcHRzXG4vLyAgICAgfSk7XG4vLyAgIH1cbi8vIH1cblxuLy8gZnVuY3Rpb24gb25Db25uZWN0ZWQoKSB7XG4vLyAgIGNvbnN0IHdhc09mZiA9ICFjb25uZWN0ZWRXUztcbi8vICAgY29ubmVjdGVkV1MgPSB0cnVlO1xuLy8gICBjbGVhclRpbWVvdXQocHJveHlGYWlsVGltZW91dElEKTtcbi8vICAgY2xlYXJUaW1lb3V0KHJlZHJhd09uRGlzY29ubmVjdGVkVGltZW91dElEKTtcbi8vICAgaWYgKHdhc09mZikgbS5yZWRyYXcoKTtcbi8vIH1cblxuLy8gZnVuY3Rpb24gb25EaXNjb25uZWN0ZWQoKSB7XG4vLyAgIGNvbnN0IHdhc09uID0gY29ubmVjdGVkV1M7XG4vLyAgIGNvbm5lY3RlZFdTID0gZmFsc2U7XG4vLyAgIGlmICh3YXNPbikgcmVkcmF3T25EaXNjb25uZWN0ZWRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuLy8gICAgIG0ucmVkcmF3KCk7XG4vLyAgIH0sIDIwMDApO1xuLy8gICBpZiAod2FzT24gJiYgIWFscmVhZHlXYXJuZWQgJiYgIXN0b3JhZ2UuZ2V0KCdkb25vdHNob3dwcm94eWZhaWx3YXJuaW5nJykpIHByb3h5RmFpbFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuLy8gICAgIC8vIGNoZWNrIGlmIGRpc2Nvbm5lY3Rpb24gbGFzdHMsIGl0IGNvdWxkIG1lYW4gYSBwcm94eSBwcmV2ZW50c1xuLy8gICAgIC8vIGVzdGFibGlzaGluZyBhIHR1bm5lbFxuLy8gICAgIGlmIChoYXNOZXR3b3JrKCkgJiYgIWNvbm5lY3RlZFdTKSB7XG4vLyAgICAgICBhbHJlYWR5V2FybmVkID0gdHJ1ZTtcbi8vICAgICAgIHdpbmRvdy5uYXZpZ2F0b3Iubm90aWZpY2F0aW9uLmFsZXJ0KHByb3h5RmFpbE1zZywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIHN0b3JhZ2Uuc2V0KCdkb25vdHNob3dwcm94eWZhaWx3YXJuaW5nJywgdHJ1ZSk7XG4vLyAgICAgICB9KTtcbi8vICAgICB9XG4vLyAgIH0sIDIwMDAwKTtcbi8vIH1cblxuLy8gd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbi8vICAgc3dpdGNoKG1zZy5kYXRhLnRvcGljKSB7XG4vLyAgIGNhc2UgJ29uT3Blbic6XG4vLyAgICAgaWYgKHNvY2tldEhhbmRsZXJzLm9uT3Blbikgc29ja2V0SGFuZGxlcnMub25PcGVuKCk7XG4vLyAgICAgYnJlYWs7XG4vLyAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4vLyAgICAgb25EaXNjb25uZWN0ZWQoKTtcbi8vICAgICBicmVhaztcbi8vICAgY2FzZSAnY29ubmVjdGVkJzpcbi8vICAgICBvbkNvbm5lY3RlZCgpO1xuLy8gICAgIGJyZWFrO1xuLy8gICBjYXNlICdvbkVycm9yJzpcbi8vICAgICBpZiAoc29ja2V0SGFuZGxlcnMub25FcnJvcikgc29ja2V0SGFuZGxlcnMub25FcnJvcigpO1xuLy8gICAgIGJyZWFrO1xuLy8gICBjYXNlICdoYW5kbGUnOlxuLy8gICAgIHZhciBoID0gc29ja2V0SGFuZGxlcnMuZXZlbnRzW21zZy5kYXRhLnBheWxvYWQudF07XG4vLyAgICAgaWYgKGgpIGgobXNnLmRhdGEucGF5bG9hZC5kIHx8IG51bGwsIG1zZy5kYXRhLnBheWxvYWQpO1xuLy8gICAgIGJyZWFrO1xuLy8gICB9XG4vLyB9KTtcblxuLy8gLy8gZXhwb3J0IGRlZmF1bHQge1xuLy8gLy8gICBjcmVhdGVEZWZhdWx0LFxuLy8gLy8gICBjcmVhdGVNYXNhLFxuLy8gLy8gICBjcmVhdGVNYXNhSG9tZSxcbi8vIC8vICAgY3JlYXRlR2FtZSxcbi8vIC8vICAgY3JlYXRlTG9iYnksXG4vLyAvLyAgIHNldFZlcnNpb24odmVyc2lvbikge1xuLy8gLy8gICAgIHRlbGxXb3JrZXIod29ya2VyLCAnc2V0VmVyc2lvbicsIHZlcnNpb24pO1xuLy8gLy8gICB9LFxuLy8gLy8gICBzZW5kKHR5cGUsIGRhdGEsIG9wdHMpIHtcbi8vIC8vICAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ3NlbmQnLCBbdHlwZSwgZGF0YSwgb3B0c10pO1xuLy8gLy8gICB9LFxuLy8gLy8gICBjb25uZWN0KCkge1xuLy8gLy8gICAgIHRlbGxXb3JrZXIod29ya2VyLCAnY29ubmVjdCcpO1xuLy8gLy8gICB9LFxuLy8gLy8gICBkaXNjb25uZWN0KCkge1xuLy8gLy8gICAgIHRlbGxXb3JrZXIod29ya2VyLCAnZGlzY29ubmVjdCcpO1xuLy8gLy8gICB9LFxuLy8gLy8gICBpc0Nvbm5lY3RlZCgpIHtcbi8vIC8vICAgICByZXR1cm4gY29ubmVjdGVkV1M7XG4vLyAvLyAgIH0sXG4vLyAvLyAgIGRlc3Ryb3koKSB7XG4vLyAvLyAgICAgdGVsbFdvcmtlcih3b3JrZXIsICdkZXN0cm95Jyk7XG4vLyAvLyAgIH0sXG4vLyAvLyAgIHRlcm1pbmF0ZSgpIHtcbi8vIC8vICAgICBpZiAod29ya2VyKSB3b3JrZXIudGVybWluYXRlKCk7XG4vLyAvLyAgIH1cbi8vIC8vIH07XG4iLCJ2YXIgdGltZW91dElkO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNwaW4oKSB7XG4gICAgaWYgKHRpbWVvdXRJZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdnbG9iYWxTcGlubmVyJykubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzcGlubmVyLmNsYXNzTmFtZSA9ICdzcGlubmVyIGdsb2JhbFNwaW5uZXInO1xuICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsICcwIDAgNDAgNDAnKTtcbiAgICBjb25zdCBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2NpcmNsZScpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N4JywgJzIwJyk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3knLCAnMjAnKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdyJywgJzE4Jyk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKGNpcmNsZSk7XG4gICAgc3Bpbm5lci5hcHBlbmRDaGlsZChzdmcpO1xuXG4gICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwaW5uZXIpLCAyMDApO1xuICB9LFxuXG4gIHN0b3AoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgdGltZW91dElkID0gbnVsbDtcbiAgICBjb25zdCBzcGlubmVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2dsb2JhbFNwaW5uZXInKTtcbiAgICBpZiAoc3Bpbm5lcnMubGVuZ3RoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAoc3Bpbm5lcnNbMF0pIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3Bpbm5lcnNbMF0pO1xuICAgICAgfSwgNTAwKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VmRvbShjbGFzc2VzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9eydzcGlubmVyICcgKyBjbGFzc2VzfT5cbiAgICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDQwIDQwXCI+XG4gICAgICAgICAgPGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIyMFwiIHI9XCIxOFwiIGZpbGw9XCJub25lXCI+PC9jaXJjbGU+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiZnVuY3Rpb24gd2l0aFN0b3JhZ2UoZikge1xuICAvLyBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHN0b3JhZ2UgaXMgZnVsbFxuICB0cnkge1xuICAgIHJldHVybiAhIXdpbmRvdy5sb2NhbFN0b3JhZ2UgPyBmKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIDogbnVsbDtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuZnVuY3Rpb24gZ2V0KGspIHtcbiAgcmV0dXJuIHdpdGhTdG9yYWdlKGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzLmdldEl0ZW0oaykpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShrKSB7XG4gIHJldHVybiB3aXRoU3RvcmFnZShmdW5jdGlvbihzKSB7XG4gICAgcy5yZW1vdmVJdGVtKGspO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldChrLCB2KSB7XG4gIHJldHVybiB3aXRoU3RvcmFnZShmdW5jdGlvbihzKSB7XG4gICAgcy5yZW1vdmVJdGVtKGspO1xuICAgIHMuc2V0SXRlbShrLCBKU09OLnN0cmluZ2lmeSh2KSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcm9wKGtleSwgaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgc2V0KGtleSwgYXJndW1lbnRzWzBdKTtcbiAgICBjb25zdCByZXQgPSBnZXQoa2V5KTtcbiAgICByZXR1cm4gKHJldCAhPT0gbnVsbCAmJiByZXQgIT09IHVuZGVmaW5lZCkgPyByZXQgOiBpbml0aWFsVmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0LFxuICBzZXQsXG4gIHJlbW92ZSxcbiAgcHJvcFxufTtcbiIsImltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uL3JvdXRlcic7XG5pbXBvcnQgeyBoYXNOZXR3b3JrLCBoYW5kbGVYaHJFcnJvciB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGdhbWUgYXMgZ2FtZVhociB9IGZyb20gJy4uLy4uL3hocic7XG5pbXBvcnQgKiBhcyBzbGVlcFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3NsZWVwJztcbmltcG9ydCBPbmxpbmVSb3VuZCBmcm9tICcuLi9zaGFyZWQvcm91bmQvT25saW5lUm91bmQnO1xuaW1wb3J0IHJvdW5kVmlldyBmcm9tICcuLi9zaGFyZWQvcm91bmQvdmlldy9yb3VuZFZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdCh7IGF0dHJzIH0pIHtcbiAgICBsZXQgZ2FtZURhdGE7XG5cbiAgICBzbGVlcFV0aWxzLmtlZXBBd2FrZSgpO1xuXG4gICAgaWYgKGhhc05ldHdvcmsoKSkge1xuICAgICAgZ2FtZVhocihhdHRycy5pZClcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgZ2FtZURhdGEgPSBkYXRhO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3VuZCA9IG5ldyBPbmxpbmVSb3VuZChhdHRycy5pZCwgZGF0YSk7XG4gICAgICAgICAgfSwgNDAwKTtcblxuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgaGFuZGxlWGhyRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJvdXRlci5zZXQoJy8nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBvbmNyZWF0ZSh2bm9kZSkge1xuICAgIGlmICh2bm9kZS5kb20pXG4gICAgICBoZWxwZXIuZWxGYWRlSW4odm5vZGUuZG9tKTtcbiAgfSxcbiAgb25yZW1vdmUoKSB7XG4gICAgc2xlZXBVdGlscy5hbGxvd1NsZWVwQWdhaW4oKTtcbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgIGlmICh0aGlzLnJvdW5kKSB7XG4gICAgICB0aGlzLnJvdW5kLnVubG9hZCgpO1xuICAgIH1cbiAgfSxcbiAgdmlldyh7YXR0cnN9KSB7XG4gICAgaWYgKHRoaXMucm91bmQpIHJldHVybiByb3VuZFZpZXcodGhpcy5yb3VuZCk7XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG4iLCJpbXBvcnQgcG9wdXBXaWRnZXQgZnJvbSAnLi9zaGFyZWQvcG9wdXAnO1xuaW1wb3J0IGZvcm1XaWRnZXRzIGZyb20gJy4vc2hhcmVkL2Zvcm0nO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4vaGVscGVyJztcbmltcG9ydCBpU2Nyb2xsIGZyb20gJ2lzY3JvbGwnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uL3NldHRpbmdzJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uL3Nlc3Npb24nO1xuaW1wb3J0IGJhY2tidXR0b24gZnJvbSAnLi4vYmFja2J1dHRvbic7XG5pbXBvcnQgbG9iYnkgZnJvbSAnLi9sb2JieSc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBWaWV3T25seUJvYXJkIGZyb20gJy4vc2hhcmVkL1ZpZXdPbmx5Qm9hcmQnO1xuXG52YXIgc2Nyb2xsZXIgPSBudWxsO1xuXG5jb25zdCBnYW1lc01lbnUgPSB7fTtcblxuZ2FtZXNNZW51LmlzT3BlbiA9IGZhbHNlO1xuXG5nYW1lc01lbnUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goZ2FtZXNNZW51LmNsb3NlKTtcbiAgZ2FtZXNNZW51LmlzT3BlbiA9IHRydWU7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWxzLmhhc05ldHdvcmsoKSAmJiBzY3JvbGxlcikgc2Nyb2xsZXIuZ29Ub1BhZ2UoMSwgMCk7XG4gIH0sIDQwMCk7XG4gIHNlc3Npb24ucmVmcmVzaCgpO1xufTtcblxuZ2FtZXNNZW51LmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBnYW1lc01lbnUuaXNPcGVuKSBiYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBnYW1lc01lbnUuaXNPcGVuID0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBqb2luR2FtZShnKSB7XG4gIGdhbWVzTWVudS5jbG9zZSgpO1xuICBtLnJvdXRlKCcvZ2FtZS8nICsgZy5mdWxsSWQpO1xufVxuXG5mdW5jdGlvbiBjYXJkRGltcygpIHtcbiAgY29uc3QgdnAgPSBoZWxwZXIudmlld3BvcnREaW0oKTtcblxuICAvLyBpZiB3ZSdyZSBoZXJlIGl0J3MgYSBwaG9uZVxuICBsZXQgd2lkdGggPSAyMDA7XG4gIGxldCBoZWlnaHQgPSB3aWR0aCAvICg0LzMpO1xuICBsZXQgbWFyZ2luID0gMTA7XG4gIHJldHVybiB7XG4gICAgdzogd2lkdGggKyBtYXJnaW4gKiAyLFxuICAgIGg6IGhlaWdodCArIDcwLFxuICAgIGlubmVyVzogd2lkdGgsXG4gICAgbWFyZ2luOiBtYXJnaW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVmlld09ubHlCb2FyZChjRGltLCBmZW4sIG9yaWVudGF0aW9uLCB2YXJpYW50KSB7XG4gIGNvbnN0IGlubmVySCA9IGNEaW0gPyBjRGltLmlubmVyVyAvICg0LzMpOiAwO1xuICBjb25zdCBpbm5lclcgPSBjRGltID8gY0RpbS5pbm5lclcgOiAwO1xuICBjb25zdCBzdHlsZSA9IGNEaW0gPyB7IGhlaWdodDogaW5uZXJIICsgJ3B4JyB9IDoge307XG4gIGNvbnN0IGJvdW5kcyA9IGNEaW0gPyB7IHdpZHRoOiBpbm5lclcsIGhlaWdodDogaW5uZXJIIH0gOiBudWxsO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9hcmRXcmFwcGVyXCIgc3R5bGU9e3N0eWxlfT5cbiAgICAgIHttLmNvbXBvbmVudChWaWV3T25seUJvYXJkLCB7IGJvdW5kcywgZmVuLCBvcmllbnRhdGlvbiwgdmFyaWFudH0pfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiB0aW1lTGVmdChnKSB7XG4gIGlmICghZy5pc015VHVybikgcmV0dXJuIGkxOG4oJ3dhaXRpbmdGb3JPcHBvbmVudCcpO1xuICByZXR1cm4gaTE4bigneW91clR1cm4nKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyR2FtZShnLCBjRGltLCBjYXJkU3R5bGUpIHtcbiAgY29uc3QgaWNvbiA9IHV0aWxzLmdhbWVJY29uKGcucGVyZik7XG4gIGNvbnN0IGNhcmRDbGFzcyA9IFtcbiAgICAnY2FyZCcsXG4gICAgJ3N0YW5kYXJkJ1xuICBdLmpvaW4oJyAnKTtcblxuICBjb25zdCB0aW1lQ2xhc3MgPSBbXG4gICAgJ3RpbWVJbmRpY2F0aW9uJyxcbiAgICBnLmlzTXlUdXJuID8gJ215VHVybic6ICdvcHBvbmVudFR1cm4nXG4gIF0uam9pbignICcpO1xuICBjb25zdCBjb25maWcgPSBoZWxwZXIub250b3VjaFgoKCkgPT4gam9pbkdhbWUoZykpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NhcmRDbGFzc30ga2V5PXsnZ2FtZS4nICsgZy5nYW1lSWR9IHN0eWxlPXtjYXJkU3R5bGV9XG4gICAgY29uZmlnPXtjb25maWd9PlxuICAgICAge3JlbmRlclZpZXdPbmx5Qm9hcmQoY0RpbSwgZy5mZW4sIGcuc2lkZSwgZy52YXJpYW50KX1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb3NcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZXNjcmlwdGlvblwiPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidmFyaWFudFwiPntnLnZhcmlhbnQubmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3RpbWVDbGFzc30+e3RpbWVMZWZ0KGcpfTwvc3Bhbj5cbiAgICAgICAgICA8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFsbEdhbWVzKGNEaW0pIHtcbiAgY29uc3Qgbm93UGxheWluZyA9IHNlc3Npb24ubm93UGxheWluZygpOyAvLyAuY29uY2F0KHNlc3Npb24ubm93UGxheWluZygpKTtcbiAgY29uc3QgY2FyZFN0eWxlID0gY0RpbSA/IHtcbiAgICB3aWR0aDogKGNEaW0udyAtIGNEaW0ubWFyZ2luICogMikgKyAncHgnLFxuICAgIGhlaWdodDogY0RpbS5oICsgJ3B4JyxcbiAgICBtYXJnaW5MZWZ0OiBjRGltLm1hcmdpbiArICdweCcsXG4gICAgbWFyZ2luUmlnaHQ6IGNEaW0ubWFyZ2luICsgJ3B4J1xuICB9IDoge307XG5cbiAgY29uc3QgbmJDYXJkcyA9IHV0aWxzLmhhc05ldHdvcmsoKSA/XG4gICAgICAgICAgICAgICAgICBub3dQbGF5aW5nLmxlbmd0aCArIDEgOlxuICAgICAgICAgICAgICAgICAgMDtcblxuICBsZXQgd3JhcHBlclN0eWxlLCB3cmFwcGVyV2lkdGg7XG4gIGlmIChjRGltKSB7XG4gICAgLy8gc2Nyb2xsZXIgd3JhcHBlciB3aWR0aFxuICAgIC8vIGNhbGN1bCBpczpcbiAgICAvLyAoKGNhcmRXaWR0aCArIHZpc2libGUgcGFydCBvZiBhZGphY2VudCBjYXJkKSAqIG5iIG9mIGNhcmRzKSArXG4gICAgLy8gd3JhcHBlcidzIG1hcmdpbkxlZnRcbiAgICB3cmFwcGVyV2lkdGggPSAoKGNEaW0udyArIGNEaW0ubWFyZ2luICogMikgKiBuYkNhcmRzKSArXG4gICAgICAgICAgICAgICAgICAgKGNEaW0ubWFyZ2luICogMik7XG4gICAgd3JhcHBlclN0eWxlID0ge1xuICAgICAgd2lkdGg6IHdyYXBwZXJXaWR0aCArICdweCcsXG4gICAgICBtYXJnaW5MZWZ0OiAoY0RpbS5tYXJnaW4gKiAzKSArICdweCdcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFsbENhcmRzID0gbm93UGxheWluZy5tYXAoZyA9PiByZW5kZXJHYW1lKGcsIGNEaW0sIGNhcmRTdHlsZSkpO1xuXG4gIGlmICghaGVscGVyLmlzV2lkZVNjcmVlbigpKSB7XG5cbiAgICBjb25zdCBuZXdHYW1lQ2FyZCA9IChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBzdGFuZGFyZFwiIGtleT1cImdhbWUubmV3LWdhbWVcIiBzdHlsZT17Y2FyZFN0eWxlfVxuICAgICAgICAgICBjb25maWc9e2hlbHBlci5vbnRvdWNoWCgoKSA9PiB7IGdhbWVzTWVudS5jbG9zZSgpOyBuZXdHYW1lRm9ybS5vcGVuKCk7IH0pfT5cbiAgICAgICAge3JlbmRlclZpZXdPbmx5Qm9hcmQoY0RpbSl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb3NcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGl0bGVcIj57aTE4bignY3JlYXRlQUdhbWUnKX08L2gyPlxuICAgICAgICAgICAgPHA+e2kxOG4oJ25ld09wcG9uZW50Jyl9PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gICAgaWYgKHV0aWxzLmhhc05ldHdvcmsoKSkgYWxsQ2FyZHMudW5zaGlmdChuZXdHYW1lQ2FyZCk7XG4gIH1cblxuICByZXR1cm4gbSgnZGl2I2FsbF9nYW1lcycsIHsgc3R5bGU6IHdyYXBwZXJTdHlsZSB9LCBhbGxDYXJkcyk7XG59XG5cblxuZ2FtZXNNZW51LnZpZXcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFnYW1lc01lbnUuaXNPcGVuKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCB2aCA9IGhlbHBlci52aWV3cG9ydERpbSgpLnZoXG4gIGNvbnN0IGNEaW0gPSBjYXJkRGltcygpO1xuICBjb25zdCB3cmFwcGVyU3R5bGUgPSBoZWxwZXIuaXNXaWRlU2NyZWVuKCkgPyB7fSA6IHsgdG9wOiAoKHZoIC0gY0RpbS5oKSAvIDIpICsgJ3B4JyB9O1xuICBjb25zdCB3cmFwcGVyQ29uZmlnID1cbiAgaGVscGVyLmlzV2lkZVNjcmVlbigpID8gdXRpbHMubm9vcCA6XG4gIGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuICAgIGlmICghaXNVcGRhdGUpIHtcbiAgICAgIHNjcm9sbGVyID0gbmV3IGlTY3JvbGwoZWwsIHtcbiAgICAgICAgc2Nyb2xsWDogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsWTogZmFsc2UsXG4gICAgICAgIG1vbWVudHVtOiBmYWxzZSxcbiAgICAgICAgc25hcDogJy5jYXJkJyxcbiAgICAgICAgc25hcFNwZWVkOiA0MDAsXG4gICAgICAgIHByZXZlbnREZWZhdWx0RXhjZXB0aW9uOiB7XG4gICAgICAgICAgdGFnTmFtZTogL14oSU5QVVR8VEVYVEFSRUF8QlVUVE9OfFNFTEVDVHxMQUJFTCkkL1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29udGV4dC51bm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2Nyb2xsZXIpIHtcbiAgICAgICAgICBzY3JvbGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgc2Nyb2xsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1YmlxL2lzY3JvbGwvaXNzdWVzLzQxMlxuICAgIHNjcm9sbGVyLm9wdGlvbnMuc25hcCA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkJyk7XG4gICAgc2Nyb2xsZXIucmVmcmVzaCgpO1xuICB9O1xuXG4gIGNvbnN0IGlzV2lkZVNjcmVlbiA9IGhlbHBlci5pc1dpZGVTY3JlZW4oKTtcblxuICBjb25zdCB3cmFwcGVyQ2xhc3MgPSBpc1dpZGVTY3JlZW4gPyAnb3ZlcmxheV9wb3B1cCcgOiAnJztcblxuICByZXR1cm4gKFxuICAgIDxkaXYgaWQ9XCJnYW1lc19tZW51XCIgY2xhc3NOYW1lPVwib3ZlcmxheV9wb3B1cF93cmFwcGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIndyYXBwZXJfb3ZlcmxheV9jbG9zZVwiXG4gICAgICAgICAgIGNvbmZpZz17aGVscGVyLm9udG91Y2goaGVscGVyLmZhZGVzT3V0KGdhbWVzTWVudS5jbG9zZSwgJy5vdmVybGF5X3BvcHVwX3dyYXBwZXInKSl9Lz5cbiAgICAgIDxkaXYgaWQ9XCJ3cmFwcGVyX2dhbWVzXCIgY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3N9IHN0eWxlPXt3cmFwcGVyU3R5bGV9IGNvbmZpZz17d3JhcHBlckNvbmZpZ30+XG4gICAgICAgIHsgaXNXaWRlU2NyZWVuID8gKFxuICAgICAgICAgIDxoZWFkZXI+XG4gICAgICAgICAgICB7aTE4bignbmJHYW1lc0luUGxheScsIHNlc3Npb24ubm93UGxheWluZygpLmxlbmd0aCl9XG4gICAgICAgICAgPC9oZWFkZXI+XG4gICAgICAgICkgOiBudWxsIH1cbiAgICAgICAgeyBpc1dpZGVTY3JlZW4gPyAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cF9jb250ZW50XCI+XG4gICAgICAgICAge3JlbmRlckFsbEdhbWVzKG51bGwpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogcmVuZGVyQWxsR2FtZXMoY0RpbSkgfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnYW1lc01lbnU7XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5cbnZhciBhbmltYXRpbmcgPSBmYWxzZTtcblxuLy8gQXV0aG9yIEJhcm5leSBDYXJvbGxcbi8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFybmV5Y2Fycm9sbC9jNjlmYmUwNzg2ZTM3Yzk0MWJhZlxuXG4vLyBEZWZpbmUgYW4gYW5pbWF0b3IgY29uc2lzdGluZyBvZiBvcHRpb25hbCBpbmNvbWluZyBhbmQgb3V0Z29pbmcgYW5pbWF0aW9ucy5cbi8vIGFsd2F5c0FuaW1hdGUgaXMgZmFsc2UgdW5sZXNzIHNwZWNpZmllZCBhcyB0cnVlOiBmYWxzZSBtZWFucyBhbiBpbmNvbWluZyBhbmltYXRpb24gd2lsbCBvbmx5IHRyaWdnZXIgaWYgYW4gb3V0Z29pbmcgYW5pbWF0aW9uIGlzIGFsc28gaW4gcHJvZ3Jlc3MuXG4vLyBmb3JjaW5nIGRvbnRDbG9uZSB0byB0cnVlIG1lYW5zIHRoZSBvdXR3YXJkIGFuaW1hdGlvbiB3aWxsIHVzZSB0aGUgb3JpZ2luYWwgZWxlbWVudCByYXRoZXIgdGhhbiBhIGNsb25lLiBUaGlzIGNvdWxkIGltcHJvdmUgcGVyZm9ybWFuY2UgYnkgcmVjeWNsaW5nIGVsZW1lbnRzLCBidXQgY2FuIGxlYWQgdG8gdHJvdWJsZTogY2xvbmVzIGhhdmUgdGhlIGFkdmFudGFnZSBvZiBiZWluZyBzdHJpcHBlZCBvZiBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYW5pbWF0b3IoaW5jb21pbmcsIG91dGdvaW5nLCBhbHdheXNBbmltYXRlLCBkb250Q2xvbmUpIHtcbiAgLy8gVGhlIHJlc3VsdGluZyBhbmltYXRvciBjYW4gYmUgYXBwbGllZCB0byBhbnkgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGUoIHgsIHksIHogKXtcbiAgICB2YXIgY29uZmlnO1xuICAgIHZhciBwYXJlbnQ7XG4gICAgdmFyIG5leHQ7XG5cbiAgICAvLyBXaGVuIHVzZWQgYXMgYSBjb25maWcgZnVuY3Rpb25cbiAgICBpZiAoIHgubm9kZVR5cGUgKSB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uQ29uZmlnKHgsIHksIHopO1xuICAgIH1cbiAgICAvLyBXaGVuIHBhc3NlZCBhIHZpcnR1YWwgRE9NIG5vZGUgKHRoZSBvdXRwdXQgb2YgbSlcbiAgICBlbHNlIGlmICggeC5hdHRycyApIHtcbiAgICAgIHJldHVybiBiaW5kQ29uZmlnVG8oIHggKTtcbiAgICB9XG4gICAgLy8gV2hlbiBhcHBsaWVkIHRvIGEgTWl0aHJpbCBtb2R1bGUgLyBjb21wb25lbnRcbiAgICBlbHNlIGlmICggeC52aWV3ICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJvbGxlcjogeC5jb250cm9sbGVyIHx8IG5vb3AsXG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uIGFuaW1hdGVkVmlldyhjdHJsKXtcbiAgICAgICAgICByZXR1cm4gYmluZENvbmZpZ1RvKHgudmlldyhjdHJsKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZENvbmZpZ1RvKCBub2RlICl7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25maWcgPSBub2RlLmF0dHJzLmNvbmZpZztcblxuICAgICAgbm9kZS5hdHRycy5jb25maWcgPSBhbmltYXRpb25Db25maWc7XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFuaW1hdGlvbkNvbmZpZyhlbCwgaW5pdCwgY29udGV4dCl7XG4gICAgICB2YXIgb3V0cHV0O1xuICAgICAgdmFyIG9udW5sb2FkO1xuXG4gICAgICBpZiAoY29uZmlnKXtcbiAgICAgICAgb3V0cHV0ID0gY29uZmlnKGVsLCBpbml0LCBjb250ZXh0KTtcbiAgICAgICAgLy8gSWYgdGhlIHJvb3QgZWxlbWVudCBhbHJlYWR5IGhhcyBhIGNvbmZpZywgaXQgbWF5IGFsc28gaGF2ZSBhbiBvbnVubG9hZCB3aGljaCB3ZSBzaG91bGQgdGFrZSBjYXJlIHRvIHByZXNlcnZlXG4gICAgICAgIG9udW5sb2FkID0gY29udGV4dC5vbnVubG9hZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhaW5pdCApe1xuICAgICAgICBpZiAoaW5jb21pbmcgJiYgYWx3YXlzQW5pbWF0ZSB8fCBhbmltYXRpbmcpIHtcbiAgICAgICAgICBpbmNvbWluZyhlbCwgbm9vcCwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm9udW5sb2FkID0gb3V0Z29pbmcgPyBvbnVubG9hZCA/IGZ1bmN0aW9uIG9udW5sb2FkV3JhcHBlcigpIHtcbiAgICAgICAgICB0ZWFyZG93bigpO1xuICAgICAgICAgIG9udW5sb2FkKCk7XG4gICAgICAgIH0gOiB0ZWFyZG93biA6IG9udW5sb2FkO1xuXG4gICAgICAgIHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIG5leHQgPSBlbC5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcblxuICAgICAgZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgICAgIHZhciBpbnNlcnRpb24gPSBkb250Q2xvbmUgPyBlbCA6IGVsLmNsb25lTm9kZSggdHJ1ZSApO1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gbnVsbDtcblxuICAgICAgICBpZiAoIG5leHQgJiYgcGFyZW50ICYmIG5leHQucGFyZW50Tm9kZSA9PT0gcGFyZW50ICl7XG4gICAgICAgICAgcmVmZXJlbmNlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGluZyA9IHRydWU7XG5cbiAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gcmVzZXRBbmltYXRpb25GbGFnKCl7XG4gICAgICAgICAgYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIH0sIDAgKTtcblxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKCBpbnNlcnRpb24sIHJlZmVyZW5jZSApO1xuXG4gICAgICAgIG91dGdvaW5nKCBpbnNlcnRpb24sIGZ1bmN0aW9uIGRlc3Ryb3koKXtcbiAgICAgICAgICBpZiAoIHBhcmVudC5jb250YWlucyggaW5zZXJ0aW9uICkgKXtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCggaW5zZXJ0aW9uICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjb250ZXh0ICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmNvbnN0IEhPTERfRFVSQVRJT04gPSA2MDA7XG5jb25zdCBSRVBFQVRfUkFURSA9IDIwO1xuY29uc3QgU0NST0xMX1RPTEVSQU5DRSA9IDg7XG5jb25zdCBBQ1RJVkVfQ0xBU1MgPSAnYWN0aXZlJztcblxuZnVuY3Rpb24gaGFzQ29udGV4dE1lbnUoKSB7XG4gIHJldHVybiB3aW5kb3cuY29yZG92YS5wbGF0Zm9ybUlkICE9PSAnaW9zJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnV0dG9uSGFuZGxlcihlbCxcbiAgdGFwSGFuZGxlcixcbiAgaG9sZEhhbmRsZXIsXG4gIHJlcGVhdEhhbmRsZXIsXG4gIHNjcm9sbFgsXG4gIHNjcm9sbFksXG4gIHRvdWNoRW5kRmVlZGJhY2spIHtcblxuICBsZXQgc3RhcnRYLCBzdGFydFksIGJvdW5kYXJpZXMsIGFjdGl2ZSwgaG9sZFRpbWVvdXRJRCwgcmVwZWF0VGltZW91dElkLCByZXBlYXRJbnRlcnZhbElEO1xuXG4gIGlmICh0eXBlb2YgdGFwSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1dHRvbkhhbmRsZXIgMm5kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiEnKTtcblxuICBpZiAoaG9sZEhhbmRsZXIgJiYgdHlwZW9mIGhvbGRIYW5kbGVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignQnV0dG9uSGFuZGxlciAzcmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuXG4gIGlmIChyZXBlYXRIYW5kbGVyICYmIHR5cGVvZiByZXBlYXRIYW5kbGVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignQnV0dG9uSGFuZGxlciA0cmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuXG4gIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ob3ctamF2YXNjcmlwdC10aW1lcnMtd29yay9cbiAgZnVuY3Rpb24gb25SZXBlYXQoKSB7XG4gICAgdmFyIHJlcyA9IHJlcGVhdEhhbmRsZXIoKTtcbiAgICByZXBlYXRJbnRlcnZhbElEID0gc2V0VGltZW91dChvblJlcGVhdCwgUkVQRUFUX1JBVEUpO1xuICAgIGlmICghcmVzKSBjbGVhclRpbWVvdXQocmVwZWF0SW50ZXJ2YWxJRCk7XG4gICAgbS5yZWRyYXcoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgbGV0IHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICBsZXQgYm91bmRpbmdSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgc3RhcnRYID0gdG91Y2guY2xpZW50WDtcbiAgICBzdGFydFkgPSB0b3VjaC5jbGllbnRZO1xuICAgIGJvdW5kYXJpZXMgPSB7XG4gICAgICBtaW5YOiBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgIG1heFg6IGJvdW5kaW5nUmVjdC5yaWdodCxcbiAgICAgIG1pblk6IGJvdW5kaW5nUmVjdC50b3AsXG4gICAgICBtYXhZOiBib3VuZGluZ1JlY3QuYm90dG9tXG4gICAgfTtcbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGFjdGl2ZSkgZWwuY2xhc3NMaXN0LmFkZChBQ1RJVkVfQ0xBU1MpO1xuICAgIH0sIDIwMCk7XG4gICAgaWYgKCFoYXNDb250ZXh0TWVudSgpKSBob2xkVGltZW91dElEID0gc2V0VGltZW91dChvbkhvbGQsIEhPTERfRFVSQVRJT04pO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRJbnRlcnZhbElEKTtcbiAgICBpZiAocmVwZWF0SGFuZGxlcikgcmVwZWF0VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXBlYXRJbnRlcnZhbElEID0gc2V0VGltZW91dChvblJlcGVhdCwgUkVQRUFUX1JBVEUpO1xuICAgIH0sIDE1MCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgLy8gaWYgZ29pbmcgb3V0IG9mIGJvdW5kcywgbm8gd2F5IHRvIHJlZW5hYmxlIHRoZSBidXR0b25cbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBsZXQgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgYWN0aXZlID0gaXNBY3RpdmUodG91Y2gpO1xuICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvbGRUaW1lb3V0SUQpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVwZWF0VGltZW91dElkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcGVhdEludGVydmFsSUQpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XG4gICAgaWYgKGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRUaW1lb3V0SWQpO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRJbnRlcnZhbElEKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaG9sZFRpbWVvdXRJRCk7XG4gICAgICBpZiAodG91Y2hFbmRGZWVkYmFjaykgZWwuY2xhc3NMaXN0LmFkZChBQ1RJVkVfQ0xBU1MpO1xuICAgICAgdGFwSGFuZGxlcihlKTtcbiAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyksIDgwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoQ2FuY2VsKCkge1xuICAgIGNsZWFyVGltZW91dChob2xkVGltZW91dElEKTtcbiAgICBjbGVhclRpbWVvdXQocmVwZWF0VGltZW91dElkKTtcbiAgICBjbGVhclRpbWVvdXQocmVwZWF0SW50ZXJ2YWxJRCk7XG4gICAgYWN0aXZlID0gZmFsc2U7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShBQ1RJVkVfQ0xBU1MpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Db250ZXh0TWVudShlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGhvbGRUaW1lb3V0SUQgPT09IHVuZGVmaW5lZCkgb25Ib2xkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkhvbGQoKSB7XG4gICAgaWYgKGhvbGRIYW5kbGVyKSB7XG4gICAgICBob2xkSGFuZGxlcigpO1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNBY3RpdmUodG91Y2gpIHtcbiAgICBsZXQgeCA9IHRvdWNoLmNsaWVudFgsXG4gICAgICB5ID0gdG91Y2guY2xpZW50WSxcbiAgICAgIGIgPSBib3VuZGFyaWVzLFxuICAgICAgZCA9IDA7XG4gICAgaWYgKHNjcm9sbFgpIGQgPSBNYXRoLmFicyh4IC0gc3RhcnRYKTtcbiAgICBpZiAoc2Nyb2xsWSkgZCA9IE1hdGguYWJzKHkgLSBzdGFydFkpO1xuICAgIHJldHVybiB4IDwgYi5tYXhYICYmIHggPiBiLm1pblggJiYgeSA8IGIubWF4WSAmJiB5ID4gYi5taW5ZICYmIGQgPCBTQ1JPTExfVE9MRVJBTkNFO1xuICB9XG5cbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBvblRvdWNoQ2FuY2VsLCBmYWxzZSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UpO1xufVxuIiwiaW1wb3J0IFphbmltbyBmcm9tICd6YW5pbW8nO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IEJ1dHRvbkhhbmRsZXIgZnJvbSAnLi9idXR0b24nO1xuaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmNvbnN0IGFuaW1EdXJhdGlvbiA9IDI1MDtcblxuZnVuY3Rpb24gY3JlYXRlVGFwSGFuZGxlcih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgc2Nyb2xsWCwgc2Nyb2xsWSwgZ2V0RWxlbWVudCwgcHJldmVudEVuZERlZmF1bHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZub2RlKSB7XG4gICAgQnV0dG9uSGFuZGxlcih2bm9kZS5kb20sXG4gICAgICAgICAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0YXBIYW5kbGVyKGUpO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBob2xkSGFuZGxlciA/IChlKSA9PiB1dGlscy5hdXRvcmVkcmF3KCgpID0+IGhvbGRIYW5kbGVyKGUpKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIHJlcGVhdEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICBzY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgc2Nyb2xsWSxcbiAgICAgICAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICBwcmV2ZW50RW5kRGVmYXVsdCk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbnRhcCh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgZ2V0RWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlVGFwSGFuZGxlcih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgZmFsc2UsIGZhbHNlLCBnZXRFbGVtZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9udGFwWFkodGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIGdldEVsZW1lbnQsIHByZXZlbnRFbmREZWZhdWx0ID0gdHJ1ZSkge1xuICByZXR1cm4gY3JlYXRlVGFwSGFuZGxlcih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgdW5kZWZpbmVkLCB0cnVlLCB0cnVlLCBnZXRFbGVtZW50LCBwcmV2ZW50RW5kRGVmYXVsdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbGlkZXNJblVwKHZub2RlKSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZG9tO1xuICBlbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgxMDAlKSc7XG4gIHZub2RlLnN0YXRlLmxvbCA9IGVsLm9mZnNldEhlaWdodDtcbiAgcmV0dXJuIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDApJywgMjUwLCAnZWFzZS1vdXQnKVxuICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsaWRlc091dERvd24oY2FsbGJhY2ssIGVsSUQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZyb21CQikge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxJRCk7XG4gICAgcmV0dXJuIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDEwMCUpJywgMjUwLCAnZWFzZS1vdXQnKVxuICAgICAgLnRoZW4oKCkgPT4gdXRpbHMuYXV0b3JlZHJhdygoKSA9PiBjYWxsYmFjayhmcm9tQkIpKSlcbiAgICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTtcbiAgfTtcbn1cblxuXG5cbi8vIGVsIGZhZGUgaW4gdHJhbnNpdGlvbiwgY2FuIGJlIGFwcGxpZWQgdG8gYW55IGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBlbEZhZGVJbihlbCwgZHVyYXRpb24gPSBhbmltRHVyYXRpb24sIG9yaWdPcGFjaXR5ID0gJzAuNScsIGVuZE9wYWNpdHkgPSAnMScpIHtcbiAgbGV0IHRJZDtcblxuICBlbC5zdHlsZS5vcGFjaXR5ID0gb3JpZ09wYWNpdHk7XG4gIGVsLnN0eWxlLnRyYW5zaXRpb24gPSBgb3BhY2l0eSAke2R1cmF0aW9ufW1zIGVhc2Utb3V0YDtcblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBlbC5zdHlsZS5vcGFjaXR5ID0gZW5kT3BhY2l0eTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRJZCk7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgYWZ0ZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgYWZ0ZXIsIGZhbHNlKTtcbiAgLy8gaW4gY2FzZSB0cmFuc2l0aW9uZW5kIGRvZXMgbm90IGZpcmVcbiAgdElkID0gc2V0VGltZW91dChhZnRlciwgZHVyYXRpb24gKyAxMCk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1dHRvbihlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICByZXR1cm4gdGFyZ2V0LnRhZ05hbWUgPT09ICdCVVRUT04nID8gdGFyZ2V0IDogZmluZFBhcmVudEJ5U2VsZWN0b3IodGFyZ2V0LCAnYnV0dG9uJyk7XG59XG5cbi8vIE9MRFxuXG4vL3N0b3JlIHRlbXBvcmFyaWx5IGxhc3Qgcm91dGUgdG8gZGlzYWJsZSBhbmltYXRpb25zIG9uIHNhbWUgcm91dGVcbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgY2F1c2UgdGhpcyBpcyB1Z2x5XG5sZXQgbGFzdFJvdXRlO1xuXG4vLyB0aGlzIG11c3QgYmUgY2FjaGVkIGJlY2F1c2Ugb2YgdGhlIGFjY2VzcyB0byBkb2N1bWVudC5ib2R5LnN0eWxlXG5sZXQgY2FjaGVkVHJhbnNmb3JtUHJvcDtcbmxldCBjYWNoZWRWaWV3cG9ydERpbSA9IG51bGw7XG5cbmZ1bmN0aW9uIHZpZXdTbGlkZUluKGVsLCBjYWxsYmFjaykge1xuICBpZiAobS5yb3V0ZSgpID09PSBsYXN0Um91dGUpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxhc3RSb3V0ZSA9IG0ucm91dGUoKTtcblxuICBmdW5jdGlvbiBhZnRlcigpIHtcbiAgICB1dGlscy5zZXRWaWV3U2xpZGVEaXJlY3Rpb24oJ2Z3ZCcpO1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgY29uc3QgZGlyZWN0aW9uID0gdXRpbHMuZ2V0Vmlld1NsaWRlRGlyZWN0aW9uKCkgPT09ICdmd2QnID8gJzEwMCUnIDogJy0xMDAlJztcbiAgZWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7ZGlyZWN0aW9ufSwwLDApYDtcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICd0cmFuc2Zvcm0gMjAwbXMgZWFzZS1vdXQnO1xuXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybT0gJ3RyYW5zbGF0ZTNkKDAlLDAsMCknO1xuICB9KTtcblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgYWZ0ZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gdmlld1NsaWRlT3V0KGVsLCBjYWxsYmFjaykge1xuICBpZiAobS5yb3V0ZSgpID09PSBsYXN0Um91dGUpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIHV0aWxzLnNldFZpZXdTbGlkZURpcmVjdGlvbignZndkJyk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGNvbnN0IGRpcmVjdGlvbiA9IHV0aWxzLmdldFZpZXdTbGlkZURpcmVjdGlvbigpID09PSAnZndkJyA/ICctMTAwJScgOiAnMTAwJSc7XG4gIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwJSwwLDApJztcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICd0cmFuc2Zvcm0gMjAwbXMgZWFzZS1vdXQnO1xuXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybT0gYHRyYW5zbGF0ZTNkKCR7ZGlyZWN0aW9ufSwwLDApYDtcbiAgfSk7XG5cbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGFmdGVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHZpZXdGYWRlc0luKGVsLCBjYWxsYmFjaykge1xuICB2YXIgdElkO1xuXG4gIGVsLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDIwMG1zIGVhc2Utb3V0JztcblxuICBzZXRUaW1lb3V0KCgpPT4ge1xuICAgIGVsLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIGNsZWFyVGltZW91dCh0SWQpO1xuICAgIGlmIChlbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVkJywgYWZ0ZXIsIGZhbHNlKTtcbiAgICB9XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lZCcsIGFmdGVyLCBmYWxzZSk7XG5cbiAgLy8gaW4gY2FzZSB0cmFuc2l0aW9uZWQgZG9lcyBub3QgZmlyZVxuICAvLyBUT0RPIGZpbmQgYSB3YXkgdG8gYXZvaWQgaXRcbiAgdElkID0gc2V0VGltZW91dChhZnRlciwgMjUwKTtcbn1cblxuZnVuY3Rpb24gdmlld0ZhZGVzT3V0KGVsLCBjYWxsYmFjaykge1xuICB2YXIgdElkO1xuXG4gIGVsLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gIGVsLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAyMDBtcyBlYXNlLW91dCwgdmlzaWJpbGl0eSAwcyBsaW5lYXIgMjAwbXMnO1xuXG4gIHNldFRpbWVvdXQoKCk9PiB7XG4gICAgZWwuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIGNsZWFyVGltZW91dCh0SWQpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZWQnLCBhZnRlciwgZmFsc2UpO1xuXG4gIC8vIGluIGNhc2UgdHJhbnNpdGlvbmVkIGRvZXMgbm90IGZpcmVcbiAgLy8gVE9ETyBmaW5kIGEgd2F5IHRvIGF2b2lkIGl0XG4gIHRJZCA9IHNldFRpbWVvdXQoYWZ0ZXIsIDI1MCk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25IYXMoY29sbCwgZWwpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoY29sbFtpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZFBhcmVudEJ5U2VsZWN0b3IoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBtYXRjaGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIHZhciBjdXIgPSBlbC5wYXJlbnROb2RlO1xuICB3aGlsZSAoY3VyICYmICFjb2xsZWN0aW9uSGFzKG1hdGNoZXMsIGN1cikpIHtcbiAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gY3VyO1xufVxuXG5mdW5jdGlvbiBvbnRvdWNoKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCByZXBlYXRIYW5kbGVyLCBzY3JvbGxYLCBzY3JvbGxZLCB0b3VjaEVuZEZlZWRiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihlbCwgaXNVcGRhdGUpIHtcbiAgICBpZiAoIWlzVXBkYXRlKSB7XG4gICAgICBCdXR0b25IYW5kbGVyKGVsLFxuICAgICAgICAgICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBtLnN0YXJ0Q29tcHV0YXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFwSGFuZGxlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5lbmRDb21wdXRhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaG9sZEhhbmRsZXIgPyAoKSA9PiB1dGlscy5hdXRvcmVkcmF3KGhvbGRIYW5kbGVyKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFksXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoRW5kRmVlZGJhY2tcbiAgICAgICAgICAgICAgICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRyYW5zZm9ybVByb3AoKSB7XG4gIHJldHVybiAndHJhbnNmb3JtJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlID9cbiAgICAndHJhbnNmb3JtJyA6ICd3ZWJraXRUcmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUgP1xuICAgICd3ZWJraXRUcmFuc2Zvcm0nIDogJ21velRyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSA/XG4gICAgJ21velRyYW5zZm9ybScgOiAnb1RyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSA/XG4gICAgJ29UcmFuc2Zvcm0nIDogJ21zVHJhbnNmb3JtJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZpZXdwb3J0RGltKCkge1xuICBpZiAoY2FjaGVkVmlld3BvcnREaW0pIHJldHVybiBjYWNoZWRWaWV3cG9ydERpbTtcblxuICBsZXQgZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgbGV0IHZwZCA9IGNhY2hlZFZpZXdwb3J0RGltID0ge1xuICAgIHZ3OiBlLmNsaWVudFdpZHRoLFxuICAgIHZoOiBlLmNsaWVudEhlaWdodFxuICB9O1xuICByZXR1cm4gdnBkO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uSGFzKGNvbGwsIGVsKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb2xsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNvbGxbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50QnlTZWxlY3RvcihlbCwgc2VsZWN0b3IpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICBsZXQgY3VyID0gZWw7XG4gIHdoaWxlIChjdXIgJiYgIWNvbGxlY3Rpb25IYXMobWF0Y2hlcywgY3VyKSkge1xuICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBjdXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMSShlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICByZXR1cm4gdGFyZ2V0LnRhZ05hbWUgPT09ICdMSScgPyB0YXJnZXQgOiBmaW5kUGFyZW50QnlTZWxlY3Rvcih0YXJnZXQsICdMSScpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xhc3NTZXQoY2xhc3Nlcykge1xuICBjb25zdCBhcnIgPSBbXTtcbiAgZm9yIChsZXQgaSBpbiBjbGFzc2VzKSB7XG4gICAgaWYgKGNsYXNzZXNbaV0pIGFyci5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBhcnIuam9pbignICcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYWNoZWRWaWV3cG9ydERpbSgpIHtcbiAgY2FjaGVkVmlld3BvcnREaW0gPSBudWxsO1xufVxuXG4vLyBleHBvcnQgZGVmYXVsdCB7XG4vLyAgIHNsaWRpbmdQYWdlOiBhbmltYXRvcih2aWV3U2xpZGVJbiwgdmlld1NsaWRlT3V0KSxcbi8vICAgZmFkaW5nUGFnZTogYW5pbWF0b3Iodmlld0ZhZGVzSW4sIHZpZXdGYWRlc091dCksXG4vLyAgIHZpZXdwb3J0RGltLFxuLy8gICBjbGVhckNhY2hlZFZpZXdwb3J0RGltKCkge1xuLy8gICAgIGNhY2hlZFZpZXdwb3J0RGltID0gbnVsbDtcbi8vICAgfSxcblxuLy8gICB0cmFuc2Zvcm1Qcm9wOiBmdW5jdGlvbigpIHtcbi8vICAgICBpZiAoIWNhY2hlZFRyYW5zZm9ybVByb3ApIGNhY2hlZFRyYW5zZm9ybVByb3AgPSBjb21wdXRlVHJhbnNmb3JtUHJvcCgpO1xuLy8gICAgIHJldHVybiBjYWNoZWRUcmFuc2Zvcm1Qcm9wO1xuLy8gICB9LFxuXG4vLyAgIHNsaWRlc0luVXA6IGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuLy8gICAgIGlmICghaXNVcGRhdGUpIHtcbi8vICAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKDEwMCUpJztcbi8vICAgICAgIC8vIGZvcmNlIHJlZmxvdyBiYWNrXG4vLyAgICAgICBjb250ZXh0LmxvbCA9IGVsLm9mZnNldEhlaWdodDtcbi8vICAgICAgIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDApJywgMjUwLCAnZWFzZS1vdXQnKVxuLy8gICAgICAgICAuY2F0Y2goY29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7XG4vLyAgICAgfVxuLy8gICB9LFxuLy8gICBzbGlkZXNPdXREb3duOiBmdW5jdGlvbihjYWxsYmFjaywgZWxJRCkge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbigpIHtcbi8vICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxJRCk7XG4vLyAgICAgICBtLnJlZHJhdy5zdHJhdGVneSgnbm9uZScpO1xuLy8gICAgICAgcmV0dXJuIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDEwMCUpJywgMjUwLCAnZWFzZS1vdXQnKVxuLy8gICAgICAgICAudGhlbih1dGlscy5hdXRvcmVkcmF3LmJpbmQobnVsbCwgY2FsbGJhY2spKVxuLy8gICAgICAgICAuY2F0Y2goY2FsbGJhY2spO1xuLy8gICAgIH07XG4vLyAgIH0sXG5cbi8vICAgZmFkZXNPdXQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBzZWxlY3RvciwgdGltZSA9IDE1MCkge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4vLyAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuLy8gICAgICAgdmFyIGVsID0gc2VsZWN0b3IgPyBmaW5kUGFyZW50QnlTZWxlY3RvcihlLnRhcmdldCwgc2VsZWN0b3IpIDogZS50YXJnZXQ7XG4vLyAgICAgICBtLnJlZHJhdy5zdHJhdGVneSgnbm9uZScpO1xuLy8gICAgICAgcmV0dXJuIFphbmltbyhlbCwgJ29wYWNpdHknLCAwLCB0aW1lKVxuLy8gICAgICAgICAudGhlbigoKSA9PiB1dGlscy5hdXRvcmVkcmF3KGNhbGxiYWNrKSlcbi8vICAgICAgICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO1xuLy8gICAgIH07XG4vLyAgIH0sXG5cbi8vICAgb250b3VjaDogZnVuY3Rpb24odGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIHRvdWNoRW5kRmVlZGJhY2sgPSB0cnVlKSB7XG4vLyAgICAgcmV0dXJuIG9udG91Y2godGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIGZhbHNlLCBmYWxzZSwgdG91Y2hFbmRGZWVkYmFjayk7XG4vLyAgIH0sXG4vLyAgIG9udG91Y2hYOiBmdW5jdGlvbih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgdG91Y2hFbmRGZWVkYmFjayA9IHRydWUpIHtcbi8vICAgICByZXR1cm4gb250b3VjaCh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgbnVsbCwgdHJ1ZSwgZmFsc2UsIHRvdWNoRW5kRmVlZGJhY2spO1xuLy8gICB9LFxuLy8gICBvbnRvdWNoWTogZnVuY3Rpb24odGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHRvdWNoRW5kRmVlZGJhY2sgPSB0cnVlKSB7XG4vLyAgICAgcmV0dXJuIG9udG91Y2godGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIG51bGwsIGZhbHNlLCB0cnVlLCB0b3VjaEVuZEZlZWRiYWNrKTtcbi8vICAgfSxcbi8vICAgY2xhc3NTZXQ6IGZ1bmN0aW9uKGNsYXNzZXMpIHtcbi8vICAgICB2YXIgYXJyID0gW107XG4vLyAgICAgZm9yICh2YXIgaSBpbiBjbGFzc2VzKSB7XG4vLyAgICAgICBpZiAoY2xhc3Nlc1tpXSkgYXJyLnB1c2goaSk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBhcnIuam9pbignICcpO1xuLy8gICB9LFxuXG4vLyAgIGlzV2lkZVNjcmVlbjogZnVuY3Rpb24oKSB7XG4vLyAgICAgcmV0dXJuIHZpZXdwb3J0RGltKCkudncgPj0gNjAwO1xuLy8gICB9LFxuLy8gICBpc0lwYWRMaWtlOiBmdW5jdGlvbigpIHtcbi8vICAgICBjb25zdCB7IHZoLCB2dyB9ID0gdmlld3BvcnREaW0oKTtcbi8vICAgICByZXR1cm4gdmggPj0gNzAwICYmIHZ3IDw9IDEwNTA7XG4vLyAgIH0sXG4vLyAgIGlzUG9ydHJhaXQ6IGZ1bmN0aW9uKCkge1xuLy8gICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYSgnKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknKS5tYXRjaGVzO1xuLy8gICB9LFxuLy8gICBpc0xhbmRzY2FwZTogZnVuY3Rpb24oKSB7XG4vLyAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcob3JpZW50YXRpb246IGxhbmRzY2FwZSknKS5tYXRjaGVzO1xuLy8gICB9LFxuLy8gICBwcm9ncmVzczogZnVuY3Rpb24gKHApIHtcbi8vICAgICBpZiAocCA9PT0gMCkgcmV0dXJuIG51bGw7XG4vLyAgICAgcmV0dXJuIG0oJ3NwYW4nLCB7XG4vLyAgICAgICBjbGFzc05hbWU6ICdwcm9ncmVzcyAnICsgKHAgPiAwID8gJ3Bvc2l0aXZlJyA6ICduZWdhdGl2ZScpLFxuLy8gICAgICAgJ2RhdGEtaWNvbic6IHAgPiAwID8gJ04nIDogJ00nXG4vLyAgICAgfSwgTWF0aC5hYnMocCkpO1xuLy8gICB9XG4vLyB9O1xuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgeyByZW5kZXJRdWlja1NldHVwIH0gZnJvbSAnLi4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IG5ld0dhbWVGb3JtIGZyb20gJy4uL25ld0dhbWVGb3JtJztcbmltcG9ydCB7IGhlYWRlciBhcyBoZWFkZXJXaWRnZXQgfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gYm9keShjdHJsKSB7XG4gIGNvbnN0IG5iUGxheWVycyA9IGkxOG4oJ25iQ29ubmVjdGVkUGxheWVycycsIGN0cmwubmJDb25uZWN0ZWRQbGF5ZXJzKCkgfHwgJz8nKTtcbiAgY29uc3QgbmJHYW1lcyA9IGkxOG4oJ25iR2FtZXNJblBsYXknLCBjdHJsLm5iR2FtZXNJblBsYXkoKSB8fCAnPycpO1xuXG4gIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5hdGl2ZV9zY3JvbGxlciBwYWdlXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaG9tZVwiPlxuICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInN0YXRzXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm51bVBsYXllcnNcIj57bmJQbGF5ZXJzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJudW1HYW1lc1wiPntuYkdhbWVzfTwvZGl2PlxuICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgIHsgcmVuZGVyUXVpY2tHYW1lKCkgfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICApO1xuXG4gIC8vIGNvbnN0IGhlYWRlciA9IGhlYWRlcldpZGdldC5iaW5kKG51bGwsICdveXVua2V5Zi5uZXQnKTtcblxuICAvLyByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCBib2R5KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUXVpY2tHYW1lKCkge1xuICByZXR1cm4gaCgnZGl2LmhvbWVDcmVhdGUnLCBbXG4gICAgaCgnaDIuaG9tZVRpdGxlJywgJ0hlbWVuIG95bmEnKSxcbiAgICByZW5kZXJRdWlja1NldHVwKCgpID0+IG5ld0dhbWVGb3JtLm9wZW5SZWFsdGltZSgnY3VzdG9tJykpXG4gIF0pO1xufVxuIiwiaW1wb3J0IHN0cmVhbSBmcm9tICdtaXRocmlsL3N0cmVhbSc7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgeyBoYXNOZXR3b3JrLCBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHsgaXNGb3JlZ3JvdW5kLCBzZXRGb3JlZ3JvdW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXBwTW9kZSc7XG5pbXBvcnQgeyBkcm9wU2hhZG93SGVhZGVyIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgeyBib2R5IH0gZnJvbSAnLi9ob21lVmlldyc7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KCkge1xuICAgIGNvbnN0IG5iQ29ubmVjdGVkUGxheWVycyA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IG5iR2FtZXNJblBsYXkgPSBzdHJlYW0oKTtcbiAgICBcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKGlzRm9yZWdyb3VuZCgpKSB7XG4gICAgICAgIHNvY2tldC5jcmVhdGVMb2JieSgnaG9tZUxvYmJ5Jywgbm9vcCwge1xuICAgICAgICAgIG46IChfLCBkKSA9PiB7XG4gICAgICAgICAgICBuYkNvbm5lY3RlZFBsYXllcnMoZC5kKTtcbiAgICAgICAgICAgIG5iR2FtZXNJblBsYXkoZC5yKTtcbiAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXN1bWUoKSB7XG4gICAgICBzZXRGb3JlZ3JvdW5kKCk7XG4gICAgICBpbml0KCk7XG4gICAgfVxuXG4gICAgaWYgKGhhc05ldHdvcmsoKSkge1xuICAgICAgaW5pdCgpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGluaXQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc3VtZScsIG9uUmVzdW1lKTtcblxuICAgIHRoaXMuY3RybCA9IHtcbiAgICAgIG5iQ29ubmVjdGVkUGxheWVycyxcbiAgICAgIG5iR2FtZXNJblBsYXlcbiAgICB9O1xuICB9LFxuICBcbiAgdmlldygpIHtcbiAgICBjb25zdCBoZWFkZXIgPSBkcm9wU2hhZG93SGVhZGVyKCdveXVua2V5Zi5uZXQnKTtcblxuICAgIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIsIGJvZHkodGhpcy5jdHJsKSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCAqIGFzIG1lbnUgZnJvbSAnLi9tZW51JztcbmltcG9ydCBNZW51VmlldyBmcm9tICcuL21lbnUvbWVudVZpZXcnO1xuaW1wb3J0IE1haW5Cb2FyZCBmcm9tICcuL3NoYXJlZC9sYXlvdXQvTWFpbkJvYXJkJztcbmltcG9ydCBnYW1lc01lbnUgZnJvbSAnLi9nYW1lc01lbnUnO1xuaW1wb3J0IG5ld0dhbWVGb3JtIGZyb20gJy4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IGxvZ2luTW9kYWwgZnJvbSAnLi9sb2dpbk1vZGFsJztcbmltcG9ydCBzaWdudXBNb2RhbCBmcm9tICcuL3NpZ251cE1vZGFsJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uL3NldHRpbmdzJztcblxudmFyIGJhY2tncm91bmQ7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBib2FyZDogZnVuY3Rpb24oaGVhZGVyLCBjb250ZW50LCBvdmVybGF5KSB7XG4gICAgYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cbiAgICByZXR1cm4gaCgnZGl2LnZpZXctY29udGFpbmVyJywgeyBjbGFzc05hbWU6IGJnQ2xhc3MoYmFja2dyb3VuZCkgfSwgW1xuICAgICAgaChNYWluQm9hcmQsIHsgaGVhZGVyIH0sIGNvbnRlbnQpLFxuICAgICAgLy8gaChNZW51VmlldyksXG4gICAgICBvdmVybGF5XG4gICAgXSk7XG4gIH0sXG5cblxuICBmcmVlOiBmdW5jdGlvbihoZWFkZXIsIGNvbnRlbnQsIGZvb3Rlciwgb3ZlcmxheSkge1xuICAgIGJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8IHNldHRpbmdzLmdlbmVyYWwudGhlbWUuYmFja2dyb3VuZCgpO1xuICAgIFxuICAgIHJldHVybiAoXG4gICAgICBoKCdkaXYudmlldy1jb250YWluZXInLCB7IGNsYXNzTmFtZTogYmdDbGFzcyhiYWNrZ3JvdW5kKSB9LCBbXG4gICAgICAgIGgoJ21haW4jcGFnZScsIHsgb25jcmVhdGU6IGhhbmRsZU1lbnVPcGVuIH0sIFtcbiAgICAgICAgICBoKCdoZWFkZXIubWFpbl9oZWFkZXInLCBoZWFkZXIpLFxuICAgICAgICAgIGgoJ2RpdiNmcmVlX2NvbnRlbnQuY29udGVudC5uYXRpdmVfc2Nyb2xsZXInLCBjb250ZW50KSxcbiAgICAgICAgICBmb290ZXIgPyBoKCdmb290ZXIubWFpbl9mb290ZXInLCBmb290ZXIpIDogbnVsbCxcbiAgICAgICAgICBoKCdkaXYjbWVudS1jbG9zZS1vdmVybGF5Lm1lbnUtYmFja2Ryb3AnLCB7IG9uY3JlYXRlOiBtZW51LmJhY2tkcm9wQ2xvc2VIYW5kbGVyIH0pXG4gICAgICAgIF0pLFxuICAgICAgICBoKE1lbnVWaWV3KSxcbiAgICAgICAgbG9naW5Nb2RhbC52aWV3KCksXG4gICAgICAgIHNpZ251cE1vZGFsLnZpZXcoKSxcbiAgICAgICAgbmV3R2FtZUZvcm0udmlldygpLFxuICAgICAgICBvdmVybGF5XG4gICAgICBdKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWVudU9wZW4oKSB7XG59XG5cbmZ1bmN0aW9uIGJnQ2xhc3MoYmdUaGVtZSkge1xuICByZXR1cm4gYmdUaGVtZSA9PT0gJ2RhcmsnIHx8IGJnVGhlbWUgPT09ICdsaWdodCcgPyBiZ1RoZW1lIDogJ3RyYW5zcCAnICsgYmdUaGVtZTtcbn1cbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuLi94aHInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN0YXJ0U2Vla2luZyhjb25mKSB7XG4gICAgZG9TdGFydFNlZWtpbmcoY29uZik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvU3RhcnRTZWVraW5nKGNvbmYpIHtcbiAgLy8gcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaCh1c2VyQ2FuY2VsU2Vla2luZyk7XG5cbiAgc2VuZEhvb2soY29uZik7XG59XG5cbmZ1bmN0aW9uIHNlbmRIb29rKHNldHVwKSB7XG4gIHhoci5zZWVrR2FtZShzZXR1cClcbiAgICAudGhlbihkYXRhID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgcm91dGVyLnNldCgnL21hc2EvJyArIGRhdGEuaWQpO1xuICAgIH0pLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbn1cblxuLy8gaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuLy8gaW1wb3J0ICogYXMgeGhyIGZyb20gJy4uL3hocic7XG4vLyBpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuLy8gbGV0IG5iUGxheWVycyA9IDA7XG4vLyBsZXQgbmJHYW1lcyA9IDA7XG5cbi8vIGNvbnN0IGxvYmJ5ID0ge307XG4vLyBsb2JieS5pc09wZW4gPSBmYWxzZTtcblxuLy8gbG9iYnkuc3RhcnRTZWVraW5nID0gZnVuY3Rpb24oKSB7XG4vLyAgIHhoci5uZXdHYW1lKCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4vLyAgICAgLy8gYW5hbHl0aWNzXG4vLyAgICAgbS5yb3V0ZSgnL21hc2EvJyArIGRhdGEuaWQpO1xuLy8gICB9LCBmdW5jdGlvbihlcnJvcikge1xuLy8gICAgIHV0aWxzLmhhbmRsZVhockVycm9yKGVycm9yKTtcbi8vICAgICB0aHJvdyBlcnJvcjtcbi8vICAgfSk7XG4vLyB9O1xuXG5cbi8vIGV4cG9ydCBkZWZhdWx0IGxvYmJ5O1xuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi9zZXNzaW9uJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBpMThuIGZyb20gJy4uL2kxOG4nO1xuaW1wb3J0IHNpZ25hbHMgZnJvbSAnLi4vc2lnbmFscyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgaGFuZGxlWGhyRXJyb3IgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi9iYWNrYnV0dG9uJztcbmltcG9ydCBzaWdudXBNb2RhbCBmcm9tICcuL3NpZ251cE1vZGFsJztcbmltcG9ydCB7IGNsb3NlSWNvbiB9IGZyb20gJy4vc2hhcmVkL2ljb25zJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vcm91dGVyJztcblxubGV0IGlzT3BlbiA9IGZhbHNlO1xubGV0IGZvcm1FcnJvciA9IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb3BlbixcbiAgY2xvc2UsXG4gIHZpZXcoKSB7XG4gICAgaWYgKCFpc09wZW4pIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIGgoJ2Rpdi5tb2RhbCNsb2dpbk1vZGFsJywgeyBvbmNyZWF0ZTogaGVscGVyLnNsaWRlc0luVXAgfSwgW1xuICAgICAgaCgnaGVhZGVyJywgW1xuICAgICAgICBoKCdidXR0b24ubW9kYWxfY2xvc2UnLCB7XG4gICAgICAgICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcChoZWxwZXIuc2xpZGVzT3V0RG93bihjbG9zZSwgJ2xvZ2luTW9kYWwnKSlcbiAgICAgICAgfSwgY2xvc2VJY29uKSxcbiAgICAgICAgaCgnaDInLCBpMThuKCdzaWduSW4nKSlcbiAgICAgIF0pLFxuICAgICAgaCgnZGl2Lm1vZGFsX2NvbnRlbnQnLCBbXG4gICAgICAgIGgoJ2Zvcm0ubG9naW4nLCB7XG4gICAgICAgICAgb25zdWJtaXQ6IChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzdWJtaXQoZS50YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgIGZvcm1FcnJvciA/IGgoJ2Rpdi5mb3JtLWVycm9yJywgZm9ybUVycm9yKTogbnVsbCxcbiAgICAgICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgICAgICBoKCdpbnB1dCN1c2VybmFtZScsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IGZvcm1FcnJvciA/ICdmb3JtLWVycm9yJzonJyxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4gICAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4gICAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiAnb2ZmJyxcbiAgICAgICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgICAgICAgICBzcGVsbGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgaCgnZGl2LmZpZWxkJywgW1xuICAgICAgICAgICAgaCgnaW5wdXQjcGFzc3dvcmQnLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdwYXNzd29yZCcsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogZm9ybUVycm9yPyAnZm9ybS1lcnJvcic6JycsXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdwYXNzd29yZCcpLFxuICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBoKCdkaXYuc3VibWl0JywgW1xuICAgICAgICAgICAgaCgnYnV0dG9uLnN1Ym1pdEJ1dHRvbltkYXRhLWljb249Rl0nLCBpMThuKCdzaWduSW4nKSlcbiAgICAgICAgICBdKVxuICAgICAgICBdKSxcbiAgICAgICAgaCgnZGl2LnNpZ251cCcsIFtcbiAgICAgICAgICBpMThuKCduZXdUb095dW5rZXlmJykgKyAnICcsXG4gICAgICAgICAgaCgnYnInKSxcbiAgICAgICAgICBoKCdhJywge1xuICAgICAgICAgICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcChzaWdudXBNb2RhbC5vcGVuKVxuICAgICAgICAgIH0sIFtpMThuKCdzaWduVXAnKV0pXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvcGVuKCkge1xuICByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wdXNoKGhlbHBlci5zbGlkZXNPdXREb3duKGNsb3NlLCAnbG9naW5Nb2RhbCcpKTtcbiAgaXNPcGVuID0gdHJ1ZTtcbiAgZm9ybUVycm9yID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xvc2UoZnJvbUJCKSB7XG4gIHdpbmRvdy5LZXlib2FyZC5oaWRlKCk7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBpc09wZW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3VibWl0KGZvcm0pIHtcbiAgY29uc3QgdXNlcm5hbWUgPSBmb3JtWyd1c2VybmFtZSddLnZhbHVlO1xuICBjb25zdCBwYXNzd29yZCA9IGZvcm1bJ3Bhc3N3b3JkJ10udmFsdWU7XG4gIGlmICghdXNlcm5hbWUgfHwgIXBhc3N3b3JkKSByZXR1cm47XG5cbiAgcmVkcmF3KCk7XG4gIHdpbmRvdy5LZXlib2FyZC5oaWRlKCk7XG4gIHNlc3Npb24ubG9naW4odXNlcm5hbWUsIHBhc3N3b3JkKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGNsb3NlKCk7XG4gICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ2xvZ2luU3VjY2Vzc2Z1bCcpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4gICAgICBzaWduYWxzLmFmdGVyTG9naW4uZGlzcGF0Y2goKTtcbiAgICAgIHJlZHJhdygpO1xuICAgICAgc29ja2V0LnJlY29ubmVjdEN1cnJlbnQoKTtcbiAgICAgIHNlc3Npb24ucmVmcmVzaCgpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuc3RhdHVzICE9PSA0MDAgJiYgZXJyLnN0YXR1cyAhPT0gNDAxKSBoYW5kbGVYaHJFcnJvcihlcnIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChlcnIuYm9keS5nbG9iYWwpIHtcbiAgICAgICAgICBmb3JtRXJyb3IgPSBlcnIuYm9keS5nbG9iYWxbMF07XG4gICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgXG59XG5cblxuLy8gT0xEXG5cbmNvbnN0IGxvZ2luTW9kYWwgPSB7fTtcblxuZnVuY3Rpb24gc3VibWl0T0xEKGZvcm0pIHtcbiAgY29uc3QgbG9naW4gPSBmb3JtWzBdLnZhbHVlLnRyaW0oKTtcbiAgY29uc3QgcGFzcyA9IGZvcm1bMV0udmFsdWU7XG4gIGlmICghbG9naW4gfHwgIXBhc3MpIHJldHVybiBmYWxzZTtcbiAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5jbG9zZSgpO1xuICByZXR1cm4gc2Vzc2lvbi5sb2dpbihsb2dpbiwgcGFzcykudGhlbihmdW5jdGlvbigpIHtcbiAgICBsb2dpbk1vZGFsLmNsb3NlKCk7XG4gICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhpMThuKCdsb2dpblN1Y2Nlc3NmdWwnKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuICAgIC8vIHB1c2gucmVnaXN0ZXIoKTtcbiAgICBzZXNzaW9uLnJlZnJlc2goKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVsb2NlL2xpY2hvYmlsZS9ibG9iL21hc3Rlci9wcm9qZWN0L3NyYy9qcy91aS9sb2dpbk1vZGFsLmpzI0wyOFxuICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3Iubm90aWZpY2F0aW9uLmFsZXJ0KCdveXVua2V5ZkF1dGhlbnRpY2F0aW9uQ2Fubm90V29ya1dpdGhvdXRDb29raWVzJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KVxuICAgIC5jYXRjaCh1dGlscy5oYW5kbGVYaHJFcnJvcik7XG59XG5cbmxvZ2luTW9kYWwub3BlbiA9IGZ1bmN0aW9uKCkge1xuICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24obG9naW5Nb2RhbC5jbG9zZSwgJ2xvZ2luTW9kYWwnKSk7XG4gIGlzT3BlbiA9IHRydWU7XG59O1xuXG5sb2dpbk1vZGFsLmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4gIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuY2xvc2UoKTtcbiAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgaXNPcGVuID0gZmFsc2U7XG59O1xuXG5sb2dpbk1vZGFsLnZpZXcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFpc09wZW4pIHJldHVybiBudWxsO1xuXG4gIHJldHVybiBtKCdkaXYubW9kYWwjbG9naW5Nb2RhbCcsIHsgY29uZmlnOiBoZWxwZXIuc2xpZGVzSW5VcCB9LCBbXG4gICAgbSgnaGVhZGVyJywgW1xuICAgICAgbSgnYnV0dG9uLm1vZGFsX2Nsb3NlW2RhdGEtaWNvbj1MXScsIHtcbiAgICAgICAgY29uZmlnOiBoZWxwZXIub250b3VjaChoZWxwZXIuc2xpZGVzT3V0RG93bihsb2dpbk1vZGFsLmNsb3NlLCAnbG9naW5Nb2RhbCcpKVxuICAgICAgfSksXG4gICAgICBtKCdoMicsIGkxOG4oJ3NpZ25JbicpKVxuICAgIF0pLFxuICAgIG0oJ2Rpdi5tb2RhbF9jb250ZW50JywgW1xuICAgICAgbSgnZm9ybS5sb2dpbicsIHtcbiAgICAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHN1Ym1pdChlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtcbiAgICAgICAgbSgnaW5wdXQjcHNldWRvW3R5cGU9dGV4dF0nLCB7XG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4gICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsXG4gICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgICAgIHNwZWxsY2hlY2s6ICdmYWxzZScsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIG0oJ2lucHV0I3Bhc3N3b3JkW3R5cGU9cGFzc3dvcmRdJywge1xuICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdwYXNzd29yZCcpLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBtKCdidXR0b24uZmF0JywgaTE4bignc2lnbkluJykpXG4gICAgICBdKSxcbiAgICAgIG0oJ2Rpdi5zaWdudXAnLCBbXG4gICAgICAgIG0oJ2EnLCB7XG4gICAgICAgICAgY29uZmlnOiBoZWxwZXIub250b3VjaChzaWdudXBNb2RhbC5vcGVuKVxuICAgICAgICB9LCBbaTE4bignbmV3VG9PeXVua2V5ZicpLCAnICcsIGkxOG4oJ3NpZ25VcCcpXSlcbiAgICAgIF0pXG4gICAgXSlcbiAgXSk7XG59O1xuXG4vLyBleHBvcnQgZGVmYXVsdCBsb2dpbk1vZGFsO1xuIiwiaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHsgaGFuZGxlWGhyRXJyb3IgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi9tYXNhWGhyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFzYXNMaXN0Q3RybChkZWZhdWx0VGFiKSB7XG4gIHRoaXMuY3VycmVudFRhYiA9IGRlZmF1bHRUYWIgfHwgMDtcblxuICB4aHIuY3VycmVudE1hc2FzKClcbiAgICAudGhlbihkYXRhID0+IHtcbiAgICAgIHRoaXMubWFzYXMgPSBkYXRhO1xuICAgICAgcmVkcmF3KCk7XG4gICAgfSkuY2F0Y2goaGFuZGxlWGhyRXJyb3IpO1xuXG4gIHRoaXMub25UYWJDaGFuZ2UgPSAodGFiSW5kZXgpID0+IHtcbiAgICBjb25zdCBsb2MgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnJlcGxhY2UoL1xcP3RhYlxcPVxcdyskLywgJycpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgJycsIGxvYyArICc/dGFiPScgKyB0YWJJbmRleCk7XG4gICAgfSBjYXRjaCAoZSkgeyBjb25zb2xlLmVycm9yKGUpOyB9XG4gICAgdGhpcy5jdXJyZW50VGFiID0gdGFiSW5kZXg7XG4gICAgcmVkcmF3KCk7XG4gIH07XG5cbn1cbiIsImltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gvdGhyb3R0bGUnO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi8uLi9zb2NrZXQnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4uL21hc2FYaHInO1xuaW1wb3J0IGZhcSBmcm9tICcuLi9mYXEnO1xuaW1wb3J0IHNvY2tldEhhbmRsZXIgZnJvbSAnLi9zb2NrZXRIYW5kbGVyJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vLi4vcm91dGVyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFzYUN0cmwoaWQpIHtcblxuICB0aGlzLmlkID0gaWQ7XG5cbiAgdGhpcy5mYXFDdHJsID0gZmFxLmNvbnRyb2xsZXIodGhpcyk7XG4gIFxuICB4aHIubWFzYShpZCkudGhlbigoZGF0YSkgPT4ge1xuICAgIHRoaXMubWFzYSA9IGRhdGE7XG4gICAgdGhpcy5zZWF0SWQgPSBkYXRhLnNlYXRJZDtcblxuICAgIHRoaXMuc3RhcnRzQXQgPSB3aW5kb3cubW9tZW50KGRhdGEuc3RhcnRzQXQpLmNhbGVuZGFyKCk7XG4gICAgbG9hZEN1cnJlbnRQYWdlKHRoaXMubWFzYS5zdGFuZGluZyk7XG4gICAgdGhpcy5oYXNKb2luZWQgPSAhIShkYXRhLm1lICYmICFkYXRhLm1lLndpdGhkcmF3KTtcblxuICAgIHNvY2tldC5jcmVhdGVNYXNhKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIHRoaXMubWFzYS5zb2NrZXRWZXJzaW9uLFxuICAgICAgc29ja2V0SGFuZGxlcih0aGlzKSk7XG5cbiAgICByZWRyYXcoKTtcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHRoaXMubm90Rm91bmQgPSB0cnVlO1xuICAgICAgcmVkcmF3KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWxzLmhhbmRsZVhockVycm9yKGVycik7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmludml0ZSA9IHRocm90dGxlKCgpID0+IHtcbiAgICB4aHIuaW52aXRlKHRoaXMubWFzYS5pZClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgICB9KS5jYXRjaCh1dGlscy5oYW5kbGVYaHJFcnJvcik7XG4gIH0sIDEwMDApO1xuXG4gIHRoaXMuam9pbiA9IHRocm90dGxlKCgpID0+IHtcbiAgICB4aHIuam9pbih0aGlzLm1hc2EuaWQpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFzSm9pbmVkID0gdHJ1ZTtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgICB9KS5jYXRjaCh1dGlscy5oYW5kbGVYaHJFcnJvcik7XG4gIH0sIDEwMDApO1xuXG4gIHRoaXMud2l0aGRyYXcgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgeGhyLndpdGhkcmF3KHRoaXMubWFzYS5pZClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5oYXNKb2luZWQgPSBmYWxzZTtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgICB9KS5jYXRjaCh1dGlscy5oYW5kbGVYaHJFcnJvcik7XG4gIH0sIDEwMDApO1xuXG4gIHRoaXMucmVsb2FkID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgIHhoci5yZWxvYWQodGhpcy5pZClcbiAgICAgIC50aGVuKG9uUmVsb2FkKVxuICAgICAgLmNhdGNoKG9uWGhyRXJyb3IpO1xuICB9LCAyMDAwKTtcblxuXG4gIHRoaXMudW5sb2FkID0gKCkgPT4ge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc3VtZScsIHRoaXMucmVsb2FkKTtcbiAgfTtcblxuICBjb25zdCBvblJlbG9hZCA9IChkYXRhKSA9PiB7XG4gICAgY29uc3Qgb2xkRGF0YSA9IHRoaXMubWFzYTtcbiAgICB0aGlzLm1hc2EgPSBkYXRhO1xuICAgIHRoaXMuc2VhdElkID0gZGF0YS5zZWF0SWQ7XG4gICAgbG9hZEN1cnJlbnRQYWdlKGRhdGEuc3RhbmRpbmcpO1xuICAgIHRoaXMuaGFzSm9pbmVkID0gISEoZGF0YS5tZSAmJiAhZGF0YS5tZS53aXRoZHJhdyk7XG4gICAgcmVkaXJlY3RUb015R2FtZSgpO1xuICAgIHJlZHJhdygpO1xuICB9O1xuXG4gIGNvbnN0IHJlZGlyZWN0VG9NeUdhbWUgPSAoKSA9PiB7XG4gICAgdmFyIGdhbWVJZCA9IG15Q3VycmVudEdhbWVJZCh0aGlzKTtcbiAgICBpZiAoZ2FtZUlkKVxuICAgICAgcm91dGVyLnNldCgnL21hc2EvJyArIHRoaXMubWFzYS5pZCArICcvZ2FtZS8nICsgZ2FtZUlkLCB0cnVlKTtcbiAgfTtcblxuICBjb25zdCBteUN1cnJlbnRHYW1lSWQgPSAoY3RybCkgPT4ge1xuICAgIHZhciBpZHMgPSB7XG4gICAgICBjcmVhdGVkOiAxMCxcbiAgICAgIHN0YXJ0ZWQ6IDIwLFxuICAgICAgYWJvcnRlZDogMjVcbiAgICB9O1xuXG4gICAgdmFyIHNlYXRJZCA9IGN0cmwuc2VhdElkO1xuICAgIGlmICghc2VhdElkKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgcGFpcmluZyA9IGN0cmwubWFzYS5wYWlyaW5ncy5maWx0ZXIocCA9PiB7XG4gICAgICByZXR1cm4gcC5zIDwgaWRzLmFib3J0ZWQgJiYgKFxuICAgICAgICBwLnUuZmlsdGVyKChpZCkgPT4gaWQudG9Mb3dlckNhc2UoKSA9PT0gc2VhdElkLnRvTG93ZXJDYXNlKCkpWzBdXG4gICAgICApO1xuICAgIH0pWzBdO1xuICAgIHJldHVybiBwYWlyaW5nID8gcGFpcmluZy5pZCA6IG51bGw7XG4gIH07XG5cbiAgY29uc3Qgb25YaHJFcnJvciA9IChlcnIpID0+IHtcbiAgICBpZiAoZXJyLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICB0aGlzLm5vdEZvdW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVkcmF3KCk7XG4gIH07XG5cbiAgY29uc3QgbG9hZEN1cnJlbnRQYWdlID0gKGRhdGEpID0+IHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlUmVzdWx0cyA9IGRhdGEucGxheWVycztcbiAgfTtcbn1cbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi8uLi9zb2NrZXQnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vLi4vaTE4bic7XG5pbXBvcnQgeyBkcm9wU2hhZG93SGVhZGVyIGFzIGhlYWRlcldpZGdldCwgYmFja0J1dHRvbiwgY29ubmVjdGluZ0Ryb3BTaGFkb3dIZWFkZXIgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi8uLi9oZWxwZXInO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi8uLi9sYXlvdXQnO1xuaW1wb3J0IHsgbWFzYUJvZHksIHJlbmRlckZBUU92ZXJsYXksIHJlbmRlckZvb3RlciwgdGltZUluZm8gfSBmcm9tICcuL21hc2FWaWV3JztcblxuaW1wb3J0IE1hc2FDdHJsIGZyb20gJy4vTWFzYUN0cmwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdCh7YXR0cnN9KSB7XG4gICAgdGhpcy5jdHJsID0gbmV3IE1hc2FDdHJsKGF0dHJzLmlkKTtcbiAgfSxcbiAgb25jcmVhdGU6IGhlbHBlci52aWV3U2xpZGVJbixcbiAgb25yZW1vdmUoKSB7XG4gICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICB0aGlzLmN0cmwudW5sb2FkKCk7XG4gIH0sXG4gIHZpZXcoKSB7XG4gICAgaWYgKHRoaXMuY3RybC5ub3RGb3VuZCkge1xuICAgICAgcmV0dXJuIGxheW91dC5mcmVlKFxuICAgICAgICBoZWFkZXJXaWRnZXQobnVsbCwgYmFja0J1dHRvbihpMThuKCdtYXNhTm90Rm91bmQnKSkpLFxuICAgICAgICBoKCdkaXYubWFzYU5vdEZvdW5kJywgeyBrZXk6ICdtYXNhLW5vdC1mb3VuZCcgfSwgW1xuICAgICAgICAgIGgoJ3AnLCBpMThuKCdtYXNhRG9lc05vdEV4aXN0JykpLFxuICAgICAgICAgIGgoJ3AnLCBpMThuKCdtYXNhTWF5SGF2ZUJlZW5DYW5jZWxlZCcpKVxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXNhID0gdGhpcy5jdHJsLm1hc2E7XG4gICAgbGV0IGhlYWRlcjtcblxuICAgIGlmIChtYXNhKSB7XG4gICAgICBoZWFkZXIgPSBoZWFkZXJXaWRnZXQobnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrQnV0dG9uKGgoJ2Rpdi5tYWluX2hlYWRlcl90aXRsZS53aXRoU3ViJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnaDEnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ3NwYW4uZmEuZmEtdHJvcGh5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3RybC5tYXNhLmZ1bGxOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgoJ2gyLmhlYWRlci1zdWJUaXRsZS5tYXNhLXN1YlRpdGxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIW1hc2EuaXNGaW5pc2hlZCAmJiAhbWFzYS5pc1N0YXJ0ZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lSW5mbygnY3JlYXRlZCcsIG1hc2EucGxheWVyc1RvU3RhcnQsICdPeXVuY3UgYmVrbGVuaXlvcicpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZUluZm8oJ3N0YXJ0ZWQnLCBtYXNhLnJvdW5kc1RvRmluaXNoLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgPSBjb25uZWN0aW5nRHJvcFNoYWRvd0hlYWRlcigpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBtYXNhQm9keSh0aGlzLmN0cmwpO1xuICAgIGNvbnN0IGZvb3RlciA9IHJlbmRlckZvb3Rlcih0aGlzLmN0cmwpO1xuICAgIGNvbnN0IGZhcU92ZXJsYXkgPSByZW5kZXJGQVFPdmVybGF5KHRoaXMuY3RybCk7XG4gICAgY29uc3Qgb3ZlcmxheSA9IFtcbiAgICAgIGZhcU92ZXJsYXlcbiAgICBdO1xuXG4gICAgcmV0dXJuIGxheW91dC5mcmVlKGhlYWRlciwgYm9keSwgZm9vdGVyLCBvdmVybGF5KTtcbiAgfVxufTtcbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi8uLi9yb3V0ZXInO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi8uLi9pMThuJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi8uLi9oZWxwZXInO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uLy4uL3NldHRpbmdzJztcblxuaW1wb3J0IGZhcSBmcm9tICcuLi9mYXEnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRkFRT3ZlcmxheShjdHJsKSB7XG4gIHJldHVybiBbXG4gICAgZmFxLnZpZXcoY3RybC5mYXFDdHJsKVxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFzYUJvZHkoY3RybCkge1xuICBjb25zdCBkYXRhID0gY3RybC5tYXNhO1xuICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiBoKCdkaXYubWFzYUNvbnRhaW5lci5uYXRpdmVfc2Nyb2xsZXIucGFnZScsIFtcbiAgICBtYXNhSGVhZGVyKGRhdGEsIGN0cmwpLFxuICAgIGRhdGEucG9kaXVtID8gbWFzYVBvZGl1bShkYXRhLnBvZGl1bSk6IG51bGwsXG4gICAgbWFzYUxlYWRlcmJvYXJkKGN0cmwpXG4gIF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRm9vdGVyKGN0cmwpIHtcbiAgY29uc3QgbSA9IGN0cmwubWFzYTtcbiAgaWYgKCFtKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbVVybCA9ICdodHRwczovL295dW5rZXlmLm5ldC9tYXNhLycgKyBtLmlkO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zX2JhclwiPlxuICAgICAgPGJ1dHRvbiBrZXk9XCJmYXFcIiBjbGFzc05hbWU9XCJhY3Rpb25fYmFyX2J1dHRvblwiIG9uY3JlYXRlPXtoZWxwZXIub250YXAoY3RybC5mYXFDdHJsLm9wZW4pfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcXVlc3Rpb24tY2lyY2xlXCIvPlxuICAgICAgICAgIFNTU1xuICAgICAgPC9idXR0b24+XG4gICAgICB7Y3RybC5oYXNKb2luZWQgPyB3aXRoZHJhd0J1dHRvbihjdHJsLCBtKSA6IGpvaW5CdXR0b24oY3RybCwgbSkgfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUluZm8oa2V5LCByb3VuZHMsIHByZWNlZWRpbmdUZXh0KSB7XG4gIGlmIChyb3VuZHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIFtcbiAgICBwcmVjZWVkaW5nVGV4dCA/IChwcmVjZWVkaW5nVGV4dCArICcgJykgOiBudWxsLFxuICAgIC8vIGgoXG4gIF07XG59XG5cbmZ1bmN0aW9uIG1hc2FIZWFkZXIoZGF0YSwgY3RybCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYga2V5PVwiaGVhZGVyXCIgY2xhc3NOYW1lPVwibWFzYUhlYWRlclwiPlxuICAgICAge21hc2FUaW1lSW5mbyhkYXRhKX1cbiAgICB7bWFzYUNyZWF0b3JJbmZvKGRhdGEsIGN0cmwuc3RhcnRzQXQpfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiBtYXNhVGltZUluZm8oZGF0YSkge1xuICBjb25zdCB2YXJpYW50ID0gZGF0YS52YXJpYW50O1xuICBjb25zdCBjb250cm9sID0gZGF0YS5zY29yZXM7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhVGltZUluZm9cIj5cbiAgICAgIDxzdHJvbmcgY2xhc3NOYW1lPVwibWFzYUluZm8gd2l0aEljb25cIj5cbiAgICAgICAgeyB2YXJpYW50ICsgJyDigKIgJyArIGNvbnRyb2wgfVxuICAgICAgPC9zdHJvbmc+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hc2FDcmVhdG9ySW5mbyhkYXRhLCBzdGFydHNBdCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWFzYUNyZWF0b3JJbmZvXCI+XG4gICAgICB7aTE4bignYnknLCBkYXRhLmNyZWF0ZWRCeSl9XG4gICAgICAmbmJzcDvigKImbmJzcDt7c3RhcnRzQXR9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGpvaW5CdXR0b24oY3RybCwgbSkge1xuICBpZiAoIXNlc3Npb24uaXNDb25uZWN0ZWQoKSB8fCBtLmlzRmluaXNoZWQpIHsgcmV0dXJuIG51bGw7IH1cbiAgY29uc3QgYWN0aW9uID0gKCkgPT4gY3RybC5qb2luKCk7XG4gIHJldHVybiAoXG4gICAgICA8YnV0dG9uIGtleT1cImpvaW5cIiBjbGFzc05hbWU9XCJhY3Rpb25fYmFyX2J1dHRvblwiIG9uY3JlYXRlPXtoZWxwZXIub250YXAoYWN0aW9uKX0+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXBsYXlcIi8+XG4gICAgICAgIHtpMThuKCdqb2luJyl9XG4gICAgICA8L2J1dHRvbj5cbiAgKTsgIFxufVxuXG5mdW5jdGlvbiB3aXRoZHJhd0J1dHRvbihjdHJsLCBtKSB7XG4gIGlmIChtLmlzRmluaXNoZWQpIHsgcmV0dXJuIG51bGw7IH1cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uIGtleT1cIndpdGhkcmF3XCIgY2xhc3NOYW1lPVwiYWN0aW9uX2Jhcl9idXR0b25cIiBvbmNyZWF0ZT17aGVscGVyLm9udGFwKGN0cmwud2l0aGRyYXcpfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWZsYWdcIi8+XG4gICAgICB7aTE4bignd2l0aGRyYXcnKX1cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFzYUxlYWRlcmJvYXJkKGN0cmwpIHtcblxuICBjb25zdCBkYXRhID0gY3RybC5tYXNhO1xuICBjb25zdCBwbGF5ZXJzID0gY3RybC5jdXJyZW50UGFnZVJlc3VsdHM7XG4gIGNvbnN0IHVzZXIgPSBzZXNzaW9uLmdldCgpO1xuICBjb25zdCB1c2VyTmFtZSA9IHVzZXIgPyB1c2VyLnVzZXJuYW1lIDogJyc7XG4gIFxuICByZXR1cm4gKFxuICAgIDxkaXYga2V5PVwibGVhZGVyYm9hcmRcIiBjbGFzc05hbWU9XCJtYXNhTGVhZGVyYm9hcmRcIj5cbiAgICAgIHsgZGF0YS5uYlBsYXllcnMgPiAwID9cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwibWFzYVRpdGxlXCI+IHtpMThuKFwibGVhZGVyYm9hcmRcIil9ICh7aTE4bignbmJDb25uZWN0ZWRQbGF5ZXJzJywgZGF0YS5uYlBsYXllcnMpfSk8L3A+IDogbnVsbCB9XG4gICAgICA8dWwgY2xhc3NOYW1lPXsnbWFzYVN0YW5kaW5ncyd9PlxuICAgICAge3BsYXllcnMubWFwKHAgPT4gcmVuZGVyUGxheWVyRW50cnkoY3RybCwgdXNlck5hbWUsIHApKX1cbiAgICAgIDwvdWw+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBsYXllckVudHJ5KGN0cmwsIHVzZXJOYW1lLCBwbGF5ZXIpIHtcbiAgY29uc3QgaXNNZSA9IHBsYXllci5uYW1lID09PSB1c2VyTmFtZTtcblxuICByZXR1cm4gKFxuICAgICghcGxheWVyLmFjdGl2ZSkgPyAoXG4gICAgICA8bGkga2V5PXtwbGF5ZXIuaWR9IGNsYXNzTmFtZT17J2xpc3QtaXRlbSBtYXNhLWxpc3QtcGxheWVyJ30+XG4gICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhUGxheWVyXCI+XG4gICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGFnUmFua1wiIGRhdGEtaWNvbj17cGxheWVyLndpdGhkcmF3ID8gJ2InOicnfT4ge3BsYXllci53aXRoZHJhdyA/ICcnIDogKHBsYXllci5yYW5rICsgJy4gJyl9PC9zcGFuPlxuICAgICAgICAgPHNwYW4+IHtpMThuKCdlbXB0eVNlYXQnKX08L3NwYW4+XG4gICAgICAgICA8YnV0dG9uIG9uY3JlYXRlPXtoZWxwZXIub250YXAoY3RybC5pbnZpdGUpfT57aTE4bignaW52aXRlQm90Jyl9PC9idXR0b24+XG4gICAgICAgPC9kaXY+XG4gICAgICAgPHNwYW4gY2xhc3NOYW1lPXsnbWFzYVBvaW50cyAnfSBkYXRhLWljb249J1EnPntwbGF5ZXIuc2NvcmV9PC9zcGFuPlxuICAgICAgPC9saT5cbiAgICApIDpcbiAgICA8bGkgY2xhc3NOYW1lPXsnbGlzdC1pdGVtIG1hc2EtbGlzdC1wbGF5ZXIgJyArIChpc01lID8gJ21hc2EtbWUnIDogJycpfSA+XG4gICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhUGxheWVyXCI+XG4gICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGFnUmFua1wiIGRhdGEtaWNvbj17cGxheWVyLndpdGhkcmF3ID8gJ2InOicnfT4ge3BsYXllci53aXRoZHJhdyA/ICcnIDogKHBsYXllci5yYW5rICsgJy4gJyl9PC9zcGFuPlxuICAgICAgICAgPHNwYW4+IHshKHBsYXllci5uYW1lKSA/ICdBbm9ueW1vdXMnIDogcGxheWVyLm5hbWUgKyAnICgnICsgcGxheWVyLnJhdGluZyArICcpICd9PC9zcGFuPlxuICAgICAgIDwvZGl2PlxuICAgICAgIDxzcGFuIGNsYXNzTmFtZT17J21hc2FQb2ludHMgJ30gZGF0YS1pY29uPSdRJz57cGxheWVyLnNjb3JlfTwvc3Bhbj5cbiAgICA8L2xpPlxuICApO1xuXG59XG4iLCJpbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uLy4uL3JvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGN0cmwpIHtcbiAgcmV0dXJuIHtcbiAgICByZWxvYWQ6IGN0cmwucmVsb2FkLFxuICAgIHJlZGlyZWN0KGdhbWVJZCkge1xuICAgICAgLy8gZG9lc24ndCBmaXJlIGZvciBuZXcgam9pblxuICAgICAgY29uc29sZS5sb2coXCJyZWRpcmVjdFwiK2dhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi8uLi9iYWNrYnV0dG9uJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi9yb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKG1hc2EpIHtcbiAgICBsZXQgaXNPcGVuID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaChjbG9zZSk7XG4gICAgICBpc09wZW4gPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZShmcm9tQkIpIHtcbiAgICAgIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICAgICAgaXNPcGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW4sXG4gICAgICBjbG9zZSxcbiAgICAgIGlzT3BlbjogZnVuY3Rpb24oKSB7IHJldHVybiBpc09wZW47IH0sXG4gICAgICBtYXNhXG4gICAgfTtcbiAgfSxcbiAgdmlldzogZnVuY3Rpb24oY3RybCkge1xuICAgIGlmICghY3RybC5pc09wZW4oKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbWFzYSA9IGN0cmwubWFzYTtcblxuICAgIGlmICghbWFzYSkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbFwiIGlkPVwibWFzYUZhcU1vZGFsXCIgY29uZmlnPXtoZWxwZXIuc2xpZGVzSW5VcH0+XG4gICAgICAgIDxoZWFkZXI+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJtb2RhbF9jbG9zZVwiIGRhdGEtaWNvbj1cIkxcIlxuICAgICAgICAgICAgICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcChoZWxwZXIuc2xpZGVzT3V0RG93bihjdHJsLmNsb3NlLCBcIm1hc2FGYXFNb2RhbFwiKSl9Lz5cbiAgICAgICAgICA8aDI+e2kxOG4oJ21hc2FGQVEnKX08L2gyPlxuICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbF9jb250ZW50XCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhRmFxXCI+XG5cbiAgICAgICAgICAgIDxoMj5QdWFubMSxIG3EsT88L2gyPlxuXG4gICAgICAgICAgICB7IG1hc2EucmF0ZWQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAnQmF6xLEgbWFzYWxhciBwdWFubMSxZMSxciB2ZSByZXl0aW5naW5pemkgZXRraWxlci4nIDpcbiAgICAgICAgICAgIG1hc2EucmF0ZWQgP1xuICAgICAgICAgICAgICAnQnUgbWFzYSBwdWFubMSxZMSxciB2ZSByZXl0aW5naW5pemkgZXRraWxlci4nIDpcbiAgICAgICAgICAgICAgJ0J1IG1hc2EgcHVhbmzEsSAqZGXEn2lsZGlyKiB2ZSByZXl0aW5naW5pemkgKmV0a2lsZW1leiouJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICA8aDI+IFB1YW5sYXIgbmFzxLFsIGhlc2FwbGFuxLFyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNheWEga2F0xLFsxLFtZGEgaGVyIG95dW5jdSBvcnRheWEgZWwgc2F5xLFzxLEga2FkYXIgcHVhbsSxbsSxIGtveWFyLiBNYXNhIHNvbnVuZGEgb3J0YWRha2kgcHVhbmxhciDFn8O2eWxlIGRhxJ/EsXTEsWzEsXI6XG5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgPGxpPjEuICU1MCBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjIuICUyNSBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjMuICUxNSBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjQuICUxMCBwdWFuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgIMOWcm5lxJ9pbiAxMCBlbGxpayBiaXIgb3l1bmRhIG95dW5jdWxhcsSxbiBwdWFubGFyxLEgMTUwMCBvbHN1bi5cblxuICAgICAgICAgICAgTWFzYXlhIGthdMSxbGTEsWtsYXLEsW5kYSBwdWFubGFyxLEgMTQ5MCBvbHVyLiBPcnRhZGEgdG9wbGFtIDQwIHB1YW4gdmFyZMSxciwgdmUgxZ/DtnlsZSBkYcSfxLF0xLFsxLFyOlxuXG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgIDxsaT4xLiArMjAgPSAxNTEwPC9saT5cbiAgICAgICAgICAgICAgPGxpPjIuICsxMCA9IDE1MDA8L2xpPlxuICAgICAgICAgICAgICA8bGk+My4gKzYgPSAxNDk2PC9saT5cbiAgICAgICAgICAgICAgPGxpPjQuICs0ID0gMTQ5NDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuXG4gICAgICAgICAgICBNYXNhIGJpdG1lZGVuIGF5csSxbGFuIG95dW5jdSBwdWFuIGFsYW1hei5cblxuICAgICAgICAgICAgPGgyPiBLYXphbmFuIG5hc8SxbCBiZWxpcmxlbmlyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNhZGEgYsO8dMO8biBlbGxlciBveW5hbmTEsWt0YW4gc29ucmEgZW4gYXogY2V6YXPEsSBvbGFuIG95dW5jdSBnYWxpcCBpbGFuIGVkaWxpci5cblxuICAgICAgICAgICAgPGgyPiBNYXNhZGEgZXNsZXN0aXJtZSBuYXNpbCB5YXBpbGlyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNheWEgNCBveXVuY3Uga2F0aWxkaWdpbmRhIGVsIGJhc2xhci4gQmlyIGVsIGJpdHRpa3RlbiBzb25yYSB5ZW5pIGVsIGJhc2xhciwgeWVuaSBlbGUga2F0aWxtYWsgaWNpbiBveXVuY3VsYXIgbWFzYXlhIGdlcmkgZG9ubWVsaWRpci5cblxuICAgICAgICAgICAgPGgyPiBNYXNhIG5lIHphbWFuIGJpdGVyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNhZGEgZWwgc2F5xLFzxLEga2FkYXIgb3l1biBveW5hbmTEscSfxLFuZGEgbWFzYSBiaXRlci5cblxuICAgICAgICAgICAgPGgyPiBPeXVuZGFuIGF5csSxbG1hIDwvaDI+XG5cbiAgICAgICAgICAgIE95dW4gZGV2YW0gZWRlcmtlbiBveXVuZGFuIGF5cmlsYW4gb3l1bmN1IG1hc2FkYW4gYXRpbGlyLCB2ZSBvIGVsIGlwdGFsIG9sdXIuIE1hc2EgYml0bWVkZW4gbWFzYWRhbiBheXLEsWxhbiBveXVuY3UgcHVhbiBhbGFtYXouXG5cbiAgICAgICAgICAgIDxoMj4gRGnEn2VyIMO2bmVtbGkga3VyYWxsYXIgPC9oMj5cblxuICAgICAgICAgICAgU2lyYW5peiBnZWxkaWdpbmRlLCBveWFuYW1hIHPDvHJlbml6aSBhxZ9hcnNhbsSxeiBzaXN0ZW0gc2l6aW4geWVyaW5pemUgb3luYXIuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufTtcbiIsImltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgeyBzYWZlU3RyaW5nVG9OdW0gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCB7IGhlYWRlciB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuXG5pbXBvcnQgTWFzYXNMaXN0Q3RybCBmcm9tICcuL01hc2FzTGlzdEN0cmwnO1xuaW1wb3J0IHsgcmVuZGVyTWFzYXNMaXN0LCByZW5kZXJGb290ZXIgfSBmcm9tICcuL21hc2FzTGlzdFZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgb25jcmVhdGU6IGhlbHBlci52aWV3RmFkZUluLFxuXG4gIG9uaW5pdCh7IGF0dHJzIH0pIHtcbiAgICAvLyBzb2NrZXQuY3JlYXRlRGVmYXVsdCgpXG5cbiAgICB0aGlzLmN0cmwgPSBuZXcgTWFzYXNMaXN0Q3RybChzYWZlU3RyaW5nVG9OdW0oYXR0cnMudGFiKSk7XG4gIH0sXG5cbiAgdmlldygpIHtcbiAgICBjb25zdCBjdHJsID0gdGhpcy5jdHJsO1xuICAgIFxuICAgIGNvbnN0IGJvZHkgPSByZW5kZXJNYXNhc0xpc3QoY3RybCk7XG4gICAgY29uc3QgZm9vdGVyID0gcmVuZGVyRm9vdGVyKCk7XG4gICAgY29uc3Qgb3ZlcmxheSA9IG51bGw7XG4gICAgXG4gICAgcmV0dXJuIGxheW91dC5mcmVlKGhlYWRlcihpMThuKCdtYXNhcycpKSwgYm9keSwgZm9vdGVyLCBvdmVybGF5KTtcbiAgfVxuXG59O1xuIiwiaW1wb3J0IHsgZmV0Y2hKU09OIH0gZnJvbSAnLi4vLi4vaHR0cCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50TWFzYXMoKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9tYXNhJywge30sIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFzYShpZCkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvbWFzYS8nICsgaWQsIHsgcXVlcnk6IHsgc29ja2V0VmVyc2lvbjogMSB9fSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWxvYWQoaWQsIHBhZ2UpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL21hc2EvJyArIGlkLCB7IG1ldGhvZDogJ0dFVCcsIHF1ZXJ5OiBwYWdlID8geyBwYWdlIH06IHt9fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBqb2luKGlkKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9tYXNhLycrIGlkICsgJy9qb2luJywgeyBtZXRob2Q6ICdQT1NUJyB9LCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludml0ZShpZCkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvbWFzYS8nKyBpZCArICcvaW52aXRlJywgeyBtZXRob2Q6ICdQT1NUJyB9LCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhkcmF3KGlkKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9tYXNhLycrIGlkICsgJy93aXRoZHJhdycsIHsgbWV0aG9kOiAnUE9TVCcgfSwgdHJ1ZSk7XG59XG5cbi8vIGltcG9ydCB7IHJlcXVlc3QgfSBmcm9tICcuLi8uLi9odHRwJztcblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnRNYXNhcygpIHtcbi8vICAgcmV0dXJuIHJlcXVlc3QoJy9tYXNhJywge30sIHRydWUpO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gbWFzYShpZCkge1xuLy8gICByZXR1cm4gcmVxdWVzdCgnL21hc2EvJyArIGlkLCB7IGRhdGE6IHtzb2NrZXRWZXJzaW9uOiAxfX0sIHRydWUpO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gcmVsb2FkKGlkKSB7XG4vLyAgIHJldHVybiByZXF1ZXN0KCcvbWFzYS8nICsgaWQsXG4vLyAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuLy8gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuLy8gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHRydWVcbi8vICAgICAgICAgICAgICAgICAgfSk7XG4vLyB9XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBqb2luKGlkLCBzaWRlKSB7XG4vLyAgIHNpZGUgPSBzaWRlID8gYD9zaWRlPSR7c2lkZX1gOiAnJztcbi8vICAgcmV0dXJuIHJlcXVlc3QoJy9tYXNhLycgKyBpZCArICcvam9pbicgKyBzaWRlLCB7IG1ldGhvZDogJ1BPU1QnIH0sIHRydWUpO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gd2l0aGRyYXcoaWQpIHtcbi8vICAgcmV0dXJuIHJlcXVlc3QoJy9tYXNhLycgKyBpZCArICcvd2l0aGRyYXcnLCB7IG1ldGhvZDogJ1BPU1QnIH0sIHRydWUpO1xuLy8gfVxuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vcm91dGVyJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBUYWJOYXZpZ2F0aW9uIGZyb20gJy4uL3NoYXJlZC9UYWJOYXZpZ2F0aW9uJztcbmltcG9ydCBUYWJWaWV3IGZyb20gJy4uL3NoYXJlZC9UYWJWaWV3JztcblxuY29uc3QgVEFCUyA9IFt7XG4gIGxhYmVsOiAnQcOnxLFrJ1xufSwge1xuICBsYWJlbDogJ095bmFuYW4nXG59LCB7XG4gIGxhYmVsOiAnQml0ZW4nXG59ICBcbl07XG5cbmZ1bmN0aW9uIG9uTWFzYVRhcChlKSB7XG4gIGNvbnN0IGVsID0gaGVscGVyLmdldExJKGUpO1xuICBjb25zdCBkcyA9IGVsLmRhdGFzZXQ7XG4gIGlmIChlbCAmJiBkcy5pZCkge1xuICAgIHJvdXRlci5zZXQoJy9tYXNhLycgKyBkcy5pZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1hc2FzTGlzdChjdHJsKSB7XG4gIGlmICghY3RybC5tYXNhcykgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgdGFic0NvbnRlbnQgPSBbXG4gICAgY3RybC5tYXNhc1snY3JlYXRlZCddLFxuICAgIGN0cmwubWFzYXNbJ3N0YXJ0ZWQnXSxcbiAgICBjdHJsLm1hc2FzWydmaW5pc2hlZCddLFxuICBdO1xuXG4gIHJldHVybiBbXG4gICAgaCgnZGl2LnRhYnMtbmF2LWhlYWRlci5zdWJIZWFkZXInLFxuICAgICAgaChUYWJOYXZpZ2F0aW9uLCB7XG4gICAgICAgIGJ1dHRvbnM6IFRBQlMsXG4gICAgICAgIHNlbGVjdGVkSW5kZXg6IGN0cmwuY3VycmVudFRhYixcbiAgICAgICAgb25UYWJDaGFuZ2U6IGN0cmwub25UYWJDaGFuZ2VcbiAgICAgIH0pLFxuICAgICAgaCgnZGl2Lm1haW5faGVhZGVyX2Ryb3Bfc2hhZG93JylcbiAgICAgKSxcbiAgICBoKFRhYlZpZXcsIHtcbiAgICAgIGNsYXNzTmFtZTogJ21hc2FUYWJzV3JhcHBlcicsXG4gICAgICBzZWxlY3RlZEluZGV4OiBjdHJsLmN1cnJlbnRUYWIsXG4gICAgICBjb250ZW50OiB0YWJzQ29udGVudCxcbiAgICAgIHJlbmRlcmVyOiByZW5kZXJNYXNhTGlzdCxcbiAgICAgIG9uVGFiQ2hhbmdlOiBjdHJsLm9uVGFiQ2hhbmdlXG4gICAgfSlcbiAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1hc2FMaXN0KGxpc3QpIHtcbiAgcmV0dXJuIGgoJ3VsLm5hdGl2ZV9zY3JvbGxlci5tYXNhTGlzdCcsIHtcbiAgICBvbmNyZWF0ZTogaGVscGVyLm9udGFwWFkob25NYXNhVGFwLCB1bmRlZmluZWQsIGhlbHBlci5nZXRMSSlcbiAgfSwgbGlzdC5tYXAocmVuZGVyTWFzYUxpc3RJdGVtKSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1hc2FMaXN0SXRlbShtYXNhLCBpbmRleCkge1xuICBjb25zdCBtb2RlID0gbWFzYS5yYXRlZCA/IGkxOG4oJ3JhdGVkJykgOiBpMThuKCdjYXN1YWwnKTtcbiAgY29uc3QgdmFyaWFudCA9IGNhcGl0YWxpemUobWFzYS52YXJpYW50LnNob3J0KTtcbiAgY29uc3QgZXZlbk9yT2RkID0gaW5kZXggJSAyID09PSAwID8gJyBldmVuICcgOiAnIG9kZCAnO1xuICBjb25zdCBzY29yZXMgPSBtYXNhLnNjb3JlcztcbiAgY29uc3Qgcm91bmRzID0gbWFzYS5yb3VuZHM7XG4gIFxuICByZXR1cm4gKFxuICAgICAgPGxpIGtleT17bWFzYS5pZH1cbiAgICAgICAgICBjbGFzc05hbWU9eydsaXN0X2l0ZW0gbWFzYV9pdGVtJyArIGV2ZW5Pck9kZH1cbiAgICAgICAgICBkYXRhLWlkPXttYXNhLmlkfVxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2FMaXN0TmFtZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZnVsbE5hbWVcIj57bWFzYS5mdWxsTmFtZX08L2Rpdj5cbiAgICAgIDxzbWFsbCBjbGFzc05hbWU9XCJpbmZvc1wiPnt2YXJpYW50fSB7bW9kZX0g4oCiIHtzY29yZXM/c2NvcmVzICsgJyAnICsgaTE4bigncG9pbnRzJyk6aTE4bigncm91bmRzJywgcm91bmRzKX08L3NtYWxsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhTGlzdFRpbWVcIj5cbiAgICAgICAgICA8c21hbGwgY2xhc3NOYW1lPVwibmJVc2VycyB3aXRoSWNvblwiIGRhdGEtaWNvbj1cInJcIj57bWFzYS5uYlBsYXllcnN9PC9zbWFsbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2xpPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRm9vdGVyKCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uc19iYXJcIj5cbiAgICAgIDxidXR0b24ga2V5PVwiY3JlYXRlTWFzYVwiIGNsYXNzTmFtZT1cImFjdGlvbl9jcmVhdGVfYnV0dG9uXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXBsdXMtY2lyY2xlXCIvPlxuICAgICAgICB7aTE4bignY3JlYXRlQU5ld01hc2EnKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IHN0cmVhbSBmcm9tICdtaXRocmlsL3N0cmVhbSc7XG5pbXBvcnQgWmFuaW1vIGZyb20gJ3phbmltbyc7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi8uLi9iYWNrYnV0dG9uJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vcm91dGVyJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IFNpZGVNZW51Q3RybCBmcm9tICcuLi9zaGFyZWQvc2lkZU1lbnUvU2lkZU1lbnVDdHJsJztcbmltcG9ydCB7IG9udGFwIH0gZnJvbSAnLi4vaGVscGVyJztcblxuXG5leHBvcnQgY29uc3QgcHJvZmlsZU1lbnVPcGVuID0gc3RyZWFtKGZhbHNlKTtcblxuZnVuY3Rpb24gb25NZW51T3BlbigpIHtcbn1cblxuZnVuY3Rpb24gb25NZW51Q2xvc2UoKSB7XG59XG5cblxuZXhwb3J0IGNvbnN0IG1haW5NZW51Q3RybCA9IG5ldyBTaWRlTWVudUN0cmwoXG4gICdsZWZ0JyxcbiAgJ3NpZGVfbWVudScsXG4gICdtZW51LWNsb3NlLW92ZXJsYXknLFxuICBvbk1lbnVPcGVuLFxuICBvbk1lbnVDbG9zZVxuKTtcblxuXG5leHBvcnQgZnVuY3Rpb24gcm91dGUocm91dGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtYWluTWVudUN0cmwuY2xvc2UoKS50aGVuKCgpID0+IHJvdXRlci5zZXQocm91dGUpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVwKGFjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1haW5NZW51Q3RybC5jbG9zZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgYWN0aW9uKCk7XG4gICAgICByZWRyYXcoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGJhY2tkcm9wQ2xvc2VIYW5kbGVyID0gb250YXAoKCkgPT4ge1xuICBtYWluTWVudUN0cmwuY2xvc2UoKTtcbn0pO1xuXG5jb25zdCBtZW51ID0ge307XG5cbi8qIHByb3BlcnRpZXMgKi9cbm1lbnUuaXNPcGVuID0gZmFsc2U7XG4vLyBtZW51LmhlYWRlck9wZW4gPSBtLnByb3AoZmFsc2UpO1xuXG5tZW51LnJvdXRlID0gZnVuY3Rpb24ocm91dGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtZW51LmNsb3NlKCkudGhlbihtLnJvdXRlLmJpbmQobnVsbCwgcm91dGUpKTtcbiAgfTtcbn07XG5cbm1lbnUucG9wdXAgPSBmdW5jdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtZW51LmNsb3NlKCkudGhlbigoKSA9PiB7XG4gICAgICBhY3Rpb24oKTtcbiAgICAgIG0ucmVkcmF3KCk7XG4gICAgfSk7XG4gIH07XG59O1xuXG5tZW51LnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAobWVudS5pc09wZW4pIG1lbnUuY2xvc2UoKTtcbiAgZWxzZSBtZW51Lm9wZW4oKTtcbn07XG5cbm1lbnUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICBiYWNrYnV0dG9uLnN0YWNrLnB1c2gobWVudS5jbG9zZSk7XG4gIG1lbnUuaXNPcGVuID0gdHJ1ZTtcbn07XG5cbm1lbnUud2lsbENsb3NlID0gZmFsc2U7XG5tZW51LmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4gIGNvbnN0IHNpZGVNZW51ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpZGVfbWVudScpO1xuXG4gIGlmIChtZW51LndpbGxDbG9zZSB8fCAhc2lkZU1lbnUpIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG5cbiAgbWVudS53aWxsQ2xvc2UgPSB0cnVlO1xuICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgbWVudS5pc09wZW4pIGJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4gIG0ucmVkcmF3LnN0cmF0ZWd5KCdub25lJyk7XG4gIHJldHVybiBaYW5pbW8oXG4gICAgc2lkZU1lbnUsXG4gICAgJ3RyYW5zZm9ybScsXG4gICAgJ3RyYW5zbGF0ZTNkKC0xMDAlLDAsMCcsIDI1MCwgJ2Vhc2Utb3V0J1xuICApLnRoZW4oKCkgPT4ge1xuICAgIG1lbnUuaGVhZGVyT3BlbihmYWxzZSk7XG4gICAgbWVudS5pc09wZW4gPSBmYWxzZTtcbiAgICBtZW51LndpbGxDbG9zZSA9IGZhbHNlO1xuICAgIG0ucmVkcmF3KCk7XG4gIH0pXG4gICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIG1lbnUuaGVhZGVyT3BlbihmYWxzZSk7XG4gICAgICBtZW51LmlzT3BlbiA9IGZhbHNlO1xuICAgICAgbWVudS53aWxsQ2xvc2UgPSBmYWxzZTtcbiAgICAgIG0ucmVkcmF3KCk7XG4gICAgfSk7XG59O1xuXG5tZW51LnRvZ2dsZUhlYWRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbWVudS5oZWFkZXJPcGVuKCkgPyBtZW51LmhlYWRlck9wZW4oZmFsc2UpIDogbWVudS5oZWFkZXJPcGVuKHRydWUpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWVudTtcbiIsImltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgbG9naW5Nb2RhbCBmcm9tICcuLi9sb2dpbk1vZGFsJztcbmltcG9ydCBuZXdHYW1lRm9ybSBmcm9tICcuLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgeyBoYXNOZXR3b3JrLCBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgWmFuaW1vIGZyb20gJ3phbmltbyc7XG5pbXBvcnQgKiBhcyBtZW51IGZyb20gJy4nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uYmVmb3JldXBkYXRlKCkge1xuICAgIHJldHVybiBtZW51Lm1haW5NZW51Q3RybC5pc09wZW47XG4gIH0sXG5cbiAgdmlldygpIHtcbiAgICBjb25zdCB1c2VyID0gc2Vzc2lvbi5nZXQoKTtcbiAgICBcbiAgICByZXR1cm4gKFxuICAgICAgPGFzaWRlIGlkPVwic2lkZV9tZW51XCI+XG4gICAgICAgIHtyZW5kZXJIZWFkZXIodXNlcil9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibmF0aXZlX3Njcm9sbGVyIHNpZGVfbWVudV9zY3JvbGxlclwiPlxuICAgICAgICAgIHt1c2VyICYmIG1lbnUucHJvZmlsZU1lbnVPcGVuKCkgPyByZW5kZXJQcm9maWxlQWN0aW9ucyh1c2VyKSA6IHJlbmRlckxpbmtzKHVzZXIpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvYXNpZGU+XG5cbiAgICApO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZW5kZXJIZWFkZXIodXNlcikge1xuICBjb25zdCBwcm9maWxlTGluayA9IHVzZXIgPyBtZW51LnJvdXRlKCcvQC8nICsgdXNlci5pZCkgOiBub29wO1xuXG4gIHJldHVybiAoXG4gICAgPGhlYWRlciBjbGFzc05hbWU9XCJzaWRlX21lbnVfaGVhZGVyXCI+XG4gICAgICB7IGhhc05ldHdvcmsoKSAmJiAhdXNlciA/XG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwic2lnbkluQnV0dG9uXCIgb25jcmVhdGU9e2hlbHBlci5vbnRhcFhZKGxvZ2luTW9kYWwub3Blbil9PlxuICAgICAgICAgIHtpMThuKCdzaWduSW4nKX1cbiAgICAgICAgPC9idXR0b24+IDogbnVsbFxuICAgICAgfVxuICAgICAgeyB1c2VyID9cbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cInVzZXJuYW1lXCIgb25jcmVhdGU9e2hlbHBlci5vbnRhcFhZKHByb2ZpbGVMaW5rKX0+XG4gICAgICAgICAge3VzZXIudXNlcm5hbWV9XG4gICAgICAgIDwvaDI+IDogbnVsbFxuICAgICAgfVxuICAgIDwvaGVhZGVyPlxuICApO1xufVxuXG5cbmZ1bmN0aW9uIHNsaWRlc0luVXAoZWwsIGlzVXBkYXRlLCBjb250ZXh0KSB7XG4gIGlmICghaXNVcGRhdGUpIHtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJztcbiAgICAvLyBmb3JjZSByZWZsb3cgYmFja1xuICAgIGNvbnRleHQubG9sID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknLCAyNTAsICdlYXNlLW91dCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckxpbmtzKHVzZXIpIHtcblxuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzc05hbWU9XCJzaWRlX2xpbmtzXCJcbiAgICAgIG9uY3JlYXRlPXtoZWxwZXIub250YXBYWShvbkxpbmtUYXAsIHVuZGVmaW5lZCwgaGVscGVyLmdldExJKX0+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgZGF0YS1yb3V0ZT1cIi9cIj5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtaG9tZVwiIC8+e2kxOG4oJ2hvbWUnKX1cbiAgICAgIDwvbGk+XG4gICAgICB7aGFzTmV0d29yaygpID8gXG4gICAgICAgIDxsaSBjbGFzc05hbWU9XCJzZXBfbGlua1wiIGtleT1cInNlcF9saW5rX29ubGluZVwiPntpMThuKCdwbGF5T25saW5lJyl9PC9saT4gOiBudWxsIFxuICAgICAgfVxuICAgICAge2hhc05ldHdvcmsoKSA/XG4gICAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBkYXRhLXBvcHVwPVwiY3JlYXRlQUdhbWVcIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXBsdXMtY2lyY2xlXCIvPntpMThuKCdjcmVhdGVBR2FtZScpfVxuICAgICAgICA8L2xpPiA6IG51bGwgfVxuICAgICAge2hhc05ldHdvcmsoKSA/IDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBkYXRhLXJvdXRlPVwiL21hc2FzXCI+XG4gICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS10cm9waHlcIi8+e2kxOG4oJ21hc2FzJyl9XG4gICAgICAgPC9saT4gOiBudWxsIH1cbiAgICAgIHtoYXNOZXR3b3JrKCkgPyA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgZGF0YS1yb3V0ZT1cIi9wbGF5ZXJzXCI+XG4gICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1hdFwiLz57aTE4bigncGxheWVycycpfVxuICAgICAgIDwvbGk+IDogbnVsbCB9XG4gICAgICB7aGFzTmV0d29yaygpID8gPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGRhdGEtcm91dGU9XCIvcmFua2luZ1wiPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1jdWJlc1wiLz57aTE4bignbGVhZGVyYm9hcmQnKX1cbiAgICAgICA8L2xpPiA6IG51bGwgfVxuICAgICAgIDxsaSBjbGFzc05hbWU9XCJoclwiPjwvbGk+XG4gICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGRhdGEtcm91dGU9XCIvc2V0dGluZ3NcIj5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtY29nXCIvPntpMThuKCdzZXR0aW5ncycpfVxuICAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUHJvZmlsZUFjdGlvbnModXNlcikge1xuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzc05hbWU9XCJzaWRlX2xpbmtzIHByb2ZpbGVBY3Rpb25zXCI+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250b3VjaChtZW51LnJvdXRlKCcvQC8nICsgdXNlci5pZCkpfT5cbiAgICAgICAgPHNwYW4gZGF0YS1pY29uPVwiclwiIC8+XG4gICAgICAgIHtpMThuKCdwcm9maWxlJyl9XG4gICAgICA8L2xpPlxuICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGNvbmZpZz17aGVscGVyLm9udG91Y2gobWVudS5yb3V0ZSgnL3NldHRpbmdzL3ByZWZlcmVuY2VzJykpfT5cbiAgICAgICAgPHNwYW4gZGF0YS1pY29uPVwiJVwiIC8+XG4gICAgICAgIHtpMThuKCdwcmVmZXJlbmNlcycpfVxuICAgICAgPC9saT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRvdWNoKCgpID0+IHtcbiAgICAgICAgc2Vzc2lvbi5sb2dvdXQoKTtcbiAgICAgICAgbWVudS5oZWFkZXJPcGVuKGZhbHNlKTtcbiAgICAgIH0pfT5cbiAgICAgICAgPHNwYW4gZGF0YS1pY29uPVwid1wiIC8+XG4gICAgICAgIHtpMThuKCdsb2dPdXQnKX1cbiAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgKTtcbn1cblxuY29uc3QgcG9wdXBBY3Rpb25NYXAgPSB7XG4gICdjcmVhdGVBR2FtZSc6ICgpID0+IG5ld0dhbWVGb3JtLm9wZW5SZWFsdGltZSgpXG59O1xuXG5mdW5jdGlvbiBvbkxpbmtUYXAoZSkge1xuICBjb25zdCBlbCA9IGhlbHBlci5nZXRMSShlKTtcbiAgY29uc3QgZHMgPSBlbC5kYXRhc2V0O1xuICBpZiAoZWwgJiYgZHMucm91dGUpIHtcbiAgICBtZW51LnJvdXRlKGRzLnJvdXRlKSgpO1xuICB9IGVsc2UgaWYgKGVsICYmIGRzLnBvcHVwKSB7XG4gICAgbWVudS5wb3B1cChwb3B1cEFjdGlvbk1hcFtkcy5wb3B1cF0pKCk7XG4gIH1cbn1cblxuXG4vLyBPTERcblxuZnVuY3Rpb24gcmVuZGVyUHJvZmlsZUFjdGlvbnNPTEQodXNlcikge1xuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzc05hbWU9XCJzaWRlX2xpbmtzIHByb2ZpbGVBY3Rpb25zXCI+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250YXBYWShtZW51LnJvdXRlKCcvQC8nICsgdXNlci5pZCkpfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtdXNlclwiLz57aTE4bigncHJvZmlsZScpfVxuICAgIDwvbGk+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250YXBYWShtZW51LnJvdXRlKCcvc2V0dGluZ3MvcHJlZmVyZW5jZXMnKSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCIlXCIgLz57aTE4bigncHJlZmVyZW5jZXMnKX1cbiAgICAgIDwvbGk+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250YXBYWSgoKSA9PiB7XG4gICAgICAgIHNlc3Npb24ubG9nb3V0KCk7XG4gICAgICAgIG1lbnUucHJvZmlsZU1lbnVPcGVuKGZhbHNlKTtcbiAgICAgIH0pfT5cbiAgICAgICAgPHNwYW4gZGF0YS1pY29uPVwid1wiIC8+XG4gICAgICAgIHtpMThuKCdsb2dPdXQnKX1cbiAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVudSgpIHtcbiAgY29uc3QgdXNlciA9IHNlc3Npb24uZ2V0KCk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJuYXRpdmVfc2Nyb2xsZXJcIj5cbiAgICAgIHtyZW5kZXJIZWFkZXIodXNlcil9XG4gICAgICB7IHVzZXIgJiYgbWVudS5oZWFkZXJPcGVuKCkgPyByZW5kZXJQcm9maWxlQWN0aW9ucyh1c2VyKSA6IHJlbmRlckxpbmtzKHVzZXIpIH1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IGh1bWFuU2V0dXBGcm9tU2V0dGluZ3MgfSBmcm9tICcuLi9veXVua2V5Zi9zZXR1cCc7XG5pbXBvcnQgcG9wdXBXaWRnZXQgZnJvbSAnLi9zaGFyZWQvcG9wdXAnO1xuaW1wb3J0IGZvcm1XaWRnZXRzIGZyb20gJy4vc2hhcmVkL2Zvcm0nO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MnO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vc2Vzc2lvbic7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi9iYWNrYnV0dG9uJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuLi94aHInO1xuaW1wb3J0IGxvYmJ5IGZyb20gJy4vbG9iYnknO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmxldCBpc09wZW4gPSBmYWxzZTtcblxuY29uc3QgaHVtYW5TZXR1cCA9IHNldHRpbmdzLmdhbWVTZXR1cC5odW1hbjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvcGVuLFxuICBjbG9zZSxcbiAgb3BlblJlYWx0aW1lKCkge1xuICAgIG9wZW4oKTtcbiAgfSxcbiAgdmlldygpIHtcbiAgICByZXR1cm4gcG9wdXBXaWRnZXQoXG4gICAgICAnbmV3X2dhbWVfZm9ybV9wb3B1cCBnYW1lX2Zvcm1fcG9wdXAnLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyQ29udGVudCxcbiAgICAgIGlzT3BlbixcbiAgICAgIGNsb3NlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb3BlbigpIHtcbiAgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaChjbG9zZSk7XG4gIGlzT3BlbiA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsb3NlKGZyb21CQikge1xuICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgaXNPcGVuKSByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgaXNPcGVuID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gIGNvbnN0IGNvbmYgPSBodW1hblNldHVwO1xuXG4gIHJldHVybiBoKCdkaXYnLCBbXG4gICAgaCgnZGl2Lm5ld0dhbWUtcHJlc2V0X3N3aXRjaCcsIFtcbiAgICAgIHJlbmRlckN1c3RvbVNldHVwKFxuICAgICAgICAnaHVtYW4nLFxuICAgICAgICBjb25mLFxuICAgICAgICBjb25mLmF2YWlsYWJsZVZhcmlhbnRzXG4gICAgICApXG4gICAgXSlcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckN1c3RvbVNldHVwKGZvcm1OYW1lLCBzZXR0aW5nc09iaiwgdmFyaWFudHMpIHtcbiAgY29uc3QgZ2VuZXJhbEZpZWxkc2V0ID0gW1xuICAgIGgoJ2Rpdi5zZWxlY3RfaW5wdXQnLCB7XG4gICAgICBrZXk6IGZvcm1OYW1lICsgJ3ZhcmlhbnQnXG4gICAgfSwgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCd2YXJpYW50JywgZm9ybU5hbWUgKyAndmFyaWFudCcsIHZhcmlhbnRzLCBzZXR0aW5nc09iai52YXJpYW50KVxuICAgICApXG4gIF07XG5cbiAgY29uc3QgbW9kZXMgPSBbXG4gICAgWydjYXN1YWwnLCAnMCddLFxuICAgIFsncmF0ZWQnLCAnMSddXG4gIF07XG5cbiAgZ2VuZXJhbEZpZWxkc2V0LnB1c2goaCgnZGl2LnNlbGVjdF9pbnB1dCcsIHtcbiAgICBrZXk6IGZvcm1OYW1lICsgJ21vZGUnXG4gIH0sIGZvcm1XaWRnZXRzLnJlbmRlclNlbGVjdCgnbW9kZScsIGZvcm1OYW1lICsgJ21vZGUnLCBtb2Rlcywgc2V0dGluZ3NPYmoubW9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuXG4gIGNvbnN0IHRpbWVGaWVsZHNldCA9IFtdO1xuXG4gIHRpbWVGaWVsZHNldC5wdXNoKFxuICAgIGgoJ2Rpdi5zZWxlY3RfaW5wdXQuaW5saW5lJywge1xuICAgICAga2V5OiBmb3JtTmFtZSArICdyb3VuZCdcbiAgICB9LFxuICAgICAgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCdyb3VuZHMnLCBmb3JtTmFtZSArICdyb3VuZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmdhbWVTZXR1cC5hdmFpbGFibGVSb3VuZHMsIHNldHRpbmdzT2JqLnJvdW5kcywgZmFsc2UpXG4gICAgIClcbiAgKTtcblxuICByZXR1cm4gaCgnZm9ybS5nYW1lX2Zvcm0nLCB7XG4gICAga2V5OiAnY3VzdG9tU2V0dXAnLFxuICAgIG9uc3VibWl0KGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgICBnb1NlZWsoaHVtYW5TZXR1cEZyb21TZXR0aW5ncyhzZXR0aW5nc09iaikpO1xuICAgIH1cbiAgfSwgW1xuICAgIGgoJ2ZpZWxkc2V0JywgZ2VuZXJhbEZpZWxkc2V0KSxcbiAgICBoKCdmaWVsZHNldCcsIHRpbWVGaWVsZHNldCksXG4gICAgaCgnZGl2LnBvcHVwQWN0aW9uV3JhcHBlcicsIFtcbiAgICAgIGgoJ2J1dHRvbltkYXRhLWljb249RV1bdHlwZT1zdWJtaXRdLnBvcHVwQWN0aW9uJywgaTE4bignY3JlYXRlQUdhbWUnKSlcbiAgICBdKVxuICBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclF1aWNrU2V0dXAob25DdXN0b20pIHtcbiAgcmV0dXJuIGgoJ2Rpdi5uZXdHYW1lLXBvb2xzJywgeyBrZXk6ICdxdWlja1NldHVwJyB9LFxuICAgICAgICAgICBoKCdkaXYubmV3R2FtZS1wb29sJywge1xuICAgICAgICAgICAgIGtleTogJ3Bvb2wtY3VzdG9tJyxcbiAgICAgICAgICAgICBvbmNyZWF0ZTogaGVscGVyLm9udGFwKG9uQ3VzdG9tKVxuICAgICAgICAgICB9LCBoKCdkaXYubmV3R2FtZS1jdXN0b20nLCAnw5Z6ZWwnKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIGdvU2Vlayhjb25mKSB7XG4gIGNsb3NlKCk7XG5cbiAgbG9iYnkuc3RhcnRTZWVraW5nKGNvbmYpO1xufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gcmVuZGVyUXVpY2tTZXR1cCgpIHtcbi8vICAgcmV0dXJuIGgoJ2Rpdi5uZXdHYW1lLXBvb2xzJywgeyBrZXk6ICdxdWlja1NldHVwJyB9LFxuLy8gICAgICAgICAgICB4aHIuY2FjaGVkUG9vbHMubWFwKHAgPT4gcmVuZGVyUG9vbChwKSlcbi8vICAgICAgICAgICApO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiByZW5kZXJQb29sKHApIHtcbi8vICAgcmV0dXJuIGgoJ2Rpdi5uZXdHYW1lLXBvb2wnLCB7XG4vLyAgICAga2V5OiAncG9vbC0nICsgcC5pZCxcbi8vICAgICBvbmNyZWF0ZTogaGVscGVyLm9udGFwKCgpID0+IHtcbi8vICAgICAgIGNvbnNvbGUubG9nKCdvbmNyZWF0ZScpO1xuLy8gICAgIH0pXG4vLyAgIH0sIFtoKCdkaXYubmV3R2FtZS1yb3VuZHMnLCBwLmlkKSxcbi8vICAgICAgIGgoJ2Rpdi5uZXdHYW1lLXBlcmYnLCBwLnBlcmYpXG4vLyAgICAgIF0pO1xuLy8gfVxuXG4vLyBjb25zdCBuZXdHYW1lRm9ybSA9IHt9O1xuXG4vLyBuZXdHYW1lRm9ybS5pc09wZW4gPSBmYWxzZTtcblxuLy8gbmV3R2FtZUZvcm0ub3BlbiA9IGZ1bmN0aW9uKCkge1xuLy8gICBiYWNrYnV0dG9uLnN0YWNrLnB1c2gobmV3R2FtZUZvcm0uY2xvc2UpO1xuLy8gICBuZXdHYW1lRm9ybS5pc09wZW4gPSB0cnVlO1xuLy8gfTtcblxuLy8gbmV3R2FtZUZvcm0uY2xvc2UgPSBmdW5jdGlvbihmcm9tQkIpIHtcbi8vICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIG5ld0dhbWVGb3JtLmlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbi8vICAgbmV3R2FtZUZvcm0uaXNPcGVuID0gZmFsc2U7XG4vLyB9O1xuXG4vLyBuZXdHYW1lRm9ybS5vcGVuUmVhbHRpbWUgPSBmdW5jdGlvbigpIHtcbi8vICAgbmV3R2FtZUZvcm0ub3BlbigpO1xuLy8gfTtcblxuLy8gZnVuY3Rpb24gc2Vla0h1bWFuR2FtZSgpIHtcbi8vICAgbmV3R2FtZUZvcm0uY2xvc2UoKTtcbi8vICAgbG9iYnkuc3RhcnRTZWVraW5nKCk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIHJlbmRlckZvcm0oZm9ybU5hbWUsIGFjdGlvbiwgc2V0dGluZ3NPYmosIHZhcmlhbnRzKSB7XG4vLyAgIHZhciBnZW5lcmFsRmllbGRzZXQgPSBbXG4vLyAgICAgbSgnZGl2LnNlbGVjdF9pbnB1dCcsIHtcbi8vICAgICAgIGtleTogZm9ybU5hbWUgKyAndmFyaWFudCdcbi8vICAgICB9LCBbXG4vLyAgICAgICBmb3JtV2lkZ2V0cy5yZW5kZXJTZWxlY3QoJ3ZhcmlhbnQnLCBmb3JtTmFtZSArICcgdmFyaWFudCcsIHZhcmlhbnRzLCBzZXR0aW5nc09iai52YXJpYW50KVxuLy8gICAgIF0pXG4vLyAgIF07XG4gIFxuXG4vLyAgIC8vIEh1bWFuIG9ubHlcbi8vICAgaWYgKHNldHRpbmdzT2JqLm1vZGUpIHtcbi8vICAgICB2YXIgbW9kZXMgPSAoc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpKSA/IFtcbi8vICAgICAgIFsnY2FzdWFsJywgJzAnXSxcbi8vICAgICAgIFsncmF0ZWQnLCAnMSddXG4vLyAgICAgXSA6IFsgWydjYXN1YWwnLCAnMCddIF07XG5cbi8vICAgICBnZW5lcmFsRmllbGRzZXQucHVzaChtKCdkaXYuc2VsZWN0X2lucHV0Jywge1xuLy8gICAgICAga2V5OiBmb3JtTmFtZSArICdtb2RlJ1xuLy8gICAgIH0sIFtcbi8vICAgICAgIGZvcm1XaWRnZXRzLnJlbmRlclNlbGVjdCgnbW9kZScsIGZvcm1OYW1lICsgJ21vZGUnLCBtb2Rlcywgc2V0dGluZ3NPYmoubW9kZSlcbi8vICAgICBdKSk7XG5cbi8vICAgICBpZiAoc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpICYmIHNldHRpbmdzT2JqLm1vZGUoKSA9PT0gJzAnKSB7XG4vLyAgICAgICBnZW5lcmFsRmllbGRzZXQucHVzaChcbi8vICAgICAgICAgZm9ybVdpZGdldHMucmVuZGVyQ2hlY2tib3goaTE4bignbWVtYmVyc09ubHknKSwgJ21lbWJlcnNPbmx5Jywgc2V0dGluZ3NPYmoubWVtYmVyc09ubHkpKTtcbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyBib3RoIGh1bWFuXG4vLyAgIHZhciByb3VuZEZpZWxkc2V0ID0gW1xuLy8gICAgIC8vIG0oJ2Rpdi5zZWxlY3RfaW5wdXQnLCB7XG4vLyAgICAgLy8gICBrZXk6IGZvcm1OYW1lICsgJ3JvdW5kcydcbi8vICAgICAvLyB9LCBbXG4vLyAgICAgLy8gICBmb3JtV2lkZ2V0cy5yZW5kZXJTZWxlY3QoJ3JvdW5kJywgZm9ybU5hbWUgKyAncm91bmRzJywgcm91bmRNb2Rlcywgc2V0dGluZ3NPYmoucm91bmRNb2RlKVxuLy8gICAgIC8vIF0pXG4vLyAgIF07XG5cbi8vICAgaWYgKHRydWUpIHtcbi8vICAgICByb3VuZEZpZWxkc2V0LnB1c2goXG4vLyAgICAgICBtKCdkaXYuc2VsZWN0X2lucHV0Jywge1xuLy8gICAgICAgICBrZXk6IGZvcm1OYW1lICsgJ3JvdW5kcydcbi8vICAgICAgIH0sIFtcbi8vICAgICAgICAgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCdyb3VuZHMnLCBmb3JtTmFtZSArICdyb3VuZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5nYW1lU2V0dXAuYXZhaWxhYmxlUm91bmRzLCBzZXR0aW5nc09iai5yb3VuZHMsIGZhbHNlKVxuLy8gICAgICAgXSlcbi8vICAgICApO1xuLy8gICB9XG5cbi8vICAgcmV0dXJuIG0oJ2Zvcm0jbmV3X2dhbWVfZm9ybS5nYW1lX2Zvcm0nLCB7XG4vLyAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbi8vICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbi8vICAgICAgIGlmICghc2V0dGluZ3MuZ2FtZVNldHVwLmlzUm91bmRWYWxpZChzZXR0aW5nc09iaikpIHJldHVybjtcbi8vICAgICAgIG5ld0dhbWVGb3JtLmNsb3NlKCk7XG4vLyAgICAgICBhY3Rpb24oKTtcbi8vICAgICB9XG4vLyAgIH0sIFtcbi8vICAgICBtKCdmaWVsZHNldCcsIFtcbi8vICAgICBdKSxcbi8vICAgICBtKCdmaWVsZHNldCcsIGdlbmVyYWxGaWVsZHNldCksXG4vLyAgICAgbSgnZmllbGRzZXQjcm91bmQnLCByb3VuZEZpZWxkc2V0KSxcbi8vICAgICBtKCdidXR0b25bZGF0YS1pY29uPUVdW3R5cGU9c3VibWl0XS5uZXdHYW1lQnV0dG9uJywgaTE4bignY3JlYXRlQUdhbWUnKSlcbi8vICAgXSk7XG4vLyB9XG5cbi8vIG5ld0dhbWVGb3JtLnZpZXcgPSBmdW5jdGlvbigpIHtcbi8vICAgZnVuY3Rpb24gZm9ybSgpIHtcbi8vICAgICByZXR1cm4gcmVuZGVyRm9ybShcbi8vICAgICAgICdodW1hbicsXG4vLyAgICAgICBzZWVrSHVtYW5HYW1lLFxuLy8gICAgICAgc2V0dGluZ3MuZ2FtZVNldHVwLmh1bWFuLFxuLy8gICAgICAgc2V0dGluZ3MuZ2FtZVNldHVwLmh1bWFuLmF2YWlsYWJsZVZhcmlhbnRzKTtcbi8vIH07XG5cbi8vICAgcmV0dXJuIHBvcHVwV2lkZ2V0KFxuLy8gICAgICduZXdfZ2FtZV9mb3JtX3BvcHVwIGdhbWVfZm9ybV9wb3B1cCcsXG4vLyAgICAgbnVsbCxcbi8vICAgICBmb3JtLFxuLy8gICAgIG5ld0dhbWVGb3JtLmlzT3Blbixcbi8vICAgICBuZXdHYW1lRm9ybS5jbG9zZVxuLy8gICApO1xuLy8gfTtcblxuLy8gZXhwb3J0IGRlZmF1bHQgbmV3R2FtZUZvcm07XG4iLCJpbXBvcnQgY29udHJvbGxlciBmcm9tICcuL3BsYXllcnNDdHJsJztcbmltcG9ydCB2aWV3IGZyb20gJy4vcGxheWVyc1ZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXIsXG4gIHZpZXdcbn07XG4iLCJpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi4vLi4vaHR0cCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBvbmxpbmVQbGF5ZXJzKCkge1xuICByZXR1cm4gcmVxdWVzdCgnL3BsYXllci9vbmxpbmUnLCB7fSwgdHJ1ZSk7XG59XG4iLCJpbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi9wbGF5ZXJYaHInO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRyb2xsZXIoKSB7XG4gIHNvY2tldC5jcmVhdGVEZWZhdWx0KCk7XG5cbiAgY29uc3QgcGxheWVycyA9IG0ucHJvcChbXSk7XG5cbiAgeGhyLm9ubGluZVBsYXllcnMoKS50aGVuKHBsYXllcnMsIGVyciA9PiB1dGlscy5oYW5kbGVYaHJFcnJvcihlcnIpKTtcblxuICByZXR1cm4ge1xuICAgIHBsYXllcnMsXG4gICAgZ29Ub1Byb2ZpbGUodSkge1xuICAgICAgbS5yb3V0ZSgnL0AvJyArIHUpO1xuICAgIH0sXG4gICAgb251bmxvYWQ6ICgpID0+IHtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoIGZyb20gJy4uL2hlbHBlcidcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCB7IG1lbnVCdXR0b24sIHVzZXJTdGF0dXMgfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlldyhjdHJsKSB7XG5cbiAgY29uc3QgaGVhZGVyQ3RybCA9IGhlYWRlci5iaW5kKG51bGwsIGN0cmwpO1xuICBjb25zdCBib2R5Q3RybCA9IGJvZHkuYmluZChudWxsLCBjdHJsKTtcblxuICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyQ3RybCwgYm9keUN0cmwsIG51bGwpO1xufVxuXG5mdW5jdGlvbiBoZWFkZXIoY3RybCkge1xuICByZXR1cm4gKFxuICAgIDxuYXY+XG4gICAgICB7bWVudUJ1dHRvbigpfVxuICAgICAgPGgxPntpMThuKCdwbGF5ZXJzJyl9PC9oMT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uc1wiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIm1haW5faGVhZGVyX2J1dHRvblwiIGtleT1cInNlYXJjaFBsYXllcnNcIiBkYXRhLWljb249XCJ5XCIvPlxuICAgICAgPC9kaXY+XG4gICAgPC9uYXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGJvZHkoY3RybCkge1xuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzc05hbWU9XCJwbGF5ZXJzU3VnZ2VzdGlvbiBuYXRpdmVfc2Nyb2xsZXJfcGFnZVwiPlxuICAgICAge2N0cmwucGxheWVycygpLm1hcChyZW5kZXJQbGF5ZXIpfVxuICAgIDwvdWw+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBsYXllcih1c2VyKSB7XG4gIC8vIGZpbmQgYmVzdCBwZXJmXG4gIGNvbnN0IHBlcmYgPSBPYmplY3Qua2V5cyh1c2VyLnBlcmZzKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICBpZiAoIXByZXYpIHJldHVybiBjdXJyO1xuICAgIGlmICh1c2VyLnBlcmZzW3ByZXZdLnJhdGluZyA8IHVzZXIucGVyZnNbY3Vycl0ucmF0aW5nKVxuICAgICAgcmV0dXJuIGN1cnI7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHByZXY7XG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPGxpIGNsYXNzTmFtZT1cImxpc3RfaXRlbSBwbGF5ZXJTdWdnZXN0aW9uIG5hdlwiIGNvbmZpZz17aC5vbnRvdWNoWSgoKSA9PiBtLnJvdXRlKCcvQC8nICsgdXNlci5pZCkpfT5cbiAgICAgIHt1c2VyU3RhdHVzKHVzZXIpfVxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicmF0aW5nXCIgZGF0YS1pY29uPXt1dGlscy5nYW1lSWNvbihwZXJmKX0+XG4gICAgICAgIHt1c2VyLnBlcmZzW3BlcmZdLnJhdGluZ31cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2xpPlxuICApO1xufVxuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IHsgaGVhZGVyIGFzIGhlYWRlcldpZGdldCwgYmFja0J1dHRvbiB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuaW1wb3J0IGZvcm1XaWRnZXRzIGZyb20gJy4uL3NoYXJlZC9mb3JtJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vc29ja2V0JztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgY29udHJvbGxlcigpIHtcbiAgICBzb2NrZXQuY3JlYXRlRGVmYXVsdCgpO1xuICB9LFxuXG4gIHZpZXcoKSB7XG4gICAgY29uc3QgaGVhZGVyID0gdXRpbHMucGFydGlhbGYoaGVhZGVyV2lkZ2V0LCBudWxsLCBiYWNrQnV0dG9uKGkxOG4oJ3NldHRpbmdzJykpKTtcblxuICAgIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIsIHJlbmRlckJvZHkpO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIHJlbmRlckJvZHkoKSB7XG4gIHJldHVybiBtKCdkaXYnLCB7XG4gICAgc3R5bGU6IHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfVxuICB9LCBbXG4gICAgbSgndWwuc2V0dGluZ3NfbGlzdC5nZW5lcmFsLm5hdGl2ZV9zY3JvbGxlci5wYWdlJywgW1xuICAgICAgbSgnbGkubGlzdF9pdGVtLm5hdicsIHtcbiAgICAgICAga2V5OiAnbGFuZycsXG4gICAgICAgIGNvbmZpZzogaGVscGVyLm9udG91Y2hZKHV0aWxzLmYobS5yb3V0ZSwgJy9zZXR0aW5ncy9sYW5nJykpXG4gICAgICB9LCBpMThuKCdsYW5ndWFnZScpKSxcbiAgICAgIG0oJ2xpLmxpc3RfaXRlbS5zZXR0aW5nc0Nob2ljZXNJbmxpbmUnLCB7XG4gICAgICAgIGtleTogJ2JhY2tncm91bmRUaGVtZSdcbiAgICAgIH0sIFtcbiAgICAgICAgbSgnbGFiZWwnLCBpMThuKCdiYWNrZ3JvdW5kJykpLFxuICAgICAgICBtKCdmaWVsZHNldCcsIFtcbiAgICAgICAgICBtKCdkaXYubmljZS1yYWRpbycsIGZvcm1XaWRnZXRzLnJlbmRlclJhZGlvKFxuICAgICAgICAgICAgaTE4bignZGFyaycpLFxuICAgICAgICAgICAgJ2JnVGhlbWUnLFxuICAgICAgICAgICAgJ2RhcmsnLFxuICAgICAgICAgICAgc2V0dGluZ3MuZ2VuZXJhbC50aGVtZS5iYWNrZ3JvdW5kKCkgPT09ICdkYXJrJyxcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLnRoZW1lLmJhY2tncm91bmQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICBsYXlvdXQub25CYWNrZ3JvdW5kQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICBtKCdkaXYubmljZS1yYWRpbycsIGZvcm1XaWRnZXRzLnJlbmRlclJhZGlvKFxuICAgICAgICAgICAgaTE4bignbGlnaHQnKSxcbiAgICAgICAgICAgICdiZ1RoZW1lJyxcbiAgICAgICAgICAgICdsaWdodCcsXG4gICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLnRoZW1lLmJhY2tncm91bmQoKSA9PT0gJ2xpZ2h0JyxcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLnRoZW1lLmJhY2tncm91bmQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICBsYXlvdXQub25CYWNrZ3JvdW5kQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgXSldKVxuICAgIF0pLFxuICAgIHdpbmRvdy5veXVua2V5Zi52ZXJzaW9uID8gbSgnc2VjdGlvbi5hcHBfdmVyc2lvbicsICd2JyArIHdpbmRvdy5veXVua2V5Zi52ZXJzaW9uKSA6IG51bGxcbiAgXSk7XG59XG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBoZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgZm9ybVdpZGdldHMgZnJvbSAnLi4vc2hhcmVkL2Zvcm0nO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCBpMThuLCB7IGxvYWRGcm9tU2V0dGluZ3MsIGdldEF2YWlsYWJsZUxhbmd1YWdlcyB9IGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHsgc2V0U2VydmVyTGFuZyB9IGZyb20gJy4uLy4uL3hocic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBsYW5ncyA9IG0ucHJvcChbXSk7XG4gICAgZ2V0QXZhaWxhYmxlTGFuZ3VhZ2VzKCkudGhlbihsYW5ncyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3NcbiAgICB9O1xuICB9LFxuICB2aWV3OiBmdW5jdGlvbihjdHJsKSB7XG4gICAgY29uc3QgaGVhZGVyID0gdXRpbHMucGFydGlhbGYoaGVhZGVyV2lkZ2V0LCBudWxsLCBiYWNrQnV0dG9uKGkxOG4oJ2xhbmd1YWdlJykpXG4gICAgICApO1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyTGFuZyhsKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8bGkgY2xhc3NOYW1lPVwibGlzdF9pdGVtXCI+XG4gICAgICAgIHtmb3JtV2lkZ2V0cy5yZW5kZXJSYWRpbyhsWzFdLCAnbGFuZycsIGxbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLmxhbmcoKSA9PT0gbFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLmxhbmcoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZXJ2ZXJMYW5nKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEZyb21TZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICApfVxuICAgICAgICA8L2xpPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJCb2R5KCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm5hdGl2ZV9zY3JvbGxlciBwYWdlIHNldHRpbmdzX2xpc3QgcmFkaW9fbGlzdFwiPlxuICAgICAgICAgIHtjdHJsLmxhbmdzKCkubWFwKGwgPT4gcmVuZGVyTGFuZyhsKSl9XG4gICAgICAgIDwvdWw+XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCByZW5kZXJCb2R5KTtcbiAgfVxufTtcbiIsImltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KHZub2RlKSB7XG4gICAgXG4gICAgY29uc3QgeyBva2V5Z3JvdW5kIH0gPSB2bm9kZS5hdHRycztcblxuICAgIHRoaXMud3JhcHBlck9uQ3JlYXRlID0gKCh7ZG9tfSkgPT4ge1xuICAgIH0pO1xuXG4gICAgdGhpcy5ib2FyZE9uQ3JlYXRlID0gKHtkb219KSA9PiB7XG4gICAgICBva2V5Z3JvdW5kLmF0dGFjaChkb20pO1xuICAgIH07XG5cbiAgICB0aGlzLmJvYXJkT25SZW1vdmUgPSAoKSA9PiB7XG4gICAgICBva2V5Z3JvdW5kLmRldGFjaCgpO1xuICAgIH07XG4gICAgXG4gIH0sXG5cbiAgdmlldyh2bm9kZSkge1xuICAgIGNvbnN0IHsgYm91bmRzIH0gPSB2bm9kZS5hdHRycztcblxuICAgIGNvbnN0IGJvYXJkQ2xhc3MgPSBbXG4gICAgICAnZGlzcGxheV9ib2FyZCcsXG4gICAgXS5qb2luKCcgJyk7XG5cbiAgICBsZXQgd3JhcHBlckNsYXNzID0gJ2dhbWVfYm9hcmRfd3JhcHBlcic7XG5cbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSBib3VuZHMgPyB7XG4gICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgKyAncHgnLFxuICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCArICdweCdcbiAgICB9IDoge307XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8c2VjdGlvbiBvbmNyZWF0ZT17dGhpcy53cmFwcGVyT25DcmVhdGV9IGNsYXNzTmFtZT17d3JhcHBlckNsYXNzfSBzdHlsZT17d3JhcHBlclN0eWxlfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Ym9hcmRDbGFzc31cbiAgICAgICAgICAgICBvbmNyZWF0ZT17dGhpcy5ib2FyZE9uQ3JlYXRlfVxuICAgICAgICAgICAgIG9ucmVtb3ZlPXt0aGlzLmJvYXJkT25SZW1vdmV9Lz5cbiAgICAgICAgPC9zZWN0aW9uPlxuICAgICk7XG4gIH1cbiAgXG59O1xuXG5cbi8vIGZ1bmN0aW9uIHJlbmRlclRvcE1lbnUoKSB7XG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBjbGFzcz1cImRpc3BsYXlfbWVudVwiPlxuLy8gICAgICAge21lbnVCdXR0b24oKX1cbi8vICAgICA8L2Rpdj5cbi8vICAgKTtcbi8vIH1cblxuLy8gZnVuY3Rpb24gcmVuZGVyUGxheWVySW5mbyhjdHJsLCBwbGF5ZXIsIHBvc2l0aW9uKSB7XG4vLyAgIGNvbnN0IHdyYXBwZXJDbGFzcyA9IGhlbHBlci5jbGFzc1NldCh7XG4vLyAgICAgJ3BsYXllckluZm9zJzogdHJ1ZSxcbi8vICAgfSkgKyBgICR7cG9zaXRpb259YDtcblxuLy8gICBjb25zdCBwbGF5ZXJOYW1lID0gcGxheWVyLmFpID9cbi8vICAgICAgICAgICAgICAgICAgICAgIGkxOG4oJ2FpQm90JywgcGxheWVyLmFpKSA6XG4vLyAgICAgICAgICAgICAgICAgICAgICB1dGlscy5wbGF5ZXJOYW1lKHBsYXllcik7XG4vLyAgIGNvbnN0IHBsYXllck9uR2FtZSA9IChwbGF5ZXIub25HYW1lIHx8IHBsYXllci5haSA/XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJvbmdhbWUgeWVzXCIgZGF0YS1pY29uPVwiM1wiLz4gOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwib25nYW1lIG5vXCIgZGF0YS1pY29uPVwiMFwiLz5cbi8vICAgKTtcblxuLy8gICBjb25zdCB0b2dnbGVQb3B1cCA9IGN0cmwudG9nZ2xlVXNlclBvcHVwLmJpbmQoY3RybCwgcG9zaXRpb24sIHBsYXllci51c2VyKTtcbi8vICAgY29uc3QgdkNvbmYgPSBoZWxwZXIub250b3VjaCh0b2dnbGVQb3B1cCk7XG5cbi8vICAgY29uc3QgcnVubmluZ1NpZGUgPSBjdHJsLmlzQ2xvY2tSdW5uaW5nKCkgPyBjdHJsLmRhdGEuZ2FtZS5wbGF5ZXIgOiBudWxsO1xuLy8gICBjb25zdCBydW5uaW5nID0gY3RybC5kYXRhLmdhbWUucGxheWVyID09PSBwbGF5ZXIuc2lkZTtcblxuLy8gICBjb25zdCBvcGVucyA9IGN0cmwuZGF0YS5nYW1lLm9zY29yZXMgPyBjdHJsLmRhdGEuZ2FtZS5vc2NvcmVzW3BsYXllci5zaWRlXSA6IG51bGw7XG4vLyAgIGNvbnN0IG9wZW5zSGludCA9IG9wZW5zID8gKG9wZW5zLnNlcmllcyA/ICdvcGVuZWRTZXJpZXMnIDogJ29wZW5lZFBhaXJzJykgOiBudWxsO1xuLy8gICBjb25zdCBvcGVuc0NsYXNzID0gXCJvcGVuc1wiICsgKChvcGVucyAmJiBvcGVucy5uZXcpID8gXCIgbmV3XCIgOiBcIlwiKTtcblxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3N9IGNvbmZpZz17dkNvbmZ9PlxuLy8gICAgICAgPGRpdiBjbGFzcz1cIndyYXBfaW5mb1wiPlxuLy8gICAgICAgICB7b3BlbnMgP1xuLy8gICAgICAgICAgPGRpdiBjbGFzcz17b3BlbnNDbGFzc30+XG4vLyAgICAgICAgICAgIHsob3BlbnMuc2VyaWVzID8gb3BlbnMuc2VyaWVzIDogb3BlbnMucGFpcnMpfVxuLy8gICAgICAgICAgICB7JyAnfVxuLy8gICAgICAgICAgICB7aTE4bihvcGVuc0hpbnQpLnNwbGl0KCcgJylbMF19XG4vLyAgICAgICAgICA8L2Rpdj46IG51bGxcbi8vICAgICAgICAgfVxuLy8gICAgICAgPC9kaXY+XG4vLyAgICAgICA8ZGl2IGNsYXNzPVwid3JhcF91c2VyXCI+XG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJwbGF5ZXJVc2VyXCI+XG4vLyAgICAgICAgICAge3BsYXllck5hbWV9XG4vLyAgICAgICAgICAge3BsYXllck9uR2FtZX1cbi8vICAgICAgICAgPC9oMj5cbi8vICAgICAgICAgeyAoY3RybC5jbG9jayAmJiBydW5uaW5nKSA/XG4vLyAgICAgICAgICAgcmVuZGVyQ2xvY2soY3RybC5jbG9jaywgcGxheWVyLnNpZGUsIHJ1bm5pbmdTaWRlLCBwb3NpdGlvbikgOiBudWxsXG4vLyAgICAgICAgIH1cbi8vICAgICAgIDwvZGl2PlxuLy8gICAgIDwvZGl2PlxuLy8gICApO1xuLy8gfVxuXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihcbi8vICAgY3RybCxcbi8vICAgb2tleWdyb3VuZEN0cmwsXG4vLyAgIGJvdW5kcyxcbi8vICAgaXNQb3J0cmFpdCxcbi8vICAgd3JhcHBlckNsYXNzZXMpIHtcbi8vICAgICBjb25zdCBkYXRhID0gY3RybC5kYXRhO1xuXG4vLyAgICAgY29uc3QgYm9hcmRDbGFzcyA9IFtcbi8vICAgICAgICdkaXNwbGF5X2JvYXJkJyxcbi8vICAgICBdLmpvaW4oJyAnKTtcblxuLy8gICAgIGNvbnN0IGtleSA9ICdib2FyZCcgKyAoaXNQb3J0cmFpdCA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJyk7XG4vLyAgICAgbGV0IHdyYXBwZXJDbGFzcyA9ICdnYW1lX2JvYXJkX3dyYXBwZXInO1xuXG4vLyAgICAgaWYgKHdyYXBwZXJDbGFzc2VzKSB7XG4vLyAgICAgICB3cmFwcGVyQ2xhc3MgKz0gJyAnICsgd3JhcHBlckNsYXNzZXM7XG4vLyAgICAgfVxuXG4vLyAgICAgY29uc3Qgd3JhcHBlclN0eWxlID0gYm91bmRzID8ge1xuLy8gICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0ICsgJ3B4Jyxcbi8vICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGggKyAncHgnXG4vLyAgICAgfSA6IHt9O1xuXG5cbi8vICAgICBmdW5jdGlvbiB3cmFwcGVyQ29uZmlnKGVsLCBpc1VwZGF0ZSkge1xuLy8gICAgICAgaWYgKCFpc1VwZGF0ZSkge1xuLy8gICAgICAgfVxuLy8gICAgIH1cblxuLy8gICAgIGZ1bmN0aW9uIGJvYXJkQ29uZmlnKGVsLCBpc1VwZGF0ZSkge1xuLy8gICAgICAgaWYgKCFpc1VwZGF0ZSkge1xuLy8gICAgICAgICBpZiAoIWJvdW5kcykge1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIG9rZXlncm91bmQucmVuZGVyKGVsLCBva2V5Z3JvdW5kQ3RybCk7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuXG4vLyAgICAgb2tleWdyb3VuZEN0cmwuZGF0YS50b3BIb29rcyA9IFtcbi8vICAgICAgIC8vIHJlbmRlclRvcE1lbnUoKSxcbi8vICAgICAgIHJlbmRlclBsYXllckluZm8oY3RybCwgZGF0YS5vcHBvbmVudFVwLCAndG9wJyksXG4vLyAgICAgICByZW5kZXJQbGF5ZXJJbmZvKGN0cmwsIGRhdGEub3Bwb25lbnRMZWZ0LCAnbGVmdCcpLFxuLy8gICAgICAgcmVuZGVyUGxheWVySW5mbyhjdHJsLCBkYXRhLnBsYXllciwgJ2JvdHRvbScpLFxuLy8gICAgICAgcmVuZGVyUGxheWVySW5mbyhjdHJsLCBkYXRhLm9wcG9uZW50UmlnaHQsICdyaWdodCcpXG4vLyAgICAgXTtcblxuXG4vLyAgICAgcmV0dXJuIChcbi8vICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT17d3JhcHBlckNsYXNzfSBjb25maWc9e3dyYXBwZXJDb25maWd9XG4vLyAgICAgICAgICAgICAgICBzdHlsZT17d3JhcHBlclN0eWxlfSBrZXk9e2tleX0+XG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtib2FyZENsYXNzfSBjb25maWc9e2JvYXJkQ29uZmlnfSAvPlxuLy8gICAgICAgPC9zZWN0aW9uPlxuLy8gICAgICk7XG4vLyB9XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2aWV3KHsgYXR0cnMgfSkge1xuXG4gICAgY29uc3QgdGl0bGUgPSAnZ2FtZUFwaS50aXRsZShkYXRhKSc7XG5cbiAgICByZXR1cm4gaCgnZGl2Lm1haW5faGVhZGVyX3RpdGxlJywge1xuICAgIH0sIFtcbiAgICAgIGgoJ2gxLmhlYWRlci1nYW1lVGl0bGUnLCBbXG4gICAgICAgIGgoJ3NwYW4nLCB0aXRsZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQoe2F0dHJzfSkge1xuICAgIHRoaXMub25UYXAgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgZWwgPSBoZWxwZXIuZ2V0QnV0dG9uKGUpO1xuICAgICAgbGV0IGk7XG4gICAgICBpZiAoZWwgJiYgKGkgPSAoZWwuZGF0YXNldCkuaW5kZXgpKSB7XG4gICAgICAgIGF0dHJzLm9uVGFiQ2hhbmdlKE51bWJlcihpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICB2aWV3KHZub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnV0dG9ucyxcbiAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICBub0luZGljYXRvcixcbiAgICAgIHdyYXBwZXJDbGFzc1xuICAgIH0gPSB2bm9kZS5hdHRycztcblxuICAgIGNvbnN0IGlXaWR0aCA9IDEwMCAvIGJ1dHRvbnMubGVuZ3RoO1xuICAgIGNvbnN0IHNoaWZ0ID0gc2VsZWN0ZWRJbmRleCAqIChpV2lkdGggKiBidXR0b25zLmxlbmd0aCk7XG5cbiAgICBjb25zdCBpbmRpY2F0b3JTdHlsZSA9IHtcbiAgICAgIHdpZHRoOiBpV2lkdGggKyAnJScsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7c2hpZnR9JSlgXG4gICAgfTtcblxuICAgIGNvbnN0IGJ1dHRvblN0eWxlID0ge1xuICAgICAgd2lkdGg6IGlXaWR0aCArICclJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZW5kZXJUYWIoYiwgaSkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gW1xuICAgICAgICAndGFiLWJ1dHRvbicsXG4gICAgICAgIHNlbGVjdGVkSW5kZXggPT09IGkgPyAnc2VsZWN0ZWQnOiAnJyxcbiAgICAgICAgYi5jbGFzc05hbWVcbiAgICAgIF0uam9pbignICcpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8YnV0dG9uIGRhdGEtaW5kZXg9e2l9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzdHlsZT17YnV0dG9uU3R5bGV9PlxuICAgICAgICAgICAge2IubGFiZWx9XG4gICAgICAgICAgICB7Yi5jaGlwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNoaXBcIj57Yi5jaGlwfTwvc3Bhbj4gOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17J3RhYnMtbmF2aWdhdGlvbicgKyAod3JhcHBlckNsYXNzID8gJyAnICsgd3JhcHBlckNsYXNzIDogJycpfVxuICAgICAgICAgICBvbmNyZWF0ZT17aGVscGVyLm9udGFwKHRoaXMub25UYXApfT5cbiAgICAgICAgICB7YnV0dG9ucy5tYXAocmVuZGVyVGFiKX1cbiAgICAgICAgICB7IG5vSW5kaWNhdG9yID8gbnVsbCA6IDxkaXYgY2xhc3NOYW1lPVwidGFiSW5kaWNhdG9yXCIgc3R5bGU9XCJpbmRpY2F0b3JTdHlsZVwiLz4gfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCB7IHZpZXdwb3J0RGltIH0gZnJvbSAnLi4vaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmNyZWF0ZSh7YXR0cnMsIGRvbX0pIHtcbiAgfSxcblxuICB2aWV3KHthdHRyc30pIHtcbiAgICBjb25zdCBjdXJJbmRleCA9IGF0dHJzLnNlbGVjdGVkSW5kZXg7XG4gICAgY29uc3QgdncgPSB2aWV3cG9ydERpbSgpLnZ3O1xuICAgIGNvbnN0IHdpZHRoID0gYXR0cnMuY29udGVudC5sZW5ndGggKiAxMDA7XG4gICAgY29uc3Qgc2hpZnQgPSAtKGN1ckluZGV4ICogdncpO1xuXG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICB3aWR0aDogYCR7d2lkdGh9dndgLFxuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke3NoaWZ0fXB4KWBcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBoKCdkaXYudGFicy12aWV3LXdyYXBwZXInLCBoKCdkaXYudGFicy12aWV3Jywge1xuICAgICAgc3R5bGUsXG4gICAgICBjbGFzc05hbWU6IGF0dHJzLmNsYXNzTmFtZVxuICAgIH0sIGF0dHJzLmNvbnRlbnQubWFwKChfLCBpbmRleCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICBoKCdkaXYudGFiLWNvbnRlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1pbmRleCc6aW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGN1ckluZGV4ID09PSBpbmRleCA/ICdjdXJyZW50JzonJ1xuICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGN1ckluZGV4ID09PSBpbmRleCA/IGgoVGFiLCB7IGluZGV4LCAuLi5hdHRycyB9KSA6IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcbiAgICBcbiAgfVxuXG59XG5cbmNvbnN0IFRhYiA9IHtcbiAgb25iZWZvcmV1cGRhdGUoe2F0dHJzfSwge2F0dHJzOiBvbGRhdHRycyB9KSB7XG4gICAgcmV0dXJuIGF0dHJzLmNvbnRlbnRbYXR0cnMuaW5kZXhdICE9PSBvbGRhdHRycy5jb250ZW50W29sZGF0dHJzLmluZGV4XTtcbiAgfSxcblxuICB2aWV3KHthdHRyc30pIHtcbiAgICByZXR1cm4gYXR0cnMucmVuZGVyZXIoYXR0cnMuY29udGVudFthdHRycy5pbmRleF0sIGF0dHJzLmluZGV4KTtcbiAgfVxufVxuIiwiaW1wb3J0IG9rZXlncm91bmQgZnJvbSAnb2tleWdyb3VuZC1tb2JpbGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZpZXcoXywgYXJncykge1xuICAgIGNvbnN0IGJvYXJkQ2xhc3MgPSBbXG4gICAgICAnZGlzcGxheV9ib2FyZCcsXG4gICAgICBhcmdzLnZhcmlhbnQgPyBhcmdzLnZhcmlhbnQua2V5IDogJydcbiAgICBdLmpvaW4oJyAnKTtcblxuICAgIGZ1bmN0aW9uIGJvYXJkQ29uZihlbCwgaXNVcGRhdGUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IG1ha2VDb25maWcoYXJncyk7XG4gICAgICBpZiAoY29udGV4dC5ncm91bmQpIHtcbiAgICAgICAgY29udGV4dC5ncm91bmQuc2V0KGNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIHRyeSB0byBhdm9pZCB0aGF0XG4gICAgICAgIGlmICghY29uZmlnLmJvdW5kcykge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdubyBib2FyZCBib3VuZHMnKTtcbiAgICAgICAgICAvLyBjb25maWcuYm91bmRzID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5ncm91bmQgPSBva2V5Z3JvdW5kKGVsLCBjb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Ym9hcmRDbGFzc30gY29uZmlnPXtib2FyZENvbmZ9Lz5cbiAgICApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYWtlQ29uZmlnKGFyZ3MpIHtcbiAgY29uc3QgeyBmZW4sIG9yaWVudGF0aW9uLCBib3VuZHMgfSA9IGFyZ3M7XG4gIGNvbnN0IGNvbmYgPSB7XG4gICAgdmlld09ubHk6IHRydWUsXG4gICAgbWluaW1hbERvbTogdHJ1ZSxcbiAgICBmZW5cbiAgfTtcblxuICAvLyBpZiAoYm91bmRzKSBjb25mLmJvdW5kcyA9IGJvdW5kcztcblxuICByZXR1cm4gY29uZjtcbn1cbiIsImltcG9ydCAqIGFzIG1lbnUgZnJvbSAnLi4vbWVudSc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgZ2FtZXNNZW51IGZyb20gJy4uL2dhbWVzTWVudSc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vcm91dGVyJztcbmltcG9ydCB7IGJhY2tBcnJvdyB9IGZyb20gJy4vaWNvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWVudUJ1dHRvbigpIHtcbiAgcmV0dXJuIGgoJ2J1dHRvbi5mYS5mYS1uYXZpY29uLm1haW5faGVhZGVyX2J1dHRvbi5tZW51X2J1dHRvbicsIHtcbiAgICBrZXk6ICdtYWluLW1lbnUnLFxuICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXAobWVudS5tYWluTWVudUN0cmwudG9nZ2xlKVxuICB9KTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGVhZGVyQnRucygpIHtcblxuICBpZiAodXRpbHMuaGFzTmV0d29yaygpICYmIHNlc3Npb24uaXNDb25uZWN0ZWQoKSkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT1cImJ1dHRvbnNcIiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT1cImJ1dHRvbnNcIiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4gIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJvcFNoYWRvd0hlYWRlcih0aXRsZSwgbGVmdEJ1dHRvbikge1xuXG4gIHJldHVybiBbXG4gICAgaCgnbmF2JywgW1xuICAgICAgbGVmdEJ1dHRvbiA/IGxlZnRCdXR0b24gOiBtZW51QnV0dG9uKCksXG4gICAgICB0aXRsZSA/IDxkaXYgY2xhc3NOYW1lPVwibWFpbl9oZWFkZXJfdGl0bGVcIiBrZXk9XCJ0aXRsZVwiPnt0aXRsZX08L2Rpdj46IG51bGwsXG4gICAgICBoZWFkZXJCdG5zKClcbiAgICBdKSxcbiAgICBoKCdkaXYubWFpbl9oZWFkZXJfZHJvcF9zaGFkb3cnKVxuICBdO1xuICBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RpbmdEcm9wU2hhZG93SGVhZGVyKHRpdGxlKSB7XG4gIHJldHVybiBbXG4gICAgaCgnbmF2JywgW1xuICAgICAgbWVudUJ1dHRvbigpLFxuICAgICAgaCgnZGl2Lm1haW5faGVhZGVyX3RpdGxlLnJlY29ubmVjdGluZycsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB0aXRsZSA/ICd3aXRoVGl0bGUnOicnLFxuICAgICAgICBrZXk6ICdjb25uZWN0aW5nLXRpdGxlJ1xuICAgICAgfSksXG4gICAgICB0aXRsZSA/IGgoJ2Rpdi5tYWluX2hlYWRlcl90aXRsZScsIHsga2V5OiAndGl0bGUnIH0sIHRpdGxlKSA6IG51bGwsXG4gICAgICBoZWFkZXJCdG5zKClcbiAgICBdKSxcbiAgICBoKCdkaXYubWFpbl9oZWFkZXJfZHJvcF9zaGFkb3cnKVxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja0J1dHRvbih0aXRsZSkge1xuICByZXR1cm4gaCgnZGl2LmJhY2tfYnV0dG9uJywgeyBrZXk6ICdkZWZhdWx0LWhpc3RvcnktYmFja2J1dHRvbicgfSwgW1xuICAgIGgoJ2J1dHRvbicsIHsgb25jcmVhdGU6IGhlbHBlci5vbnRhcChyb3V0ZXIuYmFja0hpc3RvcnkpIH0sIGJhY2tBcnJvdyksXG4gICAgdGl0bGUgIT09IHVuZGVmaW5lZCA/IHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycgPyBoKCdkaXYubWFpbl9oZWFkZXJfdGl0bGUnLCB0aXRsZSkgOiB0aXRsZSA6IG51bGxcbiAgXSk7XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBtZW51QnV0dG9uKCkge1xuLy8gICByZXR1cm4gKFxuLy8gICAgICAgPGJ1dHRvbiBrZXk9XCJtYWluLW1lbnVcIiBjbGFzc05hbWU9XCJmYSBmYS1uYXZpY29uIG1haW5faGVhZGVyX2J1dHRvbiBtZW51X2J1dHRvblwiIGNvbmZpZz17aGVscGVyLm9udG91Y2gobWVudS50b2dnbGUpfT5cbi8vICAgICA8L2J1dHRvbj5cbi8vICAgKTtcbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGJhY2tCdXR0b24odGl0bGUpIHtcbi8vICAgcmV0dXJuIChcbi8vICAgICAgIDxidXR0b24ga2V5PVwiZGVmYXVsdC1oaXN0b3J5LWJhY2tidXR0b25cIiBjbGFzc05hbWU9XCJiYWNrX2J1dHRvbiBtYWluX2hlYWRlcl9idXR0b25cIiBjb25maWc9e2hlbHBlci5vbnRvdWNoKHV0aWxzLmJhY2tIaXN0b3J5KX0+XG4vLyAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1hcnJvdy1sZWZ0XCIvPlxuLy8gICAgICAge3RpdGxlID8gPGRpdiBjbGFzc05hbWU9XCJ0aXRsZVwiPnt0aXRsZX08L2Rpdj4gOiBudWxsIH1cbi8vICAgICA8L2J1dHRvbj5cbi8vICAgKTtcbi8vIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbWVzQnV0dG9uKCkge1xuICBsZXQga2V5LCBhY3Rpb247XG5cbiAga2V5PSdnYW1lcy1tZW51JztcblxuICBpZiAoc2Vzc2lvbi5ub3dQbGF5aW5nKCkubGVuZ3RoKSB7XG4gICAga2V5ID0gJ2dhbWVzLW1lbnUnO1xuICAgIGFjdGlvbiA9IGdhbWVzTWVudS5vcGVuO1xuICB9IGVsc2Uge1xuICAgIGtleSA9ICduZXctZ2FtZS1mb3JtJztcbiAgICBhY3Rpb24gPSBuZXdHYW1lRm9ybS5vcGVuO1xuICB9XG5cbiAgY29uc3QgY2xhc3NOYW1lID0gW1xuICAgICdtYWluX2hlYWRlcl9idXR0b24nLFxuICAgICdnYW1lX21lbnVfYnV0dG9uJyxcbiAgICAhdXRpbHMuaGFzTmV0d29yaygpID8gJ2ludmlzaWJsZScgOiAnJ1xuICBdLmpvaW4oJyAnKTtcblxuICBjb25zdCBsb25nQWN0aW9uID0gKCkgPT4gd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhpMThuKCduYkdhbWVzSW5QbGF5Jywgc2Vzc2lvbi5ub3dQbGF5aW5nKCkubGVuZ3RoKSwgJ3Nob3J0JywgJ3RvcCcpO1xuXG4gIHJldHVybiAoXG4gICAgICA8YnV0dG9uIGtleT17a2V5fSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gY29uZmlnPXtoZWxwZXIub250b3VjaChhY3Rpb24sIGxvbmdBY3Rpb24pfT5cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGhlYWRlckJ0bnMoKSB7XG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBrZXk9XCJidXR0b25zXCIgY2xhc3NOYW1lPVwiYnV0dG9uc1wiPlxuLy8gICAgICAge2dhbWVzQnV0dG9uKCl9XG4vLyAgICAgPC9kaXY+XG4vLyAgICk7XG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBoZWFkZXIodGl0bGUsIGxlZnRCdXR0b24pIHtcbiAgcmV0dXJuIChcbiAgICA8bmF2PlxuICAgICAge2xlZnRCdXR0b24gPyBsZWZ0QnV0dG9uIDogbWVudUJ1dHRvbigpfVxuICAgICAge3RpdGxlID8gPGgxIGtleT1cInRpdGxlXCI+e3RpdGxlfTwvaDE+IDogbnVsbCB9XG4gICAgICB7aGVhZGVyQnRucygpfVxuICAgIDwvbmF2PlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlld09ubHlCb2FyZENvbnRlbnQoKSB7XG4gIGNvbnN0IGlzUG9ydHJhaXQgPSBmYWxzZTtcbiAgY29uc3QgeyB2dywgdmggfSA9IHsgdnc6IDEwLCB2aDogMTAgfVxuICBjb25zdCBib2FyZFN0eWxlID0gaXNQb3J0cmFpdCA/IHsgd2lkdGg6IHZ3ICsgJ3B4JywgaGVpZ2h0OiB2dyArICdweCcgfSA6IHt9O1xuICBjb25zdCBib2FyZEtleSA9ICd2aWV3b25seWJvYXJkJ1xuICBjb25zdCBjbGFzc05hbWUgPSAnYm9hcmRfd3JhcHBlcidcbiAgY29uc3QgYm9hcmQgPSAoXG4gICAgPHNlY3Rpb24ga2V5PXtib2FyZEtleX0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IHN0eWxlPXtib2FyZFN0eWxlfT5cbiAgICAgIHttLmNvbXBvbmVudChWaWV3T25seUJvYXJkKX1cbiAgICA8L3NlY3Rpb24+XG4gICk7XG4gIHJldHVybiBbXG4gICAgYm9hcmRcbiAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VyU3RhdHVzKHVzZXIpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlci5vbmxpbmUgPyAnb25saW5lJyA6ICdvZmZsaW5lJztcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVzZXJcIj5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17J3VzZXJTdGF0dXMgJyArIHN0YXR1c30gZGF0YS1pY29uPVwiclwiIC8+XG4gICAgICB7dXNlci51c2VybmFtZX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuXG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJlbmRlclNlbGVjdChcbiAgICBsYWJlbCxcbiAgICBuYW1lLFxuICAgIG9wdGlvbnMsXG4gICAgc2V0dGluZ3NQcm9wLFxuICAgIGlzRGlzYWJsZWQsXG4gICAgb25DaGFuZ2VDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb3AgPSBzZXR0aW5nc1Byb3AoKTtcbiAgICByZXR1cm4gW1xuICAgICAgaCgnbGFiZWwnLCB7XG4gICAgICAgICdmb3InOiAnc2VsZWN0XycgKyBuYW1lXG4gICAgICB9LCBpMThuKGxhYmVsKSksXG4gICAgICBoKCdzZWxlY3QnLCB7XG4gICAgICAgIGlkOiAnc2VsZWN0XycgKyBuYW1lLFxuICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgb25jaGFuZ2UoZSkge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIHNldHRpbmdzUHJvcCh2YWwpO1xuICAgICAgICAgIGlmIChvbkNoYW5nZUNhbGxiYWNrKSBvbkNoYW5nZUNhbGxiYWNrKHZhbCk7XG4gICAgICAgICAgc2V0VGltZW91dChyZWRyYXcsIDEwKTtcbiAgICAgICAgfVxuICAgICAgfSwgb3B0aW9ucy5tYXAoZSA9PiByZW5kZXJPcHRpb24oZVswXSwgZVsxXSwgcHJvcCwgZVsyXSwgZVszXSkpKVxuICAgIF07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbmRlck9wdGlvbihsYWJlbCwgdmFsdWUsIHByb3AsIGxhYmVsQXJnLCBsYWJlbEFyZzIpIHtcbiAgY29uc3QgbCA9IGxhYmVsQXJnICYmIGxhYmVsQXJnMiA/IGkxOG4obGFiZWwsIGxhYmVsQXJnLCBsYWJlbEFyZzIpIDpcbiAgICAgICAgICBsYWJlbEFyZyA/IGkxOG4obGFiZWwsIGxhYmVsQXJnKSA6IGkxOG4obGFiZWwpO1xuICByZXR1cm4gaCgnb3B0aW9uJywge1xuICAgIGtleTogdmFsdWUsXG4gICAgdmFsdWUsXG4gICAgc2VsZWN0ZWQ6IHByb3AgPT09IHZhbHVlXG4gIH0sIGwpO1xufVxuXG4vLyBpbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbi8vIGltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG4vLyBmdW5jdGlvbiByZW5kZXJPcHRpb24obGFiZWwsIHZhbHVlLCBzdG9yZWRWYWx1ZSwgbGFiZWxBcmcsIGxhYmVsQXJnMikge1xuLy8gICByZXR1cm4gbSgnb3B0aW9uJywge1xuLy8gICAgIHZhbHVlOiB2YWx1ZSxcbi8vICAgICBzZWxlY3RlZDogc3RvcmVkVmFsdWUgPT09IHZhbHVlXG4vLyAgIH0sIGkxOG4obGFiZWwsIGxhYmVsQXJnLCBsYWJlbEFyZzIpKTtcbi8vIH1cblxuLy8gZXhwb3J0IGRlZmF1bHQge1xuLy8gICByZW5kZXJSYWRpbzogZnVuY3Rpb24obGFiZWwsIG5hbWUsIHZhbHVlLCBjaGVja2VkLCBvbmNoYW5nZSkge1xuLy8gICAgIHZhciBpZCA9IG5hbWUgKyAnXycgKyB2YWx1ZTtcbi8vICAgICByZXR1cm4gW1xuLy8gICAgICAgbSgnaW5wdXQucmFkaW9bdHlwZT1yYWRpb10nLCB7XG4vLyAgICAgICAgIG5hbWUsXG4vLyAgICAgICAgIGlkLFxuLy8gICAgICAgICBjbGFzc05hbWU6IHZhbHVlLFxuLy8gICAgICAgICB2YWx1ZSxcbi8vICAgICAgICAgY2hlY2tlZCxcbi8vICAgICAgICAgb25jaGFuZ2Vcbi8vICAgICAgIH0pLFxuLy8gICAgICAgbSgnbGFiZWwnLCB7XG4vLyAgICAgICAgICdmb3InOiBpZFxuLy8gICAgICAgfSwgaTE4bihsYWJlbCkpXG4vLyAgICAgXTtcbi8vICAgfSxcblxuLy8gICByZW5kZXJTZWxlY3Q6IGZ1bmN0aW9uKGxhYmVsLCBuYW1lLCBvcHRpb25zLCBzZXR0aW5nc1Byb3AsIGlzRGlzYWJsZWQsIG9uQ2hhbmdlQ2FsbGJhY2spIHtcbi8vICAgICB2YXIgc3RvcmVkVmFsdWUgPSBzZXR0aW5nc1Byb3AoKTtcbi8vICAgICByZXR1cm4gW1xuLy8gICAgICAgbSgnbGFiZWwnLCB7XG4vLyAgICAgICAgICdmb3InOiAnc2VsZWN0XycgKyBuYW1lXG4vLyAgICAgICB9LCBpMThuKGxhYmVsKSksXG4vLyAgICAgICBtKCdzZWxlY3QnLCB7XG4vLyAgICAgICAgIGlkOiAnc2VsZWN0XycgKyBuYW1lLFxuLy8gICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbi8vICAgICAgICAgY29uZmlnOiBmdW5jdGlvbihlbCwgaXNVcGRhdGUsIGNvbnRleHQpIHtcbi8vICAgICAgICAgICBpZiAoIWlzVXBkYXRlKSB7XG4vLyAgICAgICAgICAgICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4vLyAgICAgICAgICAgICAgIHNldHRpbmdzUHJvcChlLnRhcmdldC52YWx1ZSk7XG4vLyAgICAgICAgICAgICAgIGlmIChvbkNoYW5nZUNhbGxiYWNrKSBvbkNoYW5nZUNhbGxiYWNrKGUudGFyZ2V0LnZhbHVlKTtcbi8vICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgICAgICBtLnJlZHJhdygpO1xuLy8gICAgICAgICAgICAgICB9LCAxMCk7XG4vLyAgICAgICAgICAgICB9O1xuLy8gICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbi8vICAgICAgICAgICAgIGNvbnRleHQub251bmxvYWQgPSAoKSA9PiB7XG4vLyAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4vLyAgICAgICAgICAgICB9O1xuLy8gICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgICAgfSwgb3B0aW9ucy5tYXAoZnVuY3Rpb24oZSkge1xuLy8gICAgICAgICByZXR1cm4gcmVuZGVyT3B0aW9uKGVbMF0sIGVbMV0sIHN0b3JlZFZhbHVlLCBlWzJdLCBlWzNdKTtcbi8vICAgICAgIH0pKVxuLy8gICAgIF07XG4vLyAgIH0sXG4vLyAgIHJlbmRlckNoZWNrYm94OiBmdW5jdGlvbihsYWJlbCwgbmFtZSwgc2V0dGluZ3NQcm9wLCBjYWxsYmFjaywgZGlzYWJsZWQpIHtcbi8vICAgICB2YXIgaXNPbiA9IHNldHRpbmdzUHJvcCgpO1xuLy8gICAgIHJldHVybiBtKCdkaXYuY2hlY2tfY29udGFpbmVyJywge1xuLy8gICAgICAgY2xhc3NOYW1lOiBkaXNhYmxlZCA/ICdkaXNhYmxlZCc6ICcnXG4vLyAgICAgfSwgW1xuLy8gICAgICAgbSgnbGFiZWwnLCB7XG4vLyAgICAgICAgICdmb3InOiBuYW1lXG4vLyAgICAgICB9LCBsYWJlbCksXG4vLyAgICAgICBtKCdpbnB1dFt0eXBlPWNoZWNrYm94XScsIHtcbi8vICAgICAgICAgbmFtZTogbmFtZSxcbi8vICAgICAgICAgZGlzYWJsZWQsXG4vLyAgICAgICAgIGNoZWNrZWQ6IGlzT24sXG4vLyAgICAgICAgIG9uY2hhbmdlOiBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICBjb25zdCBuZXdWYWwgPSAhaXNPbjtcbi8vICAgICAgICAgICBzZXR0aW5nc1Byb3AobmV3VmFsKTtcbi8vICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG5ld1ZhbCk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pXG4vLyAgICAgXSk7XG4vLyAgIH1cbi8vIH07XG4iLCJleHBvcnQgY29uc3QgYmFja0Fycm93ID1cbiAgPGRpdiBjbGFzc05hbWU9XCJzdmdfaWNvblwiPlxuICAgIDxkaXYgY2xhc3NOYW1lPVwic3ZnX2ljb25faW5uZXJcIj5cbiAgICAgIDxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIwIDExSDcuODNsNS41OS01LjU5TDEyIDRsLTggOCA4IDggMS40MS0xLjQxTDcuODMgMTNIMjB2LTJ6XCI+PC9wYXRoPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIDwvZGl2PjtcblxuZXhwb3J0IGNvbnN0IGNsb3NlSWNvbiA9XG4gIDxkaXYgY2xhc3NOYW1lPVwic3ZnX2ljb25cIj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cInN2Z19pY29uX2lubmVyXCI+XG4gICAgICA8c3ZnIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgPHBhdGggZD1cIk0xOSA2LjQxTDE3LjU5IDUgMTIgMTAuNTkgNi40MSA1IDUgNi40MSAxMC41OSAxMiA1IDE3LjU5IDYuNDEgMTkgMTIgMTMuNDEgMTcuNTkgMTkgMTkgMTcuNTkgMTMuNDEgMTJ6XCIvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIDwvZGl2PjtcbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdCgpIHtcbiAgfSxcbiAgdmlldyh7IGF0dHJzLCBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgeyBoZWFkZXIgfSA9IGF0dHJzO1xuXG4gICAgcmV0dXJuIGgoJ21haW4jcGFnZScsIHt9LCBbXG4gICAgICAvLyBoKCdoZWFkZXIubWFpbl9oZWFkZXIuYm9hcmQnLCBoZWFkZXIpLFxuICAgICAgaCgnZGl2LmNvbnRlbnRfcm91bmQnLCBjaGlsZHJlbilcbiAgICBdKTtcblxuICB9XG5cbn07XG4iLCJpbXBvcnQgeyBnYW1lSWNvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihrZXksIG5hbWUsIHBlcmYsIHVzZXIpIHtcbiAgdmFyIG9wdGlvbnMgPSB7IGNsYXNzTmFtZTogJ3Byb2ZpbGVQZXJmJywgJ2RhdGEtaWNvbic6IGdhbWVJY29uKGtleSkgfTtcblxuICBpZiAodmFyaWFudFBlcmZBdmFpbGFibGUoa2V5LCBwZXJmKSkge1xuICAgIG9wdGlvbnMuY2xhc3NOYW1lICs9ICcgbmF2JztcbiAgICBvcHRpb25zLmNvbmZpZyA9IGhlbHBlci5vbnRvdWNoWShnb1RvVmFyaWFudFBlcmYodXNlciwga2V5KSk7XG4gIH1cblxuICByZXR1cm4gbSgnZGl2Jywgb3B0aW9ucywgW1xuICAgIG0oJ3NwYW4ubmFtZScsIG5hbWUpLFxuICAgIG0oJ2Rpdi5yYXRpbmcnLCBbXG4gICAgICBwZXJmLnJhdGluZyxcbiAgICAgIGhlbHBlci5wcm9ncmVzcyhwZXJmLnByb2cpLFxuICAgICAgbSgnc3Bhbi5uYicsICcvICcgKyBwZXJmLmdhbWVzKVxuICAgIF0pXG4gIF0pO1xufVxuXG5mdW5jdGlvbiBnb1RvVmFyaWFudFBlcmYodXNlciwga2V5KSB7XG4gIHJldHVybiAoKSA9PiBtLnJvdXRlKCcvQC8ke3VzZXIuaWR9LyR7a2V5fS9wZXJmJyk7XG59XG5cbmZ1bmN0aW9uIHZhcmlhbnRQZXJmQXZhaWxhYmxlKGtleSwgcGVyZikge1xuICByZXR1cm4gcGVyZi5nYW1lcyA+IDA7XG59XG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG9wdXAoXG4gIGNsYXNzZXMsXG4gIGhlYWRlckYsXG4gIGNvbnRlbnRGLFxuICBpc1Nob3dpbmcsXG4gIGNsb3NlZikge1xuICBcbiAgaWYgKCFpc1Nob3dpbmcpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuICAgIG92ZXJsYXlfcG9wdXA6IHRydWUsXG4gICAgbmF0aXZlX3Njcm9sbGVyOiB0cnVlXG4gIH07XG4gIFxuICBsZXQgY2xhc3NOYW1lO1xuXG4gIGlmICh0eXBlb2YgY2xhc3NlcyA9PT0gJ29iamVjdCcpIHtcbiAgICBjbGFzc05hbWUgPSBoZWxwZXIuY2xhc3NTZXQoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENsYXNzZXMsIGNsYXNzZXMpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2xhc3NlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjbGFzc05hbWUgPSBoZWxwZXIuY2xhc3NTZXQoZGVmYXVsdENsYXNzZXMpICsgJyAnICsgY2xhc3NlcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IHBvcHVwIGFyZ3VtZW50IG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgY29uc3QgY29udGVudENsYXNzID0gaGVscGVyLmNsYXNzU2V0KHtcbiAgICAncG9wdXBfY29udGVudCc6IHRydWUsXG4gICAgJ25vaGVhZGVyJzogIWhlYWRlckZcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGtleT17U3RyaW5nKGNvbnRlbnRGKX0gY2xhc3NOYW1lPVwib3ZlcmxheV9wb3B1cF93cmFwcGVyIGZhZGUtaW5cIlxuICAgIG9uYmVmb3JlbW92ZT17KHZub2RlKSA9PiB7XG4gICAgICB2bm9kZS5kb20uY2xhc3NMaXN0LmFkZCgnZmFkaW5nX291dCcpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKTtcbiAgICAgIH0pO1xuICAgIH19PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cF9vdmVybGF5X2Nsb3NlXCJcbiAgICAgICAgb25jcmVhdGU9e2Nsb3NlZiA/IGhlbHBlci5vbnRhcChjbG9zZWYpOiB1dGlscy5ub29wIH0vPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICB7aGVhZGVyRiA/IDxoZWFkZXI+e2hlYWRlckYoKX08L2hlYWRlcj46IG51bGx9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjb250ZW50Q2xhc3N9PlxuICAgICAgICAgIHtjb250ZW50RigpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG4vLyBmdW5jdGlvbiBzdHlsZUNvbmYoZWwpIHtcbi8vICAgY29uc3QgdmggPSBoZWxwZXIudmlld3BvcnREaW0oKS52aDtcbi8vICAgY29uc3QgaCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbi8vICAgY29uc3QgdG9wID0gKHZoIC0gaCkgLyAyO1xuLy8gICAvLyBlbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuLy8gfVxuXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjbGFzc2VzLCBoZWFkZXJGLCBjb250ZW50RiwgaXNTaG93aW5nLCBjbG9zZUYpIHtcbi8vICAgaWYgKCFpc1Nob3dpbmcpIHJldHVybiBudWxsO1xuXG4vLyAgIGNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuLy8gICAgIG92ZXJsYXlfcG9wdXA6IHRydWUsXG4vLyAgICAgbmF0aXZlX3Njcm9sbGVyOiB0cnVlXG4vLyAgIH07XG5cbi8vICAgbGV0IGNsYXNzTmFtZTtcblxuLy8gICBpZiAodHlwZW9mIGNsYXNzZXMgPT09ICdvYmplY3QnKSB7XG4vLyAgICAgY2xhc3NOYW1lID0gaGVscGVyLmNsYXNzU2V0KE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDbGFzc2VzLCBjbGFzc2VzKSk7XG4vLyAgIH0gZWxzZSBpZiAodHlwZW9mIGNsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4vLyAgICAgY2xhc3NOYW1lID0gaGVscGVyLmNsYXNzU2V0KGRlZmF1bHRDbGFzc2VzKSArICcgJyArIGNsYXNzZXM7XG4vLyAgIH0gZWxzZVxuLy8gICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcG9wdXAgYXJndW1lbnQgbXVzdCBiZSBlaXRoZXIgc3RyaW5nIG9yIGFuIG9iamVjdCcpO1xuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJvdmVybGF5X3BvcHVwX3dyYXBwZXJcIj5cbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9wdXBfb3ZlcmxheV9jbG9zZVwiXG4vLyAgICAgICAgICAgIGNvbmZpZz17Y2xvc2VGID8gaGVscGVyLm9udG91Y2goaGVscGVyLmZhZGVzT3V0KGNsb3NlRiwgJy5vdmVybGF5X3BvcHVwX3dyYXBwZXInKSkgOiB1dGlscy5ub29wIH0gLz5cbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9IGNvbmZpZz17c3R5bGVDb25mfT5cbi8vICAgICAgICAge2hlYWRlckYgPyA8aGVhZGVyPntoZWFkZXJGKCl9PC9oZWFkZXI+IDogbnVsbCB9XG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9wdXBfY29udGVudFwiPlxuLy8gICAgICAgICAgIHtjb250ZW50RigpfVxuLy8gICAgICAgICA8L2Rpdj5cbi8vICAgICAgIDwvZGl2PlxuLy8gICAgIDwvZGl2PlxuLy8gICApO1xuLy8gfVxuIiwiaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgT2tleWdyb3VuZCBmcm9tICdva2V5Z3JvdW5kLW1vYmlsZSc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uLy4uL3JvdXRlcic7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgZ3JvdW5kIGZyb20gJy4vZ3JvdW5kJztcbmltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uLy4uL295dW5rZXlmL2dhbWUnO1xuaW1wb3J0IHNvY2tldEhhbmRsZXIgZnJvbSAnLi9zb2NrZXRIYW5kbGVyJztcbmltcG9ydCBDbG9ja0N0cmwgZnJvbSAnLi9jbG9jay9DbG9ja0N0cmwnO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4vcm91bmRYaHInO1xuXG5jb25zdCB7IHV0aWwgfSA9IE9rZXlncm91bmQ7XG5jb25zdCB7IHdyYXBHcm91cCwgd3JhcFBpZWNlLCB3cmFwRHJvcCwgcGFydGlhbCB9ID0gdXRpbDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gT25saW5lUm91bmQoaWQsIGNmZykge1xuICBjb25zdCBzZXREYXRhID0gKGNmZykgPT4ge1xuICAgIHRoaXMuZGF0YSA9IGNmZztcbiAgfTtcblxuICB0aGlzLm9uTW92ZSA9IChrZXksIHBpZWNlKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gT2tleWdyb3VuZC5tb3ZlLmRyYXdNaWRkbGUpIHtcbiAgICAgIHRoaXMuc2VuZE1vdmUoa2V5KTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gT2tleWdyb3VuZC5tb3ZlLmRpc2NhcmQpIHtcbiAgICAgIHRoaXMudm0uaGFzUGxheWVkRGlzY2FyZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBcbiAgdGhpcy5vblVzZXJNb3ZlID0gKGtleSwgbW92ZSkgPT4ge1xuICAgIC8vIFRPRE86IHdoeT9cbiAgICBpZiAoa2V5ID09PSBPa2V5Z3JvdW5kLm1vdmUubGVhdmVUYWtlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbmRNb3ZlKGtleSwgbW92ZSk7XG4gIH07XG5cbiAgdGhpcy5zZW5kTW92ZSA9IChrZXksIGFyZ3MgPSB7fSkgPT4ge1xuICAgIHZhciBtb3ZlID0gYXJncztcbiAgICBhcmdzLmtleSA9IGtleTtcblxuICAgIHNvY2tldC5zZW5kKCdtb3ZlJywgbW92ZSwge1xuICAgICAgYWNrYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuYXBpTW92ZSA9IChvKSA9PiB7XG4gICAgdmFyIGQgPSB0aGlzLmRhdGEsXG4gICAgICAgIHBsYXlpbmcgPSBnYW1lQXBpLmlzUGxheWVyUGxheWluZyhkKTtcblxuICAgIGQuZ2FtZS50dXJucyA9IG8ucGx5O1xuICAgIGQuZ2FtZS5wbGF5ZXIgPSBnYW1lQXBpLnNpZGVCeVBseShvLnBseSk7XG4gICAgZC5wb3NzaWJsZU1vdmVzID0gZC5wbGF5ZXIuc2lkZSA9PT0gZC5nYW1lLnBsYXllciA/IG8uZGVzdHMgOiBbXTtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgaWYgKG8uaXNNb3ZlKSB7XG4gICAgICAgIGlmIChvLmRyYXdtaWRkbGUpIHtcbiAgICAgICAgICB0aGlzLm9rZXlncm91bmQuYXBpTW92ZShvLmtleSwgd3JhcFBpZWNlKG8uZHJhd21pZGRsZS5waWVjZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKG8uZGlzY2FyZCkge1xuICAgICAgICAgIGlmICghdGhpcy52bS5oYXNQbGF5ZWREaXNjYXJkKSB7XG4gICAgICAgICAgICB0aGlzLm9rZXlncm91bmQuYXBpTW92ZShvLmtleSwgd3JhcFBpZWNlKG8uZGlzY2FyZC5waWVjZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52bS5oYXNQbGF5ZWREaXNjYXJkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoby5vcGVucykge1xuICAgICAgICAgIHRoaXMub2tleWdyb3VuZC5hcGlNb3ZlKG8ua2V5LCB3cmFwR3JvdXAoby5vcGVucy5ncm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG8uZHJvcCkge1xuICAgICAgICAgIHRoaXMub2tleWdyb3VuZC5hcGlNb3ZlKG8ua2V5LCB3cmFwRHJvcChvLmRyb3AucGllY2UsIG8uZHJvcC5wb3MpKTtcbiAgICAgICAgfSBlbHNlIGlmIChvLmtleSA9PT0gT2tleWdyb3VuZC5tb3ZlLmNvbGxlY3RPcGVuKSB7XG4gICAgICAgICAgdGhpcy5yZXN0b3JlRmVuKG8uZmVuLCBPa2V5Z3JvdW5kLm1vdmUuY29sbGVjdE9wZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG8ua2V5ID09PSBPa2V5Z3JvdW5kLm1vdmUubGVhdmVUYWtlbikge1xuICAgICAgICAgIHRoaXMub2tleWdyb3VuZC5hcGlNb3ZlKG8ua2V5LCB3cmFwUGllY2Uoby5sZWF2ZXRha2VuLnBpZWNlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5va2V5Z3JvdW5kLmFwaU1vdmUoby5rZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2tleWdyb3VuZC5zZXQoe1xuICAgICAgICB0dXJuU2lkZTogZC5nYW1lLnBsYXllcixcbiAgICAgICAgbW92YWJsZToge1xuICAgICAgICAgIGRlc3RzOiBwbGF5aW5nID8gZC5wb3NzaWJsZU1vdmVzIDogW11cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG8uY2xvY2spIHtcbiAgICAgIHZhciBjID0gby5jbG9jaztcbiAgICAgIGlmICh0aGlzLmNsb2NrKSB0aGlzLmNsb2NrLnNldENsb2NrKGQsIG8uY2xvY2suZWFzdCwgby5jbG9jay53ZXN0LCBvLmNsb2NrLnNvdXRoLCBvLmNsb2NrLm5vcnRoKTtcbiAgICB9XG5cbiAgICByZWRyYXcoKTtcbiAgfTtcblxuICB0aGlzLm91dG9mdGltZSA9IHRocm90dGxlKCgpID0+IHtcbiAgICBzb2NrZXQuc2VuZCgnb3V0b2Z0aW1lJywgdGhpcy5kYXRhLmdhbWUucGxheWVyKTtcbiAgfSwgNTAwKTtcblxuICB0aGlzLmVuZFdpdGhEYXRhID0gKHNjb3JlcykgPT4ge1xuICAgIHhoci5yZWxvYWQodGhpcykudGhlbih0aGlzLm9uUmVsb2FkKTtcbiAgfTtcblxuICB0aGlzLm9uUmVsb2FkID0gKHJDZmcpID0+IHtcbiAgICBzZXREYXRhKHJDZmcpO1xuXG4gICAgaWYgKCFnYW1lQXBpLnBsYXlhYmxlKHRoaXMuZGF0YSkpIHtcbiAgICAgIHRoaXMuc2hvd0FjdGlvbnMoKTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnNob3dBY3Rpb25zID0gKCkgPT4ge1xuICAgIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnB1c2godGhpcy5oaWRlQWN0aW9ucyk7XG4gICAgdGhpcy52bS5zaG93aW5nQWN0aW9ucyA9IHRydWU7XG4gIH07XG5cbiAgdGhpcy5oaWRlQWN0aW9ucyA9IChmcm9tQkIpID0+IHtcbiAgICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgdGhpcy52bS5zaG93aW5nQWN0aW9ucykgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4gICAgdGhpcy52bS5zaG93aW5nQWN0aW9ucyA9IGZhbHNlO1xuICB9O1xuICBcbiAgdGhpcy5pZCA9IGlkO1xuICBzZXREYXRhKGNmZyk7XG5cbiAgdGhpcy52bSA9IHtcbiAgICBzY29yZXNoZWV0SW5mbzoge31cbiAgfTtcbiAgXG4gIHRoaXMub2tleWdyb3VuZCA9IGdyb3VuZC5tYWtlKFxuICAgIHRoaXMuZGF0YSxcbiAgICB0aGlzLm9uVXNlck1vdmUsXG4gICAgdGhpcy5vbk1vdmVcbiAgKTtcblxuICB0aGlzLmNsb2NrID0gdGhpcy5kYXRhLmNsb2NrID8gbmV3IENsb2NrQ3RybCh0aGlzLmRhdGEsIHtcbiAgICBvbkZsYWc6IHRoaXMub3V0b2Z0aW1lXG4gIH0pIDogbnVsbDtcblxuICBpZiAodGhpcy5jbG9jaykge1xuICAgIGNvbnN0IHRpY2tOb3cgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNsb2NrICYmIHRoaXMuY2xvY2sudGljaygpO1xuICAgICAgaWYgKGdhbWVBcGkucGxheWFibGUodGhpcy5kYXRhKSkgdGhpcy5jbG9ja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGlja05vdywgMTAwKTtcbiAgICB9O1xuICAgIHRoaXMuY2xvY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRpY2tOb3csIDEwMCk7XG4gIH1cblxuICBzb2NrZXQuY3JlYXRlR2FtZShcbiAgICB0aGlzLmRhdGEudXJsLnNvY2tldCxcbiAgICB0aGlzLmRhdGEucGxheWVyLnZlcnNpb24sXG4gICAgc29ja2V0SGFuZGxlcih0aGlzKSxcbiAgICB0aGlzLmRhdGEudXJsLnJvdW5kKTtcblxuICB0aGlzLnVubG9hZCA9ICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9ja1RpbWVvdXRJZCk7XG4gIH07XG5cbiAgdGhpcy5sZWF2ZVRha2VuID0gKCkgPT4ge1xuICAgIHRoaXMuc2VuZE1vdmUoT2tleWdyb3VuZC5tb3ZlLmxlYXZlVGFrZW4pO1xuICB9O1xuICBcbiAgdGhpcy5vcGVuU2VyaWVzID0gKCkgPT4ge1xuICAgIHRoaXMub2tleWdyb3VuZC5wbGF5T3BlblNlcmllcygpO1xuICB9O1xuXG4gIHRoaXMub3BlblBhaXJzID0gKCkgPT4ge1xuICAgIHRoaXMub2tleWdyb3VuZC5wbGF5T3BlblBhaXJzKCk7XG4gIH07XG4gIFxuICB0aGlzLnNvcnRQYWlycyA9ICgpID0+IHtcbiAgICB0aGlzLm9rZXlncm91bmQuc29ydFBhaXJzKCk7XG4gIH07XG5cbiAgdGhpcy5zb3J0U2VyaWVzID0gKCkgPT4ge1xuICAgIHRoaXMub2tleWdyb3VuZC5zb3J0U2VyaWVzKCk7XG4gIH07XG5cbiAgdGhpcy5sZWF2ZVRha2VuID0gKCkgPT4ge1xuICAgIHRoaXMuc2VuZE1vdmUoT2tleWdyb3VuZC5tb3ZlLmxlYXZlVGFrZW4pO1xuICB9O1xuXG4gIHRoaXMuY29sbGVjdE9wZW4gPSAoKSA9PiB7XG4gICAgdGhpcy5zZW5kTW92ZShPa2V5Z3JvdW5kLm1vdmUuY29sbGVjdE9wZW4pO1xuICB9O1xuXG5cbiAgdGhpcy5yZXN0b3JlRmVuID0gKGZlbiwgaGludCkgPT4ge1xuICAgIHRoaXMub2tleWdyb3VuZC5zZXQoe1xuICAgICAgZmVuOiBmZW4sXG4gICAgICBhbmltYXRpb25IaW50OiBoaW50XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKCFnYW1lQXBpLnBsYXlhYmxlKHRoaXMuZGF0YSkpIHtcbiAgICB0aGlzLnNob3dBY3Rpb25zKCk7XG4gIH1cbiAgcmVkcmF3KCk7XG5cbn1cbiIsImltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uLy4uLy4uL295dW5rZXlmL2dhbWUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDbG9ja0N0cmwoZCwgb3B0cykge1xuXG4gIHRoaXMuc2V0Q2xvY2sgPSAoZCwgZWFzdCwgd2VzdCwgc291dGgsIG5vcnRoKSA9PiB7XG4gICAgY29uc3QgaXNDbG9ja1J1bm5pbmcgPSBnYW1lQXBpLnBsYXlhYmxlKGQpICYmXG4gICAgICAgICAgICAoZC5nYW1lLnR1cm5zID49IDQgfHwgKGQuY2xvY2sgJiYgZC5jbG9jay5ydW5uaW5nKSk7XG5cbiAgICB0aGlzLnRpbWVzID0ge1xuICAgICAgZWFzdDogZWFzdCAqIDEwMDAsXG4gICAgICB3ZXN0OiB3ZXN0ICogMTAwMCxcbiAgICAgIG5vcnRoOiBub3J0aCAqIDEwMDAsXG4gICAgICBzb3V0aDogc291dGggKiAxMDAwLFxuICAgICAgYWN0aXZlU2lkZTogaXNDbG9ja1J1bm5pbmcgPyBkLmdhbWUucGxheWVyIDogdW5kZWZpbmVkLFxuICAgICAgbGFzdFVwZGF0ZTogcGVyZm9ybWFuY2Uubm93KClcbiAgICB9O1xuICB9O1xuXG5cbiAgdGhpcy5vcHRzID0gb3B0cztcblxuICBjb25zdCBjZGF0YSA9IGQuY2xvY2s7XG5cbiAgdGhpcy5lbWVyZ01zID0gY2RhdGEuZW1lcmc7IC8vIDEwMDAgKiBNYXRoLm1pbig2MCwgTWF0aC5tYXgoMTAsIGNkYXRhLmVtZXJnICogLjEyNSkpO1xuXG4gIHRoaXMuc2V0Q2xvY2soZCwgY2RhdGEuc2lkZXMuZWFzdCwgY2RhdGEuc2lkZXMud2VzdCwgY2RhdGEuc2lkZXMuc291dGgsIGNkYXRhLnNpZGVzLm5vcnRoKTtcblxuICB0aGlzLmVsZW1lbnRzID0ge1xuICAgIGVhc3Q6IG51bGwsXG4gICAgd2VzdDogbnVsbCxcbiAgICBzb3V0aDogbnVsbCxcbiAgICBub3J0aDogbnVsbFxuICB9O1xuXG5cblxuICB0aGlzLnRpY2sgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2lkZSA9IHRoaXMudGltZXMuYWN0aXZlU2lkZTtcbiAgICBpZiAoIXNpZGUpIHJldHVybjtcblxuICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IG1pbGxpcyA9IHRoaXMudGltZXNbc2lkZV0gLSB0aGlzLmVsYXBzZWQobm93KTtcbiAgICBpZiAobWlsbGlzIDw9IDApIHRoaXMub3B0cy5vbkZsYWcoKTtcbiAgICBlbHNlIHRoaXMudXBkYXRlRWxlbWVudChzaWRlLCBtaWxsaXMpO1xuICB9O1xuXG4gIHRoaXMudXBkYXRlRWxlbWVudCA9IChzaWRlLCBtaWxsaXMpID0+IHtcbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudHNbc2lkZV07XG4gICAgaWYgKGVsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgKG1pbGxpcyAvIDMwMDAwKSAqIDEwMCkpICsgJyUnO1xuICAgICAgZWwuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIGlmIChtaWxsaXMgPCB0aGlzLmVtZXJnTXMgKiA0ICogMTAwMCkgZWwuY2xhc3NMaXN0LmFkZCgnZW1lcmcnKTtcbiAgICAgIGVsc2UgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZW1lcmcnKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5lbGFwc2VkID0gKG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpKSA9PiBNYXRoLm1heCgwLCBub3cgLSB0aGlzLnRpbWVzLmxhc3RVcGRhdGUpO1xuICBcbiAgdGhpcy5taWxsaXNPZiA9IChzaWRlKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMudGltZXMuYWN0aXZlU2lkZSA9PT0gc2lkZSA/XG4gICAgICBNYXRoLm1heCgwLCB0aGlzLnRpbWVzW3NpZGVdIC0gdGhpcy5lbGFwc2VkKCkpIDogdGhpcy50aW1lc1tzaWRlXTtcbiAgfTtcblxuICB0aGlzLmlzUnVubmluZyA9ICgpID0+IHRoaXMudGltZXMuYWN0aXZlU2lkZSAhPT0gdW5kZWZpbmVkO1xuXG59XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQoe2F0dHJzfSkge1xuICAgIGNvbnN0IHsgY3RybCwgc2lkZSB9ID0gYXR0cnM7XG5cbiAgICB0aGlzLmNsb2NrT25DcmVhdGUgPSAoe2RvbX0pID0+IHtcbiAgICAgIGN0cmwuZWxlbWVudHNbc2lkZV0gPSBkb207XG4gICAgICBjdHJsLnVwZGF0ZUVsZW1lbnQoc2lkZSwgY3RybC5taWxsaXNPZihzaWRlKSk7XG4gICAgfTtcbiAgICB0aGlzLmNsb2NrT25VcGRhdGUgPSAoe2RvbX0pID0+IHtcbiAgICAgIGN0cmwuZWxlbWVudHNbc2lkZV0gPSBkb207XG4gICAgICBjdHJsLnVwZGF0ZUVsZW1lbnQoc2lkZSwgY3RybC5taWxsaXNPZihzaWRlKSk7XG4gICAgfTtcbiAgfSxcblxuICB2aWV3KHthdHRyc30pIHtcblxuICAgIHJldHVybiBoKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2JhcicgfSwgW1xuICAgICAgaCgnc3BhbicsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYmFyMicsXG4gICAgICAgIG9uY3JlYXRlOiB0aGlzLmNsb2NrT25DcmVhdGUsXG4gICAgICAgIG9udXBkYXRlOiB0aGlzLmNsb2NrT25VcGRhdGVcbiAgICAgIH0pXG4gICAgXSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgZ2FtZUFwaSBmcm9tICcuLi8uLi8uLi9veXVua2V5Zi9nYW1lJztcbmltcG9ydCBPa2V5Z3JvdW5kIGZyb20gJ29rZXlncm91bmQtbW9iaWxlJztcblxuZnVuY3Rpb24gbWFrZUNvbmZpZyhkYXRhKSB7XG4gIGNvbnN0IGZlbiA9IGRhdGEuZ2FtZS5mZW47XG5cbiAgcmV0dXJuIHtcbiAgICBmZW4sXG4gICAgdHVyblNpZGU6IGRhdGEuZ2FtZS5wbGF5ZXIsXG4gICAgcG92U2lkZTogZGF0YS5wbGF5ZXIuc2lkZSxcbiAgICBzcGVjdGF0b3I6IGRhdGEucGxheWVyLnNwZWN0YXRvcixcbiAgICB3aXRoVG9yZTogISFkYXRhLmdhbWUudmFyaWFudC5rZXkubWF0Y2goL2R1em9rZXkvKSxcbiAgICBtb3ZhYmxlOiB7XG4gICAgICBmcmVlOiBmYWxzZSxcbiAgICAgIGJvYXJkOiBnYW1lQXBpLmlzUGxheWVyUGxheWluZyhkYXRhKSxcbiAgICAgIGRlc3RzOiBnYW1lQXBpLmlzUGxheWVyUGxheWluZyhkYXRhKSA/IGRhdGEucG9zc2libGVNb3ZlcyA6IFtdXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlKGRhdGEsIHVzZXJNb3ZlLCBvbk1vdmUpIHtcbiAgY29uc3QgY29uZmlnID0gbWFrZUNvbmZpZyhkYXRhKTtcbiAgY29uZmlnLm1vdmFibGUuZXZlbnRzID0ge1xuICAgIGFmdGVyOiB1c2VyTW92ZVxuICB9O1xuICBjb25maWcuZXZlbnRzID0ge1xuICAgIG1vdmU6IG9uTW92ZVxuICB9O1xuICBcbiAgcmV0dXJuIG5ldyBPa2V5Z3JvdW5kKGNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGVuZChncm91bmQpIHtcbiAgZ3JvdW5kLnN0b3AoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBtYWtlLFxuICBlbmRcbn07XG4iLCJpbXBvcnQgeyBmZXRjaEpTT04gfSBmcm9tICcuLi8uLi8uLi9odHRwJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbG9hZChjdHJsKSB7XG4gIHJldHVybiBmZXRjaEpTT04oY3RybC5kYXRhLnVybC5yb3VuZCk7XG59XG4iLCJpbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgZ2FtZUFwaSBmcm9tICcuLi8uLi8uLi9veXVua2V5Zi9nYW1lJztcbmltcG9ydCBncm91bmQgZnJvbSAnLi9ncm91bmQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjdHJsKSB7XG4gIGZ1bmN0aW9uIHJlbG9hZChvKSB7XG4gIH1cblxuICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICBjcm93ZChvKSB7XG4gICAgICBbJ2Vhc3QnLCAnd2VzdCcsICdub3J0aCcsICdzb3V0aCddLmZvckVhY2goKHNpZGUpID0+IHtcbiAgICAgICAgZ2FtZUFwaS5zZXRPbkdhbWUoY3RybC5kYXRhLCBzaWRlLCBvW3NpZGVdKTtcbiAgICAgIH0pO1xuICAgICAgcmVkcmF3KCk7XG4gICAgfSxcbiAgICBtb3ZlKG8pIHtcbiAgICAgIG8uaXNNb3ZlID0gdHJ1ZTtcbiAgICAgIGN0cmwuYXBpTW92ZShvKTtcbiAgICB9LFxuICAgIGVuZChzY29yZXMpIHtcbiAgICAgIGN0cmwuZGF0YS5nYW1lLnNjb3JlcyA9IHNjb3Jlcy5yZXN1bHQ7XG4gICAgICBncm91bmQuZW5kKGN0cmwub2tleWdyb3VuZCk7XG4gICAgICBjdHJsLmVuZFdpdGhEYXRhKHNjb3Jlcyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBoYW5kbGVycztcbn1cbiIsImltcG9ydCBpMThuIGZyb20gJy4uLy4uLy4uLy4uL2kxOG4nO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi8uLi8uLi9yb3V0ZXInO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uLy4uLy4uL2hlbHBlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmVzaWduKGN0cmwpIHtcbiAgICByZXR1cm4gaCgnYnV0dG9uJywge1xuICAgICAga2V5OiAncmVzaWduJyxcbiAgICAgIGNsYXNzTmFtZTogJ3Jlc2lnbicsXG4gICAgICAnZGF0YS1pY29uJzogJ2InLFxuICAgICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcChjdHJsLnJlc2lnbilcbiAgICB9LCBpMThuKCdyZXNpZ24nKSk7XG4gIH0sXG4gIHJldHVyblRvTWFzYShjdHJsKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgIGN0cmwuaGlkZUFjdGlvbnMoKTtcbiAgICAgIGNvbnN0IHVybCA9IGAvbWFzYS8ke2N0cmwuZGF0YS5nYW1lLm1hc2FJZH1gO1xuICAgICAgcm91dGVyLnNldCh1cmwsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4oXG4gICAgICAgIDxidXR0b24ga2V5PVwicmV0dXJuVG9NYXNhXCIgb25jcmVhdGU9e2hlbHBlci5vbnRhcChoYW5kbGVyKX0+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtdGhyb3BoeVwiLz5cbiAgICAgICAgICB7aTE4bignYmFja1RvTWFzYScpfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICApO1xuICB9LFxuICBvcGVuU2VyaWVzKGN0cmwpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBcIm9wZW4tc2VyaWVzXCI7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0ga2V5PVwib3BlblNlcmllc1wiXG4gICAgICBvbmNyZWF0ZT17aGVscGVyLm9udGFwKGN0cmwub3BlblNlcmllcyl9PntpMThuKCdvcGVuU2VyaWVzJyl9PC9idXR0b24+XG4gICAgKTtcbiAgfSxcbiAgb3BlblBhaXJzKGN0cmwpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBcIm9wZW4tcGFpcnNcIjtcbiAgICByZXR1cm4gKFxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBrZXk9XCJvcGVuUGFpcnNcIlxuICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLm9wZW5QYWlycyl9PntpMThuKCdvcGVuUGFpcnMnKX08L2J1dHRvbj5cbiAgICApO1xuICB9LFxuICBzb3J0UGFpcnMoY3RybCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IFwic29ydC1zZXJpZXNcIjsgICAgXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0ga2V5PVwic29ydFNlcmllc1wiXG4gICAgICBvbmNyZWF0ZT17aGVscGVyLm9udGFwKGN0cmwuc29ydFBhaXJzKX0+e2kxOG4oJ3NvcnRQYWlycycpfTwvYnV0dG9uPlxuICAgICk7XG4gIH0sXG4gIHNvcnRTZXJpZXMoY3RybCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IFwic29ydC1wYWlyc1wiO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGtleT1cInNvcnRTZXJpZXNcIlxuICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLnNvcnRTZXJpZXMpfT57aTE4bignc29ydFNlcmllcycpfTwvYnV0dG9uPlxuICAgICk7XG4gIH0sXG4gIGNvbGxlY3RPcGVuKGN0cmwpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBcImNvbGxlY3Qtb3BlblwiO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGtleT1cImNvbGxlY3RPcGVuXCJcbiAgICAgIG9uY3JlYXRlPXtoZWxwZXIub250YXAoY3RybC5jb2xsZWN0T3Blbil9PntpMThuKCdjb2xsZWN0T3BlbicpfTwvYnV0dG9uPlxuICAgICk7ICAgIFxuICB9LFxuICBsZWF2ZVRha2VuKGN0cmwpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBcImxlYXZlLXRha2VuXCI7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0ga2V5PVwibGVhdmVUYWtlblwiXG4gICAgICBvbmNyZWF0ZT17aGVscGVyLm9udGFwKGN0cmwubGVhdmVUYWtlbil9PntpMThuKCdsZWF2ZVRha2VuJyl9PC9idXR0b24+XG4gICAgKTsgICAgXG4gIH1cbn07XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uLy4uLy4uL2kxOG4nO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi8uLi8uLi9sYXlvdXQnO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi8uLi8uLi9zb2NrZXQnO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uLy4uLy4uL2hlbHBlcic7XG5pbXBvcnQgKiBhcyBwbGF5ZXJBcGkgZnJvbSAnLi4vLi4vLi4vLi4vb3l1bmtleWYvcGxheWVyJztcbmltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uLy4uLy4uL295dW5rZXlmL2dhbWUnO1xuaW1wb3J0IGdhbWVTdGF0dXNBcGkgZnJvbSAnLi4vLi4vLi4vLi4vb3l1bmtleWYvc3RhdHVzJztcblxuaW1wb3J0IHBvcHVwV2lkZ2V0IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9wb3B1cCc7XG5pbXBvcnQgQm9hcmQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0JvYXJkJztcbmltcG9ydCBHYW1lVGl0bGUgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL0dhbWVUaXRsZSc7XG5pbXBvcnQgZ2FtZUJ1dHRvbiBmcm9tICcuL2J1dHRvbic7XG5pbXBvcnQgQ2xvY2sgZnJvbSAnLi4vY2xvY2svY2xvY2tWaWV3JztcbmltcG9ydCB7IG1lbnVCdXR0b24sIGhlYWRlckJ0bnMsIGJhY2tCdXR0b24gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29tbW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlldyhjdHJsKSB7XG5cbiAgcmV0dXJuIGxheW91dC5ib2FyZChcbiAgICByZW5kZXJIZWFkZXIoY3RybCksXG4gICAgcmVuZGVyQ29udGVudChjdHJsKSxcbiAgICBvdmVybGF5KGN0cmwpKTtcblxufVxuXG5mdW5jdGlvbiBvdmVybGF5KGN0cmwpIHtcbiAgcmV0dXJuIFtcbiAgICByZW5kZXJHYW1lUG9wdXAoY3RybClcbiAgXTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyR2FtZVJ1bm5pbmdBY3Rpb25zKGN0cmwpIHtcbiAgY29uc3QgZ2FtZUNvbnRyb2xzID0gZ2FtZUJ1dHRvbi5yZXNpZ24oY3RybCk7XG4gIFxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2FtZV9jb250cm9sc1wiPlxuICAgICAge2dhbWVDb250cm9sc31cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyR2FtZUVuZGVkQWN0aW9ucyhjdHJsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdhbWVBcGkucmVzdWx0KGN0cmwuZGF0YSk7XG4gIGNvbnN0IHJlc3VsdERvbSA9IGdhbWVTdGF0dXNBcGkuYWJvcnRlZChjdHJsLmRhdGEpID8gW10gOiBbXG4gICAgaCgnc3Ryb25nJywgcmVzdWx0KSwgaCgnYnInKVxuICBdO1xuXG4gIGxldCBidXR0b25zO1xuICBjb25zdCBtYXNhSWQgPSBjdHJsLmRhdGEuZ2FtZS5tYXNhSWQ7XG4gIGlmIChtYXNhSWQpIHtcbiAgICBidXR0b25zID0gW1xuICAgICAgZ2FtZUJ1dHRvbi5yZXR1cm5Ub01hc2EoY3RybClcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImdhbWVfY29udHJvbHNcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbCBidXR0b25zXCI+e2J1dHRvbnN9PC9kaXY+ICBcbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU3RhdHVzKGN0cmwpIHtcbiAgY29uc3QgcmVzdWx0ID0gZ2FtZUFwaS5yZXN1bHQoY3RybC5kYXRhKTtcbiAgY29uc3Qgd2lubmVyID0gZ2FtZUFwaS5nZXRQbGF5ZXIoY3RybC5kYXRhLCBjdHJsLmRhdGEuZ2FtZS53aW5uZXIpO1xuICBjb25zdCBzdGF0dXMgPSBjdHJsLmRhdGEuZ2FtZS5zdGF0dXMubmFtZTtcbiAgXG4gIHJldHVybiAoZ2FtZVN0YXR1c0FwaS5hYm9ydGVkKGN0cmwuZGF0YSkgPyBbXSA6IFtcbiAgICBoKCdzdHJvbmcnLCByZXN1bHQpLCBoKCdicicpXG4gIF0pLmNvbmNhdChbaCgnZW0ucmVzdWx0U3RhdHVzJywgc3RhdHVzKV0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHYW1lUG9wdXAoY3RybCkge1xuICBjb25zdCBoZWFkZXIgPSAhZ2FtZUFwaS5wbGF5YWJsZShjdHJsLmRhdGEpID9cbiAgICAgICAgICAoKSA9PiByZW5kZXJTdGF0dXMoY3RybCkgOiB1bmRlZmluZWQ7XG4gIFxuICByZXR1cm4gcG9wdXBXaWRnZXQoXG4gICAgJ3BsYXllcl9jb250cm9scycsXG4gICAgaGVhZGVyLFxuICAgICgpID0+IGdhbWVBcGkucGxheWFibGUoY3RybC5kYXRhKSA/XG4gICAgICByZW5kZXJHYW1lUnVubmluZ0FjdGlvbnMoY3RybCkgOlxuICAgICAgcmVuZGVyR2FtZUVuZGVkQWN0aW9ucyhjdHJsKSxcbiAgICBjdHJsLnZtLnNob3dpbmdBY3Rpb25zLFxuICAgIGN0cmwuaGlkZUFjdGlvbnNcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySGVhZGVyKGN0cmwpIHtcbiAgbGV0IGNoaWxkcmVuO1xuXG4gIGNoaWxkcmVuID0gW1xuICAgIG1lbnVCdXR0b24oKSxcbiAgICByZW5kZXJUaXRsZShjdHJsKVxuICBdO1xuXG4gIGNoaWxkcmVuLnB1c2goaGVhZGVyQnRucygpKTtcblxuICByZXR1cm4gaCgnbmF2Jywge1xuICAgIGNsYXNzTmFtZTogc29ja2V0LmlzQ29ubmVjdGVkKCkgPyAnJzoncmVjb25uZWN0aW5nJ1xuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRpdGxlKGN0cmwpIHtcbiAgY29uc3QgZGF0YSA9IGN0cmwuZGF0YTtcbiAgY29uc3QgbWFzYSA9IGN0cmwuZGF0YS5tYXNhO1xuXG4gIHJldHVybiBoKEdhbWVUaXRsZSwge1xuICAgIGtleTogJ3BsYXlpbmctdGl0bGUnLFxuICAgIGRhdGE6IGN0cmwuZGF0YVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGVudChjdHJsKSB7XG4gIGNvbnN0IHBsYXllciA9IHJlbmRlclBsYXlUYWJsZShjdHJsLCBjdHJsLmRhdGEucGxheWVyLCAncGxheWVyJyk7XG4gIGNvbnN0IG9wcG9uZW50TGVmdCA9IHJlbmRlclBsYXlUYWJsZShjdHJsLCBjdHJsLmRhdGEub3Bwb25lbnRMZWZ0LCAnb3Bwb25lbnRMZWZ0Jyk7XG4gIGNvbnN0IG9wcG9uZW50UmlnaHQgPSByZW5kZXJQbGF5VGFibGUoY3RybCwgY3RybC5kYXRhLm9wcG9uZW50UmlnaHQsICdvcHBvbmVudFJpZ2h0Jyk7XG4gIGNvbnN0IG9wcG9uZW50VXAgPSByZW5kZXJQbGF5VGFibGUoY3RybCwgY3RybC5kYXRhLm9wcG9uZW50VXAsICdvcHBvbmVudFVwJyk7XG5cbiAgLy8gIGNvbnN0IGJvdW5kcyA9IGhlbHBlci5nZXRCb2FyZEJvdW5kcyhoZWxwZXIudmlld3BvcnREaW0oKSk7XG4gIFxuICBjb25zdCBib2FyZCA9IGgoQm9hcmQsIHtcbiAgICB2YXJpYW50OiBjdHJsLmRhdGEuZ2FtZS52YXJpYW50LmtleSxcbiAgICBva2V5Z3JvdW5kOiBjdHJsLm9rZXlncm91bmQsXG4gICAgICAvLyAgICBib3VuZHNcbiAgfSk7XG4gIFxuICByZXR1cm4gaC5mcmFnbWVudCh7fSwgW1xuICAgIHJlbmRlck1lbnVBY3Rpb25zQmFyKGN0cmwpLFxuICAgIHJlbmRlckdhbWVBY3Rpb25zQmFyUmlnaHQoY3RybCksXG4gICAgcGxheWVyLFxuICAgIG9wcG9uZW50TGVmdCxcbiAgICBvcHBvbmVudFJpZ2h0LFxuICAgIG9wcG9uZW50VXAsXG4gICAgYm9hcmQsXG4gIF0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHYW1lQWN0aW9uc0JhclJpZ2h0KGN0cmwpIHtcbiAgY29uc3QgbXlUdXJuID0gZ2FtZUFwaS5pc1BsYXllclR1cm4oY3RybC5kYXRhKTtcblxuICBjb25zdCBjYW5PcGVuU2VyaWVzID0gY3RybC5va2V5Z3JvdW5kLmNhbk9wZW5TZXJpZXMoKTtcbiAgY29uc3QgY2FuT3BlblBhaXJzID0gY3RybC5va2V5Z3JvdW5kLmNhbk9wZW5QYWlycygpO1xuICBjb25zdCBjYW5MZWF2ZVRha2VuID0gY3RybC5va2V5Z3JvdW5kLmNhbkxlYXZlVGFrZW4oKTtcblxuICBjb25zdCBjYW5Db2xsZWN0T3BlbiA9IGN0cmwub2tleWdyb3VuZC5jYW5Db2xsZWN0T3BlbigpO1xuXG4gIFxuICByZXR1cm4gKDxzZWN0aW9uIGNsYXNzTmFtZT1cImdhbWVfYWN0aW9uc19iYXIgcmlnaHRcIj5cbiAgICAgICAgICB7KGNhbkxlYXZlVGFrZW4pID8gZ2FtZUJ1dHRvbi5sZWF2ZVRha2VuKGN0cmwpIDogbnVsbCB9XG4gICAgICAgICAgeyhjYW5PcGVuUGFpcnMpID8gZ2FtZUJ1dHRvbi5vcGVuUGFpcnMoY3RybCkgOiBnYW1lQnV0dG9uLnNvcnRQYWlycyhjdHJsKSB9XG4gICAgICAgICAgeyhjYW5PcGVuU2VyaWVzKSA/IGdhbWVCdXR0b24ub3BlblNlcmllcyhjdHJsKSA6IGdhbWVCdXR0b24uc29ydFNlcmllcyhjdHJsKSB9XG4gICAgICAgICAgeyhjYW5Db2xsZWN0T3BlbikgPyBnYW1lQnV0dG9uLmNvbGxlY3RPcGVuKGN0cmwpIDogbnVsbH1cbiAgICAgICAgICA8L3NlY3Rpb24+KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVudUFjdGlvbnNCYXIoY3RybCkge1xuICBjb25zdCBnbUNsYXNzID0gW1xuICAgICdmYScsICdmYS1lbGxpcHNpcy12J1xuICBdLmpvaW4oJyAnKTtcbiAgXG4gIGNvbnN0IGdtQnV0dG9uID0gPGJ1dHRvbiBjbGFzc05hbWU9e2dtQ2xhc3N9IGtleT1cImdhbWVNZW51XCIgb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLnNob3dBY3Rpb25zKX0vPjtcblxuICByZXR1cm4gKDxzZWN0aW9uIGNsYXNzTmFtZT1cIm1lbnVfYWN0aW9uc19iYXJcIj5cbiAgICAgICAgICB7YmFja0J1dHRvbigpfVxuICAgICAgICAgIHtnbUJ1dHRvbn1cbiAgICAgICAgICA8L3NlY3Rpb24+KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGxheVRhYmxlKGN0cmwsIHBsYXllciwgcG9zaXRpb24pIHtcbiAgXG4gIGNvbnN0IGNsYXNzTiA9ICdwbGF5VGFibGUgJyArIHBvc2l0aW9uO1xuXG4gIHJldHVybiAoXG4gICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e2NsYXNzTn0+XG4gICAgICB7cmVuZGVyQW50YWdvbmlzdEluZm8oY3RybCwgcGxheWVyLCBwb3NpdGlvbil9XG4gICAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFudGFnb25pc3RJbmZvKGN0cmwsIHBsYXllciwgcG9zaXRpb24pIHtcbiAgLy8gY29uc3QgcnVubmluZ1NpZGUgPSBjdHJsLmlzQ2xvY2tSdW5uaW5nKCkgPyBjdHJsLmRhdGEuZ2FtZS5wbGF5ZXIgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHJ1bm5pbmcgPSBjdHJsLmRhdGEuZ2FtZS5wbGF5ZXIgPT09IHBsYXllci5zaWRlO1xuICBjb25zdCB1c2VyID0gcGxheWVyLnVzZXI7XG4gIGNvbnN0IHBsYXllck5hbWUgPSBwbGF5ZXJBcGkucGxheWVyTmFtZShwbGF5ZXIpO1xuXG4gIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17J2FudGFnb25pc3RJbmZvcyd9PlxuICAgICAgICA8aDIgY2xhc3NOYW1lPXsnYW50YWdvbmlzdFVzZXInfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXsnZmEgZmEtY2lyY2xlIHN0YXR1cyAnICsgKChwbGF5ZXIuYWkgfHwgcGxheWVyLm9uR2FtZSkgPyAnb25nYW1lJyA6ICdvZmZnYW1lJyl9Lz5cbiAgICAgICAgICB7cGxheWVyTmFtZX1cbiAgICAgICAgPC9oMj5cbiAgICAgIHtydW5uaW5nID8gcmVuZGVyQ2xvY2soY3RybC5jbG9jaywgcGxheWVyLnNpZGUpOm51bGx9XG4gICAgICA8L2Rpdj5cbiAgKTtcblxufVxuXG5mdW5jdGlvbiByZW5kZXJDbG9jayhjdHJsLCBzaWRlLCBydW5uaW5nU2lkZSkge1xuICByZXR1cm4gaChDbG9jaywge1xuICAgIGN0cmwsXG4gICAgc2lkZSxcbiAgICBydW5uaW5nU2lkZVxuICB9KTtcbn1cbiIsImltcG9ydCBaYW5pbW8gZnJvbSAnemFuaW1vJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vLi4vLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vLi4vcm91dGVyJztcblxuaW1wb3J0IHsgQkFDS0RST1BfT1BBQ0lUWSB9IGZyb20gJy4nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaWRlTWVudUN0cmwoc2lkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3BJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk9wZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZSkge1xuICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMuc2lkZSA9IHNpZGU7XG4gIHRoaXMubWVudUlEID0gbWVudUlEO1xuICB0aGlzLmJhY2tkcm9wSUQgPSBiYWNrZHJvcElEO1xuICB0aGlzLm9uT3BlbiA9IG9uT3BlbjtcbiAgdGhpcy5vbkNsb3NlID0gb25DbG9zZTtcblxuXG4gIHRoaXMub3BlbiA9ICgpID0+IHtcbiAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaCh0aGlzLmNsb3NlKTtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMubWVudUlEKTtcbiAgICBjb25zdCBiZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuYmFja2Ryb3BJRCk7XG4gICAgaWYgKHRoaXMub25PcGVuKSB0aGlzLm9uT3BlbigpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBaYW5pbW8oYmQsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnLCAwKSxcbiAgICAgIFphbmltbyhiZCwgJ29wYWNpdHknLCBCQUNLRFJPUF9PUEFDSVRZLCAyNTAsICdsaW5lYXInKSxcbiAgICAgIFphbmltbyhlbCwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScsIDApLFxuICAgICAgWmFuaW1vKFxuICAgICAgICBlbCxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICd0cmFuc2xhdGUzZCgwLDAsMCknLCAyNTAsICdlYXNlLW91dCdcbiAgICAgIClcbiAgICAgIFxuICAgIF0pLnRoZW4ocmVkcmF3KVxuICAgICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO1xuICB9O1xuXG4gIHRoaXMuY2xvc2UgPSAoZnJvbUJCKSA9PiB7XG4gICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIHRoaXMuaXNPcGVuKSByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tZW51SUQpO1xuICAgIGNvbnN0IGJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5iYWNrZHJvcElEKTtcbiAgICBpZiAodGhpcy5vbkNsb3NlKSB0aGlzLm9uQ2xvc2UoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgWmFuaW1vKGJkLCAnb3BhY2l0eScsIDAsIDI1MCwgJ2xpbmVhcicpLFxuICAgICAgWmFuaW1vKFxuICAgICAgICBlbCxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgIHRoaXMuY2xvc2VUcmFuc2xhdGUoKSwgMjUwLCAnZWFzZS1vdXQnKVxuICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBaYW5pbW8oZWwsICd2aXNpYmlsaXR5JywgJ2hpZGRlbicsIDApLFxuICAgICAgICBaYW5pbW8oYmQsICd2aXNpYmlsaXR5JywgJ2hpZGRlbicsIDApLFxuICAgICAgXSk7XG4gICAgfSkuY2F0Y2goY29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7XG4gIH07XG5cbiAgdGhpcy50b2dnbGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKSB0aGlzLmNsb3NlKCk7XG4gICAgZWxzZSB0aGlzLm9wZW4oKTtcbiAgfTtcbiAgXG4gIHRoaXMuY2xvc2VUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc2lkZSA9PT0gJ2xlZnQnID8gJ3RyYW5zbGF0ZTNkKC0xMDAlLDAsMCknOid0cmFuc2xhdGUzZCgxMDAlLDAsMCknO1xuICB9O1xuXG59O1xuIiwiZXhwb3J0IGNvbnN0IEJBQ0tEUk9QX09QQUNJVFkgPSAwLjc7XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vc29ja2V0JztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uL3Nlc3Npb24nO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IGxvZ2luTW9kYWwgZnJvbSAnLi9sb2dpbk1vZGFsJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uL2JhY2tidXR0b24nO1xuaW1wb3J0IHsgY2xvc2VJY29uIH0gZnJvbSAnLi9zaGFyZWQvaWNvbnMnO1xuXG5sZXQgaXNPcGVuID0gZmFsc2U7XG5sZXQgbG9hZGluZyA9IGZhbHNlO1xuXG5sZXQgZm9ybUVycm9yID0gbnVsbDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvcGVuLFxuICBjbG9zZSxcbiAgdmlldygpIHtcbiAgICBpZiAoIWlzT3BlbikgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gaCgnZGl2Lm1vZGFsI3NpZ251cE1vZGFsJywgeyBvbmNyZWF0ZTogaGVscGVyLnNsaWRlc0luVXAgfSwgW1xuICAgICAgaCgnaGVhZGVyJywgW1xuICAgICAgICBoKCdidXR0b24ubW9kYWxfY2xvc2UnLCB7XG4gICAgICAgICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcChoZWxwZXIuc2xpZGVzT3V0RG93bihjbG9zZSwgJ3NpZ251cE1vZGFsJykpXG4gICAgICAgIH0sIGNsb3NlSWNvbiksXG4gICAgICAgIGgoJ2gyJywgaTE4bignc2lnblVwJykpXG4gICAgICBdKSxcbiAgICAgIGgoJ2RpdiNzaWdudXBNb2RhbENvbnRlbnQubW9kYWxfY29udGVudCcsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBsb2FkaW5nID8gJ2xvYWRpbmcnIDogJydcbiAgICAgIH0sIHJlbmRlckZvcm0oKSlcbiAgICBdKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVuZGVyRm9ybSgpIHtcbiAgcmV0dXJuIFtcbiAgICBoKCdmb3JtLmxvZ2luJywge1xuICAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gc3VibWl0KGUudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LCBbXG4gICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgIGZvcm1FcnJvciAmJiBmb3JtRXJyb3IudXNlcm5hbWUgP1xuICAgICAgICAgIGgoJ2Rpdi5mb3JtLWVycm9yJywgZm9ybUVycm9yLnVzZXJuYW1lWzBdKSA6IG51bGwsXG4gICAgICAgIGgoJ2lucHV0I3BzZXVkb1t0eXBlPXRleHRdJywge1xuICAgICAgICAgIGNsYXNzTmFtZTogZm9ybUVycm9yICYmIGZvcm1FcnJvci51c2VybmFtZSA/ICdmb3JtLWVycm9yJzogJycsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4gICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsXG4gICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgICAgIHNwZWxsY2hlY2s6IGZhbHNlLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgIG9uZm9jdXM6IHNjcm9sbFRvVG9wXG4gICAgICAgIH0pLFxuICAgICAgXSksXG4gICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgIGZvcm1FcnJvciAmJiBmb3JtRXJyb3IuZW1haWwgP1xuICAgICAgICAgIGgoJ2Rpdi5mb3JtLWVycm9yJywgZm9ybUVycm9yLmVtYWlsWzBdKTogbnVsbCxcbiAgICAgICAgaCgnaW5wdXQjZW1haWxbdHlwZT1lbWFpbF0nLCB7XG4gICAgICAgICAgb25mb2N1czogc2Nyb2xsVG9Ub3AsXG4gICAgICAgICAgY2xhc3NOYW1lOiBmb3JtRXJyb3IgJiYgZm9ybUVycm9yLmVtYWlsID8gJ2Zvcm0tZXJyb3InIDogJycsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ2VtYWlsJyksXG4gICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuICAgICAgICAgIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbiAgICAgICAgICBzcGVsbGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgIGZvcm1FcnJvciAmJiBmb3JtRXJyb3IucGFzc3dvcmQgP1xuICAgICAgICAgIGgoJ2Rpdi5mb3JtLWVycm9yJywgZm9ybUVycm9yLnBhc3N3b3JkWzBdKSA6IG51bGwsXG4gICAgICAgIGgoJ2lucHV0I3Bhc3N3b3JkW3R5cGU9cGFzc3dvcmRdJywge1xuICAgICAgICAgIG9uZm9jdXM6IHNjcm9sbFRvVG9wLFxuICAgICAgICAgIGNsYXNzTmFtZTogZm9ybUVycm9yICYmIGZvcm1FcnJvci5wYXNzd29yZCA/ICdmb3JtLWVycm9yJyA6ICcnLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdwYXNzd29yZCcpLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICBdKSxcbiAgICAgIGgoJ2Rpdi5zdWJtaXQnLCBbXG4gICAgICAgIGgoJ2J1dHRvbi5zdWJtaXRCdXR0b25bZGF0YS1pY29uPUZdJywgaTE4bignc2lnblVwJykpXG4gICAgICBdKVxuICAgIF0pXG4gIF07XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFRvVG9wKGUpIHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBlLnRhcmdldDtcbiAgICBlbC5zY3JvbGxJbnRvVmlldyh0cnVlKTtcbiAgfSwgMzAwKTtcbn1cblxuZnVuY3Rpb24gc3VibWl0KGZvcm0pIHtcbiAgY29uc3QgbG9naW4gPSBmb3JtWzBdLnZhbHVlLnRyaW0oKTtcbiAgY29uc3QgZW1haWwgPSBmb3JtWzFdLnZhbHVlLnRyaW0oKTtcbiAgY29uc3QgcGFzcyA9IGZvcm1bMl0udmFsdWUudHJpbSgpO1xuICBpZiAoIWxvZ2luIHx8ICFlbWFpbCB8fCAhcGFzcykgcmV0dXJuO1xuICB3aW5kb3cuS2V5Ym9hcmQuaGlkZSgpO1xuICBsb2FkaW5nID0gdHJ1ZTtcbiAgZm9ybUVycm9yID0gbnVsbDtcbiAgcmVkcmF3KCk7XG4gIHNlc3Npb24uc2lnbnVwKGxvZ2luLCBlbWFpbCwgcGFzcylcbiAgICAudGhlbihkID0+IHtcbiAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bignbG9naW5TdWNjZXNzZnVsJyksICdzaG9ydCcsICdjZW50ZXInKTtcbiAgICAgIHNvY2tldC5yZWNvbm5lY3RDdXJyZW50KCk7XG4gICAgICByZWRyYXcoKTtcbiAgICAgIGxvZ2luTW9kYWwuY2xvc2UoKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBpZiAoaXNTdWJtaXRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBmb3JtRXJyb3IgPSBlcnJvci5ib2R5LmVycm9yO1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVhockVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXNTdWJtaXRFcnJvcihlcnIpIHtcbiAgcmV0dXJuIGVyci5ib2R5LmVycm9yICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG9wZW4oKSB7XG4gIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24oY2xvc2UsICdzaWdudXBNb2RhbCcpKTtcbiAgZm9ybUVycm9yID0gbnVsbDtcbiAgaXNPcGVuID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2xvc2UoZnJvbUJCKSB7XG4gIHdpbmRvdy5LZXlib2FyZC5oaWRlKCk7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBpc09wZW4gPSBmYWxzZTtcbn1cblxuLy8gY29uc3Qgc2lnbnVwTW9kYWwgPSB7fTtcblxuLy8gdmFyIGlzT3BlbiA9IGZhbHNlO1xuXG4vLyBmdW5jdGlvbiBzdWJtaXQoZm9ybSkge1xuLy8gICB2YXIgbG9naW4gPSBmb3JtWzBdLnZhbHVlLnRyaW0oKTtcbi8vICAgdmFyIGVtYWlsID0gZm9ybVsxXS52YWx1ZS50cmltKCk7XG4vLyAgIHZhciBwYXNzID0gZm9ybVsyXS52YWx1ZS50cmltKCk7XG4vLyAgIGlmICghbG9naW4gfHwgIWVtYWlsIHx8ICFwYXNzKSByZXR1cm4gZmFsc2U7XG4vLyAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuY2xvc2UoKTtcbi8vICAgcmV0dXJuIHNlc3Npb24uc2lnbnVwKGxvZ2luLCBlbWFpbCwgcGFzcykudGhlbihmdW5jdGlvbigpIHtcbi8vICAgICBzaWdudXBNb2RhbC5jbG9zZSgpO1xuLy8gICAgIGxvZ2luTW9kYWwuY2xvc2UoKTtcbi8vICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ2xvZ2luU3VjY2Vzc2Z1bGwnKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICB9LCBmdW5jdGlvbihlcnJvcikge1xuLy8gICAgIHZhciBkYXRhID0gZXJyb3IucmVzcG9uc2U7XG4vLyAgICAgaWYgKGRhdGEuZXJyb3IudXNlcm5hbWUpIHtcbi8vICAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coZGF0YS5lcnJvci51c2VybmFtZVswXSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvci5wYXNzd29yZCkge1xuLy8gICAgICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhkYXRhLmVycm9yLnBhc3N3b3JkWzBdLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4vLyAgICAgfVxuLy8gICB9KTtcbi8vIH1cblxuLy8gc2lnbnVwTW9kYWwub3BlbiA9IGZ1bmN0aW9uKCkge1xuLy8gICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24oc2lnbnVwTW9kYWwuY2xvc2UsICdzaWdudXBNb2RhbCcpKTtcbi8vICAgaXNPcGVuID0gdHJ1ZTtcbi8vIH07XG5cbi8vIHNpZ251cE1vZGFsLmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4vLyAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuY2xvc2UoKTtcbi8vICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbi8vICAgaXNPcGVuID0gZmFsc2U7XG4vLyB9O1xuXG4vLyBzaWdudXBNb2RhbC52aWV3ID0gZnVuY3Rpb24oKSB7XG4vLyAgIGlmICghaXNPcGVuKSByZXR1cm4gbnVsbDtcblxuLy8gICByZXR1cm4gbSgnZGl2Lm1vZGFsI3NpZ251cE1vZGFsJywgeyBjb25maWc6IGhlbHBlci5zbGlkZXNJblVwIH0sIFtcbi8vICAgICBtKCdoZWFkZXInLCBbXG4vLyAgICAgICBtKCdidXR0b24ubW9kYWxfY2xvc2VbZGF0YS1pY29uPUxdJywge1xuLy8gICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKGhlbHBlci5zbGlkZXNPdXREb3duKHNpZ251cE1vZGFsLmNsb3NlLCAnc2lnbnVwTW9kYWwnKSlcbi8vICAgICAgIH0pLFxuLy8gICAgICAgbSgnaDInLCBpMThuKCdzaWduVXAnKSlcbi8vICAgICBdKSxcbi8vICAgICBtKCdkaXYubW9kYWxfY29udGVudCcsIFtcbi8vICAgICAgIG0oJ3Auc2lnbnVwV2FybmluZy53aXRoSWNvbltkYXRhLWljb249IV0nLCBbXG4vLyAgICAgICAgIGkxOG4oJ2NvbXB1dGVyc0FyZU5vdEFsbG93ZWRUb1BsYXknKVxuLy8gICAgICAgXSksXG4vLyAgICAgICBtKCdwLnRvc1dhcm5pbmcnLCBbXG4vLyAgICAgICAgIGkxOG4oJ2J5UmVnaXN0ZXJpbmdZb3VBZ3JlZVRvQmVCb3VuZEJ5T3VyJyksXG4vLyAgICAgICAgIG0oJ2EnLCB7XG4vLyAgICAgICAgIH0sIGkxOG4oJ3Rlcm1zT2ZTZXJ2aWNlJykpLCAnLidcbi8vICAgICAgIF0pLFxuLy8gICAgICAgbSgnZm9ybS5sb2dpbicsIHtcbi8vICAgICAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbi8vICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4vLyAgICAgICAgICAgcmV0dXJuIHN1Ym1pdChlLnRhcmdldCk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0sIFtcbi8vICAgICAgICAgbSgnaW5wdXQjcHNldWRvW3R5cGU9dGV4dF0nLCB7XG4vLyAgICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4vLyAgICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbi8vICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsXG4vLyAgICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuLy8gICAgICAgICAgIHNwZWxsY2hlY2s6ICdmYWxzZScsXG4vLyAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbi8vICAgICAgICAgfSksXG4vLyAgICAgICAgIG0oJ2lucHV0I2VtYWlsW3R5cGU9ZW1haWxdJywge1xuLy8gICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdlbWFpbCcpLFxuLy8gICAgICAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4vLyAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuLy8gICAgICAgICAgIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbi8vICAgICAgICAgICBzcGVsbGNoZWNrOiAnZmFsc2UnLFxuLy8gICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4vLyAgICAgICAgIH0pLFxuLy8gICAgICAgICBtKCdpbnB1dCNwYXNzd29yZFt0eXBlPXBhc3N3b3JkXScsIHtcbi8vICAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bigncGFzc3dvcmQnKSxcbi8vICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuLy8gICAgICAgICB9KSxcbi8vICAgICAgICAgbSgnYnV0dG9uLmZhdCcsIGkxOG4oJ3NpZ25VcCcpKVxuLy8gICAgICAgXSlcbi8vICAgICBdKVxuLy8gICBdKTtcbi8vIH07XG5cbi8vIGV4cG9ydCBkZWZhdWx0IHNpZ251cE1vZGFsO1xuIiwiaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSAnLi91c2VyQ3RybCc7XG5pbXBvcnQgdmlldyBmcm9tICcuL3VzZXJWaWV3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb250cm9sbGVyLFxuICB2aWV3XG59O1xuIiwiaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi91c2VyWGhyJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vc29ja2V0JztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250cm9sbGVyKCkge1xuICBzb2NrZXQuY3JlYXRlRGVmYXVsdCgpO1xuXG4gIGNvbnN0IHVzZXIgPSBtLnByb3AoKTtcblxuICB4aHIudXNlcihtLnJvdXRlLnBhcmFtKCdpZCcpKS50aGVuKHVzZXIsIGVycm9yID0+IHtcbiAgICB1dGlscy5oYW5kbGVYaHJFcnJvcihlcnJvcik7XG4gICAgbS5yb3V0ZSgnLycpO1xuICB9KS50aGVuKHNlc3Npb24ucmVmcmVzaCk7XG5cbiAgcmV0dXJuIHtcbiAgICB1c2VyLFxuICAgIGlzTWU6ICgpID0+IHNlc3Npb24uZ2V0VXNlcklkKCkgPT09IHVzZXIoKS5pZFxuICB9O1xufVxuIiwiLy8gaW1wb3J0IHVzZXJQZXJmcyBmcm9tICcuLi8uLi9veXVua2V5Zi9wZXJmcyc7XG5pbXBvcnQgcGVyZiBmcm9tICcuLi9zaGFyZWQvcGVyZic7XG5pbXBvcnQgeyBoZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uLy4uL3Nlc3Npb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2aWV3KGN0cmwpIHtcbiAgY29uc3QgdXNlciA9IGN0cmwudXNlcigpO1xuXG4gIGlmICghdXNlcikgcmV0dXJuIG51bGw7XG5cbiAgZnVuY3Rpb24gaGVhZGVyKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdXNlci51c2VybmFtZTtcbiAgICByZXR1cm4gaGVhZGVyV2lkZ2V0KG51bGwsIGJhY2tCdXR0b24odGl0bGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2ZpbGUoKSB7XG4gICAgLy8gVE9ET1xuICAgIC8vIHN0YXRzXG4gICAgLy8gcmF0aW5nc1xuICAgIC8vIGFjdGlvbnNcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD1cInVzZXJQcm9maWxlXCIgY2xhc3NOYW1lPVwibmF0aXZlX3Njcm9sbGVyIHBhZ2VcIj5cbiAgICAgICAge3JlbmRlclN0YXR1cyh1c2VyKX1cbiAgICAgICAge3JlbmRlclByb2ZpbGUodXNlcil9XG4gICAgICAgIHtyZW5kZXJSYXRpbmdzKHVzZXIpfVxuICAgICAgICB7cmVuZGVyQWN0aW9ucyhjdHJsKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCBwcm9maWxlKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU3RhdHVzKHVzZXIpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlci5vbmxpbmUgPyAnb25saW5lJyA6ICdvZmZsaW5lJztcbiAgcmV0dXJuIChcbiAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJvbmxpbmVTdGF0dXNcIj5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17J3VzZXJTdGF0dXMgJyArIHN0YXR1c30gZGF0YS1pY29uPSdyJyAvPlxuICAgICAge2kxOG4oc3RhdHVzKX1cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclByb2ZpbGUodXNlcikge1xuICBpZiAoIXVzZXIucHJvZmlsZSkgcmV0dXJuIG51bGw7XG4gIFxuICBsZXQgZnVsbE5hbWUgPSAnJztcbiAgaWYgKHVzZXIucHJvZmlsZS5maXJzdE5hbWUpIGZ1bGxOYW1lICs9IHVzZXIucHJvZmlsZS5maXJzdE5hbWU7XG4gIGlmICh1c2VyLnByb2ZpbGUubGFzdE5hbWUpIGZ1bGxOYW1lICs9ICh1c2VyLnByb2ZpbGUuZmlyc3ROYW1lID8gJyAnIDonJykgKyB1c2VyLnByb2ZpbGUubGFzdE5hbWU7XG4gIC8vIGNvbnN0IGNvdW50cnkgPSBjb3VudHJpZXNbdXNlci5wcm9maWxlLmNvdW50cnldO1xuICBjb25zdCBsb2NhdGlvbiA9IHVzZXIucHJvZmlsZS5sb2NhdGlvbjtcbiAgY29uc3QgbWVtYmVyU2luY2UgPSBpMThuKCdtZW1iZXJTaW5jZScpICsgJyAnICsgd2luZG93Lm1vbWVudCh1c2VyLmNyZWF0ZWRBdCkuZm9ybWF0KCdMTCcpO1xuICBjb25zdCBzZWVuQXQgPSB1c2VyLnNlZW5BdCA/IGkxOG4oJ2xhc3RMb2dpbicpICsgJyAnICsgd2luZG93Lm1vbWVudCh1c2VyLnNlZW5BdCkuY2FsZW5kYXIoKSA6IG51bGw7XG5cbiAgcmV0dXJuIChcbiAgICA8c2VjdGlvbiBjbGFzc25hbWU9XCJwcm9maWxlXCI+XG4gICAgICB7ZnVsbE5hbWUgP1xuICAgICAgIDxoMyBjbGFzc05hbWU9XCJmdWxsbmFtZVwiPntmdWxsTmFtZX08L2gzPjogbnVsbFxuICAgICAgfVxuICAgICAge3VzZXIucHJvZmlsZS5iaW8gP1xuICAgICAgIDxwIGNsYXNzTmFtZT1cInByb2ZpbGVCaW9cIj57dXNlci5wcm9maWxlLmJpb308L3A+OiBudWxsXG4gICAgICB9XG4gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1c2VySW5mb3NcIj5cbiAgICAgICAgIHtcbiAgICAgICAgICAgdXNlci5sYW5ndWFnZSA/XG4gICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImxhbmd1YWdlIHdpdGhJY29uXCI+XG4gICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtY29tbWVudC1vXCI+XG4gICAgICAgICAgICAgICB7Z2V0TGFuZ3VhZ2VOYXRpdmVOYW1lKHVzZXIubGFuZ3VhZ2UpfVxuICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgPC9wPiA6IG51bGxcbiAgICAgICAgIH1cbiAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibG9jYXRpb25cIj57bG9jYXRpb259PC9wPlxuICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtZW1iZXJTaW5jZVwiPnttZW1iZXJTaW5jZX08L3A+XG4gICAgICAgICAgIHtzZWVuQXQgP1xuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibGFzdFNlZW5cIj57c2VlbkF0fTwvcD46IG51bGxcbiAgICAgICAgICAgfVxuICAgICAgIDwvZGl2PlxuICAgIDwvc2VjdGlvbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUmF0aW5ncyh1c2VyKSB7XG4gIGZ1bmN0aW9uIGlzU2hvd2luZyhwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICd5dXpiaXInLCAnZHV6b2tleSdcbiAgICBdLmluZGV4T2YocC5rZXkpIT09IC0xIHx8IHAucGVyZi5nYW1lcyA+IDA7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxzZWN0aW9uIGlkPVwidXNlclByb2ZpbGVSYXRpbmdzXCIgY2xhc3NOYW1lPVwicGVyZnNcIj5cbiAgICAgIC8vIHt1c2VyUGVyZnModXNlcikuZmlsdGVyKGlzU2hvd2luZykubWFwKHAgPT4gcGVyZihwLmtleSwgcC5uYW1lLCBwLnBlcmYsIHVzZXIpKX1cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFjdGlvbnMoY3RybCkge1xuICBjb25zdCB1c2VyID0gY3RybC51c2VyKCk7XG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gaWQ9XCJ1c2VyUHJvZmlsZUFjdGlvbnNcIiBjbGFzcz1cIm5vUGFkZGluZ1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJsaXN0X2l0ZW1fbmF2XCJcbiAgICAgICAgICAgY29uZmlnPXtoZWxwZXIub250b3VjaFkoY3RybC5nb1RvR2FtZXMpfVxuICAgICAgICAgICBrZXk9XCJ2aWV3X2FsbF9nYW1lc1wiPlxuICAgICAgICB7aTE4bigndmlld0FsbE5iR2FtZXMnLCB1c2VyLmNvdW50LmFsbCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG4iLCJpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi4vLi4vaHR0cCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VyKGlkKSB7XG4gIHZhciB1cmwgPSAnL2FwaS91c2VyLycgKyBpZDtcbiAgcmV0dXJuIHJlcXVlc3QodXJsLCB7fSwgdHJ1ZSk7XG59XG4iLCJsZXQgZm9yZWdyb3VuZCA9IHRydWU7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZvcmVncm91bmQoKSB7XG4gIHJldHVybiBmb3JlZ3JvdW5kO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Rm9yZWdyb3VuZCgpIHtcbiAgZm9yZWdyb3VuZCA9IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRCYWNrZ3JvdW5kKCkge1xuICBmb3JlZ3JvdW5kID0gZmFsc2U7XG59XG4iLCJsZXQgY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGJhdGNoaW5nID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXRjaFJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBjYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgaWYgKCFiYXRjaGluZykge1xuICAgIGJhdGNoaW5nID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRzKSA9PiB7XG4gICAgICBjb25zdCBiYXRjaCA9IGNhbGxiYWNrcztcbiAgICAgIGJhdGNoaW5nID0gZmFsc2U7XG4gICAgICBjYWxsYmFja3MgPSBuZXcgU2V0KCk7XG4gICAgICBiYXRjaC5mb3JFYWNoKGYgPT4gZih0cykpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi9yZWRyYXcnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXV0b3JlZHJhdyhhY3Rpb24pIHtcbiAgY29uc3QgcmVzID0gYWN0aW9uKCk7XG4gIHJlZHJhdygpO1xuICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVYaHJFcnJvcihlcnJvcikge1xuICBjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXM7XG4gIGNvbnN0IGRhdGEgPSBlcnJvci5ib2R5O1xuICBsZXQgbWVzc2FnZTtcblxuICBpZiAoIXN0YXR1cyB8fCBzdGF0dXMgPT09IDApIHtcbiAgICBtZXNzYWdlID0gJ295dW5rZXlmSXNVbnJlYWNoYWJsZSc7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDEpIHtcbiAgICBtZXNzYWdlID0gJ3VuYXV0aG9yaXplZEVycm9yJztcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgIG1lc3NhZ2UgPSAncmVzb3VyY2VOb3RGb3VuZEVycm9yJztcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDUwMykge1xuICAgIG1lc3NhZ2UgPSAnb3l1bmtleWZJc1VuYXZhaWxhYmxlRXJyb3InO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgPSAnRXJyb3IuJztcbiAgfVxuXG4gIG1lc3NhZ2UgPSBpMThuKG1lc3NhZ2UpO1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlICs9IGAgJHtkYXRhfWA7XG4gfVxuICBlbHNlIGlmICh0eXBlb2YgZGF0YS5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlICs9IGAgJHtpMThuKGRhdGEuZ2xvYmFsWzBdKX1gO1xuICB9XG4gIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3cobWVzc2FnZSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZExvY2FsSnNvbkZpbGUodXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAwIHx8IHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KHhocik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKG51bGwpO1xuICB9KTtcbn1cblxubGV0IHNyaTtcblxuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnRTcmkoKSB7XG4gIHJldHVybiBzcmkgfHwgbmV3U3JpKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXdTcmkoKSB7XG4gIHNyaSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKS5zbGljZSgwLCAxMCk7XG4gIHJldHVybiBzcmk7XG59XG5cbmV4cG9ydCBjb25zdCBveXVua2V5ZlNyaSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRlbGxXb3JrZXIod29ya2VyLCB0b3BpYywgcGF5bG9hZCkge1xuICBpZiAocGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdG9waWMsIHBheWxvYWQgfSk7XG4gIH0gZWxzZSB7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdG9waWMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFza1dvcmtlcih3b3JrZXIsIG1zZywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICBmdW5jdGlvbiBsaXN0ZW4oZSkge1xuICAgICAgaWYgKGUuZGF0YS50b3BpYyA9PT0gbXNnLnRvcGljKSB7XG4gICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZS5kYXRhLnBheWxvYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZS5kYXRhLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuKTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc05ldHdvcmsoKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLmNvbm5lY3Rpb24udHlwZSAhPT0gQ29ubmVjdGlvbi5OT05FO1xufVxuXG5cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVhockVycm9yKGVycm9yKSB7XG4vLyAgIHZhciB7cmVzcG9uc2U6IGRhdGEsIHN0YXR1c30gPSBlcnJvcjtcbi8vICAgaWYgKCFoYXNOZXR3b3JrKCkpIHtcbi8vICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ25vSW50ZXJuZXRDb25uZWN0aW9uJyksICdzaG9ydCcsICdjZW50ZXInKTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICBsZXQgbWVzc2FnZTtcbi8vICAgICBpZiAoIXN0YXR1cyB8fCBzdGF0dXMgPT09IDApIHtcbi8vICAgICAgIG1lc3NhZ2UgPSAnb3l1bmtleWZJc1VucmVhY2hhYmxlJztcbi8vICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4vLyAgICAgICBtZXNzYWdlID0gJ3VuYXV0aG9yaXplZEVycm9yJztcbi8vICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4vLyAgICAgICBtZXNzYWdlID0gJ3Jlc291cmNlTm90Rm91bmRFcnJvcic7XG4vLyAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDUwMykge1xuLy8gICAgICAgbWVzc2FnZSA9ICdveXVua2V5ZklzVW5hdmFpbGFibGVFcnJvcic7XG4vLyAgICAgfSBlbHNlIGlmIChzdGF0dXMgPj0gNTAwKSB7XG4vLyAgICAgICBtZXNzYWdlID0gJ3NlcnZlckVycm9yJztcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgbWVzc2FnZSA9ICdFcnJvci4nO1xuLy8gICAgIH1cblxuLy8gICAgIG1lc3NhZ2UgPSBpMThuKG1lc3NhZ2UpO1xuXG4vLyAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuLy8gICAgICAgbWVzc2FnZSArPSBgICR7ZGF0YX1gO1xuLy8gICAgIH0gZWxzZSBpZiAoZGF0YS5nbG9iYWwgJiYgZGF0YS5nbG9iYWwuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4vLyAgICAgICBtZXNzYWdlICs9IGAgJHtkYXRhLmdsb2JhbFswXX1gO1xuLy8gICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4vLyAgICAgICBtZXNzYWdlICs9IGAgJHtkYXRhLmVycm9yfWA7XG4vLyAgICAgfVxuXG4vLyAgICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhtZXNzYWdlLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4vLyAgIH1cbi8vIH1cblxuZnVuY3Rpb24gcGFydGlhbEFwcGx5KGZuLCBhcmdzKSB7XG4gIHJldHVybiBmbi5iaW5kLmFwcGx5KGZuLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpYWxmKCkge1xuICByZXR1cm4gcGFydGlhbEFwcGx5KGFyZ3VtZW50c1swXSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgIGZuID0gYXJndW1lbnRzWzBdO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZm4uYXBwbHkoZm4sIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBsYXllck5hbWUocGxheWVyLCB3aXRoUmF0aW5nKSB7XG4gIGlmIChwbGF5ZXIudXNlcm5hbWUgfHwgcGxheWVyLnVzZXIpIHtcbiAgICB2YXIgbmFtZSA9IHBsYXllci51c2VybmFtZSB8fCBwbGF5ZXIudXNlci51c2VybmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBpZiAocGxheWVyLmFpKSB7XG4gICAgcmV0dXJuIGFpTmFtZShwbGF5ZXIuYWkpO1xuICB9XG5cbiAgaWYgKHBsYXllci5zaWRlKSB7XG4gICAgcmV0dXJuIGkxOG4ocGxheWVyLnNpZGUpO1xuICB9XG5cbiAgcmV0dXJuIGkxOG4oJ2Fub255bW91cycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWlOYW1lKGxldmVsKSB7XG4gIHJldHVybiBpMThuKCdhaUJvdCcsIGxldmVsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhY2tIaXN0b3J5KCkge1xuICBzZXRWaWV3U2xpZGVEaXJlY3Rpb24oJ2J3ZCcpO1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5hcHAgJiYgd2luZG93Lm5hdmlnYXRvci5hcHAuYmFja0hpc3RvcnkpIHtcbiAgICB3aW5kb3cubmF2aWdhdG9yLmFwcC5iYWNrSGlzdG9yeSgpO1xuICB9XG4gIGVsc2VcbiAgICB3aW5kb3cuaGlzdG9yeS5nbygtMSk7XG59XG5cbi8vIHNpbXBsZSB3YXkgdG8gZGV0ZXJtaW5lIHZpZXdzIGFuaW1hdGlvbiBkaXJlY3Rpb25cbnZhciB2aWV3U2xpZGVEaXJlY3Rpb24gPSAnZndkJztcbmV4cG9ydCBmdW5jdGlvbiBzZXRWaWV3U2xpZGVEaXJlY3Rpb24oZCkge1xuICB2aWV3U2xpZGVEaXJlY3Rpb24gPSBkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdTbGlkZURpcmVjdGlvbigpIHtcbiAgcmV0dXJuIHZpZXdTbGlkZURpcmVjdGlvbjtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm9hcmRCb3VuZHModmlld3BvcnREaW0sIGlzUG9ydHJhaXQsIGlzSXBhZExpa2UsIG1vZGUpIHtcbiAgY29uc3QgeyB2aCwgdncgfSA9IHZpZXdwb3J0RGltO1xuICBjb25zdCB0b3AgPSA1MDtcblxuICBpZiAoaXNQb3J0cmFpdCkge1xuICAgIC8vIGNvbnN0IGNvbnRlbnRIZWlnaHQgPSB2aCAtIDUwO1xuICAgIC8vIGNvbnN0IHBUb3AgPSA1MCArIChtb2RlID09PSAnZ2FtZScgPyAoKGNvbnRlbnRIZWlnaHQgLSB2dyAtIDQwKSAvIDIpIDogMCk7XG4gICAgY29uc3QgY29udGVudEhlaWdodCA9IHZoO1xuICAgIGNvbnN0IHBUb3AgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHBUb3AsXG4gICAgICByaWdodDogdncsXG4gICAgICBib3R0b206IHBUb3AgKyB2dyxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogdncsXG4gICAgICBoZWlnaHQ6IHZ3XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb25zdCBsU2lkZSA9IHZoIC0gdG9wO1xuICAgIGNvbnN0IGxTaWRlID0gdmggLSA1O1xuICAgIGNvbnN0IGxXaWR0aCA9IHZ3IC0gNTsgLy8gbFNpZGUgKiAoNC8zKTtcbiAgICBjb25zdCBzcGFjZUNlbnRlciA9IHZ3IC0gbFdpZHRoO1xuICAgIHJldHVybiB7XG4gICAgICB0b3AsXG4gICAgICByaWdodDogbFNpZGUsXG4gICAgICBib3R0b206IHRvcCArIGxTaWRlLFxuICAgICAgbGVmdDogc3BhY2VDZW50ZXIgLyAyLFxuICAgICAgd2lkdGg6IGxXaWR0aCxcbiAgICAgIGhlaWdodDogbFNpZGVcbiAgICB9O1xuICB9XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBhdXRvcmVkcmF3KGFjdGlvbikge1xuLy8gICBtLnN0YXJ0Q29tcHV0YXRpb24oKTtcbi8vICAgdHJ5IHtcbi8vICAgICByZXR1cm4gYWN0aW9uKCk7XG4vLyAgIH0gZmluYWxseSB7XG4vLyAgICAgbS5lbmRDb21wdXRhdGlvbigpO1xuLy8gICB9XG4vLyB9XG5cbmNvbnN0IHBlcmZJY29uc01hcCA9IHtcbiAgeXV6YmlyOiAnVCcsXG4gIGR1em9rZXk6ICcrJ1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdhbWVJY29uKHBlcmYpIHtcbiAgcmV0dXJuIHBlcmZJY29uc01hcFtwZXJmXSB8fCAnOCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRNYXNhRHVyYXRpb24ocm91bmRzLCBzY29yZXMpIHtcbiAgcmV0dXJuIHJvdW5kcyA/IHJvdW5kcyArIGkxOG4oJ2hhbmRzJykgOiBzY29yZXMgKyBpMThuKCdzY29yZXMnKVswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZChudW0sIHNpemUpIHtcbiAgdmFyIHMgPSBudW0gKyAnJztcbiAgd2hpbGUgKHMubGVuZ3RoIDwgc2l6ZSkgcyA9ICcwJyArIHM7XG4gIHJldHVybiBzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTdHJpbmdUb051bShzKSB7XG4gIGNvbnN0IG4gPSBOdW1iZXIocyk7XG4gIHJldHVybiBpc05hTihuKSA/IHVuZGVmaW5lZCA6IG47XG59XG4iLCIvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb3phbGEvcXVlcnlzdHJpbmdcblxuZnVuY3Rpb24gc3RyaW5naWZ5UHJpbWl0aXZlICh2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgY2FzZSAnc3RyaW5nJzpcbiAgICByZXR1cm4gdjtcblxuICBjYXNlICdib29sZWFuJzpcbiAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgY2FzZSAnbnVtYmVyJzpcbiAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUXVlcnlTdHJpbmcob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIGxldCBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn1cbiIsImltcG9ydCBzaWduYWxzIGZyb20gJy4uL3NpZ25hbHMnO1xuaW1wb3J0IHsgYmF0Y2hSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfSBmcm9tICcuL2JhdGNoUkFGJztcblxuZXhwb3J0IGNvbnN0IHJlZHJhd1N5bmMgPSBzaWduYWxzLnJlZHJhdy5kaXNwYXRjaDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVkcmF3KCkge1xuICAvLyBjb25zb2xlLnRyYWNlKCk7XG4gIGJhdGNoUmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlZHJhd1N5bmMpO1xufVxuIiwiY29uc3QgSURMRV9USU1FUl9ERUxBWSA9IDE1ICogNjAgKiAxMDAwXG5jb25zdCBTTEVFUF9ERUxBWSA9IDYwICogNjAgKiAxMDAwXG5cbmxldCBzbGVlcEFnYWluVGltZW91dElkXG5sZXQgY2FuY2VsVGltZXJcblxuZXhwb3J0IGZ1bmN0aW9uIGtlZXBBd2FrZSgpIHtcbiAgd2luZG93LnBsdWdpbnMuaW5zb21uaWEua2VlcEF3YWtlKClcbiAgaWYgKGNhbmNlbFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBjYW5jZWxUaW1lcigpXG4gIH1cbiAgY2FuY2VsVGltZXIgPSBpZGxlVGltZXIoXG4gICAgSURMRV9USU1FUl9ERUxBWSxcbiAgICAoKSA9PiB7XG4gICAgICBzbGVlcEFnYWluVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5wbHVnaW5zLmluc29tbmlhLmFsbG93U2xlZXBBZ2FpbigpXG4gICAgICB9LCBTTEVFUF9ERUxBWSlcbiAgICB9LFxuICAgICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChzbGVlcEFnYWluVGltZW91dElkKVxuICAgIH1cbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsb3dTbGVlcEFnYWluKCkge1xuICBpZiAoY2FuY2VsVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNhbmNlbFRpbWVyKClcbiAgICBjYW5jZWxUaW1lciA9IHVuZGVmaW5lZFxuICB9XG4gIHdpbmRvdy5wbHVnaW5zLmluc29tbmlhLmFsbG93U2xlZXBBZ2FpbigpXG59XG5cbmZ1bmN0aW9uIGlkbGVUaW1lcihkZWxheSwgb25JZGxlLCBvbldha2VVcCkge1xuICBjb25zdCBldmVudHMgPSBbJ3RvdWNoc3RhcnQnXVxuICBsZXQgbGlzdGVuaW5nID0gZmFsc2VcbiAgbGV0IGFjdGl2ZSA9IHRydWVcbiAgbGV0IGxhc3RTZWVuQWN0aXZlID0gRGF0ZS5ub3coKVxuICBsZXQgaW50ZXJ2YWxJRFxuICBjb25zdCBvbkFjdGl2aXR5ID0gKCkgPT4ge1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnV2FrZSB1cCcpXG4gICAgICBvbldha2VVcCgpXG4gICAgfVxuICAgIGFjdGl2ZSA9IHRydWVcbiAgICBsYXN0U2VlbkFjdGl2ZSA9IERhdGUubm93KClcbiAgICBzdG9wTGlzdGVuaW5nKClcbiAgfVxuICBjb25zdCBzdGFydExpc3RlbmluZyA9ICgpID0+IHtcbiAgICBpZiAoIWxpc3RlbmluZykge1xuICAgICAgZXZlbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlLCBvbkFjdGl2aXR5KVxuICAgICAgfSlcbiAgICAgIGxpc3RlbmluZyA9IHRydWVcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9ICgpID0+IHtcbiAgICBpZiAobGlzdGVuaW5nKSB7XG4gICAgICBldmVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGUsIG9uQWN0aXZpdHkpXG4gICAgICB9KVxuICAgICAgbGlzdGVuaW5nID0gZmFsc2VcbiAgICB9XG4gIH1cbiAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJRClcbiAgICBzdG9wTGlzdGVuaW5nKClcbiAgfVxuICBpbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGlmIChhY3RpdmUgJiYgRGF0ZS5ub3coKSAtIGxhc3RTZWVuQWN0aXZlID4gZGVsYXkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdJZGxlIG1vZGUnKVxuICAgICAgb25JZGxlKClcbiAgICAgIGFjdGl2ZSA9IGZhbHNlXG4gICAgfVxuICAgIHN0YXJ0TGlzdGVuaW5nKClcbiAgfSwgMzAgKiAxMDAwKVxuXG4gIHJldHVybiBjYW5jZWxcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiB0ZWxsV29ya2VyKHdvcmtlciwgdG9waWMsIHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHRvcGljLCBwYXlsb2FkIH0pO1xuICB9IGVsc2Uge1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHRvcGljIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2tXb3JrZXIod29ya2VyLCBtc2cpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmdW5jdGlvbiBsaXN0ZW4oZSkge1xuICAgICAgaWYgKGUuZGF0YS50b3BpYyA9PT0gbXNnLnRvcGljICYmIChtc2cucmVxaWQgPT09IHVuZGVmaW5lZCB8fCBlLmRhdGEucmVxaWQgPT09IG1zZy5yZXFpZCkpIHtcbiAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW4pO1xuICAgICAgICByZXNvbHZlKGUuZGF0YS5wYXlsb2FkKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLnRvcGljID09PSAnZXJyb3InICYmIGUuZGF0YS5wYXlsb2FkLmNhbGxlclRvcGljID09PSBtc2cudG9waWMgJiYgKFxuICAgICAgICBtc2cucmVxaWQgPT09IHVuZGVmaW5lZCB8fCBlLmRhdGEucmVxaWQgPT09IG1zZy5yZXFpZCkpIHtcbiAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW4pO1xuICAgICAgICByZWplY3QoZS5kYXRhLnBheWxvYWQuZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3Rlbik7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgZmV0Y2hKU09OIH0gZnJvbSAnLi9odHRwJztcbmltcG9ydCB7IGN1cnJlbnRTcmksIG5vb3AgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4vc2Vzc2lvbic7XG5cbi8vIGV4cG9ydCBsZXQgY2FjaGVkUG9vbHMgPSBbXTtcblxuLy8gZXhwb3J0IGZ1bmN0aW9uIG5ld0dhbWUoKSB7XG4vLyAgIGNvbnN0IGNvbmZpZyA9IHNldHRpbmdzLmdhbWVTZXR1cC5odW1hbjtcblxuLy8gICBjb25zdCBkYXRhID0ge1xuLy8gICAgIHZhcmlhbnQ6IGNvbmZpZy52YXJpYW50KCksXG4vLyAgICAgcm91bmRzOiBjb25maWcucm91bmRzKCksXG4vLyAgICAgbW9kZTogc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpID8gY29uZmlnLm1vZGUoKSA6ICcwJyxcbi8vICAgICBtZW1iZXJzT25seTogc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpID8gY29uZmlnLm1lbWJlcnNPbmx5KCkgOiBmYWxzZVxuLy8gICB9O1xuXG4vLyAgIHJldHVybiByZXF1ZXN0KCcvbWFzYS9uZXcnLCB7XG4vLyAgICAgbWV0aG9kOiAnUE9TVCcsXG4vLyAgICAgZGF0YVxuLy8gICB9LCB0cnVlKTtcbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGxvYmJ5KGZlZWRiYWNrKSB7XG4vLyAgIHJldHVybiByZXF1ZXN0KCcvJywgbnVsbCwgZmVlZGJhY2spO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gZ2FtZShpZCwgYmFja2dyb3VuZCkge1xuLy8gICB2YXIgdXJsID0gJy8nICsgaWQ7XG4vLyAgIHJldHVybiByZXF1ZXN0KHVybCwgeyBiYWNrZ3JvdW5kIH0sIHRydWUpO1xuLy8gfVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtZShpZCkge1xuICBsZXQgdXJsID0gJy8nICsgaWQ7XG4gIHJldHVybiBmZXRjaEpTT04odXJsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlZWtHYW1lKHNldHVwKSB7XG4gIGNvbnN0IHsgLi4ucmVzdCB9ID0gc2V0dXA7XG5cbiAgbGV0IGJvZHk7XG5cbiAgYm9keSA9IEpTT04uc3RyaW5naWZ5KHsgLi4ucmVzdCB9KTtcblxuICByZXR1cm4gZmV0Y2hKU09OKCcvbWFzYS9uZXcnLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgYm9keVxuICB9LCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNlcnZlckxhbmcobGFuZykge1xuICBpZiAoc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgLy8gcmV0dXJuIHJlcXVlc3QoJy90cmFuc2xhdGlvbi9zZWxlY3QnLCB7XG4gICAgLy8gICBtZXRob2Q6ICdQT1NUJyxcbiAgICAvLyAgIGRhdGE6IHsgbGFuZyB9XG4gICAgLy8gfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuIl19
