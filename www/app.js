(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.Okeyground=e()}}(function(){var e;return function(){function e(t,n,r){function a(i,u){if(!n[i]){if(!t[i]){var l="function"==typeof require&&require;if(!u&&l)return l(i,!0);if(o)return o(i,!0);var d=new Error("Cannot find module '"+i+"'");throw d.code="MODULE_NOT_FOUND",d}var s=n[i]={exports:{}};t[i][0].call(s.exports,function(e){var n=t[i][1][e];return a(n||e)},s,s.exports,e,t,n,r)}return n[i].exports}for(var o="function"==typeof require&&require,i=0;i<r.length;i++)a(r[i]);return a}return e}()({1:[function(e,t,n){!function(e){function n(e,t){if("object"!==a(e))return t;for(var r in t)"object"===a(e[r])&&"object"===a(t[r])?e[r]=n(e[r],t[r]):e[r]=t[r];return e}function r(e,t,r){var i=r[0],u=r.length;(e||"object"!==a(i))&&(i={});for(var l=0;l<u;++l){var d=r[l],s=a(d);if("object"===s)for(var c in d)if("__proto__"!==c){var f=e?o.clone(d[c]):d[c];t?i[c]=n(i[c],f):i[c]=f}}return i}function a(e){return{}.toString.call(e).slice(8,-1).toLowerCase()}var o=function(e){return r(e===!0,!1,arguments)},i="merge";o.recursive=function(e){return r(e===!0,!0,arguments)},o.clone=function(e){var t,n,r=e,i=a(e);if("array"===i)for(r=[],n=e.length,t=0;t<n;++t)r[t]=o.clone(e[t]);else if("object"===i){r={};for(t in e)r[t]=o.clone(e[t])}return r},e?t.exports=o:window[i]=o}("object"==typeof t&&t&&"object"==typeof t.exports&&t.exports)},{}],2:[function(t,n,r){!function(t,r){"use strict";var a=r(t);"undefined"==typeof window&&a.deps({document:"undefined"!=typeof document?document:{},location:"undefined"!=typeof location?location:{},clearTimeout:clearTimeout,setTimeout:setTimeout}),"object"==typeof n&&null!=n&&n.exports?n.exports=a:"function"==typeof e&&e.amd?e(function(){return a}):t.m=a}("undefined"!=typeof window?window:this,function a(e,t){"use strict";function n(e){return"function"==typeof e}function r(e){return"[object Object]"===De.call(e)}function o(e){return"[object String]"===De.call(e)}function i(){}function u(e){xe=e.document,Se=e.location,Me=e.cancelAnimationFrame||e.clearTimeout,Ee=e.requestAnimationFrame||e.setTimeout}function l(e,t){for(var n,r=[],a=/(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;n=a.exec(t);)if(""===n[1]&&n[2])e.tag=n[2];else if("#"===n[1])e.attrs.id=n[2];else if("."===n[1])r.push(n[2]);else if("["===n[3].charAt(0)){var o=n[6];o&&(o=o.replace(/\\(["'])/g,"$1")),"class"===n[4]?r.push(o):e.attrs[n[4]]=o||!0}return r}function d(e,t){var n=t?e.slice(1):e;return 1===n.length&&Ke(n[0])?n[0]:n}function s(e,t,n){var r="class"in t?"class":"className";for(var a in t)Ce.call(t,a)&&(a===r&&null!=t[a]&&""!==t[a]?(n.push(t[a]),e[a]=""):e[a]=t[a]);n.length&&(e[r]=n.join(" "))}function c(e,t){for(var a=[],i=1,u=arguments.length;i<u;i++)a[i-1]=arguments[i];if(e&&n(e.view))return ae(e,a);if(!o(e))throw new Error("selector in m(selector, attrs, children) should be a string");var c=null!=t&&r(t)&&!("tag"in t||"view"in t||"subtree"in t),f=c?t:{},p={tag:"div",attrs:{},children:d(a,c)};return s(p.attrs,f,l(p,e)),p}function f(e,t){for(var n=0;n<e.length&&!t(e[n],n++););}function p(e,t){f(e,function(e,n){return(e=e&&e.attrs)&&null!=e.key&&t(e,n)})}function v(e){try{if("boolean"!=typeof e&&null!=e&&null!=e.toString())return e}catch(t){}return""}function m(e,t,n,r){try{h(e,t,n),t.nodeValue=r}catch(a){}}function g(e){for(var t=0;t<e.length;t++)Ke(e[t])&&(e=e.concat.apply([],e),t--);return e}function h(e,t,n){e.insertBefore(t,e.childNodes[n]||null)}function y(e,t,n,r){p(e,function(e,r){t[e=e.key]=t[e]?{action:je,index:r,from:t[e].index,element:n.nodes[t[e].index]||xe.createElement("div")}:{action:Be,index:r}});var a=[];for(var o in t)Ce.call(t,o)&&a.push(t[o]);var i=a.sort(H),u=new Array(n.length);return u.nodes=n.nodes.slice(),f(i,function(t){var a=t.index;if(t.action===Te&&(V(n[a].nodes,n[a]),u.splice(a,1)),t.action===Be){var o=xe.createElement("div");o.key=e[a].attrs.key,h(r,o,a),u.splice(a,0,{attrs:{key:e[a].attrs.key},nodes:[o]}),u.nodes[a]=o}if(t.action===je){var i=t.element,l=r.childNodes[a];l!==i&&null!==i&&r.insertBefore(i,l||null),u[a]=n[t.from],u.nodes[a]=i}}),u}function w(e,t,n,r){var a=e.length!==t.length;return a||p(e,function(e,n){var r=t[n];return a=r&&r.attrs&&r.attrs.key!==e.key}),a?y(e,n,t,r):t}function b(e,t,n){f(e,function(e,r){null!=t[r]&&n.push.apply(n,t[r].nodes)}),f(t.nodes,function(e,r){null!=e.parentNode&&n.indexOf(e)<0&&V([e],[t[r]])}),e.length<t.length&&(t.length=e.length),t.nodes=n}function P(e){var t=0;p(e,function(){return f(e,function(e){(e=e&&e.attrs)&&null==e.key&&(e.key="__mithril__"+t++)}),1})}function k(e,t,n){return e.tag!==t.tag||(n.sort().join()!==Object.keys(t.attrs).sort().join()||(e.attrs.id!==t.attrs.id||(e.attrs.key!==t.attrs.key||("all"===c.redraw.strategy()?!t.configContext||t.configContext.retain!==!0:"diff"===c.redraw.strategy()&&(t.configContext&&t.configContext.retain===!1)))))}function O(e,t,r){k(e,t,r)&&(t.nodes.length&&V(t.nodes),t.configContext&&n(t.configContext.onunload)&&t.configContext.onunload(),t.controllers&&f(t.controllers,function(e){e.onunload&&e.onunload({preventDefault:i})}))}function x(e,t){return e.attrs.xmlns?e.attrs.xmlns:"svg"===e.tag?"http://www.w3.org/2000/svg":"math"===e.tag?"http://www.w3.org/1998/Math/MathML":t}function S(e,t,n){n.length&&(e.views=t,e.controllers=n,f(n,function(e){if(e.onunload&&e.onunload.$old&&(e.onunload=e.onunload.$old),Re&&e.onunload){var t=e.onunload;e.onunload=function(){},e.onunload.$old=t}}))}function E(e,t,r,a,o){if(n(t.attrs.config)){var i=o.configContext=o.configContext||{};e.push(function(){return t.attrs.config.call(t,r,!a,i,o)})}}function M(e,n,r,a,o,i,u,l){var d=e.nodes[0];return a&&J(d,n.tag,n.attrs,e.attrs,o),e.children=q(d,n.tag,t,t,n.children,e.children,!1,0,n.attrs.contenteditable?d:r,o,u),e.nodes.intact=!0,l.length&&(e.views=i,e.controllers=l),d}function C(e,t,n){var r;e.$trusted?r=ee(t,n,e):(r=[xe.createTextNode(e)],t.nodeName in Ae||h(t,r[0],n));var a;return a="string"==typeof e||"number"==typeof e||"boolean"==typeof e?new e.constructor(e):e,a.nodes=r,a}function D(e,t,n,r,a,o){var i=t.nodes;return r&&r===xe.activeElement&&e===t||(e.$trusted?(V(i,t),i=ee(n,a,e)):"textarea"===o?n.value=e:r?(r.innerHTML=e,i=[].slice.call(r.childNodes)):((1===i[0].nodeType||i.length>1||i[0].nodeValue.trim&&!i[0].nodeValue.trim())&&(V(t.nodes,t),i=[xe.createTextNode(e)]),m(n,i[0],a,e))),t=new e.constructor(e),t.nodes=i,t.$trusted=e.$trusted,t}function K(e,t,n,r,a,o,i){return e.nodes.length?e.valueOf()!==t.valueOf()||a?D(t,e,r,o,n,i):(e.nodes.intact=!0,e):C(t,r,n)}function A(e){return e.$trusted?e.nodes.length:Ke(e)?e.length:1}function T(e,n,r,a,o,i,u,l,d){e=g(e);var s=[],c=n.length===e.length,f=0,v={},m=!1;p(n,function(e,t){m=!0,v[n[t].attrs.key]={action:Te,index:t}}),P(e),m&&(n=w(e,n,v,r));for(var h=0,y=0,k=e.length;y<k;y++){var O=q(r,o,n,a,e[y],n[h],i,a+f||f,u,l,d);O!==t&&(c=c&&O.nodes.intact,f+=A(O),n[h++]=O)}return c||b(e,n,s),n}function B(e,t,n,r,a){if(null!=t){if(De.call(t)===De.call(e))return t;if(a&&a.nodes){var o=n-r,i=o+(Ke(e)?e:t.nodes).length;V(a.nodes.slice(o,i),a.slice(o,i))}else t.nodes&&V(t.nodes,t)}return t=new e.constructor,t.tag&&(t={}),t.nodes=[],t}function j(e,t){return e.attrs.is?null==t?xe.createElement(e.tag,e.attrs.is):xe.createElementNS(t,e.tag,e.attrs.is):null==t?xe.createElement(e.tag):xe.createElementNS(t,e.tag)}function R(e,t,n,r){return r?J(t,e.tag,e.attrs,{},n):e.attrs}function N(e,n,r,a,o,i){return null!=e.children&&e.children.length>0?q(n,e.tag,t,t,e.children,r.children,!0,0,e.attrs.contenteditable?n:a,o,i):e.children}function G(e,t,n,r,a,o,i){var u={tag:e.tag,attrs:t,children:n,nodes:[r]};return S(u,o,i),u.children&&!u.children.nodes&&(u.children.nodes=[]),u}function F(e,t,r,a){var o;return o="diff"===c.redraw.strategy()&&e?e.indexOf(t):-1,o>-1?r[o]:n(a)?new a:{}}function _(e,t,n,r){null!=r.onunload&&Ge.map(function(e){return e.handler}).indexOf(r.onunload)<0&&Ge.push({controller:r,handler:r.onunload}),e.push(n),t.push(r)}function L(e,t,n,r,a,o){var i=F(n.views,t,r,e.controller),u=e&&e.attrs&&e.attrs.key;return e=0===Re||Fe||r&&r.indexOf(i)>-1?e.view(i):{tag:"placeholder"},"retain"===e.subtree?e:(e.attrs=e.attrs||{},e.attrs.key=u,_(o,a,t,i),e)}function I(e,t,n,r){for(var a=t&&t.controllers;null!=e.view;)e=L(e,e.view.$original||e.view,t,a,r,n);return e}function U(e,t,n,r,a,i,u,l){var d=[],s=[];if(e=I(e,t,d,s),"retain"===e.subtree)return t;if(!e.tag&&s.length)throw new Error("Component template must return a virtual element, not an array, string, etc.");e.attrs=e.attrs||{},t.attrs=t.attrs||{};var c=Object.keys(e.attrs),f=c.length>("key"in e.attrs?1:0);if(O(e,t,c),o(e.tag)){var p=0===t.nodes.length;u=x(e,u);var v;if(p){v=j(e,u);var m=R(e,v,u,f);h(r,v,a);var g=N(e,v,t,n,u,l);t=G(e,m,g,v,u,d,s)}else v=M(t,e,n,f,u,d,l,s);return"select"===e.tag&&"value"in e.attrs&&J(v,e.tag,{value:e.attrs.value},{},u),p||i!==!0||null==v||h(r,v,a),E(l,e,v,p,t),t}}function q(e,t,a,o,i,u,l,d,s,c,f){return i=v(i),"retain"===i.subtree?u:(u=B(i,u,d,o,a),Ke(i)?T(i,u,e,d,t,l,s,c,f):null!=i&&r(i)?U(i,u,s,e,d,l,c,f):n(i)?u:K(u,i,d,e,l,s,t))}function H(e,t){return e.action-t.action||e.index-t.index}function X(e,t,n){n===t&&(e.style="",n={});for(var r in t)Ce.call(t,r)&&(null!=n&&n[r]===t[r]||(e.style[r]=t[r]));for(r in n)Ce.call(n,r)&&(Ce.call(t,r)||(e.style[r]=""))}function z(e,t,a,o,i,u){if("config"===t||"key"===t)return!0;if(n(a)&&"on"===t.slice(0,2))e[t]=te(a,e);else if("style"===t&&null!=a&&r(a))X(e,a,o);else if(null!=u)"href"===t?e.setAttributeNS("http://www.w3.org/1999/xlink","href",a):e.setAttribute("className"===t?"class":t,a);else if(t in e&&!_e[t])try{("input"!==i&&!e.isContentEditable||e[t]!=a)&&(e[t]=a)}catch(l){e.setAttribute(t,a)}else try{e.setAttribute(t,a)}catch(l){}}function $(e,t,n,r,a,o,i){if(t in a&&r===n&&"object"!=typeof n&&xe.activeElement!==e)"value"===t&&"input"===o&&e.value!=n&&(e.value=n);else{a[t]=n;try{return z(e,t,n,r,o,i)}catch(u){if(u.message.indexOf("Invalid argument")<0)throw u}}}function J(e,t,n,r,a){for(var o in n)!Ce.call(n,o)||!$(e,o,n[o],r[o],r,t,a);return r}function V(e,t){for(var n=e.length-1;n>-1;n--)if(e[n]&&e[n].parentNode){try{e[n].parentNode.removeChild(e[n])}catch(r){}t=[].concat(t),t[n]&&Y(t[n])}e.length&&(e.length=0)}function Y(e){e.configContext&&n(e.configContext.onunload)&&(e.configContext.onunload(),e.configContext.onunload=null),e.controllers&&f(e.controllers,function(e){n(e.onunload)&&e.onunload({preventDefault:i})}),e.children&&(Ke(e.children)?f(e.children,Y):e.children.tag&&Y(e.children))}function Q(e,t){try{e.appendChild(xe.createRange().createContextualFragment(t))}catch(n){e.insertAdjacentHTML("beforeend",t),W(e)}}function W(e){if("SCRIPT"===e.tagName)e.parentNode.replaceChild(Z(e),e);else{var t=e.childNodes;if(t&&t.length)for(var n=0;n<t.length;n++)W(t[n])}return e}function Z(e){for(var t=document.createElement("script"),n=e.attributes,r=0;r<n.length;r++)t.setAttribute(n[r].name,n[r].value);return t.text=e.innerHTML,t}function ee(e,t,n){var r=e.childNodes[t];if(r){var a=1!==r.nodeType,o=xe.createElement("span");a?(e.insertBefore(o,r||null),o.insertAdjacentHTML("beforebegin",n),e.removeChild(o)):r.insertAdjacentHTML("beforebegin",n)}else Q(e,n);for(var i=[];e.childNodes[t]!==r;)i.push(e.childNodes[t]),t++;return i}function te(e,t){return function(n){n=n||event,c.redraw.strategy("diff"),c.startComputation();try{return e.call(t,n)}finally{le()}}}function ne(e){var t=Ie.indexOf(e);return t<0?Ie.push(e)-1:t}function re(e){function t(){return arguments.length&&(e=arguments[0]),e}return t.toJSON=function(){return e&&n(e.toJSON)?e.toJSON():e},t}function ae(e,t){function n(){return(e.controller||i).apply(this,t)||this}function r(n){for(var r=[n].concat(t),a=1;a<arguments.length;a++)r.push(arguments[a]);return e.view.apply(e,r)}e.controller&&(n.prototype=e.controller.prototype),r.$original=e.view;var a={controller:n,view:r};return t[0]&&null!=t[0].key&&(a.attrs={key:t[0].key}),a}function oe(e,t,n,r){if(!r){c.redraw.strategy("all"),c.startComputation(),He[n]=t;var a;a=qe=e?e:e={controller:i};var o=new(e.controller||i);return a===qe&&(ze[n]=o,Xe[n]=e),le(),null===e&&ie(t,n),ze[n]}null==e&&ie(t,n),Ze&&(We=Ze)}function ie(e,t){He.splice(t,1),ze.splice(t,1),Xe.splice(t,1),me(e),Ie.splice(ne(e),1),Ge=[]}function ue(){Ve&&(Ve(),Ve=null),f(He,function(e,t){var n=Xe[t];if(ze[t]){var r=[ze[t]];c.render(e,n.view?n.view(ze[t],r):"")}}),Ye&&(Ye(),Ye=null),$e=null,Je=new Date,c.redraw.strategy("diff")}function le(){"none"===c.redraw.strategy()?(Re--,c.redraw.strategy("diff")):c.endComputation()}function de(e){return e.slice(nt[c.route.mode].length)}function se(e,t,n){tt={};var r=n.indexOf("?");r!==-1&&(tt=ve(n.substr(r+1,n.length)),n=n.substr(0,r));var a=Object.keys(t),o=a.indexOf(n);if(o!==-1)return c.mount(e,t[a[o]]),!0;for(var i in t)if(Ce.call(t,i)){if(i===n)return c.mount(e,t[i]),!0;var u=new RegExp("^"+i.replace(/:[^\/]+?\.{3}/g,"(.*?)").replace(/:[^\/]+/g,"([^\\/]+)")+"/?$");if(u.test(n))return n.replace(u,function(){var n=i.match(/:[^\/]+/g)||[],r=[].slice.call(arguments,1,-2);f(n,function(e,t){tt[e.replace(/:|\./g,"")]=decodeURIComponent(r[t])}),c.mount(e,t[i])}),!0}}function ce(e){if(e=e||event,!(e.ctrlKey||e.metaKey||e.shiftKey||2===e.which)){e.preventDefault?e.preventDefault():e.returnValue=!1;var t,n=e.currentTarget||e.srcElement;for(t="pathname"===c.route.mode&&n.search?ve(n.search.slice(1)):{};n&&!/a/i.test(n.nodeName);)n=n.parentNode;Re=0,c.route(n[c.route.mode].slice(nt[c.route.mode].length),t)}}function fe(){"hash"!==c.route.mode&&Se.hash?Se.hash=Se.hash:e.scrollTo(0,0)}function pe(e,n){var a={},o=[];for(var i in e)if(Ce.call(e,i)){var u=n?n+"["+i+"]":i,l=e[i];if(null===l)o.push(encodeURIComponent(u));else if(r(l))o.push(pe(l,u));else if(Ke(l)){var d=[];a[u]=a[u]||{},f(l,function(e){a[u][e]||(a[u][e]=!0,d.push(encodeURIComponent(u)+"="+encodeURIComponent(e)))}),o.push(d.join("&"))}else l!==t&&o.push(encodeURIComponent(u)+"="+encodeURIComponent(l))}return o.join("&")}function ve(e){if(""===e||null==e)return{};"?"===e.charAt(0)&&(e=e.slice(1));var t=e.split("&"),n={};return f(t,function(e){var t=e.split("="),r=decodeURIComponent(t[0]),a=2===t.length?decodeURIComponent(t[1]):null;null!=n[r]?(Ke(n[r])||(n[r]=[n[r]]),n[r].push(a)):n[r]=a}),n}function me(e){var n=ne(e);V(e.childNodes,Ue[n]),Ue[n]=t}function ge(e,t){var n=c.prop(t);return e.then(n),n.then=function(n,r){return ge(e.then(n,r),t)},n["catch"]=n.then.bind(null,null),n}function he(e,t){function a(e){l=e||lt,s.map(function(e){l===ut?e.resolve(d):e.reject(d)})}function o(e,t,a,o){if((null!=d&&r(d)||n(d))&&n(e))try{var i=0;e.call(d,function(e){i++||(d=e,t())},function(e){i++||(d=e,a())})}catch(u){c.deferred.onerror(u),d=u,a()}else o()}function i(){var r;try{r=d&&d.then}catch(s){return c.deferred.onerror(s),d=s,l=it,i()}l===it&&c.deferred.onerror(d),o(r,function(){l=ot,i()},function(){l=it,i()},function(){try{l===ot&&n(e)?d=e(d):l===it&&n(t)&&(d=t(d),l=ot)}catch(i){return c.deferred.onerror(i),d=i,a()}d===u?(d=TypeError(),a()):o(r,function(){a(ut)},a,function(){a(l===ot&&ut)})})}var u=this,l=0,d=0,s=[];u.promise={},u.resolve=function(e){return l||(d=e,l=ot,i()),u},u.reject=function(e){return l||(d=e,l=it,i()),u},u.promise.then=function(e,t){var n=new he(e,t);return l===ut?n.resolve(d):l===lt?n.reject(d):s.push(n),n.promise}}function ye(e){return e}function we(n){var r=n.callbackName||"mithril_callback_"+(new Date).getTime()+"_"+Math.round(1e16*Math.random()).toString(36),a=xe.createElement("script");e[r]=function(o){a.parentNode.removeChild(a),n.onload({type:"load",target:{responseText:o}}),e[r]=t},a.onerror=function(){return a.parentNode.removeChild(a),n.onerror({type:"error",target:{status:500,responseText:JSON.stringify({error:"Error making jsonp request"})}}),e[r]=t,!1},a.onload=function(){return!1},a.src=n.url+(n.url.indexOf("?")>0?"&":"?")+(n.callbackKey?n.callbackKey:"callback")+"="+r+"&"+pe(n.data||{}),xe.body.appendChild(a)}function be(t){var a=new e.XMLHttpRequest;if(a.open(t.method,t.url,!0,t.user,t.password),a.onreadystatechange=function(){4===a.readyState&&(a.status>=200&&a.status<300?t.onload({type:"load",target:a}):t.onerror({type:"error",target:a}))},t.serialize===JSON.stringify&&t.data&&"GET"!==t.method&&a.setRequestHeader("Content-Type","application/json; charset=utf-8"),t.deserialize===JSON.parse&&a.setRequestHeader("Accept","application/json, text/*"),r(t.headers))for(var i in t.headers)Ce.call(t.headers,i)&&a.setRequestHeader(i,t.headers[i]);if(n(t.config)){var u=t.config(a,t);null!=u&&(a=u)}var l="GET"!==t.method&&t.data?t.data:"";if(l&&!o(l)&&l.constructor!==e.FormData)throw new Error("Request data should be either be a string or FormData. Check the `serialize` option in `m.request`");return a.send(l),a}function Pe(e){return e.dataType&&"jsonp"===e.dataType.toLowerCase()?we(e):be(e)}function ke(e,t,n){if("GET"===e.method&&"jsonp"!==e.dataType){var r=e.url.indexOf("?")<0?"?":"&",a=pe(t);e.url+=a?r+a:""}else e.data=n(t)}function Oe(e,t){return t&&(e=e.replace(/:[a-z]\w+/gi,function(e){var n=e.slice(1),r=t[n]||e;return delete t[n],r})),e}c.version=function(){return"v0.2.8"};var xe,Se,Ee,Me,Ce={}.hasOwnProperty,De={}.toString,Ke=Array.isArray||function(e){return"[object Array]"===De.call(e)},Ae={AREA:1,BASE:1,BR:1,COL:1,COMMAND:1,EMBED:1,HR:1,IMG:1,INPUT:1,KEYGEN:1,LINK:1,META:1,PARAM:1,SOURCE:1,TRACK:1,WBR:1};c.deps=function(t){return u(e=t||window),e},c.deps.factory=c.factory=a,c.deps(e);var Te=1,Be=2,je=3,Re=0;c.startComputation=function(){Re++},c.endComputation=function(){Re>1?Re--:(Re=0,c.redraw())};var Ne,Ge=[],Fe=!1,_e={list:1,style:1,form:1,type:1,width:1,height:1},Le={appendChild:function(e){Ne===t&&(Ne=xe.createElement("html")),xe.documentElement&&xe.documentElement!==e?xe.replaceChild(e,xe.documentElement):xe.appendChild(e),this.childNodes=xe.childNodes},insertBefore:function(e){this.appendChild(e)},childNodes:[]},Ie=[],Ue={};c.render=function(e,n,r){if(!e)throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");var a,o=[],i=ne(e),u=e===xe;a=u||e===xe.documentElement?Le:e,u&&"html"!==n.tag&&(n={tag:"html",attrs:{},children:n}),Ue[i]===t&&V(a.childNodes),r===!0&&me(e),Ue[i]=q(a,null,t,t,n,Ue[i],!1,0,null,t,o),f(o,function(e){e()})},c.trust=function(e){return e=new String(e),e.$trusted=!0,e},c.prop=function(e){return(null!=e&&(r(e)||n(e))||"undefined"!=typeof Promise&&e instanceof Promise)&&n(e.then)?ge(e):re(e)};var qe,He=[],Xe=[],ze=[],$e=null,Je=0,Ve=null,Ye=null,Qe=16;c.component=function(e){for(var t=new Array(arguments.length-1),n=1;n<arguments.length;n++)t[n-1]=arguments[n];return ae(e,t)};var We,Ze;c.mount=c.module=function(e,t){if(!e)throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");var r=He.indexOf(e);r<0&&(r=He.length);var a=!1,o={preventDefault:function(){a=!0,Ve=Ye=null}};return f(Ge,function(e){e.handler.call(e.controller,o),e.controller.onunload=null}),a?f(Ge,function(e){e.controller.onunload=e.handler}):Ge=[],ze[r]&&n(ze[r].onunload)&&ze[r].onunload(o),oe(t,e,r,a)};var et=!1;c.redraw=function(t){if(!et){et=!0,t&&(Fe=!0);try{$e&&!t?(Ee===e.requestAnimationFrame||new Date-Je>Qe)&&($e>0&&Me($e),$e=Ee(ue,Qe)):(ue(),$e=Ee(function(){$e=null},Qe))}finally{et=Fe=!1}}},c.redraw.strategy=c.prop(),c.withAttr=function(e,t,n){return function(r){r=r||window.event;var a=r.currentTarget||this,o=n||this,i=e in a?a[e]:a.getAttribute(e);t.call(o,i)}};var tt,nt={pathname:"",hash:"#",search:"?"},rt=i,at=!1;c.route=function(t,n,r,a){if(0===arguments.length)return We;if(3===arguments.length&&o(n)){rt=function(e){var a=We=de(e);if(!se(t,r,a)){if(at)throw new Error("Ensure the default route matches one of the routes defined in m.route");at=!0,c.route(n,!0),at=!1}};var i="hash"===c.route.mode?"onhashchange":"onpopstate";return e[i]=function(){var e=Se[c.route.mode];"pathname"===c.route.mode&&(e+=Se.search),We!==de(e)&&rt(e)},Ve=fe,void e[i]()}if(t.addEventListener||t.attachEvent){var u="pathname"!==c.route.mode?Se.pathname:"";return t.href=u+nt[c.route.mode]+a.attrs.href,void(t.addEventListener?(t.removeEventListener("click",ce),t.addEventListener("click",ce)):(t.detachEvent("onclick",ce),t.attachEvent("onclick",ce)))}if(o(t)){Ze=We,We=t;var l,d=n||{},s=We.indexOf("?");l=s>-1?ve(We.slice(s+1)):{};for(var f in d)Ce.call(d,f)&&(l[f]=d[f]);var p,v=pe(l);p=s>-1?We.slice(0,s):We,v&&(We=p+(p.indexOf("?")===-1?"?":"&")+v);var m=(3===arguments.length?r:n)===!0||Ze===We;if(e.history.pushState){var g=m?"replaceState":"pushState";Ve=fe,Ye=function(){try{e.history[g](null,xe.title,nt[c.route.mode]+We)}catch(t){Se[c.route.mode]=We}},rt(nt[c.route.mode]+We)}else Se[c.route.mode]=We,rt(nt[c.route.mode]+We);Ze=null}},c.route.param=function(e){if(!tt)throw new Error("You must call m.route(element, defaultRoute, routes) before calling m.route.param()");return e?tt[e]:tt},c.route.mode="search",c.route.buildQueryString=pe,c.route.parseQueryString=ve,c.deferred=function(){var e=new he;return e.promise=ge(e.promise),e};var ot=1,it=2,ut=3,lt=4;return c.deferred.onerror=function(e){if("[object Error]"===De.call(e)&&!/ Error/.test(e.constructor.toString()))throw Re=0,e},c.sync=function(e){function t(e,t){return function(i){return a[e]=i,t||(o="reject"),0===--r&&(n.promise(a),n[o](a)),i}}var n=c.deferred(),r=e.length,a=[],o="resolve";return e.length>0?f(e,function(e,n){e.then(t(n,!0),t(n,!1))}):n.resolve([]),n.promise},c.request=function(e){e.background!==!0&&c.startComputation();var t,n,r,a=new he,o=e.dataType&&"jsonp"===e.dataType.toLowerCase();return o?(t=e.serialize=n=e.deserialize=ye,r=function(e){return e.responseText}):(t=e.serialize=e.serialize||JSON.stringify,n=e.deserialize=e.deserialize||JSON.parse,r=e.extract||function(e){return e.responseText.length||n!==JSON.parse?e.responseText:null}),e.method=(e.method||"GET").toUpperCase(),e.url=Oe(e.url,e.data),ke(e,e.data,t),e.onload=e.onerror=function(t){try{t=t||event;var o=n(r(t.target,e));"load"===t.type?(e.unwrapSuccess&&(o=e.unwrapSuccess(o,t.target)),Ke(o)&&e.type?f(o,function(t,n){o[n]=new e.type(t)}):e.type&&(o=new e.type(o)),a.resolve(o)):(e.unwrapError&&(o=e.unwrapError(o,t.target)),a.reject(o))}catch(i){a.reject(i),c.deferred.onerror(i)}finally{e.background!==!0&&c.endComputation()}},Pe(e),a.promise=ge(a.promise,e.initialValue),a.promise},c})},{}],3:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){var n,r,a,o=t.animation.current,i=d["default"].findPov(t.povSide,t.turnSide),u=d["default"].vectorByPov(i),l=t.bounds(),s=4/3,f=1*l.width,p=(l.height*(s/24.32),608/350),v=f,m=l.height*(s/p),g=.0625*v,h=.14*m,y={},w=[];if(o.hint===c["default"].drawMiddle){n=[12*g,m],r=[v*u[0],m*u[1]];var a=[r[0]-n[0],r[1]-n[1]];y[d["default"].middleCount]=[a,a,!0]}else if(o.hint===c["default"].discard){var b=d["default"].discardByPov(i),P=d["default"].topKey2pos(b);n=[g*P[0],h*P[1]],r=[v*u[0],m*u[1]],a=[r[0]-n[0],r[1]-n[1]],y[b]=[a,a]}return{anims:y,fadings:w}}function o(e,t){return Math.round(e*t)/t}function i(e){if(e.animation.current.start){var t=1-((new Date).getTime()-e.animation.current.start)/e.animation.current.duration;if(t<=0)e.animation.current={},e.render();else{var n=f.easeInOutCubic(t);for(var r in e.animation.current.anims){var a=e.animation.current.anims[r];a[1]=[o(a[0][0]*n,10),o(a[0][1]*n,10)],a[2]&&(a[1]=[a[0][0]-a[1][0],a[0][1]-a[1][1]])}for(var u in e.animation.current.fadings)e.animations.current.fadings[u].opacity=o(n,100);e.render(),d["default"].requestAnimationFrame(function(){i(e)})}}}function u(e,t){var n={pieces:{},opens:{},middles:{}};for(var r in t.pieces)t.pieces[r]&&(n.pieces[r]={color:t.pieces[r].color,number:t.pieces[r].number});var o=e(),u=a(n,t);if(Object.keys(u.anims).length>0||u.fadings.length>0){var l=t.animation.current.start;t.animation.current={start:(new Date).getTime(),duration:t.animation.duration,anims:u.anims,fadings:u.fadings},l||i(t)}else t.renderRAF();return o}var l=e("./util"),d=r(l),s=e("./move"),c=r(s),f={easeInOutCubic:function(e){return e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1}};t.exports=function(e,t){return function(){var n=[t].concat(Array.prototype.slice.call(arguments,0));if(t.animation.enabled)return u(d["default"].partialApply(e,n),t);var r=e.apply(null,n);return t.renderRAF(),r}}},{"./move":11,"./util":15}],4:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=e("./board"),o=r(a);t.exports=function(e){return{set:e.set,getPieceGroups:function(){return o["default"].getPieceGroups(e.data)},apiMove:e.apiMove,apiDrawMiddleEnd:e.apiDrawMiddleEnd,playOpenSeries:e.playOpenSeries,playOpenPairs:e.playOpenPairs,stop:e.stop,getPieceGroupSeries:e.getPieceGroupSeries,getPieceGroupPairs:e.getPieceGroupPairs,getFen:e.getFen}}},{"./board":5}],5:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e){if(K(e)){var t=e.middles[J["default"].gosterge],n=H(e);if(n=n.filter(function(n){return ee["default"].series(n.map(function(t){return e.pieces[t]}),t)}),n.length>0){var r=L(n.map(function(t){return t.map(function(t){return e.pieces[t]})}));return s(e,n),ne(J["default"].partial(e.movable.events.after,Y["default"].openSeries,te(r))),!0}}return!1}function i(e){if(A(e)){var t=e.middles[J["default"].gosterge],n=H(e);if(n=n.filter(function(n){return ee["default"].pairs(n.map(function(t){return e.pieces[t]}),t)}),n.length>0){var r=L(n.map(function(t){return t.map(function(t){return e.pieces[t]})}));return d(e,n),ne(J["default"].partial(e.movable.events.after,Y["default"].openPairs,te(r))),!0}}return!1}function u(e,t){var n=J["default"].middleCount;v(e,n),p(e,n),l(e,t)}function l(e,t){"string"==typeof t&&(t=W["default"].readPiece(t).piece),e.middleHolder.piece=t,c(e)}function d(e,t){var n=t.map(function(t){return t.map(function(t){return e.pieces[t]})}),r=L(n);ne(J["default"].partial(e.events.move,Y["default"].openPairs,te(r))),t.forEach(function(t){return t.map(function(t){return delete e.pieces[t]})});var a=e.opens.pairs.concat(n);e.opens.pairs=a,e.opens.relayout(e)}function s(e,t){var n=t.map(function(t){return t.map(function(t){return e.pieces[t]})}),r=L(n);ne(J["default"].partial(e.events.move,Y["default"].openSeries,te(r))),t.forEach(function(t){return t.map(function(t){return delete e.pieces[t]})});var a=e.opens.series.concat(n);e.opens.series=a,e.opens.relayout(e)}function c(e){var t=e.middleHolder.key,n=e.middleHolder.piece;t&&n&&(e.pieces[t]=n,e.lastMove=[J["default"].middleCount],e.middleHolder.current=!1,e.middleHolder.key=null,e.middleHolder.piece=null)}function f(e,t,n){if(t===n||!e.pieces[t])return!1;var r=e.pieces[n];return e.pieces[n]=e.pieces[t],e.pieces[t]=r,!0}function p(e,t,n){if(!n||e.pieces[n]){var r=G(e);n=r}return ne(J["default"].partial(e.events.move,Y["default"].drawMiddleEnd)),e.middleHolder.key=n,c(e),!0}function v(e,t){return ne(J["default"].partial(e.events.move,Y["default"].drawMiddle)),e.middles[J["default"].middleCount]--,e.middleHolder.current=!0,!0}function m(e,t,n){return!e.pieces[n]&&(ne(J["default"].partial(e.events.move,Y["default"].drawLeft)),e.pieces[n]=e.discards[J["default"].discards[1]][0],e.discards[J["default"].discards[1]].shift(),!0)}function g(e,t,n){if(n&&J["default"].isBoardKey(t)&&J["default"].isBoardKey(n)&&S(e,t,n)&&f(e,t,n))return!0}function h(e,t){if(J["default"].isMiddleKey(t)&&M(e,t))return v(e,t),!0}function y(e,t,n){if(J["default"].isMiddleKey(t)&&C(e,t))return p(e,t,n),!0}function w(e,t,n){if(n&&J["default"].isBoardKey(n)&&J["default"].isDrawLeftKey(t)&&D(e,t,n)&&m(e,t,n))return ne(J["default"].partial(e.movable.events.after,Y["default"].drawLeft)),!0}function b(e,t,n){n||(J["default"].isMiddleKey(t)?h(e,t)&&k(e,t):J["default"].isDrawLeftKey(t)&&D(e)&&k(e,t))}function P(e,t){e.selected?(t?e.selected!==t&&(g(e,e.selected,t)||w(e,e.selected,t)||y(e,e.selected,t)):y(e,e.selected,t),k(e,null)):x(e,t)&&k(e,t)}function k(e,t){if(e.selected=t,t&&J["default"].isBoardKey(t))if(N(e,t)){var n=e.middles[J["default"].gosterge];e.openable.dests=ee["default"].compute(e.opens,e.pieces[t],n)}else e.openable.dests=[];else e.openable.dests=[]}function O(e){return e.povSide===e.turnSide}function x(e,t){var n=e.pieces[t];return n&&e.movable.board}function S(e,t,n){return t!=n&&x(e,t)}function E(e){return O(e)}function M(e,t){return E(e)&&!e.middleHolder.current&&J["default"].containsX(e.movable.dests,Y["default"].drawMiddle)}function C(e){return e.middleHolder.current}function D(e,t,n){return E(e)&&!C(e)&&J["default"].containsX(e.movable.dests,Y["default"].drawLeft)}function K(e){return O(e)&&J["default"].containsX(e.movable.dests,Y["default"].openSeries)}function A(e){return O(e)&&J["default"].containsX(e.movable.dests,Y["default"].openPairs)}function T(e){return O(e)&&J["default"].containsX(e.movable.dests,Y["default"].leaveTaken)}function B(e){return O(e)&&J["default"].containsX(e.movable.dests,Y["default"].collectOpen)}function j(e){P(e,null)}function R(e){e.movable.side=null,e.movable.dests=[],e.openable.dests=[],e.movable.board=!1,j(e)}function N(e,t){var n=e.pieces[t];return!(!n||e.povSide!==e.turnSide)}function G(e){var t=J["default"].allAllowedBoardKeys.slice(1),n=J["default"].allAllowedBoardKeys.slice(2),r=J["default"].allAllowedBoardKeys.map(function(e,r){return[e,t[r],n[r]]}).filter(function(t){var n=z(t,3),r=n[0],a=n[1],o=n[2];return r&&a&&o&&!e.pieces[r]&&!e.pieces[a]&&!e.pieces[o]});return r[r.length-1][1]}function F(e,t,n,r){var a=_(e,t,n);if(!a)return a;var o=J["default"].decBoardKey(a);return o!==r&&e.pieces[o]&&(a=o),J["default"].notAllowedBoardKeys.indexOf(a)!==-1?null:a}function _(e,t,n){if(n||e.bounds){n=n||e.bounds();var r=Math.floor(J["default"].columns*((t[0]-n.left)/n.width)),a=Math.floor(J["default"].rows*((t[1]-n.top)/n.height));return a>=0&&a<J["default"].rows&&r>=0&&r<J["default"].columns?J["default"].pos2key([r,a]):void 0}}function L(e){return e.map(function(e){return e.map(function(e){return e.key}).join("")}).join(" ")}function I(e){var t=e.middles[J["default"].gosterge],n=e.withTore,r=q(e).filter(function(e){return ee["default"].series(e,t,n)});return L(r)}function U(e){var t=e.middles[J["default"].gosterge],n=q(e).filter(function(e){return ee["default"].pairs(e,t)});return L(n)}function q(e){return H(e).map(function(t){return t.map(function(t){return e.pieces[t]})})}function H(e){var t=J["default"].pos2key([J["default"].columns-1,0]),n=J["default"].allKeys.slice(1),r=J["default"].allKeys.map(function(e,t){return[e,n[t]]}).reduce(function(n,r){var a=z(n,2),o=a[0],i=a[1],u=z(r,2),l=u[0],d=u[1];return e.pieces[l]&&o.push(l),(l&&!e.pieces[l]&&d&&!e.pieces[d]||l===t)&&0!==o.length&&(i.push(o),o=[]),[o,i]},[[],[]]),a=z(r,2),o=a[0],i=a[1];return 0!==o.length&&i.push(o),i}var X,z=function(){function e(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var i,u=e[Symbol.iterator]();!(r=(i=u.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(l){a=!0,o=l}finally{try{!r&&u["return"]&&u["return"]()}finally{if(a)throw o}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),$=e("./util"),J=r($),V=e("./move"),Y=r(V),Q=e("./pieces"),W=r(Q),Z=e("./open"),ee=r(Z),te=J["default"].wrapGroup,ne=J["default"].callUserFunction;t.exports=(X={playOpenSeries:o,playOpenPairs:i,apiDrawMiddleEnd:l},a(X,"apiDrawMiddleEnd",l),a(X,"apiForceDrawMiddleEnd",u),a(X,"apiForceDrawMiddleEnd",u),a(X,"userMove",g),a(X,"userDrawLeft",w),a(X,"userBeginDrawMiddle",h),a(X,"userEndDrawMiddle",y),a(X,"selectSquare",P),a(X,"selectTop",b),a(X,"setSelected",k),a(X,"canOpenSeries",K),a(X,"canOpenPairs",A),a(X,"canLeaveTaken",T),a(X,"canCollectOpen",B),a(X,"stop",R),
a(X,"isDroppableOpens",N),a(X,"getKeyAtDomPos",_),a(X,"getKeyAtDomPosOnPiece",F),a(X,"getPieceGroups",q),a(X,"getPieceGroupSeries",I),a(X,"getPieceGroupPairs",U),X)},{"./move":11,"./open":12,"./pieces":13,"./util":15}],6:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=e("merge"),o=r(a),i=e("./pieces"),u=r(i);t.exports=function(e,t){if(t&&(o["default"].recursive(e,t),e.fen)){var n=u["default"].read(e.fen);e.pieces=n.pieces,e.discards=n.discards,e.opens=n.opens,e.middles=n.middles,delete e.fen}}},{"./pieces":13,merge:1}],7:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=e("./table"),o=r(a),i=e("./board"),u=r(i),l=e("./data"),d=r(l),s=e("./configure"),c=r(s),f=e("./util"),p=r(f),v=e("./anim"),m=r(v),g=e("./drag"),h=r(g),y=e("./pieces"),w=r(y);t.exports=function(e){var t=this;this.data=(0,d["default"])(e),this.getFen=function(){return w["default"].write(t.data.pieces)},this.getPieceGroupSeries=function(){return u["default"].getPieceGroupSeries(t.data)},this.getPieceGroupPairs=function(){return u["default"].getPieceGroupPairs(t.data)},this.set=(0,m["default"])(c["default"],this.data),this.apiMove=(0,m["default"])(o["default"].apiMove,this.data),this.apiDrawMiddleEnd=(0,m["default"])(u["default"].apiDrawMiddleEnd,this.data),this.playOpenSeries=(0,m["default"])(u["default"].playOpenSeries,this.data),this.playOpenPairs=(0,m["default"])(u["default"].playOpenPairs,this.data),this.canLeaveTaken=p["default"].partial(u["default"].canLeaveTaken,this.data),this.canCollectOpen=p["default"].partial(u["default"].canCollectOpen,this.data),this.canOpenSeries=p["default"].partial(u["default"].canOpenSeries,this.data),this.canOpenPairs=p["default"].partial(u["default"].canOpenPairs,this.data),this.stop=(0,m["default"])(function(e){u["default"].stop(e),h["default"].cancel(e)},this.data)}},{"./anim":3,"./board":5,"./configure":6,"./data":8,"./drag":9,"./pieces":13,"./table":14,"./util":15}],8:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=e("merge"),o=(r(a),e("./pieces")),i=r(o),u=e("./configure"),l=r(u);t.exports=function(e){var t={povSide:"east",turnSide:"east",lastMove:null,withTore:!1,pieces:i["default"].readBoard(i["default"].mixed),discards:i["default"].readDiscards(i["default"].initialDiscards,"east"),opens:i["default"].readOpenGroups(i["default"].initialOpenGroups),middles:i["default"].readMiddles(i["default"].initialMiddles),selected:null,middleHolder:{current:!1,key:null,piece:null},animation:{enabled:!0,duration:500,current:{}},draggable:{enabled:!0,distance:3,current:{}},movable:{board:!0,free:!0,events:{after:function(e,t){}}},openable:{dests:[]},events:{move:function(e,t){}}};return(0,l["default"])(t,e||{}),t}},{"./configure":6,"./pieces":13,merge:1}],9:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g["default"].rows,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:g["default"].columns;return{left:t.left+t.width*n[0]/a,top:t.top+t.height*n[1]/r,width:t.width/a,height:t.height/r}}function o(e,t){if(void 0===t.button||0===t.button){t.stopPropagation(),t.preventDefault(),s=t.target;var n=e.selected,r=g["default"].eventPosition(t),o=e.boardBounds(),u=e.opensBounds(),l=e.topBounds(),d=f["default"].getKeyAtDomPosOnPiece(e,r,o);f["default"].selectSquare(e,d),d||(d=v["default"].getDrawKeyAtDomPos(e,r,l))&&f["default"].selectTop(e,d,n),!d&&n&&((d=v["default"].getOpensKeyAtDomPos(e,r,u))?v["default"].dropOpens(e,n,d):(d=v["default"].getDiscardKeyAtDomPos(e,r,l))&&v["default"].dropTop(e,n,d));var c=e.selected===d;if(c&&v["default"].isDraggable(e,d)){var p=g["default"].isBoardKey(d)?a(e,o,g["default"].key2pos(d)):a(e,l,g["default"].topKey2pos(d),g["default"].topRows,g["default"].topColumns);e.draggable.current={orig:d,rel:r,epos:r,pos:[0,0],dec:[r[0]-(p.left+p.width/2),r[1]-(p.top+p.height/2)],boardBounds:o,opensBounds:u,topBounds:l,started:!1}}i(e)}}function i(e){g["default"].requestAnimationFrame(function(){var t=e.draggable.current;t.orig&&(!t.started&&g["default"].distance(t.epos,t.rel)>=e.draggable.distance&&(t.started=!0),t.started&&(t.pos=[t.epos[0]-t.rel[0],t.epos[1]-t.rel[1]],t.over=f["default"].getKeyAtDomPosOnPiece(e,t.epos,t.boardBounds,t.orig),!t.over&&g["default"].isBoardKey(t.orig)&&(t.over=v["default"].getOpensKeyAtDomPos(e,t.epos,t.opensBounds)||v["default"].getDiscardKeyAtDomPos(e,t.epos,t.topBounds)))),e.render(),t.orig&&i(e)})}function u(e,t){e.draggable.current.orig&&(e.draggable.current.epos=g["default"].eventPosition(t))}function l(e,t){var n=e.draggable,r=n.current?n.current.orig:null;if(r){var a=n.current.over;n.current.started&&(f["default"].setSelected(e,null),f["default"].userMove(e,r,a)||v["default"].dropOpens(e,r,a)||v["default"].dropTop(e,r,a)||f["default"].userDrawLeft(e,r,a)||f["default"].userEndDrawMiddle(e,r,a)),n.current={}}}function d(e){e.draggable.current.orig&&(e.draggable.current={},f["default"].selectSquare(e,null))}var s,c=e("./board"),f=r(c),p=e("./table"),v=r(p),m=e("./util"),g=r(m);t.exports={start:o,move:u,end:l,cancel:d}},{"./board":5,"./table":14,"./util":15}],10:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){var n=new l["default"](t);return i["default"].render(e,(0,s["default"])(n)),(0,g["default"])(n)}var o=e("mithril"),i=r(o),u=e("./ctrl"),l=r(u),d=e("./view"),s=r(d),c=e("./util"),f=r(c),p=e("./move"),v=r(p),m=e("./api"),g=r(m);t.exports=a,t.exports.controller=l["default"],t.exports.view=s["default"],t.exports.util=f["default"],t.exports.move=v["default"]},{"./api":4,"./ctrl":7,"./move":11,"./util":15,"./view":16,mithril:2}],11:[function(e,t,n){"use strict";var r="dm",a="dl",o="dd",i="lt",u="ss",l="os",d="op",s="co",c="dos",f="dop",p="dds",v="ddp",m="l",g="r",h="p";t.exports={drawMiddle:r,drawLeft:a,discard:o,leaveTaken:i,sign:u,openSeries:l,openPairs:d,collectOpen:s,dropOpenSeries:c,dropOpenPairs:f,dropLeft:m,dropRight:g,dropReplace:h,discardEndSeries:p,discardEndPairs:v}},{}],12:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){return e.length===t.length&&e.every(function(e,n){return e===t[n]})}function o(e,t){return t.every(function(t,n){return t.color===e[n]})}function i(e,t){if(e.length<3)return!1;var n=e.length,r=e[0].color,o=e.map(function(e){return e.key}),i=o.slice(0).reverse(),u=h["default"].seriesByColor(r);t&&(u=u.slice(0),u.push(u[0]));for(var l=0;l<=u.length-n;l++){var d=u.slice(l,l+n);if(a(d,o)|a(d,i))return!0}return!1}function u(e){var t=e.length,n=e[0].number;return!!(3===t|4===t)&&(!!e.every(function(e){return e.number===n})&&y.some(function(t){return o(t.slice(0,e.length),e)}))}function l(e,t){var n=h["default"].makePiece(t.c,t.n);return n.isFake=!0,h["default"].pieceFake(e)?n:e}function d(e,t){return!e.isFake&&e.key===t.key}function s(e,t){function n(e,t){return e.filter(function(e){return t.indexOf(e)<0})}function r(e,t){return e.key===t.key}function a(e,t){var r=["r","g","b","l"],a=e.filter(function(e){return!d(e,t)}),o=n(r,a.map(function(e){return e.c}));if(o.length<1)return e;if(a.length<1)return e;if(!(a.length<e.length))return e;var i=o[0],u=a[0].n,l=h["default"].makePiece(i,u);return a.push(l),a}function o(e,t){var n;if(0===e.length)return e;if(e.length<3)return e;var a=m(e,3),i=a[0],u=a[1],l=a[2],s=[i,u,l];if(n=e.slice(3,e.length),d(i,t))r(h["default"].pieceUp(u),l)?s=[h["default"].pieceDown(u),u,l]:r(h["default"].pieceDown(u),l)&&(s=[h["default"].pieceUp(u),u,l]);else if(d(u,t))r(h["default"].pieceUp(h["default"].pieceUp(i)),l)?s=[i,h["default"].pieceUp(i),l]:r(h["default"].pieceDown(h["default"].pieceDown(i)),l)&&(s=[i,h["default"].pieceDown(i),l]);else{if(!d(l,t))return n=o(e.slice(1,e.length),t),n.unshift(e[0]),n;r(h["default"].pieceUp(i),u)?s=[i,u,h["default"].pieceUp(u)]:r(h["default"].pieceDown(i),u)&&(s=[i,u,h["default"].pieceDown(u)])}return s.concat(n)}function i(e,t){if(2!=e.length)return e;var n=m(e,2),r=n[0],a=n[1];return d(r,t)?[a,a]:d(a,t)?[r,r]:e}if(e.filter(function(e){return d(e,t)}).length>1)return e;if(e.length<3)return i(e,t);var u=e.filter(function(e){return!d(e,t)});return u.every(function(e){return e.n===u[0].n})?a(e,t):u.every(function(e){return e.c===u[0].c})?o(e,t):e}function c(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=h["default"].pieceUp(t),a=e.map(function(e){return l(e,r)}),o=s(a,r);return i(o,n)|u(o)}function f(e,t){if(2!==e.length)return!1;var n=h["default"].pieceUp(t),r=e.map(function(e){return l(e,n)}),a=s(r,n),o=m(a,2),i=o[0],u=o[1];return i.key===u.key}function p(e,t,n){var r=[],a=h["default"].pieceUp(n);return t=l(t,a),e.series.forEach(function(o,i){var u=o.slice(0),l=o.slice(0);u.splice(0,0,t),l.splice(o.length,0,t),c(u,n)&&r.push(h["default"].getOpenSerieKeyFromGroupIndex(e,i,0)),c(l,n)&&r.push(h["default"].getOpenSerieKeyFromGroupIndex(e,i,o.length+1));var s=o.map(function(e){return d(e,a)?t:e});if(c(s,n)){var f;o.forEach(function(e,t){d(e,a)&&(f=t)}),r.push(h["default"].getOpenSerieKeyFromGroupIndex(e,i,f+1))}}),e.pairs.forEach(function(o,i){var u=o.map(function(e){return d(e,a)?t:e});if(f(u,n)){var l=v(o,a);r.push(h["default"].getOpenPairKeyFromGroupIndex(e,i,l))}}),r}function v(e,t){var n;return e.forEach(function(e,r){d(e,t)&&(n=r)}),n}Object.defineProperty(n,"__esModule",{value:!0});var m=function(){function e(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var i,u=e[Symbol.iterator]();!(r=(i=u.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(l){a=!0,o=l}finally{try{!r&&u["return"]&&u["return"]()}finally{if(a)throw o}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),g=e("./pieces"),h=r(g),y=function(){var e=h["default"].colors,t=[];for(var n in e)for(var r in e)for(var a in e)for(var o in e)n!==r&&n!==a&&n!==o&&r!==a&&r!==o&&a!==o&&t.push([e[n],e[r],e[a],e[o]]);return t}();n["default"]={compute:p,series:c,pairs:f,findOkeyIndex:v},t.exports=n["default"]},{"./pieces":13}],13:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){var t=[];for(var n in A)t.push(k(e,n).key);return t}function o(e){var t={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9},n=t[e[0]],r=t[e[1]];return void 0===r?void 0===n?{left:e.slice(1)}:{number:n,left:e.slice(1)}:{number:10*n+r,left:e.slice(2)}}function i(e){var t=/([l|r|p])(\d\d?)/,n=e.match(t),r=n[1],a=parseInt(n[2]);return{type:r,groupIndex:a}}function u(e){var t=e[0],n=e[1],r=e[2],a=2;return K[t]?(A[n+r]&&(n+=r,a=3),{piece:k(t,n),left:e.slice(a)}):{left:e.slice(1)}}function l(e){var t=[],n=[];for(e+="\n";e.length>0;){var r=u(e);r.piece?n.push(r.piece):(n.length>0&&t.push(n),n=[]),e=r.left}return t}function d(e){for(var t=[],n=0;e.length>0;){var r=u(e);r.piece&&(t[n]=r.piece),n++,e=r.left}return t}function s(e){var t={};e=d(e);for(var n=0,r=0;r<e.length;r++){if(e[r]){for(;n<100&&!D["default"].isAllowedBoardKey(D["default"].encodeKey(n,"b"));)n++;t[D["default"].encodeKey(n,"b")]=e[r],n++}n++}return t}function c(e,t){e=e.split(" ");var n={};return D["default"].allSides.map(function(e){return D["default"].findPov(t,e)}).forEach(function(t,r){var a=d(e[r]||"");n[D["default"].discardByPov(t)]=a}),n}function f(e){var t=e.split("/"),n=M(t,2),r=n[0],a=n[1];r=l(r),a=l(a);var o=p(r,a);return{series:r,pairs:a,layout:o,relayout:function(e){e.opens.layout=p(e.opens.series,e.opens.pairs)}}}function p(e,t){var n,r,a,o,i,u={},l={series:{},pairs:{}},d=[],s=0;for(n=0;n<e.length;n++){var c=e[n];o=(d[s]||1)-1,i=s,l.series[D["default"].miniPos2key([o,i])]=n;for(var f=0;f<c.length;f++)a=d[s]||1,r=D["default"].miniPos2key([a,s]),u[r]=c[f],d[s]=a+1;d[s]+=2,s++,s>=D["default"].miniRows&&(s=0)}for(d=[],n=0,f=0,r=0,a=0,s=0,n=0;n<t.length;n++){var p=t[n];for(o=(d[s]||D["default"].miniColumns-1)-1,i=s,l.pairs[D["default"].miniPos2key([o,i])]=n,f=p.length-1;f>=0;f--)a=d[s]||D["default"].miniColumns-1,r=D["default"].miniPos2key([a,s]),u[r]=p[f],d[s]=a-1;d[s]-=1,s++,s>=D["default"].miniRows&&(s=0)}return{layout:u,groupMap:l}}function v(e,t,n){for(var r in e)if(e[r]===t){var a=D["default"].miniKey2pos(r),o=M(a,2),i=o[0],u=o[1],l=[i+n,u];return D["default"].miniPos2key(l)}}function m(e,t,n){var r=e.layout.groupMap.pairs;return v(r,t,n)}function g(e,t,n){var r=e.layout.groupMap.series;return v(r,t,n)}function h(e,t){var n=e.opens,r=n.series,a=n.layout.groupMap,o=M(t,2),i=o[0],u=o[1];for(var l in a.series){var d=a.series[l],s=r[d],c=D["default"].miniKey2pos(l),f=M(c,2),p=f[0],v=f[1],m=i-p;if(!(m<0||m>s.length+1||u!=v))return[d,m]}}function y(e,t){var n=e.opens,r=n.pairs,a=n.layout.groupMap,o=M(t,2),i=o[0],u=o[1];for(var l in a.pairs){var d=a.pairs[l],s=(r[d],D["default"].miniKey2pos(l)),c=M(s,2),f=c[0],p=c[1],v=i-f;if(!(v<0||v>1||u!=p))return[d,v]}}function w(e){var t={},n=o(e);return t[D["default"].middleCount]=n.number,n=u(n.left),t[D["default"].gosterge]=n.piece,t}function b(e){e=e.split("/");var t=2,n=3,r=4,a=1,o=0,i={e:"east",w:"west",n:"north",s:"south"}[e[o]];return{pieces:s(e[t]),discards:c(e[n],i),opens:f([e[r],e[r+1]].join("/")),middles:w(e[a])}}function P(e){var t=D["default"].allKeys.map(function(t){return e[t]}).map(function(e){return e&&e.key||" "}).join("");return t.replace(/([^\s])\s/g,"$1")}function k(e,t){return{color:K[e],number:A[t],c:e,n:parseInt(t),key:e+t}}function O(e){var t=e.c,n=e.n%13+1;return k(t,n)}function x(e){var t=e.c,n=(e.n+11)%13+1;return k(t,n)}function S(e){return"fake"===e.color}function E(e){return e.length>0&&14===e.match(T).length}var M=function(){function e(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var i,u=e[Symbol.iterator]();!(r=(i=u.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(l){a=!0,o=l}finally{try{!r&&u["return"]&&u["return"]()}finally{if(a)throw o}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),C=e("./util"),D=r(C),K={b:"blue",r:"red",g:"green",l:"black",f:"fake"},A={1:"one",2:"two",3:"three",4:"four",5:"five",6:"six",7:"seven",8:"eight",9:"nine",10:"ten",11:"eleven",12:"twelve",13:"thirteen"},T=/[f|r|l|b|g]\d\d?/g,B=function(){var e={};for(var t in K)e[K[t]]=a(t);return e}(),j=function(e){return B[e]},R="g7r7b7l7 g8r8b8l8 g13r13b13l13 l12 r6r5r4r12r13 g9g8g13 g6 l8l7l12",N="r1g1l1b1 r2g2l2b2 r3g3l3b3 r4g4l4b4 r13g13l13b13 r1g1l1b1",G="r1r2 r3r4r5r6r7r8r9r10r11r12r13l1l2l3l4l5l6l7   g1g2  l3",F="20l3",_="b1  r1r2 g1",L="r8l8b8\nb1b2b3\nb9b10b11b12\nl13r13b13\nr12b12g12\nr7r8r9r10\ng10g11g12\nl6b6r6\nl9l10l11\nb7l7r7g7\nr13l13b13g13\nl10r10b10g10\nl6r6g6\nl1b1g1\n/r1r1\ng1g1\ng2g2\ng3g3\ng4g4\ng5g5\ng6g6\ng7g7\ng8g8\ng9g9\ng10g10\ng11g11\ng12g12\n\n";t.exports={validDuzOkeyGroupFen:E,initial:G,rainbow:N,mixed:R,write:P,read:b,readDropPos:i,readPiece:u,readBoard:s,initialMiddles:F,initialDiscards:_,initialOpenGroups:L,readMiddles:w,readDiscards:c,readPieceGroup:l,readOpenGroups:f,layoutOpens:p,seriesByColor:j,makePiece:k,pieceUp:O,pieceDown:x,pieceFake:S,colors:K,getOpenSerieKeyFromGroupIndex:g,getOpenPairKeyFromGroupIndex:m,getOpenSerieFromPos:h,getOpenPairFromPos:y}},{"./util":15}],14:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.piece,a=n.group,p=n.pos;if(e.turnSide===e.povSide)switch(t){case R["default"].discard:r=G["default"].readPiece(r).piece,m(e,r,B["default"].discards[2]);break;case R["default"].drawMiddle:r=G["default"].readPiece(r).piece,e.middleHolder.current?I["default"].apiDrawMiddleEnd(e,r):I["default"].apiForceDrawMiddleEnd(e,r)}else{var v=B["default"].findPov(e.povSide,e.turnSide);switch(t){case R["default"].drawMiddle:s(e),e.animation.current.hint=R["default"].drawMiddle;break;case R["default"].drawLeft:c(e,B["default"].drawByPov(v));break;case R["default"].discard:r=G["default"].readPiece(r).piece,d(e,B["default"].discardByPov(v),r),e.animation.current.hint=R["default"].discard;break;case R["default"].leaveTaken:r=G["default"].readPiece(r).piece,f(e,B["default"].drawByPov(v),r);break;case R["default"].openSeries:a=G["default"].readPieceGroup(a),u(e,a);break;case R["default"].openPairs:a=G["default"].readPieceGroup(a),l(e,a);break;case R["default"].dropOpenSeries:r=G["default"].readPiece(r).piece,p=G["default"].readDropPos(p),o(e,r,p);break;case R["default"].dropOpenPairs:r=G["default"].readPiece(r).piece,p=G["default"].readDropPos(p),i(e,r,p);break;default:console.error("unknown move")}}}function o(e,t,n){var r=n.type,a=n.groupIndex,o=e.opens.series[a],i=r!==R["default"].dropReplace?0:1,u=0;if(r===R["default"].dropLeft)u=0;else if(r===R["default"].dropRight)u=o.length+1;else{var l=G["default"].pieceUp(e.middles[B["default"].gosterge]);u=_["default"].findOkeyIndex(o,l)+1}o.splice(u-i,i,t),e.opens.relayout(e)}function i(e,t,n){var r=n.groupIndex,a=e.opens.pairs[r],o=G["default"].pieceUp(e.middles[B["default"].gosterge]),i=_["default"].findOkeyIndex(a,o);a.splice(i,1,t),e.opens.relayout(e)}function u(e,t){var n=t,r=e.opens.series.concat(n);e.opens.series=r,e.opens.relayout(e)}function l(e,t){var n=t,r=e.opens.pairs.concat(n);e.opens.pairs=r,e.opens.relayout(e)}function d(e,t,n){return e.discards[t].unshift(n),e.lastMove=[t],!0}function s(e){return e.middles[B["default"].middleCount]--,e.lastMove=[B["default"].middleCount],!0}function c(e,t){return e.discards[t].shift(),!0}function f(e,t,n){return e.discards[t].unshift(n),!0}function p(e,t,n,r){if(!e.pieces[t]||!r)return!1;var a=e.pieces[t];X(B["default"].partial(e.events.move,R["default"].dropOpenSeries,q(a.key)));var o=A(r,2),i=o[0],u=o[1],l=e.opens.series[i],d=w(l,u),s=d!==R["default"].dropReplace?0:1;if(l.splice(u-s,s,a),e.opens.relayout(e),delete e.pieces[t],d===R["default"].dropReplace){var c=G["default"].pieceUp(e.middles[B["default"].gosterge]);e.pieces[t]=c}return!0}function v(e,t,n,r){if(!e.pieces[t]||!r)return!1;var a=e.pieces[t];X(B["default"].partial(e.events.move,R["default"].dropOpenPairs,q(a.key)));var o=A(r,2),i=o[0],u=o[1],l=e.opens.pairs[i];l.splice(u,1,a),e.opens.relayout(e),delete e.pieces[t];var d=G["default"].pieceUp(e.middles[B["default"].gosterge]);return e.pieces[t]=d,!0}function m(e,t,n){for(var r in e.pieces){var a=e.pieces[r];if(a&&B["default"].pieceEqual(t,a))return g(e,r,n),!0}return!1}function g(e,t,n){var r=e.pieces[t];return!!r&&(X(B["default"].partial(e.events.move,R["default"].discard,q(r.key))),e.discards[n].unshift(e.pieces[t]),delete e.pieces[t],e.lastMove=[n],!0)}function h(e,t){var n=e.pieces[t];return!!n&&(!!B["default"].pieceEqual(n,e.middles[B["default"].gosterge])&&(X(B["default"].partial(e.events.move,R["default"].sign,q(n.key))),!0))}function y(e,t){var n=e.pieces[t];if(!n)return!1;delete e.pieces[t];var r=(G["default"].write(e.pieces),I["default"].getPieceGroupSeries(e)),a=I["default"].getPieceGroupPairs(e);if(G["default"].validDuzOkeyGroupFen(r))X(B["default"].partial(e.events.move,R["default"].discardEndSeries,H(r)));else{if(!G["default"].validDuzOkeyGroupFen(a))return e.pieces[t]=n,!1;X(B["default"].partial(e.events.move,R["default"].discardEndPairs,H(a)))}return!0}function w(e,t){return 0===t?R["default"].dropLeft:t===e.length+1?R["default"].dropRight:R["default"].dropReplace}function b(e,t,n){if(n&&B["default"].isOpensKey(n)&&E(e,t,n)){var r,a,o,i,u,l=e.pieces[t],d=G["default"].getOpenSerieFromPos(e,B["default"].miniKey2pos(n));if(d){var s=A(d,2);r=s[0],a=s[1],o=e.opens.series[r],i=w(o,a),u=i+r}if(p(e,t,n,d))return X(B["default"].partial(e.movable.events.after,R["default"].dropOpenSeries,U(l.key,u))),!0;var c=G["default"].getOpenPairFromPos(e,B["default"].miniKey2pos(n));if(c){var f=A(c,2);r=f[0],a=f[1],o=e.opens.pairs[r],i=w(o,a),u=i+r}if(v(e,t,n,c))return X(B["default"].partial(e.movable.events.after,R["default"].dropOpenPairs,U(l.key,u))),!0}return!1}function P(e,t,n){var r=e.pieces[t];if(n&&n===B["default"].discards[2]){if(M(e,t,n)&&g(e,t,n))return X(B["default"].partial(e.movable.events.after,R["default"].discard,q(r.key))),!0}else if(n===B["default"].gosterge){if(D(e,t)&&h(e,t))return X(B["default"].partial(e.movable.events.after,R["default"].sign,q(r.key))),!0;if(C(e,t)&&y(e,t)){var a=(G["default"].write(e.pieces),I["default"].getPieceGroupSeries(e)),o=I["default"].getPieceGroupPairs(e);return G["default"].validDuzOkeyGroupFen(a)?X(B["default"].partial(e.movable.events.after,R["default"].discardEndSeries,H(a))):G["default"].validDuzOkeyGroupFen(o)&&X(B["default"].partial(e.movable.events.after,R["default"].discardEndPairs,H(o))),!0}}return!1}function k(e,t){O(e,t)}function O(e,t){e.selected=t}function x(e,t){return B["default"].isMiddleKey(t)||B["default"].isDrawLeftKey(t)?e.povSide===e.turnSide:B["default"].isBoardKey(t)}function S(e){return e.povSide===e.turnSide}function E(e,t,n){var r=e.middles[B["default"].gosterge];return I["default"].isDroppableOpens(e,t)&&B["default"].isBoardKey(t)&&B["default"].isOpensKey(n)&&B["default"].containsX(e.movable.dests,R["default"].dropOpenSeries)&&B["default"].containsX(e.movable.dests,R["default"].dropOpenPairs)&&B["default"].containsX(_["default"].compute(e.opens,e.pieces[t],r),n)}function M(e,t,n){return S(e)&&B["default"].containsX(e.movable.dests,R["default"].discard)}function C(e,t){return S(e)&&B["default"].containsX(e.movable.dests,R["default"].discardEndSeries)}function D(e,t){return S(e)&&B["default"].containsX(e.movable.dests,R["default"].showSign)}function K(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B["default"].topColumns,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:B["default"].topRows;return function(r,a,o){if(o||r.bounds){o=o||r.bounds();var i=Math.floor(t*((a[0]-o.left)/o.width)),u=Math.floor(n*((a[1]-o.top)/o.height));return u>=0&&u<n&&i>=0&&i<t?e(u,i):void 0}}}Object.defineProperty(n,"__esModule",{value:!0});var A=function(){function e(e,t){var n=[],r=!0,a=!1,o=void 0;try{for(var i,u=e[Symbol.iterator]();!(r=(i=u.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(l){a=!0,o=l}finally{try{!r&&u["return"]&&u["return"]()}finally{if(a)throw o}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),T=e("./util"),B=r(T),j=e("./move"),R=r(j),N=e("./pieces"),G=r(N),F=e("./open"),_=r(F),L=e("./board"),I=r(L),U=B["default"].wrapDrop,q=B["default"].wrapPiece,H=B["default"].wrapGroup,X=B["default"].callUserFunction,z=K(function(e,t){return B["default"].miniPos2key([t,e])},B["default"].miniColumns,B["default"].miniRows),$=K(function(e,t){if(e===B["default"].topRows-1){if(0===t)return B["default"].discards[1];if(t===B["default"].topColumns-4)return B["default"].middleCount}}),J=K(function(e,t){if(e===B["default"].topRows-1){if(t===B["default"].topColumns-1)return B["default"].discards[2];if(t===B["default"].topColumns-3)return B["default"].gosterge}});n["default"]={apiMove:a,selectTop:k,dropTop:P,dropOpens:b,isDraggable:x,getDrawKeyAtDomPos:$,getDiscardKeyAtDomPos:J,getOpensKeyAtDomPos:z},t.exports=n["default"]},{"./board":5,"./move":11,"./open":12,"./pieces":13,"./util":15}],15:[function(e,t,n){"use strict";function r(e,t){return G[e][t]}function a(e,t){return e.color===t.color&&e.number===t.number}function o(e,t){for(var n=[],r=0;r<e;r++)for(var a=0;a<t;a++)n.push([a,r]);return n}function i(e,t){return t+e}function u(e,t){return parseInt(e.slice(1))}function l(e){return i(u(e)-1,V)}function d(e){return e[0]===V}function s(e){return e[0]===Y}function c(e){return e===X}function f(e){return e===H[1]}function p(e){var t=e[1]*K+e[0];return i(t,V)}function v(e){return e=u(e),[e%K,Math.floor(e/K)]}function m(e){return $[e]}function g(e){var t=e[1]*j+e[0];return i(t,Y)}function h(e){return e=u(e),[e%j,Math.floor(e/j)]}function y(e){var t=[];for(var n in e)e[n]&&t.push(n);return t.join(" ")}function w(e,t){return e&&e.indexOf(t)!==-1}function b(e){return e.touches?[e.targetTouches[0].clientX,e.targetTouches[0].clientY]:[e.clientX,e.clientY]}function P(e,t){return Math.sqrt(Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2))}function k(){return"transform"in document.body.style?"transform":"webkitTransform"in document.body.style?"webkitTransform":"mozTransform"in document.body.style?"mozTransform":"oTransform"in document.body.style?"oTransform":"msTransform"}function O(){return D||(D=k()),D}function x(e){return"translate("+e[0]+"px,"+e[1]+"px)"}function S(e,t){return e.bind.apply(e,[null].concat(t))}function E(){return S(arguments[0],Array.prototype.slice.call(arguments,1))}function M(e){var t,n=function(){return void 0===t&&(t=e()),t};return n.clear=function(){t=void 0},n}function C(e){setTimeout(e,1)}var D,K=32,A=2,T=16,B=7,j=20,R=8,N=["east","west","north","south"],G={east:{east:"down",west:"up",north:"right",south:"left"},west:{east:"up",west:"down",north:"left",south:"right"},north:{east:"left",west:"right",north:"down",south:"up"},south:{east:"right",west:"left",north:"up",south:"down"}},F={up:0,left:1,down:2,right:3},_={up:3,left:0,down:1,right:2},L={up:[.5,0],left:[0,.5],right:[1,.5],down:[.5,1]},I=function(e){return L[e]},U=function(e){return H[F[e]]},q=function(e){return H[_[e]]},H=["dup","dleft","ddown","dright"],X="mmiddleCount",z="mgosterge",$={dup:[0,0],dleft:[0,B-1],ddown:[T-1,B-1],dright:[T-1,0],mmiddleCount:[T-4,B-1],mgosterge:[T-3,B-1]},J={color:"empty",number:1},V="b",Y="o",Q=o(A,K),W=o(R,j),Z=[[0,0],[30,0],[31,0],[32,0],[62,0],[63,0]].map(p),ee=function(e){return Z.indexOf(e)===-1},te=Q.map(p),ne=te.filter(ee),re=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t.piece=e,t},ae=function(e){return{group:e}},oe=function(e,t){return{piece:e,pos:t}};t.exports={topColumns:T,topRows:B,columns:K,rows:A,emptyPiece:J,pieceEqual:a,allSides:N,allPos:Q,allKeys:te,topKey2pos:m,pos2key:p,key2pos:v,miniColumns:j,miniRows:R,miniAllPos:W,miniPos2key:g,miniKey2pos:h,encodeKey:i,decBoardKey:l,notAllowedBoardKeys:Z,isAllowedBoardKey:ee,allAllowedBoardKeys:ne,isBoardKey:d,isOpensKey:s,isMiddleKey:c,isDrawLeftKey:f,findPov:r,vectorByPov:I,drawByPov:q,discardByPov:U,discards:H,middleCount:X,gosterge:z,classSet:y,containsX:w,eventPosition:b,distance:P,transformProp:O,translate:x,requestAnimationFrame:(window.requestAnimationFrame||window.setTimeout).bind(window),partialApply:S,partial:E,memo:M,wrapPiece:re,wrapGroup:ae,wrapDrop:oe,callUserFunction:C}},{}],16:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){return e.color+" "+e.number}function o(e){return{left:e[0]*(100/K["default"].columns)+"%",top:e[1]*(100/K["default"].rows)+"%"}}function i(e){return{left:e[0]*(100/K["default"].miniColumns)+"%",top:e[1]*(100/K["default"].miniRows)+"%"}}function u(e,t,n,r){var o=(e.data,{key:n,style:i(t),"class":a(r)+" mini"});return{tag:"piece",attrs:o}}function l(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=e.data,i=K["default"].classSet({selected:o.selected===t,"last-move":o.lastMove&&K["default"].containsX(o.lastMove,t)}),u={style:{},"class":[a(n),t,i].join(" "),"data-middle-count":e.data.middles[t]},l=e.data.draggable.current;if(r&&l.orig===t)u.style[K["default"].transformProp()]=K["default"].translate([l.pos[0]+l.dec[0],l.pos[1]+l.dec[1]]),u["class"]+=" dragging";else if(!r&&e.data.animation.current.anims){var d=e.data.animation.current.anims[t];d&&(u.style[K["default"].transformProp()]=K["default"].translate(d[1]))}return{tag:"piece",attrs:u}}function d(e,t,n,r){var o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=e.data,u=K["default"].classSet({selected:i.selected===t}),l={key:t+(o?"":"d"),style:{},"class":[a(n),t,u].join(" ")};r&&(l["class"]+=" "+r);var d=e.data.draggable.current;if(o&&d.orig===t)l.style[K["default"].transformProp()]=K["default"].translate([d.pos[0]+d.dec[0],d.pos[1]+d.dec[1]]),l["class"]+=" dragging";else if(o&&e.data.animation.current.anims){var s=e.data.animation.current.anims[t];s&&(l.style[K["default"].transformProp()]=K["default"].translate(s[1]))}return{tag:"piece",attrs:l}}function s(e,t,n){var r=(e.data,K["default"].classSet({"piece-holder":!0})),a={key:t,style:{},"class":[t,r,n].join(" ")};return{tag:"div",attrs:a}}function c(e,t,n,r,i){var u=e.data,l=K["default"].classSet({selected:u.selected===n}),d={key:n,style:o(t),"class":[a(r),l].join(" ")};i&&(d["class"]+=" "+i);var s=e.data.draggable.current;return s.orig===n&&(s.over&&K["default"].isOpensKey(s.over)&&(d.style.width=s.opensBounds.width/K["default"].miniColumns+"px",d.style.height=s.opensBounds.height/K["default"].miniRows+"px"),d.style[K["default"].transformProp()]=K["default"].translate([s.pos[0]+s.dec[0],s.pos[1]+s.dec[1]]),d["class"]+=" dragging"),{tag:"piece",attrs:d}}function f(e,t,n){return{tag:"div",attrs:{"class":e+" oc "+n}}}function p(e,t,n){return{tag:"div",attrs:{style:i(n),"class":e+" oc"}}}function v(e,t,n){return{tag:"div",attrs:{style:o(n),"class":e}}}function m(e){function t(e){return{tag:"div",attrs:{"class":"wood "+e}}}var n,r=e.data,a=K["default"].allPos,o=[];o.push(t("left"),t("right"));for(var i=0;i<a.length;i++){var u=K["default"].pos2key(a[i]),l=r.pieces[u];l&&o.push(c(e,a[i],u,l)),r.draggable.current.over===u&&(n=v("drag-over",e,a[i]))}return r.middleHolder.key&&o.push(c(e,K["default"].key2pos(r.middleHolder.key),r.middleHolder.key,K["default"].emptyPiece,"loading")),n&&o.push(n),{tag:"div",attrs:{config:function(t,n,r){n||(e.data.boardBounds=K["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-board"},children:o}}function g(e,t){for(var n=e.data,r=K["default"].miniAllPos,a=[],o=[],i=0;i<r.length;i++){var l=K["default"].miniPos2key(r[i]),d=t[l];d&&a.push(u(e,r[i],l,d));var s=K["default"].classSet({"drag-over":n.draggable.current.over===l,"move-dest":K["default"].containsX(n.openable.dests,l)});""!==s&&o.push(p(s,e,r[i]))}return a.push(o),a}function h(e){var t=e.data,n=g(e,t.opens.layout.layout);return{tag:"div",attrs:{config:function(t,n,r){n||(e.data.opensBounds=K["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-opens"},children:n}}function y(e){var t=e.data,n=[],r=[];for(var a in t.discards){var o=t.discards[a][0],i=K["default"].classSet({"drag-over":t.draggable.current.over===a,"move-dest":"ddown"===a&&t.selected&&K["default"].isBoardKey(t.selected)&&K["default"].containsX(t.movable.dests,T["default"].discard),"last-move":t.lastMove&&K["default"].containsX(t.lastMove,a)});o?(t.discards[a][1]&&r.push(d(e,a,t.discards[a][1],"fake",!1)),r.push(d(e,a,o,i))):n.push(s(e,a,i))}return n.push(r),n}function w(e){var t=e.data,n=[],r=t.middleHolder.piece||K["default"].emptyPiece;return n.push(d(e,K["default"].gosterge,t.middles[K["default"].gosterge])),n.push(l(e,K["default"].middleCount,K["default"].emptyPiece)),(K["default"].isMiddleKey(t.draggable.current.orig)||t.animation.current.anims&&t.animation.current.anims[K["default"].middleCount])&&n.push(l(e,K["default"].middleCount,r,!0)),t.draggable.current.over===K["default"].gosterge&&n.push(f("drag-over",e,K["default"].gosterge)),n}function b(e){var t=[w(e),y(e),h(e)];return{tag:"div",attrs:{config:function(t,n,r){n||(e.data.topBounds=K["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-top"},children:t}}function P(e){return[b(e),m(e)]}function k(e,t){return function(n){t(e,n)}}function O(e,t,n){var r=e.data,a=k(r,C["default"].start),o=k(r,C["default"].move),i=k(r,C["default"].end),u=["touchstart","mousedown"],l=["touchmove","mousemove"],d=["touchend","mouseup"];u.forEach(function(e){t.addEventListener(e,a)}),l.forEach(function(e){document.addEventListener(e,o)}),d.forEach(function(e){document.addEventListener(e,i)}),n.onunload=function(){u.forEach(function(e){t.removeEventListener(e,a)}),l.forEach(function(e){document.removeEventListener(e,o)}),d.forEach(function(e){document.removeEventListener(e,i)})}}function x(e){
return{tag:"div",attrs:{"class":"og-table",config:function(t,n,r){n||(O(e,t,r),e.data.render=function(){E["default"].render(t,P(e))},e.data.renderRAF=function(){K["default"].requestAnimationFrame(e.data.render)},e.data.bounds=K["default"].memo(t.getBoundingClientRect.bind(t)),e.data.element=t,e.data.render())}},children:[]}}var S=e("mithril"),E=r(S),M=e("./drag"),C=r(M),D=e("./util"),K=r(D),A=e("./move"),T=r(A);t.exports=function(e){return{tag:"div",attrs:{config:function(t,n){n||["onscroll","onresize"].forEach(function(t){var n=window[t];window[t]=function(){n&&n(),e.data.bounds.clear(),e.data.boardBounds.clear(),e.data.opensBounds.clear(),e.data.topBounds.clear()}})},"class":["og-table-wrap"].join(" ")},children:[x(e)]}}},{"./drag":9,"./move":11,"./util":15,mithril:2}]},{},[10])(10)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

},{}],3:[function(require,module,exports){
var conversions = require("./conversions");

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;
},{"./conversions":2}],4:[function(require,module,exports){
module.exports={
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
}
},{}],5:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');

module.exports = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
}

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr =  /^#([a-fA-F0-9]{3})$/,
       hex =  /^#([a-fA-F0-9]{6})$/,
       rgba = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d\.]+)\s*)?\)$/,
       per = /^rgba?\(\s*([\d\.]+)\%\s*,\s*([\d\.]+)\%\s*,\s*([\d\.]+)\%\s*(?:,\s*([\d\.]+)\s*)?\)$/,
       keyword = /(\D+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr);
   if (match) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   }
   else if (match = string.match(hex)) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   }
   else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   }
   else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*(\d+)(?:deg)?\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*(?:,\s*([\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(parseFloat(match[4]) || 1, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*(\d+)(?:deg)?\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*(?:,\s*([\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(parseFloat(match[4]) || 1, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   }
   else if (vals = getHsla(string)) {
      return vals[3];
   }
   else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgb) {
   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
              + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return (str.length < 2) ? "0" + str : str;
}


//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
   reverseNames[colorNames[name]] = name;
}
},{"color-name":4}],6:[function(require,module,exports){
/* MIT license */
var convert = require("color-convert"),
    string = require("color-string");

var Color = function(cssString) {
  if (cssString instanceof Color) return cssString;
  if (! (this instanceof Color)) return new Color(cssString);

   this.values = {
      rgb: [0, 0, 0],
      hsl: [0, 0, 0],
      hsv: [0, 0, 0],
      hwb: [0, 0, 0],
      cmyk: [0, 0, 0, 0],
      alpha: 1
   }

   // parse Color() argument
   if (typeof cssString == "string") {
      var vals = string.getRgba(cssString);
      if (vals) {
         this.setValues("rgb", vals);
      }
      else if(vals = string.getHsla(cssString)) {
         this.setValues("hsl", vals);
      }
      else if(vals = string.getHwb(cssString)) {
         this.setValues("hwb", vals);
      }
      else {
        throw new Error("Unable to parse color from string \"" + cssString + "\"");
      }
   }
   else if (typeof cssString == "object") {
      var vals = cssString;
      if(vals["r"] !== undefined || vals["red"] !== undefined) {
         this.setValues("rgb", vals)
      }
      else if(vals["l"] !== undefined || vals["lightness"] !== undefined) {
         this.setValues("hsl", vals)
      }
      else if(vals["v"] !== undefined || vals["value"] !== undefined) {
         this.setValues("hsv", vals)
      }
      else if(vals["w"] !== undefined || vals["whiteness"] !== undefined) {
         this.setValues("hwb", vals)
      }
      else if(vals["c"] !== undefined || vals["cyan"] !== undefined) {
         this.setValues("cmyk", vals)
      }
      else {
        throw new Error("Unable to parse color from object " + JSON.stringify(cssString));
      }
   }
}

Color.prototype = {
   rgb: function (vals) {
      return this.setSpace("rgb", arguments);
   },
   hsl: function(vals) {
      return this.setSpace("hsl", arguments);
   },
   hsv: function(vals) {
      return this.setSpace("hsv", arguments);
   },
   hwb: function(vals) {
      return this.setSpace("hwb", arguments);
   },
   cmyk: function(vals) {
      return this.setSpace("cmyk", arguments);
   },

   rgbArray: function() {
      return this.values.rgb;
   },
   hslArray: function() {
      return this.values.hsl;
   },
   hsvArray: function() {
      return this.values.hsv;
   },
   hwbArray: function() {
      if (this.values.alpha !== 1) {
        return this.values.hwb.concat([this.values.alpha])
      }
      return this.values.hwb;
   },
   cmykArray: function() {
      return this.values.cmyk;
   },
   rgbaArray: function() {
      var rgb = this.values.rgb;
      return rgb.concat([this.values.alpha]);
   },
   hslaArray: function() {
      var hsl = this.values.hsl;
      return hsl.concat([this.values.alpha]);
   },
   alpha: function(val) {
      if (val === undefined) {
         return this.values.alpha;
      }
      this.setValues("alpha", val);
      return this;
   },

   red: function(val) {
      return this.setChannel("rgb", 0, val);
   },
   green: function(val) {
      return this.setChannel("rgb", 1, val);
   },
   blue: function(val) {
      return this.setChannel("rgb", 2, val);
   },
   hue: function(val) {
      return this.setChannel("hsl", 0, val);
   },
   saturation: function(val) {
      return this.setChannel("hsl", 1, val);
   },
   lightness: function(val) {
      return this.setChannel("hsl", 2, val);
   },
   saturationv: function(val) {
      return this.setChannel("hsv", 1, val);
   },
   whiteness: function(val) {
      return this.setChannel("hwb", 1, val);
   },
   blackness: function(val) {
      return this.setChannel("hwb", 2, val);
   },
   value: function(val) {
      return this.setChannel("hsv", 2, val);
   },
   cyan: function(val) {
      return this.setChannel("cmyk", 0, val);
   },
   magenta: function(val) {
      return this.setChannel("cmyk", 1, val);
   },
   yellow: function(val) {
      return this.setChannel("cmyk", 2, val);
   },
   black: function(val) {
      return this.setChannel("cmyk", 3, val);
   },

   hexString: function() {
      return string.hexString(this.values.rgb);
   },
   rgbString: function() {
      return string.rgbString(this.values.rgb, this.values.alpha);
   },
   rgbaString: function() {
      return string.rgbaString(this.values.rgb, this.values.alpha);
   },
   percentString: function() {
      return string.percentString(this.values.rgb, this.values.alpha);
   },
   hslString: function() {
      return string.hslString(this.values.hsl, this.values.alpha);
   },
   hslaString: function() {
      return string.hslaString(this.values.hsl, this.values.alpha);
   },
   hwbString: function() {
      return string.hwbString(this.values.hwb, this.values.alpha);
   },
   keyword: function() {
      return string.keyword(this.values.rgb, this.values.alpha);
   },

   rgbNumber: function() {
      return (this.values.rgb[0] << 16) | (this.values.rgb[1] << 8) | this.values.rgb[2];
   },

   luminosity: function() {
      // http://www.w3.org/TR/WCAG20/#relativeluminancedef
      var rgb = this.values.rgb;
      var lum = [];
      for (var i = 0; i < rgb.length; i++) {
         var chan = rgb[i] / 255;
         lum[i] = (chan <= 0.03928) ? chan / 12.92
                  : Math.pow(((chan + 0.055) / 1.055), 2.4)
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
   },

   contrast: function(color2) {
      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
         return (lum1 + 0.05) / (lum2 + 0.05)
      };
      return (lum2 + 0.05) / (lum1 + 0.05);
   },

   level: function(color2) {
     var contrastRatio = this.contrast(color2);
     return (contrastRatio >= 7.1)
       ? 'AAA'
       : (contrastRatio >= 4.5)
        ? 'AA'
        : '';
   },

   dark: function() {
      // YIQ equation from http://24ways.org/2010/calculating-color-contrast
      var rgb = this.values.rgb,
          yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
   	return yiq < 128;
   },

   light: function() {
      return !this.dark();
   },

   negate: function() {
      var rgb = []
      for (var i = 0; i < 3; i++) {
         rgb[i] = 255 - this.values.rgb[i];
      }
      this.setValues("rgb", rgb);
      return this;
   },

   lighten: function(ratio) {
      this.values.hsl[2] += this.values.hsl[2] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   darken: function(ratio) {
      this.values.hsl[2] -= this.values.hsl[2] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   saturate: function(ratio) {
      this.values.hsl[1] += this.values.hsl[1] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   desaturate: function(ratio) {
      this.values.hsl[1] -= this.values.hsl[1] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   whiten: function(ratio) {
      this.values.hwb[1] += this.values.hwb[1] * ratio;
      this.setValues("hwb", this.values.hwb);
      return this;
   },

   blacken: function(ratio) {
      this.values.hwb[2] += this.values.hwb[2] * ratio;
      this.setValues("hwb", this.values.hwb);
      return this;
   },

   greyscale: function() {
      var rgb = this.values.rgb;
      // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      this.setValues("rgb", [val, val, val]);
      return this;
   },

   clearer: function(ratio) {
      this.setValues("alpha", this.values.alpha - (this.values.alpha * ratio));
      return this;
   },

   opaquer: function(ratio) {
      this.setValues("alpha", this.values.alpha + (this.values.alpha * ratio));
      return this;
   },

   rotate: function(degrees) {
      var hue = this.values.hsl[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      this.values.hsl[0] = hue;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   mix: function(color2, weight) {
      weight = 1 - (weight == null ? 0.5 : weight);

      // algorithm from Sass's mix(). Ratio of first color in mix is
      // determined by the alphas of both colors and the weight
      var t1 = weight * 2 - 1,
          d = this.alpha() - color2.alpha();

      var weight1 = (((t1 * d == -1) ? t1 : (t1 + d) / (1 + t1 * d)) + 1) / 2;
      var weight2 = 1 - weight1;

      var rgb = this.rgbArray();
      var rgb2 = color2.rgbArray();

      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = rgb[i] * weight1 + rgb2[i] * weight2;
      }
      this.setValues("rgb", rgb);

      var alpha = this.alpha() * weight + color2.alpha() * (1 - weight);
      this.setValues("alpha", alpha);

      return this;
   },

   toJSON: function() {
     return this.rgb();
   },

   clone: function() {
     return new Color(this.rgb());
   }
}


Color.prototype.getValues = function(space) {
   var vals = {};
   for (var i = 0; i < space.length; i++) {
      vals[space[i]] = this.values[space][i];
   }
   if (this.values.alpha != 1) {
      vals["a"] = this.values.alpha;
   }
   // {r: 255, g: 255, b: 255, a: 0.4}
   return vals;
}

Color.prototype.setValues = function(space, vals) {
   var spaces = {
      "rgb": ["red", "green", "blue"],
      "hsl": ["hue", "saturation", "lightness"],
      "hsv": ["hue", "saturation", "value"],
      "hwb": ["hue", "whiteness", "blackness"],
      "cmyk": ["cyan", "magenta", "yellow", "black"]
   };

   var maxes = {
      "rgb": [255, 255, 255],
      "hsl": [360, 100, 100],
      "hsv": [360, 100, 100],
      "hwb": [360, 100, 100],
      "cmyk": [100, 100, 100, 100]
   };

   var alpha = 1;
   if (space == "alpha") {
      alpha = vals;
   }
   else if (vals.length) {
      // [10, 10, 10]
      this.values[space] = vals.slice(0, space.length);
      alpha = vals[space.length];
   }
   else if (vals[space[0]] !== undefined) {
      // {r: 10, g: 10, b: 10}
      for (var i = 0; i < space.length; i++) {
        this.values[space][i] = vals[space[i]];
      }
      alpha = vals.a;
   }
   else if (vals[spaces[space][0]] !== undefined) {
      // {red: 10, green: 10, blue: 10}
      var chans = spaces[space];
      for (var i = 0; i < space.length; i++) {
        this.values[space][i] = vals[chans[i]];
      }
      alpha = vals.alpha;
   }
   this.values.alpha = Math.max(0, Math.min(1, (alpha !== undefined ? alpha : this.values.alpha) ));
   if (space == "alpha") {
      return;
   }

   // cap values of the space prior converting all values
   for (var i = 0; i < space.length; i++) {
      var capped = Math.max(0, Math.min(maxes[space][i], this.values[space][i]));
      this.values[space][i] = Math.round(capped);
   }

   // convert to all the other color spaces
   for (var sname in spaces) {
      if (sname != space) {
         this.values[sname] = convert[space][sname](this.values[space])
      }

      // cap values
      for (var i = 0; i < sname.length; i++) {
         var capped = Math.max(0, Math.min(maxes[sname][i], this.values[sname][i]));
         this.values[sname][i] = Math.round(capped);
      }
   }
   return true;
}

Color.prototype.setSpace = function(space, args) {
   var vals = args[0];
   if (vals === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof vals == "number") {
      vals = Array.prototype.slice.call(args);
   }
   this.setValues(space, vals);
   return this;
}

Color.prototype.setChannel = function(space, index, val) {
   if (val === undefined) {
      // color.red()
      return this.values[space][index];
   }
   // color.red(100)
   this.values[space][index] = val;
   this.setValues(space, this.values[space]);
   return this;
}

module.exports = Color;

},{"color-convert":3,"color-string":5}],7:[function(require,module,exports){
/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
(function (window, document, Math) {
var rAF = window.requestAnimationFrame	||
	window.webkitRequestAnimationFrame	||
	window.mozRequestAnimationFrame		||
	window.oRequestAnimationFrame		||
	window.msRequestAnimationFrame		||
	function (callback) { window.setTimeout(callback, 1000 / 60); };

var utils = (function () {
	var me = {};

	var _elementStyle = document.createElement('div').style;
	var _vendor = (function () {
		var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			transform,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			transform = vendors[i] + 'ransform';
			if ( transform in _elementStyle ) return vendors[i].substr(0, vendors[i].length-1);
		}

		return false;
	})();

	function _prefixStyle (style) {
		if ( _vendor === false ) return false;
		if ( _vendor === '' ) return style;
		return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
	}

	me.getTime = Date.now || function getTime () { return new Date().getTime(); };

	me.extend = function (target, obj) {
		for ( var i in obj ) {
			target[i] = obj[i];
		}
	};

	me.addEvent = function (el, type, fn, capture) {
		el.addEventListener(type, fn, !!capture);
	};

	me.removeEvent = function (el, type, fn, capture) {
		el.removeEventListener(type, fn, !!capture);
	};

	me.prefixPointerEvent = function (pointerEvent) {
		return window.MSPointerEvent ?
			'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8):
			pointerEvent;
	};

	me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
		var distance = current - start,
			speed = Math.abs(distance) / time,
			destination,
			duration;

		deceleration = deceleration === undefined ? 0.0006 : deceleration;

		destination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance < 0 ? -1 : 1 );
		duration = speed / deceleration;

		if ( destination < lowerMargin ) {
			destination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin;
			distance = Math.abs(destination - current);
			duration = distance / speed;
		} else if ( destination > 0 ) {
			destination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0;
			distance = Math.abs(current) + destination;
			duration = distance / speed;
		}

		return {
			destination: Math.round(destination),
			duration: duration
		};
	};

	var _transform = _prefixStyle('transform');

	me.extend(me, {
		hasTransform: _transform !== false,
		hasPerspective: _prefixStyle('perspective') in _elementStyle,
		hasTouch: 'ontouchstart' in window,
		hasPointer: !!(window.PointerEvent || window.MSPointerEvent), // IE10 is prefixed
		hasTransition: _prefixStyle('transition') in _elementStyle
	});

	/*
	This should find all Android browsers lower than build 535.19 (both stock browser and webview)
	- galaxy S2 is ok
    - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`
    - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S3 is badAndroid (stock brower, webview)
     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S4 is badAndroid (stock brower, webview)
     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S5 is OK
     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
   - galaxy S6 is OK
     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
  */
	me.isBadAndroid = (function() {
		var appVersion = window.navigator.appVersion;
		// Android browser is not a chrome browser.
		if (/Android/.test(appVersion) && !(/Chrome\/\d/.test(appVersion))) {
			var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);
			if(safariVersion && typeof safariVersion === "object" && safariVersion.length >= 2) {
				return parseFloat(safariVersion[1]) < 535.19;
			} else {
				return true;
			}
		} else {
			return false;
		}
	})();

	me.extend(me.style = {}, {
		transform: _transform,
		transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
		transitionDuration: _prefixStyle('transitionDuration'),
		transitionDelay: _prefixStyle('transitionDelay'),
		transformOrigin: _prefixStyle('transformOrigin')
	});

	me.hasClass = function (e, c) {
		var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
		return re.test(e.className);
	};

	me.addClass = function (e, c) {
		if ( me.hasClass(e, c) ) {
			return;
		}

		var newclass = e.className.split(' ');
		newclass.push(c);
		e.className = newclass.join(' ');
	};

	me.removeClass = function (e, c) {
		if ( !me.hasClass(e, c) ) {
			return;
		}

		var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
		e.className = e.className.replace(re, ' ');
	};

	me.offset = function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;

		// jshint -W084
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		// jshint +W084

		return {
			left: left,
			top: top
		};
	};

	me.preventDefaultException = function (el, exceptions) {
		for ( var i in exceptions ) {
			if ( exceptions[i].test(el[i]) ) {
				return true;
			}
		}

		return false;
	};

	me.extend(me.eventType = {}, {
		touchstart: 1,
		touchmove: 1,
		touchend: 1,

		mousedown: 2,
		mousemove: 2,
		mouseup: 2,

		pointerdown: 3,
		pointermove: 3,
		pointerup: 3,

		MSPointerDown: 3,
		MSPointerMove: 3,
		MSPointerUp: 3
	});

	me.extend(me.ease = {}, {
		quadratic: {
			style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
			fn: function (k) {
				return k * ( 2 - k );
			}
		},
		circular: {
			style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',	// Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
			fn: function (k) {
				return Math.sqrt( 1 - ( --k * k ) );
			}
		},
		back: {
			style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
			fn: function (k) {
				var b = 4;
				return ( k = k - 1 ) * k * ( ( b + 1 ) * k + b ) + 1;
			}
		},
		bounce: {
			style: '',
			fn: function (k) {
				if ( ( k /= 1 ) < ( 1 / 2.75 ) ) {
					return 7.5625 * k * k;
				} else if ( k < ( 2 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
				} else if ( k < ( 2.5 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
				} else {
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
				}
			}
		},
		elastic: {
			style: '',
			fn: function (k) {
				var f = 0.22,
					e = 0.4;

				if ( k === 0 ) { return 0; }
				if ( k == 1 ) { return 1; }

				return ( e * Math.pow( 2, - 10 * k ) * Math.sin( ( k - f / 4 ) * ( 2 * Math.PI ) / f ) + 1 );
			}
		}
	});

	me.tap = function (e, eventName) {
		var ev = document.createEvent('Event');
		ev.initEvent(eventName, true, true);
		ev.pageX = e.pageX;
		ev.pageY = e.pageY;
		e.target.dispatchEvent(ev);
	};

	me.click = function (e) {
		var target = e.target,
			ev;

		if ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) {
			ev = document.createEvent('MouseEvents');
			ev.initMouseEvent('click', true, true, e.view, 1,
				target.screenX, target.screenY, target.clientX, target.clientY,
				e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
				0, null);

			ev._constructed = true;
			target.dispatchEvent(ev);
		}
	};

	return me;
})();
function IScroll (el, options) {
	this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
	this.scroller = this.wrapper.children[0];
	this.scrollerStyle = this.scroller.style;		// cache style for better performance

	this.options = {

		resizeScrollbars: true,

		mouseWheelSpeed: 20,

		snapThreshold: 0.334,

// INSERT POINT: OPTIONS
		disablePointer : !utils.hasPointer,
		disableTouch : utils.hasPointer || !utils.hasTouch,
		disableMouse : utils.hasPointer || utils.hasTouch,
		startX: 0,
		startY: 0,
		scrollY: true,
		directionLockThreshold: 5,
		momentum: true,

		bounce: true,
		bounceTime: 600,
		bounceEasing: '',

		preventDefault: true,
		preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

		HWCompositing: true,
		useTransition: true,
		useTransform: true,
		bindToWrapper: typeof window.onmousedown === "undefined"
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	// Normalize options
	this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

	this.options.useTransition = utils.hasTransition && this.options.useTransition;
	this.options.useTransform = utils.hasTransform && this.options.useTransform;

	this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
	this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

	// If you want eventPassthrough I have to lock one of the axes
	this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
	this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

	// With eventPassthrough we also need lockDirection mechanism
	this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
	this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

	this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

	this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

	if ( this.options.tap === true ) {
		this.options.tap = 'tap';
	}

	if ( this.options.shrinkScrollbars == 'scale' ) {
		this.options.useTransition = false;
	}

	this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

// INSERT POINT: NORMALIZATION

	// Some defaults
	this.x = 0;
	this.y = 0;
	this.directionX = 0;
	this.directionY = 0;
	this._events = {};

// INSERT POINT: DEFAULTS

	this._init();
	this.refresh();

	this.scrollTo(this.options.startX, this.options.startY);
	this.enable();
}

IScroll.prototype = {
	version: '5.2.0',

	_init: function () {
		this._initEvents();

		if ( this.options.scrollbars || this.options.indicators ) {
			this._initIndicators();
		}

		if ( this.options.mouseWheel ) {
			this._initWheel();
		}

		if ( this.options.snap ) {
			this._initSnap();
		}

		if ( this.options.keyBindings ) {
			this._initKeys();
		}

// INSERT POINT: _init

	},

	destroy: function () {
		this._initEvents(true);
		clearTimeout(this.resizeTimeout);
 		this.resizeTimeout = null;
		this._execEvent('destroy');
	},

	_transitionEnd: function (e) {
		if ( e.target != this.scroller || !this.isInTransition ) {
			return;
		}

		this._transitionTime();
		if ( !this.resetPosition(this.options.bounceTime) ) {
			this.isInTransition = false;
			this._execEvent('scrollEnd');
		}
	},

	_start: function (e) {
		// React to left mouse button only
		if ( utils.eventType[e.type] != 1 ) {
		  // for button property
		  // http://unixpapa.com/js/mouse.html
		  var button;
	    if (!e.which) {
	      /* IE case */
	      button = (e.button < 2) ? 0 :
	               ((e.button == 4) ? 1 : 2);
	    } else {
	      /* All others */
	      button = e.button;
	    }
			if ( button !== 0 ) {
				return;
			}
		}

		if ( !this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated) ) {
			return;
		}

		if ( this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.touches ? e.touches[0] : e,
			pos;

		this.initiated	= utils.eventType[e.type];
		this.moved		= false;
		this.distX		= 0;
		this.distY		= 0;
		this.directionX = 0;
		this.directionY = 0;
		this.directionLocked = 0;

		this.startTime = utils.getTime();

		if ( this.options.useTransition && this.isInTransition ) {
			this._transitionTime();
			this.isInTransition = false;
			pos = this.getComputedPosition();
			this._translate(Math.round(pos.x), Math.round(pos.y));
			this._execEvent('scrollEnd');
		} else if ( !this.options.useTransition && this.isAnimating ) {
			this.isAnimating = false;
			this._execEvent('scrollEnd');
		}

		this.startX    = this.x;
		this.startY    = this.y;
		this.absStartX = this.x;
		this.absStartY = this.y;
		this.pointX    = point.pageX;
		this.pointY    = point.pageY;

		this._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault ) {	// increases performance on Android? TODO: check!
			e.preventDefault();
		}

		var point		= e.touches ? e.touches[0] : e,
			deltaX		= point.pageX - this.pointX,
			deltaY		= point.pageY - this.pointY,
			timestamp	= utils.getTime(),
			newX, newY,
			absDistX, absDistY;

		this.pointX		= point.pageX;
		this.pointY		= point.pageY;

		this.distX		+= deltaX;
		this.distY		+= deltaY;
		absDistX		= Math.abs(this.distX);
		absDistY		= Math.abs(this.distY);

		// We need to move at least 10 pixels for the scrolling to initiate
		if ( timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10) ) {
			return;
		}

		// If you are scrolling in one direction lock the other
		if ( !this.directionLocked && !this.options.freeScroll ) {
			if ( absDistX > absDistY + this.options.directionLockThreshold ) {
				this.directionLocked = 'h';		// lock horizontally
			} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {
				this.directionLocked = 'v';		// lock vertically
			} else {
				this.directionLocked = 'n';		// no lock
			}
		}

		if ( this.directionLocked == 'h' ) {
			if ( this.options.eventPassthrough == 'vertical' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'horizontal' ) {
				this.initiated = false;
				return;
			}

			deltaY = 0;
		} else if ( this.directionLocked == 'v' ) {
			if ( this.options.eventPassthrough == 'horizontal' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'vertical' ) {
				this.initiated = false;
				return;
			}

			deltaX = 0;
		}

		deltaX = this.hasHorizontalScroll ? deltaX : 0;
		deltaY = this.hasVerticalScroll ? deltaY : 0;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		// Slow down if outside of the boundaries
		if ( newX > 0 || newX < this.maxScrollX ) {
			newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
		}
		if ( newY > 0 || newY < this.maxScrollY ) {
			newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
		}

		this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if ( !this.moved ) {
			this._execEvent('scrollStart');
		}

		this.moved = true;

		this._translate(newX, newY);

/* REPLACE START: _move */

		if ( timestamp - this.startTime > 300 ) {
			this.startTime = timestamp;
			this.startX = this.x;
			this.startY = this.y;
		}

/* REPLACE END: _move */

	},

	_end: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.changedTouches ? e.changedTouches[0] : e,
			momentumX,
			momentumY,
			duration = utils.getTime() - this.startTime,
			newX = Math.round(this.x),
			newY = Math.round(this.y),
			distanceX = Math.abs(newX - this.startX),
			distanceY = Math.abs(newY - this.startY),
			time = 0,
			easing = '';

		this.isInTransition = 0;
		this.initiated = 0;
		this.endTime = utils.getTime();

		// reset if we are outside of the boundaries
		if ( this.resetPosition(this.options.bounceTime) ) {
			return;
		}

		this.scrollTo(newX, newY);	// ensures that the last position is rounded

		// we scrolled less than 10 pixels
		if ( !this.moved ) {
			if ( this.options.tap ) {
				utils.tap(e, this.options.tap);
			}

			if ( this.options.click ) {
				utils.click(e);
			}

			this._execEvent('scrollCancel');
			return;
		}

		if ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {
			this._execEvent('flick');
			return;
		}

		// start momentum animation if needed
		if ( this.options.momentum && duration < 300 ) {
			momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
			momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
			newX = momentumX.destination;
			newY = momentumY.destination;
			time = Math.max(momentumX.duration, momentumY.duration);
			this.isInTransition = 1;
		}


		if ( this.options.snap ) {
			var snap = this._nearestSnap(newX, newY);
			this.currentPage = snap;
			time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(newX - snap.x), 1000),
						Math.min(Math.abs(newY - snap.y), 1000)
					), 300);
			newX = snap.x;
			newY = snap.y;

			this.directionX = 0;
			this.directionY = 0;
			easing = this.options.bounceEasing;
		}

// INSERT POINT: _end

		if ( newX != this.x || newY != this.y ) {
			// change easing function when scroller goes out of the boundaries
			if ( newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY ) {
				easing = utils.ease.quadratic;
			}

			this.scrollTo(newX, newY, time, easing);
			return;
		}

		this._execEvent('scrollEnd');
	},

	_resize: function () {
		var that = this;

		clearTimeout(this.resizeTimeout);

		this.resizeTimeout = setTimeout(function () {
			that.refresh();
		}, this.options.resizePolling);
	},

	resetPosition: function (time) {
		var x = this.x,
			y = this.y;

		time = time || 0;

		if ( !this.hasHorizontalScroll || this.x > 0 ) {
			x = 0;
		} else if ( this.x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( !this.hasVerticalScroll || this.y > 0 ) {
			y = 0;
		} else if ( this.y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		if ( x == this.x && y == this.y ) {
			return false;
		}

		this.scrollTo(x, y, time, this.options.bounceEasing);

		return true;
	},

	disable: function () {
		this.enabled = false;
	},

	enable: function () {
		this.enabled = true;
	},

	refresh: function () {
		var rf = this.wrapper.offsetHeight;		// Force reflow

		this.wrapperWidth	= this.wrapper.clientWidth;
		this.wrapperHeight	= this.wrapper.clientHeight;

/* REPLACE START: refresh */

		this.scrollerWidth	= this.scroller.offsetWidth;
		this.scrollerHeight	= this.scroller.offsetHeight;

		this.maxScrollX		= this.wrapperWidth - this.scrollerWidth;
		this.maxScrollY		= this.wrapperHeight - this.scrollerHeight;

/* REPLACE END: refresh */

		this.hasHorizontalScroll	= this.options.scrollX && this.maxScrollX < 0;
		this.hasVerticalScroll		= this.options.scrollY && this.maxScrollY < 0;

		if ( !this.hasHorizontalScroll ) {
			this.maxScrollX = 0;
			this.scrollerWidth = this.wrapperWidth;
		}

		if ( !this.hasVerticalScroll ) {
			this.maxScrollY = 0;
			this.scrollerHeight = this.wrapperHeight;
		}

		this.endTime = 0;
		this.directionX = 0;
		this.directionY = 0;

		this.wrapperOffset = utils.offset(this.wrapper);

		this._execEvent('refresh');

		this.resetPosition();

// INSERT POINT: _refresh

	},

	on: function (type, fn) {
		if ( !this._events[type] ) {
			this._events[type] = [];
		}

		this._events[type].push(fn);
	},

	off: function (type, fn) {
		if ( !this._events[type] ) {
			return;
		}

		var index = this._events[type].indexOf(fn);

		if ( index > -1 ) {
			this._events[type].splice(index, 1);
		}
	},

	_execEvent: function (type) {
		if ( !this._events[type] ) {
			return;
		}

		var i = 0,
			l = this._events[type].length;

		if ( !l ) {
			return;
		}

		for ( ; i < l; i++ ) {
			this._events[type][i].apply(this, [].slice.call(arguments, 1));
		}
	},

	scrollBy: function (x, y, time, easing) {
		x = this.x + x;
		y = this.y + y;
		time = time || 0;

		this.scrollTo(x, y, time, easing);
	},

	scrollTo: function (x, y, time, easing) {
		easing = easing || utils.ease.circular;

		this.isInTransition = this.options.useTransition && time > 0;
		var transitionType = this.options.useTransition && easing.style;
		if ( !time || transitionType ) {
				if(transitionType) {
					this._transitionTimingFunction(easing.style);
					this._transitionTime(time);
				}
			this._translate(x, y);
		} else {
			this._animate(x, y, time, easing.fn);
		}
	},

	scrollToElement: function (el, time, offsetX, offsetY, easing) {
		el = el.nodeType ? el : this.scroller.querySelector(el);

		if ( !el ) {
			return;
		}

		var pos = utils.offset(el);

		pos.left -= this.wrapperOffset.left;
		pos.top  -= this.wrapperOffset.top;

		// if offsetX/Y are true we center the element to the screen
		if ( offsetX === true ) {
			offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
		}
		if ( offsetY === true ) {
			offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
		}

		pos.left -= offsetX || 0;
		pos.top  -= offsetY || 0;

		pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
		pos.top  = pos.top  > 0 ? 0 : pos.top  < this.maxScrollY ? this.maxScrollY : pos.top;

		time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x-pos.left), Math.abs(this.y-pos.top)) : time;

		this.scrollTo(pos.left, pos.top, time, easing);
	},

	_transitionTime: function (time) {
		time = time || 0;

		var durationProp = utils.style.transitionDuration;
		this.scrollerStyle[durationProp] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.scrollerStyle[durationProp] = '0.0001ms';
			// remove 0.0001ms
			var self = this;
			rAF(function() {
				if(self.scrollerStyle[durationProp] === '0.0001ms') {
					self.scrollerStyle[durationProp] = '0s';
				}
			});
		}


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTime(time);
			}
		}


// INSERT POINT: _transitionTime

	},

	_transitionTimingFunction: function (easing) {
		this.scrollerStyle[utils.style.transitionTimingFunction] = easing;


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTimingFunction(easing);
			}
		}


// INSERT POINT: _transitionTimingFunction

	},

	_translate: function (x, y) {
		if ( this.options.useTransform ) {

/* REPLACE START: _translate */

			this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

/* REPLACE END: _translate */

		} else {
			x = Math.round(x);
			y = Math.round(y);
			this.scrollerStyle.left = x + 'px';
			this.scrollerStyle.top = y + 'px';
		}

		this.x = x;
		this.y = y;


	if ( this.indicators ) {
		for ( var i = this.indicators.length; i--; ) {
			this.indicators[i].updatePosition();
		}
	}


// INSERT POINT: _translate

	},

	_initEvents: function (remove) {
		var eventType = remove ? utils.removeEvent : utils.addEvent,
			target = this.options.bindToWrapper ? this.wrapper : window;

		eventType(window, 'orientationchange', this);
		eventType(window, 'resize', this);

		if ( this.options.click ) {
			eventType(this.wrapper, 'click', this, true);
		}

		if ( !this.options.disableMouse ) {
			eventType(this.wrapper, 'mousedown', this);
			eventType(target, 'mousemove', this);
			eventType(target, 'mousecancel', this);
			eventType(target, 'mouseup', this);
		}

		if ( utils.hasPointer && !this.options.disablePointer ) {
			eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
			eventType(target, utils.prefixPointerEvent('pointermove'), this);
			eventType(target, utils.prefixPointerEvent('pointercancel'), this);
			eventType(target, utils.prefixPointerEvent('pointerup'), this);
		}

		if ( utils.hasTouch && !this.options.disableTouch ) {
			eventType(this.wrapper, 'touchstart', this);
			eventType(target, 'touchmove', this);
			eventType(target, 'touchcancel', this);
			eventType(target, 'touchend', this);
		}

		eventType(this.scroller, 'transitionend', this);
		eventType(this.scroller, 'webkitTransitionEnd', this);
		eventType(this.scroller, 'oTransitionEnd', this);
		eventType(this.scroller, 'MSTransitionEnd', this);
	},

	getComputedPosition: function () {
		var matrix = window.getComputedStyle(this.scroller, null),
			x, y;

		if ( this.options.useTransform ) {
			matrix = matrix[utils.style.transform].split(')')[0].split(', ');
			x = +(matrix[12] || matrix[4]);
			y = +(matrix[13] || matrix[5]);
		} else {
			x = +matrix.left.replace(/[^-\d.]/g, '');
			y = +matrix.top.replace(/[^-\d.]/g, '');
		}

		return { x: x, y: y };
	},
	_initIndicators: function () {
		var interactive = this.options.interactiveScrollbars,
			customStyle = typeof this.options.scrollbars != 'string',
			indicators = [],
			indicator;

		var that = this;

		this.indicators = [];

		if ( this.options.scrollbars ) {
			// Vertical scrollbar
			if ( this.options.scrollY ) {
				indicator = {
					el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenX: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}

			// Horizontal scrollbar
			if ( this.options.scrollX ) {
				indicator = {
					el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenY: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}
		}

		if ( this.options.indicators ) {
			// TODO: check concat compatibility
			indicators = indicators.concat(this.options.indicators);
		}

		for ( var i = indicators.length; i--; ) {
			this.indicators.push( new Indicator(this, indicators[i]) );
		}

		// TODO: check if we can use array.map (wide compatibility and performance issues)
		function _indicatorsMap (fn) {
			if (that.indicators) {
				for ( var i = that.indicators.length; i--; ) {
					fn.call(that.indicators[i]);
				}
			}
		}

		if ( this.options.fadeScrollbars ) {
			this.on('scrollEnd', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollCancel', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1);
				});
			});

			this.on('beforeScrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1, true);
				});
			});
		}


		this.on('refresh', function () {
			_indicatorsMap(function () {
				this.refresh();
			});
		});

		this.on('destroy', function () {
			_indicatorsMap(function () {
				this.destroy();
			});

			delete this.indicators;
		});
	},

	_initWheel: function () {
		utils.addEvent(this.wrapper, 'wheel', this);
		utils.addEvent(this.wrapper, 'mousewheel', this);
		utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

		this.on('destroy', function () {
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = null;
			utils.removeEvent(this.wrapper, 'wheel', this);
			utils.removeEvent(this.wrapper, 'mousewheel', this);
			utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
		});
	},

	_wheel: function (e) {
		if ( !this.enabled ) {
			return;
		}

		e.preventDefault();

		var wheelDeltaX, wheelDeltaY,
			newX, newY,
			that = this;

		if ( this.wheelTimeout === undefined ) {
			that._execEvent('scrollStart');
		}

		// Execute the scrollEnd event after 400ms the wheel stopped scrolling
		clearTimeout(this.wheelTimeout);
		this.wheelTimeout = setTimeout(function () {
			if(!that.options.snap) {
				that._execEvent('scrollEnd');
			}
			that.wheelTimeout = undefined;
		}, 400);

		if ( 'deltaX' in e ) {
			if (e.deltaMode === 1) {
				wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
				wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
			} else {
				wheelDeltaX = -e.deltaX;
				wheelDeltaY = -e.deltaY;
			}
		} else if ( 'wheelDeltaX' in e ) {
			wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
			wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
		} else if ( 'wheelDelta' in e ) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
		} else if ( 'detail' in e ) {
			wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
		} else {
			return;
		}

		wheelDeltaX *= this.options.invertWheelDirection;
		wheelDeltaY *= this.options.invertWheelDirection;

		if ( !this.hasVerticalScroll ) {
			wheelDeltaX = wheelDeltaY;
			wheelDeltaY = 0;
		}

		if ( this.options.snap ) {
			newX = this.currentPage.pageX;
			newY = this.currentPage.pageY;

			if ( wheelDeltaX > 0 ) {
				newX--;
			} else if ( wheelDeltaX < 0 ) {
				newX++;
			}

			if ( wheelDeltaY > 0 ) {
				newY--;
			} else if ( wheelDeltaY < 0 ) {
				newY++;
			}

			this.goToPage(newX, newY);

			return;
		}

		newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
		newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

		this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
		this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;

		if ( newX > 0 ) {
			newX = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
		}

		if ( newY > 0 ) {
			newY = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
		}

		this.scrollTo(newX, newY, 0);

// INSERT POINT: _wheel
	},

	_initSnap: function () {
		this.currentPage = {};

		if ( typeof this.options.snap == 'string' ) {
			this.options.snap = this.scroller.querySelectorAll(this.options.snap);
		}

		this.on('refresh', function () {
			var i = 0, l,
				m = 0, n,
				cx, cy,
				x = 0, y,
				stepX = this.options.snapStepX || this.wrapperWidth,
				stepY = this.options.snapStepY || this.wrapperHeight,
				el;

			this.pages = [];

			if ( !this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight ) {
				return;
			}

			if ( this.options.snap === true ) {
				cx = Math.round( stepX / 2 );
				cy = Math.round( stepY / 2 );

				while ( x > -this.scrollerWidth ) {
					this.pages[i] = [];
					l = 0;
					y = 0;

					while ( y > -this.scrollerHeight ) {
						this.pages[i][l] = {
							x: Math.max(x, this.maxScrollX),
							y: Math.max(y, this.maxScrollY),
							width: stepX,
							height: stepY,
							cx: x - cx,
							cy: y - cy
						};

						y -= stepY;
						l++;
					}

					x -= stepX;
					i++;
				}
			} else {
				el = this.options.snap;
				l = el.length;
				n = -1;

				for ( ; i < l; i++ ) {
					if ( i === 0 || el[i].offsetLeft <= el[i-1].offsetLeft ) {
						m = 0;
						n++;
					}

					if ( !this.pages[m] ) {
						this.pages[m] = [];
					}

					x = Math.max(-el[i].offsetLeft, this.maxScrollX);
					y = Math.max(-el[i].offsetTop, this.maxScrollY);
					cx = x - Math.round(el[i].offsetWidth / 2);
					cy = y - Math.round(el[i].offsetHeight / 2);

					this.pages[m][n] = {
						x: x,
						y: y,
						width: el[i].offsetWidth,
						height: el[i].offsetHeight,
						cx: cx,
						cy: cy
					};

					if ( x > this.maxScrollX ) {
						m++;
					}
				}
			}

			this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

			// Update snap threshold if needed
			if ( this.options.snapThreshold % 1 === 0 ) {
				this.snapThresholdX = this.options.snapThreshold;
				this.snapThresholdY = this.options.snapThreshold;
			} else {
				this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
				this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
			}
		});

		this.on('flick', function () {
			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.x - this.startX), 1000),
						Math.min(Math.abs(this.y - this.startY), 1000)
					), 300);

			this.goToPage(
				this.currentPage.pageX + this.directionX,
				this.currentPage.pageY + this.directionY,
				time
			);
		});
	},

	_nearestSnap: function (x, y) {
		if ( !this.pages.length ) {
			return { x: 0, y: 0, pageX: 0, pageY: 0 };
		}

		var i = 0,
			l = this.pages.length,
			m = 0;

		// Check if we exceeded the snap threshold
		if ( Math.abs(x - this.absStartX) < this.snapThresholdX &&
			Math.abs(y - this.absStartY) < this.snapThresholdY ) {
			return this.currentPage;
		}

		if ( x > 0 ) {
			x = 0;
		} else if ( x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( y > 0 ) {
			y = 0;
		} else if ( y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		for ( ; i < l; i++ ) {
			if ( x >= this.pages[i][0].cx ) {
				x = this.pages[i][0].x;
				break;
			}
		}

		l = this.pages[i].length;

		for ( ; m < l; m++ ) {
			if ( y >= this.pages[0][m].cy ) {
				y = this.pages[0][m].y;
				break;
			}
		}

		if ( i == this.currentPage.pageX ) {
			i += this.directionX;

			if ( i < 0 ) {
				i = 0;
			} else if ( i >= this.pages.length ) {
				i = this.pages.length - 1;
			}

			x = this.pages[i][0].x;
		}

		if ( m == this.currentPage.pageY ) {
			m += this.directionY;

			if ( m < 0 ) {
				m = 0;
			} else if ( m >= this.pages[0].length ) {
				m = this.pages[0].length - 1;
			}

			y = this.pages[0][m].y;
		}

		return {
			x: x,
			y: y,
			pageX: i,
			pageY: m
		};
	},

	goToPage: function (x, y, time, easing) {
		easing = easing || this.options.bounceEasing;

		if ( x >= this.pages.length ) {
			x = this.pages.length - 1;
		} else if ( x < 0 ) {
			x = 0;
		}

		if ( y >= this.pages[x].length ) {
			y = this.pages[x].length - 1;
		} else if ( y < 0 ) {
			y = 0;
		}

		var posX = this.pages[x][y].x,
			posY = this.pages[x][y].y;

		time = time === undefined ? this.options.snapSpeed || Math.max(
			Math.max(
				Math.min(Math.abs(posX - this.x), 1000),
				Math.min(Math.abs(posY - this.y), 1000)
			), 300) : time;

		this.currentPage = {
			x: posX,
			y: posY,
			pageX: x,
			pageY: y
		};

		this.scrollTo(posX, posY, time, easing);
	},

	next: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x++;

		if ( x >= this.pages.length && this.hasVerticalScroll ) {
			x = 0;
			y++;
		}

		this.goToPage(x, y, time, easing);
	},

	prev: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x--;

		if ( x < 0 && this.hasVerticalScroll ) {
			x = 0;
			y--;
		}

		this.goToPage(x, y, time, easing);
	},

	_initKeys: function (e) {
		// default key bindings
		var keys = {
			pageUp: 33,
			pageDown: 34,
			end: 35,
			home: 36,
			left: 37,
			up: 38,
			right: 39,
			down: 40
		};
		var i;

		// if you give me characters I give you keycode
		if ( typeof this.options.keyBindings == 'object' ) {
			for ( i in this.options.keyBindings ) {
				if ( typeof this.options.keyBindings[i] == 'string' ) {
					this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
				}
			}
		} else {
			this.options.keyBindings = {};
		}

		for ( i in keys ) {
			this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
		}

		utils.addEvent(window, 'keydown', this);

		this.on('destroy', function () {
			utils.removeEvent(window, 'keydown', this);
		});
	},

	_key: function (e) {
		if ( !this.enabled ) {
			return;
		}

		var snap = this.options.snap,	// we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			newY = snap ? this.currentPage.pageY : this.y,
			now = utils.getTime(),
			prevTime = this.keyTime || 0,
			acceleration = 0.250,
			pos;

		if ( this.options.useTransition && this.isInTransition ) {
			pos = this.getComputedPosition();

			this._translate(Math.round(pos.x), Math.round(pos.y));
			this.isInTransition = false;
		}

		this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

		switch ( e.keyCode ) {
			case this.options.keyBindings.pageUp:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX += snap ? 1 : this.wrapperWidth;
				} else {
					newY += snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.pageDown:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX -= snap ? 1 : this.wrapperWidth;
				} else {
					newY -= snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.end:
				newX = snap ? this.pages.length-1 : this.maxScrollX;
				newY = snap ? this.pages[0].length-1 : this.maxScrollY;
				break;
			case this.options.keyBindings.home:
				newX = 0;
				newY = 0;
				break;
			case this.options.keyBindings.left:
				newX += snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.up:
				newY += snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.right:
				newX -= snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.down:
				newY -= snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			default:
				return;
		}

		if ( snap ) {
			this.goToPage(newX, newY);
			return;
		}

		if ( newX > 0 ) {
			newX = 0;
			this.keyAcceleration = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
			this.keyAcceleration = 0;
		}

		if ( newY > 0 ) {
			newY = 0;
			this.keyAcceleration = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
			this.keyAcceleration = 0;
		}

		this.scrollTo(newX, newY, 0);

		this.keyTime = now;
	},

	_animate: function (destX, destY, duration, easingFn) {
		var that = this,
			startX = this.x,
			startY = this.y,
			startTime = utils.getTime(),
			destTime = startTime + duration;

		function step () {
			var now = utils.getTime(),
				newX, newY,
				easing;

			if ( now >= destTime ) {
				that.isAnimating = false;
				that._translate(destX, destY);

				if ( !that.resetPosition(that.options.bounceTime) ) {
					that._execEvent('scrollEnd');
				}

				return;
			}

			now = ( now - startTime ) / duration;
			easing = easingFn(now);
			newX = ( destX - startX ) * easing + startX;
			newY = ( destY - startY ) * easing + startY;
			that._translate(newX, newY);

			if ( that.isAnimating ) {
				rAF(step);
			}
		}

		this.isAnimating = true;
		step();
	},
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
			case 'orientationchange':
			case 'resize':
				this._resize();
				break;
			case 'transitionend':
			case 'webkitTransitionEnd':
			case 'oTransitionEnd':
			case 'MSTransitionEnd':
				this._transitionEnd(e);
				break;
			case 'wheel':
			case 'DOMMouseScroll':
			case 'mousewheel':
				this._wheel(e);
				break;
			case 'keydown':
				this._key(e);
				break;
			case 'click':
				if ( this.enabled && !e._constructed ) {
					e.preventDefault();
					e.stopPropagation();
				}
				break;
		}
	}
};
function createDefaultScrollbar (direction, interactive, type) {
	var scrollbar = document.createElement('div'),
		indicator = document.createElement('div');

	if ( type === true ) {
		scrollbar.style.cssText = 'position:absolute;z-index:9999';
		indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
	}

	indicator.className = 'iScrollIndicator';

	if ( direction == 'h' ) {
		if ( type === true ) {
			scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
			indicator.style.height = '100%';
		}
		scrollbar.className = 'iScrollHorizontalScrollbar';
	} else {
		if ( type === true ) {
			scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
			indicator.style.width = '100%';
		}
		scrollbar.className = 'iScrollVerticalScrollbar';
	}

	scrollbar.style.cssText += ';overflow:hidden';

	if ( !interactive ) {
		scrollbar.style.pointerEvents = 'none';
	}

	scrollbar.appendChild(indicator);

	return scrollbar;
}

function Indicator (scroller, options) {
	this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
	this.wrapperStyle = this.wrapper.style;
	this.indicator = this.wrapper.children[0];
	this.indicatorStyle = this.indicator.style;
	this.scroller = scroller;

	this.options = {
		listenX: true,
		listenY: true,
		interactive: false,
		resize: true,
		defaultScrollbars: false,
		shrink: false,
		fade: false,
		speedRatioX: 0,
		speedRatioY: 0
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	this.sizeRatioX = 1;
	this.sizeRatioY = 1;
	this.maxPosX = 0;
	this.maxPosY = 0;

	if ( this.options.interactive ) {
		if ( !this.options.disableTouch ) {
			utils.addEvent(this.indicator, 'touchstart', this);
			utils.addEvent(window, 'touchend', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
			utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(this.indicator, 'mousedown', this);
			utils.addEvent(window, 'mouseup', this);
		}
	}

	if ( this.options.fade ) {
		this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
		var durationProp = utils.style.transitionDuration;
		this.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms';
		// remove 0.0001ms
		var self = this;
		if(utils.isBadAndroid) {
			rAF(function() {
				if(self.wrapperStyle[durationProp] === '0.0001ms') {
					self.wrapperStyle[durationProp] = '0s';
				}
			});
		}
		this.wrapperStyle.opacity = '0';
	}
}

Indicator.prototype = {
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
		}
	},

	destroy: function () {
		if ( this.options.fadeScrollbars ) {
			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;
		}
		if ( this.options.interactive ) {
			utils.removeEvent(this.indicator, 'touchstart', this);
			utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
			utils.removeEvent(this.indicator, 'mousedown', this);

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			utils.removeEvent(window, 'touchend', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
			utils.removeEvent(window, 'mouseup', this);
		}

		if ( this.options.defaultScrollbars ) {
			this.wrapper.parentNode.removeChild(this.wrapper);
		}
	},

	_start: function (e) {
		var point = e.touches ? e.touches[0] : e;

		e.preventDefault();
		e.stopPropagation();

		this.transitionTime();

		this.initiated = true;
		this.moved = false;
		this.lastPointX	= point.pageX;
		this.lastPointY	= point.pageY;

		this.startTime	= utils.getTime();

		if ( !this.options.disableTouch ) {
			utils.addEvent(window, 'touchmove', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(window, 'mousemove', this);
		}

		this.scroller._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		var point = e.touches ? e.touches[0] : e,
			deltaX, deltaY,
			newX, newY,
			timestamp = utils.getTime();

		if ( !this.moved ) {
			this.scroller._execEvent('scrollStart');
		}

		this.moved = true;

		deltaX = point.pageX - this.lastPointX;
		this.lastPointX = point.pageX;

		deltaY = point.pageY - this.lastPointY;
		this.lastPointY = point.pageY;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		this._pos(newX, newY);

// INSERT POINT: indicator._move

		e.preventDefault();
		e.stopPropagation();
	},

	_end: function (e) {
		if ( !this.initiated ) {
			return;
		}

		this.initiated = false;

		e.preventDefault();
		e.stopPropagation();

		utils.removeEvent(window, 'touchmove', this);
		utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
		utils.removeEvent(window, 'mousemove', this);

		if ( this.scroller.options.snap ) {
			var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.scroller.x - snap.x), 1000),
						Math.min(Math.abs(this.scroller.y - snap.y), 1000)
					), 300);

			if ( this.scroller.x != snap.x || this.scroller.y != snap.y ) {
				this.scroller.directionX = 0;
				this.scroller.directionY = 0;
				this.scroller.currentPage = snap;
				this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
			}
		}

		if ( this.moved ) {
			this.scroller._execEvent('scrollEnd');
		}
	},

	transitionTime: function (time) {
		time = time || 0;
		var durationProp = utils.style.transitionDuration;
		this.indicatorStyle[durationProp] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.indicatorStyle[durationProp] = '0.0001ms';
			// remove 0.0001ms
			var self = this;
			rAF(function() {
				if(self.indicatorStyle[durationProp] === '0.0001ms') {
					self.indicatorStyle[durationProp] = '0s';
				}
			});
		}
	},

	transitionTimingFunction: function (easing) {
		this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
	},

	refresh: function () {
		this.transitionTime();

		if ( this.options.listenX && !this.options.listenY ) {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
		} else if ( this.options.listenY && !this.options.listenX ) {
			this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
		} else {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
		}

		if ( this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ) {
			utils.addClass(this.wrapper, 'iScrollBothScrollbars');
			utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '8px';
				} else {
					this.wrapper.style.bottom = '8px';
				}
			}
		} else {
			utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
			utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '2px';
				} else {
					this.wrapper.style.bottom = '2px';
				}
			}
		}

		var r = this.wrapper.offsetHeight;	// force refresh

		if ( this.options.listenX ) {
			this.wrapperWidth = this.wrapper.clientWidth;
			if ( this.options.resize ) {
				this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
				this.indicatorStyle.width = this.indicatorWidth + 'px';
			} else {
				this.indicatorWidth = this.indicator.clientWidth;
			}

			this.maxPosX = this.wrapperWidth - this.indicatorWidth;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryX = -this.indicatorWidth + 8;
				this.maxBoundaryX = this.wrapperWidth - 8;
			} else {
				this.minBoundaryX = 0;
				this.maxBoundaryX = this.maxPosX;
			}

			this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));
		}

		if ( this.options.listenY ) {
			this.wrapperHeight = this.wrapper.clientHeight;
			if ( this.options.resize ) {
				this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
				this.indicatorStyle.height = this.indicatorHeight + 'px';
			} else {
				this.indicatorHeight = this.indicator.clientHeight;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryY = -this.indicatorHeight + 8;
				this.maxBoundaryY = this.wrapperHeight - 8;
			} else {
				this.minBoundaryY = 0;
				this.maxBoundaryY = this.maxPosY;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;
			this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
		}

		this.updatePosition();
	},

	updatePosition: function () {
		var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

		if ( !this.options.ignoreBoundaries ) {
			if ( x < this.minBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth + x, 8);
					this.indicatorStyle.width = this.width + 'px';
				}
				x = this.minBoundaryX;
			} else if ( x > this.maxBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
					this.indicatorStyle.width = this.width + 'px';
					x = this.maxPosX + this.indicatorWidth - this.width;
				} else {
					x = this.maxBoundaryX;
				}
			} else if ( this.options.shrink == 'scale' && this.width != this.indicatorWidth ) {
				this.width = this.indicatorWidth;
				this.indicatorStyle.width = this.width + 'px';
			}

			if ( y < this.minBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight + y * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
				}
				y = this.minBoundaryY;
			} else if ( y > this.maxBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
					y = this.maxPosY + this.indicatorHeight - this.height;
				} else {
					y = this.maxBoundaryY;
				}
			} else if ( this.options.shrink == 'scale' && this.height != this.indicatorHeight ) {
				this.height = this.indicatorHeight;
				this.indicatorStyle.height = this.height + 'px';
			}
		}

		this.x = x;
		this.y = y;

		if ( this.scroller.options.useTransform ) {
			this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
		} else {
			this.indicatorStyle.left = x + 'px';
			this.indicatorStyle.top = y + 'px';
		}
	},

	_pos: function (x, y) {
		if ( x < 0 ) {
			x = 0;
		} else if ( x > this.maxPosX ) {
			x = this.maxPosX;
		}

		if ( y < 0 ) {
			y = 0;
		} else if ( y > this.maxPosY ) {
			y = this.maxPosY;
		}

		x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
		y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

		this.scroller.scrollTo(x, y);
	},

	fade: function (val, hold) {
		if ( hold && !this.visible ) {
			return;
		}

		clearTimeout(this.fadeTimeout);
		this.fadeTimeout = null;

		var time = val ? 250 : 500,
			delay = val ? 0 : 300;

		val = val ? '1' : '0';

		this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

		this.fadeTimeout = setTimeout((function (val) {
			this.wrapperStyle.opacity = val;
			this.visible = +val;
		}).bind(this, val), delay);
	}
};

IScroll.utils = utils;

if ( typeof module != 'undefined' && module.exports ) {
	module.exports = IScroll;
} else if ( typeof define == 'function' && define.amd ) {
        define( function () { return IScroll; } );
} else {
	window.IScroll = IScroll;
}

})(window, document, Math);

},{}],8:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":78,"./_root":118}],9:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":85,"./_hashDelete":86,"./_hashGet":87,"./_hashHas":88,"./_hashSet":89}],10:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":98,"./_listCacheDelete":99,"./_listCacheGet":100,"./_listCacheHas":101,"./_listCacheSet":102}],11:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":78,"./_root":118}],12:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":103,"./_mapCacheDelete":104,"./_mapCacheGet":105,"./_mapCacheHas":106,"./_mapCacheSet":107}],13:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":78,"./_root":118}],14:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":78,"./_root":118}],15:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":12,"./_setCacheAdd":120,"./_setCacheHas":121}],16:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":10,"./_stackClear":125,"./_stackDelete":126,"./_stackGet":127,"./_stackHas":128,"./_stackSet":129}],17:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":118}],18:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":118}],19:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":78,"./_root":118}],20:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],21:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],22:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":55,"./_isIndex":91,"./isArguments":140,"./isArray":141,"./isBuffer":144,"./isTypedArray":151}],23:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],24:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],25:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],26:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":29,"./eq":135}],27:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":29,"./eq":135}],28:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":135}],29:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":70}],30:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":147}],31:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":68}],32:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":31,"./keys":152}],33:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":60,"./_toKey":131}],34:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":24,"./isArray":141}],35:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":17,"./_getRawTag":80,"./_objectToString":115}],36:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],37:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":35,"./isObjectLike":148}],38:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":39,"./isObjectLike":148}],39:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":16,"./_equalArrays":71,"./_equalByTag":72,"./_equalObjects":73,"./_getTag":82,"./isArray":141,"./isBuffer":144,"./isTypedArray":151}],40:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":16,"./_baseIsEqual":38}],41:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":95,"./_toSource":132,"./isFunction":145,"./isObject":147}],42:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":35,"./isLength":146,"./isObjectLike":148}],43:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":46,"./_baseMatchesProperty":47,"./identity":139,"./isArray":141,"./property":158}],44:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":96,"./_nativeKeys":112}],45:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":96,"./_nativeKeysIn":113,"./isObject":147}],46:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":40,"./_getMatchData":77,"./_matchesStrictComparable":109}],47:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":38,"./_isKey":93,"./_isStrictComparable":97,"./_matchesStrictComparable":109,"./_toKey":131,"./get":137,"./hasIn":138}],48:[function(require,module,exports){
var Stack = require('./_Stack'),
    assignMergeValue = require('./_assignMergeValue'),
    baseFor = require('./_baseFor'),
    baseMergeDeep = require('./_baseMergeDeep'),
    isObject = require('./isObject'),
    keysIn = require('./keysIn'),
    safeGet = require('./_safeGet');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":16,"./_assignMergeValue":26,"./_baseFor":31,"./_baseMergeDeep":49,"./_safeGet":119,"./isObject":147,"./keysIn":153}],49:[function(require,module,exports){
var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    safeGet = require('./_safeGet'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":26,"./_cloneBuffer":62,"./_cloneTypedArray":63,"./_copyArray":64,"./_initCloneObject":90,"./_safeGet":119,"./isArguments":140,"./isArray":141,"./isArrayLikeObject":143,"./isBuffer":144,"./isFunction":145,"./isObject":147,"./isPlainObject":149,"./isTypedArray":151,"./toPlainObject":165}],50:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],51:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":33}],52:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;

},{}],53:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":117,"./_setToString":123,"./identity":139}],54:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":70,"./constant":133,"./identity":139}],55:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],56:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":17,"./_arrayMap":23,"./isArray":141,"./isSymbol":150}],57:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],58:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],59:[function(require,module,exports){
var identity = require('./identity');

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

},{"./identity":139}],60:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":93,"./_stringToPath":130,"./isArray":141,"./toString":166}],61:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":18}],62:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":118}],63:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":61}],64:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],65:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":27,"./_baseAssignValue":29}],66:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":118}],67:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":53,"./_isIterateeCall":92}],68:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],69:[function(require,module,exports){
var baseRange = require('./_baseRange'),
    isIterateeCall = require('./_isIterateeCall'),
    toFinite = require('./toFinite');

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;

},{"./_baseRange":52,"./_isIterateeCall":92,"./toFinite":163}],70:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":78}],71:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":15,"./_arraySome":25,"./_cacheHas":58}],72:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":17,"./_Uint8Array":18,"./_equalArrays":71,"./_mapToArray":108,"./_setToArray":122,"./eq":135}],73:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":75}],74:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],75:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":34,"./_getSymbols":81,"./keys":152}],76:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":94}],77:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":97,"./keys":152}],78:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":41,"./_getValue":83}],79:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":116}],80:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":17}],81:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":21,"./stubArray":160}],82:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":8,"./_Map":11,"./_Promise":13,"./_Set":14,"./_WeakMap":19,"./_baseGetTag":35,"./_toSource":132}],83:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],84:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":60,"./_isIndex":91,"./_toKey":131,"./isArguments":140,"./isArray":141,"./isLength":146}],85:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":111}],86:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],87:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":111}],88:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":111}],89:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":111}],90:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":30,"./_getPrototype":79,"./_isPrototype":96}],91:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],92:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":91,"./eq":135,"./isArrayLike":142,"./isObject":147}],93:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":141,"./isSymbol":150}],94:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],95:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":66}],96:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],97:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":147}],98:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],99:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":28}],100:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":28}],101:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":28}],102:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":28}],103:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":9,"./_ListCache":10,"./_Map":11}],104:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":76}],105:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":76}],106:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":76}],107:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":76}],108:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],109:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],110:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":155}],111:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":78}],112:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":116}],113:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],114:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":74}],115:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],116:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],117:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":20}],118:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":74}],119:[function(require,module,exports){
/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

},{}],120:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],121:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],122:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],123:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":54,"./_shortOut":124}],124:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],125:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":10}],126:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],127:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],128:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],129:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":10,"./_Map":11,"./_MapCache":12}],130:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":110}],131:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":150}],132:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],133:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],134:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":147,"./now":157,"./toNumber":164}],135:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],136:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    castFunction = require('./_castFunction'),
    keysIn = require('./keysIn');

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, castFunction(iteratee), keysIn);
}

module.exports = forIn;

},{"./_baseFor":31,"./_castFunction":59,"./keysIn":153}],137:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":33}],138:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":36,"./_hasPath":84}],139:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],140:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":37,"./isObjectLike":148}],141:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],142:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":145,"./isLength":146}],143:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":142,"./isObjectLike":148}],144:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":118,"./stubFalse":161}],145:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":35,"./isObject":147}],146:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],147:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],148:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],149:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":35,"./_getPrototype":79,"./isObjectLike":148}],150:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":35,"./isObjectLike":148}],151:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":42,"./_baseUnary":57,"./_nodeUtil":114}],152:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":22,"./_baseKeys":44,"./isArrayLike":142}],153:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":22,"./_baseKeysIn":45,"./isArrayLike":142}],154:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    baseForOwn = require('./_baseForOwn'),
    baseIteratee = require('./_baseIteratee');

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;

},{"./_baseAssignValue":29,"./_baseForOwn":32,"./_baseIteratee":43}],155:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":12}],156:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":48,"./_createAssigner":67}],157:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":118}],158:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":50,"./_basePropertyDeep":51,"./_isKey":93,"./_toKey":131}],159:[function(require,module,exports){
var createRange = require('./_createRange');

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;

},{"./_createRange":69}],160:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],161:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],162:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":134,"./isObject":147}],163:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":164}],164:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":147,"./isSymbol":150}],165:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":65,"./keysIn":153}],166:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":56}],167:[function(require,module,exports){
"use strict"

var hyperscript = require("./render/hyperscript")

hyperscript.trust = require("./render/trust")
hyperscript.fragment = require("./render/fragment")

module.exports = hyperscript

},{"./render/fragment":170,"./render/hyperscript":171,"./render/trust":173}],168:[function(require,module,exports){
(function (global,setImmediate){
;(function() {
"use strict"
function Vnode(tag, key, attrs0, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
}
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i])
	}
	return children
}
var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty
function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}
function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}
function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text
	var className = attrs.className || attrs.class
	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}
		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key]
			}
		}
		attrs = newAttrs
	}
	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key]
		}
	}
	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined
			attrs.className = className
		}
		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className
		}
	}
	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true
			break
		}
	}
	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children
	} else {
		childList = children
	}
	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}
function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}
	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector)
	}
	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = 1
	}
	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}
	var normalized = Vnode.normalizeChildren(children)
	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}
hyperscript.trust = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}
hyperscript.fragment = function(attrs1, children) {
	return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)
}
var m = hyperscript
/** @constructor */
var PromisePolyfill = function(executor) {
	if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")
	if (typeof executor !== "function") throw new TypeError("executor must be a function")
	var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)
	var instance = self._instance = {resolvers: resolvers, rejectors: rejectors}
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
	function handler(list, shouldAbsorb) {
		return function execute(value) {
			var then
			try {
				if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
					if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
					executeOnce(then.bind(value))
				}
				else {
					callAsync(function() {
						if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)
						for (var i = 0; i < list.length; i++) list[i](value)
						resolvers.length = 0, rejectors.length = 0
						instance.state = shouldAbsorb
						instance.retry = function() {execute(value)}
					})
				}
			}
			catch (e) {
				rejectCurrent(e)
			}
		}
	}
	function executeOnce(then) {
		var runs = 0
		function run(fn) {
			return function(value) {
				if (runs++ > 0) return
				fn(value)
			}
		}
		var onerror = run(rejectCurrent)
		try {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}
	}
	executeOnce(executor)
}
PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
	var self = this, instance = self._instance
	function handle(callback, list, next, state) {
		list.push(function(value) {
			if (typeof callback !== "function") next(value)
			else try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}
		})
		if (typeof instance.retry === "function" && state === instance.state) instance.retry()
	}
	var resolveNext, rejectNext
	var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})
	handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)
	return promise
}
PromisePolyfill.prototype.catch = function(onRejection) {
	return this.then(null, onRejection)
}
PromisePolyfill.resolve = function(value) {
	if (value instanceof PromisePolyfill) return value
	return new PromisePolyfill(function(resolve) {resolve(value)})
}
PromisePolyfill.reject = function(value) {
	return new PromisePolyfill(function(resolve, reject) {reject(value)})
}
PromisePolyfill.all = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		var total = list.length, count = 0, values = []
		if (list.length === 0) resolve([])
		else for (var i = 0; i < list.length; i++) {
			(function(i) {
				function consume(value) {
					count++
					values[i] = value
					if (count === total) resolve(values)
				}
				if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
					list[i].then(consume, reject)
				}
				else consume(list[i])
			})(i)
		}
	})
}
PromisePolyfill.race = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		for (var i = 0; i < list.length; i++) {
			list[i].then(resolve, reject)
		}
	})
}
if (typeof window !== "undefined") {
	if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill
	var PromisePolyfill = window.Promise
} else if (typeof global !== "undefined") {
	if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill
	var PromisePolyfill = global.Promise
} else {
}
var buildQueryString = function(object) {
	if (Object.prototype.toString.call(object) !== "[object Object]") return ""
	var args = []
	for (var key0 in object) {
		destructure(key0, object[key0])
	}
	return args.join("&")
	function destructure(key0, value) {
		if (Array.isArray(value)) {
			for (var i = 0; i < value.length; i++) {
				destructure(key0 + "[" + i + "]", value[i])
			}
		}
		else if (Object.prototype.toString.call(value) === "[object Object]") {
			for (var i in value) {
				destructure(key0 + "[" + i + "]", value[i])
			}
		}
		else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))
	}
}
var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")
var _8 = function($window, Promise) {
	var callbackCount = 0
	var oncompletion
	function setCompletionCallback(callback) {oncompletion = callback}
	function finalizer() {
		var count = 0
		function complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}
		return function finalize(promise0) {
			var then0 = promise0.then
			promise0.then = function() {
				count++
				var next = then0.apply(promise0, arguments)
				next.then(complete, function(e) {
					complete()
					if (count === 0) throw e
				})
				return finalize(next)
			}
			return promise0
		}
	}
	function normalize(args, extra) {
		if (typeof args === "string") {
			var url = args
			args = extra || {}
			if (args.url == null) args.url = url
		}
		return args
	}
	function request(args, extra) {
		var finalize = finalizer()
		args = normalize(args, extra)
		var promise0 = new Promise(function(resolve, reject) {
			if (args.method == null) args.method = "GET"
			args.method = args.method.toUpperCase()
			var useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)
			if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify
			if (typeof args.deserialize !== "function") args.deserialize = deserialize
			if (typeof args.extract !== "function") args.extract = extract
			args.url = interpolate(args.url, args.data)
			if (useBody) args.data = args.serialize(args.data)
			else args.url = assemble(args.url, args.data)
			var xhr = new $window.XMLHttpRequest(),
				aborted = false,
				_abort = xhr.abort
			xhr.abort = function abort() {
				aborted = true
				_abort.call(xhr)
			}
			xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)
			if (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty("Content-Type"))) {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
			}
			if (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty("Accept"))) {
				xhr.setRequestHeader("Accept", "application/json, text/*")
			}
			if (args.withCredentials) xhr.withCredentials = args.withCredentials
			for (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {
				xhr.setRequestHeader(key, args.headers[key])
			}
			if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr
			xhr.onreadystatechange = function() {
				// Don't throw errors on xhr.abort().
				if(aborted) return
				if (xhr.readyState === 4) {
					try {
						var response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))
						if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
							resolve(cast(args.type, response))
						}
						else {
							var error = new Error(xhr.responseText)
							for (var key in response) error[key] = response[key]
							reject(error)
						}
					}
					catch (e) {
						reject(e)
					}
				}
			}
			if (useBody && (args.data != null)) xhr.send(args.data)
			else xhr.send()
		})
		return args.background === true ? promise0 : finalize(promise0)
	}
	function jsonp(args, extra) {
		var finalize = finalizer()
		args = normalize(args, extra)
		var promise0 = new Promise(function(resolve, reject) {
			var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++
			var script = $window.document.createElement("script")
			$window[callbackName] = function(data) {
				script.parentNode.removeChild(script)
				resolve(cast(args.type, data))
				delete $window[callbackName]
			}
			script.onerror = function() {
				script.parentNode.removeChild(script)
				reject(new Error("JSONP request failed"))
				delete $window[callbackName]
			}
			if (args.data == null) args.data = {}
			args.url = interpolate(args.url, args.data)
			args.data[args.callbackKey || "callback"] = callbackName
			script.src = assemble(args.url, args.data)
			$window.document.documentElement.appendChild(script)
		})
		return args.background === true? promise0 : finalize(promise0)
	}
	function interpolate(url, data) {
		if (data == null) return url
		var tokens = url.match(/:[^\/]+/gi) || []
		for (var i = 0; i < tokens.length; i++) {
			var key = tokens[i].slice(1)
			if (data[key] != null) {
				url = url.replace(tokens[i], data[key])
			}
		}
		return url
	}
	function assemble(url, data) {
		var querystring = buildQueryString(data)
		if (querystring !== "") {
			var prefix = url.indexOf("?") < 0 ? "?" : "&"
			url += prefix + querystring
		}
		return url
	}
	function deserialize(data) {
		try {return data !== "" ? JSON.parse(data) : null}
		catch (e) {throw new Error(data)}
	}
	function extract(xhr) {return xhr.responseText}
	function cast(type0, data) {
		if (typeof type0 === "function") {
			if (Array.isArray(data)) {
				for (var i = 0; i < data.length; i++) {
					data[i] = new type0(data[i])
				}
			}
			else return new type0(data)
		}
		return data
	}
	return {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}
}
var requestService = _8(window, PromisePolyfill)
var coreRenderer = function($window) {
	var $doc = $window.document
	var $emptyFragment = $doc.createDocumentFragment()
	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}
	var onevent
	function setEventCallback(callback) {return onevent = callback}
	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}
	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match1 = vnode.children.match(/^\s*?<(\w+)/im) || []
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"
		var temp = $doc.createElement(parent1)
		temp.innerHTML = vnode.children
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodes(fragment, children, 0, children.length, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs2 = vnode.attrs
		var is = attrs2 && attrs2.is
		ns = getNameSpace(vnode) || ns
		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element
		if (attrs2 != null) {
			setAttrs(vnode, attrs2, ns)
		}
		insertNode(parent, element, nextSibling)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(element, children, 0, children.length, hooks, null, ns)
				setLateAttrs(vnode)
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		vnode._state = vnode.state
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		initLifecycle(vnode._state, vnode, hooks)
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
			insertNode(parent, element, nextSibling)
			return element
		}
		else {
			vnode.domSize = 0
			return $emptyFragment
		}
	}
	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes)
			if (recycling) {
				var pool = old.pool
				old = old.concat(old.pool)
			}
			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start]
				if (o === v && !recycling) oldStart++, start++
				else if (o == null) oldStart++
				else if (v == null) start++
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
					oldStart++, start++
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
				}
				else {
					var o = old[oldEnd]
					if (o === v && !recycling) oldEnd--, start++
					else if (o == null) oldEnd--
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
						oldEnd--, start++
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end]
				if (o === v && !recycling) oldEnd--, end--
				else if (o == null) oldEnd--
				else if (v == null) end--
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					if (o.dom != null) nextSibling = o.dom
					oldEnd--, end--
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd)
					if (v != null) {
						var oldIndex = map[v.key]
						if (oldIndex != null) {
							var movable = old[oldIndex]
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
							insertNode(parent, toFragment(movable), nextSibling)
							old[oldIndex].skip = true
							if (movable.dom != null) nextSibling = movable.dom
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling)
							nextSibling = dom
						}
					}
					end--
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
			removeNodes(old, oldStart, oldEnd + 1, vnodes)
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode._state = old._state
			vnode.events = old.events
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {}
						initLifecycle(vnode.attrs, vnode, hooks)
					}
					else updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
		}
		else {
			removeNode(old, null)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns
		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle0 multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks)
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
			updateLifecycle(vnode._state, vnode, hooks)
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance, null)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				var key2 = vnode.key
				if (key2 != null) map[key2] = i
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count0 = vnode.domSize
		if (count0 != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count0 > 0) {
				var dom = vnode.dom
				while (--count0) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}
	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}
	function setContentEditable(vnode) {
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}
	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false
				else removeNode(vnode, context)
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				onremove(vnode)
				if (vnode.dom) {
					var count0 = vnode.domSize || 1
					if (count0 > 1) {
						var dom = vnode.dom
						while (--count0) {
							removeNodeFromDOM(dom.nextSibling)
						}
					}
					removeNodeFromDOM(vnode.dom)
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode]
						else context.pool.push(vnode)
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode
		if (parent != null) parent.removeChild(node)
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}
	//attrs2
	function setAttrs(vnode, attrs2, ns) {
		for (var key2 in attrs2) {
			setAttr(vnode, key2, null, attrs2[key2], ns)
		}
	}
	function setAttr(vnode, key2, old, value, ns) {
		var element = vnode.dom
		if (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return
		var nsLastIndex = key2.indexOf(":")
		if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)
		}
		else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)
		else if (key2 === "style") updateStyle(element, old, value)
		else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
			if (key2 === "value") {
				var normalized0 = "" + value // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return
			}
			// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
			if (vnode.tag === "input" && key2 === "type") {
				element.setAttribute(key2, value)
				return
			}
			element[key2] = value
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key2, "")
				else element.removeAttribute(key2)
			}
			else element.setAttribute(key2 === "className" ? "class" : key2, value)
		}
	}
	function setLateAttrs(vnode) {
		var attrs2 = vnode.attrs
		if (vnode.tag === "select" && attrs2 != null) {
			if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)
			if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)
		}
	}
	function updateAttrs(vnode, old, attrs2, ns) {
		if (attrs2 != null) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, old && old[key2], attrs2[key2], ns)
			}
		}
		if (old != null) {
			for (var key2 in old) {
				if (attrs2 == null || !(key2 in attrs2)) {
					if (key2 === "className") key2 = "class"
					if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)
					else if (key2 !== "key") vnode.dom.removeAttribute(key2)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}
	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null
		if (style == null) element.style.cssText = ""
		else if (typeof style === "string") element.style.cssText = style
		else {
			if (typeof old === "string") element.style.cssText = ""
			for (var key2 in style) {
				element.style[key2] = style[key2]
			}
			if (old != null && typeof old !== "string") {
				for (var key2 in old) {
					if (!(key2 in style)) element.style[key2] = ""
				}
			}
		}
	}
	//event
	function updateEvent(vnode, key2, value) {
		var element = vnode.dom
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e)
			onevent.call(element, e)
			return result
		}
		if (key2 in element) element[key2] = typeof value === "function" ? callback : null
		else {
			var eventName = key2.slice(2)
			if (vnode.events === undefined) vnode.events = {}
			if (vnode.events[key2] === callback) return
			if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)
			if (typeof value === "function") {
				vnode.events[key2] = callback
				element.addEventListener(eventName, vnode.events[key2], false)
			}
		}
	}
	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
			vnode.instance = old.instance
			return true
		}
		return false
	}
	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = $doc.activeElement
		var namespace = dom.namespaceURI
		// First time0 rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""
		if (!Array.isArray(vnodes)) vnodes = [vnodes]
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}
	return {render: render, setEventCallback: setEventCallback}
}
function throttle(callback) {
	//60fps translates to 16.6ms, round it down since setTimeout requires int
	var time = 16
	var last = 0, pending = null
	var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout
	return function() {
		var now = Date.now()
		if (last === 0 || now - last >= time) {
			last = now
			callback()
		}
		else if (pending === null) {
			pending = timeout(function() {
				pending = null
				callback()
				last = Date.now()
			}, time - (now - last))
		}
	}
}
var _11 = function($window) {
	var renderService = coreRenderer($window)
	renderService.setEventCallback(function(e) {
		if (e.redraw === false) e.redraw = undefined
		else redraw()
	})
	var callbacks = []
	function subscribe(key1, callback) {
		unsubscribe(key1)
		callbacks.push(key1, throttle(callback))
	}
	function unsubscribe(key1) {
		var index = callbacks.indexOf(key1)
		if (index > -1) callbacks.splice(index, 2)
	}
	function redraw() {
		for (var i = 1; i < callbacks.length; i += 2) {
			callbacks[i]()
		}
	}
	return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
}
var redrawService = _11(window)
requestService.setCompletionCallback(redrawService.redraw)
var _16 = function(redrawService0) {
	return function(root, component) {
		if (component === null) {
			redrawService0.render(root, [])
			redrawService0.unsubscribe(root)
			return
		}
		
		if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")
		
		var run0 = function() {
			redrawService0.render(root, Vnode(component))
		}
		redrawService0.subscribe(root, run0)
		redrawService0.redraw()
	}
}
m.mount = _16(redrawService)
var Promise = PromisePolyfill
var parseQueryString = function(string) {
	if (string === "" || string == null) return {}
	if (string.charAt(0) === "?") string = string.slice(1)
	var entries = string.split("&"), data0 = {}, counters = {}
	for (var i = 0; i < entries.length; i++) {
		var entry = entries[i].split("=")
		var key5 = decodeURIComponent(entry[0])
		var value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""
		if (value === "true") value = true
		else if (value === "false") value = false
		var levels = key5.split(/\]\[?|\[/)
		var cursor = data0
		if (key5.indexOf("[") > -1) levels.pop()
		for (var j = 0; j < levels.length; j++) {
			var level = levels[j], nextLevel = levels[j + 1]
			var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))
			var isValue = j === levels.length - 1
			if (level === "") {
				var key5 = levels.slice(0, j).join()
				if (counters[key5] == null) counters[key5] = 0
				level = counters[key5]++
			}
			if (cursor[level] == null) {
				cursor[level] = isValue ? value : isNumber ? [] : {}
			}
			cursor = cursor[level]
		}
	}
	return data0
}
var coreRouter = function($window) {
	var supportsPushState = typeof $window.history.pushState === "function"
	var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout
	function normalize1(fragment0) {
		var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)
		if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data
		return data
	}
	var asyncId
	function debounceAsync(callback0) {
		return function() {
			if (asyncId != null) return
			asyncId = callAsync0(function() {
				asyncId = null
				callback0()
			})
		}
	}
	function parsePath(path, queryData, hashData) {
		var queryIndex = path.indexOf("?")
		var hashIndex = path.indexOf("#")
		var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length
		if (queryIndex > -1) {
			var queryEnd = hashIndex > -1 ? hashIndex : path.length
			var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))
			for (var key4 in queryParams) queryData[key4] = queryParams[key4]
		}
		if (hashIndex > -1) {
			var hashParams = parseQueryString(path.slice(hashIndex + 1))
			for (var key4 in hashParams) hashData[key4] = hashParams[key4]
		}
		return path.slice(0, pathEnd)
	}
	var router = {prefix: "#!"}
	router.getPath = function() {
		var type2 = router.prefix.charAt(0)
		switch (type2) {
			case "#": return normalize1("hash").slice(router.prefix.length)
			case "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")
			default: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")
		}
	}
	router.setPath = function(path, data, options) {
		var queryData = {}, hashData = {}
		path = parsePath(path, queryData, hashData)
		if (data != null) {
			for (var key4 in data) queryData[key4] = data[key4]
			path = path.replace(/:([^\/]+)/g, function(match2, token) {
				delete queryData[token]
				return data[token]
			})
		}
		var query = buildQueryString(queryData)
		if (query) path += "?" + query
		var hash = buildQueryString(hashData)
		if (hash) path += "#" + hash
		if (supportsPushState) {
			var state = options ? options.state : null
			var title = options ? options.title : null
			$window.onpopstate()
			if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)
			else $window.history.pushState(state, title, router.prefix + path)
		}
		else $window.location.href = router.prefix + path
	}
	router.defineRoutes = function(routes, resolve, reject) {
		function resolveRoute() {
			var path = router.getPath()
			var params = {}
			var pathname = parsePath(path, params, params)
			var state = $window.history.state
			if (state != null) {
				for (var k in state) params[k] = state[k]
			}
			for (var route0 in routes) {
				var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$")
				if (matcher.test(pathname)) {
					pathname.replace(matcher, function() {
						var keys = route0.match(/:[^\/]+/g) || []
						var values = [].slice.call(arguments, 1, -2)
						for (var i = 0; i < keys.length; i++) {
							params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i])
						}
						resolve(routes[route0], params, path, route0)
					})
					return
				}
			}
			reject(path, params)
		}
		if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)
		else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute
		resolveRoute()
	}
	return router
}
var _20 = function($window, redrawService0) {
	var routeService = coreRouter($window)
	var identity = function(v) {return v}
	var render1, component, attrs3, currentPath, lastUpdate
	var route = function(root, defaultRoute, routes) {
		if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
		var run1 = function() {
			if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))
		}
		var bail = function(path) {
			if (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})
			else throw new Error("Could not resolve default route " + defaultRoute)
		}
		routeService.defineRoutes(routes, function(payload, params, path) {
			var update = lastUpdate = function(routeResolver, comp) {
				if (update !== lastUpdate) return
				component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"
				attrs3 = params, currentPath = path, lastUpdate = null
				render1 = (routeResolver.render || identity).bind(routeResolver)
				run1()
			}
			if (payload.view || typeof payload === "function") update({}, payload)
			else {
				if (payload.onmatch) {
					Promise.resolve(payload.onmatch(params, path)).then(function(resolved) {
						update(payload, resolved)
					}, bail)
				}
				else update(payload, "div")
			}
		}, bail)
		redrawService0.subscribe(root, run1)
	}
	route.set = function(path, data, options) {
		if (lastUpdate != null) {
			options = options || {}
			options.replace = true
		}
		lastUpdate = null
		routeService.setPath(path, data, options)
	}
	route.get = function() {return currentPath}
	route.prefix = function(prefix0) {routeService.prefix = prefix0}
	route.link = function(vnode1) {
		vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)
		vnode1.dom.onclick = function(e) {
			if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return
			e.preventDefault()
			e.redraw = false
			var href = this.getAttribute("href")
			if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)
			route.set(href, undefined, undefined)
		}
	}
	route.param = function(key3) {
		if(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]
		return attrs3
	}
	return route
}
m.route = _20(window, redrawService)
m.withAttr = function(attrName, callback1, context) {
	return function(e) {
		callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))
	}
}
var _28 = coreRenderer(window)
m.render = _28.render
m.redraw = redrawService.redraw
m.request = requestService.request
m.jsonp = requestService.jsonp
m.parseQueryString = parseQueryString
m.buildQueryString = buildQueryString
m.version = "1.1.6"
m.vnode = Vnode
if (typeof module !== "undefined") module["exports"] = m
else window.m = m
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":183}],169:[function(require,module,exports){
"use strict"

module.exports = require("./render/render")(window)

},{"./render/render":172}],170:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function(attrs, children) {
	return Vnode("[", attrs.key, attrs, Vnode.normalizeChildren(children), undefined, undefined)
}

},{"../render/vnode":174}],171:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty

function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}

function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}

function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text
	var className = attrs.className || attrs.class

	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}

		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key]
			}
		}

		attrs = newAttrs
	}

	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key]
		}
	}

	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined
			attrs.className = className
		}

		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className
		}
	}

	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true
			break
		}
	}

	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children
	} else {
		childList = children
	}

	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}

function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children

	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}

	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector)
	}

	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = 1
	}

	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}

	var normalized = Vnode.normalizeChildren(children)

	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}

module.exports = hyperscript

},{"../render/vnode":174}],172:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function($window) {
	var $doc = $window.document
	var $emptyFragment = $doc.createDocumentFragment()

	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}

	var onevent
	function setEventCallback(callback) {return onevent = callback}

	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}

	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match = vnode.children.match(/^\s*?<(\w+)/im) || []
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match[1]] || "div"
		var temp = $doc.createElement(parent1)

		temp.innerHTML = vnode.children
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodes(fragment, children, 0, children.length, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs = vnode.attrs
		var is = attrs && attrs.is

		ns = getNameSpace(vnode) || ns

		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element

		if (attrs != null) {
			setAttrs(vnode, attrs, ns)
		}

		insertNode(parent, element, nextSibling)

		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(element, children, 0, children.length, hooks, null, ns)
				setLateAttrs(vnode)
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		vnode._state = vnode.state
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		initLifecycle(vnode._state, vnode, hooks)
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
			insertNode(parent, element, nextSibling)
			return element
		}
		else {
			vnode.domSize = 0
			return $emptyFragment
		}
	}

	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes)
			if (recycling) {
				var pool = old.pool
				old = old.concat(old.pool)
			}

			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start]
				if (o === v && !recycling) oldStart++, start++
				else if (o == null) oldStart++
				else if (v == null) start++
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
					oldStart++, start++
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
				}
				else {
					var o = old[oldEnd]
					if (o === v && !recycling) oldEnd--, start++
					else if (o == null) oldEnd--
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
						oldEnd--, start++
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end]
				if (o === v && !recycling) oldEnd--, end--
				else if (o == null) oldEnd--
				else if (v == null) end--
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					if (o.dom != null) nextSibling = o.dom
					oldEnd--, end--
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd)
					if (v != null) {
						var oldIndex = map[v.key]
						if (oldIndex != null) {
							var movable = old[oldIndex]
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
							insertNode(parent, toFragment(movable), nextSibling)
							old[oldIndex].skip = true
							if (movable.dom != null) nextSibling = movable.dom
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling)
							nextSibling = dom
						}
					}
					end--
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
			removeNodes(old, oldStart, oldEnd + 1, vnodes)
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode._state = old._state
			vnode.events = old.events
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {}
						initLifecycle(vnode.attrs, vnode, hooks)
					}
					else updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
		}
		else {
			removeNode(old, null)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns

		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks)
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
			updateLifecycle(vnode._state, vnode, hooks)
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance, null)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				var key = vnode.key
				if (key != null) map[key] = i
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count = vnode.domSize
		if (count != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count > 0) {
				var dom = vnode.dom
				while (--count) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}

	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}

	function setContentEditable(vnode) {
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}

	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false
				else removeNode(vnode, context)
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				onremove(vnode)
				if (vnode.dom) {
					var count = vnode.domSize || 1
					if (count > 1) {
						var dom = vnode.dom
						while (--count) {
							removeNodeFromDOM(dom.nextSibling)
						}
					}
					removeNodeFromDOM(vnode.dom)
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode]
						else context.pool.push(vnode)
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode
		if (parent != null) parent.removeChild(node)
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}

	//attrs
	function setAttrs(vnode, attrs, ns) {
		for (var key in attrs) {
			setAttr(vnode, key, null, attrs[key], ns)
		}
	}
	function setAttr(vnode, key, old, value, ns) {
		var element = vnode.dom
		if (key === "key" || key === "is" || (old === value && !isFormAttribute(vnode, key)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key)) return
		var nsLastIndex = key.indexOf(":")
		if (nsLastIndex > -1 && key.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(nsLastIndex + 1), value)
		}
		else if (key[0] === "o" && key[1] === "n" && typeof value === "function") updateEvent(vnode, key, value)
		else if (key === "style") updateStyle(element, old, value)
		else if (key in element && !isAttribute(key) && ns === undefined && !isCustomElement(vnode)) {
			if (key === "value") {
				var normalized = "" + value // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized) return
			}
			// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
			if (vnode.tag === "input" && key === "type") {
				element.setAttribute(key, value)
				return
			}
			element[key] = value
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key, "")
				else element.removeAttribute(key)
			}
			else element.setAttribute(key === "className" ? "class" : key, value)
		}
	}
	function setLateAttrs(vnode) {
		var attrs = vnode.attrs
		if (vnode.tag === "select" && attrs != null) {
			if ("value" in attrs) setAttr(vnode, "value", null, attrs.value, undefined)
			if ("selectedIndex" in attrs) setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, undefined)
		}
	}
	function updateAttrs(vnode, old, attrs, ns) {
		if (attrs != null) {
			for (var key in attrs) {
				setAttr(vnode, key, old && old[key], attrs[key], ns)
			}
		}
		if (old != null) {
			for (var key in old) {
				if (attrs == null || !(key in attrs)) {
					if (key === "className") key = "class"
					if (key[0] === "o" && key[1] === "n" && !isLifecycleMethod(key)) updateEvent(vnode, key, undefined)
					else if (key !== "key") vnode.dom.removeAttribute(key)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}

	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null
		if (style == null) element.style.cssText = ""
		else if (typeof style === "string") element.style.cssText = style
		else {
			if (typeof old === "string") element.style.cssText = ""
			for (var key in style) {
				element.style[key] = style[key]
			}
			if (old != null && typeof old !== "string") {
				for (var key in old) {
					if (!(key in style)) element.style[key] = ""
				}
			}
		}
	}

	//event
	function updateEvent(vnode, key, value) {
		var element = vnode.dom
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e)
			onevent.call(element, e)
			return result
		}
		if (key in element) element[key] = typeof value === "function" ? callback : null
		else {
			var eventName = key.slice(2)
			if (vnode.events === undefined) vnode.events = {}
			if (vnode.events[key] === callback) return
			if (vnode.events[key] != null) element.removeEventListener(eventName, vnode.events[key], false)
			if (typeof value === "function") {
				vnode.events[key] = callback
				element.addEventListener(eventName, vnode.events[key], false)
			}
		}
	}

	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
			vnode.instance = old.instance
			return true
		}
		return false
	}

	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = $doc.activeElement
		var namespace = dom.namespaceURI

		// First time rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""

		if (!Array.isArray(vnodes)) vnodes = [vnodes]
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}

	return {render: render, setEventCallback: setEventCallback}
}

},{"../render/vnode":174}],173:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}

},{"../render/vnode":174}],174:[function(require,module,exports){
"use strict"

function Vnode(tag, key, attrs, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
}
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i])
	}
	return children
}

module.exports = Vnode

},{}],175:[function(require,module,exports){
"use strict"

module.exports = require("./stream/stream")

},{"./stream/stream":176}],176:[function(require,module,exports){
/* eslint-disable */
;(function() {
"use strict"
/* eslint-enable */

var guid = 0, HALT = {}
function createStream() {
	function stream() {
		if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])
		return stream._state.value
	}
	initStream(stream)

	if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])

	return stream
}
function initStream(stream) {
	stream.constructor = createStream
	stream._state = {id: guid++, value: undefined, state: 0, derive: undefined, recover: undefined, deps: {}, parents: [], endStream: undefined, unregister: undefined}
	stream.map = stream["fantasy-land/map"] = map, stream["fantasy-land/ap"] = ap, stream["fantasy-land/of"] = createStream
	stream.valueOf = valueOf, stream.toJSON = toJSON, stream.toString = valueOf

	Object.defineProperties(stream, {
		end: {get: function() {
			if (!stream._state.endStream) {
				var endStream = createStream()
				endStream.map(function(value) {
					if (value === true) {
						unregisterStream(stream)
						endStream._state.unregister = function(){unregisterStream(endStream)}
					}
					return value
				})
				stream._state.endStream = endStream
			}
			return stream._state.endStream
		}}
	})
}
function updateStream(stream, value) {
	updateState(stream, value)
	for (var id in stream._state.deps) updateDependency(stream._state.deps[id], false)
	if (stream._state.unregister != null) stream._state.unregister()
	finalize(stream)
}
function updateState(stream, value) {
	stream._state.value = value
	stream._state.changed = true
	if (stream._state.state !== 2) stream._state.state = 1
}
function updateDependency(stream, mustSync) {
	var state = stream._state, parents = state.parents
	if (parents.length > 0 && parents.every(active) && (mustSync || parents.some(changed))) {
		var value = stream._state.derive()
		if (value === HALT) return false
		updateState(stream, value)
	}
}
function finalize(stream) {
	stream._state.changed = false
	for (var id in stream._state.deps) stream._state.deps[id]._state.changed = false
}

function combine(fn, streams) {
	if (!streams.every(valid)) throw new Error("Ensure that each item passed to stream.combine/stream.merge is a stream")
	return initDependency(createStream(), streams, function() {
		return fn.apply(this, streams.concat([streams.filter(changed)]))
	})
}

function initDependency(dep, streams, derive) {
	var state = dep._state
	state.derive = derive
	state.parents = streams.filter(notEnded)

	registerDependency(dep, state.parents)
	updateDependency(dep, true)

	return dep
}
function registerDependency(stream, parents) {
	for (var i = 0; i < parents.length; i++) {
		parents[i]._state.deps[stream._state.id] = stream
		registerDependency(stream, parents[i]._state.parents)
	}
}
function unregisterStream(stream) {
	for (var i = 0; i < stream._state.parents.length; i++) {
		var parent = stream._state.parents[i]
		delete parent._state.deps[stream._state.id]
	}
	for (var id in stream._state.deps) {
		var dependent = stream._state.deps[id]
		var index = dependent._state.parents.indexOf(stream)
		if (index > -1) dependent._state.parents.splice(index, 1)
	}
	stream._state.state = 2 //ended
	stream._state.deps = {}
}

function map(fn) {return combine(function(stream) {return fn(stream())}, [this])}
function ap(stream) {return combine(function(s1, s2) {return s1()(s2())}, [stream, this])}
function valueOf() {return this._state.value}
function toJSON() {return this._state.value != null && typeof this._state.value.toJSON === "function" ? this._state.value.toJSON() : this._state.value}

function valid(stream) {return stream._state }
function active(stream) {return stream._state.state === 1}
function changed(stream) {return stream._state.changed}
function notEnded(stream) {return stream._state.state !== 2}

function merge(streams) {
	return combine(function() {
		return streams.map(function(s) {return s()})
	}, streams)
}

function scan(reducer, seed, stream) {
	var newStream = combine(function (s) {
		return seed = reducer(seed, s._state.value)
	}, [stream])

	if (newStream._state.state === 0) newStream(seed)

	return newStream
}

function scanMerge(tuples, seed) {
	var streams = tuples.map(function(tuple) {
		var stream = tuple[0]
		if (stream._state.state === 0) stream(undefined)
		return stream
	})

	var newStream = combine(function() {
		var changed = arguments[arguments.length - 1]

		streams.forEach(function(stream, idx) {
			if (changed.indexOf(stream) > -1) {
				seed = tuples[idx][1](seed, stream._state.value)
			}
		})

		return seed
	}, streams)

	return newStream
}

createStream["fantasy-land/of"] = createStream
createStream.merge = merge
createStream.combine = combine
createStream.scan = scan
createStream.scanMerge = scanMerge
createStream.HALT = HALT

if (typeof module !== "undefined") module["exports"] = createStream
else if (typeof window.m === "function" && !("stream" in window.m)) window.m.stream = createStream
else window.m = {stream : createStream}

}());

},{}],177:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],178:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],179:[function(require,module,exports){
(function (process,setImmediate){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof self !== "undefined") {
        self.Q = definition();

    } else {
        throw new Error("This environment was not anticiapted by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":178,"timers":183}],180:[function(require,module,exports){
/*
 * Qanimationframe.js - Promisified requestAnimationFrame with Q
 */
/*jslint newcap: true */
(function (definition) {
    if (typeof exports === "object") {
        module.exports = definition();
    } else {
        window.QanimationFrame = definition();
    }
})(function () {
  "use strict";

  // Import Q
  var Q = window.Q || require("q");

  // requestAnimationFrame polyfill
  var requestAnimationFrame = (function(){
    return window.requestAnimationFrame       ||
           window.oRequestAnimationFrame      ||
           window.msRequestAnimationFrame     ||
           window.mozRequestAnimationFrame    ||
           window.webkitRequestAnimationFrame ||
           function (callback) {
             window.setTimeout(callback, 1000 / 60);
           };
  })();

  // QanimationFrame(f: function) => promise containing the return value of f
  // ---
  //
  var QanimationFrame = function (f) {
    var d = Q.defer();
    requestAnimationFrame(function () {
      try {
        d.resolve(f());
      } catch (e) {
        d.reject(e);
      }
    });
    return d.promise;
  };

  return QanimationFrame;
});

},{"q":179}],181:[function(require,module,exports){
// This library started as an experiment to see how small I could make
// a functional router. It has since been optimized (and thus grown).
// The redundancy and inelegance here is for the sake of either size
// or speed.
(function (root, factory) {
  var define = root.define;

  if (define && define.amd) {
    define('rlite', [], factory);
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = factory();
  } else {
    root.Rlite = factory();
  }
}(this, function () { return function() {
    var routes = {},
        decode = decodeURIComponent;

    function noop(s) { return s; }

    function sanitize(url) {
      ~url.indexOf('/?') && (url = url.replace('/?', '?'));
      url[0] == '/' && (url = url.slice(1));
      url[url.length - 1] == '/' && (url = url.slice(0, -1));

      return url;
    }

    function processUrl(url, esc) {
      var pieces = url.split('/'),
          rules = routes,
          params = {};

      for (var i = 0; i < pieces.length && rules; ++i) {
        var piece = esc(pieces[i]);
        rules = rules[piece.toLowerCase()] || rules[':'];
        rules && rules['~'] && (params[rules['~']] = piece);
      }

      return rules && {
        cb: rules['@'],
        params: params
      };
    }

    function processQuery(url, ctx, esc) {
      if (url && ctx.cb) {
        var hash = url.indexOf('#'),
            query = (hash < 0 ? url : url.slice(0, hash)).split('&');

        for (var i = 0; i < query.length; ++i) {
          var nameValue = query[i].split('=');

          ctx.params[nameValue[0]] = esc(nameValue[1]);
        }
      }

      return ctx;
    }

    function lookup(url) {
      var querySplit = sanitize(url).split('?'),
          esc = ~url.indexOf('%') ? decode : noop;

      return processQuery(querySplit[1], processUrl(querySplit[0], esc) || {}, esc);
    }

    return {
      add: function(route, handler) {

        var pieces = route.split('/'),
            rules = routes;

        for (var i = 0; i < pieces.length; ++i) {
          var piece = pieces[i],
              name = piece[0] == ':' ? ':' : piece.toLowerCase();

          rules = rules[name] || (rules[name] = {});

          name == ':' && (rules['~'] = piece.slice(1));
        }

        rules['@'] = handler;
      },

      exists: function (url) {
        return !!lookup(url).cb;
      },

      lookup: lookup,

      run: function(url) {
        var result = lookup(url);

        result.cb && result.cb({
          url: url,
          params: result.params
        });

        return !!result.cb;
      }
    };
  };
}));

},{}],182:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],183:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":178,"timers":183}],184:[function(require,module,exports){
'use strict';

var style = document.createElement('p').style,
    prefixes = 'O ms Moz webkit'.split(' '),
    hasPrefix = /^(o|ms|moz|webkit)/,
    upper = /([A-Z])/g,
    memo = {};

function get(key){
    return (key in memo) ? memo[key] : memo[key] = prefix(key);
}

function prefix(key){
    var capitalizedKey = key.replace(/-([a-z])/g, function(s, match){
            return match.toUpperCase();
        }),
        i = prefixes.length,
        name;

    if (style[capitalizedKey] !== undefined) return capitalizedKey;

    capitalizedKey = capitalize(key);

    while (i--) {
        name = prefixes[i] + capitalizedKey;
        if (style[name] !== undefined) return name;
    }

    throw new Error('unable to prefix ' + key);
}

function capitalize(str){
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function dashedPrefix(key){
    var prefixedKey = get(key),
        upper = /([A-Z])/g;

    if (upper.test(prefixedKey)) {
        prefixedKey = (hasPrefix.test(prefixedKey) ? '-' : '') + prefixedKey.replace(upper, '-$1');
    }

    return prefixedKey.toLowerCase();
}

module.exports = get;
module.exports.dash = dashedPrefix;

},{}],185:[function(require,module,exports){
// Zanimo.js - Promise based CSS3 transitions
// (c) 2011-2014 Paul Panserrieu

'use strict';

var Q = require('q'),
    QanimationFrame = require('qanimationframe'),
    prefix = require('vendor-prefix'),
    normalizeTransformValue = require('../src/normalize-transform-value'),
    shorthand = require('../src/transition-shorthand-property'),
    transition = prefix('transition'),
    transitionend = 'WebkitTransition' in document.body.style ? 'webkitTransitionEnd' : 'transitionend',

    isDOM = function (el) {
        try {
            return el && el.nodeType;
        } catch(err) {
            return false;
        };
    },

    addTransition = function (elt, attr, value, duration, easing) {
        var currentValue = elt.style[transition];
        attr = prefix.dash(attr);
        if (currentValue) {
            elt.style[transition] = currentValue + ", " + shorthand(attr, duration, easing);
        }
        else {
            elt.style[transition] = shorthand(attr, duration, easing);
        }
        elt.style[prefix(attr)] = value;
    },

    removeTransition = function (el, attr) {
        el.style[transition] = el.style[transition]
            .split(',').filter(function(t) {
                return !t.match(attr);
            }).join(',');
    },

    applycss = function (el, attr, value) {
        return QanimationFrame(function(){
            el.style[prefix.dash(attr)] = value;
            return el;
        });
    },

    css = function (el, attr, value) {
        if(el._zanimo && el._zanimo.hasOwnProperty(attr)) {
            el._zanimo[attr].defer.reject(new Error(
                "Zanimo transition with transform=" +
                el._zanimo[attr].value +
                " stopped by transform=" + value
            ));
            el._zanimo[attr].cb();
        }
        return applycss(el, attr, value);
    },

    animate = function (el, attr, value, duration, easing) {
        var prefixed = prefix.dash(attr),
            d = Q.defer(),
            timeout,
            cb = function (clear) {
                if (timeout) { clearTimeout(timeout); timeout = null; }
                removeTransition(el, attr);
                el.removeEventListener(transitionend, cbTransitionend);
                if (clear) { delete el._zanimo[attr]; }
            },
            cbTransitionend = function (evt) {
                if(prefix(evt.propertyName) === prefix(prefixed)) {
                    cb(true);
                    d.resolve(el);
                }
            };

        el.addEventListener(transitionend, cbTransitionend);

        QanimationFrame(function () {
            addTransition(el, attr, normalizeTransformValue(value), duration, easing);
            timeout = setTimeout(function () {
                var rawVal = el.style.getPropertyValue(prefixed),
                    domVal = normalizeTransformValue(rawVal),
                    givenVal = normalizeTransformValue(value);

                cb(true);
                if (domVal === givenVal) { d.resolve(el); }
                else {
                    d.reject( new Error("Zanimo transition: with "
                        + attr + " = " + givenVal + ", DOM value=" + domVal
                    ));
                }
            }, duration + 20 );

            el._zanimo = el._zanimo || { };
            if(el._zanimo[attr]) {
                el._zanimo[attr].defer.reject(new Error(
                    "Zanimo transition with " +
                    attr + "=" + el._zanimo[attr].value +
                    " stopped by transition with " + attr + "=" + value
                ));
                el._zanimo[attr].cb();
            }
            el._zanimo[attr] = {cb: cb, value: value, defer: d};
        });

        return d.promise;
    };

/**
 * Zanimo(el | promise[el])
 * > Returns a Promise of el.
 *
 * Zanimo(el | promise[el], attr, value)
 * > Sets el.style[attr]=value and returns the promise of el.
 *
 * Zanimo(el | promise[el], attr, value, duration, [easing])
 * > Performs a transition.
 */
var Zanimo = function (el, attr, value, duration, easing) {
    var args = arguments,
        arity = arguments.length;
    if (arity === 0 || arity === 2 || arity > 5) {
        return Q.reject(new Error("Zanimo invalid arguments"));
    }
    if (Q.isPromise(el)) {
        return el.then(function (val) {
            return Zanimo.apply(this, [val].concat(Array.prototype.slice.call(args, 1)));
        });
    }
    if (!isDOM(el)) {
        return Q.reject(new Error("Zanimo require an HTMLElement, or a promise of an HTMLElement"));
    }
    if (arity === 1) {
        return Q(el);
    }
    try {
        prefix.dash(attr);
    } catch(err) {
        return Q.reject(new Error("Zanimo transition: " + attr + ' is not supported!'));
    };
    if (arity === 3) {
        return css(el, attr, value);
    }
    if(window.isNaN(parseInt(duration, 10))) {
        return Q.reject(new Error("Zanimo transition: duration must be an integer!"));
    }
    return animate(el, attr, value, duration, easing);
};

/**
 * A function wrapping `Zanimo(el, ...)` as a `f(...)(el)` for easy chaining purpose.
 */
Zanimo.f = function (attr, value, duration, easing) {
    var args = Array.prototype.slice.call(arguments);
    return function (el) {
        return Zanimo.apply(this, [el].concat(args));
    };
};

module.exports = Zanimo;

},{"../src/normalize-transform-value":187,"../src/transition-shorthand-property":188,"q":179,"qanimationframe":180,"vendor-prefix":184}],186:[function(require,module,exports){
'use strict';

var matchParenthesis = /(\(.+?\))/g,
    space = / +/g,
    emptyString = "",
    whitespace = " ",

    normalize = function (match) {
        var args = match.substr(1, match.length-2).split(","),
            rst = args.map(function (arg) {
                return parseFloat(arg.replace(space, emptyString));
            });
        return "(" + rst.join(",") + ")";
    };

module.exports = function (t) {
    return  typeof t === 'string' ? t.replace(space, whitespace).replace(matchParenthesis, normalize) : t;
};

},{}],187:[function(require,module,exports){
'use strict';

var Color = require('color'),
    matchParenthesis = /(\(.+?\))/g,
    matchColors = /(\brgba\b|\bhsl\b|\bhsla\b)(\(.+?\))/g,
    space = / +/g,
    emptyString = "",
    whitespace = " ",
    zeropixel = /^0px$/g,
    zero = "0",

    normArgs = function (match) {
        var args = match.substr(1, match.length-2).split(","),
            rst = args.map(function (arg) {
                return arg.replace(space, emptyString).replace(zeropixel, zero);
            });
        return "(" + rst.join(",") + ")";
    },

    normColors = function (match) {
        var c = Color(match);
        if (c.alpha() ) { c.alpha(Math.round(c.alpha() * 10) / 10); }
        return c.rgbString();
    },

    normalize = function (val) {
        return val.replace(space, whitespace)
            .replace(matchColors, normColors)
            .replace(matchParenthesis, normArgs);
    };

module.exports = function (val) {
    if (val === null || val === undefined) return emptyString;
    return window.isNaN(val) ? normalize(val) : val.toString();
};

},{"color":6}],188:[function(require,module,exports){
'use strict';

var prefix = require('vendor-prefix'),
    normalizeTransformValue = require('./normalize-transform-value'),
    normalizeTimingFunction = require('./normalize-timing-function'),
    transition = prefix.dash('transition'),
    el = document.createElement('div'),
    test = 'opacity 100ms linear 0s',
    normalizedTest = normalizeTransformValue(test),
    shorthand = function shorthand(v, d, t) {
        return v + " " + d + "ms " + (t || "linear");
    };

el.style[transition] = normalizedTest;

if(normalizeTransformValue(el.style[transition]) === normalizedTest) {
    shorthand = function (v, d, t) {
        return v + " " + d + "ms " + (normalizeTimingFunction(t) || "linear") + " 0s";
    };
}

module.exports = shorthand;

},{"./normalize-timing-function":186,"./normalize-transform-value":187,"vendor-prefix":184}],189:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = backbutton;

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('./utils');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stack = [];

function backbutton() {
  var b = stack.pop();
  if ((0, _isFunction2.default)(b)) {
    b('backbutton');
    _mithril2.default.redraw();
  } else if (!/^\/$/.test(_mithril2.default.route())) {
    // if playing a game as anon ask for confirmation
    if (/^\/game\/[a-zA-Z0-9]{12}/.test(_mithril2.default.route())) {
      navigator.notification.confirm((0, _i18n2.default)('thereIsAGameInProgress'), function (i) {
        if (i === 1) (0, _utils.backHistory)();
      });
    } else {
      (0, _utils.backHistory)();
    }
  } else {
    window.navigator.app.exitApp();
  }
};

backbutton.stack = stack;

},{"./i18n":191,"./utils":262,"lodash/isFunction":145,"mithril":168}],190:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.apiVersion = undefined;
exports.request = request;

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _spinner = require('./spinner');

var _spinner2 = _interopRequireDefault(_spinner);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var apiVersion = exports.apiVersion = 1;

var baseUrl = window.oyunkeyf.apiEndPoint;

function onSuccess(data) {
  _spinner2.default.stop();
  return data;
}

function onError(data) {
  _spinner2.default.stop();
  throw data;
}

function xhrConfig(xhr) {
  xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  xhr.setRequestHeader('Accept', 'application/vnd.oyunkeyf.v' + apiVersion + '+json');
  xhr.withCredentials = true;
  xhr.timeout = 8000;
}

// convenient wrapper around m.request
function request(url, opts, feedback, xhrConf) {
  var cfg = {
    url: baseUrl + url,
    method: 'GET',
    data: {},
    config: xhrConf || xhrConfig,
    deserialize: function deserialize(text) {
      try {
        return JSON.parse(text);
      } catch (e) {
        throw { response: { error: 'Cannot read data from the server' } };
      }
    },
    unwrapError: function unwrapError(response, xhr) {
      return { response: response, status: xhr.status };
    }
  };
  (0, _merge2.default)(cfg, opts);

  if (cfg.method === 'GET') {
    cfg.data._ = Date.now();
  }

  var promise = _mithril2.default.request(cfg);

  if (feedback) {
    _spinner2.default.spin(document.body);
    return promise.then(onSuccess, onError);
  } else {
    return promise;
  }
}

},{"./spinner":201,"lodash/merge":156,"mithril":168}],191:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = i18n;
exports.loadPreferredLanguage = loadPreferredLanguage;
exports.getAvailableLanguages = getAvailableLanguages;
exports.loadFromSettings = loadFromSettings;

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var messages = [];

var untranslated = {};

var defaultCode = 'tr';

function i18n(key) {
  var str = messages[key] || untranslated[key] || key;
  for (var i = 1; i < arguments.length; ++i) {
    str = str.replace('%s', arguments[i]);
  }
  return str;
}

function loadPreferredLanguage() {
  if (_settings2.default.general.lang()) return loadFromSettings();

  // var deferred = m.deferred();
  // window.navigator.globalization.getPreferredLanguage(
  //   language => deferred.resolve(language.value.split('-')[0]),
  //   () => deferred.resolve(defaultCode));

  // return deferred.promise.then(code => {
  //   settings.general.lang(code);
  //   return code;
  // })
  //   .then(loadFile)
  //   .then(loadMomentLocale);
}

function getAvailableLanguages() {
  return _mithril2.default.request({
    url: 'i18n/refs.json',
    method: 'GET'
  }).then(function (data) {
    return data;
  }, function (error) {
    // same workaround for iOS as above
    if (error && error[0][0] === 'tr') return error;else throw { error: 'Cannot load languages' };
  });
}

function loadFromSettings() {
  return loadFile(_settings2.default.general.lang()).then(loadMomentLocale);
}

function loadFile(code) {
  return _mithril2.default.request({
    url: 'i18n/' + code + '.json',
    method: 'GET',
    deserialize: function deserialize(text) {
      try {
        return JSON.parse(text);
      } catch (e) {
        throw { error: 'Lang not available' };
      }
    }
  }).then(function (data) {
    messages = data;
    return code;
  }, function (error) {
    // workaround for iOS: because xhr for local file has a 0 status it will
    // reject the promise and still have the response object
    if (error && error.playWithAFriend) {
      messages = error;
      return code;
    } else {
      if (code === defaultCode) throw new Error(error);
      return loadFile(defaultCode);
    }
  });
}

function loadMomentLocale(code) {
  if (code !== 'en') {
    var script = document.createElement('script');
    script.src = 'moment/locale/' + code + '.js';
    document.head.appendChild(script);
  }
  window.moment.locale(code);
  return code;
}

},{"./settings":198,"mithril":168}],192:[function(require,module,exports){
'use strict';

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('./i18n');

var _xhr = require('./xhr');

var _helper = require('./ui/helper');

var helper = _interopRequireWildcard(_helper);

var _backbutton = require('./backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _socket = require('./socket');

var _socket2 = _interopRequireDefault(_socket);

var _routes = require('./routes');

var _routes2 = _interopRequireDefault(_routes);

var _appMode = require('./utils/appMode');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.moment = _moment2.default; /* application entry point */

// import './polyfills';


// for moment a global object makes loading locales easier


function main() {
  _routes2.default.init();
  // cache viewport dims
  helper.viewportDim();

  // pull session data once (to log in user automatically thanks to cookie)
  // and also listen to online event in case network was disconnected at app
  // startup
  if (utils.hasNetwork()) {
    // onOnline();
  }

  document.addEventListener('online', onOnline, false);
  document.addEventListener('offline', onOffline, false);
  document.addEventListener('resume', onResume, false);
  document.addEventListener('pause', onPause, false);
  document.addEventListener('backbutton', _backbutton2.default, false);
  window.addEventListener('unload', function () {
    _socket2.default.destroy();
    _socket2.default.terminate();
  });
  window.addEventListener('resize', onResize, false);

  if (cordova.platformId === 'android') {
    window.StatusBar.backgroundColorByHexString('#151A1E');
  }

  setTimeout(function () {
    window.navigator.splashscreen.hide();
    window.StatusBar.hide();
    // xhrStatus();
  }, 500);
}

function onOnline() {
  if ((0, _appMode.isForeground)()) {
    _session2.default.rememberLogin().then(function () {
      _mithril2.default.redraw();
    }).then(function () {
      return (0, _xhr.setServerLang)(_settings2.default.general.lang());
    });
  }
}

function onOffline() {
  if ((0, _appMode.isForeground)()) {
    _socket2.default.disconnect();
    _mithril2.default.redraw();
  }
}

function onResize() {
  helper.clearCachedViewportDim();
  _mithril2.default.redraw();
}

function onResume() {
  (0, _appMode.setForeground)();
  _socket2.default.connect();
}

function onPause() {
  (0, _appMode.setBackground)();
  _socket2.default.disconnect();
}

// function handleError(event, source, fileno, columNumber) {
//   var description = event + ' at ' + source + ' [' + fileno + ', ' + columNumber + ']';
// }

// window.onerror = handleError;

document.addEventListener('deviceready', function () {
  return main();
}, //loadPreferredLanguage().then(main),
false);

},{"./backbutton":189,"./i18n":191,"./routes":196,"./session":197,"./settings":198,"./socket":200,"./ui/helper":209,"./utils":262,"./utils/appMode":260,"./xhr":264,"mithril":168,"moment":177}],193:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _status = require('./status');

var _status2 = _interopRequireDefault(_status);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function playable(data) {
  return data.game.status.id < _status2.default.ids.aborted;
}

function isPlayerPlaying(data) {
  return playable(data) && !data.player.spectator;
}

function isPlayerTurn(data) {
  return isPlayerPlaying(data) && data.game.player === data.player.side;
}

function getPlayer(data, side) {
  return ['player', 'opponentLeft', 'opponentRight', 'opponentUp'].map(function (k) {
    return data[k];
  }).filter(function (player) {
    return player.side === side;
  })[0];
}

function result(data) {
  if (_status2.default.aborted(data)) {
    return (0, _i18n2.default)('gameAborted');
  } else if (_status2.default.finished(data)) {
    return (0, _i18n2.default)('gameFinished');
  }
};

var sides = ["east", "north", "west", "south"];

function sideByPly(ply) {
  return sides[ply % 4];
}

function setOnGame(data, side, onGame) {
  var player = getPlayer(data, side);
  player.onGame = onGame;
}

// function roundsOrScores(game) {
//   if (game.rounds) {
//     return data.
//   } else if (data.scores) {

//   } else {
//     return '';
//   }
// }

function title(data) {
  var text;
  if (isPlayerTurn(data)) {
    text = (0, _i18n2.default)('yourTurn');
  } else {
    text = (0, _i18n2.default)('waitingForOpponent');
  }
  // const variant = getVariant(data.game.variant.key);
  // const name = variant ? (variant.shortName || variant.name) : '';
  return text;
}

exports.default = {
  isPlayerPlaying: isPlayerPlaying,
  isPlayerTurn: isPlayerTurn,
  getPlayer: getPlayer,
  sideByPly: sideByPly,
  playable: playable,
  setOnGame: setOnGame,
  title: title,
  result: result
};

},{"../i18n":191,"./status":194}],194:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ids = {
  created: 10,
  started: 20,
  aborted: 25,
  middleEnd: 30,
  normalEnd: 40,
  variantEnd: 70
}; // scalaokey/src/main/scala/Status.scala

function started(data) {
  return data.game.status.id >= ids.started;
}

function finished(data) {
  return data.game.status.id >= ids.middleEnd;
}

function aborted(data) {
  return data.game.status.id === ids.aborted;
}

function middleEnd(data) {
  return data.game.status.id === ids.middleEnd;
}

function playing(data) {
  return started(data) && !finished(data) && !aborted(data);
}

function toLabel(status, winner, variant) {
  switch (status) {
    case 'started':
      return (0, _i18n2.default)('playingRightNow');
    case 'aborted':
      return (0, _i18n2.default)('gameAborted');
    case 'middleEnd':
      return (0, _i18n2.default)('gameMiddleFinished');
    case 'normalEnd':
      return (0, _i18n2.default)('gameFinished');
    case 'variantEnd':
      return (0, _i18n2.default)('gameFinished');
  }
};

exports.default = {
  ids: ids,
  started: started,
  finished: finished,
  aborted: aborted,
  playing: playing,
  middleEnd: middleEnd,
  toLabel: toLabel
};

},{"../i18n":191}],195:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineRoutes = defineRoutes;

var _rliteRouter = require('rlite-router');

var _rliteRouter2 = _interopRequireDefault(_rliteRouter);

var _render = require('mithril/render');

var RenderService = _interopRequireWildcard(_render);

var _vnode = require('mithril/render/vnode');

var _vnode2 = _interopRequireDefault(_vnode);

var _signals = require('./signals');

var _signals2 = _interopRequireDefault(_signals);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var router = new _rliteRouter2.default();

var currentStateId = 0;
var viewSlideDirection = 'fwd';

var previousPath = '/';

var backbutton = function () {
  var x = function x() {

    var b = x.stack.length === 0 ? null : x.stack.pop();

    if (isFunction(b)) {
      b('backbutton');
      (0, _redraw2.default)();
    } else if (!/^\/$/.test(get())) {
      backHistory();
    } else {
      window.navigator.app.exitApp();
    }
  };

  x.stack = [];

  return x;
}();

function defineRoutes(mountPoint, routes) {
  var _loop = function _loop(route) {
    var component = routes[route];
    router.add(route, function onRouteMatch(_ref) {
      var params = _ref.params;

      var RouteComponent = {
        view: function view() {
          var node = (0, _vnode2.default)(component, undefined, params);
          return node;
        }
      };

      function redraw() {
        RenderService.render(mountPoint, (0, _vnode2.default)(RouteComponent));
      }

      _signals2.default.redraw.removeAll();
      _signals2.default.redraw.add(redraw);
      try {
        redraw();
      } catch (e) {
        _signals2.default.redraw.removeAll();
        throw e;
      }
    });
  };

  for (var route in routes) {
    _loop(route);
  }
  window.addEventListener('popstate', processQuerystring);
  processQuerystring();
}

function processQuerystring(e) {
  if (e && e.state) {
    if (e.state.id < currentStateId) {
      viewSlideDirection = 'bwd';
    } else {
      viewSlideDirection = 'fwd';
    }
    currentStateId = e.state.id;
  }
  previousPath = get();
  var qs = window.location.search || '?=';
  var matched = router.run(qs.slice(2));
  if (!matched) router.run('/');
}

function get() {
  var path = window.location.search || '?=/';
  return decodeURIComponent(path.substring(2));
}

function backHistory() {
  window.history.go(-1);
}

exports.default = {
  backbutton: backbutton
};

},{"./signals":199,"./utils/redraw":263,"mithril/render":169,"mithril/render/vnode":174,"rlite-router":181}],196:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _home = require('./ui/home');

var _home2 = _interopRequireDefault(_home);

var _game = require('./ui/game');

var _game2 = _interopRequireDefault(_game);

var _user = require('./ui/user');

var _user2 = _interopRequireDefault(_user);

var _players = require('./ui/players');

var _players2 = _interopRequireDefault(_players);

var _detail = require('./ui/masa/detail');

var _detail2 = _interopRequireDefault(_detail);

var _masa = require('./ui/masa');

var _masa2 = _interopRequireDefault(_masa);

var _settings = require('./ui/settings');

var _settings2 = _interopRequireDefault(_settings);

var _lang = require('./ui/settings/lang');

var _lang2 = _interopRequireDefault(_lang);

var _router = require('./router');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  init: function init() {
    (0, _router.defineRoutes)(document.body, {
      '': _home2.default,
      '/@/:id': _user2.default,
      '/players': _players2.default,
      '/game/:id': _game2.default,
      '/masa': _masa2.default,
      '/masa/:id': _detail2.default,
      '/masa/:masaId/game/:id': _game2.default,
      '/settings': _settings2.default,
      '/settings/lang': _lang2.default
    });
  }
};

},{"./router":195,"./ui/game":205,"./ui/home":212,"./ui/masa":220,"./ui/masa/detail":216,"./ui/players":228,"./ui/settings":243,"./ui/settings/lang":244,"./ui/user":256}],197:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _http = require('./http');

var _utils = require('./utils');

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var session = null;

function isConnected() {
  return !!session;
}

function getSession() {
  return session;
}

function getUserId() {
  return session && session.id ? session.id : null;
}

function nowPlaying() {
  var np = session && session.nowPlaying || [];
  return np.filter(function (e) {
    return _settings2.default.game.supportedVariants.indexOf(e.variant.key) !== -1;
  });
}

function login(username, password) {
  return (0, _http.request)('/login', {
    method: 'POST',
    data: {
      username: username,
      password: password
    }
  }, true).then(function (data) {
    session = data;
    return session;
  });
}

function logout() {
  return (0, _http.request)('/logout', {}, true).then(function () {
    session = null;
  }, function (err) {
    (0, _utils.handleXhrError)(err);
    throw err;
  });
}

function signup(username, email, password) {
  return (0, _http.request)('/signup', {
    method: 'POST',
    data: {
      username: username,
      email: email,
      password: password
    }
  }, true).then(function (data) {
    session = data;
    return session;
  });
}

function rememberLogin() {
  return (0, _http.request)('/account/info', {
    background: true
  }).then(function (data) {
    session = data;
    return data;
  });
}

function refresh() {
  if ((0, _utils.hasNetwork)() && isConnected()) {
    return (0, _http.request)('/account/info', {
      background: true
    }).then(function (data) {
      session = data;
      _mithril2.default.redraw();
      return session;
    }, function (err) {
      if (session && err.status === 401) {
        session = null;
        _mithril2.default.redraw();
        window.plugins.toast.show((0, _i18n2.default)('signedOut'), 'short', 'center');
      }
      throw err;
    });
  } else {
    return Promise.resolve(false);
  }
}

exports.default = {
  isConnected: isConnected,
  signup: signup,
  logout: logout,
  login: (0, _throttle2.default)(login, 1000),
  rememberLogin: (0, _throttle2.default)(rememberLogin, 1000),
  refresh: (0, _throttle2.default)(refresh, 1000),
  get: getSession,
  getUserId: getUserId,
  nowPlaying: nowPlaying
};

},{"./http":190,"./i18n":191,"./settings":198,"./utils":262,"lodash/throttle":162,"mithril":168}],198:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

var _range = require('lodash/range');

var _range2 = _interopRequireDefault(_range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function localstorageprop(key, initialValue) {
  return function () {
    if (arguments.length) _storage2.default.set(key, arguments[0]);
    var ret = _storage2.default.get(key);
    return ret !== null ? ret : initialValue;
  };
}

function tupleOf(x) {
  return [x.toString(), x.toString()];
}

exports.default = {
  general: {
    lang: localstorageprop('settings.lang'),
    theme: {
      background: localstorageprop('settings.bgTheme', 'dark')
    }
  },
  game: {
    supportedVariants: ['standard', 'yuzbir', 'duzokey']
  },
  gameSetup: {
    availableRounds: [1, 5, 10, 15, 20, 25, 30].map(tupleOf),
    isRoundValid: function isRoundValid(gameSettings) {
      return gameSettings.rounds() !== '0';
    },
    human: {
      availableVariants: [['101 Okey', '1'], ['Dz Okey', '3']],
      variant: localstorageprop('settings.game.human.variant', '1'),
      rounds: localstorageprop('settings.game.human.rounds', '1'),
      mode: localstorageprop('settings.game.human.mode', '0'),
      membersOnly: localstorageprop('settings.game.human.membersOnly', false)
    }
  }
};

},{"./storage":202,"lodash/range":159}],199:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _signals = require('signals');

exports.default = {

  redraw: new _signals.Signal(),

  afterLogin: new _signals.Signal(),

  afterLogout: new _signals.Signal(),

  sessionRestored: new _signals.Signal()

};

},{"signals":182}],200:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

var _utils = require('./utils');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var worker = new Worker('lib/socketWorker.js');

var socketHandlers = void 0;
var errorDetected = false;
var connectedWS = true;

var alreadyWarned = false;
var redrawOnDisconnectedTimeoutID = void 0;
var proxyFailTimeoutID = void 0;
var proxyFailMsg = "Oyunkeyf sunucularna balant koptu. Problem srekli yaanyorsa proxy yada network'la ilgili olabilir.";

var defaultHandlers = {};

function createGame(url, version, handlers, gameUrl) {
  errorDetected = false;
  socketHandlers = {
    onError: function onError() {
      // we can't get socket error, so we send an xhr to test whether the
      // rejection is an authorization issue
      if (!errorDetected) {
        // just to be sure that we don't send an xhr every second when the
        // websocket is trying to reconnect
        errorDetected = true;
        xhr.game(gameUrl.substring(1)).then(function () {}, function (err) {
          if (err.status === 401) {
            window.plugins.toast.show(i18n('unauthorizedError'), 'short', 'center');
            _mithril2.default.route('/');
          }
        });
      }
    },
    events: Object.assign({}, defaultHandlers, handlers)
  };

  var opts = {
    options: {
      name: 'game',
      debug: false,
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  (0, _utils.tellWorker)(worker, 'create', {
    clientId: _utils.oyunkeyfSri,
    socketEndPoint: window.oyunkeyf.socketEndPoint,
    url: url,
    version: version,
    opts: opts
  });
}

function createMasa(masaId, version, handlers) {
  var url = '/masa/' + masaId + '/socket/v1';

  socketHandlers = {
    events: Object.assign({}, defaultHandlers, handlers)
  };
  var opts = {
    options: {
      name: 'masa',
      debug: false,
      pingDelay: 2000,
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  (0, _utils.tellWorker)(worker, 'create', {
    clientId: _utils.oyunkeyfSri,
    socketEndPoint: window.oyunkeyf.socketEndPoint,
    url: url,
    version: version,
    opts: opts
  });
}

function createMasaHome(handlers) {
  var url = '/socket';

  socketHandlers = {
    events: Object.assign({}, defaultHandlers, handlers)
  };
  var opts = {
    params: { flag: 'masa' },
    options: {
      name: 'masaHome',
      debug: false,
      pingDelay: 2000,
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  (0, _utils.tellWorker)(worker, 'create', {
    clientId: _utils.oyunkeyfSri,
    socketEndPoint: window.oyunkeyf.socketEndPoint,
    url: url,
    version: 0,
    opts: opts
  });
}

function createLobby(lobbyVersion, onOpen, handlers) {
  socketHandlers = {
    onOpen: onOpen,
    events: Object.assign({}, defaultHandlers, handlers)
  };
  var opts = {
    options: {
      name: 'lobby',
      debug: false,
      pingDelay: 2000,
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  (0, _utils.tellWorker)(worker, 'create', {
    clientId: _utils.oyunkeyfSri,
    socketEndPoint: window.oyunkeyf.socketEndPoint,
    url: '/lobby/socket/v1',
    version: lobbyVersion,
    opts: opts
  });
}

function createDefault() {
  // default socket is useless when anon.?
  if ((0, _utils.hasNetwork)()) {
    socketHandlers = {
      events: defaultHandlers
    };
    var opts = {
      options: {
        name: 'default',
        debug: false,
        pingDelay: 2000,
        registeredEvents: Object.keys(socketHandlers.events)
      }
    };
    (0, _utils.tellWorker)(worker, 'create', {
      clientId: _utils.oyunkeyfSri,
      socketEndPoint: window.oyunkeyf.socketEndPoint,
      url: '/socket',
      version: 0,
      opts: opts
    });
  }
}

function onConnected() {
  var wasOff = !connectedWS;
  connectedWS = true;
  clearTimeout(proxyFailTimeoutID);
  clearTimeout(redrawOnDisconnectedTimeoutID);
  if (wasOff) _mithril2.default.redraw();
}

function onDisconnected() {
  var wasOn = connectedWS;
  connectedWS = false;
  if (wasOn) redrawOnDisconnectedTimeoutID = setTimeout(function () {
    _mithril2.default.redraw();
  }, 2000);
  if (wasOn && !alreadyWarned && !_storage2.default.get('donotshowproxyfailwarning')) proxyFailTimeoutID = setTimeout(function () {
    // check if disconnection lasts, it could mean a proxy prevents
    // establishing a tunnel
    if ((0, _utils.hasNetwork)() && !connectedWS) {
      alreadyWarned = true;
      window.navigator.notification.alert(proxyFailMsg, function () {
        _storage2.default.set('donotshowproxyfailwarning', true);
      });
    }
  }, 20000);
}

worker.addEventListener('message', function (msg) {
  switch (msg.data.topic) {
    case 'onOpen':
      if (socketHandlers.onOpen) socketHandlers.onOpen();
      break;
    case 'disconnected':
      onDisconnected();
      break;
    case 'connected':
      onConnected();
      break;
    case 'onError':
      if (socketHandlers.onError) socketHandlers.onError();
      break;
    case 'handle':
      var h = socketHandlers.events[msg.data.payload.t];
      if (h) h(msg.data.payload.d || null, msg.data.payload);
      break;
  }
});

exports.default = {
  createDefault: createDefault,
  createMasa: createMasa,
  createMasaHome: createMasaHome,
  createGame: createGame,
  createLobby: createLobby,
  setVersion: function setVersion(version) {
    (0, _utils.tellWorker)(worker, 'setVersion', version);
  },
  send: function send(type, data, opts) {
    (0, _utils.tellWorker)(worker, 'send', [type, data, opts]);
  },
  connect: function connect() {
    (0, _utils.tellWorker)(worker, 'connect');
  },
  disconnect: function disconnect() {
    (0, _utils.tellWorker)(worker, 'disconnect');
  },
  isConnected: function isConnected() {
    return connectedWS;
  },
  destroy: function destroy() {
    (0, _utils.tellWorker)(worker, 'destroy');
  },
  terminate: function terminate() {
    if (worker) worker.terminate();
  }
};

},{"./storage":202,"./utils":262,"mithril":168}],201:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var timeoutId;

exports.default = {
  spin: function spin() {
    if (timeoutId || document.getElementsByClassName('globalSpinner').length > 0) {
      return false;
    }

    var spinner = document.createElement('div');
    spinner.className = 'spinner globalSpinner';
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 40 40');
    var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', '20');
    circle.setAttribute('cy', '20');
    circle.setAttribute('r', '18');
    circle.setAttribute('fill', 'none');
    svg.appendChild(circle);
    spinner.appendChild(svg);

    timeoutId = setTimeout(function () {
      return document.body.appendChild(spinner);
    }, 200);
  },
  stop: function stop() {
    clearTimeout(timeoutId);
    timeoutId = null;
    var spinners = document.getElementsByClassName('globalSpinner');
    if (spinners.length) {
      setTimeout(function () {
        while (spinners[0]) {
          document.body.removeChild(spinners[0]);
        }
      }, 500);
    }
  },
  getVdom: function getVdom(classes) {
    return h(
      'div',
      { 'class': 'spinner ' + classes },
      h(
        'svg',
        { viewBox: '0 0 40 40' },
        h('circle', { cx: '20', cy: '20', r: '18', fill: 'none' })
      )
    );
  }
};

},{"mithril/hyperscript":167}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function withStorage(f) {
  // can throw an exception if storage is full
  try {
    return !!window.localStorage ? f(window.localStorage) : null;
  } catch (e) {}
}

exports.default = {

  get: function get(k) {
    return withStorage(function (s) {
      return JSON.parse(s.getItem(k));
    });
  },
  remove: function remove(k) {
    return withStorage(function (s) {
      s.removeItem(k);
    });
  },
  set: function set(k, v) {
    return withStorage(function (s) {
      s.removeItem(k);
      s.setItem(k, JSON.stringify(v));
    });
  }
};

},{}],203:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _utils = require('../../utils');

var _xhr = require('../../xhr');

var _roundCtrl = require('../round/roundCtrl');

var _roundCtrl2 = _interopRequireDefault(_roundCtrl);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  var gameData;
  var round;

  if ((0, _utils.hasNetwork)()) {
    (0, _xhr.game)(_mithril2.default.route.param('id')).then(function (data) {
      gameData = data;
      round = new _roundCtrl2.default(data);
    }, function (error) {
      (0, _utils.handleXhrError)(error);
      _mithril2.default.route('/');
    });
  }

  return {
    onunload: function onunload() {
      if (round) {
        round.onunload();
        round = null;
      }
    },
    getRound: function getRound() {
      return round;
    }
  };
}

},{"../../utils":262,"../../xhr":264,"../round/roundCtrl":237,"mithril":168}],204:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = view;

var _roundView = require('../round/view/roundView');

var _roundView2 = _interopRequireDefault(_roundView);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function view(ctrl) {
  if (ctrl.getRound()) return (0, _roundView2.default)(ctrl.getRound());
}

},{"../round/view/roundView":242,"mithril":168}],205:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gameCtrl = require('./gameCtrl');

var _gameCtrl2 = _interopRequireDefault(_gameCtrl);

var _gameView = require('./gameView');

var _gameView2 = _interopRequireDefault(_gameView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _gameCtrl2.default,
  view: _gameView2.default
};

},{"./gameCtrl":203,"./gameView":204}],206:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _popup = require('./shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _form = require('./shared/form');

var _form2 = _interopRequireDefault(_form);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _newGameForm = require('./newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _iscroll = require('iscroll');

var _iscroll2 = _interopRequireDefault(_iscroll);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _lobby = require('./lobby');

var _lobby2 = _interopRequireDefault(_lobby);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _ViewOnlyBoard = require('./shared/ViewOnlyBoard');

var _ViewOnlyBoard2 = _interopRequireDefault(_ViewOnlyBoard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scroller = null;

var gamesMenu = {};

gamesMenu.isOpen = false;

gamesMenu.open = function () {
  _backbutton2.default.stack.push(gamesMenu.close);
  gamesMenu.isOpen = true;
  setTimeout(function () {
    if (utils.hasNetwork() && scroller) scroller.goToPage(1, 0);
  }, 400);
  _session2.default.refresh();
};

gamesMenu.close = function (fromBB) {
  if (fromBB !== 'backbutton' && gamesMenu.isOpen) _backbutton2.default.stack.pop();
  gamesMenu.isOpen = false;
};

function joinGame(g) {
  gamesMenu.close();
  _mithril2.default.route('/game/' + g.fullId);
}

function cardDims() {
  var vp = _helper2.default.viewportDim();

  // if we're here it's a phone
  var width = 200;
  var height = width / (4 / 3);
  var margin = 10;
  return {
    w: width + margin * 2,
    h: height + 70,
    innerW: width,
    margin: margin
  };
}

function renderViewOnlyBoard(cDim, fen, orientation, variant) {
  var innerH = cDim ? cDim.innerW / (4 / 3) : 0;
  var innerW = cDim ? cDim.innerW : 0;
  var style = cDim ? { height: innerH + 'px' } : {};
  var bounds = cDim ? { width: innerW, height: innerH } : null;
  return h(
    'div',
    { className: 'boardWrapper', style: style },
    _mithril2.default.component(_ViewOnlyBoard2.default, { bounds: bounds, fen: fen, orientation: orientation, variant: variant })
  );
}

function timeLeft(g) {
  if (!g.isMyTurn) return (0, _i18n2.default)('waitingForOpponent');
  return (0, _i18n2.default)('yourTurn');
}

function renderGame(g, cDim, cardStyle) {
  var icon = utils.gameIcon(g.perf);
  var cardClass = ['card', 'standard'].join(' ');

  var timeClass = ['timeIndication', g.isMyTurn ? 'myTurn' : 'opponentTurn'].join(' ');
  var config = _helper2.default.ontouchX(function () {
    return joinGame(g);
  });

  return h(
    'div',
    { className: cardClass, key: 'game.' + g.gameId, style: cardStyle,
      config: config },
    renderViewOnlyBoard(cDim, g.fen, g.side, g.variant),
    h(
      'div',
      { className: 'infos' },
      h(
        'div',
        { className: 'description' },
        h(
          'p',
          null,
          h(
            'span',
            { className: 'variant' },
            g.variant.name
          ),
          h(
            'span',
            { className: timeClass },
            timeLeft(g)
          )
        )
      )
    )
  );
}

function renderAllGames(cDim) {
  var nowPlaying = _session2.default.nowPlaying(); // .concat(session.nowPlaying());
  var cardStyle = cDim ? {
    width: cDim.w - cDim.margin * 2 + 'px',
    height: cDim.h + 'px',
    marginLeft: cDim.margin + 'px',
    marginRight: cDim.margin + 'px'
  } : {};

  var nbCards = utils.hasNetwork() ? nowPlaying.length + 1 : 0;

  var wrapperStyle = void 0,
      wrapperWidth = void 0;
  if (cDim) {
    // scroller wrapper width
    // calcul is:
    // ((cardWidth + visible part of adjacent card) * nb of cards) +
    // wrapper's marginLeft
    wrapperWidth = (cDim.w + cDim.margin * 2) * nbCards + cDim.margin * 2;
    wrapperStyle = {
      width: wrapperWidth + 'px',
      marginLeft: cDim.margin * 3 + 'px'
    };
  }

  var allCards = nowPlaying.map(function (g) {
    return renderGame(g, cDim, cardStyle);
  });

  if (!_helper2.default.isWideScreen()) {

    var newGameCard = h(
      'div',
      { className: 'card standard', key: 'game.new-game', style: cardStyle,
        config: _helper2.default.ontouchX(function () {
          gamesMenu.close();_newGameForm2.default.open();
        }) },
      renderViewOnlyBoard(cDim),
      h(
        'div',
        { className: 'infos' },
        h(
          'div',
          { className: 'description' },
          h(
            'h2',
            { className: 'title' },
            (0, _i18n2.default)('createAGame')
          ),
          h(
            'p',
            null,
            (0, _i18n2.default)('newOpponent')
          )
        )
      )
    );
    if (utils.hasNetwork()) allCards.unshift(newGameCard);
  }

  return (0, _mithril2.default)('div#all_games', { style: wrapperStyle }, allCards);
}

gamesMenu.view = function () {
  if (!gamesMenu.isOpen) return null;

  var vh = _helper2.default.viewportDim().vh;
  var cDim = cardDims();
  var wrapperStyle = _helper2.default.isWideScreen() ? {} : { top: (vh - cDim.h) / 2 + 'px' };
  var wrapperConfig = _helper2.default.isWideScreen() ? utils.noop : function (el, isUpdate, context) {
    if (!isUpdate) {
      scroller = new _iscroll2.default(el, {
        scrollX: true,
        scrollY: false,
        momentum: false,
        snap: '.card',
        snapSpeed: 400,
        preventDefaultException: {
          tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|LABEL)$/
        }
      });

      context.unonload = function () {
        if (scroller) {
          scroller.destroy();
          scroller = null;
        }
      };
    }
    // see https://github.com/cubiq/iscroll/issues/412
    scroller.options.snap = el.querySelectorAll('.card');
    scroller.refresh();
  };

  var isWideScreen = _helper2.default.isWideScreen();

  var wrapperClass = isWideScreen ? 'overlay_popup' : '';

  return h(
    'div',
    { id: 'games_menu', className: 'overlay_popup_wrapper' },
    h('div', { className: 'wrapper_overlay_close',
      config: _helper2.default.ontouch(_helper2.default.fadesOut(gamesMenu.close, '.overlay_popup_wrapper')) }),
    h(
      'div',
      { id: 'wrapper_games', className: wrapperClass, style: wrapperStyle, config: wrapperConfig },
      isWideScreen ? h(
        'header',
        null,
        (0, _i18n2.default)('nbGamesInPlay', _session2.default.nowPlaying().length)
      ) : null,
      isWideScreen ? h(
        'div',
        { className: 'popup_content' },
        renderAllGames(null)
      ) : renderAllGames(cDim)
    )
  );
};

exports.default = gamesMenu;

},{"../backbutton":189,"../i18n":191,"../session":197,"../settings":198,"../utils":262,"./helper":209,"./lobby":214,"./newGameForm":227,"./shared/ViewOnlyBoard":247,"./shared/form":249,"./shared/popup":251,"iscroll":7,"mithril":168,"mithril/hyperscript":167}],207:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = animator;

var _utils = require('../../utils');

var animating = false;

// Author Barney Caroll
// taken from https://gist.github.com/barneycarroll/c69fbe0786e37c941baf

// Define an animator consisting of optional incoming and outgoing animations.
// alwaysAnimate is false unless specified as true: false means an incoming animation will only trigger if an outgoing animation is also in progress.
// forcing dontClone to true means the outward animation will use the original element rather than a clone. This could improve performance by recycling elements, but can lead to trouble: clones have the advantage of being stripped of all event listeners.
function animator(incoming, outgoing, alwaysAnimate, dontClone) {
  // The resulting animator can be applied to any number of components
  return function animate(x, y, z) {
    var config;
    var parent;
    var next;

    // When used as a config function
    if (x.nodeType) {
      return animationConfig(x, y, z);
    }
    // When passed a virtual DOM node (the output of m)
    else if (x.attrs) {
        return bindConfigTo(x);
      }
      // When applied to a Mithril module / component
      else if (x.view) {
          return {
            controller: x.controller || _utils.noop,
            view: function animatedView(ctrl) {
              return bindConfigTo(x.view(ctrl));
            }
          };
        }

    function bindConfigTo(node) {
      if (!node) return null;

      config = node.attrs.config;

      node.attrs.config = animationConfig;

      return node;
    }

    function animationConfig(el, init, context) {
      var output;
      var onunload;

      if (config) {
        output = config(el, init, context);
        // If the root element already has a config, it may also have an onunload which we should take care to preserve
        onunload = context.onunload;
      }

      if (!init) {
        if (incoming && alwaysAnimate || animating) {
          incoming(el, _utils.noop, context);
        }

        context.onunload = outgoing ? onunload ? function onunloadWrapper() {
          teardown();
          onunload();
        } : teardown : onunload;

        parent = el.parentElement;
        next = el.nextSibling;
      }

      return output;

      function teardown() {
        var insertion = dontClone ? el : el.cloneNode(true);
        var reference = null;

        if (next && parent && next.parentNode === parent) {
          reference = next;
        }

        animating = true;

        setTimeout(function resetAnimationFlag() {
          animating = false;
        }, 0);

        parent.insertBefore(insertion, reference);

        outgoing(insertion, function destroy() {
          if (parent.contains(insertion)) {
            parent.removeChild(insertion);
          }
        }, context);
      }
    }
  };
}

},{"../../utils":262}],208:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ButtonHandler;

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HOLD_DURATION = 600;
var REPEAT_RATE = 20;
var SCROLL_TOLERANCE = 8;
var ACTIVE_CLASS = 'active';

function hasContextMenu() {
  return window.cordova.platformId !== 'ios';
}

function ButtonHandler(el, tapHandler, holdHandler, repeatHandler, scrollX, scrollY, touchEndFeedback) {

  var startX = void 0,
      startY = void 0,
      boundaries = void 0,
      active = void 0,
      holdTimeoutID = void 0,
      repeatTimeoutId = void 0,
      repeatIntervalID = void 0;

  if (typeof tapHandler !== 'function') throw new Error('ButtonHandler 2nd argument must be a function!');

  if (holdHandler && typeof holdHandler !== 'function') throw new Error('ButtonHandler 3rd argument must be a function!');

  if (repeatHandler && typeof repeatHandler !== 'function') throw new Error('ButtonHandler 4rd argument must be a function!');

  // http://ejohn.org/blog/how-javascript-timers-work/
  function onRepeat() {
    var res = repeatHandler();
    repeatIntervalID = setTimeout(onRepeat, REPEAT_RATE);
    if (!res) clearTimeout(repeatIntervalID);
    _mithril2.default.redraw();
  }

  function onTouchStart(e) {
    var touch = e.changedTouches[0];
    var boundingRect = el.getBoundingClientRect();
    startX = touch.clientX;
    startY = touch.clientY;
    boundaries = {
      minX: boundingRect.left,
      maxX: boundingRect.right,
      minY: boundingRect.top,
      maxY: boundingRect.bottom
    };
    active = true;
    setTimeout(function () {
      if (active) el.classList.add(ACTIVE_CLASS);
    }, 200);
    if (!hasContextMenu()) holdTimeoutID = setTimeout(onHold, HOLD_DURATION);
    clearTimeout(repeatIntervalID);
    if (repeatHandler) repeatTimeoutId = setTimeout(function () {
      repeatIntervalID = setTimeout(onRepeat, REPEAT_RATE);
    }, 150);
  }

  function onTouchMove(e) {
    // if going out of bounds, no way to reenable the button
    if (active) {
      var touch = e.changedTouches[0];
      active = isActive(touch);
      if (!active) {
        clearTimeout(holdTimeoutID);
        clearTimeout(repeatTimeoutId);
        clearTimeout(repeatIntervalID);
        el.classList.remove(ACTIVE_CLASS);
      }
    }
  }

  function onTouchEnd(e) {
    if (e.cancelable) e.preventDefault();
    clearTimeout(repeatTimeoutId);
    clearTimeout(repeatIntervalID);
    if (active) {
      clearTimeout(holdTimeoutID);
      if (touchEndFeedback) el.classList.add(ACTIVE_CLASS);
      tapHandler(e);
      active = false;
      setTimeout(function () {
        return el.classList.remove(ACTIVE_CLASS);
      }, 80);
    }
  }

  function onTouchCancel() {
    clearTimeout(holdTimeoutID);
    clearTimeout(repeatTimeoutId);
    clearTimeout(repeatIntervalID);
    active = false;
    el.classList.remove(ACTIVE_CLASS);
  }

  function onContextMenu(e) {
    e.preventDefault();
    e.stopPropagation();
    if (holdTimeoutID === undefined) onHold();
  }

  function onHold() {
    if (holdHandler) {
      holdHandler();
      active = false;
      el.classList.remove(ACTIVE_CLASS);
    }
  }

  function isActive(touch) {
    var x = touch.clientX,
        y = touch.clientY,
        b = boundaries,
        d = 0;
    if (scrollX) d = Math.abs(x - startX);
    if (scrollY) d = Math.abs(y - startY);
    return x < b.maxX && x > b.minX && y < b.maxY && y > b.minY && d < SCROLL_TOLERANCE;
  }

  el.addEventListener('touchstart', onTouchStart, false);
  el.addEventListener('touchmove', onTouchMove, false);
  el.addEventListener('touchend', onTouchEnd, false);
  el.addEventListener('touchcancel', onTouchCancel, false);
  el.addEventListener('contextmenu', onContextMenu, false);
}

},{"mithril":168}],209:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ontap = ontap;
exports.ontapXY = ontapXY;
exports.viewportDim = viewportDim;

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _button = require('./button');

var _button2 = _interopRequireDefault(_button);

var _animator = require('./animator');

var _animator2 = _interopRequireDefault(_animator);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createTapHandler(tapHandler, holdHandler, repeatHandler, scrollX, scrollY, getElement, preventEndDefault) {
  return function (vnode) {
    (0, _button2.default)(vnode.dom, function (e) {
      tapHandler(e);
      (0, _redraw2.default)();
    }, holdHandler ? function (e) {
      return utils.autoredraw(function () {
        return holdHandler(e);
      });
    } : undefined, repeatHandler, scrollX, scrollY, getElement, preventEndDefault);
  };
}

function ontap(tapHandler, holdHandler, repeatHandler, getElement) {
  return createTapHandler(tapHandler, holdHandler, repeatHandler, false, false, getElement);
}

function ontapXY(tapHandler, holdHandler, getElement) {
  var preventEndDefault = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  return createTapHandler(tapHandler, holdHandler, undefined, true, true, getElement, preventEndDefault);
}

//store temporarily last route to disable animations on same route
// TODO find a better way cause this is ugly
var lastRoute = void 0;

// this must be cached because of the access to document.body.style
var cachedTransformProp = void 0;
var cachedViewportDim = null;

function viewSlideIn(el, callback) {
  if (_mithril2.default.route() === lastRoute) {
    callback();
    return;
  }

  lastRoute = _mithril2.default.route();

  function after() {
    utils.setViewSlideDirection('fwd');
    el.removeAttribute('style');
    callback();
  }

  var direction = utils.getViewSlideDirection() === 'fwd' ? '100%' : '-100%';
  el.style.transform = 'translate3d(' + direction + ',0,0)';
  el.style.transition = 'transform 200ms ease-out';

  setTimeout(function () {
    el.style.transform = 'translate3d(0%,0,0)';
  });

  el.addEventListener('transitionend', after, false);
}

function viewSlideOut(el, callback) {
  if (_mithril2.default.route() === lastRoute) {
    callback();
    return;
  }

  function after() {
    utils.setViewSlideDirection('fwd');
    callback();
  }

  var direction = utils.getViewSlideDirection() === 'fwd' ? '-100%' : '100%';
  el.style.transform = 'translate3d(0%,0,0)';
  el.style.transition = 'transform 200ms ease-out';

  setTimeout(function () {
    el.style.transform = 'translate3d(' + direction + ',0,0)';
  });

  el.addEventListener('transitionend', after, false);
}

function viewFadesIn(el, callback) {
  var tId;

  el.style.opacity = '0.5';
  el.style.transition = 'opacity 200ms ease-out';

  setTimeout(function () {
    el.style.opacity = '1';
  });

  function after() {
    clearTimeout(tId);
    if (el) {
      el.removeAttribute('style');
      el.removeEventListener('transitioned', after, false);
    }
    callback();
  }

  el.addEventListener('transitioned', after, false);

  // in case transitioned does not fire
  // TODO find a way to avoid it
  tId = setTimeout(after, 250);
}

function viewFadesOut(el, callback) {
  var tId;

  el.style.opacity = '1';
  el.style.transition = 'opacity 200ms ease-out, visibility 0s linear 200ms';

  setTimeout(function () {
    el.style.opacity = '0';
    el.style.visibility = 'hidden';
  });

  function after() {
    clearTimeout(tId);
    callback();
  }

  el.addEventListener('transitioned', after, false);

  // in case transitioned does not fire
  // TODO find a way to avoid it
  tId = setTimeout(after, 250);
}

function collectionHas(coll, el) {
  for (var i = 0, len = coll.length; i < len; i++) {
    if (coll[i] === el) return true;
  }
  return false;
}

function findParentBySelector(el, selector) {
  var matches = document.querySelectorAll(selector);
  var cur = el.parentNode;
  while (cur && !collectionHas(matches, cur)) {
    cur = cur.parentNode;
  }
  return cur;
}

function ontouch(tapHandler, holdHandler, repeatHandler, scrollX, scrollY, touchEndFeedback) {
  return function (el, isUpdate) {
    if (!isUpdate) {
      (0, _button2.default)(el, function (e) {
        _mithril2.default.startComputation();
        try {
          tapHandler(e);
        } finally {
          _mithril2.default.endComputation();
        }
      }, holdHandler ? function () {
        return utils.autoredraw(holdHandler);
      } : null, repeatHandler, scrollX, scrollY, touchEndFeedback);
    }
  };
}

function computeTransformProp() {
  return 'transform' in document.body.style ? 'transform' : 'webkitTransform' in document.body.style ? 'webkitTransform' : 'mozTransform' in document.body.style ? 'mozTransform' : 'oTransform' in document.body.style ? 'oTransform' : 'msTransform';
}

function viewportDim() {
  if (cachedViewportDim) return cachedViewportDim;

  var e = document.documentElement;
  var vpd = cachedViewportDim = {
    vw: e.clientWidth,
    vh: e.clientHeight
  };
  return vpd;
}

// export default {
//   slidingPage: animator(viewSlideIn, viewSlideOut),
//   fadingPage: animator(viewFadesIn, viewFadesOut),
//   viewportDim,
//   clearCachedViewportDim() {
//     cachedViewportDim = null;
//   },

//   transformProp: function() {
//     if (!cachedTransformProp) cachedTransformProp = computeTransformProp();
//     return cachedTransformProp;
//   },

//   slidesInUp: function(el, isUpdate, context) {
//     if (!isUpdate) {
//       el.style.transform = 'translateY(100%)';
//       // force reflow back
//       context.lol = el.offsetHeight;
//       Zanimo(el, 'transform', 'translateY(0)', 250, 'ease-out')
//         .catch(console.log.bind(console));
//     }
//   },
//   slidesOutDown: function(callback, elID) {
//     return function() {
//       const el = document.getElementById(elID);
//       m.redraw.strategy('none');
//       return Zanimo(el, 'transform', 'translateY(100%)', 250, 'ease-out')
//         .then(utils.autoredraw.bind(null, callback))
//         .catch(callback);
//     };
//   },

//   fadesOut: function(callback, selector, time = 150) {
//     return function(e) {
//       e.stopPropagation();
//       var el = selector ? findParentBySelector(e.target, selector) : e.target;
//       m.redraw.strategy('none');
//       return Zanimo(el, 'opacity', 0, time)
//         .then(() => utils.autoredraw(callback))
//         .catch(console.log.bind(console));
//     };
//   },

//   ontouch: function(tapHandler, holdHandler, repeatHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, repeatHandler, false, false, touchEndFeedback);
//   },
//   ontouchX: function(tapHandler, holdHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, null, true, false, touchEndFeedback);
//   },
//   ontouchY: function(tapHandler, holdHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, null, false, true, touchEndFeedback);
//   },
//   classSet: function(classes) {
//     var arr = [];
//     for (var i in classes) {
//       if (classes[i]) arr.push(i);
//     }
//     return arr.join(' ');
//   },

//   isWideScreen: function() {
//     return viewportDim().vw >= 600;
//   },
//   isIpadLike: function() {
//     const { vh, vw } = viewportDim();
//     return vh >= 700 && vw <= 1050;
//   },
//   isPortrait: function() {
//     return window.matchMedia('(orientation: portrait)').matches;
//   },
//   isLandscape: function() {
//     return window.matchMedia('(orientation: landscape)').matches;
//   },
//   progress: function (p) {
//     if (p === 0) return null;
//     return m('span', {
//       className: 'progress ' + (p > 0 ? 'positive' : 'negative'),
//       'data-icon': p > 0 ? 'N' : 'M'
//     }, Math.abs(p));
//   }
// };

},{"../../utils":262,"../../utils/redraw":263,"./animator":207,"./button":208,"mithril":168,"zanimo":185}],210:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = homeCtrl;

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _xhr = require('../../xhr');

var _utils = require('../../utils');

var _appMode = require('../../utils/appMode');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function homeCtrl() {
  var nbConnectedPlayers = _mithril2.default.prop();
  var nbGamesInPlay = _mithril2.default.prop();

  function init() {
    if ((0, _appMode.isForeground)()) {
      (0, _xhr.lobby)(true).then(function (data) {
        _socket2.default.createLobby(data.lobby.version, _utils.noop, {
          n: function n(_, d) {
            nbConnectedPlayers(d.d);
            nbGamesInPlay(d.r);
            _mithril2.default.redraw();
          }
        });
      });
    }
  }

  function onResume() {
    (0, _appMode.setForeground)();
    init();
  }

  if ((0, _utils.hasNetwork)()) {
    init();
  }

  document.addEventListener('online', init);
  document.addEventListener('resume', onResume);

  return {
    nbConnectedPlayers: nbConnectedPlayers,
    nbGamesInPlay: nbGamesInPlay,
    onunload: function onunload() {
      _socket2.default.destroy();
      document.removeEventListener('online', init);
      document.removeEventListener('resume', onResume);
    }
  };
}

},{"../../socket":200,"../../utils":262,"../../utils/appMode":260,"../../xhr":264,"mithril":168}],211:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.body = body;

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _common = require('../shared/common');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function body(ctrl) {
  var nbPlayers = (0, _i18n2.default)('nbConnectedPlayers', ctrl.nbConnectedPlayers() || '?');
  var nbGames = (0, _i18n2.default)('nbGamesInPlay', ctrl.nbGamesInPlay() || '?');

  return h(
    'div',
    { className: 'native_scroller page' },
    h(
      'div',
      { className: 'home' },
      h(
        'section',
        { className: 'stats' },
        h(
          'div',
          { className: 'numPlayers' },
          nbPlayers
        ),
        h(
          'div',
          { className: 'numGames' },
          nbGames
        )
      ),
      renderQuickGame()
    )
  );

  // const header = headerWidget.bind(null, 'oyunkeyf.net');

  // return layout.free(header, body);
}

function renderQuickGame() {
  return h('div.homeCreate', [h('h2.homeTitle', 'Hemen oyna'), (0, _newGameForm.renderQuickSetup)(function () {
    return _newGameForm2.default.openRealtime('custom');
  })]);
}

},{"../../i18n":191,"../helper":209,"../layout":213,"../newGameForm":227,"../shared/common":248,"mithril":168,"mithril/hyperscript":167}],212:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stream = require('mithril/stream');

var _stream2 = _interopRequireDefault(_stream);

var _homeCtrl = require('./homeCtrl');

var _homeCtrl2 = _interopRequireDefault(_homeCtrl);

var _common = require('../shared/common');

var _homeView = require('./homeView');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit() {
    var nbConnectedPlayers = (0, _stream2.default)();
    var nbGamesInPlay = (0, _stream2.default)();

    this.ctrl = {
      nbConnectedPlayers: nbConnectedPlayers,
      nbGamesInPlay: nbGamesInPlay
    };
  },
  view: function view() {
    var header = (0, _common.dropShadowHeader)('oyunkeyf.net');

    return _layout2.default.free(header, (0, _homeView.body)(this.ctrl));
  }
};

},{"../layout":213,"../shared/common":248,"./homeCtrl":210,"./homeView":211,"mithril/stream":175}],213:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _menu = require('./menu');

var menu = _interopRequireWildcard(_menu);

var _menuView = require('./menu/menuView');

var _menuView2 = _interopRequireDefault(_menuView);

var _gamesMenu = require('./gamesMenu');

var _gamesMenu2 = _interopRequireDefault(_gamesMenu);

var _newGameForm = require('./newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _loginModal = require('./loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _signupModal = require('./signupModal');

var _signupModal2 = _interopRequireDefault(_signupModal);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var background;

exports.default = {

  free: function free(header, content, footer, overlay) {
    background = background || _settings2.default.general.theme.background();

    return (0, _hyperscript2.default)('div.view-container', { className: bgClass(background) }, [(0, _hyperscript2.default)('main#page', { oncreate: handleMenuOpen }, [(0, _hyperscript2.default)('header.main_header', header), (0, _hyperscript2.default)('div#free_content.content.native_scroller', content), footer ? (0, _hyperscript2.default)('footer.main_footer', footer) : null, (0, _hyperscript2.default)('div#menu-close-overlay.menu-backdrop', { oncreate: menu.backdropCloseHandler })]), (0, _hyperscript2.default)(_menuView2.default)]);
  }
};


function handleMenuOpen() {}

function bgClass(bgTheme) {
  return bgTheme === 'dark' || bgTheme === 'light' ? bgTheme : 'transp ' + bgTheme;
}

},{"../settings":198,"./gamesMenu":206,"./helper":209,"./loginModal":215,"./menu":225,"./menu/menuView":226,"./newGameForm":227,"./signupModal":255,"mithril/hyperscript":167}],214:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _xhr = require('../xhr');

var xhr = _interopRequireWildcard(_xhr);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var nbPlayers = 0;
var nbGames = 0;

var lobby = {};
lobby.isOpen = false;

lobby.startSeeking = function () {
  xhr.newGame().then(function (data) {
    // analytics
    _mithril2.default.route('/masa/' + data.id);
  }, function (error) {
    utils.handleXhrError(error);
    throw error;
  });
};

exports.default = lobby;

},{"../utils":262,"../xhr":264,"mithril":168}],215:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _signupModal = require('./signupModal');

var _signupModal2 = _interopRequireDefault(_signupModal);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var loginModal = {};

var isOpen = false;

function submit(form) {
  var login = form[0].value.trim();
  var pass = form[1].value;
  if (!login || !pass) return false;
  window.cordova.plugins.Keyboard.close();
  return _session2.default.login(login, pass).then(function () {
    loginModal.close();
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    // push.register();
    _session2.default.refresh().catch(function (err) {
      if (err.status === 401) {
        // https://github.com/veloce/lichobile/blob/master/project/src/js/ui/loginModal.js#L28
        window.navigator.notification.alert('oyunkeyfAuthenticationCannotWorkWithoutCookies');
      }
    });
  }).catch(utils.handleXhrError);
}

loginModal.open = function () {
  _backbutton2.default.stack.push(_helper2.default.slidesOutDown(loginModal.close, 'loginModal'));
  isOpen = true;
};

loginModal.close = function (fromBB) {
  window.cordova.plugins.Keyboard.close();
  if (fromBB !== 'backbutton' && isOpen) _backbutton2.default.stack.pop();
  isOpen = false;
};

loginModal.view = function () {
  if (!isOpen) return null;

  return (0, _mithril2.default)('div.modal#loginModal', { config: _helper2.default.slidesInUp }, [(0, _mithril2.default)('header', [(0, _mithril2.default)('button.modal_close[data-icon=L]', {
    config: _helper2.default.ontouch(_helper2.default.slidesOutDown(loginModal.close, 'loginModal'))
  }), (0, _mithril2.default)('h2', (0, _i18n2.default)('signIn'))]), (0, _mithril2.default)('div.modal_content', [(0, _mithril2.default)('form.login', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      return submit(e.target);
    }
  }, [(0, _mithril2.default)('input#pseudo[type=text]', {
    placeholder: (0, _i18n2.default)('username'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: 'false',
    required: true
  }), (0, _mithril2.default)('input#password[type=password]', {
    placeholder: (0, _i18n2.default)('password'),
    required: true
  }), (0, _mithril2.default)('button.fat', (0, _i18n2.default)('signIn'))]), (0, _mithril2.default)('div.signup', [(0, _mithril2.default)('a', {
    config: _helper2.default.ontouch(_signupModal2.default.open)
  }, [(0, _i18n2.default)('newToOyunkeyf'), ' ', (0, _i18n2.default)('signUp')])])])]);
};

exports.default = loginModal;

},{"../backbutton":189,"../i18n":191,"../session":197,"../utils":262,"./helper":209,"./signupModal":255,"mithril":168}],216:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _masaDetailCtrl = require('./masaDetailCtrl');

var _masaDetailCtrl2 = _interopRequireDefault(_masaDetailCtrl);

var _masaDetailView = require('./masaDetailView');

var _masaDetailView2 = _interopRequireDefault(_masaDetailView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _masaDetailCtrl2.default,
  view: _masaDetailView2.default
};

},{"./masaDetailCtrl":217,"./masaDetailView":218}],217:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _utils = require('../../../utils');

var utils = _interopRequireWildcard(_utils);

var _masaXhr = require('../masaXhr');

var xhr = _interopRequireWildcard(_masaXhr);

var _faq = require('../faq');

var _faq2 = _interopRequireDefault(_faq);

var _playerInfo = require('../playerInfo');

var _playerInfo2 = _interopRequireDefault(_playerInfo);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  var masa = _mithril2.default.prop();
  var hasJoined = _mithril2.default.prop(false);
  var isLoading = _mithril2.default.prop(false);
  var faqCtrl = _faq2.default.controller(masa);
  var playerInfoCtrl = _playerInfo2.default.controller(masa);

  function reload(data) {
    isLoading(false);
    var oldData = masa();
    masa(data);
    hasJoined(data.me && data.me.active);

    if (data.socketVersion) {
      _socket2.default.setVersion(data.socketVersion);
    }

    if (oldData.playerId !== data.playerId) {
      // reconnect with new playerId
      // TODO might miss redirect
      _socket2.default.connect();
    }
    _mithril2.default.redraw();
  }

  function join(id, side) {
    xhr.join(id, side).then(function () {
      hasJoined(true);
      _mithril2.default.redraw();
    }).catch(utils.handleXhrError);
  }

  function withdraw(id) {
    xhr.withdraw(id).then(function () {
      hasJoined(false);
      _mithril2.default.redraw();
    }).catch(utils.handleXhrError);
  }

  var id = _mithril2.default.route.param('id');

  var throttleReload = (0, _throttle2.default)(function (m) {
    isLoading(true);
    xhr.reload(m).then(reload).catch(function () {
      return isLoading(false);
    });
  }, 1000);

  var handlers = {
    reload: function reload() {
      return throttleReload(id);
    },
    resync: function resync() {
      return throttleReload(id);
    },
    redirect: function redirect(gameId) {
      _mithril2.default.route('/masa/' + masa().id + '/game/' + gameId, null, true);
    }
  };

  xhr.masa(id).then(function (data) {
    masa(data);
    hasJoined(data.me);
    _socket2.default.createMasa(id, masa().socketVersion, handlers);
  }).catch(utils.handleXhrError);

  return {
    masa: masa,
    hasJoined: hasJoined,
    faqCtrl: faqCtrl,
    playerInfoCtrl: playerInfoCtrl,
    join: (0, _throttle2.default)(join, 1000),
    withdraw: (0, _throttle2.default)(withdraw, 1000),
    isLoading: isLoading,
    onunload: function onunload() {
      _socket2.default.destroy();
    }
  };
}

},{"../../../socket":200,"../../../utils":262,"../faq":219,"../masaXhr":223,"../playerInfo":224,"lodash/throttle":162,"mithril":168}],218:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _mapValues = require('lodash/mapValues');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _common = require('../../shared/common');

var _session = require('../../../session');

var _session2 = _interopRequireDefault(_session);

var _layout = require('../../layout');

var _layout2 = _interopRequireDefault(_layout);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _faq = require('../faq');

var _faq2 = _interopRequireDefault(_faq);

var _helper = require('../../helper');

var _helper2 = _interopRequireDefault(_helper);

var _utils = require('../../../utils');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function view(ctrl) {
  var headerCtrl = _common.header.bind(null, null, (0, _common.backButton)(ctrl.masa() ? ctrl.masa().fullName : null));
  var body = masaBody.bind(null, ctrl);
  var footer = renderFooter.bind(null, ctrl);
  var faqOverlay = renderFAQOverlay.bind(null, ctrl);
  var overlay = function overlay() {
    return [faqOverlay()];
  };

  return _layout2.default.free(headerCtrl, body, footer, overlay);
};

function renderFAQOverlay(ctrl) {
  return [_faq2.default.view(ctrl.faqCtrl)];
}

function masaBody(ctrl) {
  var data = ctrl.masa();
  if (!data) return null;

  var body = void 0;
  if (data.isFinished) {
    body = masaContentFinished(ctrl);
  } else if (!data.isStarted) {
    body = masaContentCreated(ctrl);
  } else {
    body = masaContentStarted(ctrl);
  }

  return h(
    'div',
    { 'class': 'masaContainer native_scroller page withFooter' },
    body
  );
}

function masaContentFinished(ctrl) {
  var data = ctrl.masa();
  return [masaHeader(data, data.roundsToFinish, ''), data.podium ? masaPodium(data.podium.map(function (p) {
    return (0, _merge2.default)(p, data.players[p.id]);
  })) : null, masaLeaderboard(ctrl)];
}

function currentGames(data) {
  var ids = {
    created: 10,
    started: 20,
    aborted: 25,
    middleEnd: 30,
    normalEnd: 40,
    variantEnd: 70
  };
  return data.pairings.filter(function (p) {
    return p.s < ids.aborted;
  });
}

function myCurrentGameId(data) {
  var playerId = data.playerId;
  if (!playerId) return null;

  var pairing = currentGames(data).filter(function (p) {
    return p.u.filter(function (id) {
      return id.toLowerCase() === playerId.toLowerCase();
    })[0];
  })[0];

  return pairing ? pairing.id : null;
}

function masaContentStarted(ctrl) {
  var data = ctrl.masa();
  var gameId = myCurrentGameId(data);
  var playings = currentGames(data);
  var currentGameId = playings[0] ? playings[0].id : null;
  return [masaHeader(data, data.roundsToFinish, ''), gameId ? (0, _mithril2.default)('a.pov.button.glowed', {
    config: _helper2.default.ontouch(_mithril2.default.route.bind(null, '/masa/' + data.id + '/game/' + gameId))
  }, [(0, _i18n2.default)('youArePlaying'), (0, _mithril2.default)('span.text[data-icon=G]', (0, _i18n2.default)('joinTheGame'))]) : currentGameId ? (0, _mithril2.default)('a.pov.spectator.button', {
    config: _helper2.default.ontouch(_mithril2.default.route.bind(null, '/masa/' + data.id + '/game/' + currentGameId))
  }, [(0, _i18n2.default)('playingRightNow'), (0, _mithril2.default)('span.text[data-icon=G]', (0, _i18n2.default)('spectateGame'))]) : null, masaLeaderboard(ctrl)];
}

function masaContentCreated(ctrl) {
  var data = ctrl.masa();
  return [masaHeader(data, data.roundsToFinish, ''), masaSeats(ctrl), masaLeaderboard(ctrl)];
}

function masaHeader(data, rounds, roundsText) {
  var variant = variantDisplay(data);
  var control = (0, _i18n2.default)('rated');
  var handS = (0, _i18n2.default)('hands');
  var roundString = data.rounds ? data.nbRounds + '/' + data.rounds + handS : data.scores + 'P';

  return h(
    'div',
    { key: 'header', className: 'masaHeader' },
    h(
      'div',
      { className: 'masaInfoRounds' },
      h(
        'strong',
        { className: 'masaInfo', 'data-icon': (0, _utils.gameIcon)(variantKey(data)) },
        variant + '  ' + control + '  ' + roundString
      )
    ),
    h(
      'div',
      { className: 'masaCreatorInfo' },
      (0, _i18n2.default)('by', formatCreatedBy(data)),
      '\xA0\u2022\xA0',
      window.moment(data.createdAt).calendar()
    )
  );
}

function masaSeats(ctrl) {
  var data = ctrl.masa();
  var players = data.players;
  var actives = (0, _mapValues2.default)(data.actives, function (p) {
    return players[p.id];
  });
  var me = data.me ? data.me.side : '';
  return h(
    'div',
    { key: 'seats', className: 'masaSeats' },
    masaSeat(ctrl, 'north', actives.north, me),
    h(
      'div',
      { className: 'middle' },
      masaSeat(ctrl, 'west', actives.west, me),
      h('div', { className: 'table' }),
      masaSeat(ctrl, 'east', actives.east, me)
    ),
    masaSeat(ctrl, 'south', actives.south, me)
  );
}

function getPlayerName(p) {
  return p.ai ? (0, _i18n2.default)('aiBot', p.ai) : p.name ? p.name : (0, _i18n2.default)('anonymous');
}

function masaSeat(ctrl, side, p, me) {
  var playerName = p ? getPlayerName(p) : '';
  var classes = ' in' + (p ? '' : ' empty') + (me === side[0] ? ' me' : '');
  return h(
    'div',
    { className: "masaSeat" + classes },
    playerName ? h(
      'span',
      { className: 'title' },
      playerName
    ) : joinButton(ctrl, '', side)
  );
}

function masaLeaderboard(ctrl) {
  var data = ctrl.masa();
  var players = data.standing.players.map(function (p) {
    return (0, _merge2.default)(p, data.players[p.id]);
  });
  var user = _session2.default.get();
  var userName = user ? user.username : '';

  return h(
    'div',
    { key: 'leaderboard', className: 'masaLeaderboard' },
    h(
      'p',
      { className: 'masaTitle' },
      ' ',
      (0, _i18n2.default)('leaderboard'),
      ' (',
      (0, _i18n2.default)('nbPlayers', data.nbPlayers),
      ')'
    ),
    h(
      'table',
      { className: 'masaStandings' },
      players.map(renderLeaderboardItem.bind(null, ctrl.playerInfoCtrl, userName, data.playerId))
    )
  );
}

function masaPairings(ctrl) {
  return h(
    'div',
    { key: 'pairings', className: 'masaPairings' },
    h(
      'p',
      { className: 'masaTitle' },
      ' ',
      (0, _i18n2.default)('rounds')
    ),
    h('table', { className: 'masaPairings' })
  );
}

function renderLeaderboardItem(playerInfoCtrl, userName, playerId, player) {
  var isMe = player.id === playerId;
  var playerName = player.name || getPlayerName(player);
  var playerRating = player.rating ? ' (' + player.rating + ') ' : '';
  var playerWithRating = playerName + playerRating;

  return h(
    'tr',
    { key: player.name, className: 'list_item' + (isMe ? ' me' : ''), config: _helper2.default.ontouchY(playerInfoCtrl.open.bind(null, player)) },
    h(
      'td',
      { className: 'masaPlayer' },
      h(
        'span',
        { className: 'flagRank', 'data-icon': player.active ? '' : 'b' },
        player.active ? player.rank + '. ' : ''
      ),
      h(
        'span',
        null,
        ' ',
        playerWithRating,
        ' '
      )
    ),
    h(
      'td',
      { className: 'masaPoints' },
      h(
        'span',
        { 'data-icon': 'Q' },
        player.score
      )
    )
  );
}

function masaPodium(podium) {
  return h(
    'div',
    { key: 'podium', className: 'podium' },
    renderPlace(podium[0])
  );
}

function renderPlace(data) {
  if (!data) return null;

  var rank = data.rank;
  return h(
    'div',
    { className: 'place' + rank },
    h('div', { className: 'trophy' }),
    h(
      'div',
      { className: 'username', config: data.name ? _helper2.default.ontouch(function () {
          return _mithril2.default.route('/@/' + data.name);
        }) : null },
      getPlayerName(data)
    ),
    data.rating ? h(
      'div',
      { className: 'rating' },
      ' ',
      data.rating,
      ' ',
      _helper2.default.progress(data.ratingDiff),
      ' '
    ) : null,
    h('table', { className: 'stats' })
  );
}

function renderFooter(ctrl) {
  if (!ctrl.masa()) {
    return null;
  }

  return h(
    'div',
    { className: 'actions_bar' },
    h(
      'button',
      { key: 'faq', className: 'action_bar_button', config: _helper2.default.ontouch(ctrl.faqCtrl.open) },
      h('span', { className: 'fa fa-question-circle' }),
      (0, _i18n2.default)('faq')
    ),
    ctrl.hasJoined() ? withdrawButton(ctrl) : joinButton(ctrl, "action_bar_button")
  );
}

function joinButton(ctrl, klass, side) {
  //if (!session.isConnected() || ctrl.masa().isFinished) {
  if (ctrl.masa().isFinished) {
    return null;
  }

  klass = klass || "";

  return h(
    'button',
    { key: 'join', className: klass, config: _helper2.default.ontouch(function () {
        return ctrl.join(ctrl.masa().id, side);
      }) },
    h('span', { className: 'fa fa-play' }),
    (0, _i18n2.default)('join')
  );
}

function withdrawButton(ctrl) {
  // if (!session.isConnected() || ctrl.masa().isFinished) {
  if (ctrl.masa().isFinished) {
    return null;
  }

  return h(
    'button',
    { key: 'withdraw', className: 'action_bar_button', config: _helper2.default.ontouch(function () {
        return ctrl.withdraw(ctrl.masa().id);
      }) },
    h('span', { className: 'fa fa-flag' }),
    (0, _i18n2.default)('withdraw')
  );
}

function variantDisplay(data) {
  var variant = variantKey(data);
  // variant = variant.split(' ')[0]; // Cut off names to first word

  // if (variant.length > 0) {
  //   variant = variant.charAt(0).toUpperCase() + variant.substring(1);
  // }

  return (0, _i18n2.default)(variant);
}

function variantKey(data) {
  var variant = data.variant;
  return variant;
}

function formatCreatedBy(data) {
  var player = data.players[data.createdBy];

  return player ? player.name ? player.name : (0, _i18n2.default)('anonymous') : data.createdBy;
}

},{"../../../i18n":191,"../../../session":197,"../../../utils":262,"../../helper":209,"../../layout":213,"../../shared/common":248,"../faq":219,"lodash/mapValues":154,"lodash/merge":156,"mithril":168,"mithril/hyperscript":167}],219:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: function controller(masa) {
    var _isOpen = false;

    function open() {
      _backbutton2.default.stack.push(close);
      _isOpen = true;
    }
    function close(fromBB) {
      if (fromBB !== 'backbutton' && _isOpen) _backbutton2.default.stack.pop();
      _isOpen = false;
    }

    return {
      open: open,
      close: close,
      isOpen: function isOpen() {
        return _isOpen;
      },
      masa: masa
    };
  },
  view: function view(ctrl) {
    if (!ctrl.isOpen()) return null;
    var masa = ctrl.masa();

    if (!masa) return null;

    return h(
      'div',
      { className: 'modal', id: 'masaFaqModal', config: _helper2.default.slidesInUp },
      h(
        'header',
        null,
        h('button', { className: 'modal_close', 'data-icon': 'L',
          config: _helper2.default.ontouch(_helper2.default.slidesOutDown(ctrl.close, "masaFaqModal")) }),
        h(
          'h2',
          null,
          (0, _i18n2.default)('masaFAQ')
        )
      ),
      h(
        'div',
        { className: 'modal_content' },
        h(
          'div',
          { className: 'masaFaq' },
          h(
            'h2',
            null,
            'Puanl\u0131 m\u0131?'
          ),
          masa.rated === undefined ? 'Baz masalar puanldr ve reytinginizi etkiler.' : masa.rated ? 'Bu masa puanldr ve reytinginizi etkiler.' : 'Bu masa puanl *deildir* ve reytinginizi *etkilemez*.',
          h(
            'h2',
            null,
            ' Puanlar nas\u0131l hesaplan\u0131r? '
          ),
          'Masaya kat\u0131l\u0131mda her oyuncu ortaya el say\u0131s\u0131 kadar puan\u0131n\u0131 koyar. Masa sonunda ortadaki puanlar \u015F\xF6yle da\u011F\u0131t\u0131l\u0131r:',
          h(
            'ul',
            null,
            h(
              'li',
              null,
              '1. %50 puan'
            ),
            h(
              'li',
              null,
              '2. %25 puan'
            ),
            h(
              'li',
              null,
              '3. %15 puan'
            ),
            h(
              'li',
              null,
              '4. %10 puan'
            )
          ),
          '\xD6rne\u011Fin 10 ellik bir oyunda oyuncular\u0131n puanlar\u0131 1500 olsun. Masaya kat\u0131ld\u0131klar\u0131nda puanlar\u0131 1490 olur. Ortada toplam 40 puan vard\u0131r, ve \u015F\xF6yle da\u011F\u0131t\u0131l\u0131r:',
          h(
            'ul',
            null,
            h(
              'li',
              null,
              '1. +20 = 1510'
            ),
            h(
              'li',
              null,
              '2. +10 = 1500'
            ),
            h(
              'li',
              null,
              '3. +6 = 1496'
            ),
            h(
              'li',
              null,
              '4. +4 = 1494'
            )
          ),
          'Masa bitmeden ayr\u0131lan oyuncu puan alamaz.',
          h(
            'h2',
            null,
            ' Kazanan nas\u0131l belirlenir? '
          ),
          'Masada b\xFCt\xFCn eller oynand\u0131ktan sonra en az cezas\u0131 olan oyuncu galip ilan edilir.',
          h(
            'h2',
            null,
            ' Masada eslestirme nasil yapilir? '
          ),
          'Masaya 4 oyuncu katildiginda el baslar. Bir el bittikten sonra yeni el baslar, yeni ele katilmak icin oyuncular masaya geri donmelidir.',
          h(
            'h2',
            null,
            ' Masa ne zaman biter? '
          ),
          'Masada el say\u0131s\u0131 kadar oyun oynand\u0131\u011F\u0131nda masa biter.',
          h(
            'h2',
            null,
            ' Oyundan ayr\u0131lma '
          ),
          'Oyun devam ederken oyundan ayrilan oyuncu masadan atilir, ve o el iptal olur. Masa bitmeden masadan ayr\u0131lan oyuncu puan alamaz.',
          h(
            'h2',
            null,
            ' Di\u011Fer \xF6nemli kurallar '
          ),
          'Siraniz geldiginde, oyanama s\xFCrenizi a\u015Farsan\u0131z sistem sizin yerinize oynar.'
        )
      )
    );
  }
};

},{"../../backbutton":189,"../../i18n":191,"../helper":209,"mithril/hyperscript":167}],220:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _masaCtrl = require('./masaCtrl');

var _masaCtrl2 = _interopRequireDefault(_masaCtrl);

var _masaView = require('./masaView');

var _masaView2 = _interopRequireDefault(_masaView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _masaCtrl2.default,
  view: _masaView2.default
};

},{"./masaCtrl":221,"./masaView":222}],221:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _masaXhr = require('./masaXhr');

var xhr = _interopRequireWildcard(_masaXhr);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {

  var masas = _mithril2.default.prop();
  var currentTab = _mithril2.default.prop(_mithril2.default.route.param('tab') || 'created');

  function _reload(data) {
    data.started = data.started.filter(supported);
    data.created = data.created.filter(supported);
    data.finished = data.finished.filter(supported);
    masas(data);
    return data;
  }

  var handlers = {
    reload: function reload(data) {
      _reload(data);_mithril2.default.redraw();
    }
  };

  _socket2.default.createMasaHome(handlers);

  var refresh = (0, _throttle2.default)(function () {
    xhr.currentMasas().then(_reload).catch(utils.handleXhrError);
  }, 1000);

  refresh();

  return {
    masas: masas,
    currentTab: currentTab,
    refresh: refresh
  };
}

function supported(t) {
  return _session2.default.isConnected() || !t.rated && !t.mOnly;
}

},{"../../session":197,"../../socket":200,"../../utils":262,"../helper":209,"./masaXhr":223,"lodash/throttle":162,"mithril":168}],222:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _common = require('../shared/common');

var _utils = require('../../utils');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _tabs = require('../shared/tabs');

var _tabs2 = _interopRequireDefault(_tabs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function view(ctrl) {
  var bodyCtrl = masaListBody.bind(null, ctrl);

  return _layout2.default.free(_common.header.bind(null, (0, _i18n2.default)('masas')), bodyCtrl);
}

var TABS = function TABS(i18n) {
  return [{
    key: 'started',
    label: i18n('inProgressTables')
  }, {
    key: 'created',
    label: i18n('openTables')
  }, {
    key: 'finished',
    label: i18n('completed')
  }];
};

function tabNavigation(currentTabFn) {
  return (0, _mithril2.default)('.nav-header', _mithril2.default.component(_tabs2.default, {
    buttons: TABS(_i18n2.default),
    selectedTab: currentTabFn(),
    onTabChange: function onTabChange(k) {
      var loc = window.location.search.replace(/\?tab\=\w+$/, '');
      window.history.replaceState(null, null, loc + '?tab=' + k);
      currentTabFn(k);
    }
  }));
}

function masaListBody(ctrl) {
  if (!ctrl.masas()) return null;
  var tabContent = ctrl.masas()[ctrl.currentTab()];

  return (0, _mithril2.default)('.module-tabs.tabs-routing', [tabNavigation(ctrl.currentTab), (0, _mithril2.default)('.tab-content.layout.center-center.native_scroller', renderMasaList(tabContent, ctrl.currentTab(), ctrl.refresh))]);
}

function renderMasaList(list, id, onRefresh) {
  return list.length ? (0, _helper2.default)(
    'table',
    { key: id, className: 'masaList' },
    list.map(renderMasaListItem)
  ) : (0, _helper2.default)(
    'div',
    { className: 'vertical_align empty_masas_list' },
    (0, _helper2.default)(
      'div',
      null,
      (0, _i18n2.default)('nothingHere')
    ),
    (0, _helper2.default)(
      'button',
      { id: 'refreshButton', config: _helper2.default.ontouchY(onRefresh) },
      (0, _helper2.default)('span', { className: 'fa fa-refresh' }),
      (0, _i18n2.default)('refresh')
    )
  );
}

function renderMasaListItem(masa) {
  var mode = masa.rated ? (0, _i18n2.default)('rated') : (0, _i18n2.default)('casual');
  var duration = (0, _utils.formatMasaDuration)(masa.rounds, masa.scores);
  var variant = (0, _utils.capitalize)(masa.variant.short);

  return (0, _helper2.default)(
    'tr',
    { key: masa.id,
      className: 'list_item masa_item',
      config: _helper2.default.ontouchY(function () {
        return _mithril2.default.route('/masa/' + masa.id);
      }) },
    (0, _helper2.default)(
      'td',
      { className: 'masaListName', 'data-icon': masa.perf ? masa.perf.icon : '8' },
      (0, _helper2.default)(
        'div',
        { className: 'fullName' },
        masa.fullName
      ),
      (0, _helper2.default)(
        'small',
        { className: 'infos' },
        ' ',
        variant,
        ' ',
        mode,
        ' \u2022 ',
        duration,
        ' '
      )
    ),
    (0, _helper2.default)(
      'td',
      { className: 'masaListTime' },
      (0, _helper2.default)(
        'div',
        { className: 'time' },
        formatTime(masa.createdAt)
      ),
      (0, _helper2.default)(
        'small',
        { className: 'nbUsers withIcon', 'data-icon': 'r' },
        masa.nbPlayers
      )
    ),
    (0, _helper2.default)(
      'td',
      { className: 'masaListNav' },
      '\uF054'
    )
  );
}

function formatTime(timeInMillis) {
  var date = new Date(timeInMillis);
  var hours = (0, _utils.pad)(date.getHours().toString(), 2);
  var mins = (0, _utils.pad)(date.getMinutes().toString(), 2);
  return hours + ':' + mins;
}

},{"../../i18n":191,"../../utils":262,"../helper":209,"../layout":213,"../shared/common":248,"../shared/tabs":254,"mithril":168,"mithril/hyperscript":167}],223:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.currentMasas = currentMasas;
exports.masa = masa;
exports.reload = reload;
exports.join = join;
exports.withdraw = withdraw;

var _http = require('../../http');

function currentMasas() {
  return (0, _http.request)('/masa', {}, true);
}

function masa(id) {
  return (0, _http.request)('/masa/' + id, { data: { socketVersion: 1 } }, true);
}

function reload(id) {
  return (0, _http.request)('/masa/' + id, {
    method: 'GET',
    data: {},
    background: true
  });
}

function join(id, side) {
  side = side ? '?side=' + side : '';
  return (0, _http.request)('/masa/' + id + '/join' + side, { method: 'POST' }, true);
}

function withdraw(id) {
  return (0, _http.request)('/masa/' + id + '/withdraw', { method: 'POST' }, true);
}

},{"../../http":190}],224:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: function controller(masa) {
    var _isOpen = false;
    var playerData = _mithril2.default.prop();

    function open() {
      _backbutton2.default.stack.push(close);
      _isOpen = true;
    }
    function close(fromBB) {
      if (fromBB !== 'backbutton' && _isOpen) _backbutton2.default.stack.pop();
      _isOpen = false;
    }

    return {
      open: open,
      close: close,
      isOpen: function isOpen() {
        return _isOpen;
      },
      masa: masa
    };
  },
  view: function view(ctrl) {}
};

},{"../../backbutton":189,"../helper":209,"mithril":168}],225:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backdropCloseHandler = exports.mainMenuCtrl = exports.profileMenuOpen = undefined;
exports.route = route;

var _stream = require('mithril/stream');

var _stream2 = _interopRequireDefault(_stream);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _SideMenuCtrl = require('../shared/sideMenu/SideMenuCtrl');

var _SideMenuCtrl2 = _interopRequireDefault(_SideMenuCtrl);

var _helper = require('../helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var profileMenuOpen = exports.profileMenuOpen = (0, _stream2.default)(false);

function onMenuOpen() {}

function onMenuClose() {}

var mainMenuCtrl = exports.mainMenuCtrl = new _SideMenuCtrl2.default('left', 'side_menu', 'menu-close-overlay', onMenuOpen, onMenuClose);

function route(route) {
  return function () {
    return mainMenuCtrl.close().then(function () {
      return router.set(route);
    });
  };
}

var backdropCloseHandler = exports.backdropCloseHandler = (0, _helper.ontap)(function () {
  mainMenuCtrl.close();
});

var menu = {};

/* properties */
menu.isOpen = false;
// menu.headerOpen = m.prop(false);

menu.route = function (route) {
  return function () {
    return menu.close().then(_mithril2.default.route.bind(null, route));
  };
};

menu.popup = function (action) {
  return function () {
    return menu.close().then(function () {
      action();
      _mithril2.default.redraw();
    });
  };
};

menu.toggle = function () {
  if (menu.isOpen) menu.close();else menu.open();
};

menu.open = function () {
  _backbutton2.default.stack.push(menu.close);
  menu.isOpen = true;
};

menu.willClose = false;
menu.close = function (fromBB) {
  var sideMenu = document.getElementById('side_menu');

  if (menu.willClose || !sideMenu) return Promise.resolve(null);

  menu.willClose = true;
  if (fromBB !== 'backbutton' && menu.isOpen) _backbutton2.default.stack.pop();
  _mithril2.default.redraw.strategy('none');
  return (0, _zanimo2.default)(sideMenu, 'transform', 'translate3d(-100%,0,0', 250, 'ease-out').then(function () {
    menu.headerOpen(false);
    menu.isOpen = false;
    menu.willClose = false;
    _mithril2.default.redraw();
  }).catch(function (err) {
    console.error(err);
    menu.headerOpen(false);
    menu.isOpen = false;
    menu.willClose = false;
    _mithril2.default.redraw();
  });
};

menu.toggleHeader = function () {
  return menu.headerOpen() ? menu.headerOpen(false) : menu.headerOpen(true);
};

exports.default = menu;

},{"../../backbutton":189,"../helper":209,"../shared/sideMenu/SideMenuCtrl":252,"mithril":168,"mithril/stream":175,"zanimo":185}],226:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _loginModal = require('../loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _utils = require('../../utils');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _ = require('.');

var menu = _interopRequireWildcard(_);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  onbeforeupdate: function onbeforeupdate() {
    return menu.mainMenuCtrl.isOpen;
  },
  view: function view() {
    var user = _session2.default.get();

    return h(
      'aside',
      { id: 'side_menu' },
      renderHeader(),
      h(
        'div',
        { className: 'native_scroller side_menu_scroller' },
        user && menu.profileMenuOpen() ? renderProfileActions(user) : renderLinks(user)
      )
    );
  }
};


function renderHeader(user) {
  var profileLink = user ? menu.route('/@/' + user.id) : _utils.noop;

  return h(
    'header',
    { className: 'side_menu_header' },
    h(
      'button',
      { className: 'signInButton' },
      (0, _i18n2.default)('signIn')
    )
  );
}

function slidesInUp(el, isUpdate, context) {
  if (!isUpdate) {
    el.style.transform = 'translate3d(-100%, 0, 0)';
    // force reflow back
    context.lol = el.offsetHeight;
    (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out');
  }
}

function renderProfileActionsOLD(user) {
  return h(
    'ul',
    { className: 'side_links profileActions' },
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(menu.route('/@/' + user.id)) },
      h('span', { className: 'fa fa-user' }),
      (0, _i18n2.default)('profile')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(menu.route('/settings/preferences')) },
      h('span', { 'data-icon': '%' }),
      (0, _i18n2.default)('preferences')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(function () {
          _session2.default.logout();
          menu.profileMenuOpen(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

function renderLinks(user) {

  return h(
    'ul',
    { className: 'side_links' },
    h(
      'li',
      { className: 'side_link', key: 'home', config: helper.ontapXY(menu.route('/')) },
      h('span', { className: 'fa fa-home' }),
      (0, _i18n2.default)('home')
    ),
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'sep_link', key: 'sep_link_online' },
      (0, _i18n2.default)('playOnline')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-popup': 'createAGame' },
      h('span', { className: 'fa fa-plus-circle' }),
      (0, _i18n2.default)('createAGame')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/masas' },
      h('span', { className: 'fa fa-trophy' }),
      (0, _i18n2.default)('masas')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/players' },
      h('span', { className: 'fa fa-at' }),
      (0, _i18n2.default)('players')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/ranking' },
      h('span', { className: 'fa fa-cubes' }),
      (0, _i18n2.default)('leaderboard')
    ) : null,
    h('li', { className: 'hr' }),
    h(
      'li',
      { className: 'side_link', 'data-route': '/settings' },
      h('span', { className: 'fa fa-cog' }),
      (0, _i18n2.default)('settings')
    )
  );
}

// OLD

function renderProfileActionsOLD(user) {
  return h(
    'ul',
    { className: 'side_links profileActions' },
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(menu.route('/@/' + user.id)) },
      h('span', { 'data-icon': 'r' }),
      (0, _i18n2.default)('profile')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(menu.route('/settings/preferences')) },
      h('span', { 'data-icon': '%' }),
      (0, _i18n2.default)('preferences')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(function () {
          _session2.default.logout();
          menu.headerOpen(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

function renderLinksOLD(user) {

  return h(
    'ul',
    { className: 'side_links' },
    h(
      'li',
      { className: 'side_link', key: 'home', config: helper.ontouchY(menu.route('/')) },
      h('span', { className: 'fa fa-home' }),
      (0, _i18n2.default)('home')
    ),
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'sep_link', key: 'sep_link_online' },
      (0, _i18n2.default)('playOnline')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', key: 'play_real_time', config: helper.ontouchY(menu.popup(_newGameForm2.default.openRealtime)) },
      h('span', { className: 'fa fa-plus-circle' }),
      (0, _i18n2.default)('createAGame')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', key: 'masas', config: helper.ontouchY(menu.route('/masa')) },
      h('span', { className: 'fa fa-trophy' }),
      (0, _i18n2.default)('masas')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'sep_link', key: 'sep_link_community' },
      (0, _i18n2.default)('community')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', key: 'players', config: helper.ontouchY(menu.route('/players')) },
      h('span', { className: 'fa fa-at' }),
      (0, _i18n2.default)('players')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', key: 'ranking' },
      h('span', { className: 'fa fa-cubes' }),
      (0, _i18n2.default)('leaderboard')
    ) : null,
    h('li', { className: 'hr', key: 'set_link_settings' }),
    h(
      'li',
      { className: 'side_link', key: 'settings', config: helper.ontouchY(menu.route('/settings')) },
      h('span', { className: 'fa fa-cog' }),
      (0, _i18n2.default)('settings')
    )
  );
}

function renderMenu() {
  var user = _session2.default.get();
  return h(
    'div',
    { className: 'native_scroller' },
    renderHeader(user),
    user && menu.headerOpen() ? renderProfileActions(user) : renderLinks(user)
  );
}

},{".":225,"../../i18n":191,"../../session":197,"../../utils":262,"../helper":209,"../loginModal":215,"../newGameForm":227,"mithril/hyperscript":167,"zanimo":185}],227:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderQuickSetup = renderQuickSetup;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _popup = require('./shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _form = require('./shared/form');

var _form2 = _interopRequireDefault(_form);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _xhr = require('../xhr');

var xhr = _interopRequireWildcard(_xhr);

var _lobby = require('./lobby');

var _lobby2 = _interopRequireDefault(_lobby);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderQuickSetup() {
  return (0, _hyperscript2.default)('div.newGame-pools', { key: 'quickSetup' }, xhr.cachedPools.map(function (p) {
    return renderPool(p);
  }));
}

function renderPool(p) {
  return (0, _hyperscript2.default)('div.newGame-pool', {
    key: 'pool-' + p.id,
    oncreate: helper.ontap(function () {
      console.log('oncreate');
    })
  }, [(0, _hyperscript2.default)('div.newGame-rounds', p.id), (0, _hyperscript2.default)('div.newGame-perf', p.perf)]);
}

var newGameForm = {};

newGameForm.isOpen = false;

newGameForm.open = function () {
  _backbutton2.default.stack.push(newGameForm.close);
  newGameForm.isOpen = true;
};

newGameForm.close = function (fromBB) {
  if (fromBB !== 'backbutton' && newGameForm.isOpen) _backbutton2.default.stack.pop();
  newGameForm.isOpen = false;
};

newGameForm.openRealtime = function () {
  newGameForm.open();
};

function seekHumanGame() {
  newGameForm.close();
  _lobby2.default.startSeeking();
}

function renderForm(formName, action, settingsObj, variants) {
  var generalFieldset = [(0, _mithril2.default)('div.select_input', {
    key: formName + 'variant'
  }, [_form2.default.renderSelect('variant', formName + ' variant', variants, settingsObj.variant)])];

  // Human only
  if (settingsObj.mode) {
    var modes = _session2.default.isConnected() ? [['casual', '0'], ['rated', '1']] : [['casual', '0']];

    generalFieldset.push((0, _mithril2.default)('div.select_input', {
      key: formName + 'mode'
    }, [_form2.default.renderSelect('mode', formName + 'mode', modes, settingsObj.mode)]));

    if (_session2.default.isConnected() && settingsObj.mode() === '0') {
      generalFieldset.push(_form2.default.renderCheckbox((0, _i18n2.default)('membersOnly'), 'membersOnly', settingsObj.membersOnly));
    }
  }

  // both human
  var roundFieldset = [
    // m('div.select_input', {
    //   key: formName + 'rounds'
    // }, [
    //   formWidgets.renderSelect('round', formName + 'rounds', roundModes, settingsObj.roundMode)
    // ])
  ];

  if (true) {
    roundFieldset.push((0, _mithril2.default)('div.select_input', {
      key: formName + 'rounds'
    }, [_form2.default.renderSelect('rounds', formName + 'round', _settings2.default.gameSetup.availableRounds, settingsObj.rounds, false)]));
  }

  return (0, _mithril2.default)('form#new_game_form.game_form', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      if (!_settings2.default.gameSetup.isRoundValid(settingsObj)) return;
      newGameForm.close();
      action();
    }
  }, [(0, _mithril2.default)('fieldset', []), (0, _mithril2.default)('fieldset', generalFieldset), (0, _mithril2.default)('fieldset#round', roundFieldset), (0, _mithril2.default)('button[data-icon=E][type=submit].newGameButton', (0, _i18n2.default)('createAGame'))]);
}

newGameForm.view = function () {
  function form() {
    return renderForm('human', seekHumanGame, _settings2.default.gameSetup.human, _settings2.default.gameSetup.human.availableVariants);
  };

  return (0, _popup2.default)('new_game_form_popup game_form_popup', null, form, newGameForm.isOpen, newGameForm.close);
};

exports.default = newGameForm;

},{"../backbutton":189,"../i18n":191,"../session":197,"../settings":198,"../xhr":264,"./lobby":214,"./shared/form":249,"./shared/popup":251,"mithril":168,"mithril/hyperscript":167}],228:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _playersCtrl = require('./playersCtrl');

var _playersCtrl2 = _interopRequireDefault(_playersCtrl);

var _playersView = require('./playersView');

var _playersView2 = _interopRequireDefault(_playersView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _playersCtrl2.default,
  view: _playersView2.default
};

},{"./playersCtrl":230,"./playersView":231}],229:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onlinePlayers = onlinePlayers;

var _http = require('../../http');

function onlinePlayers() {
  return (0, _http.request)('/player/online', {}, true);
}

},{"../../http":190}],230:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _playerXhr = require('./playerXhr');

var xhr = _interopRequireWildcard(_playerXhr);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  _socket2.default.createDefault();

  var players = _mithril2.default.prop([]);

  xhr.onlinePlayers().then(players, function (err) {
    return utils.handleXhrError(err);
  });

  return {
    players: players,
    goToProfile: function goToProfile(u) {
      _mithril2.default.route('/@/' + u);
    },

    onunload: function onunload() {}
  };
}

},{"../../socket":200,"../../utils":262,"./playerXhr":229,"mithril":168}],231:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _common = require('../shared/common');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function view(ctrl) {

  var headerCtrl = header.bind(null, ctrl);
  var bodyCtrl = body.bind(null, ctrl);

  return _layout2.default.free(headerCtrl, bodyCtrl, null);
}

function header(ctrl) {
  return (0, _helper2.default)(
    'nav',
    null,
    (0, _common.menuButton)(),
    (0, _helper2.default)(
      'h1',
      null,
      (0, _i18n2.default)('players')
    ),
    (0, _helper2.default)(
      'div',
      { className: 'buttons' },
      (0, _helper2.default)('button', { className: 'main_header_button', key: 'searchPlayers', 'data-icon': 'y' })
    )
  );
}

function body(ctrl) {
  return (0, _helper2.default)(
    'ul',
    { className: 'playersSuggestion native_scroller_page' },
    ctrl.players().map(renderPlayer)
  );
}

function renderPlayer(user) {
  // find best perf
  var perf = Object.keys(user.perfs).reduce(function (prev, curr) {
    if (!prev) return curr;
    if (user.perfs[prev].rating < user.perfs[curr].rating) return curr;else return prev;
  });

  return (0, _helper2.default)(
    'li',
    { className: 'list_item playerSuggestion nav', config: _helper2.default.ontouchY(function () {
        return _mithril2.default.route('/@/' + user.id);
      }) },
    (0, _common.userStatus)(user),
    (0, _helper2.default)(
      'span',
      { className: 'rating', 'data-icon': utils.gameIcon(perf) },
      user.perfs[perf].rating
    )
  );
}

},{"../../i18n":191,"../../utils":262,"../helper":209,"../layout":213,"../shared/common":248,"mithril":168,"mithril/hyperscript":167}],232:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _storage = require('../../storage');

var _storage2 = _interopRequireDefault(_storage);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _game = require('../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: function controller(root) {
    var _this = this;

    var storageId = 'chat.' + root.data.game.id;

    var chatHeight = void 0;

    this.root = root;
    this.showing = false;
    this.messages = root.data.chat || [];
    this.inputValue = '';
    this.unread = false;

    var checkUnreadFromStorage = function checkUnreadFromStorage() {
      var nbMessages = _storage2.default.get(storageId);
      if (_this.messages && nbMessages < _this.messages.length) _this.unread = true;
    };
    checkUnreadFromStorage();
    _storage2.default.set(storageId, this.messages.length);

    this.open = function () {
      _backbutton2.default.stack.push(_helper2.default.slidesOutDown(_this.close, 'chat'));
      _this.showing = true;
    };

    this.close = function (fromBB) {
      window.cordova.plugins.Keyboard.close();
      if (fromBB !== 'backbutton' && _this.showing) _backbutton2.default.stack.pop();
      _this.showing = false;
      _this.unread = false;
    };

    this.onReload = function (messages) {
      if (!messages) {
        return;
      }
      _this.messages = messages;
      checkUnreadFromStorage();
      _storage2.default.set(storageId, _this.messages.length);
    };

    this.append = function (msg) {
      _this.messages.push(msg);
      _storage2.default.set(storageId, _this.messages.length);
      if (msg.u !== 'oyunkeyf') _this.unread = true;
      _mithril2.default.redraw();
    };

    // function onKeyboardShow(e) {
    // }

    // function onKeyboardHide(e) {
    // }

    // window.addEventListener('native.keyboardhide', onKeyboardHide);
    // window.addEventListener('native.keyboardshow', onKeyboardShow);

    this.onunload = function () {
      if (_game2.default.playable(_this.root.data)) _storage2.default.remove(storageId);
      // document.removeEventListener('native.keyboardhide', onKeyboardHide);
      // document.removeEventListener('native.keyboardshow', onKeyboardShow);
    };
  },
  view: function view(ctrl) {
    if (!ctrl.showing) return null;
    return (0, _mithril2.default)('div#chat.modal', { config: _helper2.default.slidesInUp }, [(0, _mithril2.default)('header', [(0, _mithril2.default)('button.modal_close[data-icon=L]', {
      config: _helper2.default.ontouch(_helper2.default.slidesOutDown(ctrl.close, 'chat'))
    }), (0, _mithril2.default)('h2', (0, _i18n2.default)('chat'))]), (0, _mithril2.default)('div.modal_content', [(0, _mithril2.default)('div#chat_scroller.native_scroller', {
      config: function config(el) {
        el.scrollTop = el.scrollHeight;
      }
    }, [(0, _mithril2.default)('ul.chat_messages', ctrl.messages.map(function (msg, i, all) {
      var player = ctrl.root.data.player;

      var oyunkeyfTalking = msg.u === 'oyunkeyf';
      var playerTalking = msg.s ? msg.s === player.side : player.user && msg.u === player.user.username;
      var closeBalloon = true;
      var next = all[i + 1];
      var nextTalking;

      if (next) {
        nextTalking = next.s ? next.s === player.side : player.user && next.u === player.user.username;
      }
      if (!!nextTalking) closeBalloon = nextTalking !== playerTalking;

      return (0, _mithril2.default)('li.chat_msg.allow_select', {
        className: _helper2.default.classSet({
          system: oyunkeyfTalking,
          player: playerTalking,
          opponent: !oyunkeyfTalking && !playerTalking,
          'close_balloon': closeBalloon
        })
      }, [_mithril2.default.trust(msg.t)]);
    }))]), (0, _mithril2.default)('form.chat_form', {
      onsubmit: function onsubmit(e) {
        e.preventDefault();
        var msg = e.target[0].value.trim();
        if (!msg) return;
        if (msg.length > 140) {
          return;
        }
        ctrl.inputValue = '';
        _socket2.default.send('talk', msg);
      }
    }, [(0, _mithril2.default)('input#chat_input.chat_input[type=text]', {
      placeholder: (0, _i18n2.default)('talkInChat'),
      autocomplete: 'off',
      value: ctrl.inputValue,
      config: function config(el, isUpdate) {
        if (!isUpdate) {
          el.addEventListener('input', inputListener.bind(null, ctrl));
        }
      }
    }), (0, _mithril2.default)('button.chat_send[data-icon=z]')])])]);
  }
};


function inputListener(ctrl, e) {
  ctrl.inputValue = e.target.value;
}

},{"../../backbutton":189,"../../i18n":191,"../../oyunkeyf/game":193,"../../socket":200,"../../storage":202,"../helper":209,"mithril":168}],233:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ctrl;

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ctrl(data, outOfTime, soundSide, redrawBoard) {
  var _this = this;

  var lastUpdate = {};

  this.data = data;
  this.data.barTime = Math.max(this.data.initial, 2);

  function setLastUpdate() {
    lastUpdate = {
      east: data.sides['east'],
      west: data.sides['west'],
      north: data.sides['north'],
      south: data.sides['south'],
      at: new Date()
    };
  }
  setLastUpdate();

  this.update = function (sides) {
    _this.data.sides = sides;
    setLastUpdate();
  };

  this.tick = function (side) {
    _this.data.sides[side] = Math.max(0, lastUpdate[side] - (new Date() - lastUpdate.at) / 1000);
    if (_this.data.sides[side] === 0) outOfTime();
    redrawBoard();
  };
}

},{"mithril":168}],234:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.view = view;

var _helper = require('../../helper');

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function view(ctrl, side, runningSide, position) {
  var time = ctrl.data.sides[side];
  var isRunning = runningSide === side;
  var className = 'clock clock_' + side + ' clock_' + position + ' ' + _helper2.default.classSet({
    outoftime: !time,
    running: isRunning,
    emerg: time < ctrl.data.emerg
  });

  return h(
    'div',
    { className: className },
    showBar(ctrl, time)
  );
}

function showBar(ctrl, time) {
  var barStyle = {
    width: Math.max(0, Math.min(100, time / ctrl.data.barTime * 100)) + '%'
  };
  return h(
    'div',
    { className: 'bar' },
    h('span', { style: barStyle })
  );
}

},{"../../helper":209,"mithril/hyperscript":167}],235:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (data) {
  return data;
};

},{}],236:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

var _game = require('../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function makeConfig(data, fen) {
  return {
    fen: fen,
    turnSide: data.game.player,
    povSide: data.player.side,
    spectator: data.player.spectator,
    withTore: !!data.game.variant.key.match(/duzokey/),
    movable: {
      free: false,
      board: _game2.default.isPlayerPlaying(data),
      dests: _game2.default.isPlayerPlaying(data) ? data.possibleMoves : []
    }
  };
}

function make(data, fen, userMove, onMove) {
  var config = makeConfig(data, fen);
  config.movable.events = {
    after: userMove
  };
  config.events = {
    move: onMove
  };
  return new _okeygroundMobile2.default.controller(config);
}

function end(ground) {
  ground.stop();
}

exports.default = {
  make: make,
  end: end
};

},{"../../oyunkeyf/game":193,"okeyground-mobile":1}],237:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (cfg) {
  var _this = this;

  this.data = (0, _data2.default)(cfg);

  this.data.game.oscores = {
    east: {
      series: 101,
      new: true
    },
    west: {
      pairs: 5
    },
    north: {
      pairs: 5
    },
    south: {
      pairs: 5
    }
  };

  this.chat = new _chat2.default.controller(this);

  this.vm = {
    showingActions: false
  };

  this.setTitle = function (text) {
    if (!text) {
      if (_status2.default.started(_this.data)) {
        text = _game2.default.title(_this.data);
      } else if (_status2.default.finished(_this.data)) {
        text = (0, _i18n2.default)('gameOver');
      }
    } else {
      text = 'oyunkeyf.net';
    }
    _this.title = text;
  };
  this.setTitle();

  var connectSocket = function connectSocket() {
    if (utils.hasNetwork()) {
      _socket2.default.createGame(_this.data.url.socket, _this.data.player.version, (0, _socketHandler2.default)(_this), _this.data.url.round);
    }
  };

  connectSocket();

  this.toggleUserPopup = function (position, userId) {
    console.log('user', userId);
  };

  this.showActions = function () {
    _backbutton2.default.stack.push(_this.hideActions);
    _this.vm.showingActions = true;
  };

  this.hideActions = function (fromBB) {
    if (fromBB !== 'backbutton' && _this.vm.showingActions) _backbutton2.default.stack.pop();
    _this.vm.showingActions = false;
  };

  var userMove = function userMove(key, move) {
    if (key === _okeygroundMobile2.default.move.leaveTaken) {
      return;
    }
    _this.sendMove(key, move);
  };

  var onMove = function onMove(key, piece) {
    console.log('sound.move', key, piece);
    if (key === _okeygroundMobile2.default.move.drawMiddle) {
      _this.sendMove(key);
    }
    if (key === _okeygroundMobile2.default.move.discard) {
      _this.vm.hasPlayedDiscard = true;
    }
  };

  this.sendMove = function (key) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var move = args;
    args.key = key;
    _socket2.default.send('move', move, {
      ackable: true
    });
  };

  this.apiMove = function (o) {
    var d = _this.data;
    var playing = _game2.default.isPlayerPlaying(d);

    d.game.turns = o.ply;
    d.game.player = _game2.default.sideByPly(o.ply);
    d.game.oscores = o.oscores;
    d.possibleMoves = d.player.side === d.game.player ? o.dests : [];
    _this.setTitle();
    if (true) {
      if (o.isMove) {
        if (o.drawmiddle) {
          _this.okeyground.apiMove(o.key, wrapPiece(o.drawmiddle.piece));
        } else if (o.discard) {
          if (!_this.vm.hasPlayedDiscard) {
            _this.okeyground.apiMove(o.key, wrapPiece(o.discard.piece));
          } else {}
          _this.vm.hasPlayedDiscard = false;
        } else if (o.opens) {
          _this.okeyground.apiMove(o.key, wrapGroup(o.opens.group));
        } else if (o.drop) {
          _this.okeyground.apiMove(o.key, wrapDrop(o.drop.piece, o.drop.pos));
        } else if (o.key === _okeygroundMobile2.default.move.collectOpen) {
          _this.restoreFen(o.fen, _okeygroundMobile2.default.move.collectOpen);
        } else if (o.key === _okeygroundMobile2.default.move.leaveTaken) {
          // this.restoreFen(o.fen);
          _this.okeyground.apiMove(o.key, wrapPiece(o.leavetaken.piece));
        } else {
          _this.okeyground.apiMove(o.key);
        }
      }

      _this.okeyground.set({
        turnSide: d.game.player,
        movable: {
          dests: playing ? d.possibleMoves : []
        }
      });
    }

    if (o.clock) {
      var c = o.clock;
      if (_this.clock) _this.clock.update(c);
    }
    _this.updateGameActions();
  };

  this.restoreFen = function (fen, hint) {
    var oldBoard = _this.okeyground.getFen();

    // make a hack fen to split
    var oldFen = "//" + oldBoard + "/";

    _this.okeyground.set({
      fen: _util2.default.persistentFen(fen, oldFen),
      animationHint: hint
    });
  };

  this.saveBoard = function () {
    var boardFen = _this.okeyground.getFen();
    _util2.default.fenStore.set(boardFen);
  };

  this.okeyground = _ground2.default.make(this.data, cfg.game.fen, userMove, onMove);

  this.redrawBoard = function () {
    _mithril2.default.redraw();
    _this.okeyground.data.renderRAF();
  };

  this.clock = this.data.clock ? new _clockCtrl2.default(this.data.clock, this.data.player.spectator ? utils.noop : (0, _throttle2.default)(function () {
    return _socket2.default.send('outoftime', 1000);
  }), this.data.player.spectator ? null : this.data.player.side, this.redrawBoard) : false;

  this.isClockRunning = function () {
    return _this.data.clock && _game2.default.playable(_this.data) && (_this.data.game.turns > 0 || _this.data.clock.running);
  };

  this.clockTick = function () {
    if (_this.isClockRunning()) _this.clock.tick(_this.data.game.player);
  };

  var clockIntervalId;
  if (this.clock) clockIntervalId = setInterval(this.clockTick, 100);

  this.openSeries = function () {
    _this.okeyground.playOpenSeries();
  };
  this.openPairs = function () {
    _this.okeyground.playOpenPairs();
  };
  this.collectOpen = function () {
    _this.sendMove(_okeygroundMobile2.default.move.collectOpen);
  };
  this.leaveTaken = function () {
    _this.sendMove(_okeygroundMobile2.default.move.leaveTaken);
  };

  this.followUp = function () {
    _mithril2.default.route('/masa/' + _this.data.masa.id);
  };

  this.removeGameAction = function (id, f) {
    var el = document.getElementById(id);
    if (!el) return null;
    return (0, _zanimo2.default)(el,
    // 'opacity', 0, 250, 'ease-out'
    'transform', 'translate3d(0, -100%, 0)', 250, 'ease-out').then(function () {
      _this.vm[id] = false;
      _mithril2.default.redraw();
    }).catch(console.log.bind(console));
  };

  this.updateGameActions = function () {
    (0, _forIn2.default)({
      'openPairs': _this.okeyground.canOpenPairs(),
      'openSeries': _this.okeyground.canOpenSeries(),
      'collectOpen': _this.okeyground.canCollectOpen(),
      'leaveTaken': _this.okeyground.canLeaveTaken()
    }, function (value, key) {
      if (value) {
        _this.vm[key] = true;
      } else _this.removeGameAction(key);
    });
  };
  this.updateGameActions();

  this.reload = function (rCfg) {
    _this.data = (0, _data2.default)(rCfg);
    _this.setTitle();

    // ground.reload(this.okeyground, this.data, rCfg.game.fen);
    _mithril2.default.redraw();
  };

  var reloadGameData = function reloadGameData() {
    xhr.reload(_this).then(_this.reload);
  };

  document.addEventListener('resume', reloadGameData);
  window.plugins.insomnia.keepAwake();

  this.onunload = function () {
    _socket2.default.destroy();
    clearInterval(clockIntervalId);
    document.removeEventListener('resume', reloadGameData);
    window.plugins.insomnia.allowSleepAgain();
    if (this.chat) this.chat.onunload();
    if (this.okeyground) {
      this.okeyground.onunload();
    }
  };
};

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

var _data = require('./data');

var _data2 = _interopRequireDefault(_data);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _forIn = require('lodash/forIn');

var _forIn2 = _interopRequireDefault(_forIn);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _socketHandler = require('./socketHandler');

var _socketHandler2 = _interopRequireDefault(_socketHandler);

var _ground = require('./ground');

var _ground2 = _interopRequireDefault(_ground);

var _clockCtrl = require('./clock/clockCtrl');

var _clockCtrl2 = _interopRequireDefault(_clockCtrl);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _chat = require('./chat');

var _chat2 = _interopRequireDefault(_chat);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _roundXhr = require('./roundXhr');

var xhr = _interopRequireWildcard(_roundXhr);

var _game = require('../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _status = require('../../oyunkeyf/status');

var _status2 = _interopRequireDefault(_status);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = _okeygroundMobile2.default.util;
var wrapGroup = util.wrapGroup,
    wrapPiece = util.wrapPiece,
    wrapDrop = util.wrapDrop,
    partial = util.partial;

},{"../../backbutton":189,"../../i18n":191,"../../oyunkeyf/game":193,"../../oyunkeyf/status":194,"../../socket":200,"../../utils":262,"./chat":232,"./clock/clockCtrl":233,"./data":235,"./ground":236,"./roundXhr":238,"./socketHandler":239,"./util":240,"lodash/forIn":136,"lodash/throttle":162,"mithril":168,"okeyground-mobile":1,"zanimo":185}],238:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reload = reload;

var _http = require('../../http');

function reload(ctrl) {
  return (0, _http.request)(ctrl.data.url.round, { background: true });
}

},{"../../http":190}],239:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ctrl) {
  return {
    move: function move(o) {
      o.isMove = true;
      ctrl.apiMove(o);
      _mithril2.default.redraw(false, true);
    },
    reload: function reload() {
      xhr.reload(ctrl).then(ctrl.reload);
    },
    resync: function resync() {
      console.log('resync');
      xhr.reload(ctrl).then(function (data) {
        _socket2.default.setVersion(data.player.version);
        ctrl.reload(data);
      }, function (err) {
        (0, _utils.handleXhrError)(err);
      });
    },
    end: function end(scores) {
      console.log(scores);
      ctrl.data.game.scores = scores.result;
      _ground2.default.end(ctrl.okeyground);
      // allow sleep again
      ctrl.saveBoard();
      // ctrl.setLoading(true);
      xhr.reload(ctrl).then(ctrl.reload);
      window.plugins.insomnia.allowSleepAgain();
      setTimeout(function () {
        ctrl.showActions();
        _mithril2.default.redraw();
      }, 500);
    },
    message: function message(msg) {
      if (ctrl.chat) ctrl.chat.append(msg);
    },
    crowd: function crowd(o) {
      ['east', 'west', 'north', 'south'].forEach(function (side) {
        _game2.default.setOnGame(ctrl.data, side, o[side]);
      });
      _mithril2.default.redraw(false, true);
      // top hooks
      ctrl.okeyground.data.renderRAF();
    }
  };
};

var _game = require('../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _ground = require('./ground');

var _ground2 = _interopRequireDefault(_ground);

var _roundXhr = require('./roundXhr');

var xhr = _interopRequireWildcard(_roundXhr);

var _utils = require('../../utils');

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"../../oyunkeyf/game":193,"../../socket":200,"../../utils":262,"./ground":236,"./roundXhr":238,"mithril":168}],240:[function(require,module,exports){
'use strict';

var _storage = require('../../storage');

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sk = 'round.' + 'board';

function assertEqual(a1, a2) {
  return a1.every(function (k, i) {
    return k === a2[i];
  });
}

var fenS = function fenS(fen) {
  return "|" + fen + "|";
};
var regPiece = /[f|r|l|b|g]\d\d?/g;

function boardDiffTest() {
  function test(fen1, fen2) {
    var diff = boardDiff(fen1, fen2);
    var diffLength = diff.match(regPiece).length + (diff.match(/\s/g) || []).length;
    console.log("test \n", fenS(fen1), "\n", fenS(fen2));
    console.log(fenS(diff), diffLength);
  }
  var source = "g7b8g13r12r1r1b3b10r8r9g12b13b13g4g5r10l4g6b12g11g1g8";
  test(source, source);
  test("g7g8g13", source);
  test("               g7g8g13", source);
  test("                    g7g8g13", source);
  test("                            g7g8g13", source);
  test("                            b7 g8 g13 r1", source);
  test("               b13b13g4g5r10l4g6b12g11   b7 g8 g13 r1", source);
}

function boardDiff(oldFen, newFen) {
  if (!oldFen || !newFen || newFen === "") {
    return newFen;
  }

  var pieces = newFen.match(regPiece);
  var unusedIndexes = pieces.map(function (k, i) {
    return i;
  });

  var oldPieces = oldFen.match(/[f|r|l|g|b]\d\d?|./g);

  var piecesLength = pieces.length;

  pieces.forEach(function (p, i) {
    var oldI = oldPieces.indexOf(p);
    if (oldI !== -1) oldPieces.splice(oldI, 1, { f: true, i: i });
  });

  oldPieces = oldPieces.map(function (key) {
    if (key && key.f) {
      unusedIndexes.splice(unusedIndexes.indexOf(key.i), 1);
      return pieces[key.i];
    }
    return " ";
  });

  oldPieces = oldPieces.join("");

  oldPieces = oldPieces.replace(/\s*$/, "  ");

  // var rest = unusedIndexes.map(_ => pieces[_]).join("");
  // var result = oldPieces + rest;
  // var spaces = Math.ceil(result.match(/\s/g).length / 2);
  // spaces += piecesLength;
  // while (spaces-- > 34) {
  //   //result = result.replace(/\s/, "");
  //   //result = result.replace(/\s([^\s]*)$/, "$1");
  // }

  var rest = unusedIndexes.map(function (_) {
    return pieces[_];
  });
  var result = oldPieces + rest.slice(0).fill('  ').join("");

  // index 0 not allowed piece shift hack
  result = result.replace(/^\s/, "");

  rest.forEach(function (p) {
    return result = result.replace(/\s\s/, p);
  });

  if (!assertEqual(result.match(regPiece).sort(), newFen.match(regPiece).sort())) {
    console.warn("board diff failed\n", fenS(result), "\n", fenS(oldFen), "\n", fenS(newFen));
    result = newFen;
  }

  return result;
}

function boardDiff2(oldFen, newFen) {

  if (!oldFen) {
    return newFen;
  }

  var pieces = newFen.match(regPiece);
  var unusedIndexes = pieces.map(function (k, i) {
    return i;
  });

  var oldFenIndexed = oldFen;

  var piecesLength = pieces.length;

  pieces.forEach(function (p, i) {
    var regP = new RegExp(p);
    oldFenIndexed = oldFenIndexed.replace(regP, "${" + i + "}");
  });

  oldFenIndexed = oldFenIndexed.replace(regPiece, "");

  oldFenIndexed.match(/\${\d\d?}/g).forEach(function (key) {
    var i = parseInt(key.match(/\d\d?/));
    unusedIndexes.splice(unusedIndexes.indexOf(i), 1);
    oldFenIndexed = oldFenIndexed.replace(key, pieces[i]);
  });

  oldFenIndexed = oldFenIndexed.replace(/\s*$/, "  ");

  var rest = unusedIndexes.map(function (_) {
    return pieces[_];
  }).join("");

  var result = oldFenIndexed + rest;

  var spaces = result.match(/\s/g).length + piecesLength;

  while (spaces-- > 32) {
    //result = result.replace(/\s/, "");

    //result = result.replace(/\s([^\s]*)$/, "$1");
  }

  if (!assertEqual(result.match(regPiece).sort(), newFen.match(regPiece).sort())) {
    console.warn("board diff failed\n", fenS(result), "\n", fenS(oldFen), "\n", fenS(newFen));
    result = newFen;
  }

  return result;
}

var iBoard = 2;

function persistentFen(fen, oldFen) {
  var oldBoard = oldFen.split('/')[iBoard];
  var board = fen.split('/')[iBoard];
  var rest = fen.substr(board.length);

  var newBoard = board;

  var diff = boardDiff(oldBoard, newBoard);

  // fen = diff + rest;

  fen = fen.replace(board, diff);

  return fen;
}

module.exports = {
  persistentFen: persistentFen,
  fenStore: {
    get: function get(fen) {
      var oldBoard = _storage2.default.get(sk);

      // make a hack fen to split
      var oldFen = "//" + oldBoard + "/";

      return persistentFen(fen, oldFen);
    },
    set: function set(fen) {
      //var board = fen.split('/')[iBoard];
      var board = fen;
      _storage2.default.set(sk, board);
    }
  }
};

},{"../../storage":202}],241:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../../helper');

var _helper2 = _interopRequireDefault(_helper);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function makeActionBarButton(key, icon, name, action) {
  return function (ctrl, config) {
    var className = _helper2.default.classSet({
      'game_action_bar_button': true
    });

    if (!ctrl.vm[action]) {
      return h('button', { className: 'game_action_bar_button empty' });
    }

    return h(
      'button',
      { id: name, className: className, key: key, 'data-icon': icon, config: both(slidesInDown, _helper2.default.ontouch(gameActionHandler(ctrl, action))) },
      (0, _i18n2.default)(name)
    );
  };
}

exports.default = {
  openSeries: makeActionBarButton('openSeries', 'L', 'openSeries', 'openSeries'),
  openPairs: makeActionBarButton('openPairs', 'L', 'openPairs', 'openPairs'),
  leaveTaken: makeActionBarButton('leaveTaken', 'L', 'leaveTaken', 'leaveTaken'),
  collectOpen: makeActionBarButton('collectOpen', 'L', 'collectOpen', 'collectOpen'),
  followUp: function followUp(ctrl) {
    var className = _helper2.default.classSet({
      'game_action_bar_button': true,
      'glow': true
    });

    if (_game2.default.playable(ctrl.data)) return null;

    return h(
      'button',
      { id: 'followUp', className: className, key: 'followUp', 'data-icon': 'G', config: both(slidesInDown, _helper2.default.ontouch(function () {
          return ctrl.followUp();
        })) },
      (0, _i18n2.default)('backToMasa')
    );
  },
  returnToMasa: function returnToMasa(ctrl) {
    function handler() {
      ctrl.hideActions();
      _mithril2.default.route('/masa/' + ctrl.data.game.masaId, null, true);
    }
    return h(
      'button',
      { key: 'returnToMasa', config: _helper2.default.ontouch(handler) },
      h('span', { className: 'fa fa-trophy' }),
      (0, _i18n2.default)('backToMasa')
    );
  },
  withdrawFromMasa: function withdrawFromMasa(ctrl) {
    function handler() {
      ctrl.hideActions();
      masaXhr.withdraw(ctrl.data.game.masaId);
      _mithril2.default.route('/masa/' + ctrl.data.game.masaId);
    }
    return h(
      'button',
      { key: 'withdrawFromMasa', config: _helper2.default.ontouch(handler) },
      h('span', { className: 'fa fa-flag' }),
      (0, _i18n2.default)('withdraw')
    );
  }
};


function gameActionHandler(ctrl, action) {
  return function () {
    if (ctrl[action]) ctrl[action].call();
  };
}

function slidesInUp(el, isUpdate, context) {
  if (!isUpdate) {
    el.style.transform = 'translate3d(100%, 0, 0)';
    // force reflow hack
    context.lol = el.offsetHeight;
    (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out');
  }
}

function slidesInDown(el, isUpdate, context) {
  if (!isUpdate) {
    el.style.transform = 'translate3d(0, -100%, 0)';
    // force reflow hack
    context.lol = el.offsetHeight;
    (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out');
  }
}

function fadesIn(el, isUpdate, context) {
  if (!isUpdate) {
    el.style.opacity = 0;
    // force reflow hack
    context.lol = el.offsetHeight;
    (0, _zanimo2.default)(el, 'opacity', 1, 250, 'ease-out');
  }
}

function both(config1, config2) {
  return function () {
    config1.apply(null, arguments);
    config2.apply(null, arguments);
  };
}

},{"../../../i18n":191,"../../../oyunkeyf/game":193,"../../helper":209,"mithril":168,"mithril/hyperscript":167,"zanimo":185}],242:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('../../../utils');

var utils = _interopRequireWildcard(_utils);

var _layout = require('../../layout');

var _layout2 = _interopRequireDefault(_layout);

var _helper = require('../../helper');

var _helper2 = _interopRequireDefault(_helper);

var _common = require('../../shared/common');

var _chat = require('../chat');

var _chat2 = _interopRequireDefault(_chat);

var _button = require('./button');

var _button2 = _interopRequireDefault(_button);

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _status = require('../../../oyunkeyf/status');

var _status2 = _interopRequireDefault(_status);

var _Board = require('../../shared/Board');

var _Board2 = _interopRequireDefault(_Board);

var _popup = require('../../shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = _okeygroundMobile2.default.util;
var partial = util.partial;
function view(ctrl) {
  var isPortrait = _helper2.default.isPortrait();

  return _layout2.default.board(function () {
    return renderHeader(ctrl);
  }, function () {
    return renderContent(ctrl, isPortrait);
  }, function () {
    return overlay(ctrl);
  });
}

function overlay(ctrl) {
  return [ctrl.chat ? _chat2.default.view(ctrl.chat) : null, renderGamePopup(ctrl)];
}

function renderHeader(ctrl) {
  return null;
}

function renderContent(ctrl, isPortrait) {
  var bounds = utils.getBoardBounds(_helper2.default.viewportDim(), isPortrait, _helper2.default.isIpadLike(), 'game');
  var board = (0, _Board2.default)(ctrl, ctrl.okeyground, bounds, isPortrait, null);

  return [board, h(
    'section',
    { key: 'table', className: 'table' },
    h(
      'header',
      { key: 'table-header', className: 'tableHeader' },
      (0, _common.menuButton)(),
      gameInfos(ctrl)
    ),
    renderReplay(ctrl),
    renderGameActionsBar(ctrl)
  )];
}

function renderReplay(ctrl) {
  var gmClass = ['fa', 'fa-ellipsis-h'].concat(['game_bar_button']).join(' ');
  var gmButton = h('button', { className: gmClass, key: 'gameMenu', config: _helper2.default.ontouch(ctrl.showActions) });

  var chatClass = ['game_bar_button', ctrl.chat && ctrl.chat.unread ? 'glow' : ''].join(' ');
  var chatButton = ctrl.chat ? h('button', { className: chatClass, 'data-icon': 'c',
    key: 'chat',
    config: _helper2.default.ontouch(ctrl.chat.open) }) : null;

  return h(
    'div',
    { 'class': 'replay' },
    gmButton,
    chatButton
  );
}

function renderResult(ctrl) {
  var result;
  if (_status2.default.finished(ctrl.data)) switch (ctrl.data.game.winner) {
    default:
      result = (0, _i18n2.default)('gameEnded');
      break;
  }

  if (result || _status2.default.aborted(ctrl.data)) {
    var winner = _game2.default.getPlayer(ctrl.data, ctrl.data.game.winner);
    return [(0, _mithril2.default)('p.result', result), (0, _mithril2.default)('p.status', [winner ? ', ' + (0, _i18n2.default)('isVictorous') : null])];
  }
}

function gameInfos(ctrl) {
  var data = ctrl.data;

  // const roundString = gameApi.roundsOrScores(data);
  var mode = data.game.rated ? (0, _i18n2.default)('rated') : (0, _i18n2.default)('casual');
  var icon = utils.gameIcon(data.game.perf);
  var variant = (0, _mithril2.default)('span.variant', {}, data.game.variant.name);
  var infos = [variant, (0, _mithril2.default)('br'), mode];
  return [(0, _mithril2.default)('div.icon-game', {
    'data-icon': icon ? icon : ''
  }), (0, _mithril2.default)('div.game-title.no_select', infos)];
}

function renderGameActionsBar(ctrl) {
  return h(
    'section',
    { className: 'game_actions_bar', key: 'game-actions-bar' },
    _button2.default.leaveTaken(ctrl),
    _button2.default.collectOpen(ctrl),
    _button2.default.openPairs(ctrl),
    _button2.default.openSeries(ctrl),
    _button2.default.followUp(ctrl)
  );
}

function renderGamePopup(ctrl) {
  return (0, _popup2.default)('player_controls', function () {
    return gameInfos(ctrl);
  }, _game2.default.playable(ctrl.data) ? function () {
    return renderGameRunningActions(ctrl);
  } : function () {
    return renderGameEndedActions(ctrl);
  }, ctrl.vm.showingActions, ctrl.hideActions);
}

function renderGameRunningActions(ctrl) {
  var gameControls = [_button2.default.returnToMasa(ctrl)];

  return h(
    'div',
    { className: 'game_controls' },
    gameControls
  );
}

function renderGameEndedActions(ctrl) {
  var nbHand = ctrl.data.game.roundAt + 1;
  var result = _game2.default.result(ctrl.data);
  var winner = _game2.default.getPlayer(ctrl.data, ctrl.data.game.winner);
  var status = _status2.default.toLabel(ctrl.data.game.status.name, ctrl.data.game.winner, ctrl.data.game.variant.key);
  var resultDOM = _status2.default.aborted(ctrl.data) ? [] : [(0, _mithril2.default)('strong', nbHand + '. ' + result), (0, _mithril2.default)('br')];

  resultDOM.push((0, _mithril2.default)('em.resultStatus', status));
  var buttons = null;
  if (ctrl.data.game.masaId) {
    buttons = [_button2.default.returnToMasa(ctrl), _button2.default.withdrawFromMasa(ctrl)];
  }

  return h(
    'div',
    { className: 'game_controls' },
    h(
      'div',
      { className: 'result' },
      resultDOM
    ),
    renderScores(ctrl),
    h(
      'div',
      { className: 'control buttons' },
      buttons
    )
  );
}

function renderScores(ctrl) {
  var d = ctrl.data;
  var sides = ['east', 'west', 'north', 'south'];
  var scores = sides.map(function (side) {
    return {
      player: _game2.default.getPlayer(d, side),
      scores: d.game.scores ? d.game.scores[side] : { scores: [] },
      opens: d.game.oscores ? d.game.oscores[side] : null
    };
  });

  var tableBody = scores.map(partial(duzPlayerTr, ctrl));

  return h(
    'div',
    { className: 'crosstable' },
    h(
      'table',
      null,
      h(
        'thead',
        null,
        h('tr', null)
      ),
      h(
        'tbody',
        null,
        tableBody
      )
    )
  );
}

function duzPlayerTr(ctrl, _ref) {
  var player = _ref.player,
      scores = _ref.scores;

  var mySide = ctrl.data.player.side;

  var trClass = _helper2.default.classSet({
    'me': player.side === mySide
  });

  return h(
    'tr',
    { key: player.side, className: trClass },
    h(
      'th',
      { className: 'score' },
      scores.total
    ),
    h(
      'th',
      { className: 'user' },
      utilPlayer(player, 'a')
    )
  );
}

function utilPlayer(p, tag) {
  var fullName = p.user ? p.user.username : p.ai ? (0, _i18n2.default)('aiBot', p.ai) : (0, _i18n2.default)(p.side);
  var attrs = {
    class: 'user_link'
  };
  if (p.user && p.user.username) attrs[tag === 'a' ? 'href' : 'data-href'] = '/@/' + p.user.username;
  return {
    tag: tag,
    attrs: attrs,
    children: fullName
  };
}

},{"../../../i18n":191,"../../../oyunkeyf/game":193,"../../../oyunkeyf/status":194,"../../../utils":262,"../../helper":209,"../../layout":213,"../../shared/Board":245,"../../shared/common":248,"../../shared/popup":251,"../chat":232,"./button":241,"mithril":168,"mithril/hyperscript":167,"okeyground-mobile":1,"zanimo":185}],243:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _form = require('../shared/form');

var _form2 = _interopRequireDefault(_form);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  controller: function controller() {
    _socket2.default.createDefault();
  },
  view: function view() {
    var header = utils.partialf(_common.header, null, (0, _common.backButton)((0, _i18n2.default)('settings')));

    return _layout2.default.free(header, renderBody);
  }
};


function renderBody() {
  return (0, _mithril2.default)('div', {
    style: { width: '100%', height: '100%' }
  }, [(0, _mithril2.default)('ul.settings_list.general.native_scroller.page', [(0, _mithril2.default)('li.list_item.nav', {
    key: 'lang',
    config: _helper2.default.ontouchY(utils.f(_mithril2.default.route, '/settings/lang'))
  }, (0, _i18n2.default)('language')), (0, _mithril2.default)('li.list_item.settingsChoicesInline', {
    key: 'backgroundTheme'
  }, [(0, _mithril2.default)('label', (0, _i18n2.default)('background')), (0, _mithril2.default)('fieldset', [(0, _mithril2.default)('div.nice-radio', _form2.default.renderRadio((0, _i18n2.default)('dark'), 'bgTheme', 'dark', _settings2.default.general.theme.background() === 'dark', function (e) {
    _settings2.default.general.theme.background(e.target.value);
    _layout2.default.onBackgroundChange(e.target.value);
  })), (0, _mithril2.default)('div.nice-radio', _form2.default.renderRadio((0, _i18n2.default)('light'), 'bgTheme', 'light', _settings2.default.general.theme.background() === 'light', function (e) {
    _settings2.default.general.theme.background(e.target.value);
    _layout2.default.onBackgroundChange(e.target.value);
  }))])])]), window.oyunkeyf.version ? (0, _mithril2.default)('section.app_version', 'v' + window.oyunkeyf.version) : null]);
}

},{"../../i18n":191,"../../settings":198,"../../socket":200,"../../utils":262,"../helper":209,"../layout":213,"../shared/common":248,"../shared/form":249,"mithril":168}],244:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _form = require('../shared/form');

var _form2 = _interopRequireDefault(_form);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _xhr = require('../../xhr');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  controller: function controller() {
    var langs = _mithril2.default.prop([]);
    (0, _i18n.getAvailableLanguages)().then(langs);

    return {
      langs: langs
    };
  },
  view: function view(ctrl) {
    var header = utils.partialf(_common.header, null, (0, _common.backButton)((0, _i18n2.default)('language')));

    function renderLang(l) {
      return h(
        'li',
        { className: 'list_item' },
        _form2.default.renderRadio(l[1], 'lang', l[0], _settings2.default.general.lang() === l[0], function (e) {
          _settings2.default.general.lang(e.target.value);
          (0, _xhr.setServerLang)(e.target.value);
          (0, _i18n.loadFromSettings)();
        })
      );
    }

    function renderBody() {
      return h(
        'ul',
        { className: 'native_scroller page settings_list radio_list' },
        ctrl.langs().map(function (l) {
          return renderLang(l);
        })
      );
    }
    return _layout2.default.free(header, renderBody);
  }
};

},{"../../i18n":191,"../../settings":198,"../../utils":262,"../../xhr":264,"../layout":213,"../shared/common":248,"../shared/form":249,"mithril":168,"mithril/hyperscript":167}],245:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = function (ctrl, okeygroundCtrl, bounds, isPortrait, wrapperClasses) {
  var data = ctrl.data;

  var boardClass = ['display_board'].join(' ');

  var key = 'board' + (isPortrait ? 'portrait' : 'landscape');
  var wrapperClass = 'game_board_wrapper';

  if (wrapperClasses) {
    wrapperClass += ' ' + wrapperClasses;
  }

  var wrapperStyle = bounds ? {
    height: bounds.height + 'px',
    width: bounds.width + 'px'
  } : {};

  function wrapperConfig(el, isUpdate) {
    if (!isUpdate) {}
  }

  function boardConfig(el, isUpdate) {
    if (!isUpdate) {
      if (!bounds) {}
      _okeygroundMobile2.default.render(el, okeygroundCtrl);
    }
  }

  okeygroundCtrl.data.topHooks = [
  // renderTopMenu(),
  renderPlayerInfo(ctrl, data.opponentUp, 'top'), renderPlayerInfo(ctrl, data.opponentLeft, 'left'), renderPlayerInfo(ctrl, data.player, 'bottom'), renderPlayerInfo(ctrl, data.opponentRight, 'right')];

  return h(
    'section',
    { className: wrapperClass, config: wrapperConfig,
      style: wrapperStyle, key: key },
    h('div', { className: boardClass, config: boardConfig })
  );
};

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

var _common = require('./common');

var _Players = require('./Players');

var _clockView = require('../round/clock/clockView');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderTopMenu() {
  return h(
    'div',
    { 'class': 'display_menu' },
    (0, _common.menuButton)()
  );
}

function renderPlayerInfo(ctrl, player, position) {
  var wrapperClass = _helper2.default.classSet({
    'playerInfos': true
  }) + (' ' + position);

  var playerName = player.ai ? (0, _i18n2.default)('aiBot', player.ai) : utils.playerName(player);
  var playerOnGame = player.onGame || player.ai ? h('span', { className: 'ongame yes', 'data-icon': '3' }) : h('span', { className: 'ongame no', 'data-icon': '0' });

  var togglePopup = ctrl.toggleUserPopup.bind(ctrl, position, player.user);
  var vConf = _helper2.default.ontouch(togglePopup);

  var runningSide = ctrl.isClockRunning() ? ctrl.data.game.player : null;
  var running = ctrl.data.game.player === player.side;

  var opens = ctrl.data.game.oscores ? ctrl.data.game.oscores[player.side] : null;
  var opensHint = opens ? opens.series ? 'openedSeries' : 'openedPairs' : null;
  var opensClass = "opens" + (opens && opens.new ? " new" : "");

  return h(
    'div',
    { className: wrapperClass, config: vConf },
    h(
      'div',
      { 'class': 'wrap_info' },
      opens ? h(
        'div',
        { 'class': opensClass },
        opens.series ? opens.series : opens.pairs,
        ' ',
        (0, _i18n2.default)(opensHint).split(' ')[0]
      ) : null
    ),
    h(
      'div',
      { 'class': 'wrap_user' },
      h(
        'h2',
        { className: 'playerUser' },
        playerName,
        playerOnGame
      ),
      ctrl.clock && running ? (0, _clockView.view)(ctrl.clock, player.side, runningSide, position) : null
    )
  );
}

},{"../../i18n":191,"../../utils":262,"../helper":209,"../round/clock/clockView":234,"./Players":246,"./common":248,"mithril/hyperscript":167,"okeyground-mobile":1}],246:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.renderPlayer = renderPlayer;

exports.default = function (data, bounds) {

  var playerClass = ['display_player'].join(' ');

  var key = 'players';

  var topPlayer = renderPlayer('top');
  var leftPlayer = renderPlayer('left');
  var rightPlayer = renderPlayer('right');
  var bottomPlayer = renderPlayer('bottom');

  return h(
    'div',
    { className: playerClass },
    topPlayer,
    leftPlayer,
    rightPlayer,
    bottomPlayer
  );
};

function renderPlayer(position) {
  var playerClass = ['player', position].join(' ');

  return h('div', { className: playerClass });
}

},{"mithril/hyperscript":167}],247:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(_, args) {
    var boardClass = ['display_board', args.variant ? args.variant.key : ''].join(' ');

    function boardConf(el, isUpdate, context) {
      var config = makeConfig(args);
      if (context.ground) {
        context.ground.set(config);
      } else {
        // TODO try to avoid that
        if (!config.bounds) {
          // console.log('no board bounds');
          // config.bounds = el.getBoundingClientRect();
        }
        context.ground = (0, _okeygroundMobile2.default)(el, config);
      }
    }
    return h('div', { className: boardClass, config: boardConf });
  }
};


function makeConfig(args) {
  var fen = args.fen,
      orientation = args.orientation,
      bounds = args.bounds;

  var conf = {
    viewOnly: true,
    minimalDom: true,
    fen: fen
  };

  // if (bounds) conf.bounds = bounds;

  return conf;
}

},{"mithril/hyperscript":167,"okeyground-mobile":1}],248:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.menuButton = menuButton;
exports.headerBtns = headerBtns;
exports.dropShadowHeader = dropShadowHeader;
exports.backButton = backButton;
exports.gamesButton = gamesButton;
exports.header = header;
exports.viewOnlyBoardContent = viewOnlyBoardContent;
exports.empty = empty;
exports.userStatus = userStatus;

var _menu = require('../menu');

var menu = _interopRequireWildcard(_menu);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _gamesMenu = require('../gamesMenu');

var _gamesMenu2 = _interopRequireDefault(_gamesMenu);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _ViewOnlyBoard = require('./ViewOnlyBoard');

var _ViewOnlyBoard2 = _interopRequireDefault(_ViewOnlyBoard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function menuButton() {
  return h('button.fa.fa-navicon.main_header_button.menu_button', {
    key: 'main-menu',
    oncreate: helper.ontap(menu.mainMenuCtrl.toggle)
  });
}

function headerBtns() {

  if (utils.hasNetwork() && _session2.default.isConnected()) {
    return h('div', { key: 'buttons', className: 'buttons' });
  } else {
    return h('div', { key: 'buttons', className: 'buttons' });
  }
}

function dropShadowHeader(title, leftButton) {

  return [h('nav', [leftButton ? leftButton : menuButton(), title ? h(
    'div',
    { className: 'main_header_title', key: 'title' },
    title
  ) : null, headerBtns()]), h('div.main_header_drop_shadow')];
}

// export function menuButton() {
//   return (
//       <button key="main-menu" className="fa fa-navicon main_header_button menu_button" config={helper.ontouch(menu.toggle)}>
//     </button>
//   );
// }

function backButton(title) {
  return h(
    'button',
    { key: 'default-history-backbutton', className: 'back_button main_header_button', config: helper.ontouch(utils.backHistory) },
    h('span', { className: 'fa fa-arrow-left' }),
    title ? h(
      'div',
      { className: 'title' },
      title
    ) : null
  );
}

function gamesButton() {
  var key = void 0,
      action = void 0;

  key = 'games-menu';

  if (_session2.default.nowPlaying().length) {
    key = 'games-menu';
    action = _gamesMenu2.default.open;
  } else {
    key = 'new-game-form';
    action = _newGameForm2.default.open;
  }

  var className = ['main_header_button', 'game_menu_button', !utils.hasNetwork() ? 'invisible' : ''].join(' ');

  var longAction = function longAction() {
    return window.plugins.toast.show(i18n('nbGamesInPlay', _session2.default.nowPlaying().length), 'short', 'top');
  };

  return h('button', { key: key, className: className, config: helper.ontouch(action, longAction) });
}

// export function headerBtns() {
//   return (
//     <div key="buttons" className="buttons">
//       {gamesButton()}
//     </div>
//   );
// }

function header(title, leftButton) {
  return h(
    'nav',
    null,
    leftButton ? leftButton : menuButton(),
    title ? h(
      'h1',
      { key: 'title' },
      title
    ) : null,
    headerBtns()
  );
}

function viewOnlyBoardContent() {
  var isPortrait = false;
  var _vw$vh = { vw: 10, vh: 10 },
      vw = _vw$vh.vw,
      vh = _vw$vh.vh;

  var boardStyle = isPortrait ? { width: vw + 'px', height: vw + 'px' } : {};
  var boardKey = 'viewonlyboard';
  var className = 'board_wrapper';
  var board = h(
    'section',
    { key: boardKey, className: className, style: boardStyle },
    _mithril2.default.component(_ViewOnlyBoard2.default)
  );
  return [board];
}

function empty() {
  return [];
}

function userStatus(user) {
  var status = user.online ? 'online' : 'offline';
  return h(
    'div',
    { className: 'user' },
    h('span', { className: 'userStatus ' + status, 'data-icon': 'r' }),
    user.username
  );
}

},{"../../session":197,"../../utils":262,"../gamesMenu":206,"../helper":209,"../menu":225,"../newGameForm":227,"./ViewOnlyBoard":247,"mithril":168,"mithril/hyperscript":167}],249:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderOption(label, value, storedValue, labelArg, labelArg2) {
  return (0, _mithril2.default)('option', {
    value: value,
    selected: storedValue === value
  }, (0, _i18n2.default)(label, labelArg, labelArg2));
}

exports.default = {
  renderRadio: function renderRadio(label, name, value, checked, onchange) {
    var id = name + '_' + value;
    return [(0, _mithril2.default)('input.radio[type=radio]', {
      name: name,
      id: id,
      className: value,
      value: value,
      checked: checked,
      onchange: onchange
    }), (0, _mithril2.default)('label', {
      'for': id
    }, (0, _i18n2.default)(label))];
  },

  renderSelect: function renderSelect(label, name, options, settingsProp, isDisabled, onChangeCallback) {
    var storedValue = settingsProp();
    return [(0, _mithril2.default)('label', {
      'for': 'select_' + name
    }, (0, _i18n2.default)(label)), (0, _mithril2.default)('select', {
      id: 'select_' + name,
      disabled: isDisabled,
      config: function config(el, isUpdate, context) {
        if (!isUpdate) {
          var onChange = function onChange(e) {
            settingsProp(e.target.value);
            if (onChangeCallback) onChangeCallback(e.target.value);
            setTimeout(function () {
              _mithril2.default.redraw();
            }, 10);
          };
          el.addEventListener('change', onChange, false);
          context.onunload = function () {
            el.removeEventListener('change', onChange, false);
          };
        }
      }
    }, options.map(function (e) {
      return renderOption(e[0], e[1], storedValue, e[2], e[3]);
    }))];
  },
  renderCheckbox: function renderCheckbox(label, name, settingsProp, callback, disabled) {
    var isOn = settingsProp();
    return (0, _mithril2.default)('div.check_container', {
      className: disabled ? 'disabled' : ''
    }, [(0, _mithril2.default)('label', {
      'for': name
    }, label), (0, _mithril2.default)('input[type=checkbox]', {
      name: name,
      disabled: disabled,
      checked: isOn,
      onchange: function onchange() {
        var newVal = !isOn;
        settingsProp(newVal);
        if (callback) callback(newVal);
      }
    })]);
  }
};

},{"../../i18n":191,"mithril":168}],250:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (key, name, perf, user) {
  var options = { className: 'profilePerf', 'data-icon': (0, _utils.gameIcon)(key) };

  if (variantPerfAvailable(key, perf)) {
    options.className += ' nav';
    options.config = _helper2.default.ontouchY(goToVariantPerf(user, key));
  }

  return (0, _mithril2.default)('div', options, [(0, _mithril2.default)('span.name', name), (0, _mithril2.default)('div.rating', [perf.rating, _helper2.default.progress(perf.prog), (0, _mithril2.default)('span.nb', '/ ' + perf.games)])]);
};

var _utils = require('../../utils');

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function goToVariantPerf(user, key) {
  return function () {
    return _mithril2.default.route('/@/${user.id}/${key}/perf');
  };
}

function variantPerfAvailable(key, perf) {
  return perf.games > 0;
}

},{"../../utils":262,"../helper":209,"mithril":168}],251:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var h = require('mithril/hyperscript');

exports.default = function (classes, headerF, contentF, isShowing, closeF) {
  if (!isShowing) return null;

  var defaultClasses = {
    overlay_popup: true,
    native_scroller: true
  };

  var className = void 0;

  if ((typeof classes === 'undefined' ? 'undefined' : _typeof(classes)) === 'object') {
    className = _helper2.default.classSet(Object.assign({}, defaultClasses, classes));
  } else if (typeof classes === 'string') {
    className = _helper2.default.classSet(defaultClasses) + ' ' + classes;
  } else throw new Error('First popup argument must be either string or an object');

  return h(
    'div',
    { className: 'overlay_popup_wrapper' },
    h('div', { className: 'popup_overlay_close',
      config: closeF ? _helper2.default.ontouch(_helper2.default.fadesOut(closeF, '.overlay_popup_wrapper')) : utils.noop }),
    h(
      'div',
      { className: className, config: styleConf },
      headerF ? h(
        'header',
        null,
        headerF()
      ) : null,
      h(
        'div',
        { className: 'popup_content' },
        contentF()
      )
    )
  );
};

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function styleConf(el) {
  var vh = _helper2.default.viewportDim().vh;
  var h = el.getBoundingClientRect().height;
  var top = (vh - h) / 2;
  // el.style.top = top + 'px';
}

},{"../helper":209,"mithril/hyperscript":167}],252:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SideMenuCtrl;

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _ = require('.');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SideMenuCtrl(side, menuID, backdropID, onOpen, onClose) {
  var _this = this;

  this.isOpen = false;

  this.side = side;
  this.menuID = menuID;
  this.backdropID = backdropID;
  this.onOpen = onOpen;
  this.onClose = onClose;

  this.open = function () {
    _this.isOpen = true;
    _router2.default.backbutton.stack.push(_this.close);
    var el = document.getElementById(_this.menuID);
    var bd = document.getElementById(_this.backdropID);
    if (_this.onOpen) _this.onOpen();
    return Promise.all([(0, _zanimo2.default)(bd, 'visibility', 'visible', 0), (0, _zanimo2.default)(bd, 'opacity', _.BACKDROP_OPACITY, 250, 'linear'), (0, _zanimo2.default)(el, 'visibility', 'visible', 0), (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out')]).then(_redraw2.default).catch(console.log.bind(console));
  };

  this.close = function (fromBB) {
    if (fromBB !== 'backbutton' && _this.isOpen) _router2.default.backbutton.stack.pop();
    _this.isOpen = false;
    var el = document.getElementById(_this.menuID);
    var bd = document.getElementById(_this.backdropID);
    if (_this.onClose) _this.onClose();
    return Promise.all([(0, _zanimo2.default)(bd, 'opacity', 0, 250, 'linear'), (0, _zanimo2.default)(el, 'transform', _this.closeTranslate(), 250, 'ease-out')]).then(function () {
      Promise.all([(0, _zanimo2.default)(el, 'visibility', 'hidden', 0), (0, _zanimo2.default)(bd, 'visibility', 'hidden', 0)]);
    }).catch(console.log.bind(console));
  };

  this.toggle = function () {
    if (_this.isOpen) _this.close();else _this.open();
  };

  this.closeTranslate = function () {
    return _this.side === 'left' ? 'translate3d(-100%,0,0)' : 'translate3d(100%,0,0)';
  };
};

},{".":253,"../../../router":195,"../../../utils/redraw":263,"zanimo":185}],253:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var BACKDROP_OPACITY = exports.BACKDROP_OPACITY = 0.7;

},{}],254:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(_, args) {
    var buttons = args.buttons,
        selectedTab = args.selectedTab,
        onTabChange = args.onTabChange;


    var iWidth = 100 / buttons.length;
    var index = buttons.findIndex(function (e) {
      return e.key === selectedTab;
    });
    var shift = index * (iWidth * buttons.length);

    var indicatorStyle = {
      width: iWidth + '%',
      transform: 'translateX(' + shift + '%)'
    };

    var buttonStyle = {
      width: iWidth + '%'
    };

    function renderTab(b) {
      var className = ['tab', selectedTab === b.key ? 'selected' : ''].join(' ');
      var config = _helper2.default.ontouch(onTabChange.bind(null, b.key));
      return h(
        'button',
        { className: className, config: config, style: buttonStyle },
        b.label
      );
    }

    return h(
      'div',
      { className: 'tabs' },
      buttons.map(renderTab),
      h('div', { className: 'tabIndicator', style: indicatorStyle })
    );
  }
};

},{"../helper":209,"mithril/hyperscript":167}],255:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _loginModal = require('./loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var signupModal = {};

var isOpen = false;

function submit(form) {
  var login = form[0].value.trim();
  var email = form[1].value.trim();
  var pass = form[2].value.trim();
  if (!login || !email || !pass) return false;
  window.cordova.plugins.Keyboard.close();
  return _session2.default.signup(login, email, pass).then(function () {
    signupModal.close();
    _loginModal2.default.close();
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessfull'), 'short', 'center');
  }, function (error) {
    var data = error.response;
    if (data.error.username) {
      window.plugins.toast.show(data.error.username[0], 'short', 'center');
    } else if (data.error.password) {
      window.plugins.toast.show(data.error.password[0], 'short', 'center');
    }
  });
}

signupModal.open = function () {
  _backbutton2.default.stack.push(_helper2.default.slidesOutDown(signupModal.close, 'signupModal'));
  isOpen = true;
};

signupModal.close = function (fromBB) {
  window.cordova.plugins.Keyboard.close();
  if (fromBB !== 'backbutton' && isOpen) _backbutton2.default.stack.pop();
  isOpen = false;
};

signupModal.view = function () {
  if (!isOpen) return null;

  return (0, _mithril2.default)('div.modal#signupModal', { config: _helper2.default.slidesInUp }, [(0, _mithril2.default)('header', [(0, _mithril2.default)('button.modal_close[data-icon=L]', {
    config: _helper2.default.ontouch(_helper2.default.slidesOutDown(signupModal.close, 'signupModal'))
  }), (0, _mithril2.default)('h2', (0, _i18n2.default)('signUp'))]), (0, _mithril2.default)('div.modal_content', [(0, _mithril2.default)('p.signupWarning.withIcon[data-icon=!]', [(0, _i18n2.default)('computersAreNotAllowedToPlay')]), (0, _mithril2.default)('p.tosWarning', [(0, _i18n2.default)('byRegisteringYouAgreeToBeBoundByOur'), (0, _mithril2.default)('a', {}, (0, _i18n2.default)('termsOfService')), '.']), (0, _mithril2.default)('form.login', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      return submit(e.target);
    }
  }, [(0, _mithril2.default)('input#pseudo[type=text]', {
    placeholder: (0, _i18n2.default)('username'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: 'false',
    required: true
  }), (0, _mithril2.default)('input#email[type=email]', {
    placeholder: (0, _i18n2.default)('email'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: 'false',
    required: true
  }), (0, _mithril2.default)('input#password[type=password]', {
    placeholder: (0, _i18n2.default)('password'),
    required: true
  }), (0, _mithril2.default)('button.fat', (0, _i18n2.default)('signUp'))])])]);
};

exports.default = signupModal;

},{"../backbutton":189,"../i18n":191,"../session":197,"./helper":209,"./loginModal":215,"mithril":168}],256:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _userCtrl = require('./userCtrl');

var _userCtrl2 = _interopRequireDefault(_userCtrl);

var _userView = require('./userView');

var _userView2 = _interopRequireDefault(_userView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _userCtrl2.default,
  view: _userView2.default
};

},{"./userCtrl":257,"./userView":258}],257:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _userXhr = require('./userXhr');

var xhr = _interopRequireWildcard(_userXhr);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  _socket2.default.createDefault();

  var user = _mithril2.default.prop();

  xhr.user(_mithril2.default.route.param('id')).then(user, function (error) {
    utils.handleXhrError(error);
    _mithril2.default.route('/');
  }).then(_session2.default.refresh);

  return {
    user: user,
    isMe: function isMe() {
      return _session2.default.getUserId() === user().id;
    }
  };
}

},{"../../session":197,"../../socket":200,"../../utils":262,"../helper":209,"./userXhr":259,"mithril":168}],258:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _perf = require('../shared/perf');

var _perf2 = _interopRequireDefault(_perf);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import userPerfs from '../../oyunkeyf/perfs';
function view(ctrl) {
  var user = ctrl.user();

  if (!user) return null;

  function header() {
    var title = user.username;
    return (0, _common.header)(null, (0, _common.backButton)(title));
  }

  function profile() {
    // TODO
    // stats
    // ratings
    // actions
    return h(
      'div',
      { id: 'userProfile', className: 'native_scroller page' },
      renderStatus(user),
      renderProfile(user),
      renderRatings(user),
      renderActions(ctrl)
    );
  }

  return _layout2.default.free(header, profile);
}

function renderStatus(user) {
  var status = user.online ? 'online' : 'offline';
  return h(
    'section',
    { className: 'onlineStatus' },
    h('span', { className: 'userStatus ' + status, 'data-icon': 'r' }),
    (0, _i18n2.default)(status)
  );
}

function renderProfile(user) {
  if (!user.profile) return null;

  var fullName = '';
  if (user.profile.firstName) fullName += user.profile.firstName;
  if (user.profile.lastName) fullName += (user.profile.firstName ? ' ' : '') + user.profile.lastName;
  // const country = countries[user.profile.country];
  var location = user.profile.location;
  var memberSince = (0, _i18n2.default)('memberSince') + ' ' + window.moment(user.createdAt).format('LL');
  var seenAt = user.seenAt ? (0, _i18n2.default)('lastLogin') + ' ' + window.moment(user.seenAt).calendar() : null;

  return h(
    'section',
    { classname: 'profile' },
    fullName ? h(
      'h3',
      { className: 'fullname' },
      fullName
    ) : null,
    user.profile.bio ? h(
      'p',
      { className: 'profileBio' },
      user.profile.bio
    ) : null,
    h(
      'div',
      { className: 'userInfos' },
      user.language ? h(
        'p',
        { className: 'language withIcon' },
        h(
          'span',
          { className: 'fa fa-comment-o' },
          getLanguageNativeName(user.language)
        )
      ) : null,
      h(
        'p',
        { className: 'location' },
        location
      ),
      h(
        'p',
        { className: 'memberSince' },
        memberSince
      ),
      seenAt ? h(
        'p',
        { className: 'lastSeen' },
        seenAt
      ) : null
    )
  );
}

function renderRatings(user) {
  function isShowing(p) {
    return ['yuzbir', 'duzokey'].indexOf(p.key) !== -1 || p.perf.games > 0;
  }

  return h(
    'section',
    { id: 'userProfileRatings', className: 'perfs' },
    '// ',
    userPerfs(user).filter(isShowing).map(function (p) {
      return (0, _perf2.default)(p.key, p.name, p.perf, user);
    })
  );
}

function renderActions(ctrl) {
  var user = ctrl.user();
  return h(
    'section',
    { id: 'userProfileActions', 'class': 'noPadding' },
    h(
      'div',
      { className: 'list_item_nav',
        config: _helper2.default.ontouchY(ctrl.goToGames),
        key: 'view_all_games' },
      (0, _i18n2.default)('viewAllNbGames', user.count.all)
    )
  );
}

},{"../../i18n":191,"../../session":197,"../helper":209,"../layout":213,"../shared/common":248,"../shared/perf":250,"mithril/hyperscript":167}],259:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.user = user;

var _http = require('../../http');

function user(id) {
  var url = '/api/user/' + id;
  return (0, _http.request)(url, {}, true);
}

},{"../../http":190}],260:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForeground = isForeground;
exports.setForeground = setForeground;
exports.setBackground = setBackground;
var foreground = true;

function isForeground() {
  return foreground;
}

function setForeground() {
  foreground = true;
}

function setBackground() {
  foreground = false;
}

},{}],261:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.batchRequestAnimationFrame = batchRequestAnimationFrame;
var callbacks = new Set();
var batching = false;

function batchRequestAnimationFrame(callback) {
  callbacks.add(callback);
  if (!batching) {
    batching = true;
    requestAnimationFrame(function (ts) {
      var batch = callbacks;
      batching = false;
      callbacks = new Set();
      batch.forEach(function (f) {
        return f(ts);
      });
    });
  }
}

},{}],262:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.oyunkeyfSri = undefined;
exports.noop = noop;
exports.tellWorker = tellWorker;
exports.askWorker = askWorker;
exports.hasNetwork = hasNetwork;
exports.handleXhrError = handleXhrError;
exports.partialf = partialf;
exports.f = f;
exports.playerName = playerName;
exports.aiName = aiName;
exports.backHistory = backHistory;
exports.setViewSlideDirection = setViewSlideDirection;
exports.getViewSlideDirection = getViewSlideDirection;
exports.getBoardBounds = getBoardBounds;
exports.autoredraw = autoredraw;
exports.gameIcon = gameIcon;
exports.formatMasaDuration = formatMasaDuration;
exports.pad = pad;
exports.capitalize = capitalize;

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function noop() {}

var oyunkeyfSri = exports.oyunkeyfSri = Math.random().toString(36).substring(2);

function tellWorker(worker, topic, payload) {
  if (payload !== undefined) {
    worker.postMessage({ topic: topic, payload: payload });
  } else {
    worker.postMessage({ topic: topic });
  }
}

function askWorker(worker, msg, callback) {
  return new Promise(function (resolve) {
    function listen(e) {
      if (e.data.topic === msg.topic) {
        worker.removeEventListener('message', listen);
        if (callback) {
          callback(e.data.payload);
        } else {
          resolve(e.data.payload);
        }
      }
    }
    worker.addEventListener('message', listen);
    worker.postMessage(msg);
  });
}

function hasNetwork() {
  return window.navigator.connection.type !== Connection.NONE;
}

function handleXhrError(error) {
  var data = error.response,
      status = error.status;

  if (!hasNetwork()) {
    window.plugins.toast.show((0, _i18n2.default)('noInternetConnection'), 'short', 'center');
  } else {
    var message = void 0;
    if (!status || status === 0) {
      message = 'oyunkeyfIsUnreachable';
    } else if (status === 401) {
      message = 'unauthorizedError';
    } else if (status === 404) {
      message = 'resourceNotFoundError';
    } else if (status === 503) {
      message = 'oyunkeyfIsUnavailableError';
    } else if (status >= 500) {
      message = 'serverError';
    } else {
      message = 'Error.';
    }

    message = (0, _i18n2.default)(message);

    if (typeof data === 'string') {
      message += ' ' + data;
    } else if (data.global && data.global.constructor === Array) {
      message += ' ' + data.global[0];
    } else if (typeof data.error === 'string') {
      message += ' ' + data.error;
    }

    window.plugins.toast.show(message, 'short', 'center');
  }
}

function partialApply(fn, args) {
  return fn.bind.apply(fn, [null].concat(args));
}

function partialf() {
  return partialApply(arguments[0], Array.prototype.slice.call(arguments, 1));
}

function f() {
  var args = arguments,
      fn = arguments[0];
  return function () {
    fn.apply(fn, Array.prototype.slice.call(args, 1));
  };
}

function playerName(player, withRating) {
  if (player.username || player.user) {
    var name = player.username || player.user.username;
    return name;
  }
  if (player.ai) {
    return aiName(player.ai);
  }

  if (player.side) {
    return (0, _i18n2.default)(player.side);
  }

  return (0, _i18n2.default)('anonymous');
}

function aiName(level) {
  return (0, _i18n2.default)('aiBot', level);
}

function backHistory() {
  setViewSlideDirection('bwd');
  if (window.navigator.app && window.navigator.app.backHistory) {
    window.navigator.app.backHistory();
  } else window.history.go(-1);
}

// simple way to determine views animation direction
var viewSlideDirection = 'fwd';
function setViewSlideDirection(d) {
  viewSlideDirection = d;
}
function getViewSlideDirection() {
  return viewSlideDirection;
}

function getBoardBounds(viewportDim, isPortrait, isIpadLike, mode) {
  var vh = viewportDim.vh,
      vw = viewportDim.vw;

  var top = 50;

  if (isPortrait) {
    // const contentHeight = vh - 50;
    // const pTop = 50 + (mode === 'game' ? ((contentHeight - vw - 40) / 2) : 0);
    var contentHeight = vh;
    var pTop = 0;
    return {
      top: pTop,
      right: vw,
      bottom: pTop + vw,
      left: 0,
      width: vw,
      height: vw
    };
  } else {
    // const lSide = vh - top;
    var lSide = vh - 5;
    var lWidth = vw - 5; // lSide * (4/3);
    var spaceCenter = vw - lWidth;
    return {
      top: top,
      right: lSide,
      bottom: top + lSide,
      left: spaceCenter / 2,
      width: lWidth,
      height: lSide
    };
  }
}

function autoredraw(action) {
  _mithril2.default.startComputation();
  try {
    return action();
  } finally {
    _mithril2.default.endComputation();
  }
}

var perfIconsMap = {
  yuzbir: 'T',
  duzokey: '+'
};

function gameIcon(perf) {
  return perfIconsMap[perf] || '8';
}

function formatMasaDuration(rounds, scores) {
  return rounds ? rounds + (0, _i18n2.default)('hands') : scores + (0, _i18n2.default)('scores')[0];
}

function pad(num, size) {
  var s = num + '';
  while (s.length < size) {
    s = '0' + s;
  }return s;
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

},{"../i18n":191,"mithril":168}],263:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.redrawSync = undefined;
exports.default = redraw;

var _signals = require('../signals');

var _signals2 = _interopRequireDefault(_signals);

var _batchRAF = require('./batchRAF');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var redrawSync = exports.redrawSync = _signals2.default.redraw.dispatch;

function redraw() {
  console.trace();
  (0, _batchRAF.batchRequestAnimationFrame)(redrawSync);
}

},{"../signals":199,"./batchRAF":261}],264:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cachedPools = undefined;
exports.newGame = newGame;
exports.lobby = lobby;
exports.game = game;
exports.setServerLang = setServerLang;

var _http = require('./http');

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cachedPools = exports.cachedPools = [];

function newGame() {
  var config = _settings2.default.gameSetup.human;

  var data = {
    variant: config.variant(),
    rounds: config.rounds(),
    mode: _session2.default.isConnected() ? config.mode() : '0',
    membersOnly: _session2.default.isConnected() ? config.membersOnly() : false
  };

  return (0, _http.request)('/masa/new', {
    method: 'POST',
    data: data
  }, true);
}

function lobby(feedback) {
  return (0, _http.request)('/', null, feedback);
}

function game(id, background) {
  var url = '/' + id;
  return (0, _http.request)(url, { background: background }, true);
}

function setServerLang(lang) {
  if (_session2.default.isConnected()) {
    // return request('/translation/select', {
    //   method: 'POST',
    //   data: { lang }
    // });
    return Promise.resolve();
  } else {
    return Promise.resolve();
  }
}

},{"./http":190,"./session":197,"./settings":198}]},{},[192])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9va2V5Z3JvdW5kLW1vYmlsZS9idWlsZC9ub2RlX21vZHVsZXMvb2tleWdyb3VuZC1tb2JpbGUvYnVpbGQvb2tleWdyb3VuZC5taW4uanMiLCJub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLW5hbWUvaW5kZXguanNvbiIsIm5vZGVfbW9kdWxlcy9jb2xvci1zdHJpbmcvY29sb3Itc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yL2NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2lzY3JvbGwvYnVpbGQvaXNjcm9sbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0UGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlUmFuZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1BhdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9kZWJvdW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2ZvckluLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL21hcFZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbWVyZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3JhbmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdGhyb3R0bGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvRmluaXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b051bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9oeXBlcnNjcmlwdC5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL21pdGhyaWwuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvZnJhZ21lbnQuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvaHlwZXJzY3JpcHQuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9yZW5kZXIvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL3RydXN0LmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL3Zub2RlLmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvc3RyZWFtL3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9xL3EuanMiLCJub2RlX21vZHVsZXMvcWFuaW1hdGlvbmZyYW1lL3NyYy9xYW5pbWF0aW9uZnJhbWUuanMiLCJub2RlX21vZHVsZXMvcmxpdGUtcm91dGVyL3JsaXRlLmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbHMvZGlzdC9zaWduYWxzLmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdmVuZG9yLXByZWZpeC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy96YW5pbW8vc3JjL1phbmltby5qcyIsIm5vZGVfbW9kdWxlcy96YW5pbW8vc3JjL25vcm1hbGl6ZS10aW1pbmctZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvemFuaW1vL3NyYy9ub3JtYWxpemUtdHJhbnNmb3JtLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL3phbmltby9zcmMvdHJhbnNpdGlvbi1zaG9ydGhhbmQtcHJvcGVydHkuanMiLCJzcmMvYmFja2J1dHRvbi5qcyIsInNyYy9odHRwLmpzIiwic3JjL2kxOG4uanMiLCJzcmMvbWFpbi5qcyIsInNyYy9veXVua2V5Zi9nYW1lLmpzIiwic3JjL295dW5rZXlmL3N0YXR1cy5qcyIsInNyYy9yb3V0ZXIuanMiLCJzcmMvcm91dGVzLmpzIiwic3JjL3Nlc3Npb24uanMiLCJzcmMvc2V0dGluZ3MuanMiLCJzcmMvc2lnbmFscy5qcyIsInNyYy9zb2NrZXQuanMiLCJzcmMvc3Bpbm5lci5qcyIsInNyYy9zdG9yYWdlLmpzIiwic3JjL3VpL2dhbWUvZ2FtZUN0cmwuanMiLCJzcmMvdWkvZ2FtZS9nYW1lVmlldy5qcyIsInNyYy91aS9nYW1lL2luZGV4LmpzIiwic3JjL3VpL2dhbWVzTWVudS5qcyIsInNyYy91aS9oZWxwZXIvYW5pbWF0b3IuanMiLCJzcmMvdWkvaGVscGVyL2J1dHRvbi5qcyIsInNyYy91aS9oZWxwZXIvaW5kZXguanMiLCJzcmMvdWkvaG9tZS9ob21lQ3RybC5qcyIsInNyYy91aS9ob21lL2hvbWVWaWV3LmpzIiwic3JjL3VpL2hvbWUvaW5kZXguanMiLCJzcmMvdWkvbGF5b3V0LmpzIiwic3JjL3VpL2xvYmJ5LmpzIiwic3JjL3VpL2xvZ2luTW9kYWwuanMiLCJzcmMvdWkvbWFzYS9kZXRhaWwvaW5kZXguanMiLCJzcmMvdWkvbWFzYS9kZXRhaWwvbWFzYURldGFpbEN0cmwuanMiLCJzcmMvdWkvbWFzYS9kZXRhaWwvbWFzYURldGFpbFZpZXcuanMiLCJzcmMvdWkvbWFzYS9mYXEuanMiLCJzcmMvdWkvbWFzYS9pbmRleC5qcyIsInNyYy91aS9tYXNhL21hc2FDdHJsLmpzIiwic3JjL3VpL21hc2EvbWFzYVZpZXcuanMiLCJzcmMvdWkvbWFzYS9tYXNhWGhyLmpzIiwic3JjL3VpL21hc2EvcGxheWVySW5mby5qcyIsInNyYy91aS9tZW51L2luZGV4LmpzIiwic3JjL3VpL21lbnUvbWVudVZpZXcuanMiLCJzcmMvdWkvbmV3R2FtZUZvcm0uanMiLCJzcmMvdWkvcGxheWVycy9pbmRleC5qcyIsInNyYy91aS9wbGF5ZXJzL3BsYXllclhoci5qcyIsInNyYy91aS9wbGF5ZXJzL3BsYXllcnNDdHJsLmpzIiwic3JjL3VpL3BsYXllcnMvcGxheWVyc1ZpZXcuanMiLCJzcmMvdWkvcm91bmQvY2hhdC5qcyIsInNyYy91aS9yb3VuZC9jbG9jay9jbG9ja0N0cmwuanMiLCJzcmMvdWkvcm91bmQvY2xvY2svY2xvY2tWaWV3LmpzIiwic3JjL3VpL3JvdW5kL2RhdGEuanMiLCJzcmMvdWkvcm91bmQvZ3JvdW5kLmpzIiwic3JjL3VpL3JvdW5kL3JvdW5kQ3RybC5qcyIsInNyYy91aS9yb3VuZC9yb3VuZFhoci5qcyIsInNyYy91aS9yb3VuZC9zb2NrZXRIYW5kbGVyLmpzIiwic3JjL3VpL3JvdW5kL3V0aWwuanMiLCJzcmMvdWkvcm91bmQvdmlldy9idXR0b24uanMiLCJzcmMvdWkvcm91bmQvdmlldy9yb3VuZFZpZXcuanMiLCJzcmMvdWkvc2V0dGluZ3MvaW5kZXguanMiLCJzcmMvdWkvc2V0dGluZ3MvbGFuZy5qc3giLCJzcmMvdWkvc2hhcmVkL0JvYXJkLmpzIiwic3JjL3VpL3NoYXJlZC9QbGF5ZXJzLmpzIiwic3JjL3VpL3NoYXJlZC9WaWV3T25seUJvYXJkLmpzIiwic3JjL3VpL3NoYXJlZC9jb21tb24uanMiLCJzcmMvdWkvc2hhcmVkL2Zvcm0uanMiLCJzcmMvdWkvc2hhcmVkL3BlcmYuanMiLCJzcmMvdWkvc2hhcmVkL3BvcHVwLmpzIiwic3JjL3VpL3NoYXJlZC9zaWRlTWVudS9TaWRlTWVudUN0cmwuanMiLCJzcmMvdWkvc2hhcmVkL3NpZGVNZW51L2luZGV4LmpzIiwic3JjL3VpL3NoYXJlZC90YWJzLmpzIiwic3JjL3VpL3NpZ251cE1vZGFsLmpzIiwic3JjL3VpL3VzZXIvaW5kZXguanMiLCJzcmMvdWkvdXNlci91c2VyQ3RybC5qcyIsInNyYy91aS91c2VyL3VzZXJWaWV3LmpzIiwic3JjL3VpL3VzZXIvdXNlclhoci5qcyIsInNyYy91dGlscy9hcHBNb2RlLmpzIiwic3JjL3V0aWxzL2JhdGNoUkFGLmpzIiwic3JjL3V0aWxzL2luZGV4LmpzIiwic3JjL3V0aWxzL3JlZHJhdy5qcyIsInNyYy94aHIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNpRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeHVDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzEvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2o1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDRDs7QUFFTSxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkI7QUFDbEMsTUFBSSxrQkFBUSxXQUFSLEVBQUosRUFBMkI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPLFFBQVEsT0FBUixFQUFQO0FBQ0QsR0FORCxNQU1PO0FBQ0wsV0FBTyxRQUFRLE9BQVIsRUFBUDtBQUNEO0FBQ0YiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciB0O3Q9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLHQuT2tleWdyb3VuZD1lKCl9fShmdW5jdGlvbigpe3ZhciBlO3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIGEoaSx1KXtpZighbltpXSl7aWYoIXRbaV0pe3ZhciBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXUmJmwpcmV0dXJuIGwoaSwhMCk7aWYobylyZXR1cm4gbyhpLCEwKTt2YXIgZD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGQuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixkfXZhciBzPW5baV09e2V4cG9ydHM6e319O3RbaV1bMF0uY2FsbChzLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtpXVsxXVtlXTtyZXR1cm4gYShufHxlKX0scyxzLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIG89XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTxyLmxlbmd0aDtpKyspYShyW2ldKTtyZXR1cm4gYX1yZXR1cm4gZX0oKSh7MTpbZnVuY3Rpb24oZSx0LG4peyFmdW5jdGlvbihlKXtmdW5jdGlvbiBuKGUsdCl7aWYoXCJvYmplY3RcIiE9PWEoZSkpcmV0dXJuIHQ7Zm9yKHZhciByIGluIHQpXCJvYmplY3RcIj09PWEoZVtyXSkmJlwib2JqZWN0XCI9PT1hKHRbcl0pP2Vbcl09bihlW3JdLHRbcl0pOmVbcl09dFtyXTtyZXR1cm4gZX1mdW5jdGlvbiByKGUsdCxyKXt2YXIgaT1yWzBdLHU9ci5sZW5ndGg7KGV8fFwib2JqZWN0XCIhPT1hKGkpKSYmKGk9e30pO2Zvcih2YXIgbD0wO2w8dTsrK2wpe3ZhciBkPXJbbF0scz1hKGQpO2lmKFwib2JqZWN0XCI9PT1zKWZvcih2YXIgYyBpbiBkKWlmKFwiX19wcm90b19fXCIhPT1jKXt2YXIgZj1lP28uY2xvbmUoZFtjXSk6ZFtjXTt0P2lbY109bihpW2NdLGYpOmlbY109Zn19cmV0dXJuIGl9ZnVuY3Rpb24gYShlKXtyZXR1cm57fS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpLnRvTG93ZXJDYXNlKCl9dmFyIG89ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZT09PSEwLCExLGFyZ3VtZW50cyl9LGk9XCJtZXJnZVwiO28ucmVjdXJzaXZlPWZ1bmN0aW9uKGUpe3JldHVybiByKGU9PT0hMCwhMCxhcmd1bWVudHMpfSxvLmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0LG4scj1lLGk9YShlKTtpZihcImFycmF5XCI9PT1pKWZvcihyPVtdLG49ZS5sZW5ndGgsdD0wO3Q8bjsrK3Qpclt0XT1vLmNsb25lKGVbdF0pO2Vsc2UgaWYoXCJvYmplY3RcIj09PWkpe3I9e307Zm9yKHQgaW4gZSlyW3RdPW8uY2xvbmUoZVt0XSl9cmV0dXJuIHJ9LGU/dC5leHBvcnRzPW86d2luZG93W2ldPW99KFwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZcIm9iamVjdFwiPT10eXBlb2YgdC5leHBvcnRzJiZ0LmV4cG9ydHMpfSx7fV0sMjpbZnVuY3Rpb24odCxuLHIpeyFmdW5jdGlvbih0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXIodCk7XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyYmYS5kZXBzKHtkb2N1bWVudDpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6e30sbG9jYXRpb246XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGxvY2F0aW9uP2xvY2F0aW9uOnt9LGNsZWFyVGltZW91dDpjbGVhclRpbWVvdXQsc2V0VGltZW91dDpzZXRUaW1lb3V0fSksXCJvYmplY3RcIj09dHlwZW9mIG4mJm51bGwhPW4mJm4uZXhwb3J0cz9uLmV4cG9ydHM9YTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLmFtZD9lKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTp0Lm09YX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dGhpcyxmdW5jdGlvbiBhKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlfWZ1bmN0aW9uIHIoZSl7cmV0dXJuXCJbb2JqZWN0IE9iamVjdF1cIj09PURlLmNhbGwoZSl9ZnVuY3Rpb24gbyhlKXtyZXR1cm5cIltvYmplY3QgU3RyaW5nXVwiPT09RGUuY2FsbChlKX1mdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIHUoZSl7eGU9ZS5kb2N1bWVudCxTZT1lLmxvY2F0aW9uLE1lPWUuY2FuY2VsQW5pbWF0aW9uRnJhbWV8fGUuY2xlYXJUaW1lb3V0LEVlPWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxlLnNldFRpbWVvdXR9ZnVuY3Rpb24gbChlLHQpe2Zvcih2YXIgbixyPVtdLGE9Lyg/OihefCN8XFwuKShbXiNcXC5cXFtcXF1dKykpfChcXFsoLis/KSg/Olxccyo9XFxzKihcInwnfCkoKD86XFxcXFtcIidcXF1dfC4pKj8pXFw1KT9cXF0pL2c7bj1hLmV4ZWModCk7KWlmKFwiXCI9PT1uWzFdJiZuWzJdKWUudGFnPW5bMl07ZWxzZSBpZihcIiNcIj09PW5bMV0pZS5hdHRycy5pZD1uWzJdO2Vsc2UgaWYoXCIuXCI9PT1uWzFdKXIucHVzaChuWzJdKTtlbHNlIGlmKFwiW1wiPT09blszXS5jaGFyQXQoMCkpe3ZhciBvPW5bNl07byYmKG89by5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLFwiJDFcIikpLFwiY2xhc3NcIj09PW5bNF0/ci5wdXNoKG8pOmUuYXR0cnNbbls0XV09b3x8ITB9cmV0dXJuIHJ9ZnVuY3Rpb24gZChlLHQpe3ZhciBuPXQ/ZS5zbGljZSgxKTplO3JldHVybiAxPT09bi5sZW5ndGgmJktlKG5bMF0pP25bMF06bn1mdW5jdGlvbiBzKGUsdCxuKXt2YXIgcj1cImNsYXNzXCJpbiB0P1wiY2xhc3NcIjpcImNsYXNzTmFtZVwiO2Zvcih2YXIgYSBpbiB0KUNlLmNhbGwodCxhKSYmKGE9PT1yJiZudWxsIT10W2FdJiZcIlwiIT09dFthXT8obi5wdXNoKHRbYV0pLGVbYV09XCJcIik6ZVthXT10W2FdKTtuLmxlbmd0aCYmKGVbcl09bi5qb2luKFwiIFwiKSl9ZnVuY3Rpb24gYyhlLHQpe2Zvcih2YXIgYT1bXSxpPTEsdT1hcmd1bWVudHMubGVuZ3RoO2k8dTtpKyspYVtpLTFdPWFyZ3VtZW50c1tpXTtpZihlJiZuKGUudmlldykpcmV0dXJuIGFlKGUsYSk7aWYoIW8oZSkpdGhyb3cgbmV3IEVycm9yKFwic2VsZWN0b3IgaW4gbShzZWxlY3RvciwgYXR0cnMsIGNoaWxkcmVuKSBzaG91bGQgYmUgYSBzdHJpbmdcIik7dmFyIGM9bnVsbCE9dCYmcih0KSYmIShcInRhZ1wiaW4gdHx8XCJ2aWV3XCJpbiB0fHxcInN1YnRyZWVcImluIHQpLGY9Yz90Ont9LHA9e3RhZzpcImRpdlwiLGF0dHJzOnt9LGNoaWxkcmVuOmQoYSxjKX07cmV0dXJuIHMocC5hdHRycyxmLGwocCxlKSkscH1mdW5jdGlvbiBmKGUsdCl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aCYmIXQoZVtuXSxuKyspOyk7fWZ1bmN0aW9uIHAoZSx0KXtmKGUsZnVuY3Rpb24oZSxuKXtyZXR1cm4oZT1lJiZlLmF0dHJzKSYmbnVsbCE9ZS5rZXkmJnQoZSxuKX0pfWZ1bmN0aW9uIHYoZSl7dHJ5e2lmKFwiYm9vbGVhblwiIT10eXBlb2YgZSYmbnVsbCE9ZSYmbnVsbCE9ZS50b1N0cmluZygpKXJldHVybiBlfWNhdGNoKHQpe31yZXR1cm5cIlwifWZ1bmN0aW9uIG0oZSx0LG4scil7dHJ5e2goZSx0LG4pLHQubm9kZVZhbHVlPXJ9Y2F0Y2goYSl7fX1mdW5jdGlvbiBnKGUpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKUtlKGVbdF0pJiYoZT1lLmNvbmNhdC5hcHBseShbXSxlKSx0LS0pO3JldHVybiBlfWZ1bmN0aW9uIGgoZSx0LG4pe2UuaW5zZXJ0QmVmb3JlKHQsZS5jaGlsZE5vZGVzW25dfHxudWxsKX1mdW5jdGlvbiB5KGUsdCxuLHIpe3AoZSxmdW5jdGlvbihlLHIpe3RbZT1lLmtleV09dFtlXT97YWN0aW9uOmplLGluZGV4OnIsZnJvbTp0W2VdLmluZGV4LGVsZW1lbnQ6bi5ub2Rlc1t0W2VdLmluZGV4XXx8eGUuY3JlYXRlRWxlbWVudChcImRpdlwiKX06e2FjdGlvbjpCZSxpbmRleDpyfX0pO3ZhciBhPVtdO2Zvcih2YXIgbyBpbiB0KUNlLmNhbGwodCxvKSYmYS5wdXNoKHRbb10pO3ZhciBpPWEuc29ydChIKSx1PW5ldyBBcnJheShuLmxlbmd0aCk7cmV0dXJuIHUubm9kZXM9bi5ub2Rlcy5zbGljZSgpLGYoaSxmdW5jdGlvbih0KXt2YXIgYT10LmluZGV4O2lmKHQuYWN0aW9uPT09VGUmJihWKG5bYV0ubm9kZXMsblthXSksdS5zcGxpY2UoYSwxKSksdC5hY3Rpb249PT1CZSl7dmFyIG89eGUuY3JlYXRlRWxlbWVudChcImRpdlwiKTtvLmtleT1lW2FdLmF0dHJzLmtleSxoKHIsbyxhKSx1LnNwbGljZShhLDAse2F0dHJzOntrZXk6ZVthXS5hdHRycy5rZXl9LG5vZGVzOltvXX0pLHUubm9kZXNbYV09b31pZih0LmFjdGlvbj09PWplKXt2YXIgaT10LmVsZW1lbnQsbD1yLmNoaWxkTm9kZXNbYV07bCE9PWkmJm51bGwhPT1pJiZyLmluc2VydEJlZm9yZShpLGx8fG51bGwpLHVbYV09blt0LmZyb21dLHUubm9kZXNbYV09aX19KSx1fWZ1bmN0aW9uIHcoZSx0LG4scil7dmFyIGE9ZS5sZW5ndGghPT10Lmxlbmd0aDtyZXR1cm4gYXx8cChlLGZ1bmN0aW9uKGUsbil7dmFyIHI9dFtuXTtyZXR1cm4gYT1yJiZyLmF0dHJzJiZyLmF0dHJzLmtleSE9PWUua2V5fSksYT95KGUsbix0LHIpOnR9ZnVuY3Rpb24gYihlLHQsbil7ZihlLGZ1bmN0aW9uKGUscil7bnVsbCE9dFtyXSYmbi5wdXNoLmFwcGx5KG4sdFtyXS5ub2Rlcyl9KSxmKHQubm9kZXMsZnVuY3Rpb24oZSxyKXtudWxsIT1lLnBhcmVudE5vZGUmJm4uaW5kZXhPZihlKTwwJiZWKFtlXSxbdFtyXV0pfSksZS5sZW5ndGg8dC5sZW5ndGgmJih0Lmxlbmd0aD1lLmxlbmd0aCksdC5ub2Rlcz1ufWZ1bmN0aW9uIFAoZSl7dmFyIHQ9MDtwKGUsZnVuY3Rpb24oKXtyZXR1cm4gZihlLGZ1bmN0aW9uKGUpeyhlPWUmJmUuYXR0cnMpJiZudWxsPT1lLmtleSYmKGUua2V5PVwiX19taXRocmlsX19cIit0KyspfSksMX0pfWZ1bmN0aW9uIGsoZSx0LG4pe3JldHVybiBlLnRhZyE9PXQudGFnfHwobi5zb3J0KCkuam9pbigpIT09T2JqZWN0LmtleXModC5hdHRycykuc29ydCgpLmpvaW4oKXx8KGUuYXR0cnMuaWQhPT10LmF0dHJzLmlkfHwoZS5hdHRycy5rZXkhPT10LmF0dHJzLmtleXx8KFwiYWxsXCI9PT1jLnJlZHJhdy5zdHJhdGVneSgpPyF0LmNvbmZpZ0NvbnRleHR8fHQuY29uZmlnQ29udGV4dC5yZXRhaW4hPT0hMDpcImRpZmZcIj09PWMucmVkcmF3LnN0cmF0ZWd5KCkmJih0LmNvbmZpZ0NvbnRleHQmJnQuY29uZmlnQ29udGV4dC5yZXRhaW49PT0hMSkpKSkpfWZ1bmN0aW9uIE8oZSx0LHIpe2soZSx0LHIpJiYodC5ub2Rlcy5sZW5ndGgmJlYodC5ub2RlcyksdC5jb25maWdDb250ZXh0JiZuKHQuY29uZmlnQ29udGV4dC5vbnVubG9hZCkmJnQuY29uZmlnQ29udGV4dC5vbnVubG9hZCgpLHQuY29udHJvbGxlcnMmJmYodC5jb250cm9sbGVycyxmdW5jdGlvbihlKXtlLm9udW5sb2FkJiZlLm9udW5sb2FkKHtwcmV2ZW50RGVmYXVsdDppfSl9KSl9ZnVuY3Rpb24geChlLHQpe3JldHVybiBlLmF0dHJzLnhtbG5zP2UuYXR0cnMueG1sbnM6XCJzdmdcIj09PWUudGFnP1wiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjpcIm1hdGhcIj09PWUudGFnP1wiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiOnR9ZnVuY3Rpb24gUyhlLHQsbil7bi5sZW5ndGgmJihlLnZpZXdzPXQsZS5jb250cm9sbGVycz1uLGYobixmdW5jdGlvbihlKXtpZihlLm9udW5sb2FkJiZlLm9udW5sb2FkLiRvbGQmJihlLm9udW5sb2FkPWUub251bmxvYWQuJG9sZCksUmUmJmUub251bmxvYWQpe3ZhciB0PWUub251bmxvYWQ7ZS5vbnVubG9hZD1mdW5jdGlvbigpe30sZS5vbnVubG9hZC4kb2xkPXR9fSkpfWZ1bmN0aW9uIEUoZSx0LHIsYSxvKXtpZihuKHQuYXR0cnMuY29uZmlnKSl7dmFyIGk9by5jb25maWdDb250ZXh0PW8uY29uZmlnQ29udGV4dHx8e307ZS5wdXNoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXR0cnMuY29uZmlnLmNhbGwodCxyLCFhLGksbyl9KX19ZnVuY3Rpb24gTShlLG4scixhLG8saSx1LGwpe3ZhciBkPWUubm9kZXNbMF07cmV0dXJuIGEmJkooZCxuLnRhZyxuLmF0dHJzLGUuYXR0cnMsbyksZS5jaGlsZHJlbj1xKGQsbi50YWcsdCx0LG4uY2hpbGRyZW4sZS5jaGlsZHJlbiwhMSwwLG4uYXR0cnMuY29udGVudGVkaXRhYmxlP2Q6cixvLHUpLGUubm9kZXMuaW50YWN0PSEwLGwubGVuZ3RoJiYoZS52aWV3cz1pLGUuY29udHJvbGxlcnM9bCksZH1mdW5jdGlvbiBDKGUsdCxuKXt2YXIgcjtlLiR0cnVzdGVkP3I9ZWUodCxuLGUpOihyPVt4ZS5jcmVhdGVUZXh0Tm9kZShlKV0sdC5ub2RlTmFtZSBpbiBBZXx8aCh0LHJbMF0sbikpO3ZhciBhO3JldHVybiBhPVwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlP25ldyBlLmNvbnN0cnVjdG9yKGUpOmUsYS5ub2Rlcz1yLGF9ZnVuY3Rpb24gRChlLHQsbixyLGEsbyl7dmFyIGk9dC5ub2RlcztyZXR1cm4gciYmcj09PXhlLmFjdGl2ZUVsZW1lbnQmJmU9PT10fHwoZS4kdHJ1c3RlZD8oVihpLHQpLGk9ZWUobixhLGUpKTpcInRleHRhcmVhXCI9PT1vP24udmFsdWU9ZTpyPyhyLmlubmVySFRNTD1lLGk9W10uc2xpY2UuY2FsbChyLmNoaWxkTm9kZXMpKTooKDE9PT1pWzBdLm5vZGVUeXBlfHxpLmxlbmd0aD4xfHxpWzBdLm5vZGVWYWx1ZS50cmltJiYhaVswXS5ub2RlVmFsdWUudHJpbSgpKSYmKFYodC5ub2Rlcyx0KSxpPVt4ZS5jcmVhdGVUZXh0Tm9kZShlKV0pLG0obixpWzBdLGEsZSkpKSx0PW5ldyBlLmNvbnN0cnVjdG9yKGUpLHQubm9kZXM9aSx0LiR0cnVzdGVkPWUuJHRydXN0ZWQsdH1mdW5jdGlvbiBLKGUsdCxuLHIsYSxvLGkpe3JldHVybiBlLm5vZGVzLmxlbmd0aD9lLnZhbHVlT2YoKSE9PXQudmFsdWVPZigpfHxhP0QodCxlLHIsbyxuLGkpOihlLm5vZGVzLmludGFjdD0hMCxlKTpDKHQscixuKX1mdW5jdGlvbiBBKGUpe3JldHVybiBlLiR0cnVzdGVkP2Uubm9kZXMubGVuZ3RoOktlKGUpP2UubGVuZ3RoOjF9ZnVuY3Rpb24gVChlLG4scixhLG8saSx1LGwsZCl7ZT1nKGUpO3ZhciBzPVtdLGM9bi5sZW5ndGg9PT1lLmxlbmd0aCxmPTAsdj17fSxtPSExO3AobixmdW5jdGlvbihlLHQpe209ITAsdltuW3RdLmF0dHJzLmtleV09e2FjdGlvbjpUZSxpbmRleDp0fX0pLFAoZSksbSYmKG49dyhlLG4sdixyKSk7Zm9yKHZhciBoPTAseT0wLGs9ZS5sZW5ndGg7eTxrO3krKyl7dmFyIE89cShyLG8sbixhLGVbeV0sbltoXSxpLGErZnx8Zix1LGwsZCk7TyE9PXQmJihjPWMmJk8ubm9kZXMuaW50YWN0LGYrPUEoTyksbltoKytdPU8pfXJldHVybiBjfHxiKGUsbixzKSxufWZ1bmN0aW9uIEIoZSx0LG4scixhKXtpZihudWxsIT10KXtpZihEZS5jYWxsKHQpPT09RGUuY2FsbChlKSlyZXR1cm4gdDtpZihhJiZhLm5vZGVzKXt2YXIgbz1uLXIsaT1vKyhLZShlKT9lOnQubm9kZXMpLmxlbmd0aDtWKGEubm9kZXMuc2xpY2UobyxpKSxhLnNsaWNlKG8saSkpfWVsc2UgdC5ub2RlcyYmVih0Lm5vZGVzLHQpfXJldHVybiB0PW5ldyBlLmNvbnN0cnVjdG9yLHQudGFnJiYodD17fSksdC5ub2Rlcz1bXSx0fWZ1bmN0aW9uIGooZSx0KXtyZXR1cm4gZS5hdHRycy5pcz9udWxsPT10P3hlLmNyZWF0ZUVsZW1lbnQoZS50YWcsZS5hdHRycy5pcyk6eGUuY3JlYXRlRWxlbWVudE5TKHQsZS50YWcsZS5hdHRycy5pcyk6bnVsbD09dD94ZS5jcmVhdGVFbGVtZW50KGUudGFnKTp4ZS5jcmVhdGVFbGVtZW50TlModCxlLnRhZyl9ZnVuY3Rpb24gUihlLHQsbixyKXtyZXR1cm4gcj9KKHQsZS50YWcsZS5hdHRycyx7fSxuKTplLmF0dHJzfWZ1bmN0aW9uIE4oZSxuLHIsYSxvLGkpe3JldHVybiBudWxsIT1lLmNoaWxkcmVuJiZlLmNoaWxkcmVuLmxlbmd0aD4wP3EobixlLnRhZyx0LHQsZS5jaGlsZHJlbixyLmNoaWxkcmVuLCEwLDAsZS5hdHRycy5jb250ZW50ZWRpdGFibGU/bjphLG8saSk6ZS5jaGlsZHJlbn1mdW5jdGlvbiBHKGUsdCxuLHIsYSxvLGkpe3ZhciB1PXt0YWc6ZS50YWcsYXR0cnM6dCxjaGlsZHJlbjpuLG5vZGVzOltyXX07cmV0dXJuIFModSxvLGkpLHUuY2hpbGRyZW4mJiF1LmNoaWxkcmVuLm5vZGVzJiYodS5jaGlsZHJlbi5ub2Rlcz1bXSksdX1mdW5jdGlvbiBGKGUsdCxyLGEpe3ZhciBvO3JldHVybiBvPVwiZGlmZlwiPT09Yy5yZWRyYXcuc3RyYXRlZ3koKSYmZT9lLmluZGV4T2YodCk6LTEsbz4tMT9yW29dOm4oYSk/bmV3IGE6e319ZnVuY3Rpb24gXyhlLHQsbixyKXtudWxsIT1yLm9udW5sb2FkJiZHZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGFuZGxlcn0pLmluZGV4T2Yoci5vbnVubG9hZCk8MCYmR2UucHVzaCh7Y29udHJvbGxlcjpyLGhhbmRsZXI6ci5vbnVubG9hZH0pLGUucHVzaChuKSx0LnB1c2gocil9ZnVuY3Rpb24gTChlLHQsbixyLGEsbyl7dmFyIGk9RihuLnZpZXdzLHQscixlLmNvbnRyb2xsZXIpLHU9ZSYmZS5hdHRycyYmZS5hdHRycy5rZXk7cmV0dXJuIGU9MD09PVJlfHxGZXx8ciYmci5pbmRleE9mKGkpPi0xP2UudmlldyhpKTp7dGFnOlwicGxhY2Vob2xkZXJcIn0sXCJyZXRhaW5cIj09PWUuc3VidHJlZT9lOihlLmF0dHJzPWUuYXR0cnN8fHt9LGUuYXR0cnMua2V5PXUsXyhvLGEsdCxpKSxlKX1mdW5jdGlvbiBJKGUsdCxuLHIpe2Zvcih2YXIgYT10JiZ0LmNvbnRyb2xsZXJzO251bGwhPWUudmlldzspZT1MKGUsZS52aWV3LiRvcmlnaW5hbHx8ZS52aWV3LHQsYSxyLG4pO3JldHVybiBlfWZ1bmN0aW9uIFUoZSx0LG4scixhLGksdSxsKXt2YXIgZD1bXSxzPVtdO2lmKGU9SShlLHQsZCxzKSxcInJldGFpblwiPT09ZS5zdWJ0cmVlKXJldHVybiB0O2lmKCFlLnRhZyYmcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHRlbXBsYXRlIG11c3QgcmV0dXJuIGEgdmlydHVhbCBlbGVtZW50LCBub3QgYW4gYXJyYXksIHN0cmluZywgZXRjLlwiKTtlLmF0dHJzPWUuYXR0cnN8fHt9LHQuYXR0cnM9dC5hdHRyc3x8e307dmFyIGM9T2JqZWN0LmtleXMoZS5hdHRycyksZj1jLmxlbmd0aD4oXCJrZXlcImluIGUuYXR0cnM/MTowKTtpZihPKGUsdCxjKSxvKGUudGFnKSl7dmFyIHA9MD09PXQubm9kZXMubGVuZ3RoO3U9eChlLHUpO3ZhciB2O2lmKHApe3Y9aihlLHUpO3ZhciBtPVIoZSx2LHUsZik7aChyLHYsYSk7dmFyIGc9TihlLHYsdCxuLHUsbCk7dD1HKGUsbSxnLHYsdSxkLHMpfWVsc2Ugdj1NKHQsZSxuLGYsdSxkLGwscyk7cmV0dXJuXCJzZWxlY3RcIj09PWUudGFnJiZcInZhbHVlXCJpbiBlLmF0dHJzJiZKKHYsZS50YWcse3ZhbHVlOmUuYXR0cnMudmFsdWV9LHt9LHUpLHB8fGkhPT0hMHx8bnVsbD09dnx8aChyLHYsYSksRShsLGUsdixwLHQpLHR9fWZ1bmN0aW9uIHEoZSx0LGEsbyxpLHUsbCxkLHMsYyxmKXtyZXR1cm4gaT12KGkpLFwicmV0YWluXCI9PT1pLnN1YnRyZWU/dToodT1CKGksdSxkLG8sYSksS2UoaSk/VChpLHUsZSxkLHQsbCxzLGMsZik6bnVsbCE9aSYmcihpKT9VKGksdSxzLGUsZCxsLGMsZik6bihpKT91OksodSxpLGQsZSxsLHMsdCkpfWZ1bmN0aW9uIEgoZSx0KXtyZXR1cm4gZS5hY3Rpb24tdC5hY3Rpb258fGUuaW5kZXgtdC5pbmRleH1mdW5jdGlvbiBYKGUsdCxuKXtuPT09dCYmKGUuc3R5bGU9XCJcIixuPXt9KTtmb3IodmFyIHIgaW4gdClDZS5jYWxsKHQscikmJihudWxsIT1uJiZuW3JdPT09dFtyXXx8KGUuc3R5bGVbcl09dFtyXSkpO2ZvcihyIGluIG4pQ2UuY2FsbChuLHIpJiYoQ2UuY2FsbCh0LHIpfHwoZS5zdHlsZVtyXT1cIlwiKSl9ZnVuY3Rpb24geihlLHQsYSxvLGksdSl7aWYoXCJjb25maWdcIj09PXR8fFwia2V5XCI9PT10KXJldHVybiEwO2lmKG4oYSkmJlwib25cIj09PXQuc2xpY2UoMCwyKSllW3RdPXRlKGEsZSk7ZWxzZSBpZihcInN0eWxlXCI9PT10JiZudWxsIT1hJiZyKGEpKVgoZSxhLG8pO2Vsc2UgaWYobnVsbCE9dSlcImhyZWZcIj09PXQ/ZS5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcImhyZWZcIixhKTplLnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiPT09dD9cImNsYXNzXCI6dCxhKTtlbHNlIGlmKHQgaW4gZSYmIV9lW3RdKXRyeXsoXCJpbnB1dFwiIT09aSYmIWUuaXNDb250ZW50RWRpdGFibGV8fGVbdF0hPWEpJiYoZVt0XT1hKX1jYXRjaChsKXtlLnNldEF0dHJpYnV0ZSh0LGEpfWVsc2UgdHJ5e2Uuc2V0QXR0cmlidXRlKHQsYSl9Y2F0Y2gobCl7fX1mdW5jdGlvbiAkKGUsdCxuLHIsYSxvLGkpe2lmKHQgaW4gYSYmcj09PW4mJlwib2JqZWN0XCIhPXR5cGVvZiBuJiZ4ZS5hY3RpdmVFbGVtZW50IT09ZSlcInZhbHVlXCI9PT10JiZcImlucHV0XCI9PT1vJiZlLnZhbHVlIT1uJiYoZS52YWx1ZT1uKTtlbHNle2FbdF09bjt0cnl7cmV0dXJuIHooZSx0LG4scixvLGkpfWNhdGNoKHUpe2lmKHUubWVzc2FnZS5pbmRleE9mKFwiSW52YWxpZCBhcmd1bWVudFwiKTwwKXRocm93IHV9fX1mdW5jdGlvbiBKKGUsdCxuLHIsYSl7Zm9yKHZhciBvIGluIG4pIUNlLmNhbGwobixvKXx8ISQoZSxvLG5bb10scltvXSxyLHQsYSk7cmV0dXJuIHJ9ZnVuY3Rpb24gVihlLHQpe2Zvcih2YXIgbj1lLmxlbmd0aC0xO24+LTE7bi0tKWlmKGVbbl0mJmVbbl0ucGFyZW50Tm9kZSl7dHJ5e2Vbbl0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlW25dKX1jYXRjaChyKXt9dD1bXS5jb25jYXQodCksdFtuXSYmWSh0W25dKX1lLmxlbmd0aCYmKGUubGVuZ3RoPTApfWZ1bmN0aW9uIFkoZSl7ZS5jb25maWdDb250ZXh0JiZuKGUuY29uZmlnQ29udGV4dC5vbnVubG9hZCkmJihlLmNvbmZpZ0NvbnRleHQub251bmxvYWQoKSxlLmNvbmZpZ0NvbnRleHQub251bmxvYWQ9bnVsbCksZS5jb250cm9sbGVycyYmZihlLmNvbnRyb2xsZXJzLGZ1bmN0aW9uKGUpe24oZS5vbnVubG9hZCkmJmUub251bmxvYWQoe3ByZXZlbnREZWZhdWx0Oml9KX0pLGUuY2hpbGRyZW4mJihLZShlLmNoaWxkcmVuKT9mKGUuY2hpbGRyZW4sWSk6ZS5jaGlsZHJlbi50YWcmJlkoZS5jaGlsZHJlbikpfWZ1bmN0aW9uIFEoZSx0KXt0cnl7ZS5hcHBlbmRDaGlsZCh4ZS5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCh0KSl9Y2F0Y2gobil7ZS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIix0KSxXKGUpfX1mdW5jdGlvbiBXKGUpe2lmKFwiU0NSSVBUXCI9PT1lLnRhZ05hbWUpZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChaKGUpLGUpO2Vsc2V7dmFyIHQ9ZS5jaGlsZE5vZGVzO2lmKHQmJnQubGVuZ3RoKWZvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKVcodFtuXSl9cmV0dXJuIGV9ZnVuY3Rpb24gWihlKXtmb3IodmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxuPWUuYXR0cmlidXRlcyxyPTA7cjxuLmxlbmd0aDtyKyspdC5zZXRBdHRyaWJ1dGUobltyXS5uYW1lLG5bcl0udmFsdWUpO3JldHVybiB0LnRleHQ9ZS5pbm5lckhUTUwsdH1mdW5jdGlvbiBlZShlLHQsbil7dmFyIHI9ZS5jaGlsZE5vZGVzW3RdO2lmKHIpe3ZhciBhPTEhPT1yLm5vZGVUeXBlLG89eGUuY3JlYXRlRWxlbWVudChcInNwYW5cIik7YT8oZS5pbnNlcnRCZWZvcmUobyxyfHxudWxsKSxvLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWJlZ2luXCIsbiksZS5yZW1vdmVDaGlsZChvKSk6ci5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLG4pfWVsc2UgUShlLG4pO2Zvcih2YXIgaT1bXTtlLmNoaWxkTm9kZXNbdF0hPT1yOylpLnB1c2goZS5jaGlsZE5vZGVzW3RdKSx0Kys7cmV0dXJuIGl9ZnVuY3Rpb24gdGUoZSx0KXtyZXR1cm4gZnVuY3Rpb24obil7bj1ufHxldmVudCxjLnJlZHJhdy5zdHJhdGVneShcImRpZmZcIiksYy5zdGFydENvbXB1dGF0aW9uKCk7dHJ5e3JldHVybiBlLmNhbGwodCxuKX1maW5hbGx5e2xlKCl9fX1mdW5jdGlvbiBuZShlKXt2YXIgdD1JZS5pbmRleE9mKGUpO3JldHVybiB0PDA/SWUucHVzaChlKS0xOnR9ZnVuY3Rpb24gcmUoZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoJiYoZT1hcmd1bWVudHNbMF0pLGV9cmV0dXJuIHQudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIGUmJm4oZS50b0pTT04pP2UudG9KU09OKCk6ZX0sdH1mdW5jdGlvbiBhZShlLHQpe2Z1bmN0aW9uIG4oKXtyZXR1cm4oZS5jb250cm9sbGVyfHxpKS5hcHBseSh0aGlzLHQpfHx0aGlzfWZ1bmN0aW9uIHIobil7Zm9yKHZhciByPVtuXS5jb25jYXQodCksYT0xO2E8YXJndW1lbnRzLmxlbmd0aDthKyspci5wdXNoKGFyZ3VtZW50c1thXSk7cmV0dXJuIGUudmlldy5hcHBseShlLHIpfWUuY29udHJvbGxlciYmKG4ucHJvdG90eXBlPWUuY29udHJvbGxlci5wcm90b3R5cGUpLHIuJG9yaWdpbmFsPWUudmlldzt2YXIgYT17Y29udHJvbGxlcjpuLHZpZXc6cn07cmV0dXJuIHRbMF0mJm51bGwhPXRbMF0ua2V5JiYoYS5hdHRycz17a2V5OnRbMF0ua2V5fSksYX1mdW5jdGlvbiBvZShlLHQsbixyKXtpZighcil7Yy5yZWRyYXcuc3RyYXRlZ3koXCJhbGxcIiksYy5zdGFydENvbXB1dGF0aW9uKCksSGVbbl09dDt2YXIgYTthPXFlPWU/ZTplPXtjb250cm9sbGVyOml9O3ZhciBvPW5ldyhlLmNvbnRyb2xsZXJ8fGkpO3JldHVybiBhPT09cWUmJih6ZVtuXT1vLFhlW25dPWUpLGxlKCksbnVsbD09PWUmJmllKHQsbiksemVbbl19bnVsbD09ZSYmaWUodCxuKSxaZSYmKFdlPVplKX1mdW5jdGlvbiBpZShlLHQpe0hlLnNwbGljZSh0LDEpLHplLnNwbGljZSh0LDEpLFhlLnNwbGljZSh0LDEpLG1lKGUpLEllLnNwbGljZShuZShlKSwxKSxHZT1bXX1mdW5jdGlvbiB1ZSgpe1ZlJiYoVmUoKSxWZT1udWxsKSxmKEhlLGZ1bmN0aW9uKGUsdCl7dmFyIG49WGVbdF07aWYoemVbdF0pe3ZhciByPVt6ZVt0XV07Yy5yZW5kZXIoZSxuLnZpZXc/bi52aWV3KHplW3RdLHIpOlwiXCIpfX0pLFllJiYoWWUoKSxZZT1udWxsKSwkZT1udWxsLEplPW5ldyBEYXRlLGMucmVkcmF3LnN0cmF0ZWd5KFwiZGlmZlwiKX1mdW5jdGlvbiBsZSgpe1wibm9uZVwiPT09Yy5yZWRyYXcuc3RyYXRlZ3koKT8oUmUtLSxjLnJlZHJhdy5zdHJhdGVneShcImRpZmZcIikpOmMuZW5kQ29tcHV0YXRpb24oKX1mdW5jdGlvbiBkZShlKXtyZXR1cm4gZS5zbGljZShudFtjLnJvdXRlLm1vZGVdLmxlbmd0aCl9ZnVuY3Rpb24gc2UoZSx0LG4pe3R0PXt9O3ZhciByPW4uaW5kZXhPZihcIj9cIik7ciE9PS0xJiYodHQ9dmUobi5zdWJzdHIocisxLG4ubGVuZ3RoKSksbj1uLnN1YnN0cigwLHIpKTt2YXIgYT1PYmplY3Qua2V5cyh0KSxvPWEuaW5kZXhPZihuKTtpZihvIT09LTEpcmV0dXJuIGMubW91bnQoZSx0W2Fbb11dKSwhMDtmb3IodmFyIGkgaW4gdClpZihDZS5jYWxsKHQsaSkpe2lmKGk9PT1uKXJldHVybiBjLm1vdW50KGUsdFtpXSksITA7dmFyIHU9bmV3IFJlZ0V4cChcIl5cIitpLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLFwiKC4qPylcIikucmVwbGFjZSgvOlteXFwvXSsvZyxcIihbXlxcXFwvXSspXCIpK1wiLz8kXCIpO2lmKHUudGVzdChuKSlyZXR1cm4gbi5yZXBsYWNlKHUsZnVuY3Rpb24oKXt2YXIgbj1pLm1hdGNoKC86W15cXC9dKy9nKXx8W10scj1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxLC0yKTtmKG4sZnVuY3Rpb24oZSx0KXt0dFtlLnJlcGxhY2UoLzp8XFwuL2csXCJcIildPWRlY29kZVVSSUNvbXBvbmVudChyW3RdKX0pLGMubW91bnQoZSx0W2ldKX0pLCEwfX1mdW5jdGlvbiBjZShlKXtpZihlPWV8fGV2ZW50LCEoZS5jdHJsS2V5fHxlLm1ldGFLZXl8fGUuc2hpZnRLZXl8fDI9PT1lLndoaWNoKSl7ZS5wcmV2ZW50RGVmYXVsdD9lLnByZXZlbnREZWZhdWx0KCk6ZS5yZXR1cm5WYWx1ZT0hMTt2YXIgdCxuPWUuY3VycmVudFRhcmdldHx8ZS5zcmNFbGVtZW50O2Zvcih0PVwicGF0aG5hbWVcIj09PWMucm91dGUubW9kZSYmbi5zZWFyY2g/dmUobi5zZWFyY2guc2xpY2UoMSkpOnt9O24mJiEvYS9pLnRlc3Qobi5ub2RlTmFtZSk7KW49bi5wYXJlbnROb2RlO1JlPTAsYy5yb3V0ZShuW2Mucm91dGUubW9kZV0uc2xpY2UobnRbYy5yb3V0ZS5tb2RlXS5sZW5ndGgpLHQpfX1mdW5jdGlvbiBmZSgpe1wiaGFzaFwiIT09Yy5yb3V0ZS5tb2RlJiZTZS5oYXNoP1NlLmhhc2g9U2UuaGFzaDplLnNjcm9sbFRvKDAsMCl9ZnVuY3Rpb24gcGUoZSxuKXt2YXIgYT17fSxvPVtdO2Zvcih2YXIgaSBpbiBlKWlmKENlLmNhbGwoZSxpKSl7dmFyIHU9bj9uK1wiW1wiK2krXCJdXCI6aSxsPWVbaV07aWYobnVsbD09PWwpby5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1KSk7ZWxzZSBpZihyKGwpKW8ucHVzaChwZShsLHUpKTtlbHNlIGlmKEtlKGwpKXt2YXIgZD1bXTthW3VdPWFbdV18fHt9LGYobCxmdW5jdGlvbihlKXthW3VdW2VdfHwoYVt1XVtlXT0hMCxkLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHUpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChlKSkpfSksby5wdXNoKGQuam9pbihcIiZcIikpfWVsc2UgbCE9PXQmJm8ucHVzaChlbmNvZGVVUklDb21wb25lbnQodSkrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGwpKX1yZXR1cm4gby5qb2luKFwiJlwiKX1mdW5jdGlvbiB2ZShlKXtpZihcIlwiPT09ZXx8bnVsbD09ZSlyZXR1cm57fTtcIj9cIj09PWUuY2hhckF0KDApJiYoZT1lLnNsaWNlKDEpKTt2YXIgdD1lLnNwbGl0KFwiJlwiKSxuPXt9O3JldHVybiBmKHQsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIj1cIikscj1kZWNvZGVVUklDb21wb25lbnQodFswXSksYT0yPT09dC5sZW5ndGg/ZGVjb2RlVVJJQ29tcG9uZW50KHRbMV0pOm51bGw7bnVsbCE9bltyXT8oS2UobltyXSl8fChuW3JdPVtuW3JdXSksbltyXS5wdXNoKGEpKTpuW3JdPWF9KSxufWZ1bmN0aW9uIG1lKGUpe3ZhciBuPW5lKGUpO1YoZS5jaGlsZE5vZGVzLFVlW25dKSxVZVtuXT10fWZ1bmN0aW9uIGdlKGUsdCl7dmFyIG49Yy5wcm9wKHQpO3JldHVybiBlLnRoZW4obiksbi50aGVuPWZ1bmN0aW9uKG4scil7cmV0dXJuIGdlKGUudGhlbihuLHIpLHQpfSxuW1wiY2F0Y2hcIl09bi50aGVuLmJpbmQobnVsbCxudWxsKSxufWZ1bmN0aW9uIGhlKGUsdCl7ZnVuY3Rpb24gYShlKXtsPWV8fGx0LHMubWFwKGZ1bmN0aW9uKGUpe2w9PT11dD9lLnJlc29sdmUoZCk6ZS5yZWplY3QoZCl9KX1mdW5jdGlvbiBvKGUsdCxhLG8pe2lmKChudWxsIT1kJiZyKGQpfHxuKGQpKSYmbihlKSl0cnl7dmFyIGk9MDtlLmNhbGwoZCxmdW5jdGlvbihlKXtpKyt8fChkPWUsdCgpKX0sZnVuY3Rpb24oZSl7aSsrfHwoZD1lLGEoKSl9KX1jYXRjaCh1KXtjLmRlZmVycmVkLm9uZXJyb3IodSksZD11LGEoKX1lbHNlIG8oKX1mdW5jdGlvbiBpKCl7dmFyIHI7dHJ5e3I9ZCYmZC50aGVufWNhdGNoKHMpe3JldHVybiBjLmRlZmVycmVkLm9uZXJyb3IocyksZD1zLGw9aXQsaSgpfWw9PT1pdCYmYy5kZWZlcnJlZC5vbmVycm9yKGQpLG8ocixmdW5jdGlvbigpe2w9b3QsaSgpfSxmdW5jdGlvbigpe2w9aXQsaSgpfSxmdW5jdGlvbigpe3RyeXtsPT09b3QmJm4oZSk/ZD1lKGQpOmw9PT1pdCYmbih0KSYmKGQ9dChkKSxsPW90KX1jYXRjaChpKXtyZXR1cm4gYy5kZWZlcnJlZC5vbmVycm9yKGkpLGQ9aSxhKCl9ZD09PXU/KGQ9VHlwZUVycm9yKCksYSgpKTpvKHIsZnVuY3Rpb24oKXthKHV0KX0sYSxmdW5jdGlvbigpe2EobD09PW90JiZ1dCl9KX0pfXZhciB1PXRoaXMsbD0wLGQ9MCxzPVtdO3UucHJvbWlzZT17fSx1LnJlc29sdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGx8fChkPWUsbD1vdCxpKCkpLHV9LHUucmVqZWN0PWZ1bmN0aW9uKGUpe3JldHVybiBsfHwoZD1lLGw9aXQsaSgpKSx1fSx1LnByb21pc2UudGhlbj1mdW5jdGlvbihlLHQpe3ZhciBuPW5ldyBoZShlLHQpO3JldHVybiBsPT09dXQ/bi5yZXNvbHZlKGQpOmw9PT1sdD9uLnJlamVjdChkKTpzLnB1c2gobiksbi5wcm9taXNlfX1mdW5jdGlvbiB5ZShlKXtyZXR1cm4gZX1mdW5jdGlvbiB3ZShuKXt2YXIgcj1uLmNhbGxiYWNrTmFtZXx8XCJtaXRocmlsX2NhbGxiYWNrX1wiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpK1wiX1wiK01hdGgucm91bmQoMWUxNipNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNiksYT14ZS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2Vbcl09ZnVuY3Rpb24obyl7YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLG4ub25sb2FkKHt0eXBlOlwibG9hZFwiLHRhcmdldDp7cmVzcG9uc2VUZXh0Om99fSksZVtyXT10fSxhLm9uZXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLG4ub25lcnJvcih7dHlwZTpcImVycm9yXCIsdGFyZ2V0OntzdGF0dXM6NTAwLHJlc3BvbnNlVGV4dDpKU09OLnN0cmluZ2lmeSh7ZXJyb3I6XCJFcnJvciBtYWtpbmcganNvbnAgcmVxdWVzdFwifSl9fSksZVtyXT10LCExfSxhLm9ubG9hZD1mdW5jdGlvbigpe3JldHVybiExfSxhLnNyYz1uLnVybCsobi51cmwuaW5kZXhPZihcIj9cIik+MD9cIiZcIjpcIj9cIikrKG4uY2FsbGJhY2tLZXk/bi5jYWxsYmFja0tleTpcImNhbGxiYWNrXCIpK1wiPVwiK3IrXCImXCIrcGUobi5kYXRhfHx7fSkseGUuYm9keS5hcHBlbmRDaGlsZChhKX1mdW5jdGlvbiBiZSh0KXt2YXIgYT1uZXcgZS5YTUxIdHRwUmVxdWVzdDtpZihhLm9wZW4odC5tZXRob2QsdC51cmwsITAsdC51c2VyLHQucGFzc3dvcmQpLGEub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ND09PWEucmVhZHlTdGF0ZSYmKGEuc3RhdHVzPj0yMDAmJmEuc3RhdHVzPDMwMD90Lm9ubG9hZCh7dHlwZTpcImxvYWRcIix0YXJnZXQ6YX0pOnQub25lcnJvcih7dHlwZTpcImVycm9yXCIsdGFyZ2V0OmF9KSl9LHQuc2VyaWFsaXplPT09SlNPTi5zdHJpbmdpZnkmJnQuZGF0YSYmXCJHRVRcIiE9PXQubWV0aG9kJiZhLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIiksdC5kZXNlcmlhbGl6ZT09PUpTT04ucGFyc2UmJmEuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC8qXCIpLHIodC5oZWFkZXJzKSlmb3IodmFyIGkgaW4gdC5oZWFkZXJzKUNlLmNhbGwodC5oZWFkZXJzLGkpJiZhLnNldFJlcXVlc3RIZWFkZXIoaSx0LmhlYWRlcnNbaV0pO2lmKG4odC5jb25maWcpKXt2YXIgdT10LmNvbmZpZyhhLHQpO251bGwhPXUmJihhPXUpfXZhciBsPVwiR0VUXCIhPT10Lm1ldGhvZCYmdC5kYXRhP3QuZGF0YTpcIlwiO2lmKGwmJiFvKGwpJiZsLmNvbnN0cnVjdG9yIT09ZS5Gb3JtRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGRhdGEgc2hvdWxkIGJlIGVpdGhlciBiZSBhIHN0cmluZyBvciBGb3JtRGF0YS4gQ2hlY2sgdGhlIGBzZXJpYWxpemVgIG9wdGlvbiBpbiBgbS5yZXF1ZXN0YFwiKTtyZXR1cm4gYS5zZW5kKGwpLGF9ZnVuY3Rpb24gUGUoZSl7cmV0dXJuIGUuZGF0YVR5cGUmJlwianNvbnBcIj09PWUuZGF0YVR5cGUudG9Mb3dlckNhc2UoKT93ZShlKTpiZShlKX1mdW5jdGlvbiBrZShlLHQsbil7aWYoXCJHRVRcIj09PWUubWV0aG9kJiZcImpzb25wXCIhPT1lLmRhdGFUeXBlKXt2YXIgcj1lLnVybC5pbmRleE9mKFwiP1wiKTwwP1wiP1wiOlwiJlwiLGE9cGUodCk7ZS51cmwrPWE/cithOlwiXCJ9ZWxzZSBlLmRhdGE9bih0KX1mdW5jdGlvbiBPZShlLHQpe3JldHVybiB0JiYoZT1lLnJlcGxhY2UoLzpbYS16XVxcdysvZ2ksZnVuY3Rpb24oZSl7dmFyIG49ZS5zbGljZSgxKSxyPXRbbl18fGU7cmV0dXJuIGRlbGV0ZSB0W25dLHJ9KSksZX1jLnZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm5cInYwLjIuOFwifTt2YXIgeGUsU2UsRWUsTWUsQ2U9e30uaGFzT3duUHJvcGVydHksRGU9e30udG9TdHJpbmcsS2U9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09RGUuY2FsbChlKX0sQWU9e0FSRUE6MSxCQVNFOjEsQlI6MSxDT0w6MSxDT01NQU5EOjEsRU1CRUQ6MSxIUjoxLElNRzoxLElOUFVUOjEsS0VZR0VOOjEsTElOSzoxLE1FVEE6MSxQQVJBTToxLFNPVVJDRToxLFRSQUNLOjEsV0JSOjF9O2MuZGVwcz1mdW5jdGlvbih0KXtyZXR1cm4gdShlPXR8fHdpbmRvdyksZX0sYy5kZXBzLmZhY3Rvcnk9Yy5mYWN0b3J5PWEsYy5kZXBzKGUpO3ZhciBUZT0xLEJlPTIsamU9MyxSZT0wO2Muc3RhcnRDb21wdXRhdGlvbj1mdW5jdGlvbigpe1JlKyt9LGMuZW5kQ29tcHV0YXRpb249ZnVuY3Rpb24oKXtSZT4xP1JlLS06KFJlPTAsYy5yZWRyYXcoKSl9O3ZhciBOZSxHZT1bXSxGZT0hMSxfZT17bGlzdDoxLHN0eWxlOjEsZm9ybToxLHR5cGU6MSx3aWR0aDoxLGhlaWdodDoxfSxMZT17YXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oZSl7TmU9PT10JiYoTmU9eGUuY3JlYXRlRWxlbWVudChcImh0bWxcIikpLHhlLmRvY3VtZW50RWxlbWVudCYmeGUuZG9jdW1lbnRFbGVtZW50IT09ZT94ZS5yZXBsYWNlQ2hpbGQoZSx4ZS5kb2N1bWVudEVsZW1lbnQpOnhlLmFwcGVuZENoaWxkKGUpLHRoaXMuY2hpbGROb2Rlcz14ZS5jaGlsZE5vZGVzfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24oZSl7dGhpcy5hcHBlbmRDaGlsZChlKX0sY2hpbGROb2RlczpbXX0sSWU9W10sVWU9e307Yy5yZW5kZXI9ZnVuY3Rpb24oZSxuLHIpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKTt2YXIgYSxvPVtdLGk9bmUoZSksdT1lPT09eGU7YT11fHxlPT09eGUuZG9jdW1lbnRFbGVtZW50P0xlOmUsdSYmXCJodG1sXCIhPT1uLnRhZyYmKG49e3RhZzpcImh0bWxcIixhdHRyczp7fSxjaGlsZHJlbjpufSksVWVbaV09PT10JiZWKGEuY2hpbGROb2Rlcykscj09PSEwJiZtZShlKSxVZVtpXT1xKGEsbnVsbCx0LHQsbixVZVtpXSwhMSwwLG51bGwsdCxvKSxmKG8sZnVuY3Rpb24oZSl7ZSgpfSl9LGMudHJ1c3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9bmV3IFN0cmluZyhlKSxlLiR0cnVzdGVkPSEwLGV9LGMucHJvcD1mdW5jdGlvbihlKXtyZXR1cm4obnVsbCE9ZSYmKHIoZSl8fG4oZSkpfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgUHJvbWlzZSYmZSBpbnN0YW5jZW9mIFByb21pc2UpJiZuKGUudGhlbik/Z2UoZSk6cmUoZSl9O3ZhciBxZSxIZT1bXSxYZT1bXSx6ZT1bXSwkZT1udWxsLEplPTAsVmU9bnVsbCxZZT1udWxsLFFlPTE2O2MuY29tcG9uZW50PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO3JldHVybiBhZShlLHQpfTt2YXIgV2UsWmU7Yy5tb3VudD1jLm1vZHVsZT1mdW5jdGlvbihlLHQpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKTt2YXIgcj1IZS5pbmRleE9mKGUpO3I8MCYmKHI9SGUubGVuZ3RoKTt2YXIgYT0hMSxvPXtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe2E9ITAsVmU9WWU9bnVsbH19O3JldHVybiBmKEdlLGZ1bmN0aW9uKGUpe2UuaGFuZGxlci5jYWxsKGUuY29udHJvbGxlcixvKSxlLmNvbnRyb2xsZXIub251bmxvYWQ9bnVsbH0pLGE/ZihHZSxmdW5jdGlvbihlKXtlLmNvbnRyb2xsZXIub251bmxvYWQ9ZS5oYW5kbGVyfSk6R2U9W10semVbcl0mJm4oemVbcl0ub251bmxvYWQpJiZ6ZVtyXS5vbnVubG9hZChvKSxvZSh0LGUscixhKX07dmFyIGV0PSExO2MucmVkcmF3PWZ1bmN0aW9uKHQpe2lmKCFldCl7ZXQ9ITAsdCYmKEZlPSEwKTt0cnl7JGUmJiF0PyhFZT09PWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxuZXcgRGF0ZS1KZT5RZSkmJigkZT4wJiZNZSgkZSksJGU9RWUodWUsUWUpKToodWUoKSwkZT1FZShmdW5jdGlvbigpeyRlPW51bGx9LFFlKSl9ZmluYWxseXtldD1GZT0hMX19fSxjLnJlZHJhdy5zdHJhdGVneT1jLnByb3AoKSxjLndpdGhBdHRyPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocil7cj1yfHx3aW5kb3cuZXZlbnQ7dmFyIGE9ci5jdXJyZW50VGFyZ2V0fHx0aGlzLG89bnx8dGhpcyxpPWUgaW4gYT9hW2VdOmEuZ2V0QXR0cmlidXRlKGUpO3QuY2FsbChvLGkpfX07dmFyIHR0LG50PXtwYXRobmFtZTpcIlwiLGhhc2g6XCIjXCIsc2VhcmNoOlwiP1wifSxydD1pLGF0PSExO2Mucm91dGU9ZnVuY3Rpb24odCxuLHIsYSl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIFdlO2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoJiZvKG4pKXtydD1mdW5jdGlvbihlKXt2YXIgYT1XZT1kZShlKTtpZighc2UodCxyLGEpKXtpZihhdCl0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIGRlZmF1bHQgcm91dGUgbWF0Y2hlcyBvbmUgb2YgdGhlIHJvdXRlcyBkZWZpbmVkIGluIG0ucm91dGVcIik7YXQ9ITAsYy5yb3V0ZShuLCEwKSxhdD0hMX19O3ZhciBpPVwiaGFzaFwiPT09Yy5yb3V0ZS5tb2RlP1wib25oYXNoY2hhbmdlXCI6XCJvbnBvcHN0YXRlXCI7cmV0dXJuIGVbaV09ZnVuY3Rpb24oKXt2YXIgZT1TZVtjLnJvdXRlLm1vZGVdO1wicGF0aG5hbWVcIj09PWMucm91dGUubW9kZSYmKGUrPVNlLnNlYXJjaCksV2UhPT1kZShlKSYmcnQoZSl9LFZlPWZlLHZvaWQgZVtpXSgpfWlmKHQuYWRkRXZlbnRMaXN0ZW5lcnx8dC5hdHRhY2hFdmVudCl7dmFyIHU9XCJwYXRobmFtZVwiIT09Yy5yb3V0ZS5tb2RlP1NlLnBhdGhuYW1lOlwiXCI7cmV0dXJuIHQuaHJlZj11K250W2Mucm91dGUubW9kZV0rYS5hdHRycy5ocmVmLHZvaWQodC5hZGRFdmVudExpc3RlbmVyPyh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGNlKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGNlKSk6KHQuZGV0YWNoRXZlbnQoXCJvbmNsaWNrXCIsY2UpLHQuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsY2UpKSl9aWYobyh0KSl7WmU9V2UsV2U9dDt2YXIgbCxkPW58fHt9LHM9V2UuaW5kZXhPZihcIj9cIik7bD1zPi0xP3ZlKFdlLnNsaWNlKHMrMSkpOnt9O2Zvcih2YXIgZiBpbiBkKUNlLmNhbGwoZCxmKSYmKGxbZl09ZFtmXSk7dmFyIHAsdj1wZShsKTtwPXM+LTE/V2Uuc2xpY2UoMCxzKTpXZSx2JiYoV2U9cCsocC5pbmRleE9mKFwiP1wiKT09PS0xP1wiP1wiOlwiJlwiKSt2KTt2YXIgbT0oMz09PWFyZ3VtZW50cy5sZW5ndGg/cjpuKT09PSEwfHxaZT09PVdlO2lmKGUuaGlzdG9yeS5wdXNoU3RhdGUpe3ZhciBnPW0/XCJyZXBsYWNlU3RhdGVcIjpcInB1c2hTdGF0ZVwiO1ZlPWZlLFllPWZ1bmN0aW9uKCl7dHJ5e2UuaGlzdG9yeVtnXShudWxsLHhlLnRpdGxlLG50W2Mucm91dGUubW9kZV0rV2UpfWNhdGNoKHQpe1NlW2Mucm91dGUubW9kZV09V2V9fSxydChudFtjLnJvdXRlLm1vZGVdK1dlKX1lbHNlIFNlW2Mucm91dGUubW9kZV09V2UscnQobnRbYy5yb3V0ZS5tb2RlXStXZSk7WmU9bnVsbH19LGMucm91dGUucGFyYW09ZnVuY3Rpb24oZSl7aWYoIXR0KXRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IGNhbGwgbS5yb3V0ZShlbGVtZW50LCBkZWZhdWx0Um91dGUsIHJvdXRlcykgYmVmb3JlIGNhbGxpbmcgbS5yb3V0ZS5wYXJhbSgpXCIpO3JldHVybiBlP3R0W2VdOnR0fSxjLnJvdXRlLm1vZGU9XCJzZWFyY2hcIixjLnJvdXRlLmJ1aWxkUXVlcnlTdHJpbmc9cGUsYy5yb3V0ZS5wYXJzZVF1ZXJ5U3RyaW5nPXZlLGMuZGVmZXJyZWQ9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgaGU7cmV0dXJuIGUucHJvbWlzZT1nZShlLnByb21pc2UpLGV9O3ZhciBvdD0xLGl0PTIsdXQ9MyxsdD00O3JldHVybiBjLmRlZmVycmVkLm9uZXJyb3I9ZnVuY3Rpb24oZSl7aWYoXCJbb2JqZWN0IEVycm9yXVwiPT09RGUuY2FsbChlKSYmIS8gRXJyb3IvLnRlc3QoZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpKSl0aHJvdyBSZT0wLGV9LGMuc3luYz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiBhW2VdPWksdHx8KG89XCJyZWplY3RcIiksMD09PS0tciYmKG4ucHJvbWlzZShhKSxuW29dKGEpKSxpfX12YXIgbj1jLmRlZmVycmVkKCkscj1lLmxlbmd0aCxhPVtdLG89XCJyZXNvbHZlXCI7cmV0dXJuIGUubGVuZ3RoPjA/ZihlLGZ1bmN0aW9uKGUsbil7ZS50aGVuKHQobiwhMCksdChuLCExKSl9KTpuLnJlc29sdmUoW10pLG4ucHJvbWlzZX0sYy5yZXF1ZXN0PWZ1bmN0aW9uKGUpe2UuYmFja2dyb3VuZCE9PSEwJiZjLnN0YXJ0Q29tcHV0YXRpb24oKTt2YXIgdCxuLHIsYT1uZXcgaGUsbz1lLmRhdGFUeXBlJiZcImpzb25wXCI9PT1lLmRhdGFUeXBlLnRvTG93ZXJDYXNlKCk7cmV0dXJuIG8/KHQ9ZS5zZXJpYWxpemU9bj1lLmRlc2VyaWFsaXplPXllLHI9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVzcG9uc2VUZXh0fSk6KHQ9ZS5zZXJpYWxpemU9ZS5zZXJpYWxpemV8fEpTT04uc3RyaW5naWZ5LG49ZS5kZXNlcmlhbGl6ZT1lLmRlc2VyaWFsaXplfHxKU09OLnBhcnNlLHI9ZS5leHRyYWN0fHxmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXNwb25zZVRleHQubGVuZ3RofHxuIT09SlNPTi5wYXJzZT9lLnJlc3BvbnNlVGV4dDpudWxsfSksZS5tZXRob2Q9KGUubWV0aG9kfHxcIkdFVFwiKS50b1VwcGVyQ2FzZSgpLGUudXJsPU9lKGUudXJsLGUuZGF0YSksa2UoZSxlLmRhdGEsdCksZS5vbmxvYWQ9ZS5vbmVycm9yPWZ1bmN0aW9uKHQpe3RyeXt0PXR8fGV2ZW50O3ZhciBvPW4ocih0LnRhcmdldCxlKSk7XCJsb2FkXCI9PT10LnR5cGU/KGUudW53cmFwU3VjY2VzcyYmKG89ZS51bndyYXBTdWNjZXNzKG8sdC50YXJnZXQpKSxLZShvKSYmZS50eXBlP2YobyxmdW5jdGlvbih0LG4pe29bbl09bmV3IGUudHlwZSh0KX0pOmUudHlwZSYmKG89bmV3IGUudHlwZShvKSksYS5yZXNvbHZlKG8pKTooZS51bndyYXBFcnJvciYmKG89ZS51bndyYXBFcnJvcihvLHQudGFyZ2V0KSksYS5yZWplY3QobykpfWNhdGNoKGkpe2EucmVqZWN0KGkpLGMuZGVmZXJyZWQub25lcnJvcihpKX1maW5hbGx5e2UuYmFja2dyb3VuZCE9PSEwJiZjLmVuZENvbXB1dGF0aW9uKCl9fSxQZShlKSxhLnByb21pc2U9Z2UoYS5wcm9taXNlLGUuaW5pdGlhbFZhbHVlKSxhLnByb21pc2V9LGN9KX0se31dLDM6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlLHQpe3ZhciBuLHIsYSxvPXQuYW5pbWF0aW9uLmN1cnJlbnQsaT1kW1wiZGVmYXVsdFwiXS5maW5kUG92KHQucG92U2lkZSx0LnR1cm5TaWRlKSx1PWRbXCJkZWZhdWx0XCJdLnZlY3RvckJ5UG92KGkpLGw9dC5ib3VuZHMoKSxzPTQvMyxmPTEqbC53aWR0aCxwPShsLmhlaWdodCoocy8yNC4zMiksNjA4LzM1MCksdj1mLG09bC5oZWlnaHQqKHMvcCksZz0uMDYyNSp2LGg9LjE0Km0seT17fSx3PVtdO2lmKG8uaGludD09PWNbXCJkZWZhdWx0XCJdLmRyYXdNaWRkbGUpe249WzEyKmcsbV0scj1bdip1WzBdLG0qdVsxXV07dmFyIGE9W3JbMF0tblswXSxyWzFdLW5bMV1dO3lbZFtcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdPVthLGEsITBdfWVsc2UgaWYoby5oaW50PT09Y1tcImRlZmF1bHRcIl0uZGlzY2FyZCl7dmFyIGI9ZFtcImRlZmF1bHRcIl0uZGlzY2FyZEJ5UG92KGkpLFA9ZFtcImRlZmF1bHRcIl0udG9wS2V5MnBvcyhiKTtuPVtnKlBbMF0saCpQWzFdXSxyPVt2KnVbMF0sbSp1WzFdXSxhPVtyWzBdLW5bMF0sclsxXS1uWzFdXSx5W2JdPVthLGFdfXJldHVybnthbmltczp5LGZhZGluZ3M6d319ZnVuY3Rpb24gbyhlLHQpe3JldHVybiBNYXRoLnJvdW5kKGUqdCkvdH1mdW5jdGlvbiBpKGUpe2lmKGUuYW5pbWF0aW9uLmN1cnJlbnQuc3RhcnQpe3ZhciB0PTEtKChuZXcgRGF0ZSkuZ2V0VGltZSgpLWUuYW5pbWF0aW9uLmN1cnJlbnQuc3RhcnQpL2UuYW5pbWF0aW9uLmN1cnJlbnQuZHVyYXRpb247aWYodDw9MCllLmFuaW1hdGlvbi5jdXJyZW50PXt9LGUucmVuZGVyKCk7ZWxzZXt2YXIgbj1mLmVhc2VJbk91dEN1YmljKHQpO2Zvcih2YXIgciBpbiBlLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zKXt2YXIgYT1lLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW3JdO2FbMV09W28oYVswXVswXSpuLDEwKSxvKGFbMF1bMV0qbiwxMCldLGFbMl0mJihhWzFdPVthWzBdWzBdLWFbMV1bMF0sYVswXVsxXS1hWzFdWzFdXSl9Zm9yKHZhciB1IGluIGUuYW5pbWF0aW9uLmN1cnJlbnQuZmFkaW5ncyllLmFuaW1hdGlvbnMuY3VycmVudC5mYWRpbmdzW3VdLm9wYWNpdHk9byhuLDEwMCk7ZS5yZW5kZXIoKSxkW1wiZGVmYXVsdFwiXS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtpKGUpfSl9fX1mdW5jdGlvbiB1KGUsdCl7dmFyIG49e3BpZWNlczp7fSxvcGVuczp7fSxtaWRkbGVzOnt9fTtmb3IodmFyIHIgaW4gdC5waWVjZXMpdC5waWVjZXNbcl0mJihuLnBpZWNlc1tyXT17Y29sb3I6dC5waWVjZXNbcl0uY29sb3IsbnVtYmVyOnQucGllY2VzW3JdLm51bWJlcn0pO3ZhciBvPWUoKSx1PWEobix0KTtpZihPYmplY3Qua2V5cyh1LmFuaW1zKS5sZW5ndGg+MHx8dS5mYWRpbmdzLmxlbmd0aD4wKXt2YXIgbD10LmFuaW1hdGlvbi5jdXJyZW50LnN0YXJ0O3QuYW5pbWF0aW9uLmN1cnJlbnQ9e3N0YXJ0OihuZXcgRGF0ZSkuZ2V0VGltZSgpLGR1cmF0aW9uOnQuYW5pbWF0aW9uLmR1cmF0aW9uLGFuaW1zOnUuYW5pbXMsZmFkaW5nczp1LmZhZGluZ3N9LGx8fGkodCl9ZWxzZSB0LnJlbmRlclJBRigpO3JldHVybiBvfXZhciBsPWUoXCIuL3V0aWxcIiksZD1yKGwpLHM9ZShcIi4vbW92ZVwiKSxjPXIocyksZj17ZWFzZUluT3V0Q3ViaWM6ZnVuY3Rpb24oZSl7cmV0dXJuIGU8LjU/NCplKmUqZTooZS0xKSooMiplLTIpKigyKmUtMikrMX19O3QuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPVt0XS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApKTtpZih0LmFuaW1hdGlvbi5lbmFibGVkKXJldHVybiB1KGRbXCJkZWZhdWx0XCJdLnBhcnRpYWxBcHBseShlLG4pLHQpO3ZhciByPWUuYXBwbHkobnVsbCxuKTtyZXR1cm4gdC5yZW5kZXJSQUYoKSxyfX19LHtcIi4vbW92ZVwiOjExLFwiLi91dGlsXCI6MTV9XSw0OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fXZhciBhPWUoXCIuL2JvYXJkXCIpLG89cihhKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJue3NldDplLnNldCxnZXRQaWVjZUdyb3VwczpmdW5jdGlvbigpe3JldHVybiBvW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwcyhlLmRhdGEpfSxhcGlNb3ZlOmUuYXBpTW92ZSxhcGlEcmF3TWlkZGxlRW5kOmUuYXBpRHJhd01pZGRsZUVuZCxwbGF5T3BlblNlcmllczplLnBsYXlPcGVuU2VyaWVzLHBsYXlPcGVuUGFpcnM6ZS5wbGF5T3BlblBhaXJzLHN0b3A6ZS5zdG9wLGdldFBpZWNlR3JvdXBTZXJpZXM6ZS5nZXRQaWVjZUdyb3VwU2VyaWVzLGdldFBpZWNlR3JvdXBQYWlyczplLmdldFBpZWNlR3JvdXBQYWlycyxnZXRGZW46ZS5nZXRGZW59fX0se1wiLi9ib2FyZFwiOjV9XSw1OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIG8oZSl7aWYoSyhlKSl7dmFyIHQ9ZS5taWRkbGVzW0pbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxuPUgoZSk7aWYobj1uLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4gZWVbXCJkZWZhdWx0XCJdLnNlcmllcyhuLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KSx0KX0pLG4ubGVuZ3RoPjApe3ZhciByPUwobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnBpZWNlc1t0XX0pfSkpO3JldHVybiBzKGUsbiksbmUoSltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLFlbXCJkZWZhdWx0XCJdLm9wZW5TZXJpZXMsdGUocikpKSwhMH19cmV0dXJuITF9ZnVuY3Rpb24gaShlKXtpZihBKGUpKXt2YXIgdD1lLm1pZGRsZXNbSltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdLG49SChlKTtpZihuPW4uZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiBlZVtcImRlZmF1bHRcIl0ucGFpcnMobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSksdCl9KSxuLmxlbmd0aD4wKXt2YXIgcj1MKG4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pKTtyZXR1cm4gZChlLG4pLG5lKEpbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixZW1wiZGVmYXVsdFwiXS5vcGVuUGFpcnMsdGUocikpKSwhMH19cmV0dXJuITF9ZnVuY3Rpb24gdShlLHQpe3ZhciBuPUpbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50O3YoZSxuKSxwKGUsbiksbChlLHQpfWZ1bmN0aW9uIGwoZSx0KXtcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9V1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHQpLnBpZWNlKSxlLm1pZGRsZUhvbGRlci5waWVjZT10LGMoZSl9ZnVuY3Rpb24gZChlLHQpe3ZhciBuPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pLHI9TChuKTtuZShKW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsWVtcImRlZmF1bHRcIl0ub3BlblBhaXJzLHRlKHIpKSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIGUucGllY2VzW3RdfSl9KTt2YXIgYT1lLm9wZW5zLnBhaXJzLmNvbmNhdChuKTtlLm9wZW5zLnBhaXJzPWEsZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBzKGUsdCl7dmFyIG49dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnBpZWNlc1t0XX0pfSkscj1MKG4pO25lKEpbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxZW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzLHRlKHIpKSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIGUucGllY2VzW3RdfSl9KTt2YXIgYT1lLm9wZW5zLnNlcmllcy5jb25jYXQobik7ZS5vcGVucy5zZXJpZXM9YSxlLm9wZW5zLnJlbGF5b3V0KGUpfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9ZS5taWRkbGVIb2xkZXIua2V5LG49ZS5taWRkbGVIb2xkZXIucGllY2U7dCYmbiYmKGUucGllY2VzW3RdPW4sZS5sYXN0TW92ZT1bSltcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdLGUubWlkZGxlSG9sZGVyLmN1cnJlbnQ9ITEsZS5taWRkbGVIb2xkZXIua2V5PW51bGwsZS5taWRkbGVIb2xkZXIucGllY2U9bnVsbCl9ZnVuY3Rpb24gZihlLHQsbil7aWYodD09PW58fCFlLnBpZWNlc1t0XSlyZXR1cm4hMTt2YXIgcj1lLnBpZWNlc1tuXTtyZXR1cm4gZS5waWVjZXNbbl09ZS5waWVjZXNbdF0sZS5waWVjZXNbdF09ciwhMH1mdW5jdGlvbiBwKGUsdCxuKXtpZighbnx8ZS5waWVjZXNbbl0pe3ZhciByPUcoZSk7bj1yfXJldHVybiBuZShKW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsWVtcImRlZmF1bHRcIl0uZHJhd01pZGRsZUVuZCkpLGUubWlkZGxlSG9sZGVyLmtleT1uLGMoZSksITB9ZnVuY3Rpb24gdihlLHQpe3JldHVybiBuZShKW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsWVtcImRlZmF1bHRcIl0uZHJhd01pZGRsZSkpLGUubWlkZGxlc1tKW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0tLSxlLm1pZGRsZUhvbGRlci5jdXJyZW50PSEwLCEwfWZ1bmN0aW9uIG0oZSx0LG4pe3JldHVybiFlLnBpZWNlc1tuXSYmKG5lKEpbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxZW1wiZGVmYXVsdFwiXS5kcmF3TGVmdCkpLGUucGllY2VzW25dPWUuZGlzY2FyZHNbSltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMV1dWzBdLGUuZGlzY2FyZHNbSltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMV1dLnNoaWZ0KCksITApfWZ1bmN0aW9uIGcoZSx0LG4pe2lmKG4mJkpbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodCkmJkpbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkobikmJlMoZSx0LG4pJiZmKGUsdCxuKSlyZXR1cm4hMH1mdW5jdGlvbiBoKGUsdCl7aWYoSltcImRlZmF1bHRcIl0uaXNNaWRkbGVLZXkodCkmJk0oZSx0KSlyZXR1cm4gdihlLHQpLCEwfWZ1bmN0aW9uIHkoZSx0LG4pe2lmKEpbXCJkZWZhdWx0XCJdLmlzTWlkZGxlS2V5KHQpJiZDKGUsdCkpcmV0dXJuIHAoZSx0LG4pLCEwfWZ1bmN0aW9uIHcoZSx0LG4pe2lmKG4mJkpbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkobikmJkpbXCJkZWZhdWx0XCJdLmlzRHJhd0xlZnRLZXkodCkmJkQoZSx0LG4pJiZtKGUsdCxuKSlyZXR1cm4gbmUoSltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLFlbXCJkZWZhdWx0XCJdLmRyYXdMZWZ0KSksITB9ZnVuY3Rpb24gYihlLHQsbil7bnx8KEpbXCJkZWZhdWx0XCJdLmlzTWlkZGxlS2V5KHQpP2goZSx0KSYmayhlLHQpOkpbXCJkZWZhdWx0XCJdLmlzRHJhd0xlZnRLZXkodCkmJkQoZSkmJmsoZSx0KSl9ZnVuY3Rpb24gUChlLHQpe2Uuc2VsZWN0ZWQ/KHQ/ZS5zZWxlY3RlZCE9PXQmJihnKGUsZS5zZWxlY3RlZCx0KXx8dyhlLGUuc2VsZWN0ZWQsdCl8fHkoZSxlLnNlbGVjdGVkLHQpKTp5KGUsZS5zZWxlY3RlZCx0KSxrKGUsbnVsbCkpOngoZSx0KSYmayhlLHQpfWZ1bmN0aW9uIGsoZSx0KXtpZihlLnNlbGVjdGVkPXQsdCYmSltcImRlZmF1bHRcIl0uaXNCb2FyZEtleSh0KSlpZihOKGUsdCkpe3ZhciBuPWUubWlkZGxlc1tKW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV07ZS5vcGVuYWJsZS5kZXN0cz1lZVtcImRlZmF1bHRcIl0uY29tcHV0ZShlLm9wZW5zLGUucGllY2VzW3RdLG4pfWVsc2UgZS5vcGVuYWJsZS5kZXN0cz1bXTtlbHNlIGUub3BlbmFibGUuZGVzdHM9W119ZnVuY3Rpb24gTyhlKXtyZXR1cm4gZS5wb3ZTaWRlPT09ZS50dXJuU2lkZX1mdW5jdGlvbiB4KGUsdCl7dmFyIG49ZS5waWVjZXNbdF07cmV0dXJuIG4mJmUubW92YWJsZS5ib2FyZH1mdW5jdGlvbiBTKGUsdCxuKXtyZXR1cm4gdCE9biYmeChlLHQpfWZ1bmN0aW9uIEUoZSl7cmV0dXJuIE8oZSl9ZnVuY3Rpb24gTShlLHQpe3JldHVybiBFKGUpJiYhZS5taWRkbGVIb2xkZXIuY3VycmVudCYmSltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxZW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlKX1mdW5jdGlvbiBDKGUpe3JldHVybiBlLm1pZGRsZUhvbGRlci5jdXJyZW50fWZ1bmN0aW9uIEQoZSx0LG4pe3JldHVybiBFKGUpJiYhQyhlKSYmSltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxZW1wiZGVmYXVsdFwiXS5kcmF3TGVmdCl9ZnVuY3Rpb24gSyhlKXtyZXR1cm4gTyhlKSYmSltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxZW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzKX1mdW5jdGlvbiBBKGUpe3JldHVybiBPKGUpJiZKW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLFlbXCJkZWZhdWx0XCJdLm9wZW5QYWlycyl9ZnVuY3Rpb24gVChlKXtyZXR1cm4gTyhlKSYmSltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxZW1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuKX1mdW5jdGlvbiBCKGUpe3JldHVybiBPKGUpJiZKW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLFlbXCJkZWZhdWx0XCJdLmNvbGxlY3RPcGVuKX1mdW5jdGlvbiBqKGUpe1AoZSxudWxsKX1mdW5jdGlvbiBSKGUpe2UubW92YWJsZS5zaWRlPW51bGwsZS5tb3ZhYmxlLmRlc3RzPVtdLGUub3BlbmFibGUuZGVzdHM9W10sZS5tb3ZhYmxlLmJvYXJkPSExLGooZSl9ZnVuY3Rpb24gTihlLHQpe3ZhciBuPWUucGllY2VzW3RdO3JldHVybiEoIW58fGUucG92U2lkZSE9PWUudHVyblNpZGUpfWZ1bmN0aW9uIEcoZSl7dmFyIHQ9SltcImRlZmF1bHRcIl0uYWxsQWxsb3dlZEJvYXJkS2V5cy5zbGljZSgxKSxuPUpbXCJkZWZhdWx0XCJdLmFsbEFsbG93ZWRCb2FyZEtleXMuc2xpY2UoMikscj1KW1wiZGVmYXVsdFwiXS5hbGxBbGxvd2VkQm9hcmRLZXlzLm1hcChmdW5jdGlvbihlLHIpe3JldHVybltlLHRbcl0sbltyXV19KS5maWx0ZXIoZnVuY3Rpb24odCl7dmFyIG49eih0LDMpLHI9blswXSxhPW5bMV0sbz1uWzJdO3JldHVybiByJiZhJiZvJiYhZS5waWVjZXNbcl0mJiFlLnBpZWNlc1thXSYmIWUucGllY2VzW29dfSk7cmV0dXJuIHJbci5sZW5ndGgtMV1bMV19ZnVuY3Rpb24gRihlLHQsbixyKXt2YXIgYT1fKGUsdCxuKTtpZighYSlyZXR1cm4gYTt2YXIgbz1KW1wiZGVmYXVsdFwiXS5kZWNCb2FyZEtleShhKTtyZXR1cm4gbyE9PXImJmUucGllY2VzW29dJiYoYT1vKSxKW1wiZGVmYXVsdFwiXS5ub3RBbGxvd2VkQm9hcmRLZXlzLmluZGV4T2YoYSkhPT0tMT9udWxsOmF9ZnVuY3Rpb24gXyhlLHQsbil7aWYobnx8ZS5ib3VuZHMpe249bnx8ZS5ib3VuZHMoKTt2YXIgcj1NYXRoLmZsb29yKEpbXCJkZWZhdWx0XCJdLmNvbHVtbnMqKCh0WzBdLW4ubGVmdCkvbi53aWR0aCkpLGE9TWF0aC5mbG9vcihKW1wiZGVmYXVsdFwiXS5yb3dzKigodFsxXS1uLnRvcCkvbi5oZWlnaHQpKTtyZXR1cm4gYT49MCYmYTxKW1wiZGVmYXVsdFwiXS5yb3dzJiZyPj0wJiZyPEpbXCJkZWZhdWx0XCJdLmNvbHVtbnM/SltcImRlZmF1bHRcIl0ucG9zMmtleShbcixhXSk6dm9pZCAwfX1mdW5jdGlvbiBMKGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUua2V5fSkuam9pbihcIlwiKX0pLmpvaW4oXCIgXCIpfWZ1bmN0aW9uIEkoZSl7dmFyIHQ9ZS5taWRkbGVzW0pbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxuPWUud2l0aFRvcmUscj1xKGUpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZWVbXCJkZWZhdWx0XCJdLnNlcmllcyhlLHQsbil9KTtyZXR1cm4gTChyKX1mdW5jdGlvbiBVKGUpe3ZhciB0PWUubWlkZGxlc1tKW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0sbj1xKGUpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZWVbXCJkZWZhdWx0XCJdLnBhaXJzKGUsdCl9KTtyZXR1cm4gTChuKX1mdW5jdGlvbiBxKGUpe3JldHVybiBIKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSl9KX1mdW5jdGlvbiBIKGUpe3ZhciB0PUpbXCJkZWZhdWx0XCJdLnBvczJrZXkoW0pbXCJkZWZhdWx0XCJdLmNvbHVtbnMtMSwwXSksbj1KW1wiZGVmYXVsdFwiXS5hbGxLZXlzLnNsaWNlKDEpLHI9SltcImRlZmF1bHRcIl0uYWxsS2V5cy5tYXAoZnVuY3Rpb24oZSx0KXtyZXR1cm5bZSxuW3RdXX0pLnJlZHVjZShmdW5jdGlvbihuLHIpe3ZhciBhPXoobiwyKSxvPWFbMF0saT1hWzFdLHU9eihyLDIpLGw9dVswXSxkPXVbMV07cmV0dXJuIGUucGllY2VzW2xdJiZvLnB1c2gobCksKGwmJiFlLnBpZWNlc1tsXSYmZCYmIWUucGllY2VzW2RdfHxsPT09dCkmJjAhPT1vLmxlbmd0aCYmKGkucHVzaChvKSxvPVtdKSxbbyxpXX0sW1tdLFtdXSksYT16KHIsMiksbz1hWzBdLGk9YVsxXTtyZXR1cm4gMCE9PW8ubGVuZ3RoJiZpLnB1c2gobyksaX12YXIgWCx6PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZhciBuPVtdLHI9ITAsYT0hMSxvPXZvaWQgMDt0cnl7Zm9yKHZhciBpLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShpPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChpLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtyPSEwKTt9Y2F0Y2gobCl7YT0hMCxvPWx9ZmluYWxseXt0cnl7IXImJnVbXCJyZXR1cm5cIl0mJnVbXCJyZXR1cm5cIl0oKX1maW5hbGx5e2lmKGEpdGhyb3cgb319cmV0dXJuIG59cmV0dXJuIGZ1bmN0aW9uKHQsbil7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdDtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpKXJldHVybiBlKHQsbik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9fSgpLCQ9ZShcIi4vdXRpbFwiKSxKPXIoJCksVj1lKFwiLi9tb3ZlXCIpLFk9cihWKSxRPWUoXCIuL3BpZWNlc1wiKSxXPXIoUSksWj1lKFwiLi9vcGVuXCIpLGVlPXIoWiksdGU9SltcImRlZmF1bHRcIl0ud3JhcEdyb3VwLG5lPUpbXCJkZWZhdWx0XCJdLmNhbGxVc2VyRnVuY3Rpb247dC5leHBvcnRzPShYPXtwbGF5T3BlblNlcmllczpvLHBsYXlPcGVuUGFpcnM6aSxhcGlEcmF3TWlkZGxlRW5kOmx9LGEoWCxcImFwaURyYXdNaWRkbGVFbmRcIixsKSxhKFgsXCJhcGlGb3JjZURyYXdNaWRkbGVFbmRcIix1KSxhKFgsXCJhcGlGb3JjZURyYXdNaWRkbGVFbmRcIix1KSxhKFgsXCJ1c2VyTW92ZVwiLGcpLGEoWCxcInVzZXJEcmF3TGVmdFwiLHcpLGEoWCxcInVzZXJCZWdpbkRyYXdNaWRkbGVcIixoKSxhKFgsXCJ1c2VyRW5kRHJhd01pZGRsZVwiLHkpLGEoWCxcInNlbGVjdFNxdWFyZVwiLFApLGEoWCxcInNlbGVjdFRvcFwiLGIpLGEoWCxcInNldFNlbGVjdGVkXCIsayksYShYLFwiY2FuT3BlblNlcmllc1wiLEspLGEoWCxcImNhbk9wZW5QYWlyc1wiLEEpLGEoWCxcImNhbkxlYXZlVGFrZW5cIixUKSxhKFgsXCJjYW5Db2xsZWN0T3BlblwiLEIpLGEoWCxcInN0b3BcIixSKSxcbmEoWCxcImlzRHJvcHBhYmxlT3BlbnNcIixOKSxhKFgsXCJnZXRLZXlBdERvbVBvc1wiLF8pLGEoWCxcImdldEtleUF0RG9tUG9zT25QaWVjZVwiLEYpLGEoWCxcImdldFBpZWNlR3JvdXBzXCIscSksYShYLFwiZ2V0UGllY2VHcm91cFNlcmllc1wiLEkpLGEoWCxcImdldFBpZWNlR3JvdXBQYWlyc1wiLFUpLFgpfSx7XCIuL21vdmVcIjoxMSxcIi4vb3BlblwiOjEyLFwiLi9waWVjZXNcIjoxMyxcIi4vdXRpbFwiOjE1fV0sNjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX12YXIgYT1lKFwibWVyZ2VcIiksbz1yKGEpLGk9ZShcIi4vcGllY2VzXCIpLHU9cihpKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtpZih0JiYob1tcImRlZmF1bHRcIl0ucmVjdXJzaXZlKGUsdCksZS5mZW4pKXt2YXIgbj11W1wiZGVmYXVsdFwiXS5yZWFkKGUuZmVuKTtlLnBpZWNlcz1uLnBpZWNlcyxlLmRpc2NhcmRzPW4uZGlzY2FyZHMsZS5vcGVucz1uLm9wZW5zLGUubWlkZGxlcz1uLm1pZGRsZXMsZGVsZXRlIGUuZmVufX19LHtcIi4vcGllY2VzXCI6MTMsbWVyZ2U6MX1dLDc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19dmFyIGE9ZShcIi4vdGFibGVcIiksbz1yKGEpLGk9ZShcIi4vYm9hcmRcIiksdT1yKGkpLGw9ZShcIi4vZGF0YVwiKSxkPXIobCkscz1lKFwiLi9jb25maWd1cmVcIiksYz1yKHMpLGY9ZShcIi4vdXRpbFwiKSxwPXIoZiksdj1lKFwiLi9hbmltXCIpLG09cih2KSxnPWUoXCIuL2RyYWdcIiksaD1yKGcpLHk9ZShcIi4vcGllY2VzXCIpLHc9cih5KTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLmRhdGE9KDAsZFtcImRlZmF1bHRcIl0pKGUpLHRoaXMuZ2V0RmVuPWZ1bmN0aW9uKCl7cmV0dXJuIHdbXCJkZWZhdWx0XCJdLndyaXRlKHQuZGF0YS5waWVjZXMpfSx0aGlzLmdldFBpZWNlR3JvdXBTZXJpZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdVtcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFNlcmllcyh0LmRhdGEpfSx0aGlzLmdldFBpZWNlR3JvdXBQYWlycz1mdW5jdGlvbigpe3JldHVybiB1W1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwUGFpcnModC5kYXRhKX0sdGhpcy5zZXQ9KDAsbVtcImRlZmF1bHRcIl0pKGNbXCJkZWZhdWx0XCJdLHRoaXMuZGF0YSksdGhpcy5hcGlNb3ZlPSgwLG1bXCJkZWZhdWx0XCJdKShvW1wiZGVmYXVsdFwiXS5hcGlNb3ZlLHRoaXMuZGF0YSksdGhpcy5hcGlEcmF3TWlkZGxlRW5kPSgwLG1bXCJkZWZhdWx0XCJdKSh1W1wiZGVmYXVsdFwiXS5hcGlEcmF3TWlkZGxlRW5kLHRoaXMuZGF0YSksdGhpcy5wbGF5T3BlblNlcmllcz0oMCxtW1wiZGVmYXVsdFwiXSkodVtcImRlZmF1bHRcIl0ucGxheU9wZW5TZXJpZXMsdGhpcy5kYXRhKSx0aGlzLnBsYXlPcGVuUGFpcnM9KDAsbVtcImRlZmF1bHRcIl0pKHVbXCJkZWZhdWx0XCJdLnBsYXlPcGVuUGFpcnMsdGhpcy5kYXRhKSx0aGlzLmNhbkxlYXZlVGFrZW49cFtcImRlZmF1bHRcIl0ucGFydGlhbCh1W1wiZGVmYXVsdFwiXS5jYW5MZWF2ZVRha2VuLHRoaXMuZGF0YSksdGhpcy5jYW5Db2xsZWN0T3Blbj1wW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKHVbXCJkZWZhdWx0XCJdLmNhbkNvbGxlY3RPcGVuLHRoaXMuZGF0YSksdGhpcy5jYW5PcGVuU2VyaWVzPXBbXCJkZWZhdWx0XCJdLnBhcnRpYWwodVtcImRlZmF1bHRcIl0uY2FuT3BlblNlcmllcyx0aGlzLmRhdGEpLHRoaXMuY2FuT3BlblBhaXJzPXBbXCJkZWZhdWx0XCJdLnBhcnRpYWwodVtcImRlZmF1bHRcIl0uY2FuT3BlblBhaXJzLHRoaXMuZGF0YSksdGhpcy5zdG9wPSgwLG1bXCJkZWZhdWx0XCJdKShmdW5jdGlvbihlKXt1W1wiZGVmYXVsdFwiXS5zdG9wKGUpLGhbXCJkZWZhdWx0XCJdLmNhbmNlbChlKX0sdGhpcy5kYXRhKX19LHtcIi4vYW5pbVwiOjMsXCIuL2JvYXJkXCI6NSxcIi4vY29uZmlndXJlXCI6NixcIi4vZGF0YVwiOjgsXCIuL2RyYWdcIjo5LFwiLi9waWVjZXNcIjoxMyxcIi4vdGFibGVcIjoxNCxcIi4vdXRpbFwiOjE1fV0sODpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX12YXIgYT1lKFwibWVyZ2VcIiksbz0ocihhKSxlKFwiLi9waWVjZXNcIikpLGk9cihvKSx1PWUoXCIuL2NvbmZpZ3VyZVwiKSxsPXIodSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PXtwb3ZTaWRlOlwiZWFzdFwiLHR1cm5TaWRlOlwiZWFzdFwiLGxhc3RNb3ZlOm51bGwsd2l0aFRvcmU6ITEscGllY2VzOmlbXCJkZWZhdWx0XCJdLnJlYWRCb2FyZChpW1wiZGVmYXVsdFwiXS5taXhlZCksZGlzY2FyZHM6aVtcImRlZmF1bHRcIl0ucmVhZERpc2NhcmRzKGlbXCJkZWZhdWx0XCJdLmluaXRpYWxEaXNjYXJkcyxcImVhc3RcIiksb3BlbnM6aVtcImRlZmF1bHRcIl0ucmVhZE9wZW5Hcm91cHMoaVtcImRlZmF1bHRcIl0uaW5pdGlhbE9wZW5Hcm91cHMpLG1pZGRsZXM6aVtcImRlZmF1bHRcIl0ucmVhZE1pZGRsZXMoaVtcImRlZmF1bHRcIl0uaW5pdGlhbE1pZGRsZXMpLHNlbGVjdGVkOm51bGwsbWlkZGxlSG9sZGVyOntjdXJyZW50OiExLGtleTpudWxsLHBpZWNlOm51bGx9LGFuaW1hdGlvbjp7ZW5hYmxlZDohMCxkdXJhdGlvbjo1MDAsY3VycmVudDp7fX0sZHJhZ2dhYmxlOntlbmFibGVkOiEwLGRpc3RhbmNlOjMsY3VycmVudDp7fX0sbW92YWJsZTp7Ym9hcmQ6ITAsZnJlZTohMCxldmVudHM6e2FmdGVyOmZ1bmN0aW9uKGUsdCl7fX19LG9wZW5hYmxlOntkZXN0czpbXX0sZXZlbnRzOnttb3ZlOmZ1bmN0aW9uKGUsdCl7fX19O3JldHVybigwLGxbXCJkZWZhdWx0XCJdKSh0LGV8fHt9KSx0fX0se1wiLi9jb25maWd1cmVcIjo2LFwiLi9waWVjZXNcIjoxMyxtZXJnZToxfV0sOTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUsdCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106Z1tcImRlZmF1bHRcIl0ucm93cyxhPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTpnW1wiZGVmYXVsdFwiXS5jb2x1bW5zO3JldHVybntsZWZ0OnQubGVmdCt0LndpZHRoKm5bMF0vYSx0b3A6dC50b3ArdC5oZWlnaHQqblsxXS9yLHdpZHRoOnQud2lkdGgvYSxoZWlnaHQ6dC5oZWlnaHQvcn19ZnVuY3Rpb24gbyhlLHQpe2lmKHZvaWQgMD09PXQuYnV0dG9ufHwwPT09dC5idXR0b24pe3Quc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLHM9dC50YXJnZXQ7dmFyIG49ZS5zZWxlY3RlZCxyPWdbXCJkZWZhdWx0XCJdLmV2ZW50UG9zaXRpb24odCksbz1lLmJvYXJkQm91bmRzKCksdT1lLm9wZW5zQm91bmRzKCksbD1lLnRvcEJvdW5kcygpLGQ9ZltcImRlZmF1bHRcIl0uZ2V0S2V5QXREb21Qb3NPblBpZWNlKGUscixvKTtmW1wiZGVmYXVsdFwiXS5zZWxlY3RTcXVhcmUoZSxkKSxkfHwoZD12W1wiZGVmYXVsdFwiXS5nZXREcmF3S2V5QXREb21Qb3MoZSxyLGwpKSYmZltcImRlZmF1bHRcIl0uc2VsZWN0VG9wKGUsZCxuKSwhZCYmbiYmKChkPXZbXCJkZWZhdWx0XCJdLmdldE9wZW5zS2V5QXREb21Qb3MoZSxyLHUpKT92W1wiZGVmYXVsdFwiXS5kcm9wT3BlbnMoZSxuLGQpOihkPXZbXCJkZWZhdWx0XCJdLmdldERpc2NhcmRLZXlBdERvbVBvcyhlLHIsbCkpJiZ2W1wiZGVmYXVsdFwiXS5kcm9wVG9wKGUsbixkKSk7dmFyIGM9ZS5zZWxlY3RlZD09PWQ7aWYoYyYmdltcImRlZmF1bHRcIl0uaXNEcmFnZ2FibGUoZSxkKSl7dmFyIHA9Z1tcImRlZmF1bHRcIl0uaXNCb2FyZEtleShkKT9hKGUsbyxnW1wiZGVmYXVsdFwiXS5rZXkycG9zKGQpKTphKGUsbCxnW1wiZGVmYXVsdFwiXS50b3BLZXkycG9zKGQpLGdbXCJkZWZhdWx0XCJdLnRvcFJvd3MsZ1tcImRlZmF1bHRcIl0udG9wQ29sdW1ucyk7ZS5kcmFnZ2FibGUuY3VycmVudD17b3JpZzpkLHJlbDpyLGVwb3M6cixwb3M6WzAsMF0sZGVjOltyWzBdLShwLmxlZnQrcC53aWR0aC8yKSxyWzFdLShwLnRvcCtwLmhlaWdodC8yKV0sYm9hcmRCb3VuZHM6byxvcGVuc0JvdW5kczp1LHRvcEJvdW5kczpsLHN0YXJ0ZWQ6ITF9fWkoZSl9fWZ1bmN0aW9uIGkoZSl7Z1tcImRlZmF1bHRcIl0ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5kcmFnZ2FibGUuY3VycmVudDt0Lm9yaWcmJighdC5zdGFydGVkJiZnW1wiZGVmYXVsdFwiXS5kaXN0YW5jZSh0LmVwb3MsdC5yZWwpPj1lLmRyYWdnYWJsZS5kaXN0YW5jZSYmKHQuc3RhcnRlZD0hMCksdC5zdGFydGVkJiYodC5wb3M9W3QuZXBvc1swXS10LnJlbFswXSx0LmVwb3NbMV0tdC5yZWxbMV1dLHQub3Zlcj1mW1wiZGVmYXVsdFwiXS5nZXRLZXlBdERvbVBvc09uUGllY2UoZSx0LmVwb3MsdC5ib2FyZEJvdW5kcyx0Lm9yaWcpLCF0Lm92ZXImJmdbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodC5vcmlnKSYmKHQub3Zlcj12W1wiZGVmYXVsdFwiXS5nZXRPcGVuc0tleUF0RG9tUG9zKGUsdC5lcG9zLHQub3BlbnNCb3VuZHMpfHx2W1wiZGVmYXVsdFwiXS5nZXREaXNjYXJkS2V5QXREb21Qb3MoZSx0LmVwb3MsdC50b3BCb3VuZHMpKSkpLGUucmVuZGVyKCksdC5vcmlnJiZpKGUpfSl9ZnVuY3Rpb24gdShlLHQpe2UuZHJhZ2dhYmxlLmN1cnJlbnQub3JpZyYmKGUuZHJhZ2dhYmxlLmN1cnJlbnQuZXBvcz1nW1wiZGVmYXVsdFwiXS5ldmVudFBvc2l0aW9uKHQpKX1mdW5jdGlvbiBsKGUsdCl7dmFyIG49ZS5kcmFnZ2FibGUscj1uLmN1cnJlbnQ/bi5jdXJyZW50Lm9yaWc6bnVsbDtpZihyKXt2YXIgYT1uLmN1cnJlbnQub3ZlcjtuLmN1cnJlbnQuc3RhcnRlZCYmKGZbXCJkZWZhdWx0XCJdLnNldFNlbGVjdGVkKGUsbnVsbCksZltcImRlZmF1bHRcIl0udXNlck1vdmUoZSxyLGEpfHx2W1wiZGVmYXVsdFwiXS5kcm9wT3BlbnMoZSxyLGEpfHx2W1wiZGVmYXVsdFwiXS5kcm9wVG9wKGUscixhKXx8ZltcImRlZmF1bHRcIl0udXNlckRyYXdMZWZ0KGUscixhKXx8ZltcImRlZmF1bHRcIl0udXNlckVuZERyYXdNaWRkbGUoZSxyLGEpKSxuLmN1cnJlbnQ9e319fWZ1bmN0aW9uIGQoZSl7ZS5kcmFnZ2FibGUuY3VycmVudC5vcmlnJiYoZS5kcmFnZ2FibGUuY3VycmVudD17fSxmW1wiZGVmYXVsdFwiXS5zZWxlY3RTcXVhcmUoZSxudWxsKSl9dmFyIHMsYz1lKFwiLi9ib2FyZFwiKSxmPXIoYykscD1lKFwiLi90YWJsZVwiKSx2PXIocCksbT1lKFwiLi91dGlsXCIpLGc9cihtKTt0LmV4cG9ydHM9e3N0YXJ0Om8sbW92ZTp1LGVuZDpsLGNhbmNlbDpkfX0se1wiLi9ib2FyZFwiOjUsXCIuL3RhYmxlXCI6MTQsXCIuL3V0aWxcIjoxNX1dLDEwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0KXt2YXIgbj1uZXcgbFtcImRlZmF1bHRcIl0odCk7cmV0dXJuIGlbXCJkZWZhdWx0XCJdLnJlbmRlcihlLCgwLHNbXCJkZWZhdWx0XCJdKShuKSksKDAsZ1tcImRlZmF1bHRcIl0pKG4pfXZhciBvPWUoXCJtaXRocmlsXCIpLGk9cihvKSx1PWUoXCIuL2N0cmxcIiksbD1yKHUpLGQ9ZShcIi4vdmlld1wiKSxzPXIoZCksYz1lKFwiLi91dGlsXCIpLGY9cihjKSxwPWUoXCIuL21vdmVcIiksdj1yKHApLG09ZShcIi4vYXBpXCIpLGc9cihtKTt0LmV4cG9ydHM9YSx0LmV4cG9ydHMuY29udHJvbGxlcj1sW1wiZGVmYXVsdFwiXSx0LmV4cG9ydHMudmlldz1zW1wiZGVmYXVsdFwiXSx0LmV4cG9ydHMudXRpbD1mW1wiZGVmYXVsdFwiXSx0LmV4cG9ydHMubW92ZT12W1wiZGVmYXVsdFwiXX0se1wiLi9hcGlcIjo0LFwiLi9jdHJsXCI6NyxcIi4vbW92ZVwiOjExLFwiLi91dGlsXCI6MTUsXCIuL3ZpZXdcIjoxNixtaXRocmlsOjJ9XSwxMTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPVwiZG1cIixhPVwiZGxcIixvPVwiZGRcIixpPVwibHRcIix1PVwic3NcIixsPVwib3NcIixkPVwib3BcIixzPVwiY29cIixjPVwiZG9zXCIsZj1cImRvcFwiLHA9XCJkZHNcIix2PVwiZGRwXCIsbT1cImxcIixnPVwiclwiLGg9XCJwXCI7dC5leHBvcnRzPXtkcmF3TWlkZGxlOnIsZHJhd0xlZnQ6YSxkaXNjYXJkOm8sbGVhdmVUYWtlbjppLHNpZ246dSxvcGVuU2VyaWVzOmwsb3BlblBhaXJzOmQsY29sbGVjdE9wZW46cyxkcm9wT3BlblNlcmllczpjLGRyb3BPcGVuUGFpcnM6Zixkcm9wTGVmdDptLGRyb3BSaWdodDpnLGRyb3BSZXBsYWNlOmgsZGlzY2FyZEVuZFNlcmllczpwLGRpc2NhcmRFbmRQYWlyczp2fX0se31dLDEyOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm4gZS5sZW5ndGg9PT10Lmxlbmd0aCYmZS5ldmVyeShmdW5jdGlvbihlLG4pe3JldHVybiBlPT09dFtuXX0pfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4gdC5ldmVyeShmdW5jdGlvbih0LG4pe3JldHVybiB0LmNvbG9yPT09ZVtuXX0pfWZ1bmN0aW9uIGkoZSx0KXtpZihlLmxlbmd0aDwzKXJldHVybiExO3ZhciBuPWUubGVuZ3RoLHI9ZVswXS5jb2xvcixvPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmtleX0pLGk9by5zbGljZSgwKS5yZXZlcnNlKCksdT1oW1wiZGVmYXVsdFwiXS5zZXJpZXNCeUNvbG9yKHIpO3QmJih1PXUuc2xpY2UoMCksdS5wdXNoKHVbMF0pKTtmb3IodmFyIGw9MDtsPD11Lmxlbmd0aC1uO2wrKyl7dmFyIGQ9dS5zbGljZShsLGwrbik7aWYoYShkLG8pfGEoZCxpKSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiB1KGUpe3ZhciB0PWUubGVuZ3RoLG49ZVswXS5udW1iZXI7cmV0dXJuISEoMz09PXR8ND09PXQpJiYoISFlLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlLm51bWJlcj09PW59KSYmeS5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiBvKHQuc2xpY2UoMCxlLmxlbmd0aCksZSl9KSl9ZnVuY3Rpb24gbChlLHQpe3ZhciBuPWhbXCJkZWZhdWx0XCJdLm1ha2VQaWVjZSh0LmMsdC5uKTtyZXR1cm4gbi5pc0Zha2U9ITAsaFtcImRlZmF1bHRcIl0ucGllY2VGYWtlKGUpP246ZX1mdW5jdGlvbiBkKGUsdCl7cmV0dXJuIWUuaXNGYWtlJiZlLmtleT09PXQua2V5fWZ1bmN0aW9uIHMoZSx0KXtmdW5jdGlvbiBuKGUsdCl7cmV0dXJuIGUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB0LmluZGV4T2YoZSk8MH0pfWZ1bmN0aW9uIHIoZSx0KXtyZXR1cm4gZS5rZXk9PT10LmtleX1mdW5jdGlvbiBhKGUsdCl7dmFyIHI9W1wiclwiLFwiZ1wiLFwiYlwiLFwibFwiXSxhPWUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiFkKGUsdCl9KSxvPW4ocixhLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5jfSkpO2lmKG8ubGVuZ3RoPDEpcmV0dXJuIGU7aWYoYS5sZW5ndGg8MSlyZXR1cm4gZTtpZighKGEubGVuZ3RoPGUubGVuZ3RoKSlyZXR1cm4gZTt2YXIgaT1vWzBdLHU9YVswXS5uLGw9aFtcImRlZmF1bHRcIl0ubWFrZVBpZWNlKGksdSk7cmV0dXJuIGEucHVzaChsKSxhfWZ1bmN0aW9uIG8oZSx0KXt2YXIgbjtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU7aWYoZS5sZW5ndGg8MylyZXR1cm4gZTt2YXIgYT1tKGUsMyksaT1hWzBdLHU9YVsxXSxsPWFbMl0scz1baSx1LGxdO2lmKG49ZS5zbGljZSgzLGUubGVuZ3RoKSxkKGksdCkpcihoW1wiZGVmYXVsdFwiXS5waWVjZVVwKHUpLGwpP3M9W2hbXCJkZWZhdWx0XCJdLnBpZWNlRG93bih1KSx1LGxdOnIoaFtcImRlZmF1bHRcIl0ucGllY2VEb3duKHUpLGwpJiYocz1baFtcImRlZmF1bHRcIl0ucGllY2VVcCh1KSx1LGxdKTtlbHNlIGlmKGQodSx0KSlyKGhbXCJkZWZhdWx0XCJdLnBpZWNlVXAoaFtcImRlZmF1bHRcIl0ucGllY2VVcChpKSksbCk/cz1baSxoW1wiZGVmYXVsdFwiXS5waWVjZVVwKGkpLGxdOnIoaFtcImRlZmF1bHRcIl0ucGllY2VEb3duKGhbXCJkZWZhdWx0XCJdLnBpZWNlRG93bihpKSksbCkmJihzPVtpLGhbXCJkZWZhdWx0XCJdLnBpZWNlRG93bihpKSxsXSk7ZWxzZXtpZighZChsLHQpKXJldHVybiBuPW8oZS5zbGljZSgxLGUubGVuZ3RoKSx0KSxuLnVuc2hpZnQoZVswXSksbjtyKGhbXCJkZWZhdWx0XCJdLnBpZWNlVXAoaSksdSk/cz1baSx1LGhbXCJkZWZhdWx0XCJdLnBpZWNlVXAodSldOnIoaFtcImRlZmF1bHRcIl0ucGllY2VEb3duKGkpLHUpJiYocz1baSx1LGhbXCJkZWZhdWx0XCJdLnBpZWNlRG93bih1KV0pfXJldHVybiBzLmNvbmNhdChuKX1mdW5jdGlvbiBpKGUsdCl7aWYoMiE9ZS5sZW5ndGgpcmV0dXJuIGU7dmFyIG49bShlLDIpLHI9blswXSxhPW5bMV07cmV0dXJuIGQocix0KT9bYSxhXTpkKGEsdCk/W3Iscl06ZX1pZihlLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZChlLHQpfSkubGVuZ3RoPjEpcmV0dXJuIGU7aWYoZS5sZW5ndGg8MylyZXR1cm4gaShlLHQpO3ZhciB1PWUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiFkKGUsdCl9KTtyZXR1cm4gdS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZS5uPT09dVswXS5ufSk/YShlLHQpOnUuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYz09PXVbMF0uY30pP28oZSx0KTplfWZ1bmN0aW9uIGMoZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLHI9aFtcImRlZmF1bHRcIl0ucGllY2VVcCh0KSxhPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBsKGUscil9KSxvPXMoYSxyKTtyZXR1cm4gaShvLG4pfHUobyl9ZnVuY3Rpb24gZihlLHQpe2lmKDIhPT1lLmxlbmd0aClyZXR1cm4hMTt2YXIgbj1oW1wiZGVmYXVsdFwiXS5waWVjZVVwKHQpLHI9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGwoZSxuKX0pLGE9cyhyLG4pLG89bShhLDIpLGk9b1swXSx1PW9bMV07cmV0dXJuIGkua2V5PT09dS5rZXl9ZnVuY3Rpb24gcChlLHQsbil7dmFyIHI9W10sYT1oW1wiZGVmYXVsdFwiXS5waWVjZVVwKG4pO3JldHVybiB0PWwodCxhKSxlLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8saSl7dmFyIHU9by5zbGljZSgwKSxsPW8uc2xpY2UoMCk7dS5zcGxpY2UoMCwwLHQpLGwuc3BsaWNlKG8ubGVuZ3RoLDAsdCksYyh1LG4pJiZyLnB1c2goaFtcImRlZmF1bHRcIl0uZ2V0T3BlblNlcmllS2V5RnJvbUdyb3VwSW5kZXgoZSxpLDApKSxjKGwsbikmJnIucHVzaChoW1wiZGVmYXVsdFwiXS5nZXRPcGVuU2VyaWVLZXlGcm9tR3JvdXBJbmRleChlLGksby5sZW5ndGgrMSkpO3ZhciBzPW8ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBkKGUsYSk/dDplfSk7aWYoYyhzLG4pKXt2YXIgZjtvLmZvckVhY2goZnVuY3Rpb24oZSx0KXtkKGUsYSkmJihmPXQpfSksci5wdXNoKGhbXCJkZWZhdWx0XCJdLmdldE9wZW5TZXJpZUtleUZyb21Hcm91cEluZGV4KGUsaSxmKzEpKX19KSxlLnBhaXJzLmZvckVhY2goZnVuY3Rpb24obyxpKXt2YXIgdT1vLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZChlLGEpP3Q6ZX0pO2lmKGYodSxuKSl7dmFyIGw9dihvLGEpO3IucHVzaChoW1wiZGVmYXVsdFwiXS5nZXRPcGVuUGFpcktleUZyb21Hcm91cEluZGV4KGUsaSxsKSl9fSkscn1mdW5jdGlvbiB2KGUsdCl7dmFyIG47cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlLHIpe2QoZSx0KSYmKG49cil9KSxufU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBtPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZhciBuPVtdLHI9ITAsYT0hMSxvPXZvaWQgMDt0cnl7Zm9yKHZhciBpLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShpPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChpLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtyPSEwKTt9Y2F0Y2gobCl7YT0hMCxvPWx9ZmluYWxseXt0cnl7IXImJnVbXCJyZXR1cm5cIl0mJnVbXCJyZXR1cm5cIl0oKX1maW5hbGx5e2lmKGEpdGhyb3cgb319cmV0dXJuIG59cmV0dXJuIGZ1bmN0aW9uKHQsbil7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdDtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpKXJldHVybiBlKHQsbik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9fSgpLGc9ZShcIi4vcGllY2VzXCIpLGg9cihnKSx5PWZ1bmN0aW9uKCl7dmFyIGU9aFtcImRlZmF1bHRcIl0uY29sb3JzLHQ9W107Zm9yKHZhciBuIGluIGUpZm9yKHZhciByIGluIGUpZm9yKHZhciBhIGluIGUpZm9yKHZhciBvIGluIGUpbiE9PXImJm4hPT1hJiZuIT09byYmciE9PWEmJnIhPT1vJiZhIT09byYmdC5wdXNoKFtlW25dLGVbcl0sZVthXSxlW29dXSk7cmV0dXJuIHR9KCk7bltcImRlZmF1bHRcIl09e2NvbXB1dGU6cCxzZXJpZXM6YyxwYWlyczpmLGZpbmRPa2V5SW5kZXg6dn0sdC5leHBvcnRzPW5bXCJkZWZhdWx0XCJdfSx7XCIuL3BpZWNlc1wiOjEzfV0sMTM6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlKXt2YXIgdD1bXTtmb3IodmFyIG4gaW4gQSl0LnB1c2goayhlLG4pLmtleSk7cmV0dXJuIHR9ZnVuY3Rpb24gbyhlKXt2YXIgdD17MDowLDE6MSwyOjIsMzozLDQ6NCw1OjUsNjo2LDc6Nyw4OjgsOTo5fSxuPXRbZVswXV0scj10W2VbMV1dO3JldHVybiB2b2lkIDA9PT1yP3ZvaWQgMD09PW4/e2xlZnQ6ZS5zbGljZSgxKX06e251bWJlcjpuLGxlZnQ6ZS5zbGljZSgxKX06e251bWJlcjoxMCpuK3IsbGVmdDplLnNsaWNlKDIpfX1mdW5jdGlvbiBpKGUpe3ZhciB0PS8oW2x8cnxwXSkoXFxkXFxkPykvLG49ZS5tYXRjaCh0KSxyPW5bMV0sYT1wYXJzZUludChuWzJdKTtyZXR1cm57dHlwZTpyLGdyb3VwSW5kZXg6YX19ZnVuY3Rpb24gdShlKXt2YXIgdD1lWzBdLG49ZVsxXSxyPWVbMl0sYT0yO3JldHVybiBLW3RdPyhBW24rcl0mJihuKz1yLGE9Mykse3BpZWNlOmsodCxuKSxsZWZ0OmUuc2xpY2UoYSl9KTp7bGVmdDplLnNsaWNlKDEpfX1mdW5jdGlvbiBsKGUpe3ZhciB0PVtdLG49W107Zm9yKGUrPVwiXFxuXCI7ZS5sZW5ndGg+MDspe3ZhciByPXUoZSk7ci5waWVjZT9uLnB1c2goci5waWVjZSk6KG4ubGVuZ3RoPjAmJnQucHVzaChuKSxuPVtdKSxlPXIubGVmdH1yZXR1cm4gdH1mdW5jdGlvbiBkKGUpe2Zvcih2YXIgdD1bXSxuPTA7ZS5sZW5ndGg+MDspe3ZhciByPXUoZSk7ci5waWVjZSYmKHRbbl09ci5waWVjZSksbisrLGU9ci5sZWZ0fXJldHVybiB0fWZ1bmN0aW9uIHMoZSl7dmFyIHQ9e307ZT1kKGUpO2Zvcih2YXIgbj0wLHI9MDtyPGUubGVuZ3RoO3IrKyl7aWYoZVtyXSl7Zm9yKDtuPDEwMCYmIURbXCJkZWZhdWx0XCJdLmlzQWxsb3dlZEJvYXJkS2V5KERbXCJkZWZhdWx0XCJdLmVuY29kZUtleShuLFwiYlwiKSk7KW4rKzt0W0RbXCJkZWZhdWx0XCJdLmVuY29kZUtleShuLFwiYlwiKV09ZVtyXSxuKyt9bisrfXJldHVybiB0fWZ1bmN0aW9uIGMoZSx0KXtlPWUuc3BsaXQoXCIgXCIpO3ZhciBuPXt9O3JldHVybiBEW1wiZGVmYXVsdFwiXS5hbGxTaWRlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIERbXCJkZWZhdWx0XCJdLmZpbmRQb3YodCxlKX0pLmZvckVhY2goZnVuY3Rpb24odCxyKXt2YXIgYT1kKGVbcl18fFwiXCIpO25bRFtcImRlZmF1bHRcIl0uZGlzY2FyZEJ5UG92KHQpXT1hfSksbn1mdW5jdGlvbiBmKGUpe3ZhciB0PWUuc3BsaXQoXCIvXCIpLG49TSh0LDIpLHI9blswXSxhPW5bMV07cj1sKHIpLGE9bChhKTt2YXIgbz1wKHIsYSk7cmV0dXJue3NlcmllczpyLHBhaXJzOmEsbGF5b3V0Om8scmVsYXlvdXQ6ZnVuY3Rpb24oZSl7ZS5vcGVucy5sYXlvdXQ9cChlLm9wZW5zLnNlcmllcyxlLm9wZW5zLnBhaXJzKX19fWZ1bmN0aW9uIHAoZSx0KXt2YXIgbixyLGEsbyxpLHU9e30sbD17c2VyaWVzOnt9LHBhaXJzOnt9fSxkPVtdLHM9MDtmb3Iobj0wO248ZS5sZW5ndGg7bisrKXt2YXIgYz1lW25dO289KGRbc118fDEpLTEsaT1zLGwuc2VyaWVzW0RbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFtvLGldKV09bjtmb3IodmFyIGY9MDtmPGMubGVuZ3RoO2YrKylhPWRbc118fDEscj1EW1wiZGVmYXVsdFwiXS5taW5pUG9zMmtleShbYSxzXSksdVtyXT1jW2ZdLGRbc109YSsxO2Rbc10rPTIscysrLHM+PURbXCJkZWZhdWx0XCJdLm1pbmlSb3dzJiYocz0wKX1mb3IoZD1bXSxuPTAsZj0wLHI9MCxhPTAscz0wLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHA9dFtuXTtmb3Iobz0oZFtzXXx8RFtcImRlZmF1bHRcIl0ubWluaUNvbHVtbnMtMSktMSxpPXMsbC5wYWlyc1tEW1wiZGVmYXVsdFwiXS5taW5pUG9zMmtleShbbyxpXSldPW4sZj1wLmxlbmd0aC0xO2Y+PTA7Zi0tKWE9ZFtzXXx8RFtcImRlZmF1bHRcIl0ubWluaUNvbHVtbnMtMSxyPURbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFthLHNdKSx1W3JdPXBbZl0sZFtzXT1hLTE7ZFtzXS09MSxzKysscz49RFtcImRlZmF1bHRcIl0ubWluaVJvd3MmJihzPTApfXJldHVybntsYXlvdXQ6dSxncm91cE1hcDpsfX1mdW5jdGlvbiB2KGUsdCxuKXtmb3IodmFyIHIgaW4gZSlpZihlW3JdPT09dCl7dmFyIGE9RFtcImRlZmF1bHRcIl0ubWluaUtleTJwb3Mociksbz1NKGEsMiksaT1vWzBdLHU9b1sxXSxsPVtpK24sdV07cmV0dXJuIERbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KGwpfX1mdW5jdGlvbiBtKGUsdCxuKXt2YXIgcj1lLmxheW91dC5ncm91cE1hcC5wYWlycztyZXR1cm4gdihyLHQsbil9ZnVuY3Rpb24gZyhlLHQsbil7dmFyIHI9ZS5sYXlvdXQuZ3JvdXBNYXAuc2VyaWVzO3JldHVybiB2KHIsdCxuKX1mdW5jdGlvbiBoKGUsdCl7dmFyIG49ZS5vcGVucyxyPW4uc2VyaWVzLGE9bi5sYXlvdXQuZ3JvdXBNYXAsbz1NKHQsMiksaT1vWzBdLHU9b1sxXTtmb3IodmFyIGwgaW4gYS5zZXJpZXMpe3ZhciBkPWEuc2VyaWVzW2xdLHM9cltkXSxjPURbXCJkZWZhdWx0XCJdLm1pbmlLZXkycG9zKGwpLGY9TShjLDIpLHA9ZlswXSx2PWZbMV0sbT1pLXA7aWYoIShtPDB8fG0+cy5sZW5ndGgrMXx8dSE9dikpcmV0dXJuW2QsbV19fWZ1bmN0aW9uIHkoZSx0KXt2YXIgbj1lLm9wZW5zLHI9bi5wYWlycyxhPW4ubGF5b3V0Lmdyb3VwTWFwLG89TSh0LDIpLGk9b1swXSx1PW9bMV07Zm9yKHZhciBsIGluIGEucGFpcnMpe3ZhciBkPWEucGFpcnNbbF0scz0ocltkXSxEW1wiZGVmYXVsdFwiXS5taW5pS2V5MnBvcyhsKSksYz1NKHMsMiksZj1jWzBdLHA9Y1sxXSx2PWktZjtpZighKHY8MHx8dj4xfHx1IT1wKSlyZXR1cm5bZCx2XX19ZnVuY3Rpb24gdyhlKXt2YXIgdD17fSxuPW8oZSk7cmV0dXJuIHRbRFtcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdPW4ubnVtYmVyLG49dShuLmxlZnQpLHRbRFtcImRlZmF1bHRcIl0uZ29zdGVyZ2VdPW4ucGllY2UsdH1mdW5jdGlvbiBiKGUpe2U9ZS5zcGxpdChcIi9cIik7dmFyIHQ9MixuPTMscj00LGE9MSxvPTAsaT17ZTpcImVhc3RcIix3Olwid2VzdFwiLG46XCJub3J0aFwiLHM6XCJzb3V0aFwifVtlW29dXTtyZXR1cm57cGllY2VzOnMoZVt0XSksZGlzY2FyZHM6YyhlW25dLGkpLG9wZW5zOmYoW2Vbcl0sZVtyKzFdXS5qb2luKFwiL1wiKSksbWlkZGxlczp3KGVbYV0pfX1mdW5jdGlvbiBQKGUpe3ZhciB0PURbXCJkZWZhdWx0XCJdLmFsbEtleXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLmtleXx8XCIgXCJ9KS5qb2luKFwiXCIpO3JldHVybiB0LnJlcGxhY2UoLyhbXlxcc10pXFxzL2csXCIkMVwiKX1mdW5jdGlvbiBrKGUsdCl7cmV0dXJue2NvbG9yOktbZV0sbnVtYmVyOkFbdF0sYzplLG46cGFyc2VJbnQodCksa2V5OmUrdH19ZnVuY3Rpb24gTyhlKXt2YXIgdD1lLmMsbj1lLm4lMTMrMTtyZXR1cm4gayh0LG4pfWZ1bmN0aW9uIHgoZSl7dmFyIHQ9ZS5jLG49KGUubisxMSklMTMrMTtyZXR1cm4gayh0LG4pfWZ1bmN0aW9uIFMoZSl7cmV0dXJuXCJmYWtlXCI9PT1lLmNvbG9yfWZ1bmN0aW9uIEUoZSl7cmV0dXJuIGUubGVuZ3RoPjAmJjE0PT09ZS5tYXRjaChUKS5sZW5ndGh9dmFyIE09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49W10scj0hMCxhPSExLG89dm9pZCAwO3RyeXtmb3IodmFyIGksdT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGk9dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGkudmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaChsKXthPSEwLG89bH1maW5hbGx5e3RyeXshciYmdVtcInJldHVyblwiXSYmdVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYoYSl0aHJvdyBvfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24odCxuKXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0O2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCkpcmV0dXJuIGUodCxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksQz1lKFwiLi91dGlsXCIpLEQ9cihDKSxLPXtiOlwiYmx1ZVwiLHI6XCJyZWRcIixnOlwiZ3JlZW5cIixsOlwiYmxhY2tcIixmOlwiZmFrZVwifSxBPXsxOlwib25lXCIsMjpcInR3b1wiLDM6XCJ0aHJlZVwiLDQ6XCJmb3VyXCIsNTpcImZpdmVcIiw2Olwic2l4XCIsNzpcInNldmVuXCIsODpcImVpZ2h0XCIsOTpcIm5pbmVcIiwxMDpcInRlblwiLDExOlwiZWxldmVuXCIsMTI6XCJ0d2VsdmVcIiwxMzpcInRoaXJ0ZWVuXCJ9LFQ9L1tmfHJ8bHxifGddXFxkXFxkPy9nLEI9ZnVuY3Rpb24oKXt2YXIgZT17fTtmb3IodmFyIHQgaW4gSyllW0tbdF1dPWEodCk7cmV0dXJuIGV9KCksaj1mdW5jdGlvbihlKXtyZXR1cm4gQltlXX0sUj1cImc3cjdiN2w3IGc4cjhiOGw4IGcxM3IxM2IxM2wxMyBsMTIgcjZyNXI0cjEycjEzIGc5ZzhnMTMgZzYgbDhsN2wxMlwiLE49XCJyMWcxbDFiMSByMmcybDJiMiByM2czbDNiMyByNGc0bDRiNCByMTNnMTNsMTNiMTMgcjFnMWwxYjFcIixHPVwicjFyMiByM3I0cjVyNnI3cjhyOXIxMHIxMXIxMnIxM2wxbDJsM2w0bDVsNmw3ICAgZzFnMiAgbDNcIixGPVwiMjBsM1wiLF89XCJiMSAgcjFyMiBnMVwiLEw9XCJyOGw4YjhcXG5iMWIyYjNcXG5iOWIxMGIxMWIxMlxcbmwxM3IxM2IxM1xcbnIxMmIxMmcxMlxcbnI3cjhyOXIxMFxcbmcxMGcxMWcxMlxcbmw2YjZyNlxcbmw5bDEwbDExXFxuYjdsN3I3ZzdcXG5yMTNsMTNiMTNnMTNcXG5sMTByMTBiMTBnMTBcXG5sNnI2ZzZcXG5sMWIxZzFcXG4vcjFyMVxcbmcxZzFcXG5nMmcyXFxuZzNnM1xcbmc0ZzRcXG5nNWc1XFxuZzZnNlxcbmc3ZzdcXG5nOGc4XFxuZzlnOVxcbmcxMGcxMFxcbmcxMWcxMVxcbmcxMmcxMlxcblxcblwiO3QuZXhwb3J0cz17dmFsaWREdXpPa2V5R3JvdXBGZW46RSxpbml0aWFsOkcscmFpbmJvdzpOLG1peGVkOlIsd3JpdGU6UCxyZWFkOmIscmVhZERyb3BQb3M6aSxyZWFkUGllY2U6dSxyZWFkQm9hcmQ6cyxpbml0aWFsTWlkZGxlczpGLGluaXRpYWxEaXNjYXJkczpfLGluaXRpYWxPcGVuR3JvdXBzOkwscmVhZE1pZGRsZXM6dyxyZWFkRGlzY2FyZHM6YyxyZWFkUGllY2VHcm91cDpsLHJlYWRPcGVuR3JvdXBzOmYsbGF5b3V0T3BlbnM6cCxzZXJpZXNCeUNvbG9yOmosbWFrZVBpZWNlOmsscGllY2VVcDpPLHBpZWNlRG93bjp4LHBpZWNlRmFrZTpTLGNvbG9yczpLLGdldE9wZW5TZXJpZUtleUZyb21Hcm91cEluZGV4OmcsZ2V0T3BlblBhaXJLZXlGcm9tR3JvdXBJbmRleDptLGdldE9wZW5TZXJpZUZyb21Qb3M6aCxnZXRPcGVuUGFpckZyb21Qb3M6eX19LHtcIi4vdXRpbFwiOjE1fV0sMTQ6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fSxyPW4ucGllY2UsYT1uLmdyb3VwLHA9bi5wb3M7aWYoZS50dXJuU2lkZT09PWUucG92U2lkZSlzd2l0Y2godCl7Y2FzZSBSW1wiZGVmYXVsdFwiXS5kaXNjYXJkOnI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLG0oZSxyLEJbXCJkZWZhdWx0XCJdLmRpc2NhcmRzWzJdKTticmVhaztjYXNlIFJbXCJkZWZhdWx0XCJdLmRyYXdNaWRkbGU6cj1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UocikucGllY2UsZS5taWRkbGVIb2xkZXIuY3VycmVudD9JW1wiZGVmYXVsdFwiXS5hcGlEcmF3TWlkZGxlRW5kKGUscik6SVtcImRlZmF1bHRcIl0uYXBpRm9yY2VEcmF3TWlkZGxlRW5kKGUscil9ZWxzZXt2YXIgdj1CW1wiZGVmYXVsdFwiXS5maW5kUG92KGUucG92U2lkZSxlLnR1cm5TaWRlKTtzd2l0Y2godCl7Y2FzZSBSW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlOnMoZSksZS5hbmltYXRpb24uY3VycmVudC5oaW50PVJbXCJkZWZhdWx0XCJdLmRyYXdNaWRkbGU7YnJlYWs7Y2FzZSBSW1wiZGVmYXVsdFwiXS5kcmF3TGVmdDpjKGUsQltcImRlZmF1bHRcIl0uZHJhd0J5UG92KHYpKTticmVhaztjYXNlIFJbXCJkZWZhdWx0XCJdLmRpc2NhcmQ6cj1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UocikucGllY2UsZChlLEJbXCJkZWZhdWx0XCJdLmRpc2NhcmRCeVBvdih2KSxyKSxlLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9UltcImRlZmF1bHRcIl0uZGlzY2FyZDticmVhaztjYXNlIFJbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW46cj1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UocikucGllY2UsZihlLEJbXCJkZWZhdWx0XCJdLmRyYXdCeVBvdih2KSxyKTticmVhaztjYXNlIFJbXCJkZWZhdWx0XCJdLm9wZW5TZXJpZXM6YT1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2VHcm91cChhKSx1KGUsYSk7YnJlYWs7Y2FzZSBSW1wiZGVmYXVsdFwiXS5vcGVuUGFpcnM6YT1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2VHcm91cChhKSxsKGUsYSk7YnJlYWs7Y2FzZSBSW1wiZGVmYXVsdFwiXS5kcm9wT3BlblNlcmllczpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxwPUdbXCJkZWZhdWx0XCJdLnJlYWREcm9wUG9zKHApLG8oZSxyLHApO2JyZWFrO2Nhc2UgUltcImRlZmF1bHRcIl0uZHJvcE9wZW5QYWlyczpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSxwPUdbXCJkZWZhdWx0XCJdLnJlYWREcm9wUG9zKHApLGkoZSxyLHApO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS5lcnJvcihcInVua25vd24gbW92ZVwiKX19fWZ1bmN0aW9uIG8oZSx0LG4pe3ZhciByPW4udHlwZSxhPW4uZ3JvdXBJbmRleCxvPWUub3BlbnMuc2VyaWVzW2FdLGk9ciE9PVJbXCJkZWZhdWx0XCJdLmRyb3BSZXBsYWNlPzA6MSx1PTA7aWYocj09PVJbXCJkZWZhdWx0XCJdLmRyb3BMZWZ0KXU9MDtlbHNlIGlmKHI9PT1SW1wiZGVmYXVsdFwiXS5kcm9wUmlnaHQpdT1vLmxlbmd0aCsxO2Vsc2V7dmFyIGw9R1tcImRlZmF1bHRcIl0ucGllY2VVcChlLm1pZGRsZXNbQltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdKTt1PV9bXCJkZWZhdWx0XCJdLmZpbmRPa2V5SW5kZXgobyxsKSsxfW8uc3BsaWNlKHUtaSxpLHQpLGUub3BlbnMucmVsYXlvdXQoZSl9ZnVuY3Rpb24gaShlLHQsbil7dmFyIHI9bi5ncm91cEluZGV4LGE9ZS5vcGVucy5wYWlyc1tyXSxvPUdbXCJkZWZhdWx0XCJdLnBpZWNlVXAoZS5taWRkbGVzW0JbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSksaT1fW1wiZGVmYXVsdFwiXS5maW5kT2tleUluZGV4KGEsbyk7YS5zcGxpY2UoaSwxLHQpLGUub3BlbnMucmVsYXlvdXQoZSl9ZnVuY3Rpb24gdShlLHQpe3ZhciBuPXQscj1lLm9wZW5zLnNlcmllcy5jb25jYXQobik7ZS5vcGVucy5zZXJpZXM9cixlLm9wZW5zLnJlbGF5b3V0KGUpfWZ1bmN0aW9uIGwoZSx0KXt2YXIgbj10LHI9ZS5vcGVucy5wYWlycy5jb25jYXQobik7ZS5vcGVucy5wYWlycz1yLGUub3BlbnMucmVsYXlvdXQoZSl9ZnVuY3Rpb24gZChlLHQsbil7cmV0dXJuIGUuZGlzY2FyZHNbdF0udW5zaGlmdChuKSxlLmxhc3RNb3ZlPVt0XSwhMH1mdW5jdGlvbiBzKGUpe3JldHVybiBlLm1pZGRsZXNbQltcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdLS0sZS5sYXN0TW92ZT1bQltcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdLCEwfWZ1bmN0aW9uIGMoZSx0KXtyZXR1cm4gZS5kaXNjYXJkc1t0XS5zaGlmdCgpLCEwfWZ1bmN0aW9uIGYoZSx0LG4pe3JldHVybiBlLmRpc2NhcmRzW3RdLnVuc2hpZnQobiksITB9ZnVuY3Rpb24gcChlLHQsbixyKXtpZighZS5waWVjZXNbdF18fCFyKXJldHVybiExO3ZhciBhPWUucGllY2VzW3RdO1goQltcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLFJbXCJkZWZhdWx0XCJdLmRyb3BPcGVuU2VyaWVzLHEoYS5rZXkpKSk7dmFyIG89QShyLDIpLGk9b1swXSx1PW9bMV0sbD1lLm9wZW5zLnNlcmllc1tpXSxkPXcobCx1KSxzPWQhPT1SW1wiZGVmYXVsdFwiXS5kcm9wUmVwbGFjZT8wOjE7aWYobC5zcGxpY2UodS1zLHMsYSksZS5vcGVucy5yZWxheW91dChlKSxkZWxldGUgZS5waWVjZXNbdF0sZD09PVJbXCJkZWZhdWx0XCJdLmRyb3BSZXBsYWNlKXt2YXIgYz1HW1wiZGVmYXVsdFwiXS5waWVjZVVwKGUubWlkZGxlc1tCW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0pO2UucGllY2VzW3RdPWN9cmV0dXJuITB9ZnVuY3Rpb24gdihlLHQsbixyKXtpZighZS5waWVjZXNbdF18fCFyKXJldHVybiExO3ZhciBhPWUucGllY2VzW3RdO1goQltcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLFJbXCJkZWZhdWx0XCJdLmRyb3BPcGVuUGFpcnMscShhLmtleSkpKTt2YXIgbz1BKHIsMiksaT1vWzBdLHU9b1sxXSxsPWUub3BlbnMucGFpcnNbaV07bC5zcGxpY2UodSwxLGEpLGUub3BlbnMucmVsYXlvdXQoZSksZGVsZXRlIGUucGllY2VzW3RdO3ZhciBkPUdbXCJkZWZhdWx0XCJdLnBpZWNlVXAoZS5taWRkbGVzW0JbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSk7cmV0dXJuIGUucGllY2VzW3RdPWQsITB9ZnVuY3Rpb24gbShlLHQsbil7Zm9yKHZhciByIGluIGUucGllY2VzKXt2YXIgYT1lLnBpZWNlc1tyXTtpZihhJiZCW1wiZGVmYXVsdFwiXS5waWVjZUVxdWFsKHQsYSkpcmV0dXJuIGcoZSxyLG4pLCEwfXJldHVybiExfWZ1bmN0aW9uIGcoZSx0LG4pe3ZhciByPWUucGllY2VzW3RdO3JldHVybiEhciYmKFgoQltcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLFJbXCJkZWZhdWx0XCJdLmRpc2NhcmQscShyLmtleSkpKSxlLmRpc2NhcmRzW25dLnVuc2hpZnQoZS5waWVjZXNbdF0pLGRlbGV0ZSBlLnBpZWNlc1t0XSxlLmxhc3RNb3ZlPVtuXSwhMCl9ZnVuY3Rpb24gaChlLHQpe3ZhciBuPWUucGllY2VzW3RdO3JldHVybiEhbiYmKCEhQltcImRlZmF1bHRcIl0ucGllY2VFcXVhbChuLGUubWlkZGxlc1tCW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0pJiYoWChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUsUltcImRlZmF1bHRcIl0uc2lnbixxKG4ua2V5KSkpLCEwKSl9ZnVuY3Rpb24geShlLHQpe3ZhciBuPWUucGllY2VzW3RdO2lmKCFuKXJldHVybiExO2RlbGV0ZSBlLnBpZWNlc1t0XTt2YXIgcj0oR1tcImRlZmF1bHRcIl0ud3JpdGUoZS5waWVjZXMpLElbXCJkZWZhdWx0XCJdLmdldFBpZWNlR3JvdXBTZXJpZXMoZSkpLGE9SVtcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFBhaXJzKGUpO2lmKEdbXCJkZWZhdWx0XCJdLnZhbGlkRHV6T2tleUdyb3VwRmVuKHIpKVgoQltcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLFJbXCJkZWZhdWx0XCJdLmRpc2NhcmRFbmRTZXJpZXMsSChyKSkpO2Vsc2V7aWYoIUdbXCJkZWZhdWx0XCJdLnZhbGlkRHV6T2tleUdyb3VwRmVuKGEpKXJldHVybiBlLnBpZWNlc1t0XT1uLCExO1goQltcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLFJbXCJkZWZhdWx0XCJdLmRpc2NhcmRFbmRQYWlycyxIKGEpKSl9cmV0dXJuITB9ZnVuY3Rpb24gdyhlLHQpe3JldHVybiAwPT09dD9SW1wiZGVmYXVsdFwiXS5kcm9wTGVmdDp0PT09ZS5sZW5ndGgrMT9SW1wiZGVmYXVsdFwiXS5kcm9wUmlnaHQ6UltcImRlZmF1bHRcIl0uZHJvcFJlcGxhY2V9ZnVuY3Rpb24gYihlLHQsbil7aWYobiYmQltcImRlZmF1bHRcIl0uaXNPcGVuc0tleShuKSYmRShlLHQsbikpe3ZhciByLGEsbyxpLHUsbD1lLnBpZWNlc1t0XSxkPUdbXCJkZWZhdWx0XCJdLmdldE9wZW5TZXJpZUZyb21Qb3MoZSxCW1wiZGVmYXVsdFwiXS5taW5pS2V5MnBvcyhuKSk7aWYoZCl7dmFyIHM9QShkLDIpO3I9c1swXSxhPXNbMV0sbz1lLm9wZW5zLnNlcmllc1tyXSxpPXcobyxhKSx1PWkrcn1pZihwKGUsdCxuLGQpKXJldHVybiBYKEJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixSW1wiZGVmYXVsdFwiXS5kcm9wT3BlblNlcmllcyxVKGwua2V5LHUpKSksITA7dmFyIGM9R1tcImRlZmF1bHRcIl0uZ2V0T3BlblBhaXJGcm9tUG9zKGUsQltcImRlZmF1bHRcIl0ubWluaUtleTJwb3MobikpO2lmKGMpe3ZhciBmPUEoYywyKTtyPWZbMF0sYT1mWzFdLG89ZS5vcGVucy5wYWlyc1tyXSxpPXcobyxhKSx1PWkrcn1pZih2KGUsdCxuLGMpKXJldHVybiBYKEJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixSW1wiZGVmYXVsdFwiXS5kcm9wT3BlblBhaXJzLFUobC5rZXksdSkpKSwhMH1yZXR1cm4hMX1mdW5jdGlvbiBQKGUsdCxuKXt2YXIgcj1lLnBpZWNlc1t0XTtpZihuJiZuPT09QltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMl0pe2lmKE0oZSx0LG4pJiZnKGUsdCxuKSlyZXR1cm4gWChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIsUltcImRlZmF1bHRcIl0uZGlzY2FyZCxxKHIua2V5KSkpLCEwfWVsc2UgaWYobj09PUJbXCJkZWZhdWx0XCJdLmdvc3RlcmdlKXtpZihEKGUsdCkmJmgoZSx0KSlyZXR1cm4gWChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIsUltcImRlZmF1bHRcIl0uc2lnbixxKHIua2V5KSkpLCEwO2lmKEMoZSx0KSYmeShlLHQpKXt2YXIgYT0oR1tcImRlZmF1bHRcIl0ud3JpdGUoZS5waWVjZXMpLElbXCJkZWZhdWx0XCJdLmdldFBpZWNlR3JvdXBTZXJpZXMoZSkpLG89SVtcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFBhaXJzKGUpO3JldHVybiBHW1wiZGVmYXVsdFwiXS52YWxpZER1ek9rZXlHcm91cEZlbihhKT9YKEJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixSW1wiZGVmYXVsdFwiXS5kaXNjYXJkRW5kU2VyaWVzLEgoYSkpKTpHW1wiZGVmYXVsdFwiXS52YWxpZER1ek9rZXlHcm91cEZlbihvKSYmWChCW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIsUltcImRlZmF1bHRcIl0uZGlzY2FyZEVuZFBhaXJzLEgobykpKSwhMH19cmV0dXJuITF9ZnVuY3Rpb24gayhlLHQpe08oZSx0KX1mdW5jdGlvbiBPKGUsdCl7ZS5zZWxlY3RlZD10fWZ1bmN0aW9uIHgoZSx0KXtyZXR1cm4gQltcImRlZmF1bHRcIl0uaXNNaWRkbGVLZXkodCl8fEJbXCJkZWZhdWx0XCJdLmlzRHJhd0xlZnRLZXkodCk/ZS5wb3ZTaWRlPT09ZS50dXJuU2lkZTpCW1wiZGVmYXVsdFwiXS5pc0JvYXJkS2V5KHQpfWZ1bmN0aW9uIFMoZSl7cmV0dXJuIGUucG92U2lkZT09PWUudHVyblNpZGV9ZnVuY3Rpb24gRShlLHQsbil7dmFyIHI9ZS5taWRkbGVzW0JbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXTtyZXR1cm4gSVtcImRlZmF1bHRcIl0uaXNEcm9wcGFibGVPcGVucyhlLHQpJiZCW1wiZGVmYXVsdFwiXS5pc0JvYXJkS2V5KHQpJiZCW1wiZGVmYXVsdFwiXS5pc09wZW5zS2V5KG4pJiZCW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLFJbXCJkZWZhdWx0XCJdLmRyb3BPcGVuU2VyaWVzKSYmQltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxSW1wiZGVmYXVsdFwiXS5kcm9wT3BlblBhaXJzKSYmQltcImRlZmF1bHRcIl0uY29udGFpbnNYKF9bXCJkZWZhdWx0XCJdLmNvbXB1dGUoZS5vcGVucyxlLnBpZWNlc1t0XSxyKSxuKX1mdW5jdGlvbiBNKGUsdCxuKXtyZXR1cm4gUyhlKSYmQltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxSW1wiZGVmYXVsdFwiXS5kaXNjYXJkKX1mdW5jdGlvbiBDKGUsdCl7cmV0dXJuIFMoZSkmJkJbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMsUltcImRlZmF1bHRcIl0uZGlzY2FyZEVuZFNlcmllcyl9ZnVuY3Rpb24gRChlLHQpe3JldHVybiBTKGUpJiZCW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLFJbXCJkZWZhdWx0XCJdLnNob3dTaWduKX1mdW5jdGlvbiBLKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpCW1wiZGVmYXVsdFwiXS50b3BDb2x1bW5zLG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOkJbXCJkZWZhdWx0XCJdLnRvcFJvd3M7cmV0dXJuIGZ1bmN0aW9uKHIsYSxvKXtpZihvfHxyLmJvdW5kcyl7bz1vfHxyLmJvdW5kcygpO3ZhciBpPU1hdGguZmxvb3IodCooKGFbMF0tby5sZWZ0KS9vLndpZHRoKSksdT1NYXRoLmZsb29yKG4qKChhWzFdLW8udG9wKS9vLmhlaWdodCkpO3JldHVybiB1Pj0wJiZ1PG4mJmk+PTAmJmk8dD9lKHUsaSk6dm9pZCAwfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIEE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49W10scj0hMCxhPSExLG89dm9pZCAwO3RyeXtmb3IodmFyIGksdT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGk9dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKGkudmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaChsKXthPSEwLG89bH1maW5hbGx5e3RyeXshciYmdVtcInJldHVyblwiXSYmdVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYoYSl0aHJvdyBvfX1yZXR1cm4gbn1yZXR1cm4gZnVuY3Rpb24odCxuKXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0O2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCkpcmV0dXJuIGUodCxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19KCksVD1lKFwiLi91dGlsXCIpLEI9cihUKSxqPWUoXCIuL21vdmVcIiksUj1yKGopLE49ZShcIi4vcGllY2VzXCIpLEc9cihOKSxGPWUoXCIuL29wZW5cIiksXz1yKEYpLEw9ZShcIi4vYm9hcmRcIiksST1yKEwpLFU9QltcImRlZmF1bHRcIl0ud3JhcERyb3AscT1CW1wiZGVmYXVsdFwiXS53cmFwUGllY2UsSD1CW1wiZGVmYXVsdFwiXS53cmFwR3JvdXAsWD1CW1wiZGVmYXVsdFwiXS5jYWxsVXNlckZ1bmN0aW9uLHo9SyhmdW5jdGlvbihlLHQpe3JldHVybiBCW1wiZGVmYXVsdFwiXS5taW5pUG9zMmtleShbdCxlXSl9LEJbXCJkZWZhdWx0XCJdLm1pbmlDb2x1bW5zLEJbXCJkZWZhdWx0XCJdLm1pbmlSb3dzKSwkPUsoZnVuY3Rpb24oZSx0KXtpZihlPT09QltcImRlZmF1bHRcIl0udG9wUm93cy0xKXtpZigwPT09dClyZXR1cm4gQltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMV07aWYodD09PUJbXCJkZWZhdWx0XCJdLnRvcENvbHVtbnMtNClyZXR1cm4gQltcImRlZmF1bHRcIl0ubWlkZGxlQ291bnR9fSksSj1LKGZ1bmN0aW9uKGUsdCl7aWYoZT09PUJbXCJkZWZhdWx0XCJdLnRvcFJvd3MtMSl7aWYodD09PUJbXCJkZWZhdWx0XCJdLnRvcENvbHVtbnMtMSlyZXR1cm4gQltcImRlZmF1bHRcIl0uZGlzY2FyZHNbMl07aWYodD09PUJbXCJkZWZhdWx0XCJdLnRvcENvbHVtbnMtMylyZXR1cm4gQltcImRlZmF1bHRcIl0uZ29zdGVyZ2V9fSk7bltcImRlZmF1bHRcIl09e2FwaU1vdmU6YSxzZWxlY3RUb3A6ayxkcm9wVG9wOlAsZHJvcE9wZW5zOmIsaXNEcmFnZ2FibGU6eCxnZXREcmF3S2V5QXREb21Qb3M6JCxnZXREaXNjYXJkS2V5QXREb21Qb3M6SixnZXRPcGVuc0tleUF0RG9tUG9zOnp9LHQuZXhwb3J0cz1uW1wiZGVmYXVsdFwiXX0se1wiLi9ib2FyZFwiOjUsXCIuL21vdmVcIjoxMSxcIi4vb3BlblwiOjEyLFwiLi9waWVjZXNcIjoxMyxcIi4vdXRpbFwiOjE1fV0sMTU6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7cmV0dXJuIEdbZV1bdF19ZnVuY3Rpb24gYShlLHQpe3JldHVybiBlLmNvbG9yPT09dC5jb2xvciYmZS5udW1iZXI9PT10Lm51bWJlcn1mdW5jdGlvbiBvKGUsdCl7Zm9yKHZhciBuPVtdLHI9MDtyPGU7cisrKWZvcih2YXIgYT0wO2E8dDthKyspbi5wdXNoKFthLHJdKTtyZXR1cm4gbn1mdW5jdGlvbiBpKGUsdCl7cmV0dXJuIHQrZX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuIHBhcnNlSW50KGUuc2xpY2UoMSkpfWZ1bmN0aW9uIGwoZSl7cmV0dXJuIGkodShlKS0xLFYpfWZ1bmN0aW9uIGQoZSl7cmV0dXJuIGVbMF09PT1WfWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGVbMF09PT1ZfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGU9PT1YfWZ1bmN0aW9uIGYoZSl7cmV0dXJuIGU9PT1IWzFdfWZ1bmN0aW9uIHAoZSl7dmFyIHQ9ZVsxXSpLK2VbMF07cmV0dXJuIGkodCxWKX1mdW5jdGlvbiB2KGUpe3JldHVybiBlPXUoZSksW2UlSyxNYXRoLmZsb29yKGUvSyldfWZ1bmN0aW9uIG0oZSl7cmV0dXJuICRbZV19ZnVuY3Rpb24gZyhlKXt2YXIgdD1lWzFdKmorZVswXTtyZXR1cm4gaSh0LFkpfWZ1bmN0aW9uIGgoZSl7cmV0dXJuIGU9dShlKSxbZSVqLE1hdGguZmxvb3IoZS9qKV19ZnVuY3Rpb24geShlKXt2YXIgdD1bXTtmb3IodmFyIG4gaW4gZSllW25dJiZ0LnB1c2gobik7cmV0dXJuIHQuam9pbihcIiBcIil9ZnVuY3Rpb24gdyhlLHQpe3JldHVybiBlJiZlLmluZGV4T2YodCkhPT0tMX1mdW5jdGlvbiBiKGUpe3JldHVybiBlLnRvdWNoZXM/W2UudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYLGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZXTpbZS5jbGllbnRYLGUuY2xpZW50WV19ZnVuY3Rpb24gUChlLHQpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZVswXS10WzBdLDIpK01hdGgucG93KGVbMV0tdFsxXSwyKSl9ZnVuY3Rpb24gaygpe3JldHVyblwidHJhbnNmb3JtXCJpbiBkb2N1bWVudC5ib2R5LnN0eWxlP1widHJhbnNmb3JtXCI6XCJ3ZWJraXRUcmFuc2Zvcm1cImluIGRvY3VtZW50LmJvZHkuc3R5bGU/XCJ3ZWJraXRUcmFuc2Zvcm1cIjpcIm1velRyYW5zZm9ybVwiaW4gZG9jdW1lbnQuYm9keS5zdHlsZT9cIm1velRyYW5zZm9ybVwiOlwib1RyYW5zZm9ybVwiaW4gZG9jdW1lbnQuYm9keS5zdHlsZT9cIm9UcmFuc2Zvcm1cIjpcIm1zVHJhbnNmb3JtXCJ9ZnVuY3Rpb24gTygpe3JldHVybiBEfHwoRD1rKCkpLER9ZnVuY3Rpb24geChlKXtyZXR1cm5cInRyYW5zbGF0ZShcIitlWzBdK1wicHgsXCIrZVsxXStcInB4KVwifWZ1bmN0aW9uIFMoZSx0KXtyZXR1cm4gZS5iaW5kLmFwcGx5KGUsW251bGxdLmNvbmNhdCh0KSl9ZnVuY3Rpb24gRSgpe3JldHVybiBTKGFyZ3VtZW50c1swXSxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpfWZ1bmN0aW9uIE0oZSl7dmFyIHQsbj1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10JiYodD1lKCkpLHR9O3JldHVybiBuLmNsZWFyPWZ1bmN0aW9uKCl7dD12b2lkIDB9LG59ZnVuY3Rpb24gQyhlKXtzZXRUaW1lb3V0KGUsMSl9dmFyIEQsSz0zMixBPTIsVD0xNixCPTcsaj0yMCxSPTgsTj1bXCJlYXN0XCIsXCJ3ZXN0XCIsXCJub3J0aFwiLFwic291dGhcIl0sRz17ZWFzdDp7ZWFzdDpcImRvd25cIix3ZXN0OlwidXBcIixub3J0aDpcInJpZ2h0XCIsc291dGg6XCJsZWZ0XCJ9LHdlc3Q6e2Vhc3Q6XCJ1cFwiLHdlc3Q6XCJkb3duXCIsbm9ydGg6XCJsZWZ0XCIsc291dGg6XCJyaWdodFwifSxub3J0aDp7ZWFzdDpcImxlZnRcIix3ZXN0OlwicmlnaHRcIixub3J0aDpcImRvd25cIixzb3V0aDpcInVwXCJ9LHNvdXRoOntlYXN0OlwicmlnaHRcIix3ZXN0OlwibGVmdFwiLG5vcnRoOlwidXBcIixzb3V0aDpcImRvd25cIn19LEY9e3VwOjAsbGVmdDoxLGRvd246MixyaWdodDozfSxfPXt1cDozLGxlZnQ6MCxkb3duOjEscmlnaHQ6Mn0sTD17dXA6Wy41LDBdLGxlZnQ6WzAsLjVdLHJpZ2h0OlsxLC41XSxkb3duOlsuNSwxXX0sST1mdW5jdGlvbihlKXtyZXR1cm4gTFtlXX0sVT1mdW5jdGlvbihlKXtyZXR1cm4gSFtGW2VdXX0scT1mdW5jdGlvbihlKXtyZXR1cm4gSFtfW2VdXX0sSD1bXCJkdXBcIixcImRsZWZ0XCIsXCJkZG93blwiLFwiZHJpZ2h0XCJdLFg9XCJtbWlkZGxlQ291bnRcIix6PVwibWdvc3RlcmdlXCIsJD17ZHVwOlswLDBdLGRsZWZ0OlswLEItMV0sZGRvd246W1QtMSxCLTFdLGRyaWdodDpbVC0xLDBdLG1taWRkbGVDb3VudDpbVC00LEItMV0sbWdvc3RlcmdlOltULTMsQi0xXX0sSj17Y29sb3I6XCJlbXB0eVwiLG51bWJlcjoxfSxWPVwiYlwiLFk9XCJvXCIsUT1vKEEsSyksVz1vKFIsaiksWj1bWzAsMF0sWzMwLDBdLFszMSwwXSxbMzIsMF0sWzYyLDBdLFs2MywwXV0ubWFwKHApLGVlPWZ1bmN0aW9uKGUpe3JldHVybiBaLmluZGV4T2YoZSk9PT0tMX0sdGU9US5tYXAocCksbmU9dGUuZmlsdGVyKGVlKSxyZT1mdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307cmV0dXJuIHQucGllY2U9ZSx0fSxhZT1mdW5jdGlvbihlKXtyZXR1cm57Z3JvdXA6ZX19LG9lPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3BpZWNlOmUscG9zOnR9fTt0LmV4cG9ydHM9e3RvcENvbHVtbnM6VCx0b3BSb3dzOkIsY29sdW1uczpLLHJvd3M6QSxlbXB0eVBpZWNlOkoscGllY2VFcXVhbDphLGFsbFNpZGVzOk4sYWxsUG9zOlEsYWxsS2V5czp0ZSx0b3BLZXkycG9zOm0scG9zMmtleTpwLGtleTJwb3M6dixtaW5pQ29sdW1uczpqLG1pbmlSb3dzOlIsbWluaUFsbFBvczpXLG1pbmlQb3Mya2V5OmcsbWluaUtleTJwb3M6aCxlbmNvZGVLZXk6aSxkZWNCb2FyZEtleTpsLG5vdEFsbG93ZWRCb2FyZEtleXM6Wixpc0FsbG93ZWRCb2FyZEtleTplZSxhbGxBbGxvd2VkQm9hcmRLZXlzOm5lLGlzQm9hcmRLZXk6ZCxpc09wZW5zS2V5OnMsaXNNaWRkbGVLZXk6Yyxpc0RyYXdMZWZ0S2V5OmYsZmluZFBvdjpyLHZlY3RvckJ5UG92OkksZHJhd0J5UG92OnEsZGlzY2FyZEJ5UG92OlUsZGlzY2FyZHM6SCxtaWRkbGVDb3VudDpYLGdvc3RlcmdlOnosY2xhc3NTZXQ6eSxjb250YWluc1g6dyxldmVudFBvc2l0aW9uOmIsZGlzdGFuY2U6UCx0cmFuc2Zvcm1Qcm9wOk8sdHJhbnNsYXRlOngscmVxdWVzdEFuaW1hdGlvbkZyYW1lOih3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cuc2V0VGltZW91dCkuYmluZCh3aW5kb3cpLHBhcnRpYWxBcHBseTpTLHBhcnRpYWw6RSxtZW1vOk0sd3JhcFBpZWNlOnJlLHdyYXBHcm91cDphZSx3cmFwRHJvcDpvZSxjYWxsVXNlckZ1bmN0aW9uOkN9fSx7fV0sMTY6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlKXtyZXR1cm4gZS5jb2xvcitcIiBcIitlLm51bWJlcn1mdW5jdGlvbiBvKGUpe3JldHVybntsZWZ0OmVbMF0qKDEwMC9LW1wiZGVmYXVsdFwiXS5jb2x1bW5zKStcIiVcIix0b3A6ZVsxXSooMTAwL0tbXCJkZWZhdWx0XCJdLnJvd3MpK1wiJVwifX1mdW5jdGlvbiBpKGUpe3JldHVybntsZWZ0OmVbMF0qKDEwMC9LW1wiZGVmYXVsdFwiXS5taW5pQ29sdW1ucykrXCIlXCIsdG9wOmVbMV0qKDEwMC9LW1wiZGVmYXVsdFwiXS5taW5pUm93cykrXCIlXCJ9fWZ1bmN0aW9uIHUoZSx0LG4scil7dmFyIG89KGUuZGF0YSx7a2V5Om4sc3R5bGU6aSh0KSxcImNsYXNzXCI6YShyKStcIiBtaW5pXCJ9KTtyZXR1cm57dGFnOlwicGllY2VcIixhdHRyczpvfX1mdW5jdGlvbiBsKGUsdCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdLG89ZS5kYXRhLGk9S1tcImRlZmF1bHRcIl0uY2xhc3NTZXQoe3NlbGVjdGVkOm8uc2VsZWN0ZWQ9PT10LFwibGFzdC1tb3ZlXCI6by5sYXN0TW92ZSYmS1tcImRlZmF1bHRcIl0uY29udGFpbnNYKG8ubGFzdE1vdmUsdCl9KSx1PXtzdHlsZTp7fSxcImNsYXNzXCI6W2EobiksdCxpXS5qb2luKFwiIFwiKSxcImRhdGEtbWlkZGxlLWNvdW50XCI6ZS5kYXRhLm1pZGRsZXNbdF19LGw9ZS5kYXRhLmRyYWdnYWJsZS5jdXJyZW50O2lmKHImJmwub3JpZz09PXQpdS5zdHlsZVtLW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldPUtbXCJkZWZhdWx0XCJdLnRyYW5zbGF0ZShbbC5wb3NbMF0rbC5kZWNbMF0sbC5wb3NbMV0rbC5kZWNbMV1dKSx1W1wiY2xhc3NcIl0rPVwiIGRyYWdnaW5nXCI7ZWxzZSBpZighciYmZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zKXt2YXIgZD1lLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXNbdF07ZCYmKHUuc3R5bGVbS1tcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1LW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoZFsxXSkpfXJldHVybnt0YWc6XCJwaWVjZVwiLGF0dHJzOnV9fWZ1bmN0aW9uIGQoZSx0LG4scil7dmFyIG89IShhcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XSl8fGFyZ3VtZW50c1s0XSxpPWUuZGF0YSx1PUtbXCJkZWZhdWx0XCJdLmNsYXNzU2V0KHtzZWxlY3RlZDppLnNlbGVjdGVkPT09dH0pLGw9e2tleTp0KyhvP1wiXCI6XCJkXCIpLHN0eWxlOnt9LFwiY2xhc3NcIjpbYShuKSx0LHVdLmpvaW4oXCIgXCIpfTtyJiYobFtcImNsYXNzXCJdKz1cIiBcIityKTt2YXIgZD1lLmRhdGEuZHJhZ2dhYmxlLmN1cnJlbnQ7aWYobyYmZC5vcmlnPT09dClsLnN0eWxlW0tbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV09S1tcImRlZmF1bHRcIl0udHJhbnNsYXRlKFtkLnBvc1swXStkLmRlY1swXSxkLnBvc1sxXStkLmRlY1sxXV0pLGxbXCJjbGFzc1wiXSs9XCIgZHJhZ2dpbmdcIjtlbHNlIGlmKG8mJmUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltcyl7dmFyIHM9ZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW3RdO3MmJihsLnN0eWxlW0tbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV09S1tcImRlZmF1bHRcIl0udHJhbnNsYXRlKHNbMV0pKX1yZXR1cm57dGFnOlwicGllY2VcIixhdHRyczpsfX1mdW5jdGlvbiBzKGUsdCxuKXt2YXIgcj0oZS5kYXRhLEtbXCJkZWZhdWx0XCJdLmNsYXNzU2V0KHtcInBpZWNlLWhvbGRlclwiOiEwfSkpLGE9e2tleTp0LHN0eWxlOnt9LFwiY2xhc3NcIjpbdCxyLG5dLmpvaW4oXCIgXCIpfTtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6YX19ZnVuY3Rpb24gYyhlLHQsbixyLGkpe3ZhciB1PWUuZGF0YSxsPUtbXCJkZWZhdWx0XCJdLmNsYXNzU2V0KHtzZWxlY3RlZDp1LnNlbGVjdGVkPT09bn0pLGQ9e2tleTpuLHN0eWxlOm8odCksXCJjbGFzc1wiOlthKHIpLGxdLmpvaW4oXCIgXCIpfTtpJiYoZFtcImNsYXNzXCJdKz1cIiBcIitpKTt2YXIgcz1lLmRhdGEuZHJhZ2dhYmxlLmN1cnJlbnQ7cmV0dXJuIHMub3JpZz09PW4mJihzLm92ZXImJktbXCJkZWZhdWx0XCJdLmlzT3BlbnNLZXkocy5vdmVyKSYmKGQuc3R5bGUud2lkdGg9cy5vcGVuc0JvdW5kcy53aWR0aC9LW1wiZGVmYXVsdFwiXS5taW5pQ29sdW1ucytcInB4XCIsZC5zdHlsZS5oZWlnaHQ9cy5vcGVuc0JvdW5kcy5oZWlnaHQvS1tcImRlZmF1bHRcIl0ubWluaVJvd3MrXCJweFwiKSxkLnN0eWxlW0tbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV09S1tcImRlZmF1bHRcIl0udHJhbnNsYXRlKFtzLnBvc1swXStzLmRlY1swXSxzLnBvc1sxXStzLmRlY1sxXV0pLGRbXCJjbGFzc1wiXSs9XCIgZHJhZ2dpbmdcIikse3RhZzpcInBpZWNlXCIsYXR0cnM6ZH19ZnVuY3Rpb24gZihlLHQsbil7cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntcImNsYXNzXCI6ZStcIiBvYyBcIitufX19ZnVuY3Rpb24gcChlLHQsbil7cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntzdHlsZTppKG4pLFwiY2xhc3NcIjplK1wiIG9jXCJ9fX1mdW5jdGlvbiB2KGUsdCxuKXtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6e3N0eWxlOm8obiksXCJjbGFzc1wiOmV9fX1mdW5jdGlvbiBtKGUpe2Z1bmN0aW9uIHQoZSl7cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntcImNsYXNzXCI6XCJ3b29kIFwiK2V9fX12YXIgbixyPWUuZGF0YSxhPUtbXCJkZWZhdWx0XCJdLmFsbFBvcyxvPVtdO28ucHVzaCh0KFwibGVmdFwiKSx0KFwicmlnaHRcIikpO2Zvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKXt2YXIgdT1LW1wiZGVmYXVsdFwiXS5wb3Mya2V5KGFbaV0pLGw9ci5waWVjZXNbdV07bCYmby5wdXNoKGMoZSxhW2ldLHUsbCkpLHIuZHJhZ2dhYmxlLmN1cnJlbnQub3Zlcj09PXUmJihuPXYoXCJkcmFnLW92ZXJcIixlLGFbaV0pKX1yZXR1cm4gci5taWRkbGVIb2xkZXIua2V5JiZvLnB1c2goYyhlLEtbXCJkZWZhdWx0XCJdLmtleTJwb3Moci5taWRkbGVIb2xkZXIua2V5KSxyLm1pZGRsZUhvbGRlci5rZXksS1tcImRlZmF1bHRcIl0uZW1wdHlQaWVjZSxcImxvYWRpbmdcIikpLG4mJm8ucHVzaChuKSx7dGFnOlwiZGl2XCIsYXR0cnM6e2NvbmZpZzpmdW5jdGlvbih0LG4scil7bnx8KGUuZGF0YS5ib2FyZEJvdW5kcz1LW1wiZGVmYXVsdFwiXS5tZW1vKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQodCkpKX0sXCJjbGFzc1wiOlwib2ctYm9hcmRcIn0sY2hpbGRyZW46b319ZnVuY3Rpb24gZyhlLHQpe2Zvcih2YXIgbj1lLmRhdGEscj1LW1wiZGVmYXVsdFwiXS5taW5pQWxsUG9zLGE9W10sbz1bXSxpPTA7aTxyLmxlbmd0aDtpKyspe3ZhciBsPUtbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KHJbaV0pLGQ9dFtsXTtkJiZhLnB1c2godShlLHJbaV0sbCxkKSk7dmFyIHM9S1tcImRlZmF1bHRcIl0uY2xhc3NTZXQoe1wiZHJhZy1vdmVyXCI6bi5kcmFnZ2FibGUuY3VycmVudC5vdmVyPT09bCxcIm1vdmUtZGVzdFwiOktbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChuLm9wZW5hYmxlLmRlc3RzLGwpfSk7XCJcIiE9PXMmJm8ucHVzaChwKHMsZSxyW2ldKSl9cmV0dXJuIGEucHVzaChvKSxhfWZ1bmN0aW9uIGgoZSl7dmFyIHQ9ZS5kYXRhLG49ZyhlLHQub3BlbnMubGF5b3V0LmxheW91dCk7cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntjb25maWc6ZnVuY3Rpb24odCxuLHIpe258fChlLmRhdGEub3BlbnNCb3VuZHM9S1tcImRlZmF1bHRcIl0ubWVtbyh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdC5iaW5kKHQpKSl9LFwiY2xhc3NcIjpcIm9nLW9wZW5zXCJ9LGNoaWxkcmVuOm59fWZ1bmN0aW9uIHkoZSl7dmFyIHQ9ZS5kYXRhLG49W10scj1bXTtmb3IodmFyIGEgaW4gdC5kaXNjYXJkcyl7dmFyIG89dC5kaXNjYXJkc1thXVswXSxpPUtbXCJkZWZhdWx0XCJdLmNsYXNzU2V0KHtcImRyYWctb3ZlclwiOnQuZHJhZ2dhYmxlLmN1cnJlbnQub3Zlcj09PWEsXCJtb3ZlLWRlc3RcIjpcImRkb3duXCI9PT1hJiZ0LnNlbGVjdGVkJiZLW1wiZGVmYXVsdFwiXS5pc0JvYXJkS2V5KHQuc2VsZWN0ZWQpJiZLW1wiZGVmYXVsdFwiXS5jb250YWluc1godC5tb3ZhYmxlLmRlc3RzLFRbXCJkZWZhdWx0XCJdLmRpc2NhcmQpLFwibGFzdC1tb3ZlXCI6dC5sYXN0TW92ZSYmS1tcImRlZmF1bHRcIl0uY29udGFpbnNYKHQubGFzdE1vdmUsYSl9KTtvPyh0LmRpc2NhcmRzW2FdWzFdJiZyLnB1c2goZChlLGEsdC5kaXNjYXJkc1thXVsxXSxcImZha2VcIiwhMSkpLHIucHVzaChkKGUsYSxvLGkpKSk6bi5wdXNoKHMoZSxhLGkpKX1yZXR1cm4gbi5wdXNoKHIpLG59ZnVuY3Rpb24gdyhlKXt2YXIgdD1lLmRhdGEsbj1bXSxyPXQubWlkZGxlSG9sZGVyLnBpZWNlfHxLW1wiZGVmYXVsdFwiXS5lbXB0eVBpZWNlO3JldHVybiBuLnB1c2goZChlLEtbXCJkZWZhdWx0XCJdLmdvc3RlcmdlLHQubWlkZGxlc1tLW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0pKSxuLnB1c2gobChlLEtbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50LEtbXCJkZWZhdWx0XCJdLmVtcHR5UGllY2UpKSwoS1tcImRlZmF1bHRcIl0uaXNNaWRkbGVLZXkodC5kcmFnZ2FibGUuY3VycmVudC5vcmlnKXx8dC5hbmltYXRpb24uY3VycmVudC5hbmltcyYmdC5hbmltYXRpb24uY3VycmVudC5hbmltc1tLW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0pJiZuLnB1c2gobChlLEtbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50LHIsITApKSx0LmRyYWdnYWJsZS5jdXJyZW50Lm92ZXI9PT1LW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZSYmbi5wdXNoKGYoXCJkcmFnLW92ZXJcIixlLEtbXCJkZWZhdWx0XCJdLmdvc3RlcmdlKSksbn1mdW5jdGlvbiBiKGUpe3ZhciB0PVt3KGUpLHkoZSksaChlKV07cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntjb25maWc6ZnVuY3Rpb24odCxuLHIpe258fChlLmRhdGEudG9wQm91bmRzPUtbXCJkZWZhdWx0XCJdLm1lbW8odC5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZCh0KSkpfSxcImNsYXNzXCI6XCJvZy10b3BcIn0sY2hpbGRyZW46dH19ZnVuY3Rpb24gUChlKXtyZXR1cm5bYihlKSxtKGUpXX1mdW5jdGlvbiBrKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3QoZSxuKX19ZnVuY3Rpb24gTyhlLHQsbil7dmFyIHI9ZS5kYXRhLGE9ayhyLENbXCJkZWZhdWx0XCJdLnN0YXJ0KSxvPWsocixDW1wiZGVmYXVsdFwiXS5tb3ZlKSxpPWsocixDW1wiZGVmYXVsdFwiXS5lbmQpLHU9W1widG91Y2hzdGFydFwiLFwibW91c2Vkb3duXCJdLGw9W1widG91Y2htb3ZlXCIsXCJtb3VzZW1vdmVcIl0sZD1bXCJ0b3VjaGVuZFwiLFwibW91c2V1cFwiXTt1LmZvckVhY2goZnVuY3Rpb24oZSl7dC5hZGRFdmVudExpc3RlbmVyKGUsYSl9KSxsLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlLG8pfSksZC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZSxpKX0pLG4ub251bmxvYWQ9ZnVuY3Rpb24oKXt1LmZvckVhY2goZnVuY3Rpb24oZSl7dC5yZW1vdmVFdmVudExpc3RlbmVyKGUsYSl9KSxsLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLG8pfSksZC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxpKX0pfX1mdW5jdGlvbiB4KGUpe1xucmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntcImNsYXNzXCI6XCJvZy10YWJsZVwiLGNvbmZpZzpmdW5jdGlvbih0LG4scil7bnx8KE8oZSx0LHIpLGUuZGF0YS5yZW5kZXI9ZnVuY3Rpb24oKXtFW1wiZGVmYXVsdFwiXS5yZW5kZXIodCxQKGUpKX0sZS5kYXRhLnJlbmRlclJBRj1mdW5jdGlvbigpe0tbXCJkZWZhdWx0XCJdLnJlcXVlc3RBbmltYXRpb25GcmFtZShlLmRhdGEucmVuZGVyKX0sZS5kYXRhLmJvdW5kcz1LW1wiZGVmYXVsdFwiXS5tZW1vKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQodCkpLGUuZGF0YS5lbGVtZW50PXQsZS5kYXRhLnJlbmRlcigpKX19LGNoaWxkcmVuOltdfX12YXIgUz1lKFwibWl0aHJpbFwiKSxFPXIoUyksTT1lKFwiLi9kcmFnXCIpLEM9cihNKSxEPWUoXCIuL3V0aWxcIiksSz1yKEQpLEE9ZShcIi4vbW92ZVwiKSxUPXIoQSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7Y29uZmlnOmZ1bmN0aW9uKHQsbil7bnx8W1wib25zY3JvbGxcIixcIm9ucmVzaXplXCJdLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49d2luZG93W3RdO3dpbmRvd1t0XT1mdW5jdGlvbigpe24mJm4oKSxlLmRhdGEuYm91bmRzLmNsZWFyKCksZS5kYXRhLmJvYXJkQm91bmRzLmNsZWFyKCksZS5kYXRhLm9wZW5zQm91bmRzLmNsZWFyKCksZS5kYXRhLnRvcEJvdW5kcy5jbGVhcigpfX0pfSxcImNsYXNzXCI6W1wib2ctdGFibGUtd3JhcFwiXS5qb2luKFwiIFwiKX0sY2hpbGRyZW46W3goZSldfX19LHtcIi4vZHJhZ1wiOjksXCIuL21vdmVcIjoxMSxcIi4vdXRpbFwiOjE1LG1pdGhyaWw6Mn1dfSx7fSxbMTBdKSgxMCl9KTsiLCIvKiBNSVQgbGljZW5zZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmdiMmhzbDogcmdiMmhzbCxcbiAgcmdiMmhzdjogcmdiMmhzdixcbiAgcmdiMmh3YjogcmdiMmh3YixcbiAgcmdiMmNteWs6IHJnYjJjbXlrLFxuICByZ2Iya2V5d29yZDogcmdiMmtleXdvcmQsXG4gIHJnYjJ4eXo6IHJnYjJ4eXosXG4gIHJnYjJsYWI6IHJnYjJsYWIsXG4gIHJnYjJsY2g6IHJnYjJsY2gsXG5cbiAgaHNsMnJnYjogaHNsMnJnYixcbiAgaHNsMmhzdjogaHNsMmhzdixcbiAgaHNsMmh3YjogaHNsMmh3YixcbiAgaHNsMmNteWs6IGhzbDJjbXlrLFxuICBoc2wya2V5d29yZDogaHNsMmtleXdvcmQsXG5cbiAgaHN2MnJnYjogaHN2MnJnYixcbiAgaHN2MmhzbDogaHN2MmhzbCxcbiAgaHN2Mmh3YjogaHN2Mmh3YixcbiAgaHN2MmNteWs6IGhzdjJjbXlrLFxuICBoc3Yya2V5d29yZDogaHN2MmtleXdvcmQsXG5cbiAgaHdiMnJnYjogaHdiMnJnYixcbiAgaHdiMmhzbDogaHdiMmhzbCxcbiAgaHdiMmhzdjogaHdiMmhzdixcbiAgaHdiMmNteWs6IGh3YjJjbXlrLFxuICBod2Iya2V5d29yZDogaHdiMmtleXdvcmQsXG5cbiAgY215azJyZ2I6IGNteWsycmdiLFxuICBjbXlrMmhzbDogY215azJoc2wsXG4gIGNteWsyaHN2OiBjbXlrMmhzdixcbiAgY215azJod2I6IGNteWsyaHdiLFxuICBjbXlrMmtleXdvcmQ6IGNteWsya2V5d29yZCxcblxuICBrZXl3b3JkMnJnYjoga2V5d29yZDJyZ2IsXG4gIGtleXdvcmQyaHNsOiBrZXl3b3JkMmhzbCxcbiAga2V5d29yZDJoc3Y6IGtleXdvcmQyaHN2LFxuICBrZXl3b3JkMmh3Yjoga2V5d29yZDJod2IsXG4gIGtleXdvcmQyY215azoga2V5d29yZDJjbXlrLFxuICBrZXl3b3JkMmxhYjoga2V5d29yZDJsYWIsXG4gIGtleXdvcmQyeHl6OiBrZXl3b3JkMnh5eixcblxuICB4eXoycmdiOiB4eXoycmdiLFxuICB4eXoybGFiOiB4eXoybGFiLFxuICB4eXoybGNoOiB4eXoybGNoLFxuXG4gIGxhYjJ4eXo6IGxhYjJ4eXosXG4gIGxhYjJyZ2I6IGxhYjJyZ2IsXG4gIGxhYjJsY2g6IGxhYjJsY2gsXG5cbiAgbGNoMmxhYjogbGNoMmxhYixcbiAgbGNoMnh5ejogbGNoMnh5eixcbiAgbGNoMnJnYjogbGNoMnJnYlxufVxuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG4iLCJ2YXIgY29udmVyc2lvbnMgPSByZXF1aXJlKFwiLi9jb252ZXJzaW9uc1wiKTtcblxudmFyIGNvbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgQ29udmVydGVyKCk7XG59XG5cbmZvciAodmFyIGZ1bmMgaW4gY29udmVyc2lvbnMpIHtcbiAgLy8gZXhwb3J0IFJhdyB2ZXJzaW9uc1xuICBjb252ZXJ0W2Z1bmMgKyBcIlJhd1wiXSA9ICAoZnVuY3Rpb24oZnVuYykge1xuICAgIC8vIGFjY2VwdCBhcnJheSBvciBwbGFpbiBhcmdzXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgIH1cbiAgfSkoZnVuYyk7XG5cbiAgdmFyIHBhaXIgPSAvKFxcdyspMihcXHcrKS8uZXhlYyhmdW5jKSxcbiAgICAgIGZyb20gPSBwYWlyWzFdLFxuICAgICAgdG8gPSBwYWlyWzJdO1xuXG4gIC8vIGV4cG9ydCByZ2IyaHNsIGFuZCBbXCJyZ2JcIl1bXCJoc2xcIl1cbiAgY29udmVydFtmcm9tXSA9IGNvbnZlcnRbZnJvbV0gfHwge307XG5cbiAgY29udmVydFtmcm9tXVt0b10gPSBjb252ZXJ0W2Z1bmNdID0gKGZ1bmN0aW9uKGZ1bmMpIHsgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIFxuICAgICAgdmFyIHZhbCA9IGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiIHx8IHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdmFsOyAvLyBrZXl3b3JkXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKVxuICAgICAgICB2YWxbaV0gPSBNYXRoLnJvdW5kKHZhbFtpXSk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSkoZnVuYyk7XG59XG5cblxuLyogQ29udmVydGVyIGRvZXMgbGF6eSBjb252ZXJzaW9uIGFuZCBjYWNoaW5nICovXG52YXIgQ29udmVydGVyID0gZnVuY3Rpb24oKSB7XG4gICB0aGlzLmNvbnZzID0ge307XG59O1xuXG4vKiBFaXRoZXIgZ2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2Ugb3JcbiAgc2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGRlcGVuZGluZyBvbiBhcmdzICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnJvdXRlU3BhY2UgPSBmdW5jdGlvbihzcGFjZSwgYXJncykge1xuICAgdmFyIHZhbHVlcyA9IGFyZ3NbMF07XG4gICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJnYigpXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuICAgfVxuICAgLy8gY29sb3IucmdiKDEwLCAxMCwgMTApXG4gICBpZiAodHlwZW9mIHZhbHVlcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTsgICAgICAgIFxuICAgfVxuXG4gICByZXR1cm4gdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHVlcyk7XG59O1xuICBcbi8qIFNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBpbnZhbGlkYXRpbmcgY2FjaGUgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UsIHZhbHVlcykge1xuICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgdGhpcy5jb252cyA9IHt9O1xuICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWx1ZXM7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qIEdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLiBJZiB0aGVyZSdzIGFscmVhZHlcbiAgYSBjb252ZXJzaW9uIGZvciB0aGUgc3BhY2UsIGZldGNoIGl0LCBvdGhlcndpc2VcbiAgY29tcHV0ZSBpdCAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSkge1xuICAgdmFyIHZhbHMgPSB0aGlzLmNvbnZzW3NwYWNlXTtcbiAgIGlmICghdmFscykge1xuICAgICAgdmFyIGZzcGFjZSA9IHRoaXMuc3BhY2UsXG4gICAgICAgICAgZnJvbSA9IHRoaXMuY29udnNbZnNwYWNlXTtcbiAgICAgIHZhbHMgPSBjb252ZXJ0W2ZzcGFjZV1bc3BhY2VdKGZyb20pO1xuXG4gICAgICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHM7XG4gICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuW1wicmdiXCIsIFwiaHNsXCIsIFwiaHN2XCIsIFwiY215a1wiLCBcImtleXdvcmRcIl0uZm9yRWFjaChmdW5jdGlvbihzcGFjZSkge1xuICAgQ29udmVydGVyLnByb3RvdHlwZVtzcGFjZV0gPSBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3V0ZVNwYWNlKHNwYWNlLCBhcmd1bWVudHMpO1xuICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDsiLCJtb2R1bGUuZXhwb3J0cz17XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59IiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb2xvck5hbWVzID0gcmVxdWlyZSgnY29sb3ItbmFtZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgIGdldFJnYmE6IGdldFJnYmEsXG4gICBnZXRIc2xhOiBnZXRIc2xhLFxuICAgZ2V0UmdiOiBnZXRSZ2IsXG4gICBnZXRIc2w6IGdldEhzbCxcbiAgIGdldEh3YjogZ2V0SHdiLFxuICAgZ2V0QWxwaGE6IGdldEFscGhhLFxuXG4gICBoZXhTdHJpbmc6IGhleFN0cmluZyxcbiAgIHJnYlN0cmluZzogcmdiU3RyaW5nLFxuICAgcmdiYVN0cmluZzogcmdiYVN0cmluZyxcbiAgIHBlcmNlbnRTdHJpbmc6IHBlcmNlbnRTdHJpbmcsXG4gICBwZXJjZW50YVN0cmluZzogcGVyY2VudGFTdHJpbmcsXG4gICBoc2xTdHJpbmc6IGhzbFN0cmluZyxcbiAgIGhzbGFTdHJpbmc6IGhzbGFTdHJpbmcsXG4gICBod2JTdHJpbmc6IGh3YlN0cmluZyxcbiAgIGtleXdvcmQ6IGtleXdvcmRcbn1cblxuZnVuY3Rpb24gZ2V0UmdiYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgYWJiciA9ICAvXiMoW2EtZkEtRjAtOV17M30pJC8sXG4gICAgICAgaGV4ID0gIC9eIyhbYS1mQS1GMC05XXs2fSkkLyxcbiAgICAgICByZ2JhID0gL15yZ2JhP1xcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooW1xcZFxcLl0rKVxccyopP1xcKSQvLFxuICAgICAgIHBlciA9IC9ecmdiYT9cXChcXHMqKFtcXGRcXC5dKylcXCVcXHMqLFxccyooW1xcZFxcLl0rKVxcJVxccyosXFxzKihbXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFtcXGRcXC5dKylcXHMqKT9cXCkkLyxcbiAgICAgICBrZXl3b3JkID0gLyhcXEQrKS87XG5cbiAgIHZhciByZ2IgPSBbMCwgMCwgMF0sXG4gICAgICAgYSA9IDEsXG4gICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJicik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgICAgaWYgKG1hdGNoWzFdID09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJnYiA9IGNvbG9yTmFtZXNbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooXFxkKykoPzpkZWcpP1xccyosXFxzKihbXFxkXFwuXSspJVxccyosXFxzKihbXFxkXFwuXSspJVxccyooPzosXFxzKihbXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICBzID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgbCA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzRdKSB8fCAxLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFxcZCspKD86ZGVnKT9cXHMqLFxccyooW1xcZFxcLl0rKSVcXHMqLFxccyooW1xcZFxcLl0rKSVcXHMqKD86LFxccyooW1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgdyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGIgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFs0XSkgfHwgMSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZ2Ioc3RyaW5nKSB7XG4gICB2YXIgcmdiYSA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIHJldHVybiByZ2JhICYmIHJnYmEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEhzbChzdHJpbmcpIHtcbiAgdmFyIGhzbGEgPSBnZXRIc2xhKHN0cmluZyk7XG4gIHJldHVybiBoc2xhICYmIGhzbGEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEFscGhhKHN0cmluZykge1xuICAgdmFyIHZhbHMgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICBpZiAodmFscykge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHNsYShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRId2Ioc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG59XG5cbi8vIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIGhleFN0cmluZyhyZ2IpIHtcbiAgIHJldHVybiBcIiNcIiArIGhleERvdWJsZShyZ2JbMF0pICsgaGV4RG91YmxlKHJnYlsxXSlcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiWzJdKTtcbn1cblxuZnVuY3Rpb24gcmdiU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChyZ2JhWzNdICE9PSB1bmRlZmluZWQgPyByZ2JhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdXG4gICAgICAgICAgICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudFN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG5cbiAgIHJldHVybiBcInJnYihcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlLCBcIiArIChhbHBoYSB8fCByZ2JhWzNdIHx8IDEpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbFN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAoaHNsYVszXSAmJiBoc2xhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbChcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChoc2xhWzNdICE9PSB1bmRlZmluZWQgPyBoc2xhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2xhKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSwgXCJcbiAgICAgICAgICAgKyBhbHBoYSArIFwiKVwiO1xufVxuXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxuLy8gKGh3YiBoYXZlIGFscGhhIG9wdGlvbmFsICYgMSBpcyBkZWZhdWx0IHZhbHVlKVxuZnVuY3Rpb24gaHdiU3RyaW5nKGh3YiwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChod2JbM10gIT09IHVuZGVmaW5lZCA/IGh3YlszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHdiKFwiICsgaHdiWzBdICsgXCIsIFwiICsgaHdiWzFdICsgXCIlLCBcIiArIGh3YlsyXSArIFwiJVwiXG4gICAgICAgICAgICsgKGFscGhhICE9PSB1bmRlZmluZWQgJiYgYWxwaGEgIT09IDEgPyBcIiwgXCIgKyBhbHBoYSA6IFwiXCIpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn1cblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gc2NhbGUobnVtLCBtaW4sIG1heCkge1xuICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxuXG5cbi8vY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG52YXIgcmV2ZXJzZU5hbWVzID0ge307XG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZXMpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWVzW25hbWVdXSA9IG5hbWU7XG59IiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb252ZXJ0ID0gcmVxdWlyZShcImNvbG9yLWNvbnZlcnRcIiksXG4gICAgc3RyaW5nID0gcmVxdWlyZShcImNvbG9yLXN0cmluZ1wiKTtcblxudmFyIENvbG9yID0gZnVuY3Rpb24oY3NzU3RyaW5nKSB7XG4gIGlmIChjc3NTdHJpbmcgaW5zdGFuY2VvZiBDb2xvcikgcmV0dXJuIGNzc1N0cmluZztcbiAgaWYgKCEgKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHJldHVybiBuZXcgQ29sb3IoY3NzU3RyaW5nKTtcblxuICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICByZ2I6IFswLCAwLCAwXSxcbiAgICAgIGhzbDogWzAsIDAsIDBdLFxuICAgICAgaHN2OiBbMCwgMCwgMF0sXG4gICAgICBod2I6IFswLCAwLCAwXSxcbiAgICAgIGNteWs6IFswLCAwLCAwLCAwXSxcbiAgICAgIGFscGhhOiAxXG4gICB9XG5cbiAgIC8vIHBhcnNlIENvbG9yKCkgYXJndW1lbnRcbiAgIGlmICh0eXBlb2YgY3NzU3RyaW5nID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciB2YWxzID0gc3RyaW5nLmdldFJnYmEoY3NzU3RyaW5nKTtcbiAgICAgIGlmICh2YWxzKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCB2YWxzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFscyA9IHN0cmluZy5nZXRIc2xhKGNzc1N0cmluZykpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHNsXCIsIHZhbHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih2YWxzID0gc3RyaW5nLmdldEh3Yihjc3NTdHJpbmcpKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcImh3YlwiLCB2YWxzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBzdHJpbmcgXFxcIlwiICsgY3NzU3RyaW5nICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAodHlwZW9mIGNzc1N0cmluZyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YXIgdmFscyA9IGNzc1N0cmluZztcbiAgICAgIGlmKHZhbHNbXCJyXCJdICE9PSB1bmRlZmluZWQgfHwgdmFsc1tcInJlZFwiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCB2YWxzKVxuICAgICAgfVxuICAgICAgZWxzZSBpZih2YWxzW1wibFwiXSAhPT0gdW5kZWZpbmVkIHx8IHZhbHNbXCJsaWdodG5lc3NcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdmFscylcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFsc1tcInZcIl0gIT09IHVuZGVmaW5lZCB8fCB2YWxzW1widmFsdWVcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc3ZcIiwgdmFscylcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFsc1tcIndcIl0gIT09IHVuZGVmaW5lZCB8fCB2YWxzW1wid2hpdGVuZXNzXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHdiXCIsIHZhbHMpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKHZhbHNbXCJjXCJdICE9PSB1bmRlZmluZWQgfHwgdmFsc1tcImN5YW5cIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJjbXlrXCIsIHZhbHMpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gb2JqZWN0IFwiICsgSlNPTi5zdHJpbmdpZnkoY3NzU3RyaW5nKSk7XG4gICAgICB9XG4gICB9XG59XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcbiAgIHJnYjogZnVuY3Rpb24gKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNwYWNlKFwicmdiXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuICAgaHNsOiBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTcGFjZShcImhzbFwiLCBhcmd1bWVudHMpO1xuICAgfSxcbiAgIGhzdjogZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3BhY2UoXCJoc3ZcIiwgYXJndW1lbnRzKTtcbiAgIH0sXG4gICBod2I6IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNwYWNlKFwiaHdiXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuICAgY215azogZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3BhY2UoXCJjbXlrXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuXG4gICByZ2JBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMucmdiO1xuICAgfSxcbiAgIGhzbEFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5oc2w7XG4gICB9LFxuICAgaHN2QXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmhzdjtcbiAgIH0sXG4gICBod2JBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZXMuYWxwaGEgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmh3Yi5jb25jYXQoW3RoaXMudmFsdWVzLmFscGhhXSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5od2I7XG4gICB9LFxuICAgY215a0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5jbXlrO1xuICAgfSxcbiAgIHJnYmFBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuICAgICAgcmV0dXJuIHJnYi5jb25jYXQoW3RoaXMudmFsdWVzLmFscGhhXSk7XG4gICB9LFxuICAgaHNsYUFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG4gICAgICByZXR1cm4gaHNsLmNvbmNhdChbdGhpcy52YWx1ZXMuYWxwaGFdKTtcbiAgIH0sXG4gICBhbHBoYTogZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5hbHBoYTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiYWxwaGFcIiwgdmFsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgcmVkOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJyZ2JcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBncmVlbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwicmdiXCIsIDEsIHZhbCk7XG4gICB9LFxuICAgYmx1ZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwicmdiXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgaHVlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc2xcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBzYXR1cmF0aW9uOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc2xcIiwgMSwgdmFsKTtcbiAgIH0sXG4gICBsaWdodG5lc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImhzbFwiLCAyLCB2YWwpO1xuICAgfSxcbiAgIHNhdHVyYXRpb252OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc3ZcIiwgMSwgdmFsKTtcbiAgIH0sXG4gICB3aGl0ZW5lc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImh3YlwiLCAxLCB2YWwpO1xuICAgfSxcbiAgIGJsYWNrbmVzczogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwiaHdiXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgdmFsdWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImhzdlwiLCAyLCB2YWwpO1xuICAgfSxcbiAgIGN5YW46IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImNteWtcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBtYWdlbnRhOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJjbXlrXCIsIDEsIHZhbCk7XG4gICB9LFxuICAgeWVsbG93OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJjbXlrXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgYmxhY2s6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImNteWtcIiwgMywgdmFsKTtcbiAgIH0sXG5cbiAgIGhleFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmhleFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IpO1xuICAgfSxcbiAgIHJnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJnYlN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICByZ2JhU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICBwZXJjZW50U3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucGVyY2VudFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICBoc2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5oc2xTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgaHNsYVN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgaHdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcuaHdiU3RyaW5nKHRoaXMudmFsdWVzLmh3YiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuICAgfSxcbiAgIGtleXdvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5rZXl3b3JkKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuICAgfSxcblxuICAgcmdiTnVtYmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZXMucmdiWzBdIDw8IDE2KSB8ICh0aGlzLnZhbHVlcy5yZ2JbMV0gPDwgOCkgfCB0aGlzLnZhbHVlcy5yZ2JbMl07XG4gICB9LFxuXG4gICBsdW1pbm9zaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgIHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG4gICAgICB2YXIgbHVtID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG4gICAgICAgICBsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MlxuICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygoKGNoYW4gKyAwLjA1NSkgLyAxLjA1NSksIDIuNClcbiAgICAgIH1cbiAgICAgIHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG4gICB9LFxuXG4gICBjb250cmFzdDogZnVuY3Rpb24oY29sb3IyKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG4gICAgICB2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuICAgICAgdmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuICAgICAgaWYgKGx1bTEgPiBsdW0yKSB7XG4gICAgICAgICByZXR1cm4gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG4gICB9LFxuXG4gICBsZXZlbDogZnVuY3Rpb24oY29sb3IyKSB7XG4gICAgIHZhciBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuICAgICByZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNy4xKVxuICAgICAgID8gJ0FBQSdcbiAgICAgICA6IChjb250cmFzdFJhdGlvID49IDQuNSlcbiAgICAgICAgPyAnQUEnXG4gICAgICAgIDogJyc7XG4gICB9LFxuXG4gICBkYXJrOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3RcbiAgICAgIHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2IsXG4gICAgICAgICAgeWlxID0gKHJnYlswXSAqIDI5OSArIHJnYlsxXSAqIDU4NyArIHJnYlsyXSAqIDExNCkgLyAxMDAwO1xuICAgXHRyZXR1cm4geWlxIDwgMTI4O1xuICAgfSxcblxuICAgbGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmRhcmsoKTtcbiAgIH0sXG5cbiAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gW11cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG4gICAgICB9XG4gICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCByZ2IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICBsaWdodGVuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzJdICs9IHRoaXMudmFsdWVzLmhzbFsyXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgZGFya2VuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzJdIC09IHRoaXMudmFsdWVzLmhzbFsyXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgc2F0dXJhdGU6IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICB0aGlzLnZhbHVlcy5oc2xbMV0gKz0gdGhpcy52YWx1ZXMuaHNsWzFdICogcmF0aW87XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImhzbFwiLCB0aGlzLnZhbHVlcy5oc2wpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICBkZXNhdHVyYXRlOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzFdIC09IHRoaXMudmFsdWVzLmhzbFsxXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgd2hpdGVuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHdiWzFdICs9IHRoaXMudmFsdWVzLmh3YlsxXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJod2JcIiwgdGhpcy52YWx1ZXMuaHdiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgYmxhY2tlbjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMudmFsdWVzLmh3YlsyXSArPSB0aGlzLnZhbHVlcy5od2JbMl0gKiByYXRpbztcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHdiXCIsIHRoaXMudmFsdWVzLmh3Yik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIGdyZXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmF5c2NhbGUjQ29udmVydGluZ19jb2xvcl90b19ncmF5c2NhbGVcbiAgICAgIHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwicmdiXCIsIFt2YWwsIHZhbCwgdmFsXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIGNsZWFyZXI6IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImFscGhhXCIsIHRoaXMudmFsdWVzLmFscGhhIC0gKHRoaXMudmFsdWVzLmFscGhhICogcmF0aW8pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgb3BhcXVlcjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiYWxwaGFcIiwgdGhpcy52YWx1ZXMuYWxwaGEgKyAodGhpcy52YWx1ZXMuYWxwaGEgKiByYXRpbykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICByb3RhdGU6IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICAgIHZhciBodWUgPSB0aGlzLnZhbHVlcy5oc2xbMF07XG4gICAgICBodWUgPSAoaHVlICsgZGVncmVlcykgJSAzNjA7XG4gICAgICBodWUgPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzBdID0gaHVlO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgbWl4OiBmdW5jdGlvbihjb2xvcjIsIHdlaWdodCkge1xuICAgICAgd2VpZ2h0ID0gMSAtICh3ZWlnaHQgPT0gbnVsbCA/IDAuNSA6IHdlaWdodCk7XG5cbiAgICAgIC8vIGFsZ29yaXRobSBmcm9tIFNhc3MncyBtaXgoKS4gUmF0aW8gb2YgZmlyc3QgY29sb3IgaW4gbWl4IGlzXG4gICAgICAvLyBkZXRlcm1pbmVkIGJ5IHRoZSBhbHBoYXMgb2YgYm90aCBjb2xvcnMgYW5kIHRoZSB3ZWlnaHRcbiAgICAgIHZhciB0MSA9IHdlaWdodCAqIDIgLSAxLFxuICAgICAgICAgIGQgPSB0aGlzLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuICAgICAgdmFyIHdlaWdodDEgPSAoKCh0MSAqIGQgPT0gLTEpID8gdDEgOiAodDEgKyBkKSAvICgxICsgdDEgKiBkKSkgKyAxKSAvIDI7XG4gICAgICB2YXIgd2VpZ2h0MiA9IDEgLSB3ZWlnaHQxO1xuXG4gICAgICB2YXIgcmdiID0gdGhpcy5yZ2JBcnJheSgpO1xuICAgICAgdmFyIHJnYjIgPSBjb2xvcjIucmdiQXJyYXkoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHJnYltpXSAqIHdlaWdodDEgKyByZ2IyW2ldICogd2VpZ2h0MjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwicmdiXCIsIHJnYik7XG5cbiAgICAgIHZhciBhbHBoYSA9IHRoaXMuYWxwaGEoKSAqIHdlaWdodCArIGNvbG9yMi5hbHBoYSgpICogKDEgLSB3ZWlnaHQpO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJhbHBoYVwiLCBhbHBoYSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgcmV0dXJuIHRoaXMucmdiKCk7XG4gICB9LFxuXG4gICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IoKSk7XG4gICB9XG59XG5cblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHt9O1xuICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsc1tzcGFjZVtpXV0gPSB0aGlzLnZhbHVlc1tzcGFjZV1baV07XG4gICB9XG4gICBpZiAodGhpcy52YWx1ZXMuYWxwaGEgIT0gMSkge1xuICAgICAgdmFsc1tcImFcIl0gPSB0aGlzLnZhbHVlcy5hbHBoYTtcbiAgIH1cbiAgIC8vIHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAwLjR9XG4gICByZXR1cm4gdmFscztcbn1cblxuQ29sb3IucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlLCB2YWxzKSB7XG4gICB2YXIgc3BhY2VzID0ge1xuICAgICAgXCJyZ2JcIjogW1wicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCJdLFxuICAgICAgXCJoc2xcIjogW1wiaHVlXCIsIFwic2F0dXJhdGlvblwiLCBcImxpZ2h0bmVzc1wiXSxcbiAgICAgIFwiaHN2XCI6IFtcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJ2YWx1ZVwiXSxcbiAgICAgIFwiaHdiXCI6IFtcImh1ZVwiLCBcIndoaXRlbmVzc1wiLCBcImJsYWNrbmVzc1wiXSxcbiAgICAgIFwiY215a1wiOiBbXCJjeWFuXCIsIFwibWFnZW50YVwiLCBcInllbGxvd1wiLCBcImJsYWNrXCJdXG4gICB9O1xuXG4gICB2YXIgbWF4ZXMgPSB7XG4gICAgICBcInJnYlwiOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICBcImhzbFwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImhzdlwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImh3YlwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImNteWtcIjogWzEwMCwgMTAwLCAxMDAsIDEwMF1cbiAgIH07XG5cbiAgIHZhciBhbHBoYSA9IDE7XG4gICBpZiAoc3BhY2UgPT0gXCJhbHBoYVwiKSB7XG4gICAgICBhbHBoYSA9IHZhbHM7XG4gICB9XG4gICBlbHNlIGlmICh2YWxzLmxlbmd0aCkge1xuICAgICAgLy8gWzEwLCAxMCwgMTBdXG4gICAgICB0aGlzLnZhbHVlc1tzcGFjZV0gPSB2YWxzLnNsaWNlKDAsIHNwYWNlLmxlbmd0aCk7XG4gICAgICBhbHBoYSA9IHZhbHNbc3BhY2UubGVuZ3RoXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHNbc3BhY2VbMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHtyOiAxMCwgZzogMTAsIGI6IDEwfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW3NwYWNlW2ldXTtcbiAgICAgIH1cbiAgICAgIGFscGhhID0gdmFscy5hO1xuICAgfVxuICAgZWxzZSBpZiAodmFsc1tzcGFjZXNbc3BhY2VdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB7cmVkOiAxMCwgZ3JlZW46IDEwLCBibHVlOiAxMH1cbiAgICAgIHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbY2hhbnNbaV1dO1xuICAgICAgfVxuICAgICAgYWxwaGEgPSB2YWxzLmFscGhhO1xuICAgfVxuICAgdGhpcy52YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogdGhpcy52YWx1ZXMuYWxwaGEpICkpO1xuICAgaWYgKHNwYWNlID09IFwiYWxwaGFcIikge1xuICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICAvLyBjYXAgdmFsdWVzIG9mIHRoZSBzcGFjZSBwcmlvciBjb252ZXJ0aW5nIGFsbCB2YWx1ZXNcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYXBwZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhlc1tzcGFjZV1baV0sIHRoaXMudmFsdWVzW3NwYWNlXVtpXSkpO1xuICAgICAgdGhpcy52YWx1ZXNbc3BhY2VdW2ldID0gTWF0aC5yb3VuZChjYXBwZWQpO1xuICAgfVxuXG4gICAvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG4gICBmb3IgKHZhciBzbmFtZSBpbiBzcGFjZXMpIHtcbiAgICAgIGlmIChzbmFtZSAhPSBzcGFjZSkge1xuICAgICAgICAgdGhpcy52YWx1ZXNbc25hbWVdID0gY29udmVydFtzcGFjZV1bc25hbWVdKHRoaXMudmFsdWVzW3NwYWNlXSlcbiAgICAgIH1cblxuICAgICAgLy8gY2FwIHZhbHVlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NuYW1lXVtpXSwgdGhpcy52YWx1ZXNbc25hbWVdW2ldKSk7XG4gICAgICAgICB0aGlzLnZhbHVlc1tzbmFtZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG4gICAgICB9XG4gICB9XG4gICByZXR1cm4gdHJ1ZTtcbn1cblxuQ29sb3IucHJvdG90eXBlLnNldFNwYWNlID0gZnVuY3Rpb24oc3BhY2UsIGFyZ3MpIHtcbiAgIHZhciB2YWxzID0gYXJnc1swXTtcbiAgIGlmICh2YWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJnYigpXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuICAgfVxuICAgLy8gY29sb3IucmdiKDEwLCAxMCwgMTApXG4gICBpZiAodHlwZW9mIHZhbHMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgfVxuICAgdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuICAgcmV0dXJuIHRoaXM7XG59XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24oc3BhY2UsIGluZGV4LCB2YWwpIHtcbiAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmVkKClcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tzcGFjZV1baW5kZXhdO1xuICAgfVxuICAgLy8gY29sb3IucmVkKDEwMClcbiAgIHRoaXMudmFsdWVzW3NwYWNlXVtpbmRleF0gPSB2YWw7XG4gICB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdGhpcy52YWx1ZXNbc3BhY2VdKTtcbiAgIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiLyohIGlTY3JvbGwgdjUuMi4wIH4gKGMpIDIwMDgtMjAxNiBNYXR0ZW8gU3BpbmVsbGkgfiBodHRwOi8vY3ViaXEub3JnL2xpY2Vuc2UgKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgTWF0aCkge1xudmFyIHJBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdGZ1bmN0aW9uIChjYWxsYmFjaykgeyB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTsgfTtcblxudmFyIHV0aWxzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG1lID0ge307XG5cblx0dmFyIF9lbGVtZW50U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblx0dmFyIF92ZW5kb3IgPSAoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ZW5kb3JzID0gWyd0JywgJ3dlYmtpdFQnLCAnTW96VCcsICdtc1QnLCAnT1QnXSxcblx0XHRcdHRyYW5zZm9ybSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHZlbmRvcnMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dHJhbnNmb3JtID0gdmVuZG9yc1tpXSArICdyYW5zZm9ybSc7XG5cdFx0XHRpZiAoIHRyYW5zZm9ybSBpbiBfZWxlbWVudFN0eWxlICkgcmV0dXJuIHZlbmRvcnNbaV0uc3Vic3RyKDAsIHZlbmRvcnNbaV0ubGVuZ3RoLTEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBfcHJlZml4U3R5bGUgKHN0eWxlKSB7XG5cdFx0aWYgKCBfdmVuZG9yID09PSBmYWxzZSApIHJldHVybiBmYWxzZTtcblx0XHRpZiAoIF92ZW5kb3IgPT09ICcnICkgcmV0dXJuIHN0eWxlO1xuXHRcdHJldHVybiBfdmVuZG9yICsgc3R5bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHlsZS5zdWJzdHIoMSk7XG5cdH1cblxuXHRtZS5nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gZ2V0VGltZSAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuXHRtZS5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYmopIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBvYmogKSB7XG5cdFx0XHR0YXJnZXRbaV0gPSBvYmpbaV07XG5cdFx0fVxuXHR9O1xuXG5cdG1lLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuXHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sICEhY2FwdHVyZSk7XG5cdH07XG5cblx0bWUucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKSB7XG5cdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgISFjYXB0dXJlKTtcblx0fTtcblxuXHRtZS5wcmVmaXhQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAocG9pbnRlckV2ZW50KSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5NU1BvaW50ZXJFdmVudCA/XG5cdFx0XHQnTVNQb2ludGVyJyArIHBvaW50ZXJFdmVudC5jaGFyQXQoNykudG9VcHBlckNhc2UoKSArIHBvaW50ZXJFdmVudC5zdWJzdHIoOCk6XG5cdFx0XHRwb2ludGVyRXZlbnQ7XG5cdH07XG5cblx0bWUubW9tZW50dW0gPSBmdW5jdGlvbiAoY3VycmVudCwgc3RhcnQsIHRpbWUsIGxvd2VyTWFyZ2luLCB3cmFwcGVyU2l6ZSwgZGVjZWxlcmF0aW9uKSB7XG5cdFx0dmFyIGRpc3RhbmNlID0gY3VycmVudCAtIHN0YXJ0LFxuXHRcdFx0c3BlZWQgPSBNYXRoLmFicyhkaXN0YW5jZSkgLyB0aW1lLFxuXHRcdFx0ZGVzdGluYXRpb24sXG5cdFx0XHRkdXJhdGlvbjtcblxuXHRcdGRlY2VsZXJhdGlvbiA9IGRlY2VsZXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gMC4wMDA2IDogZGVjZWxlcmF0aW9uO1xuXG5cdFx0ZGVzdGluYXRpb24gPSBjdXJyZW50ICsgKCBzcGVlZCAqIHNwZWVkICkgLyAoIDIgKiBkZWNlbGVyYXRpb24gKSAqICggZGlzdGFuY2UgPCAwID8gLTEgOiAxICk7XG5cdFx0ZHVyYXRpb24gPSBzcGVlZCAvIGRlY2VsZXJhdGlvbjtcblxuXHRcdGlmICggZGVzdGluYXRpb24gPCBsb3dlck1hcmdpbiApIHtcblx0XHRcdGRlc3RpbmF0aW9uID0gd3JhcHBlclNpemUgPyBsb3dlck1hcmdpbiAtICggd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApICkgOiBsb3dlck1hcmdpbjtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoZGVzdGluYXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9IGVsc2UgaWYgKCBkZXN0aW5hdGlvbiA+IDAgKSB7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IHdyYXBwZXJTaXplID8gd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApIDogMDtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoY3VycmVudCkgKyBkZXN0aW5hdGlvbjtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVzdGluYXRpb246IE1hdGgucm91bmQoZGVzdGluYXRpb24pLFxuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0fTtcblx0fTtcblxuXHR2YXIgX3RyYW5zZm9ybSA9IF9wcmVmaXhTdHlsZSgndHJhbnNmb3JtJyk7XG5cblx0bWUuZXh0ZW5kKG1lLCB7XG5cdFx0aGFzVHJhbnNmb3JtOiBfdHJhbnNmb3JtICE9PSBmYWxzZSxcblx0XHRoYXNQZXJzcGVjdGl2ZTogX3ByZWZpeFN0eWxlKCdwZXJzcGVjdGl2ZScpIGluIF9lbGVtZW50U3R5bGUsXG5cdFx0aGFzVG91Y2g6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyxcblx0XHRoYXNQb2ludGVyOiAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudCksIC8vIElFMTAgaXMgcHJlZml4ZWRcblx0XHRoYXNUcmFuc2l0aW9uOiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb24nKSBpbiBfZWxlbWVudFN0eWxlXG5cdH0pO1xuXG5cdC8qXG5cdFRoaXMgc2hvdWxkIGZpbmQgYWxsIEFuZHJvaWQgYnJvd3NlcnMgbG93ZXIgdGhhbiBidWlsZCA1MzUuMTkgKGJvdGggc3RvY2sgYnJvd3NlciBhbmQgd2Vidmlldylcblx0LSBnYWxheHkgUzIgaXMgb2tcbiAgICAtIDIuMy42IDogYEFwcGxlV2ViS2l0LzUzMy4xIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzMuMWBcbiAgICAtIDQuMC40IDogYEFwcGxlV2ViS2l0LzUzNC4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM0LjMwYFxuICAgLSBnYWxheHkgUzMgaXMgYmFkQW5kcm9pZCAoc3RvY2sgYnJvd2VyLCB3ZWJ2aWV3KVxuICAgICBgQXBwbGVXZWJLaXQvNTM0LjMwIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzQuMzBgXG4gICAtIGdhbGF4eSBTNCBpcyBiYWRBbmRyb2lkIChzdG9jayBicm93ZXIsIHdlYnZpZXcpXG4gICAgIGBBcHBsZVdlYktpdC81MzQuMzAgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBNb2JpbGUgU2FmYXJpLzUzNC4zMGBcbiAgIC0gZ2FsYXh5IFM1IGlzIE9LXG4gICAgIGBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiAoQ2hyb21lLylgXG4gICAtIGdhbGF4eSBTNiBpcyBPS1xuICAgICBgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYgKENocm9tZS8pYFxuICAqL1xuXHRtZS5pc0JhZEFuZHJvaWQgPSAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFwcFZlcnNpb24gPSB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb247XG5cdFx0Ly8gQW5kcm9pZCBicm93c2VyIGlzIG5vdCBhIGNocm9tZSBicm93c2VyLlxuXHRcdGlmICgvQW5kcm9pZC8udGVzdChhcHBWZXJzaW9uKSAmJiAhKC9DaHJvbWVcXC9cXGQvLnRlc3QoYXBwVmVyc2lvbikpKSB7XG5cdFx0XHR2YXIgc2FmYXJpVmVyc2lvbiA9IGFwcFZlcnNpb24ubWF0Y2goL1NhZmFyaVxcLyhcXGQrLlxcZCkvKTtcblx0XHRcdGlmKHNhZmFyaVZlcnNpb24gJiYgdHlwZW9mIHNhZmFyaVZlcnNpb24gPT09IFwib2JqZWN0XCIgJiYgc2FmYXJpVmVyc2lvbi5sZW5ndGggPj0gMikge1xuXHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdChzYWZhcmlWZXJzaW9uWzFdKSA8IDUzNS4xOTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KSgpO1xuXG5cdG1lLmV4dGVuZChtZS5zdHlsZSA9IHt9LCB7XG5cdFx0dHJhbnNmb3JtOiBfdHJhbnNmb3JtLFxuXHRcdHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nKSxcblx0XHR0cmFuc2l0aW9uRHVyYXRpb246IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvbkR1cmF0aW9uJyksXG5cdFx0dHJhbnNpdGlvbkRlbGF5OiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25EZWxheScpLFxuXHRcdHRyYW5zZm9ybU9yaWdpbjogX3ByZWZpeFN0eWxlKCd0cmFuc2Zvcm1PcmlnaW4nKVxuXHR9KTtcblxuXHRtZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChlLCBjKSB7XG5cdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgYyArIFwiKFxcXFxzfCQpXCIpO1xuXHRcdHJldHVybiByZS50ZXN0KGUuY2xhc3NOYW1lKTtcblx0fTtcblxuXHRtZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlLCBjKSB7XG5cdFx0aWYgKCBtZS5oYXNDbGFzcyhlLCBjKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbmV3Y2xhc3MgPSBlLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXHRcdG5ld2NsYXNzLnB1c2goYyk7XG5cdFx0ZS5jbGFzc05hbWUgPSBuZXdjbGFzcy5qb2luKCcgJyk7XG5cdH07XG5cblx0bWUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdGlmICggIW1lLmhhc0NsYXNzKGUsIGMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGMgKyBcIihcXFxcc3wkKVwiLCAnZycpO1xuXHRcdGUuY2xhc3NOYW1lID0gZS5jbGFzc05hbWUucmVwbGFjZShyZSwgJyAnKTtcblx0fTtcblxuXHRtZS5vZmZzZXQgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHR2YXIgbGVmdCA9IC1lbC5vZmZzZXRMZWZ0LFxuXHRcdFx0dG9wID0gLWVsLm9mZnNldFRvcDtcblxuXHRcdC8vIGpzaGludCAtVzA4NFxuXHRcdHdoaWxlIChlbCA9IGVsLm9mZnNldFBhcmVudCkge1xuXHRcdFx0bGVmdCAtPSBlbC5vZmZzZXRMZWZ0O1xuXHRcdFx0dG9wIC09IGVsLm9mZnNldFRvcDtcblx0XHR9XG5cdFx0Ly8ganNoaW50ICtXMDg0XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogbGVmdCxcblx0XHRcdHRvcDogdG9wXG5cdFx0fTtcblx0fTtcblxuXHRtZS5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChlbCwgZXhjZXB0aW9ucykge1xuXHRcdGZvciAoIHZhciBpIGluIGV4Y2VwdGlvbnMgKSB7XG5cdFx0XHRpZiAoIGV4Y2VwdGlvbnNbaV0udGVzdChlbFtpXSkgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRtZS5leHRlbmQobWUuZXZlbnRUeXBlID0ge30sIHtcblx0XHR0b3VjaHN0YXJ0OiAxLFxuXHRcdHRvdWNobW92ZTogMSxcblx0XHR0b3VjaGVuZDogMSxcblxuXHRcdG1vdXNlZG93bjogMixcblx0XHRtb3VzZW1vdmU6IDIsXG5cdFx0bW91c2V1cDogMixcblxuXHRcdHBvaW50ZXJkb3duOiAzLFxuXHRcdHBvaW50ZXJtb3ZlOiAzLFxuXHRcdHBvaW50ZXJ1cDogMyxcblxuXHRcdE1TUG9pbnRlckRvd246IDMsXG5cdFx0TVNQb2ludGVyTW92ZTogMyxcblx0XHRNU1BvaW50ZXJVcDogM1xuXHR9KTtcblxuXHRtZS5leHRlbmQobWUuZWFzZSA9IHt9LCB7XG5cdFx0cXVhZHJhdGljOiB7XG5cdFx0XHRzdHlsZTogJ2N1YmljLWJlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KScsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0cmV0dXJuIGsgKiAoIDIgLSBrICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjaXJjdWxhcjoge1xuXHRcdFx0c3R5bGU6ICdjdWJpYy1iZXppZXIoMC4xLCAwLjU3LCAwLjEsIDEpJyxcdC8vIE5vdCBwcm9wZXJseSBcImNpcmN1bGFyXCIgYnV0IHRoaXMgbG9va3MgYmV0dGVyLCBpdCBzaG91bGQgYmUgKDAuMDc1LCAwLjgyLCAwLjE2NSwgMSlcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCAxIC0gKCAtLWsgKiBrICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGJhY2s6IHtcblx0XHRcdHN0eWxlOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMiwgMS4yNzUpJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHR2YXIgYiA9IDQ7XG5cdFx0XHRcdHJldHVybiAoIGsgPSBrIC0gMSApICogayAqICggKCBiICsgMSApICogayArIGIgKSArIDE7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRib3VuY2U6IHtcblx0XHRcdHN0eWxlOiAnJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRpZiAoICggayAvPSAxICkgPCAoIDEgLyAyLjc1ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyIC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAxLjUgLyAyLjc1ICkgKSAqIGsgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyLjUgLyAyLjc1ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuMjUgLyAyLjc1ICkgKSAqIGsgKyAwLjkzNzU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuNjI1IC8gMi43NSApICkgKiBrICsgMC45ODQzNzU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGVsYXN0aWM6IHtcblx0XHRcdHN0eWxlOiAnJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHR2YXIgZiA9IDAuMjIsXG5cdFx0XHRcdFx0ZSA9IDAuNDtcblxuXHRcdFx0XHRpZiAoIGsgPT09IDAgKSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdGlmICggayA9PSAxICkgeyByZXR1cm4gMTsgfVxuXG5cdFx0XHRcdHJldHVybiAoIGUgKiBNYXRoLnBvdyggMiwgLSAxMCAqIGsgKSAqIE1hdGguc2luKCAoIGsgLSBmIC8gNCApICogKCAyICogTWF0aC5QSSApIC8gZiApICsgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0bWUudGFwID0gZnVuY3Rpb24gKGUsIGV2ZW50TmFtZSkge1xuXHRcdHZhciBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuXHRcdGV2LmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIHRydWUpO1xuXHRcdGV2LnBhZ2VYID0gZS5wYWdlWDtcblx0XHRldi5wYWdlWSA9IGUucGFnZVk7XG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG5cdH07XG5cblx0bWUuY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldCxcblx0XHRcdGV2O1xuXG5cdFx0aWYgKCAhKC8oU0VMRUNUfElOUFVUfFRFWFRBUkVBKS9pKS50ZXN0KHRhcmdldC50YWdOYW1lKSApIHtcblx0XHRcdGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cdFx0XHRldi5pbml0TW91c2VFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlLCBlLnZpZXcsIDEsXG5cdFx0XHRcdHRhcmdldC5zY3JlZW5YLCB0YXJnZXQuc2NyZWVuWSwgdGFyZ2V0LmNsaWVudFgsIHRhcmdldC5jbGllbnRZLFxuXHRcdFx0XHRlLmN0cmxLZXksIGUuYWx0S2V5LCBlLnNoaWZ0S2V5LCBlLm1ldGFLZXksXG5cdFx0XHRcdDAsIG51bGwpO1xuXG5cdFx0XHRldi5fY29uc3RydWN0ZWQgPSB0cnVlO1xuXHRcdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gbWU7XG59KSgpO1xuZnVuY3Rpb24gSVNjcm9sbCAoZWwsIG9wdGlvbnMpIHtcblx0dGhpcy53cmFwcGVyID0gdHlwZW9mIGVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcblx0dGhpcy5zY3JvbGxlciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5zY3JvbGxlclN0eWxlID0gdGhpcy5zY3JvbGxlci5zdHlsZTtcdFx0Ly8gY2FjaGUgc3R5bGUgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXG5cdHRoaXMub3B0aW9ucyA9IHtcblxuXHRcdHJlc2l6ZVNjcm9sbGJhcnM6IHRydWUsXG5cblx0XHRtb3VzZVdoZWVsU3BlZWQ6IDIwLFxuXG5cdFx0c25hcFRocmVzaG9sZDogMC4zMzQsXG5cbi8vIElOU0VSVCBQT0lOVDogT1BUSU9OU1xuXHRcdGRpc2FibGVQb2ludGVyIDogIXV0aWxzLmhhc1BvaW50ZXIsXG5cdFx0ZGlzYWJsZVRvdWNoIDogdXRpbHMuaGFzUG9pbnRlciB8fCAhdXRpbHMuaGFzVG91Y2gsXG5cdFx0ZGlzYWJsZU1vdXNlIDogdXRpbHMuaGFzUG9pbnRlciB8fCB1dGlscy5oYXNUb3VjaCxcblx0XHRzdGFydFg6IDAsXG5cdFx0c3RhcnRZOiAwLFxuXHRcdHNjcm9sbFk6IHRydWUsXG5cdFx0ZGlyZWN0aW9uTG9ja1RocmVzaG9sZDogNSxcblx0XHRtb21lbnR1bTogdHJ1ZSxcblxuXHRcdGJvdW5jZTogdHJ1ZSxcblx0XHRib3VuY2VUaW1lOiA2MDAsXG5cdFx0Ym91bmNlRWFzaW5nOiAnJyxcblxuXHRcdHByZXZlbnREZWZhdWx0OiB0cnVlLFxuXHRcdHByZXZlbnREZWZhdWx0RXhjZXB0aW9uOiB7IHRhZ05hbWU6IC9eKElOUFVUfFRFWFRBUkVBfEJVVFRPTnxTRUxFQ1QpJC8gfSxcblxuXHRcdEhXQ29tcG9zaXRpbmc6IHRydWUsXG5cdFx0dXNlVHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1c2VUcmFuc2Zvcm06IHRydWUsXG5cdFx0YmluZFRvV3JhcHBlcjogdHlwZW9mIHdpbmRvdy5vbm1vdXNlZG93biA9PT0gXCJ1bmRlZmluZWRcIlxuXHR9O1xuXG5cdGZvciAoIHZhciBpIGluIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHRpb25zXG5cdHRoaXMudHJhbnNsYXRlWiA9IHRoaXMub3B0aW9ucy5IV0NvbXBvc2l0aW5nICYmIHV0aWxzLmhhc1BlcnNwZWN0aXZlID8gJyB0cmFuc2xhdGVaKDApJyA6ICcnO1xuXG5cdHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uID0gdXRpbHMuaGFzVHJhbnNpdGlvbiAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbjtcblx0dGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSA9IHV0aWxzLmhhc1RyYW5zZm9ybSAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtO1xuXG5cdHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT09IHRydWUgPyAndmVydGljYWwnIDogdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9ICF0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCAmJiB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ7XG5cblx0Ly8gSWYgeW91IHdhbnQgZXZlbnRQYXNzdGhyb3VnaCBJIGhhdmUgdG8gbG9jayBvbmUgb2YgdGhlIGF4ZXNcblx0dGhpcy5vcHRpb25zLnNjcm9sbFkgPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2Nyb2xsWTtcblx0dGhpcy5vcHRpb25zLnNjcm9sbFggPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgPyBmYWxzZSA6IHRoaXMub3B0aW9ucy5zY3JvbGxYO1xuXG5cdC8vIFdpdGggZXZlbnRQYXNzdGhyb3VnaCB3ZSBhbHNvIG5lZWQgbG9ja0RpcmVjdGlvbiBtZWNoYW5pc21cblx0dGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgPSB0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCAmJiAhdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPyAwIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQ7XG5cblx0dGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nID09ICdzdHJpbmcnID8gdXRpbHMuZWFzZVt0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nXSB8fCB1dGlscy5lYXNlLmNpcmN1bGFyIDogdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblxuXHR0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyA9IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nID09PSB1bmRlZmluZWQgPyA2MCA6IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nO1xuXG5cdGlmICggdGhpcy5vcHRpb25zLnRhcCA9PT0gdHJ1ZSApIHtcblx0XHR0aGlzLm9wdGlvbnMudGFwID0gJ3RhcCc7XG5cdH1cblxuXHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzID09ICdzY2FsZScgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gPSBmYWxzZTtcblx0fVxuXG5cdHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA/IC0xIDogMTtcblxuLy8gSU5TRVJUIFBPSU5UOiBOT1JNQUxJWkFUSU9OXG5cblx0Ly8gU29tZSBkZWZhdWx0c1xuXHR0aGlzLnggPSAwO1xuXHR0aGlzLnkgPSAwO1xuXHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXHR0aGlzLl9ldmVudHMgPSB7fTtcblxuLy8gSU5TRVJUIFBPSU5UOiBERUZBVUxUU1xuXG5cdHRoaXMuX2luaXQoKTtcblx0dGhpcy5yZWZyZXNoKCk7XG5cblx0dGhpcy5zY3JvbGxUbyh0aGlzLm9wdGlvbnMuc3RhcnRYLCB0aGlzLm9wdGlvbnMuc3RhcnRZKTtcblx0dGhpcy5lbmFibGUoKTtcbn1cblxuSVNjcm9sbC5wcm90b3R5cGUgPSB7XG5cdHZlcnNpb246ICc1LjIuMCcsXG5cblx0X2luaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzIHx8IHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzICkge1xuXHRcdFx0dGhpcy5faW5pdEluZGljYXRvcnMoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsICkge1xuXHRcdFx0dGhpcy5faW5pdFdoZWVsKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHRoaXMuX2luaXRTbmFwKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgKSB7XG5cdFx0XHR0aGlzLl9pbml0S2V5cygpO1xuXHRcdH1cblxuLy8gSU5TRVJUIFBPSU5UOiBfaW5pdFxuXG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gXHRcdHRoaXMucmVzaXplVGltZW91dCA9IG51bGw7XG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdkZXN0cm95Jyk7XG5cdH0sXG5cblx0X3RyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCBlLnRhcmdldCAhPSB0aGlzLnNjcm9sbGVyIHx8ICF0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKCk7XG5cdFx0aWYgKCAhdGhpcy5yZXNldFBvc2l0aW9uKHRoaXMub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBSZWFjdCB0byBsZWZ0IG1vdXNlIGJ1dHRvbiBvbmx5XG5cdFx0aWYgKCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPSAxICkge1xuXHRcdCAgLy8gZm9yIGJ1dHRvbiBwcm9wZXJ0eVxuXHRcdCAgLy8gaHR0cDovL3VuaXhwYXBhLmNvbS9qcy9tb3VzZS5odG1sXG5cdFx0ICB2YXIgYnV0dG9uO1xuXHQgICAgaWYgKCFlLndoaWNoKSB7XG5cdCAgICAgIC8qIElFIGNhc2UgKi9cblx0ICAgICAgYnV0dG9uID0gKGUuYnV0dG9uIDwgMikgPyAwIDpcblx0ICAgICAgICAgICAgICAgKChlLmJ1dHRvbiA9PSA0KSA/IDEgOiAyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8qIEFsbCBvdGhlcnMgKi9cblx0ICAgICAgYnV0dG9uID0gZS5idXR0b247XG5cdCAgICB9XG5cdFx0XHRpZiAoIGJ1dHRvbiAhPT0gMCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCAodGhpcy5pbml0aWF0ZWQgJiYgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAmJiAhdXRpbHMuaXNCYWRBbmRyb2lkICYmICF1dGlscy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbihlLnRhcmdldCwgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0cG9zO1xuXG5cdFx0dGhpcy5pbml0aWF0ZWRcdD0gdXRpbHMuZXZlbnRUeXBlW2UudHlwZV07XG5cdFx0dGhpcy5tb3ZlZFx0XHQ9IGZhbHNlO1xuXHRcdHRoaXMuZGlzdFhcdFx0PSAwO1xuXHRcdHRoaXMuZGlzdFlcdFx0PSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9IDA7XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKCk7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0XHRwb3MgPSB0aGlzLmdldENvbXB1dGVkUG9zaXRpb24oKTtcblx0XHRcdHRoaXMuX3RyYW5zbGF0ZShNYXRoLnJvdW5kKHBvcy54KSwgTWF0aC5yb3VuZChwb3MueSkpO1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHR9IGVsc2UgaWYgKCAhdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0FuaW1hdGluZyApIHtcblx0XHRcdHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdGFydFggICAgPSB0aGlzLng7XG5cdFx0dGhpcy5zdGFydFkgICAgPSB0aGlzLnk7XG5cdFx0dGhpcy5hYnNTdGFydFggPSB0aGlzLng7XG5cdFx0dGhpcy5hYnNTdGFydFkgPSB0aGlzLnk7XG5cdFx0dGhpcy5wb2ludFggICAgPSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLnBvaW50WSAgICA9IHBvaW50LnBhZ2VZO1xuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdiZWZvcmVTY3JvbGxTdGFydCcpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPT0gdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgKSB7XHQvLyBpbmNyZWFzZXMgcGVyZm9ybWFuY2Ugb24gQW5kcm9pZD8gVE9ETzogY2hlY2shXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvaW50XHRcdD0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcblx0XHRcdGRlbHRhWFx0XHQ9IHBvaW50LnBhZ2VYIC0gdGhpcy5wb2ludFgsXG5cdFx0XHRkZWx0YVlcdFx0PSBwb2ludC5wYWdlWSAtIHRoaXMucG9pbnRZLFxuXHRcdFx0dGltZXN0YW1wXHQ9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHRhYnNEaXN0WCwgYWJzRGlzdFk7XG5cblx0XHR0aGlzLnBvaW50WFx0XHQ9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMucG9pbnRZXHRcdD0gcG9pbnQucGFnZVk7XG5cblx0XHR0aGlzLmRpc3RYXHRcdCs9IGRlbHRhWDtcblx0XHR0aGlzLmRpc3RZXHRcdCs9IGRlbHRhWTtcblx0XHRhYnNEaXN0WFx0XHQ9IE1hdGguYWJzKHRoaXMuZGlzdFgpO1xuXHRcdGFic0Rpc3RZXHRcdD0gTWF0aC5hYnModGhpcy5kaXN0WSk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIG1vdmUgYXQgbGVhc3QgMTAgcGl4ZWxzIGZvciB0aGUgc2Nyb2xsaW5nIHRvIGluaXRpYXRlXG5cdFx0aWYgKCB0aW1lc3RhbXAgLSB0aGlzLmVuZFRpbWUgPiAzMDAgJiYgKGFic0Rpc3RYIDwgMTAgJiYgYWJzRGlzdFkgPCAxMCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgeW91IGFyZSBzY3JvbGxpbmcgaW4gb25lIGRpcmVjdGlvbiBsb2NrIHRoZSBvdGhlclxuXHRcdGlmICggIXRoaXMuZGlyZWN0aW9uTG9ja2VkICYmICF0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCApIHtcblx0XHRcdGlmICggYWJzRGlzdFggPiBhYnNEaXN0WSArIHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkICkge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICdoJztcdFx0Ly8gbG9jayBob3Jpem9udGFsbHlcblx0XHRcdH0gZWxzZSBpZiAoIGFic0Rpc3RZID49IGFic0Rpc3RYICsgdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQgKSB7XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uTG9ja2VkID0gJ3YnO1x0XHQvLyBsb2NrIHZlcnRpY2FsbHlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uTG9ja2VkID0gJ24nO1x0XHQvLyBubyBsb2NrXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmRpcmVjdGlvbkxvY2tlZCA9PSAnaCcgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICd2ZXJ0aWNhbCcgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICdob3Jpem9udGFsJyApIHtcblx0XHRcdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YVkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuZGlyZWN0aW9uTG9ja2VkID09ICd2JyApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ2hvcml6b250YWwnICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnICkge1xuXHRcdFx0XHR0aGlzLmluaXRpYXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhWCA9IDA7XG5cdFx0fVxuXG5cdFx0ZGVsdGFYID0gdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsID8gZGVsdGFYIDogMDtcblx0XHRkZWx0YVkgPSB0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsID8gZGVsdGFZIDogMDtcblxuXHRcdG5ld1ggPSB0aGlzLnggKyBkZWx0YVg7XG5cdFx0bmV3WSA9IHRoaXMueSArIGRlbHRhWTtcblxuXHRcdC8vIFNsb3cgZG93biBpZiBvdXRzaWRlIG9mIHRoZSBib3VuZGFyaWVzXG5cdFx0aWYgKCBuZXdYID4gMCB8fCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0bmV3WCA9IHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLnggKyBkZWx0YVggLyAzIDogbmV3WCA+IDAgPyAwIDogdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblx0XHRpZiAoIG5ld1kgPiAwIHx8IG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRuZXdZID0gdGhpcy5vcHRpb25zLmJvdW5jZSA/IHRoaXMueSArIGRlbHRhWSAvIDMgOiBuZXdZID4gMCA/IDAgOiB0aGlzLm1heFNjcm9sbFk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gZGVsdGFYID4gMCA/IC0xIDogZGVsdGFYIDwgMCA/IDEgOiAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWSA9IGRlbHRhWSA+IDAgPyAtMSA6IGRlbHRhWSA8IDAgPyAxIDogMDtcblxuXHRcdGlmICggIXRoaXMubW92ZWQgKSB7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbFN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb3ZlZCA9IHRydWU7XG5cblx0XHR0aGlzLl90cmFuc2xhdGUobmV3WCwgbmV3WSk7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IF9tb3ZlICovXG5cblx0XHRpZiAoIHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gMzAwICkge1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSB0aW1lc3RhbXA7XG5cdFx0XHR0aGlzLnN0YXJ0WCA9IHRoaXMueDtcblx0XHRcdHRoaXMuc3RhcnRZID0gdGhpcy55O1xuXHRcdH1cblxuLyogUkVQTEFDRSBFTkQ6IF9tb3ZlICovXG5cblx0fSxcblxuXHRfZW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPT0gdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgJiYgIXV0aWxzLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKGUudGFyZ2V0LCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHRFeGNlcHRpb24pICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHZhciBwb2ludCA9IGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZSxcblx0XHRcdG1vbWVudHVtWCxcblx0XHRcdG1vbWVudHVtWSxcblx0XHRcdGR1cmF0aW9uID0gdXRpbHMuZ2V0VGltZSgpIC0gdGhpcy5zdGFydFRpbWUsXG5cdFx0XHRuZXdYID0gTWF0aC5yb3VuZCh0aGlzLngpLFxuXHRcdFx0bmV3WSA9IE1hdGgucm91bmQodGhpcy55KSxcblx0XHRcdGRpc3RhbmNlWCA9IE1hdGguYWJzKG5ld1ggLSB0aGlzLnN0YXJ0WCksXG5cdFx0XHRkaXN0YW5jZVkgPSBNYXRoLmFicyhuZXdZIC0gdGhpcy5zdGFydFkpLFxuXHRcdFx0dGltZSA9IDAsXG5cdFx0XHRlYXNpbmcgPSAnJztcblxuXHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSAwO1xuXHRcdHRoaXMuaW5pdGlhdGVkID0gMDtcblx0XHR0aGlzLmVuZFRpbWUgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHQvLyByZXNldCBpZiB3ZSBhcmUgb3V0c2lkZSBvZiB0aGUgYm91bmRhcmllc1xuXHRcdGlmICggdGhpcy5yZXNldFBvc2l0aW9uKHRoaXMub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1kpO1x0Ly8gZW5zdXJlcyB0aGF0IHRoZSBsYXN0IHBvc2l0aW9uIGlzIHJvdW5kZWRcblxuXHRcdC8vIHdlIHNjcm9sbGVkIGxlc3MgdGhhbiAxMCBwaXhlbHNcblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudGFwICkge1xuXHRcdFx0XHR1dGlscy50YXAoZSwgdGhpcy5vcHRpb25zLnRhcCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNrICkge1xuXHRcdFx0XHR1dGlscy5jbGljayhlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxDYW5jZWwnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2V2ZW50cy5mbGljayAmJiBkdXJhdGlvbiA8IDIwMCAmJiBkaXN0YW5jZVggPCAxMDAgJiYgZGlzdGFuY2VZIDwgMTAwICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdmbGljaycpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHN0YXJ0IG1vbWVudHVtIGFuaW1hdGlvbiBpZiBuZWVkZWRcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb21lbnR1bSAmJiBkdXJhdGlvbiA8IDMwMCApIHtcblx0XHRcdG1vbWVudHVtWCA9IHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IHV0aWxzLm1vbWVudHVtKHRoaXMueCwgdGhpcy5zdGFydFgsIGR1cmF0aW9uLCB0aGlzLm1heFNjcm9sbFgsIHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLndyYXBwZXJXaWR0aCA6IDAsIHRoaXMub3B0aW9ucy5kZWNlbGVyYXRpb24pIDogeyBkZXN0aW5hdGlvbjogbmV3WCwgZHVyYXRpb246IDAgfTtcblx0XHRcdG1vbWVudHVtWSA9IHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB1dGlscy5tb21lbnR1bSh0aGlzLnksIHRoaXMuc3RhcnRZLCBkdXJhdGlvbiwgdGhpcy5tYXhTY3JvbGxZLCB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy53cmFwcGVySGVpZ2h0IDogMCwgdGhpcy5vcHRpb25zLmRlY2VsZXJhdGlvbikgOiB7IGRlc3RpbmF0aW9uOiBuZXdZLCBkdXJhdGlvbjogMCB9O1xuXHRcdFx0bmV3WCA9IG1vbWVudHVtWC5kZXN0aW5hdGlvbjtcblx0XHRcdG5ld1kgPSBtb21lbnR1bVkuZGVzdGluYXRpb247XG5cdFx0XHR0aW1lID0gTWF0aC5tYXgobW9tZW50dW1YLmR1cmF0aW9uLCBtb21lbnR1bVkuZHVyYXRpb24pO1xuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IDE7XG5cdFx0fVxuXG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dmFyIHNuYXAgPSB0aGlzLl9uZWFyZXN0U25hcChuZXdYLCBuZXdZKTtcblx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0dGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdYIC0gc25hcC54KSwgMTAwMCksXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdZIC0gc25hcC55KSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXHRcdFx0bmV3WCA9IHNuYXAueDtcblx0XHRcdG5ld1kgPSBzbmFwLnk7XG5cblx0XHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXHRcdFx0ZWFzaW5nID0gdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX2VuZFxuXG5cdFx0aWYgKCBuZXdYICE9IHRoaXMueCB8fCBuZXdZICE9IHRoaXMueSApIHtcblx0XHRcdC8vIGNoYW5nZSBlYXNpbmcgZnVuY3Rpb24gd2hlbiBzY3JvbGxlciBnb2VzIG91dCBvZiB0aGUgYm91bmRhcmllc1xuXHRcdFx0aWYgKCBuZXdYID4gMCB8fCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYIHx8IG5ld1kgPiAwIHx8IG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRcdGVhc2luZyA9IHV0aWxzLmVhc2UucXVhZHJhdGljO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIHRpbWUsIGVhc2luZyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG5cblx0XHR0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQucmVmcmVzaCgpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nKTtcblx0fSxcblxuXHRyZXNldFBvc2l0aW9uOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHZhciB4ID0gdGhpcy54LFxuXHRcdFx0eSA9IHRoaXMueTtcblxuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgfHwgdGhpcy54ID4gMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCB8fCB0aGlzLnkgPiAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy55IDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHRpZiAoIHggPT0gdGhpcy54ICYmIHkgPT0gdGhpcy55ICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJmID0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodDtcdFx0Ly8gRm9yY2UgcmVmbG93XG5cblx0XHR0aGlzLndyYXBwZXJXaWR0aFx0PSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cdFx0dGhpcy53cmFwcGVySGVpZ2h0XHQ9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IHJlZnJlc2ggKi9cblxuXHRcdHRoaXMuc2Nyb2xsZXJXaWR0aFx0PSB0aGlzLnNjcm9sbGVyLm9mZnNldFdpZHRoO1xuXHRcdHRoaXMuc2Nyb2xsZXJIZWlnaHRcdD0gdGhpcy5zY3JvbGxlci5vZmZzZXRIZWlnaHQ7XG5cblx0XHR0aGlzLm1heFNjcm9sbFhcdFx0PSB0aGlzLndyYXBwZXJXaWR0aCAtIHRoaXMuc2Nyb2xsZXJXaWR0aDtcblx0XHR0aGlzLm1heFNjcm9sbFlcdFx0PSB0aGlzLndyYXBwZXJIZWlnaHQgLSB0aGlzLnNjcm9sbGVySGVpZ2h0O1xuXG4vKiBSRVBMQUNFIEVORDogcmVmcmVzaCAqL1xuXG5cdFx0dGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsXHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxYICYmIHRoaXMubWF4U2Nyb2xsWCA8IDA7XG5cdFx0dGhpcy5oYXNWZXJ0aWNhbFNjcm9sbFx0XHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxZICYmIHRoaXMubWF4U2Nyb2xsWSA8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgKSB7XG5cdFx0XHR0aGlzLm1heFNjcm9sbFggPSAwO1xuXHRcdFx0dGhpcy5zY3JvbGxlcldpZHRoID0gdGhpcy53cmFwcGVyV2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHRoaXMubWF4U2Nyb2xsWSA9IDA7XG5cdFx0XHR0aGlzLnNjcm9sbGVySGVpZ2h0ID0gdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdH1cblxuXHRcdHRoaXMuZW5kVGltZSA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXG5cdFx0dGhpcy53cmFwcGVyT2Zmc2V0ID0gdXRpbHMub2Zmc2V0KHRoaXMud3JhcHBlcik7XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ3JlZnJlc2gnKTtcblxuXHRcdHRoaXMucmVzZXRQb3NpdGlvbigpO1xuXG4vLyBJTlNFUlQgUE9JTlQ6IF9yZWZyZXNoXG5cblx0fSxcblxuXHRvbjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2goZm4pO1xuXHR9LFxuXG5cdG9mZjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5pbmRleE9mKGZuKTtcblxuXHRcdGlmICggaW5kZXggPiAtMSApIHtcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSxcblxuXHRfZXhlY0V2ZW50OiBmdW5jdGlvbiAodHlwZSkge1xuXHRcdGlmICggIXRoaXMuX2V2ZW50c1t0eXBlXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsID0gdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcblxuXHRcdGlmICggIWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdW2ldLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0eCA9IHRoaXMueCArIHg7XG5cdFx0eSA9IHRoaXMueSArIHk7XG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRzY3JvbGxUbzogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB1dGlscy5lYXNlLmNpcmN1bGFyO1xuXG5cdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRpbWUgPiAwO1xuXHRcdHZhciB0cmFuc2l0aW9uVHlwZSA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIGVhc2luZy5zdHlsZTtcblx0XHRpZiAoICF0aW1lIHx8IHRyYW5zaXRpb25UeXBlICkge1xuXHRcdFx0XHRpZih0cmFuc2l0aW9uVHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbihlYXNpbmcuc3R5bGUpO1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKHRpbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FuaW1hdGUoeCwgeSwgdGltZSwgZWFzaW5nLmZuKTtcblx0XHR9XG5cdH0sXG5cblx0c2Nyb2xsVG9FbGVtZW50OiBmdW5jdGlvbiAoZWwsIHRpbWUsIG9mZnNldFgsIG9mZnNldFksIGVhc2luZykge1xuXHRcdGVsID0gZWwubm9kZVR5cGUgPyBlbCA6IHRoaXMuc2Nyb2xsZXIucXVlcnlTZWxlY3RvcihlbCk7XG5cblx0XHRpZiAoICFlbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcG9zID0gdXRpbHMub2Zmc2V0KGVsKTtcblxuXHRcdHBvcy5sZWZ0IC09IHRoaXMud3JhcHBlck9mZnNldC5sZWZ0O1xuXHRcdHBvcy50b3AgIC09IHRoaXMud3JhcHBlck9mZnNldC50b3A7XG5cblx0XHQvLyBpZiBvZmZzZXRYL1kgYXJlIHRydWUgd2UgY2VudGVyIHRoZSBlbGVtZW50IHRvIHRoZSBzY3JlZW5cblx0XHRpZiAoIG9mZnNldFggPT09IHRydWUgKSB7XG5cdFx0XHRvZmZzZXRYID0gTWF0aC5yb3VuZChlbC5vZmZzZXRXaWR0aCAvIDIgLSB0aGlzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyKTtcblx0XHR9XG5cdFx0aWYgKCBvZmZzZXRZID09PSB0cnVlICkge1xuXHRcdFx0b2Zmc2V0WSA9IE1hdGgucm91bmQoZWwub2Zmc2V0SGVpZ2h0IC8gMiAtIHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRwb3MubGVmdCAtPSBvZmZzZXRYIHx8IDA7XG5cdFx0cG9zLnRvcCAgLT0gb2Zmc2V0WSB8fCAwO1xuXG5cdFx0cG9zLmxlZnQgPSBwb3MubGVmdCA+IDAgPyAwIDogcG9zLmxlZnQgPCB0aGlzLm1heFNjcm9sbFggPyB0aGlzLm1heFNjcm9sbFggOiBwb3MubGVmdDtcblx0XHRwb3MudG9wICA9IHBvcy50b3AgID4gMCA/IDAgOiBwb3MudG9wICA8IHRoaXMubWF4U2Nyb2xsWSA/IHRoaXMubWF4U2Nyb2xsWSA6IHBvcy50b3A7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkIHx8IHRpbWUgPT09IG51bGwgfHwgdGltZSA9PT0gJ2F1dG8nID8gTWF0aC5tYXgoTWF0aC5hYnModGhpcy54LXBvcy5sZWZ0KSwgTWF0aC5hYnModGhpcy55LXBvcy50b3ApKSA6IHRpbWU7XG5cblx0XHR0aGlzLnNjcm9sbFRvKHBvcy5sZWZ0LCBwb3MudG9wLCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXG5cdFx0dmFyIGR1cmF0aW9uUHJvcCA9IHV0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbjtcblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9IHRpbWUgKyAnbXMnO1xuXG5cdFx0aWYgKCAhdGltZSAmJiB1dGlscy5pc0JhZEFuZHJvaWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwLjAwMDFtcyc7XG5cdFx0XHQvLyByZW1vdmUgMC4wMDAxbXNcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHJBRihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5zY3JvbGxlclN0eWxlW2R1cmF0aW9uUHJvcF0gPT09ICcwLjAwMDFtcycpIHtcblx0XHRcdFx0XHRzZWxmLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwcyc7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltZSh0aW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWVcblxuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uIChlYXNpbmcpIHtcblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZztcblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24oZWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXG5cblx0fSxcblxuXHRfdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblxuLyogUkVQTEFDRSBTVEFSVDogX3RyYW5zbGF0ZSAqL1xuXG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyArIHRoaXMudHJhbnNsYXRlWjtcblxuLyogUkVQTEFDRSBFTkQ6IF90cmFuc2xhdGUgKi9cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gTWF0aC5yb3VuZCh4KTtcblx0XHRcdHkgPSBNYXRoLnJvdW5kKHkpO1xuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuc2Nyb2xsZXJTdHlsZS50b3AgPSB5ICsgJ3B4Jztcblx0XHR9XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblxuXHRpZiAoIHRoaXMuaW5kaWNhdG9ycyApIHtcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udXBkYXRlUG9zaXRpb24oKTtcblx0XHR9XG5cdH1cblxuXG4vLyBJTlNFUlQgUE9JTlQ6IF90cmFuc2xhdGVcblxuXHR9LFxuXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0dmFyIGV2ZW50VHlwZSA9IHJlbW92ZSA/IHV0aWxzLnJlbW92ZUV2ZW50IDogdXRpbHMuYWRkRXZlbnQsXG5cdFx0XHR0YXJnZXQgPSB0aGlzLm9wdGlvbnMuYmluZFRvV3JhcHBlciA/IHRoaXMud3JhcHBlciA6IHdpbmRvdztcblxuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdyZXNpemUnLCB0aGlzKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNrICkge1xuXHRcdFx0ZXZlbnRUeXBlKHRoaXMud3JhcHBlciwgJ2NsaWNrJywgdGhpcywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVNb3VzZSApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICdtb3VzZWRvd24nLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZW1vdmUnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZWNhbmNlbCcsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoIHV0aWxzLmhhc1BvaW50ZXIgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlUG9pbnRlciApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyY2FuY2VsJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCB1dGlscy5oYXNUb3VjaCAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVUb3VjaCApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2hjYW5jZWwnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ01TVHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHR9LFxuXG5cdGdldENvbXB1dGVkUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWF0cml4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxlciwgbnVsbCksXG5cdFx0XHR4LCB5O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4W3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0uc3BsaXQoJyknKVswXS5zcGxpdCgnLCAnKTtcblx0XHRcdHggPSArKG1hdHJpeFsxMl0gfHwgbWF0cml4WzRdKTtcblx0XHRcdHkgPSArKG1hdHJpeFsxM10gfHwgbWF0cml4WzVdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9ICttYXRyaXgubGVmdC5yZXBsYWNlKC9bXi1cXGQuXS9nLCAnJyk7XG5cdFx0XHR5ID0gK21hdHJpeC50b3AucmVwbGFjZSgvW14tXFxkLl0vZywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblx0fSxcblx0X2luaXRJbmRpY2F0b3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGludGVyYWN0aXZlID0gdGhpcy5vcHRpb25zLmludGVyYWN0aXZlU2Nyb2xsYmFycyxcblx0XHRcdGN1c3RvbVN0eWxlID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICE9ICdzdHJpbmcnLFxuXHRcdFx0aW5kaWNhdG9ycyA9IFtdLFxuXHRcdFx0aW5kaWNhdG9yO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5pbmRpY2F0b3JzID0gW107XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICkge1xuXHRcdFx0Ly8gVmVydGljYWwgc2Nyb2xsYmFyXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxZICkge1xuXHRcdFx0XHRpbmRpY2F0b3IgPSB7XG5cdFx0XHRcdFx0ZWw6IGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIoJ3YnLCBpbnRlcmFjdGl2ZSwgdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMpLFxuXHRcdFx0XHRcdGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZSxcblx0XHRcdFx0XHRkZWZhdWx0U2Nyb2xsYmFyczogdHJ1ZSxcblx0XHRcdFx0XHRjdXN0b21TdHlsZTogY3VzdG9tU3R5bGUsXG5cdFx0XHRcdFx0cmVzaXplOiB0aGlzLm9wdGlvbnMucmVzaXplU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRzaHJpbms6IHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGZhZGU6IHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRsaXN0ZW5YOiBmYWxzZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IuZWwpO1xuXHRcdFx0XHRpbmRpY2F0b3JzLnB1c2goaW5kaWNhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9yaXpvbnRhbCBzY3JvbGxiYXJcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbFggKSB7XG5cdFx0XHRcdGluZGljYXRvciA9IHtcblx0XHRcdFx0XHRlbDogY3JlYXRlRGVmYXVsdFNjcm9sbGJhcignaCcsIGludGVyYWN0aXZlLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyksXG5cdFx0XHRcdFx0aW50ZXJhY3RpdmU6IGludGVyYWN0aXZlLFxuXHRcdFx0XHRcdGRlZmF1bHRTY3JvbGxiYXJzOiB0cnVlLFxuXHRcdFx0XHRcdGN1c3RvbVN0eWxlOiBjdXN0b21TdHlsZSxcblx0XHRcdFx0XHRyZXNpemU6IHRoaXMub3B0aW9ucy5yZXNpemVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdHNocmluazogdGhpcy5vcHRpb25zLnNocmlua1Njcm9sbGJhcnMsXG5cdFx0XHRcdFx0ZmFkZTogdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGxpc3Rlblk6IGZhbHNlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvci5lbCk7XG5cdFx0XHRcdGluZGljYXRvcnMucHVzaChpbmRpY2F0b3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmluZGljYXRvcnMgKSB7XG5cdFx0XHQvLyBUT0RPOiBjaGVjayBjb25jYXQgY29tcGF0aWJpbGl0eVxuXHRcdFx0aW5kaWNhdG9ycyA9IGluZGljYXRvcnMuY29uY2F0KHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzKTtcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IGluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JzLnB1c2goIG5ldyBJbmRpY2F0b3IodGhpcywgaW5kaWNhdG9yc1tpXSkgKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBjaGVjayBpZiB3ZSBjYW4gdXNlIGFycmF5Lm1hcCAod2lkZSBjb21wYXRpYmlsaXR5IGFuZCBwZXJmb3JtYW5jZSBpc3N1ZXMpXG5cdFx0ZnVuY3Rpb24gX2luZGljYXRvcnNNYXAgKGZuKSB7XG5cdFx0XHRpZiAodGhhdC5pbmRpY2F0b3JzKSB7XG5cdFx0XHRcdGZvciAoIHZhciBpID0gdGhhdC5pbmRpY2F0b3JzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoYXQuaW5kaWNhdG9yc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyApIHtcblx0XHRcdHRoaXMub24oJ3Njcm9sbEVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLm9uKCdzY3JvbGxDYW5jZWwnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbignc2Nyb2xsU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMub24oJ2JlZm9yZVNjcm9sbFN0YXJ0JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKDEsIHRydWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGRlbGV0ZSB0aGlzLmluZGljYXRvcnM7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRXaGVlbDogZnVuY3Rpb24gKCkge1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ3doZWVsJywgdGhpcyk7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnbW91c2V3aGVlbCcsIHRoaXMpO1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2hlZWxUaW1lb3V0KTtcblx0XHRcdHRoaXMud2hlZWxUaW1lb3V0ID0gbnVsbDtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMud3JhcHBlciwgJ3doZWVsJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICdtb3VzZXdoZWVsJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICdET01Nb3VzZVNjcm9sbCcsIHRoaXMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF93aGVlbDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dmFyIHdoZWVsRGVsdGFYLCB3aGVlbERlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGlmICggdGhpcy53aGVlbFRpbWVvdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBFeGVjdXRlIHRoZSBzY3JvbGxFbmQgZXZlbnQgYWZ0ZXIgNDAwbXMgdGhlIHdoZWVsIHN0b3BwZWQgc2Nyb2xsaW5nXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2hlZWxUaW1lb3V0KTtcblx0XHR0aGlzLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYoIXRoYXQub3B0aW9ucy5zbmFwKSB7XG5cdFx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGF0LndoZWVsVGltZW91dCA9IHVuZGVmaW5lZDtcblx0XHR9LCA0MDApO1xuXG5cdFx0aWYgKCAnZGVsdGFYJyBpbiBlICkge1xuXHRcdFx0aWYgKGUuZGVsdGFNb2RlID09PSAxKSB7XG5cdFx0XHRcdHdoZWVsRGVsdGFYID0gLWUuZGVsdGFYICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHRcdFx0d2hlZWxEZWx0YVkgPSAtZS5kZWx0YVkgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hlZWxEZWx0YVggPSAtZS5kZWx0YVg7XG5cdFx0XHRcdHdoZWVsRGVsdGFZID0gLWUuZGVsdGFZO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhWCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gZS53aGVlbERlbHRhWCAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0XHR3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YVkgLyAxMjAgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YSAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0fSBlbHNlIGlmICggJ2RldGFpbCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gd2hlZWxEZWx0YVkgPSAtZS5kZXRhaWwgLyAzICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHdoZWVsRGVsdGFYICo9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbjtcblx0XHR3aGVlbERlbHRhWSAqPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb247XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWTtcblx0XHRcdHdoZWVsRGVsdGFZID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0bmV3WCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVg7XG5cdFx0XHRuZXdZID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdFx0aWYgKCB3aGVlbERlbHRhWCA+IDAgKSB7XG5cdFx0XHRcdG5ld1gtLTtcblx0XHRcdH0gZWxzZSBpZiAoIHdoZWVsRGVsdGFYIDwgMCApIHtcblx0XHRcdFx0bmV3WCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdoZWVsRGVsdGFZID4gMCApIHtcblx0XHRcdFx0bmV3WS0tO1xuXHRcdFx0fSBlbHNlIGlmICggd2hlZWxEZWx0YVkgPCAwICkge1xuXHRcdFx0XHRuZXdZKys7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRuZXdYID0gdGhpcy54ICsgTWF0aC5yb3VuZCh0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgPyB3aGVlbERlbHRhWCA6IDApO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBNYXRoLnJvdW5kKHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB3aGVlbERlbHRhWSA6IDApO1xuXG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gd2hlZWxEZWx0YVggPiAwID8gLTEgOiB3aGVlbERlbHRhWCA8IDAgPyAxIDogMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSB3aGVlbERlbHRhWSA+IDAgPyAtMSA6IHdoZWVsRGVsdGFZIDwgMCA/IDEgOiAwO1xuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG4vLyBJTlNFUlQgUE9JTlQ6IF93aGVlbFxuXHR9LFxuXG5cdF9pbml0U25hcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY3VycmVudFBhZ2UgPSB7fTtcblxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5zbmFwID09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnNuYXAgPSB0aGlzLnNjcm9sbGVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNuYXApO1xuXHRcdH1cblxuXHRcdHRoaXMub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSA9IDAsIGwsXG5cdFx0XHRcdG0gPSAwLCBuLFxuXHRcdFx0XHRjeCwgY3ksXG5cdFx0XHRcdHggPSAwLCB5LFxuXHRcdFx0XHRzdGVwWCA9IHRoaXMub3B0aW9ucy5zbmFwU3RlcFggfHwgdGhpcy53cmFwcGVyV2lkdGgsXG5cdFx0XHRcdHN0ZXBZID0gdGhpcy5vcHRpb25zLnNuYXBTdGVwWSB8fCB0aGlzLndyYXBwZXJIZWlnaHQsXG5cdFx0XHRcdGVsO1xuXG5cdFx0XHR0aGlzLnBhZ2VzID0gW107XG5cblx0XHRcdGlmICggIXRoaXMud3JhcHBlcldpZHRoIHx8ICF0aGlzLndyYXBwZXJIZWlnaHQgfHwgIXRoaXMuc2Nyb2xsZXJXaWR0aCB8fCAhdGhpcy5zY3JvbGxlckhlaWdodCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwID09PSB0cnVlICkge1xuXHRcdFx0XHRjeCA9IE1hdGgucm91bmQoIHN0ZXBYIC8gMiApO1xuXHRcdFx0XHRjeSA9IE1hdGgucm91bmQoIHN0ZXBZIC8gMiApO1xuXG5cdFx0XHRcdHdoaWxlICggeCA+IC10aGlzLnNjcm9sbGVyV2lkdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5wYWdlc1tpXSA9IFtdO1xuXHRcdFx0XHRcdGwgPSAwO1xuXHRcdFx0XHRcdHkgPSAwO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCB5ID4gLXRoaXMuc2Nyb2xsZXJIZWlnaHQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBhZ2VzW2ldW2xdID0ge1xuXHRcdFx0XHRcdFx0XHR4OiBNYXRoLm1heCh4LCB0aGlzLm1heFNjcm9sbFgpLFxuXHRcdFx0XHRcdFx0XHR5OiBNYXRoLm1heCh5LCB0aGlzLm1heFNjcm9sbFkpLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogc3RlcFgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogc3RlcFksXG5cdFx0XHRcdFx0XHRcdGN4OiB4IC0gY3gsXG5cdFx0XHRcdFx0XHRcdGN5OiB5IC0gY3lcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHkgLT0gc3RlcFk7XG5cdFx0XHRcdFx0XHRsKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eCAtPSBzdGVwWDtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsID0gdGhpcy5vcHRpb25zLnNuYXA7XG5cdFx0XHRcdGwgPSBlbC5sZW5ndGg7XG5cdFx0XHRcdG4gPSAtMTtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBpID09PSAwIHx8IGVsW2ldLm9mZnNldExlZnQgPD0gZWxbaS0xXS5vZmZzZXRMZWZ0ICkge1xuXHRcdFx0XHRcdFx0bSA9IDA7XG5cdFx0XHRcdFx0XHRuKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5wYWdlc1ttXSApIHtcblx0XHRcdFx0XHRcdHRoaXMucGFnZXNbbV0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR4ID0gTWF0aC5tYXgoLWVsW2ldLm9mZnNldExlZnQsIHRoaXMubWF4U2Nyb2xsWCk7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWF4KC1lbFtpXS5vZmZzZXRUb3AsIHRoaXMubWF4U2Nyb2xsWSk7XG5cdFx0XHRcdFx0Y3ggPSB4IC0gTWF0aC5yb3VuZChlbFtpXS5vZmZzZXRXaWR0aCAvIDIpO1xuXHRcdFx0XHRcdGN5ID0geSAtIE1hdGgucm91bmQoZWxbaV0ub2Zmc2V0SGVpZ2h0IC8gMik7XG5cblx0XHRcdFx0XHR0aGlzLnBhZ2VzW21dW25dID0ge1xuXHRcdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0XHR3aWR0aDogZWxbaV0ub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGVsW2ldLm9mZnNldEhlaWdodCxcblx0XHRcdFx0XHRcdGN4OiBjeCxcblx0XHRcdFx0XHRcdGN5OiBjeVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIHggPiB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRcdFx0XHRtKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UodGhpcy5jdXJyZW50UGFnZS5wYWdlWCB8fCAwLCB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZIHx8IDAsIDApO1xuXG5cdFx0XHQvLyBVcGRhdGUgc25hcCB0aHJlc2hvbGQgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkICUgMSA9PT0gMCApIHtcblx0XHRcdFx0dGhpcy5zbmFwVGhyZXNob2xkWCA9IHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRYID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLndpZHRoICogdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQpO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLmhlaWdodCAqIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2ZsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy54IC0gdGhpcy5zdGFydFgpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMueSAtIHRoaXMuc3RhcnRZKSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXG5cdFx0XHR0aGlzLmdvVG9QYWdlKFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYICsgdGhpcy5kaXJlY3Rpb25YLFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICsgdGhpcy5kaXJlY3Rpb25ZLFxuXHRcdFx0XHR0aW1lXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9uZWFyZXN0U25hcDogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAoICF0aGlzLnBhZ2VzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHg6IDAsIHk6IDAsIHBhZ2VYOiAwLCBwYWdlWTogMCB9O1xuXHRcdH1cblxuXHRcdHZhciBpID0gMCxcblx0XHRcdGwgPSB0aGlzLnBhZ2VzLmxlbmd0aCxcblx0XHRcdG0gPSAwO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZXhjZWVkZWQgdGhlIHNuYXAgdGhyZXNob2xkXG5cdFx0aWYgKCBNYXRoLmFicyh4IC0gdGhpcy5hYnNTdGFydFgpIDwgdGhpcy5zbmFwVGhyZXNob2xkWCAmJlxuXHRcdFx0TWF0aC5hYnMoeSAtIHRoaXMuYWJzU3RhcnRZKSA8IHRoaXMuc25hcFRocmVzaG9sZFkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50UGFnZTtcblx0XHR9XG5cblx0XHRpZiAoIHggPiAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fSBlbHNlIGlmICggeCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCB5ID4gMCApIHtcblx0XHRcdHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHkgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHR5ID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggeCA+PSB0aGlzLnBhZ2VzW2ldWzBdLmN4ICkge1xuXHRcdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsID0gdGhpcy5wYWdlc1tpXS5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IG0gPCBsOyBtKysgKSB7XG5cdFx0XHRpZiAoIHkgPj0gdGhpcy5wYWdlc1swXVttXS5jeSApIHtcblx0XHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpID09IHRoaXMuY3VycmVudFBhZ2UucGFnZVggKSB7XG5cdFx0XHRpICs9IHRoaXMuZGlyZWN0aW9uWDtcblxuXHRcdFx0aWYgKCBpIDwgMCApIHtcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCBpID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0XHRpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXG5cdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdH1cblxuXHRcdGlmICggbSA9PSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICkge1xuXHRcdFx0bSArPSB0aGlzLmRpcmVjdGlvblk7XG5cblx0XHRcdGlmICggbSA8IDAgKSB7XG5cdFx0XHRcdG0gPSAwO1xuXHRcdFx0fSBlbHNlIGlmICggbSA+PSB0aGlzLnBhZ2VzWzBdLmxlbmd0aCApIHtcblx0XHRcdFx0bSA9IHRoaXMucGFnZXNbMF0ubGVuZ3RoIC0gMTtcblx0XHRcdH1cblxuXHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHksXG5cdFx0XHRwYWdlWDogaSxcblx0XHRcdHBhZ2VZOiBtXG5cdFx0fTtcblx0fSxcblxuXHRnb1RvUGFnZTogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nO1xuXG5cdFx0aWYgKCB4ID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0eCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblxuXHRcdGlmICggeSA+PSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCApIHtcblx0XHRcdHkgPSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9XG5cblx0XHR2YXIgcG9zWCA9IHRoaXMucGFnZXNbeF1beV0ueCxcblx0XHRcdHBvc1kgPSB0aGlzLnBhZ2VzW3hdW3ldLnk7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhwb3NYIC0gdGhpcy54KSwgMTAwMCksXG5cdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHBvc1kgLSB0aGlzLnkpLCAxMDAwKVxuXHRcdFx0KSwgMzAwKSA6IHRpbWU7XG5cblx0XHR0aGlzLmN1cnJlbnRQYWdlID0ge1xuXHRcdFx0eDogcG9zWCxcblx0XHRcdHk6IHBvc1ksXG5cdFx0XHRwYWdlWDogeCxcblx0XHRcdHBhZ2VZOiB5XG5cdFx0fTtcblxuXHRcdHRoaXMuc2Nyb2xsVG8ocG9zWCwgcG9zWSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRuZXh0OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4Kys7XG5cblx0XHRpZiAoIHggPj0gdGhpcy5wYWdlcy5sZW5ndGggJiYgdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eSsrO1xuXHRcdH1cblxuXHRcdHRoaXMuZ29Ub1BhZ2UoeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRwcmV2OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4LS07XG5cblx0XHRpZiAoIHggPCAwICYmIHRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHRcdHktLTtcblx0XHR9XG5cblx0XHR0aGlzLmdvVG9QYWdlKHgsIHksIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0X2luaXRLZXlzOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRlZmF1bHQga2V5IGJpbmRpbmdzXG5cdFx0dmFyIGtleXMgPSB7XG5cdFx0XHRwYWdlVXA6IDMzLFxuXHRcdFx0cGFnZURvd246IDM0LFxuXHRcdFx0ZW5kOiAzNSxcblx0XHRcdGhvbWU6IDM2LFxuXHRcdFx0bGVmdDogMzcsXG5cdFx0XHR1cDogMzgsXG5cdFx0XHRyaWdodDogMzksXG5cdFx0XHRkb3duOiA0MFxuXHRcdH07XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBpZiB5b3UgZ2l2ZSBtZSBjaGFyYWN0ZXJzIEkgZ2l2ZSB5b3Uga2V5Y29kZVxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyA9PSAnb2JqZWN0JyApIHtcblx0XHRcdGZvciAoIGkgaW4gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldID0gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgPSB7fTtcblx0XHR9XG5cblx0XHRmb3IgKCBpIGluIGtleXMgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gfHwga2V5c1tpXTtcblx0XHR9XG5cblx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICdrZXlkb3duJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAna2V5ZG93bicsIHRoaXMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9rZXk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAsXHQvLyB3ZSBhcmUgdXNpbmcgdGhpcyBhbG90LCBiZXR0ZXIgdG8gY2FjaGUgaXRcblx0XHRcdG5ld1ggPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCA6IHRoaXMueCxcblx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWSA6IHRoaXMueSxcblx0XHRcdG5vdyA9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdHByZXZUaW1lID0gdGhpcy5rZXlUaW1lIHx8IDAsXG5cdFx0XHRhY2NlbGVyYXRpb24gPSAwLjI1MCxcblx0XHRcdHBvcztcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHBvcyA9IHRoaXMuZ2V0Q29tcHV0ZWRQb3NpdGlvbigpO1xuXG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoTWF0aC5yb3VuZChwb3MueCksIE1hdGgucm91bmQocG9zLnkpKTtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IG5vdyAtIHByZXZUaW1lIDwgMjAwID8gTWF0aC5taW4odGhpcy5rZXlBY2NlbGVyYXRpb24gKyBhY2NlbGVyYXRpb24sIDUwKSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBlLmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5wYWdlVXA6XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggKz0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZICs9IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucGFnZURvd246XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggLT0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZIC09IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MuZW5kOlxuXHRcdFx0XHRuZXdYID0gc25hcCA/IHRoaXMucGFnZXMubGVuZ3RoLTEgOiB0aGlzLm1heFNjcm9sbFg7XG5cdFx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5wYWdlc1swXS5sZW5ndGgtMSA6IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5ob21lOlxuXHRcdFx0XHRuZXdYID0gMDtcblx0XHRcdFx0bmV3WSA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MubGVmdDpcblx0XHRcdFx0bmV3WCArPSBzbmFwID8gLTEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MudXA6XG5cdFx0XHRcdG5ld1kgKz0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucmlnaHQ6XG5cdFx0XHRcdG5ld1ggLT0gc25hcCA/IC0xIDogNSArIHRoaXMua2V5QWNjZWxlcmF0aW9uPj4wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmRvd246XG5cdFx0XHRcdG5ld1kgLT0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggc25hcCApIHtcblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG5cdFx0dGhpcy5rZXlUaW1lID0gbm93O1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoZGVzdFgsIGRlc3RZLCBkdXJhdGlvbiwgZWFzaW5nRm4pIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdGFydFggPSB0aGlzLngsXG5cdFx0XHRzdGFydFkgPSB0aGlzLnksXG5cdFx0XHRzdGFydFRpbWUgPSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRkZXN0VGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuXG5cdFx0ZnVuY3Rpb24gc3RlcCAoKSB7XG5cdFx0XHR2YXIgbm93ID0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0XHRlYXNpbmc7XG5cblx0XHRcdGlmICggbm93ID49IGRlc3RUaW1lICkge1xuXHRcdFx0XHR0aGF0LmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQuX3RyYW5zbGF0ZShkZXN0WCwgZGVzdFkpO1xuXG5cdFx0XHRcdGlmICggIXRoYXQucmVzZXRQb3NpdGlvbih0aGF0Lm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHRcdFx0dGhhdC5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bm93ID0gKCBub3cgLSBzdGFydFRpbWUgKSAvIGR1cmF0aW9uO1xuXHRcdFx0ZWFzaW5nID0gZWFzaW5nRm4obm93KTtcblx0XHRcdG5ld1ggPSAoIGRlc3RYIC0gc3RhcnRYICkgKiBlYXNpbmcgKyBzdGFydFg7XG5cdFx0XHRuZXdZID0gKCBkZXN0WSAtIHN0YXJ0WSApICogZWFzaW5nICsgc3RhcnRZO1xuXHRcdFx0dGhhdC5fdHJhbnNsYXRlKG5ld1gsIG5ld1kpO1xuXG5cdFx0XHRpZiAoIHRoYXQuaXNBbmltYXRpbmcgKSB7XG5cdFx0XHRcdHJBRihzdGVwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRzdGVwKCk7XG5cdH0sXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHN3aXRjaCAoIGUudHlwZSApIHtcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmRvd24nOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyRG93bic6XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHR0aGlzLl9zdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcm1vdmUnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyTW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJ1cCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJVcCc6XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGNhc2UgJ3RvdWNoY2FuY2VsJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyQ2FuY2VsJzpcblx0XHRcdGNhc2UgJ21vdXNlY2FuY2VsJzpcblx0XHRcdFx0dGhpcy5fZW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ29yaWVudGF0aW9uY2hhbmdlJzpcblx0XHRcdGNhc2UgJ3Jlc2l6ZSc6XG5cdFx0XHRcdHRoaXMuX3Jlc2l6ZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RyYW5zaXRpb25lbmQnOlxuXHRcdFx0Y2FzZSAnd2Via2l0VHJhbnNpdGlvbkVuZCc6XG5cdFx0XHRjYXNlICdvVHJhbnNpdGlvbkVuZCc6XG5cdFx0XHRjYXNlICdNU1RyYW5zaXRpb25FbmQnOlxuXHRcdFx0XHR0aGlzLl90cmFuc2l0aW9uRW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3doZWVsJzpcblx0XHRcdGNhc2UgJ0RPTU1vdXNlU2Nyb2xsJzpcblx0XHRcdGNhc2UgJ21vdXNld2hlZWwnOlxuXHRcdFx0XHR0aGlzLl93aGVlbChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdrZXlkb3duJzpcblx0XHRcdFx0dGhpcy5fa2V5KGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2NsaWNrJzpcblx0XHRcdFx0aWYgKCB0aGlzLmVuYWJsZWQgJiYgIWUuX2NvbnN0cnVjdGVkICkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxufTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIgKGRpcmVjdGlvbiwgaW50ZXJhY3RpdmUsIHR5cGUpIHtcblx0dmFyIHNjcm9sbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5cdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTknO1xuXHRcdGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gJy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMC41KTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC45KTtib3JkZXItcmFkaXVzOjNweCc7XG5cdH1cblxuXHRpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2lTY3JvbGxJbmRpY2F0b3InO1xuXG5cdGlmICggZGlyZWN0aW9uID09ICdoJyApIHtcblx0XHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO2hlaWdodDo3cHg7bGVmdDoycHg7cmlnaHQ6MnB4O2JvdHRvbTowJztcblx0XHRcdGluZGljYXRvci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdFx0fVxuXHRcdHNjcm9sbGJhci5jbGFzc05hbWUgPSAnaVNjcm9sbEhvcml6b250YWxTY3JvbGxiYXInO1xuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRcdHNjcm9sbGJhci5zdHlsZS5jc3NUZXh0ICs9ICc7d2lkdGg6N3B4O2JvdHRvbToycHg7dG9wOjJweDtyaWdodDoxcHgnO1xuXHRcdFx0aW5kaWNhdG9yLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XHRzY3JvbGxiYXIuY2xhc3NOYW1lID0gJ2lTY3JvbGxWZXJ0aWNhbFNjcm9sbGJhcic7XG5cdH1cblxuXHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO292ZXJmbG93OmhpZGRlbic7XG5cblx0aWYgKCAhaW50ZXJhY3RpdmUgKSB7XG5cdFx0c2Nyb2xsYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cdH1cblxuXHRzY3JvbGxiYXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcblxuXHRyZXR1cm4gc2Nyb2xsYmFyO1xufVxuXG5mdW5jdGlvbiBJbmRpY2F0b3IgKHNjcm9sbGVyLCBvcHRpb25zKSB7XG5cdHRoaXMud3JhcHBlciA9IHR5cGVvZiBvcHRpb25zLmVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmVsKSA6IG9wdGlvbnMuZWw7XG5cdHRoaXMud3JhcHBlclN0eWxlID0gdGhpcy53cmFwcGVyLnN0eWxlO1xuXHR0aGlzLmluZGljYXRvciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5pbmRpY2F0b3JTdHlsZSA9IHRoaXMuaW5kaWNhdG9yLnN0eWxlO1xuXHR0aGlzLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG5cblx0dGhpcy5vcHRpb25zID0ge1xuXHRcdGxpc3Rlblg6IHRydWUsXG5cdFx0bGlzdGVuWTogdHJ1ZSxcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cdFx0cmVzaXplOiB0cnVlLFxuXHRcdGRlZmF1bHRTY3JvbGxiYXJzOiBmYWxzZSxcblx0XHRzaHJpbms6IGZhbHNlLFxuXHRcdGZhZGU6IGZhbHNlLFxuXHRcdHNwZWVkUmF0aW9YOiAwLFxuXHRcdHNwZWVkUmF0aW9ZOiAwXG5cdH07XG5cblx0Zm9yICggdmFyIGkgaW4gb3B0aW9ucyApIHtcblx0XHR0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xuXHR9XG5cblx0dGhpcy5zaXplUmF0aW9YID0gMTtcblx0dGhpcy5zaXplUmF0aW9ZID0gMTtcblx0dGhpcy5tYXhQb3NYID0gMDtcblx0dGhpcy5tYXhQb3NZID0gMDtcblxuXHRpZiAoIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSApIHtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVRvdWNoICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBvaW50ZXIgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlTW91c2UgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgJ21vdXNlZG93bicsIHRoaXMpO1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGlmICggdGhpcy5vcHRpb25zLmZhZGUgKSB7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9IHRoaXMuc2Nyb2xsZXIudHJhbnNsYXRlWjtcblx0XHR2YXIgZHVyYXRpb25Qcm9wID0gdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uO1xuXHRcdHRoaXMud3JhcHBlclN0eWxlW2R1cmF0aW9uUHJvcF0gPSB1dGlscy5pc0JhZEFuZHJvaWQgPyAnMC4wMDAxbXMnIDogJzBtcyc7XG5cdFx0Ly8gcmVtb3ZlIDAuMDAwMW1zXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKHV0aWxzLmlzQmFkQW5kcm9pZCkge1xuXHRcdFx0ckFGKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihzZWxmLndyYXBwZXJTdHlsZVtkdXJhdGlvblByb3BdID09PSAnMC4wMDAxbXMnKSB7XG5cdFx0XHRcdFx0c2VsZi53cmFwcGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwcyc7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gJzAnO1xuXHR9XG59XG5cbkluZGljYXRvci5wcm90b3R5cGUgPSB7XG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHN3aXRjaCAoIGUudHlwZSApIHtcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmRvd24nOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyRG93bic6XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHR0aGlzLl9zdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcm1vdmUnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyTW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJ1cCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJVcCc6XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGNhc2UgJ3RvdWNoY2FuY2VsJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyQ2FuY2VsJzpcblx0XHRcdGNhc2UgJ21vdXNlY2FuY2VsJzpcblx0XHRcdFx0dGhpcy5fZW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZmFkZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5mYWRlVGltZW91dCA9IG51bGw7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5vcHRpb25zLmludGVyYWN0aXZlICkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMuaW5kaWNhdG9yLCAnbW91c2Vkb3duJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNoZW5kJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICkge1xuXHRcdFx0dGhpcy53cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHRoaXMudHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdHRoaXMuaW5pdGlhdGVkID0gdHJ1ZTtcblx0XHR0aGlzLm1vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5sYXN0UG9pbnRYXHQ9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMubGFzdFBvaW50WVx0PSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuc3RhcnRUaW1lXHQ9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlVG91Y2ggKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVQb2ludGVyICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZU1vdXNlICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdiZWZvcmVTY3JvbGxTdGFydCcpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG5cdFx0XHRkZWx0YVgsIGRlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aW1lc3RhbXAgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdzY3JvbGxTdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubW92ZWQgPSB0cnVlO1xuXG5cdFx0ZGVsdGFYID0gcG9pbnQucGFnZVggLSB0aGlzLmxhc3RQb2ludFg7XG5cdFx0dGhpcy5sYXN0UG9pbnRYID0gcG9pbnQucGFnZVg7XG5cblx0XHRkZWx0YVkgPSBwb2ludC5wYWdlWSAtIHRoaXMubGFzdFBvaW50WTtcblx0XHR0aGlzLmxhc3RQb2ludFkgPSBwb2ludC5wYWdlWTtcblxuXHRcdG5ld1ggPSB0aGlzLnggKyBkZWx0YVg7XG5cdFx0bmV3WSA9IHRoaXMueSArIGRlbHRhWTtcblxuXHRcdHRoaXMuX3BvcyhuZXdYLCBuZXdZKTtcblxuLy8gSU5TRVJUIFBPSU5UOiBpbmRpY2F0b3IuX21vdmVcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdF9lbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHZhciBzbmFwID0gdGhpcy5zY3JvbGxlci5fbmVhcmVzdFNuYXAodGhpcy5zY3JvbGxlci54LCB0aGlzLnNjcm9sbGVyLnkpO1xuXG5cdFx0XHR2YXIgdGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnNjcm9sbGVyLnggLSBzbmFwLngpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMuc2Nyb2xsZXIueSAtIHNuYXAueSksIDEwMDApXG5cdFx0XHRcdFx0KSwgMzAwKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNjcm9sbGVyLnggIT0gc25hcC54IHx8IHRoaXMuc2Nyb2xsZXIueSAhPSBzbmFwLnkgKSB7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWSA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHNuYXAueCwgc25hcC55LCB0aW1lLCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuYm91bmNlRWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubW92ZWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblx0fSxcblxuXHR0cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXHRcdHZhciBkdXJhdGlvblByb3AgPSB1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb247XG5cdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID0gdGltZSArICdtcyc7XG5cblx0XHRpZiAoICF0aW1lICYmIHV0aWxzLmlzQmFkQW5kcm9pZCApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwLjAwMDFtcyc7XG5cdFx0XHQvLyByZW1vdmUgMC4wMDAxbXNcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHJBRihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID09PSAnMC4wMDAxbXMnKSB7XG5cdFx0XHRcdFx0c2VsZi5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID0gJzBzJztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogZnVuY3Rpb24gKGVhc2luZykge1xuXHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZztcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy50cmFuc2l0aW9uVGltZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCAmJiAhdGhpcy5vcHRpb25zLmxpc3RlblkgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5ZICYmICF0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuZGlzcGxheSA9IHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgfHwgdGhpcy5zY3JvbGxlci5oYXNWZXJ0aWNhbFNjcm9sbCA/ICdibG9jaycgOiAnbm9uZSc7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgJiYgdGhpcy5zY3JvbGxlci5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHV0aWxzLmFkZENsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxCb3RoU2Nyb2xsYmFycycpO1xuXHRcdFx0dXRpbHMucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbExvbmVTY3JvbGxiYXInKTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjcm9sbGJhcnMgJiYgdGhpcy5vcHRpb25zLmN1c3RvbVN0eWxlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5yaWdodCA9ICc4cHgnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5ib3R0b20gPSAnOHB4Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlscy5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsQm90aFNjcm9sbGJhcnMnKTtcblx0XHRcdHV0aWxzLmFkZENsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxMb25lU2Nyb2xsYmFyJyk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICYmIHRoaXMub3B0aW9ucy5jdXN0b21TdHlsZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUucmlnaHQgPSAnMnB4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUuYm90dG9tID0gJzJweCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgciA9IHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQ7XHQvLyBmb3JjZSByZWZyZXNoXG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0dGhpcy53cmFwcGVyV2lkdGggPSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yV2lkdGggPSBNYXRoLm1heChNYXRoLnJvdW5kKHRoaXMud3JhcHBlcldpZHRoICogdGhpcy53cmFwcGVyV2lkdGggLyAodGhpcy5zY3JvbGxlci5zY3JvbGxlcldpZHRoIHx8IHRoaXMud3JhcHBlcldpZHRoIHx8IDEpKSwgOCk7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLmluZGljYXRvcldpZHRoICsgJ3B4Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yV2lkdGggPSB0aGlzLmluZGljYXRvci5jbGllbnRXaWR0aDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NYID0gdGhpcy53cmFwcGVyV2lkdGggLSB0aGlzLmluZGljYXRvcldpZHRoO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ2NsaXAnICkge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WCA9IC10aGlzLmluZGljYXRvcldpZHRoICsgODtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVggPSB0aGlzLndyYXBwZXJXaWR0aCAtIDg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WCA9IDA7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlYID0gdGhpcy5tYXhQb3NYO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNpemVSYXRpb1ggPSB0aGlzLm9wdGlvbnMuc3BlZWRSYXRpb1ggfHwgKHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWCAmJiAodGhpcy5tYXhQb3NYIC8gdGhpcy5zY3JvbGxlci5tYXhTY3JvbGxYKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWSApIHtcblx0XHRcdHRoaXMud3JhcHBlckhlaWdodCA9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9ySGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5yb3VuZCh0aGlzLndyYXBwZXJIZWlnaHQgKiB0aGlzLndyYXBwZXJIZWlnaHQgLyAodGhpcy5zY3JvbGxlci5zY3JvbGxlckhlaWdodCB8fCB0aGlzLndyYXBwZXJIZWlnaHQgfHwgMSkpLCA4KTtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodCArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvckhlaWdodCA9IHRoaXMuaW5kaWNhdG9yLmNsaWVudEhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnY2xpcCcgKSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlZID0gLXRoaXMuaW5kaWNhdG9ySGVpZ2h0ICsgODtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVkgPSB0aGlzLndyYXBwZXJIZWlnaHQgLSA4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVkgPSAwO1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WSA9IHRoaXMubWF4UG9zWTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cdFx0XHR0aGlzLnNpemVSYXRpb1kgPSB0aGlzLm9wdGlvbnMuc3BlZWRSYXRpb1kgfHwgKHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWSAmJiAodGhpcy5tYXhQb3NZIC8gdGhpcy5zY3JvbGxlci5tYXhTY3JvbGxZKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHR9LFxuXG5cdHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHggPSB0aGlzLm9wdGlvbnMubGlzdGVuWCAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWCAqIHRoaXMuc2Nyb2xsZXIueCkgfHwgMCxcblx0XHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWSAqIHRoaXMuc2Nyb2xsZXIueSkgfHwgMDtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5pZ25vcmVCb3VuZGFyaWVzICkge1xuXHRcdFx0aWYgKCB4IDwgdGhpcy5taW5Cb3VuZGFyeVggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLmluZGljYXRvcldpZHRoICsgeCwgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHggPSB0aGlzLm1pbkJvdW5kYXJ5WDtcblx0XHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heEJvdW5kYXJ5WCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMuaW5kaWNhdG9yV2lkdGggLSAoeCAtIHRoaXMubWF4UG9zWCksIDgpO1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHR4ID0gdGhpcy5tYXhQb3NYICsgdGhpcy5pbmRpY2F0b3JXaWR0aCAtIHRoaXMud2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHRoaXMubWF4Qm91bmRhcnlYO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgJiYgdGhpcy53aWR0aCAhPSB0aGlzLmluZGljYXRvcldpZHRoICkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5pbmRpY2F0b3JXaWR0aDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHkgPCB0aGlzLm1pbkJvdW5kYXJ5WSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmluZGljYXRvckhlaWdodCArIHkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR5ID0gdGhpcy5taW5Cb3VuZGFyeVk7XG5cdFx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhCb3VuZGFyeVkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JIZWlnaHQgLSAoeSAtIHRoaXMubWF4UG9zWSkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhQb3NZICsgdGhpcy5pbmRpY2F0b3JIZWlnaHQgLSB0aGlzLmhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhCb3VuZGFyeVk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyAmJiB0aGlzLmhlaWdodCAhPSB0aGlzLmluZGljYXRvckhlaWdodCApIHtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2Zvcm1dID0gJ3RyYW5zbGF0ZSgnICsgeCArICdweCwnICsgeSArICdweCknICsgdGhpcy5zY3JvbGxlci50cmFuc2xhdGVaO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUudG9wID0geSArICdweCc7XG5cdFx0fVxuXHR9LFxuXG5cdF9wb3M6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0aWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heFBvc1ggKSB7XG5cdFx0XHR4ID0gdGhpcy5tYXhQb3NYO1xuXHRcdH1cblxuXHRcdGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhQb3NZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4UG9zWTtcblx0XHR9XG5cblx0XHR4ID0gdGhpcy5vcHRpb25zLmxpc3RlblggPyBNYXRoLnJvdW5kKHggLyB0aGlzLnNpemVSYXRpb1gpIDogdGhpcy5zY3JvbGxlci54O1xuXHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSA/IE1hdGgucm91bmQoeSAvIHRoaXMuc2l6ZVJhdGlvWSkgOiB0aGlzLnNjcm9sbGVyLnk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHgsIHkpO1xuXHR9LFxuXG5cdGZhZGU6IGZ1bmN0aW9uICh2YWwsIGhvbGQpIHtcblx0XHRpZiAoIGhvbGQgJiYgIXRoaXMudmlzaWJsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5mYWRlVGltZW91dCk7XG5cdFx0dGhpcy5mYWRlVGltZW91dCA9IG51bGw7XG5cblx0XHR2YXIgdGltZSA9IHZhbCA/IDI1MCA6IDUwMCxcblx0XHRcdGRlbGF5ID0gdmFsID8gMCA6IDMwMDtcblxuXHRcdHZhbCA9IHZhbCA/ICcxJyA6ICcwJztcblxuXHRcdHRoaXMud3JhcHBlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSB0aW1lICsgJ21zJztcblxuXHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gdmFsO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gK3ZhbDtcblx0XHR9KS5iaW5kKHRoaXMsIHZhbCksIGRlbGF5KTtcblx0fVxufTtcblxuSVNjcm9sbC51dGlscyA9IHV0aWxzO1xuXG5pZiAoIHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gSVNjcm9sbDtcbn0gZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgICAgICBkZWZpbmUoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElTY3JvbGw7IH0gKTtcbn0gZWxzZSB7XG5cdHdpbmRvdy5JU2Nyb2xsID0gSVNjcm9sbDtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgTWF0aCk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWF0Y2hEYXRhJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSYW5nZTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RGdW5jdGlvbjtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBiYXNlUmFuZ2UgPSByZXF1aXJlKCcuL19iYXNlUmFuZ2UnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSYW5nZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5U29tZSA9IHJlcXVpcmUoJy4vX2FycmF5U29tZScpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgY2FzdEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fY2FzdEZ1bmN0aW9uJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZm9ySW5SaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgPyBvYmplY3RcbiAgICA6IGJhc2VGb3Iob2JqZWN0LCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpLCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckluO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gKiBAc2VlIF8ubWFwS2V5c1xuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICogfTtcbiAqXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFZhbHVlcztcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCJ2YXIgY3JlYXRlUmFuZ2UgPSByZXF1aXJlKCcuL19jcmVhdGVSYW5nZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gKlxuICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yYW5nZSg0KTtcbiAqIC8vID0+IFswLCAxLCAyLCAzXVxuICpcbiAqIF8ucmFuZ2UoLTQpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA1KTtcbiAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICpcbiAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAqXG4gKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAqXG4gKiBfLnJhbmdlKDEsIDQsIDApO1xuICogLy8gPT4gWzEsIDEsIDFdXG4gKlxuICogXy5yYW5nZSgwKTtcbiAqIC8vID0+IFtdXG4gKi9cbnZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZ2U7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgZGVib3VuY2UgPSByZXF1aXJlKCcuL2RlYm91bmNlJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGh5cGVyc2NyaXB0ID0gcmVxdWlyZShcIi4vcmVuZGVyL2h5cGVyc2NyaXB0XCIpXG5cbmh5cGVyc2NyaXB0LnRydXN0ID0gcmVxdWlyZShcIi4vcmVuZGVyL3RydXN0XCIpXG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IHJlcXVpcmUoXCIuL3JlbmRlci9mcmFnbWVudFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGVyc2NyaXB0XG4iLCI7KGZ1bmN0aW9uKCkge1xuXCJ1c2Ugc3RyaWN0XCJcbmZ1bmN0aW9uIFZub2RlKHRhZywga2V5LCBhdHRyczAsIGNoaWxkcmVuLCB0ZXh0LCBkb20pIHtcblx0cmV0dXJuIHt0YWc6IHRhZywga2V5OiBrZXksIGF0dHJzOiBhdHRyczAsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dDogdGV4dCwgZG9tOiBkb20sIGRvbVNpemU6IHVuZGVmaW5lZCwgc3RhdGU6IHVuZGVmaW5lZCwgX3N0YXRlOiB1bmRlZmluZWQsIGV2ZW50czogdW5kZWZpbmVkLCBpbnN0YW5jZTogdW5kZWZpbmVkLCBza2lwOiBmYWxzZX1cbn1cblZub2RlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBWbm9kZShcIltcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKG5vZGUpLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0aWYgKG5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIFZub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9kZSA9PT0gZmFsc2UgPyBcIlwiIDogbm9kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdHJldHVybiBub2RlXG59XG5Wbm9kZS5ub3JtYWxpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZHJlbltpXSA9IFZub2RlLm5vcm1hbGl6ZShjaGlsZHJlbltpXSlcblx0fVxuXHRyZXR1cm4gY2hpbGRyZW5cbn1cbnZhciBzZWxlY3RvclBhcnNlciA9IC8oPzooXnwjfFxcLikoW14jXFwuXFxbXFxdXSspKXwoXFxbKC4rPykoPzpcXHMqPVxccyooXCJ8J3wpKCg/OlxcXFxbXCInXFxdXXwuKSo/KVxcNSk/XFxdKS9nXG52YXIgc2VsZWN0b3JDYWNoZSA9IHt9XG52YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHlcbmZ1bmN0aW9uIGlzRW1wdHkob2JqZWN0KSB7XG5cdGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChoYXNPd24uY2FsbChvYmplY3QsIGtleSkpIHJldHVybiBmYWxzZVxuXHRyZXR1cm4gdHJ1ZVxufVxuZnVuY3Rpb24gY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG5cdHZhciBtYXRjaCwgdGFnID0gXCJkaXZcIiwgY2xhc3NlcyA9IFtdLCBhdHRycyA9IHt9XG5cdHdoaWxlIChtYXRjaCA9IHNlbGVjdG9yUGFyc2VyLmV4ZWMoc2VsZWN0b3IpKSB7XG5cdFx0dmFyIHR5cGUgPSBtYXRjaFsxXSwgdmFsdWUgPSBtYXRjaFsyXVxuXHRcdGlmICh0eXBlID09PSBcIlwiICYmIHZhbHVlICE9PSBcIlwiKSB0YWcgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiI1wiKSBhdHRycy5pZCA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIuXCIpIGNsYXNzZXMucHVzaCh2YWx1ZSlcblx0XHRlbHNlIGlmIChtYXRjaFszXVswXSA9PT0gXCJbXCIpIHtcblx0XHRcdHZhciBhdHRyVmFsdWUgPSBtYXRjaFs2XVxuXHRcdFx0aWYgKGF0dHJWYWx1ZSkgYXR0clZhbHVlID0gYXR0clZhbHVlLnJlcGxhY2UoL1xcXFwoW1wiJ10pL2csIFwiJDFcIikucmVwbGFjZSgvXFxcXFxcXFwvZywgXCJcXFxcXCIpXG5cdFx0XHRpZiAobWF0Y2hbNF0gPT09IFwiY2xhc3NcIikgY2xhc3Nlcy5wdXNoKGF0dHJWYWx1ZSlcblx0XHRcdGVsc2UgYXR0cnNbbWF0Y2hbNF1dID0gYXR0clZhbHVlID09PSBcIlwiID8gYXR0clZhbHVlIDogYXR0clZhbHVlIHx8IHRydWVcblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzZXMubGVuZ3RoID4gMCkgYXR0cnMuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKVxuXHRyZXR1cm4gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gPSB7dGFnOiB0YWcsIGF0dHJzOiBhdHRyc31cbn1cbmZ1bmN0aW9uIGV4ZWNTZWxlY3RvcihzdGF0ZSwgYXR0cnMsIGNoaWxkcmVuKSB7XG5cdHZhciBoYXNBdHRycyA9IGZhbHNlLCBjaGlsZExpc3QsIHRleHRcblx0dmFyIGNsYXNzTmFtZSA9IGF0dHJzLmNsYXNzTmFtZSB8fCBhdHRycy5jbGFzc1xuXHRpZiAoIWlzRW1wdHkoc3RhdGUuYXR0cnMpICYmICFpc0VtcHR5KGF0dHJzKSkge1xuXHRcdHZhciBuZXdBdHRycyA9IHt9XG5cdFx0Zm9yKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSkge1xuXHRcdFx0XHRuZXdBdHRyc1trZXldID0gYXR0cnNba2V5XVxuXHRcdFx0fVxuXHRcdH1cblx0XHRhdHRycyA9IG5ld0F0dHJzXG5cdH1cblx0Zm9yICh2YXIga2V5IGluIHN0YXRlLmF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKHN0YXRlLmF0dHJzLCBrZXkpKSB7XG5cdFx0XHRhdHRyc1trZXldID0gc3RhdGUuYXR0cnNba2V5XVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoYXR0cnMuY2xhc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXR0cnMuY2xhc3MgPSB1bmRlZmluZWRcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuXHRcdH1cblx0XHRpZiAoc3RhdGUuYXR0cnMuY2xhc3NOYW1lICE9IG51bGwpIHtcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IHN0YXRlLmF0dHJzLmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lXG5cdFx0fVxuXHR9XG5cdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSAmJiBrZXkgIT09IFwia2V5XCIpIHtcblx0XHRcdGhhc0F0dHJzID0gdHJ1ZVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSAhPSBudWxsICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCIjXCIpIHtcblx0XHR0ZXh0ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0fSBlbHNlIHtcblx0XHRjaGlsZExpc3QgPSBjaGlsZHJlblxuXHR9XG5cdHJldHVybiBWbm9kZShzdGF0ZS50YWcsIGF0dHJzLmtleSwgaGFzQXR0cnMgPyBhdHRycyA6IHVuZGVmaW5lZCwgY2hpbGRMaXN0LCB0ZXh0KVxufVxuZnVuY3Rpb24gaHlwZXJzY3JpcHQoc2VsZWN0b3IpIHtcblx0Ly8gQmVjYXVzZSBzbG9wcHkgbW9kZSBzdWNrc1xuXHR2YXIgYXR0cnMgPSBhcmd1bWVudHNbMV0sIHN0YXJ0ID0gMiwgY2hpbGRyZW5cblx0aWYgKHNlbGVjdG9yID09IG51bGwgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxlY3Rvci52aWV3ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR0aHJvdyBFcnJvcihcIlRoZSBzZWxlY3RvciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGNvbXBvbmVudC5cIik7XG5cdH1cblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHZhciBjYWNoZWQgPSBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSB8fCBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpXG5cdH1cblx0aWYgKGF0dHJzID09IG51bGwpIHtcblx0XHRhdHRycyA9IHt9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJzLnRhZyAhPSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHRcdHN0YXJ0ID0gMVxuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSBzdGFydCArIDEpIHtcblx0XHRjaGlsZHJlbiA9IGFyZ3VtZW50c1tzdGFydF1cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSBjaGlsZHJlbiA9IFtjaGlsZHJlbl1cblx0fSBlbHNlIHtcblx0XHRjaGlsZHJlbiA9IFtdXG5cdFx0d2hpbGUgKHN0YXJ0IDwgYXJndW1lbnRzLmxlbmd0aCkgY2hpbGRyZW4ucHVzaChhcmd1bWVudHNbc3RhcnQrK10pXG5cdH1cblx0dmFyIG5vcm1hbGl6ZWQgPSBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbilcblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBleGVjU2VsZWN0b3IoY2FjaGVkLCBhdHRycywgbm9ybWFsaXplZClcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gVm5vZGUoc2VsZWN0b3IsIGF0dHJzLmtleSwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH1cbn1cbmh5cGVyc2NyaXB0LnRydXN0ID0gZnVuY3Rpb24oaHRtbCkge1xuXHRpZiAoaHRtbCA9PSBudWxsKSBodG1sID0gXCJcIlxuXHRyZXR1cm4gVm5vZGUoXCI8XCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBodG1sLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbmh5cGVyc2NyaXB0LmZyYWdtZW50ID0gZnVuY3Rpb24oYXR0cnMxLCBjaGlsZHJlbikge1xuXHRyZXR1cm4gVm5vZGUoXCJbXCIsIGF0dHJzMS5rZXksIGF0dHJzMSwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbnZhciBtID0gaHlwZXJzY3JpcHRcbi8qKiBAY29uc3RydWN0b3IgKi9cbnZhciBQcm9taXNlUG9seWZpbGwgPSBmdW5jdGlvbihleGVjdXRvcikge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGBuZXdgXCIpXG5cdGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKVxuXHR2YXIgc2VsZiA9IHRoaXMsIHJlc29sdmVycyA9IFtdLCByZWplY3RvcnMgPSBbXSwgcmVzb2x2ZUN1cnJlbnQgPSBoYW5kbGVyKHJlc29sdmVycywgdHJ1ZSksIHJlamVjdEN1cnJlbnQgPSBoYW5kbGVyKHJlamVjdG9ycywgZmFsc2UpXG5cdHZhciBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlID0ge3Jlc29sdmVyczogcmVzb2x2ZXJzLCByZWplY3RvcnM6IHJlamVjdG9yc31cblx0dmFyIGNhbGxBc3luYyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gaGFuZGxlcihsaXN0LCBzaG91bGRBYnNvcmIpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXhlY3V0ZSh2YWx1ZSkge1xuXHRcdFx0dmFyIHRoZW5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChzaG91bGRBYnNvcmIgJiYgdmFsdWUgIT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgKHRoZW4gPSB2YWx1ZS50aGVuKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCB3LyBpdHNlbGZcIilcblx0XHRcdFx0XHRleGVjdXRlT25jZSh0aGVuLmJpbmQodmFsdWUpKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxBc3luYyhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICghc2hvdWxkQWJzb3JiICYmIGxpc3QubGVuZ3RoID09PSAwKSBjb25zb2xlLmVycm9yKFwiUG9zc2libGUgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOlwiLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgbGlzdFtpXSh2YWx1ZSlcblx0XHRcdFx0XHRcdHJlc29sdmVycy5sZW5ndGggPSAwLCByZWplY3RvcnMubGVuZ3RoID0gMFxuXHRcdFx0XHRcdFx0aW5zdGFuY2Uuc3RhdGUgPSBzaG91bGRBYnNvcmJcblx0XHRcdFx0XHRcdGluc3RhbmNlLnJldHJ5ID0gZnVuY3Rpb24oKSB7ZXhlY3V0ZSh2YWx1ZSl9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0Q3VycmVudChlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBleGVjdXRlT25jZSh0aGVuKSB7XG5cdFx0dmFyIHJ1bnMgPSAwXG5cdFx0ZnVuY3Rpb24gcnVuKGZuKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHJ1bnMrKyA+IDApIHJldHVyblxuXHRcdFx0XHRmbih2YWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIG9uZXJyb3IgPSBydW4ocmVqZWN0Q3VycmVudClcblx0XHR0cnkge3RoZW4ocnVuKHJlc29sdmVDdXJyZW50KSwgb25lcnJvcil9IGNhdGNoIChlKSB7b25lcnJvcihlKX1cblx0fVxuXHRleGVjdXRlT25jZShleGVjdXRvcilcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGlvbikge1xuXHR2YXIgc2VsZiA9IHRoaXMsIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2Vcblx0ZnVuY3Rpb24gaGFuZGxlKGNhbGxiYWNrLCBsaXN0LCBuZXh0LCBzdGF0ZSkge1xuXHRcdGxpc3QucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSBuZXh0KHZhbHVlKVxuXHRcdFx0ZWxzZSB0cnkge3Jlc29sdmVOZXh0KGNhbGxiYWNrKHZhbHVlKSl9IGNhdGNoIChlKSB7aWYgKHJlamVjdE5leHQpIHJlamVjdE5leHQoZSl9XG5cdFx0fSlcblx0XHRpZiAodHlwZW9mIGluc3RhbmNlLnJldHJ5ID09PSBcImZ1bmN0aW9uXCIgJiYgc3RhdGUgPT09IGluc3RhbmNlLnN0YXRlKSBpbnN0YW5jZS5yZXRyeSgpXG5cdH1cblx0dmFyIHJlc29sdmVOZXh0LCByZWplY3ROZXh0XG5cdHZhciBwcm9taXNlID0gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZXNvbHZlTmV4dCA9IHJlc29sdmUsIHJlamVjdE5leHQgPSByZWplY3R9KVxuXHRoYW5kbGUob25GdWxmaWxsZWQsIGluc3RhbmNlLnJlc29sdmVycywgcmVzb2x2ZU5leHQsIHRydWUpLCBoYW5kbGUob25SZWplY3Rpb24sIGluc3RhbmNlLnJlamVjdG9ycywgcmVqZWN0TmV4dCwgZmFsc2UpXG5cdHJldHVybiBwcm9taXNlXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcblx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbilcbn1cblByb21pc2VQb2x5ZmlsbC5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVBvbHlmaWxsKSByZXR1cm4gdmFsdWVcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSkge3Jlc29sdmUodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtyZWplY3QodmFsdWUpfSlcbn1cblByb21pc2VQb2x5ZmlsbC5hbGwgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdHZhciB0b3RhbCA9IGxpc3QubGVuZ3RoLCBjb3VudCA9IDAsIHZhbHVlcyA9IFtdXG5cdFx0aWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKVxuXHRcdGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQoZnVuY3Rpb24oaSkge1xuXHRcdFx0XHRmdW5jdGlvbiBjb25zdW1lKHZhbHVlKSB7XG5cdFx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSB0b3RhbCkgcmVzb2x2ZSh2YWx1ZXMpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxpc3RbaV0gIT0gbnVsbCAmJiAodHlwZW9mIGxpc3RbaV0gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGxpc3RbaV0gPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mIGxpc3RbaV0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0bGlzdFtpXS50aGVuKGNvbnN1bWUsIHJlamVjdClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGNvbnN1bWUobGlzdFtpXSlcblx0XHRcdH0pKGkpXG5cdFx0fVxuXHR9KVxufVxuUHJvbWlzZVBvbHlmaWxsLnJhY2UgPSBmdW5jdGlvbihsaXN0KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGlzdFtpXS50aGVuKHJlc29sdmUsIHJlamVjdClcblx0XHR9XG5cdH0pXG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRpZiAodHlwZW9mIHdpbmRvdy5Qcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSB3aW5kb3cuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR2YXIgUHJvbWlzZVBvbHlmaWxsID0gd2luZG93LlByb21pc2Vcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRpZiAodHlwZW9mIGdsb2JhbC5Qcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSBnbG9iYWwuUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxuXHR2YXIgUHJvbWlzZVBvbHlmaWxsID0gZ2xvYmFsLlByb21pc2Vcbn0gZWxzZSB7XG59XG52YXIgYnVpbGRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHJldHVybiBcIlwiXG5cdHZhciBhcmdzID0gW11cblx0Zm9yICh2YXIga2V5MCBpbiBvYmplY3QpIHtcblx0XHRkZXN0cnVjdHVyZShrZXkwLCBvYmplY3Rba2V5MF0pXG5cdH1cblx0cmV0dXJuIGFyZ3Muam9pbihcIiZcIilcblx0ZnVuY3Rpb24gZGVzdHJ1Y3R1cmUoa2V5MCwgdmFsdWUpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRkZXN0cnVjdHVyZShrZXkwICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGFyZ3MucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5MCkgKyAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gXCJcIiA/IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IFwiXCIpKVxuXHR9XG59XG52YXIgRklMRV9QUk9UT0NPTF9SRUdFWCA9IG5ldyBSZWdFeHAoXCJeZmlsZTovL1wiLCBcImlcIilcbnZhciBfOCA9IGZ1bmN0aW9uKCR3aW5kb3csIFByb21pc2UpIHtcblx0dmFyIGNhbGxiYWNrQ291bnQgPSAwXG5cdHZhciBvbmNvbXBsZXRpb25cblx0ZnVuY3Rpb24gc2V0Q29tcGxldGlvbkNhbGxiYWNrKGNhbGxiYWNrKSB7b25jb21wbGV0aW9uID0gY2FsbGJhY2t9XG5cdGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcblx0XHR2YXIgY291bnQgPSAwXG5cdFx0ZnVuY3Rpb24gY29tcGxldGUoKSB7aWYgKC0tY291bnQgPT09IDAgJiYgdHlwZW9mIG9uY29tcGxldGlvbiA9PT0gXCJmdW5jdGlvblwiKSBvbmNvbXBsZXRpb24oKX1cblx0XHRyZXR1cm4gZnVuY3Rpb24gZmluYWxpemUocHJvbWlzZTApIHtcblx0XHRcdHZhciB0aGVuMCA9IHByb21pc2UwLnRoZW5cblx0XHRcdHByb21pc2UwLnRoZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHR2YXIgbmV4dCA9IHRoZW4wLmFwcGx5KHByb21pc2UwLCBhcmd1bWVudHMpXG5cdFx0XHRcdG5leHQudGhlbihjb21wbGV0ZSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdGNvbXBsZXRlKClcblx0XHRcdFx0XHRpZiAoY291bnQgPT09IDApIHRocm93IGVcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuIGZpbmFsaXplKG5leHQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTBcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmdzID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgdXJsID0gYXJnc1xuXHRcdFx0YXJncyA9IGV4dHJhIHx8IHt9XG5cdFx0XHRpZiAoYXJncy51cmwgPT0gbnVsbCkgYXJncy51cmwgPSB1cmxcblx0XHR9XG5cdFx0cmV0dXJuIGFyZ3Ncblx0fVxuXHRmdW5jdGlvbiByZXF1ZXN0KGFyZ3MsIGV4dHJhKSB7XG5cdFx0dmFyIGZpbmFsaXplID0gZmluYWxpemVyKClcblx0XHRhcmdzID0gbm9ybWFsaXplKGFyZ3MsIGV4dHJhKVxuXHRcdHZhciBwcm9taXNlMCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0aWYgKGFyZ3MubWV0aG9kID09IG51bGwpIGFyZ3MubWV0aG9kID0gXCJHRVRcIlxuXHRcdFx0YXJncy5tZXRob2QgPSBhcmdzLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG5cdFx0XHR2YXIgdXNlQm9keSA9IChhcmdzLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBhcmdzLm1ldGhvZCA9PT0gXCJUUkFDRVwiKSA/IGZhbHNlIDogKHR5cGVvZiBhcmdzLnVzZUJvZHkgPT09IFwiYm9vbGVhblwiID8gYXJncy51c2VCb2R5IDogdHJ1ZSlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5zZXJpYWxpemUgIT09IFwiZnVuY3Rpb25cIikgYXJncy5zZXJpYWxpemUgPSB0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJncy5kYXRhIGluc3RhbmNlb2YgRm9ybURhdGEgPyBmdW5jdGlvbih2YWx1ZSkge3JldHVybiB2YWx1ZX0gOiBKU09OLnN0cmluZ2lmeVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmRlc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmV4dHJhY3QgIT09IFwiZnVuY3Rpb25cIikgYXJncy5leHRyYWN0ID0gZXh0cmFjdFxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0aWYgKHVzZUJvZHkpIGFyZ3MuZGF0YSA9IGFyZ3Muc2VyaWFsaXplKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgYXJncy51cmwgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0dmFyIHhociA9IG5ldyAkd2luZG93LlhNTEh0dHBSZXF1ZXN0KCksXG5cdFx0XHRcdGFib3J0ZWQgPSBmYWxzZSxcblx0XHRcdFx0X2Fib3J0ID0geGhyLmFib3J0XG5cdFx0XHR4aHIuYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWVcblx0XHRcdFx0X2Fib3J0LmNhbGwoeGhyKVxuXHRcdFx0fVxuXHRcdFx0eGhyLm9wZW4oYXJncy5tZXRob2QsIGFyZ3MudXJsLCB0eXBlb2YgYXJncy5hc3luYyA9PT0gXCJib29sZWFuXCIgPyBhcmdzLmFzeW5jIDogdHJ1ZSwgdHlwZW9mIGFyZ3MudXNlciA9PT0gXCJzdHJpbmdcIiA/IGFyZ3MudXNlciA6IHVuZGVmaW5lZCwgdHlwZW9mIGFyZ3MucGFzc3dvcmQgPT09IFwic3RyaW5nXCIgPyBhcmdzLnBhc3N3b3JkIDogdW5kZWZpbmVkKVxuXHRcdFx0aWYgKGFyZ3Muc2VyaWFsaXplID09PSBKU09OLnN0cmluZ2lmeSAmJiB1c2VCb2R5ICYmICEoYXJncy5oZWFkZXJzICYmIGFyZ3MuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShcIkNvbnRlbnQtVHlwZVwiKSkpIHtcblx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy5kZXNlcmlhbGl6ZSA9PT0gZGVzZXJpYWxpemUgJiYgIShhcmdzLmhlYWRlcnMgJiYgYXJncy5oZWFkZXJzLmhhc093blByb3BlcnR5KFwiQWNjZXB0XCIpKSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBnZXROYW1lU3BhY2Uodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMgJiYgdm5vZGUuYXR0cnMueG1sbnMgfHwgbmFtZVNwYWNlW3Zub2RlLnRhZ11cblx0fVxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2gxID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2gxWzFdXSB8fCBcImRpdlwiXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50MSlcblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRlbHNlIGlmICh2bm9kZXMgPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoLCB2bm9kZXMpXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLmxlbmd0aCA9PT0gdm5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXNVbmtleWVkID0gZmFsc2Vcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgb2xkW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGlzVW5rZXllZCA9IHZub2Rlc1tpXS5rZXkgPT0gbnVsbCAmJiBvbGRbaV0ua2V5ID09IG51bGxcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1Vua2V5ZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZFtpXSA9PT0gdm5vZGVzW2ldKSBjb250aW51ZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAob2xkW2ldID09IG51bGwgJiYgdm5vZGVzW2ldICE9IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZXNbaV0sIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodm5vZGVzW2ldID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgaSwgaSArIDEsIHZub2Rlcylcblx0XHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZFtpXSwgdm5vZGVzW2ldLCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjeWNsaW5nID0gcmVjeWNsaW5nIHx8IGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcylcblx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBvbGQucG9vbFxuXHRcdFx0XHRvbGQgPSBvbGQuY29uY2F0KG9sZC5wb29sKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZTAgbXVsdGlwbGUgY2hpbGRyZW5cblx0XHRcdFx0dm5vZGUudGV4dCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH1cblx0XHR1cGRhdGVBdHRycyh2bm9kZSwgb2xkLmF0dHJzLCB2bm9kZS5hdHRycywgbnMpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdH1cblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0aWYgKG9sZC5pbnN0YW5jZSA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQuaW5zdGFuY2UsIHZub2RlLmluc3RhbmNlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSwgbnVsbClcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKSB7XG5cdFx0aWYgKG9sZC5wb29sICE9IG51bGwgJiYgTWF0aC5hYnMob2xkLnBvb2wubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkgPD0gTWF0aC5hYnMob2xkLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpKSB7XG5cdFx0XHR2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRbMF0gJiYgb2xkWzBdLmNoaWxkcmVuICYmIG9sZFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHBvb2xDaGlsZHJlbkxlbmd0aCA9IG9sZC5wb29sWzBdICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgdm5vZGVzQ2hpbGRyZW5MZW5ndGggPSB2bm9kZXNbMF0gJiYgdm5vZGVzWzBdLmNoaWxkcmVuICYmIHZub2Rlc1swXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0aWYgKE1hdGguYWJzKHBvb2xDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSA8PSBNYXRoLmFicyhvbGRDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBlbmQpIHtcblx0XHR2YXIgbWFwID0ge30sIGkgPSAwXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5MiA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5MiAhPSBudWxsKSBtYXBba2V5Ml0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQwICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQwID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50MCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXHRmdW5jdGlvbiBzZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50MCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0XHRcdHdoaWxlICgtLWNvdW50MCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSBvbnJlbW92ZSh2bm9kZS5pbnN0YW5jZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9hdHRyczJcblx0ZnVuY3Rpb24gc2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0c2V0QXR0cih2bm9kZSwga2V5MiwgbnVsbCwgYXR0cnMyW2tleTJdLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QXR0cih2bm9kZSwga2V5Miwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkyID09PSBcImtleVwiIHx8IGtleTIgPT09IFwiaXNcIiB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkyKSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5Mi5pbmRleE9mKFwiOlwiKVxuXHRcdGlmIChuc0xhc3RJbmRleCA+IC0xICYmIGtleTIuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkyLnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgPT09IFwic3R5bGVcIikgdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyIGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleTIpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkyID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQwID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDApIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlMSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yMCB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5Ml0gPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHQvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiByZXR1cm4gbnVsbCBpbiBJRSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvYWN0aXZlRWxlbWVudFxuXHRcdGlmIChhY3RpdmUgIT0gbnVsbCAmJiAkZG9jLmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZSkgYWN0aXZlLmZvY3VzKClcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdH1cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrKSB7XG5cdC8vNjBmcHMgdHJhbnNsYXRlcyB0byAxNi42bXMsIHJvdW5kIGl0IGRvd24gc2luY2Ugc2V0VGltZW91dCByZXF1aXJlcyBpbnRcblx0dmFyIHRpbWUgPSAxNlxuXHR2YXIgbGFzdCA9IDAsIHBlbmRpbmcgPSBudWxsXG5cdHZhciB0aW1lb3V0ID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dFxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KClcblx0XHRpZiAobGFzdCA9PT0gMCB8fCBub3cgLSBsYXN0ID49IHRpbWUpIHtcblx0XHRcdGxhc3QgPSBub3dcblx0XHRcdGNhbGxiYWNrKClcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuXHRcdFx0cGVuZGluZyA9IHRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrKClcblx0XHRcdFx0bGFzdCA9IERhdGUubm93KClcblx0XHRcdH0sIHRpbWUgLSAobm93IC0gbGFzdCkpXG5cdFx0fVxuXHR9XG59XG52YXIgXzExID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgcmVuZGVyU2VydmljZSA9IGNvcmVSZW5kZXJlcigkd2luZG93KVxuXHRyZW5kZXJTZXJ2aWNlLnNldEV2ZW50Q2FsbGJhY2soZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLnJlZHJhdyA9PT0gZmFsc2UpIGUucmVkcmF3ID0gdW5kZWZpbmVkXG5cdFx0ZWxzZSByZWRyYXcoKVxuXHR9KVxuXHR2YXIgY2FsbGJhY2tzID0gW11cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKGtleTEsIGNhbGxiYWNrKSB7XG5cdFx0dW5zdWJzY3JpYmUoa2V5MSlcblx0XHRjYWxsYmFja3MucHVzaChrZXkxLCB0aHJvdHRsZShjYWxsYmFjaykpXG5cdH1cblx0ZnVuY3Rpb24gdW5zdWJzY3JpYmUoa2V5MSkge1xuXHRcdHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGtleTEpXG5cdFx0aWYgKGluZGV4ID4gLTEpIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDIpXG5cdH1cblx0ZnVuY3Rpb24gcmVkcmF3KCkge1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRjYWxsYmFja3NbaV0oKVxuXHRcdH1cblx0fVxuXHRyZXR1cm4ge3N1YnNjcmliZTogc3Vic2NyaWJlLCB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUsIHJlZHJhdzogcmVkcmF3LCByZW5kZXI6IHJlbmRlclNlcnZpY2UucmVuZGVyfVxufVxudmFyIHJlZHJhd1NlcnZpY2UgPSBfMTEod2luZG93KVxucmVxdWVzdFNlcnZpY2Uuc2V0Q29tcGxldGlvbkNhbGxiYWNrKHJlZHJhd1NlcnZpY2UucmVkcmF3KVxudmFyIF8xNiA9IGZ1bmN0aW9uKHJlZHJhd1NlcnZpY2UwKSB7XG5cdHJldHVybiBmdW5jdGlvbihyb290LCBjb21wb25lbnQpIHtcblx0XHRpZiAoY29tcG9uZW50ID09PSBudWxsKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgW10pXG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC51bnN1YnNjcmliZShyb290KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdFxuXHRcdGlmIChjb21wb25lbnQudmlldyA9PSBudWxsICYmIHR5cGVvZiBjb21wb25lbnQgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwibS5tb3VudChlbGVtZW50LCBjb21wb25lbnQpIGV4cGVjdHMgYSBjb21wb25lbnQsIG5vdCBhIHZub2RlXCIpXG5cdFx0XG5cdFx0dmFyIHJ1bjAgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBWbm9kZShjb21wb25lbnQpKVxuXHRcdH1cblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMClcblx0XHRyZWRyYXdTZXJ2aWNlMC5yZWRyYXcoKVxuXHR9XG59XG5tLm1vdW50ID0gXzE2KHJlZHJhd1NlcnZpY2UpXG52YXIgUHJvbWlzZSA9IFByb21pc2VQb2x5ZmlsbFxudmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0aWYgKHN0cmluZyA9PT0gXCJcIiB8fCBzdHJpbmcgPT0gbnVsbCkgcmV0dXJuIHt9XG5cdGlmIChzdHJpbmcuY2hhckF0KDApID09PSBcIj9cIikgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDEpXG5cdHZhciBlbnRyaWVzID0gc3RyaW5nLnNwbGl0KFwiJlwiKSwgZGF0YTAgPSB7fSwgY291bnRlcnMgPSB7fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZW50cnkgPSBlbnRyaWVzW2ldLnNwbGl0KFwiPVwiKVxuXHRcdHZhciBrZXk1ID0gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzBdKVxuXHRcdHZhciB2YWx1ZSA9IGVudHJ5Lmxlbmd0aCA9PT0gMiA/IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVsxXSkgOiBcIlwiXG5cdFx0aWYgKHZhbHVlID09PSBcInRydWVcIikgdmFsdWUgPSB0cnVlXG5cdFx0ZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikgdmFsdWUgPSBmYWxzZVxuXHRcdHZhciBsZXZlbHMgPSBrZXk1LnNwbGl0KC9cXF1cXFs/fFxcWy8pXG5cdFx0dmFyIGN1cnNvciA9IGRhdGEwXG5cdFx0aWYgKGtleTUuaW5kZXhPZihcIltcIikgPiAtMSkgbGV2ZWxzLnBvcCgpXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1tqXSwgbmV4dExldmVsID0gbGV2ZWxzW2ogKyAxXVxuXHRcdFx0dmFyIGlzTnVtYmVyID0gbmV4dExldmVsID09IFwiXCIgfHwgIWlzTmFOKHBhcnNlSW50KG5leHRMZXZlbCwgMTApKVxuXHRcdFx0dmFyIGlzVmFsdWUgPSBqID09PSBsZXZlbHMubGVuZ3RoIC0gMVxuXHRcdFx0aWYgKGxldmVsID09PSBcIlwiKSB7XG5cdFx0XHRcdHZhciBrZXk1ID0gbGV2ZWxzLnNsaWNlKDAsIGopLmpvaW4oKVxuXHRcdFx0XHRpZiAoY291bnRlcnNba2V5NV0gPT0gbnVsbCkgY291bnRlcnNba2V5NV0gPSAwXG5cdFx0XHRcdGxldmVsID0gY291bnRlcnNba2V5NV0rK1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnNvcltsZXZlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRjdXJzb3JbbGV2ZWxdID0gaXNWYWx1ZSA/IHZhbHVlIDogaXNOdW1iZXIgPyBbXSA6IHt9XG5cdFx0XHR9XG5cdFx0XHRjdXJzb3IgPSBjdXJzb3JbbGV2ZWxdXG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhMFxufVxudmFyIGNvcmVSb3V0ZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IHR5cGVvZiAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID09PSBcImZ1bmN0aW9uXCJcblx0dmFyIGNhbGxBc3luYzAgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZTEoZnJhZ21lbnQwKSB7XG5cdFx0dmFyIGRhdGEgPSAkd2luZG93LmxvY2F0aW9uW2ZyYWdtZW50MF0ucmVwbGFjZSgvKD86JVthLWY4OV1bYS1mMC05XSkrL2dpbSwgZGVjb2RlVVJJQ29tcG9uZW50KVxuXHRcdGlmIChmcmFnbWVudDAgPT09IFwicGF0aG5hbWVcIiAmJiBkYXRhWzBdICE9PSBcIi9cIikgZGF0YSA9IFwiL1wiICsgZGF0YVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0dmFyIGFzeW5jSWRcblx0ZnVuY3Rpb24gZGVib3VuY2VBc3luYyhjYWxsYmFjazApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoYXN5bmNJZCAhPSBudWxsKSByZXR1cm5cblx0XHRcdGFzeW5jSWQgPSBjYWxsQXN5bmMwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhc3luY0lkID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjazAoKVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpIHtcblx0XHR2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIilcblx0XHR2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKVxuXHRcdHZhciBwYXRoRW5kID0gcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgcXVlcnlFbmQgPSBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0XHR2YXIgcXVlcnlQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEsIHF1ZXJ5RW5kKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gcXVlcnlQYXJhbXMpIHF1ZXJ5RGF0YVtrZXk0XSA9IHF1ZXJ5UGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdGlmIChoYXNoSW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIGhhc2hQYXJhbXMgPSBwYXJzZVF1ZXJ5U3RyaW5nKHBhdGguc2xpY2UoaGFzaEluZGV4ICsgMSkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGhhc2hQYXJhbXMpIGhhc2hEYXRhW2tleTRdID0gaGFzaFBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aC5zbGljZSgwLCBwYXRoRW5kKVxuXHR9XG5cdHZhciByb3V0ZXIgPSB7cHJlZml4OiBcIiMhXCJ9XG5cdHJvdXRlci5nZXRQYXRoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR5cGUyID0gcm91dGVyLnByZWZpeC5jaGFyQXQoMClcblx0XHRzd2l0Y2ggKHR5cGUyKSB7XG5cdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gbm9ybWFsaXplMShcImhhc2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRjYXNlIFwiP1wiOiByZXR1cm4gbm9ybWFsaXplMShcInNlYXJjaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIG5vcm1hbGl6ZTEoXCJwYXRobmFtZVwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aCkgKyBub3JtYWxpemUxKFwic2VhcmNoXCIpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHR9XG5cdH1cblx0cm91dGVyLnNldFBhdGggPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0dmFyIHF1ZXJ5RGF0YSA9IHt9LCBoYXNoRGF0YSA9IHt9XG5cdFx0cGF0aCA9IHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKVxuXHRcdGlmIChkYXRhICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTQgaW4gZGF0YSkgcXVlcnlEYXRhW2tleTRdID0gZGF0YVtrZXk0XVxuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvOihbXlxcL10rKS9nLCBmdW5jdGlvbihtYXRjaDIsIHRva2VuKSB7XG5cdFx0XHRcdGRlbGV0ZSBxdWVyeURhdGFbdG9rZW5dXG5cdFx0XHRcdHJldHVybiBkYXRhW3Rva2VuXVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0dmFyIHF1ZXJ5ID0gYnVpbGRRdWVyeVN0cmluZyhxdWVyeURhdGEpXG5cdFx0aWYgKHF1ZXJ5KSBwYXRoICs9IFwiP1wiICsgcXVlcnlcblx0XHR2YXIgaGFzaCA9IGJ1aWxkUXVlcnlTdHJpbmcoaGFzaERhdGEpXG5cdFx0aWYgKGhhc2gpIHBhdGggKz0gXCIjXCIgKyBoYXNoXG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBvcHRpb25zID8gb3B0aW9ucy5zdGF0ZSA6IG51bGxcblx0XHRcdHZhciB0aXRsZSA9IG9wdGlvbnMgPyBvcHRpb25zLnRpdGxlIDogbnVsbFxuXHRcdFx0JHdpbmRvdy5vbnBvcHN0YXRlKClcblx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwbGFjZSkgJHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdFx0ZWxzZSAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0fVxuXHRcdGVsc2UgJHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcm91dGVyLnByZWZpeCArIHBhdGhcblx0fVxuXHRyb3V0ZXIuZGVmaW5lUm91dGVzID0gZnVuY3Rpb24ocm91dGVzLCByZXNvbHZlLCByZWplY3QpIHtcblx0XHRmdW5jdGlvbiByZXNvbHZlUm91dGUoKSB7XG5cdFx0XHR2YXIgcGF0aCA9IHJvdXRlci5nZXRQYXRoKClcblx0XHRcdHZhciBwYXJhbXMgPSB7fVxuXHRcdFx0dmFyIHBhdGhuYW1lID0gcGFyc2VQYXRoKHBhdGgsIHBhcmFtcywgcGFyYW1zKVxuXHRcdFx0dmFyIHN0YXRlID0gJHdpbmRvdy5oaXN0b3J5LnN0YXRlXG5cdFx0XHRpZiAoc3RhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBrIGluIHN0YXRlKSBwYXJhbXNba10gPSBzdGF0ZVtrXVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgcm91dGUwIGluIHJvdXRlcykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoXCJeXCIgKyByb3V0ZTAucmVwbGFjZSgvOlteXFwvXSs/XFwuezN9L2csIFwiKC4qPylcIikucmVwbGFjZSgvOlteXFwvXSsvZywgXCIoW15cXFxcL10rKVwiKSArIFwiXFwvPyRcIilcblx0XHRcdFx0aWYgKG1hdGNoZXIudGVzdChwYXRobmFtZSkpIHtcblx0XHRcdFx0XHRwYXRobmFtZS5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGtleXMgPSByb3V0ZTAubWF0Y2goLzpbXlxcL10rL2cpIHx8IFtdXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEsIC0yKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHBhcmFtc1trZXlzW2ldLnJlcGxhY2UoLzp8XFwuL2csIFwiXCIpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZXNbaV0pXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJvdXRlc1tyb3V0ZTBdLCBwYXJhbXMsIHBhdGgsIHJvdXRlMClcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWplY3QocGF0aCwgcGFyYW1zKVxuXHRcdH1cblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpICR3aW5kb3cub25wb3BzdGF0ZSA9IGRlYm91bmNlQXN5bmMocmVzb2x2ZVJvdXRlKVxuXHRcdGVsc2UgaWYgKHJvdXRlci5wcmVmaXguY2hhckF0KDApID09PSBcIiNcIikgJHdpbmRvdy5vbmhhc2hjaGFuZ2UgPSByZXNvbHZlUm91dGVcblx0XHRyZXNvbHZlUm91dGUoKVxuXHR9XG5cdHJldHVybiByb3V0ZXJcbn1cbnZhciBfMjAgPSBmdW5jdGlvbigkd2luZG93LCByZWRyYXdTZXJ2aWNlMCkge1xuXHR2YXIgcm91dGVTZXJ2aWNlID0gY29yZVJvdXRlcigkd2luZG93KVxuXHR2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbih2KSB7cmV0dXJuIHZ9XG5cdHZhciByZW5kZXIxLCBjb21wb25lbnQsIGF0dHJzMywgY3VycmVudFBhdGgsIGxhc3RVcGRhdGVcblx0dmFyIHJvdXRlID0gZnVuY3Rpb24ocm9vdCwgZGVmYXVsdFJvdXRlLCByb3V0ZXMpIHtcblx0XHRpZiAocm9vdCA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCB0byBgbS5yb3V0ZWAgaXMgbm90IHVuZGVmaW5lZFwiKVxuXHRcdHZhciBydW4xID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAocmVuZGVyMSAhPSBudWxsKSByZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgcmVuZGVyMShWbm9kZShjb21wb25lbnQsIGF0dHJzMy5rZXksIGF0dHJzMykpKVxuXHRcdH1cblx0XHR2YXIgYmFpbCA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdGlmIChwYXRoICE9PSBkZWZhdWx0Um91dGUpIHJvdXRlU2VydmljZS5zZXRQYXRoKGRlZmF1bHRSb3V0ZSwgbnVsbCwge3JlcGxhY2U6IHRydWV9KVxuXHRcdFx0ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBkZWZhdWx0IHJvdXRlIFwiICsgZGVmYXVsdFJvdXRlKVxuXHRcdH1cblx0XHRyb3V0ZVNlcnZpY2UuZGVmaW5lUm91dGVzKHJvdXRlcywgZnVuY3Rpb24ocGF5bG9hZCwgcGFyYW1zLCBwYXRoKSB7XG5cdFx0XHR2YXIgdXBkYXRlID0gbGFzdFVwZGF0ZSA9IGZ1bmN0aW9uKHJvdXRlUmVzb2x2ZXIsIGNvbXApIHtcblx0XHRcdFx0aWYgKHVwZGF0ZSAhPT0gbGFzdFVwZGF0ZSkgcmV0dXJuXG5cdFx0XHRcdGNvbXBvbmVudCA9IGNvbXAgIT0gbnVsbCAmJiAodHlwZW9mIGNvbXAudmlldyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBjb21wID09PSBcImZ1bmN0aW9uXCIpPyBjb21wIDogXCJkaXZcIlxuXHRcdFx0XHRhdHRyczMgPSBwYXJhbXMsIGN1cnJlbnRQYXRoID0gcGF0aCwgbGFzdFVwZGF0ZSA9IG51bGxcblx0XHRcdFx0cmVuZGVyMSA9IChyb3V0ZVJlc29sdmVyLnJlbmRlciB8fCBpZGVudGl0eSkuYmluZChyb3V0ZVJlc29sdmVyKVxuXHRcdFx0XHRydW4xKClcblx0XHRcdH1cblx0XHRcdGlmIChwYXlsb2FkLnZpZXcgfHwgdHlwZW9mIHBheWxvYWQgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlKHt9LCBwYXlsb2FkKVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChwYXlsb2FkLm9ubWF0Y2gpIHtcblx0XHRcdFx0XHRQcm9taXNlLnJlc29sdmUocGF5bG9hZC5vbm1hdGNoKHBhcmFtcywgcGF0aCkpLnRoZW4oZnVuY3Rpb24ocmVzb2x2ZWQpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZShwYXlsb2FkLCByZXNvbHZlZClcblx0XHRcdFx0XHR9LCBiYWlsKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgdXBkYXRlKHBheWxvYWQsIFwiZGl2XCIpXG5cdFx0XHR9XG5cdFx0fSwgYmFpbClcblx0XHRyZWRyYXdTZXJ2aWNlMC5zdWJzY3JpYmUocm9vdCwgcnVuMSlcblx0fVxuXHRyb3V0ZS5zZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhLCBvcHRpb25zKSB7XG5cdFx0aWYgKGxhc3RVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblx0XHRcdG9wdGlvbnMucmVwbGFjZSA9IHRydWVcblx0XHR9XG5cdFx0bGFzdFVwZGF0ZSA9IG51bGxcblx0XHRyb3V0ZVNlcnZpY2Uuc2V0UGF0aChwYXRoLCBkYXRhLCBvcHRpb25zKVxuXHR9XG5cdHJvdXRlLmdldCA9IGZ1bmN0aW9uKCkge3JldHVybiBjdXJyZW50UGF0aH1cblx0cm91dGUucHJlZml4ID0gZnVuY3Rpb24ocHJlZml4MCkge3JvdXRlU2VydmljZS5wcmVmaXggPSBwcmVmaXgwfVxuXHRyb3V0ZS5saW5rID0gZnVuY3Rpb24odm5vZGUxKSB7XG5cdFx0dm5vZGUxLmRvbS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHJvdXRlU2VydmljZS5wcmVmaXggKyB2bm9kZTEuYXR0cnMuaHJlZilcblx0XHR2bm9kZTEuZG9tLm9uY2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDIpIHJldHVyblxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpXG5cdFx0XHRlLnJlZHJhdyA9IGZhbHNlXG5cdFx0XHR2YXIgaHJlZiA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKVxuXHRcdFx0aWYgKGhyZWYuaW5kZXhPZihyb3V0ZVNlcnZpY2UucHJlZml4KSA9PT0gMCkgaHJlZiA9IGhyZWYuc2xpY2Uocm91dGVTZXJ2aWNlLnByZWZpeC5sZW5ndGgpXG5cdFx0XHRyb3V0ZS5zZXQoaHJlZiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdHJvdXRlLnBhcmFtID0gZnVuY3Rpb24oa2V5Mykge1xuXHRcdGlmKHR5cGVvZiBhdHRyczMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGtleTMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBhdHRyczNba2V5M11cblx0XHRyZXR1cm4gYXR0cnMzXG5cdH1cblx0cmV0dXJuIHJvdXRlXG59XG5tLnJvdXRlID0gXzIwKHdpbmRvdywgcmVkcmF3U2VydmljZSlcbm0ud2l0aEF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSwgY2FsbGJhY2sxLCBjb250ZXh0KSB7XG5cdHJldHVybiBmdW5jdGlvbihlKSB7XG5cdFx0Y2FsbGJhY2sxLmNhbGwoY29udGV4dCB8fCB0aGlzLCBhdHRyTmFtZSBpbiBlLmN1cnJlbnRUYXJnZXQgPyBlLmN1cnJlbnRUYXJnZXRbYXR0ck5hbWVdIDogZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyTmFtZSkpXG5cdH1cbn1cbnZhciBfMjggPSBjb3JlUmVuZGVyZXIod2luZG93KVxubS5yZW5kZXIgPSBfMjgucmVuZGVyXG5tLnJlZHJhdyA9IHJlZHJhd1NlcnZpY2UucmVkcmF3XG5tLnJlcXVlc3QgPSByZXF1ZXN0U2VydmljZS5yZXF1ZXN0XG5tLmpzb25wID0gcmVxdWVzdFNlcnZpY2UuanNvbnBcbm0ucGFyc2VRdWVyeVN0cmluZyA9IHBhcnNlUXVlcnlTdHJpbmdcbm0uYnVpbGRRdWVyeVN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmdcbm0udmVyc2lvbiA9IFwiMS4xLjZcIlxubS52bm9kZSA9IFZub2RlXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IG1cbmVsc2Ugd2luZG93Lm0gPSBtXG59KCkpOyIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVuZGVyL3JlbmRlclwiKSh3aW5kb3cpXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgVm5vZGUgPSByZXF1aXJlKFwiLi4vcmVuZGVyL3Zub2RlXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXR0cnMsIGNoaWxkcmVuKSB7XG5cdHJldHVybiBWbm9kZShcIltcIiwgYXR0cnMua2V5LCBhdHRycywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxudmFyIHNlbGVjdG9yUGFyc2VyID0gLyg/OihefCN8XFwuKShbXiNcXC5cXFtcXF1dKykpfChcXFsoLis/KSg/Olxccyo9XFxzKihcInwnfCkoKD86XFxcXFtcIidcXF1dfC4pKj8pXFw1KT9cXF0pL2dcbnZhciBzZWxlY3RvckNhY2hlID0ge31cbnZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuXHRmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBpZiAoaGFzT3duLmNhbGwob2JqZWN0LCBrZXkpKSByZXR1cm4gZmFsc2Vcblx0cmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG5cdHZhciBtYXRjaCwgdGFnID0gXCJkaXZcIiwgY2xhc3NlcyA9IFtdLCBhdHRycyA9IHt9XG5cdHdoaWxlIChtYXRjaCA9IHNlbGVjdG9yUGFyc2VyLmV4ZWMoc2VsZWN0b3IpKSB7XG5cdFx0dmFyIHR5cGUgPSBtYXRjaFsxXSwgdmFsdWUgPSBtYXRjaFsyXVxuXHRcdGlmICh0eXBlID09PSBcIlwiICYmIHZhbHVlICE9PSBcIlwiKSB0YWcgPSB2YWx1ZVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwiI1wiKSBhdHRycy5pZCA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIuXCIpIGNsYXNzZXMucHVzaCh2YWx1ZSlcblx0XHRlbHNlIGlmIChtYXRjaFszXVswXSA9PT0gXCJbXCIpIHtcblx0XHRcdHZhciBhdHRyVmFsdWUgPSBtYXRjaFs2XVxuXHRcdFx0aWYgKGF0dHJWYWx1ZSkgYXR0clZhbHVlID0gYXR0clZhbHVlLnJlcGxhY2UoL1xcXFwoW1wiJ10pL2csIFwiJDFcIikucmVwbGFjZSgvXFxcXFxcXFwvZywgXCJcXFxcXCIpXG5cdFx0XHRpZiAobWF0Y2hbNF0gPT09IFwiY2xhc3NcIikgY2xhc3Nlcy5wdXNoKGF0dHJWYWx1ZSlcblx0XHRcdGVsc2UgYXR0cnNbbWF0Y2hbNF1dID0gYXR0clZhbHVlID09PSBcIlwiID8gYXR0clZhbHVlIDogYXR0clZhbHVlIHx8IHRydWVcblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzZXMubGVuZ3RoID4gMCkgYXR0cnMuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKVxuXHRyZXR1cm4gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gPSB7dGFnOiB0YWcsIGF0dHJzOiBhdHRyc31cbn1cblxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cblx0aWYgKCFpc0VtcHR5KHN0YXRlLmF0dHJzKSAmJiAhaXNFbXB0eShhdHRycykpIHtcblx0XHR2YXIgbmV3QXR0cnMgPSB7fVxuXG5cdFx0Zm9yKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSkge1xuXHRcdFx0XHRuZXdBdHRyc1trZXldID0gYXR0cnNba2V5XVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGF0dHJzID0gbmV3QXR0cnNcblx0fVxuXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblxuXHRpZiAoY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoYXR0cnMuY2xhc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0YXR0cnMuY2xhc3MgPSB1bmRlZmluZWRcblx0XHRcdGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuXHRcdH1cblxuXHRcdGlmIChzdGF0ZS5hdHRycy5jbGFzc05hbWUgIT0gbnVsbCkge1xuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gc3RhdGUuYXR0cnMuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWVcblx0XHR9XG5cdH1cblxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cblx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSAhPSBudWxsICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCIjXCIpIHtcblx0XHR0ZXh0ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0fSBlbHNlIHtcblx0XHRjaGlsZExpc3QgPSBjaGlsZHJlblxuXHR9XG5cblx0cmV0dXJuIFZub2RlKHN0YXRlLnRhZywgYXR0cnMua2V5LCBoYXNBdHRycyA/IGF0dHJzIDogdW5kZWZpbmVkLCBjaGlsZExpc3QsIHRleHQpXG59XG5cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cblx0aWYgKHNlbGVjdG9yID09IG51bGwgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxlY3Rvci52aWV3ICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR0aHJvdyBFcnJvcihcIlRoZSBzZWxlY3RvciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGNvbXBvbmVudC5cIik7XG5cdH1cblxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dmFyIGNhY2hlZCA9IHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdIHx8IGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcilcblx0fVxuXG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSBzdGFydCArIDEpIHtcblx0XHRjaGlsZHJlbiA9IGFyZ3VtZW50c1tzdGFydF1cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSBjaGlsZHJlbiA9IFtjaGlsZHJlbl1cblx0fSBlbHNlIHtcblx0XHRjaGlsZHJlbiA9IFtdXG5cdFx0d2hpbGUgKHN0YXJ0IDwgYXJndW1lbnRzLmxlbmd0aCkgY2hpbGRyZW4ucHVzaChhcmd1bWVudHNbc3RhcnQrK10pXG5cdH1cblxuXHR2YXIgbm9ybWFsaXplZCA9IFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKVxuXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwZXJzY3JpcHRcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciAkZG9jID0gJHdpbmRvdy5kb2N1bWVudFxuXHR2YXIgJGVtcHR5RnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXG5cdHZhciBuYW1lU3BhY2UgPSB7XG5cdFx0c3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG5cdFx0bWF0aDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCJcblx0fVxuXG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXG5cdGZ1bmN0aW9uIGdldE5hbWVTcGFjZSh2bm9kZSkge1xuXHRcdHJldHVybiB2bm9kZS5hdHRycyAmJiB2bm9kZS5hdHRycy54bWxucyB8fCBuYW1lU3BhY2Vbdm5vZGUudGFnXVxuXHR9XG5cblx0Ly9jcmVhdGVcblx0ZnVuY3Rpb24gY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAodHlwZW9mIHRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHN3aXRjaCAodGFnKSB7XG5cdFx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiPFwiOiByZXR1cm4gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIltcIjogcmV0dXJuIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGRlZmF1bHQ6IHJldHVybiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2bm9kZS5kb20gPSAkZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLmNoaWxkcmVuKVxuXHRcdGluc2VydE5vZGUocGFyZW50LCB2bm9kZS5kb20sIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2hbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXG5cdFx0dGVtcC5pbm5lckhUTUwgPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IHRlbXAuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSB0ZW1wLmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHR2YXIgY2hpbGRcblx0XHR3aGlsZSAoY2hpbGQgPSB0ZW1wLmZpcnN0Q2hpbGQpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXHRcdH1cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0Y3JlYXRlTm9kZXMoZnJhZ21lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gZnJhZ21lbnQuZmlyc3RDaGlsZFxuXHRcdHZub2RlLmRvbVNpemUgPSBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdHZhciBhdHRycyA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMgJiYgYXR0cnMuaXNcblxuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBucyA/XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpIDpcblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50KHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50KHRhZylcblx0XHR2bm9kZS5kb20gPSBlbGVtZW50XG5cblx0XHRpZiAoYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzLCBucylcblx0XHR9XG5cblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZWxlbWVudCwgbmV4dFNpYmxpbmcpXG5cblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXG5cdC8vdXBkYXRlXG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLCB2bm9kZXMsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGlmIChvbGQgPT09IHZub2RlcyB8fCBvbGQgPT0gbnVsbCAmJiB2bm9kZXMgPT0gbnVsbCkgcmV0dXJuXG5cdFx0ZWxzZSBpZiAob2xkID09IG51bGwpIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCAwLCB2bm9kZXMubGVuZ3RoLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cblx0XHRcdHZhciBvbGRTdGFydCA9IDAsIHN0YXJ0ID0gMCwgb2xkRW5kID0gb2xkLmxlbmd0aCAtIDEsIGVuZCA9IHZub2Rlcy5sZW5ndGggLSAxLCBtYXBcblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZFN0YXJ0XSwgdiA9IHZub2Rlc1tzdGFydF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZFN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRTdGFydCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0b2xkU3RhcnQrKywgc3RhcnQrK1xuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF1cblx0XHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0XHRpZiAocmVjeWNsaW5nIHx8IHN0YXJ0IDwgZW5kKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRTdGFydCwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0b2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdLCB2ID0gdm5vZGVzW2VuZF1cblx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkRW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nICYmIG8udGFnID09PSB2LnRhZykgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGlmIChvLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG8uZG9tXG5cdFx0XHRcdFx0b2xkRW5kLS0sIGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCFtYXApIG1hcCA9IGdldEtleU1hcChvbGQsIG9sZEVuZClcblx0XHRcdFx0XHRpZiAodiAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHR2YXIgb2xkSW5kZXggPSBtYXBbdi5rZXldXG5cdFx0XHRcdFx0XHRpZiAob2xkSW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbW92YWJsZSA9IG9sZFtvbGRJbmRleF1cblx0XHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEluZGV4ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG1vdmFibGUsIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobW92YWJsZSksIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRvbGRbb2xkSW5kZXhdLnNraXAgPSB0cnVlXG5cdFx0XHRcdFx0XHRcdGlmIChtb3ZhYmxlLmRvbSAhPSBudWxsKSBuZXh0U2libGluZyA9IG1vdmFibGUuZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRvbSA9IGNyZWF0ZU5vZGUocGFyZW50LCB2LCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0XHRuZXh0U2libGluZyA9IGRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbmQgPCBzdGFydCkgYnJlYWtcblx0XHRcdH1cblx0XHRcdGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kICsgMSwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRcdHJlbW92ZU5vZGVzKG9sZCwgb2xkU3RhcnQsIG9sZEVuZCArIDEsIHZub2Rlcylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTm9kZShwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdHZhciBvbGRUYWcgPSBvbGQudGFnLCB0YWcgPSB2bm9kZS50YWdcblx0XHRpZiAob2xkVGFnID09PSB0YWcpIHtcblx0XHRcdHZub2RlLnN0YXRlID0gb2xkLnN0YXRlXG5cdFx0XHR2bm9kZS5fc3RhdGUgPSBvbGQuX3N0YXRlXG5cdFx0XHR2bm9kZS5ldmVudHMgPSBvbGQuZXZlbnRzXG5cdFx0XHRpZiAoIXJlY3ljbGluZyAmJiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkpIHJldHVyblxuXHRcdFx0aWYgKHR5cGVvZiBvbGRUYWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRcdFx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRcdH1cblx0XHRcdFx0c3dpdGNoIChvbGRUYWcpIHtcblx0XHRcdFx0XHRjYXNlIFwiI1wiOiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCI8XCI6IHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBuZXh0U2libGluZyk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIltcIjogdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpOyBicmVha1xuXHRcdFx0XHRcdGRlZmF1bHQ6IHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLCBudWxsKVxuXHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVUZXh0KG9sZCwgdm5vZGUpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuLnRvU3RyaW5nKCkgIT09IHZub2RlLmNoaWxkcmVuLnRvU3RyaW5nKCkpIHtcblx0XHRcdG9sZC5kb20ubm9kZVZhbHVlID0gdm5vZGUuY2hpbGRyZW5cblx0XHR9XG5cdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUhUTUwocGFyZW50LCBvbGQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4gIT09IHZub2RlLmNoaWxkcmVuKSB7XG5cdFx0XHR0b0ZyYWdtZW50KG9sZClcblx0XHRcdGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHRcdGVsc2Ugdm5vZGUuZG9tID0gb2xkLmRvbSwgdm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocGFyZW50LCBvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHR1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHR2YXIgZG9tU2l6ZSA9IDAsIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSBudWxsXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuZG9tICE9IG51bGwpIHtcblx0XHRcdFx0XHRpZiAodm5vZGUuZG9tID09IG51bGwpIHZub2RlLmRvbSA9IGNoaWxkLmRvbVxuXHRcdFx0XHRcdGRvbVNpemUgKz0gY2hpbGQuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkb21TaXplICE9PSAxKSB2bm9kZS5kb21TaXplID0gZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZSBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkgPSB2bm9kZS5rZXlcblx0XHRcdFx0aWYgKGtleSAhPSBudWxsKSBtYXBba2V5XSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQgPSB2bm9kZS5kb21TaXplXG5cdFx0aWYgKGNvdW50ICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQpIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0ZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGRvbSwgZnJhZ21lbnQuZmlyc3RDaGlsZClcblx0XHRcdH1cblx0XHRcdHJldHVybiBmcmFnbWVudFxuXHRcdH1cblx0XHRlbHNlIHJldHVybiB2bm9kZS5kb21cblx0fVxuXHRmdW5jdGlvbiBnZXROZXh0U2libGluZyh2bm9kZXMsIGksIG5leHRTaWJsaW5nKSB7XG5cdFx0Zm9yICg7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiB2bm9kZXNbaV0uZG9tICE9IG51bGwpIHJldHVybiB2bm9kZXNbaV0uZG9tXG5cdFx0fVxuXHRcdHJldHVybiBuZXh0U2libGluZ1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblxuXHQvL3JlbW92ZVxuXHRmdW5jdGlvbiByZW1vdmVOb2Rlcyh2bm9kZXMsIHN0YXJ0LCBlbmQsIGNvbnRleHQpIHtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUuc2tpcCkgdm5vZGUuc2tpcCA9IGZhbHNlXG5cdFx0XHRcdGVsc2UgcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dClcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZSh2bm9kZSwgY29udGV4dCkge1xuXHRcdHZhciBleHBlY3RlZCA9IDEsIGNhbGxlZCA9IDBcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGludWF0aW9uKClcblx0XHRmdW5jdGlvbiBjb250aW51YXRpb24oKSB7XG5cdFx0XHRpZiAoKytjYWxsZWQgPT09IGV4cGVjdGVkKSB7XG5cdFx0XHRcdG9ucmVtb3ZlKHZub2RlKVxuXHRcdFx0XHRpZiAodm5vZGUuZG9tKSB7XG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQpIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00oZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTSh2bm9kZS5kb20pXG5cdFx0XHRcdFx0aWYgKGNvbnRleHQgIT0gbnVsbCAmJiB2bm9kZS5kb21TaXplID09IG51bGwgJiYgIWhhc0ludGVncmF0aW9uTWV0aG9kcyh2bm9kZS5hdHRycykgJiYgdHlwZW9mIHZub2RlLnRhZyA9PT0gXCJzdHJpbmdcIikgeyAvL1RPRE8gdGVzdCBjdXN0b20gZWxlbWVudHNcblx0XHRcdFx0XHRcdGlmICghY29udGV4dC5wb29sKSBjb250ZXh0LnBvb2wgPSBbdm5vZGVdXG5cdFx0XHRcdFx0XHRlbHNlIGNvbnRleHQucG9vbC5wdXNoKHZub2RlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlRnJvbURPTShub2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZVxuXHRcdGlmIChwYXJlbnQgIT0gbnVsbCkgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpXG5cdH1cblx0ZnVuY3Rpb24gb25yZW1vdmUodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuYXR0cnMgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLmF0dHJzLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpZiAodHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkgb25yZW1vdmUodm5vZGUuaW5zdGFuY2UpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0aWYgKGNoaWxkICE9IG51bGwpIG9ucmVtb3ZlKGNoaWxkKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly9hdHRyc1xuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMsIG5zKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXksIG51bGwsIGF0dHJzW2tleV0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXksIG9sZCwgdmFsdWUsIG5zKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHRpZiAoa2V5ID09PSBcImtleVwiIHx8IGtleSA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleSkpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNMaWZlY3ljbGVNZXRob2Qoa2V5KSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5LmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5LnN1YnN0cigwLCBuc0xhc3RJbmRleCkgPT09IFwieGxpbmtcIikge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwga2V5LnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXlbMF0gPT09IFwib1wiICYmIGtleVsxXSA9PT0gXCJuXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXksIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleSBpbiBlbGVtZW50ICYmICFpc0F0dHJpYnV0ZShrZXkpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkgPT09IFwidmFsdWVcIikge1xuXHRcdFx0XHR2YXIgbm9ybWFsaXplZCA9IFwiXCIgKyB2YWx1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG5cdFx0XHRcdC8vc2V0dGluZyBpbnB1dFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSBieSB0eXBpbmcgb24gZm9jdXNlZCBlbGVtZW50IG1vdmVzIGN1cnNvciB0byBlbmQgaW4gQ2hyb21lXG5cdFx0XHRcdGlmICgodm5vZGUudGFnID09PSBcImlucHV0XCIgfHwgdm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vc2V0dGluZyBvcHRpb25bdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYgb2xkICE9IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkKSByZXR1cm5cblx0XHRcdH1cblx0XHRcdC8vIElmIHlvdSBhc3NpZ24gYW4gaW5wdXQgdHlwZSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5ID09PSBcInR5cGVcIikge1xuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5XSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG5cdFx0XHRcdGVsc2UgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXksIHZhbHVlKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRMYXRlQXR0cnModm5vZGUpIHtcblx0XHR2YXIgYXR0cnMgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRycykgc2V0QXR0cih2bm9kZSwgXCJ2YWx1ZVwiLCBudWxsLCBhdHRycy52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMuc2VsZWN0ZWRJbmRleCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyh2bm9kZSwgb2xkLCBhdHRycywgbnMpIHtcblx0XHRpZiAoYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleSwgb2xkICYmIG9sZFtrZXldLCBhdHRyc1trZXldLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb2xkKSB7XG5cdFx0XHRcdGlmIChhdHRycyA9PSBudWxsIHx8ICEoa2V5IGluIGF0dHJzKSkge1xuXHRcdFx0XHRcdGlmIChrZXkgPT09IFwiY2xhc3NOYW1lXCIpIGtleSA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXlbMF0gPT09IFwib1wiICYmIGtleVsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleSkpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXksIHVuZGVmaW5lZClcblx0XHRcdFx0XHRlbHNlIGlmIChrZXkgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXG5cdC8vc3R5bGVcblx0ZnVuY3Rpb24gdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCBzdHlsZSkge1xuXHRcdGlmIChvbGQgPT09IHN0eWxlKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiLCBvbGQgPSBudWxsXG5cdFx0aWYgKHN0eWxlID09IG51bGwpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRlbHNlIGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZCA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5XSA9IHN0eWxlW2tleV1cblx0XHRcdH1cblx0XHRcdGlmIChvbGQgIT0gbnVsbCAmJiB0eXBlb2Ygb2xkICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleV0gPSBcIlwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXksIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkgaW4gZWxlbWVudCkgZWxlbWVudFtrZXldID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5XSA9PT0gY2FsbGJhY2spIHJldHVyblxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXldICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXldLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5XSA9IGNhbGxiYWNrXG5cdFx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXldLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXIoZG9tLCB2bm9kZXMpIHtcblx0XHRpZiAoIWRvbSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCBiZWluZyBwYXNzZWQgdG8gbS5yb3V0ZS9tLm1vdW50L20ucmVuZGVyIGlzIG5vdCB1bmRlZmluZWQuXCIpXG5cdFx0dmFyIGhvb2tzID0gW11cblx0XHR2YXIgYWN0aXZlID0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGRvbS5uYW1lc3BhY2VVUklcblxuXHRcdC8vIEZpcnN0IHRpbWUgcmVuZGVyaW5nIGludG8gYSBub2RlIGNsZWFycyBpdCBvdXRcblx0XHRpZiAoZG9tLnZub2RlcyA9PSBudWxsKSBkb20udGV4dENvbnRlbnQgPSBcIlwiXG5cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodm5vZGVzKSkgdm5vZGVzID0gW3Zub2Rlc11cblx0XHR1cGRhdGVOb2Rlcyhkb20sIGRvbS52bm9kZXMsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlcyksIGZhbHNlLCBob29rcywgbnVsbCwgbmFtZXNwYWNlID09PSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZSlcblx0XHRkb20udm5vZGVzID0gdm5vZGVzXG5cdFx0Ly8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gcmV0dXJuIG51bGwgaW4gSUUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2FjdGl2ZUVsZW1lbnRcblx0XHRpZiAoYWN0aXZlICE9IG51bGwgJiYgJGRvYy5hY3RpdmVFbGVtZW50ICE9PSBhY3RpdmUpIGFjdGl2ZS5mb2N1cygpXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykgaG9va3NbaV0oKVxuXHR9XG5cblx0cmV0dXJuIHtyZW5kZXI6IHJlbmRlciwgc2V0RXZlbnRDYWxsYmFjazogc2V0RXZlbnRDYWxsYmFja31cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihodG1sKSB7XG5cdGlmIChodG1sID09IG51bGwpIGh0bWwgPSBcIlwiXG5cdHJldHVybiBWbm9kZShcIjxcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGh0bWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gVm5vZGUodGFnLCBrZXksIGF0dHJzLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGV4dDogdGV4dCwgZG9tOiBkb20sIGRvbVNpemU6IHVuZGVmaW5lZCwgc3RhdGU6IHVuZGVmaW5lZCwgX3N0YXRlOiB1bmRlZmluZWQsIGV2ZW50czogdW5kZWZpbmVkLCBpbnN0YW5jZTogdW5kZWZpbmVkLCBza2lwOiBmYWxzZX1cbn1cblZub2RlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHJldHVybiBWbm9kZShcIltcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKG5vZGUpLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0aWYgKG5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIFZub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbm9kZSA9PT0gZmFsc2UgPyBcIlwiIDogbm9kZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdHJldHVybiBub2RlXG59XG5Wbm9kZS5ub3JtYWxpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZHJlbltpXSA9IFZub2RlLm5vcm1hbGl6ZShjaGlsZHJlbltpXSlcblx0fVxuXHRyZXR1cm4gY2hpbGRyZW5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWbm9kZVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zdHJlYW0vc3RyZWFtXCIpXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBndWlkID0gMCwgSEFMVCA9IHt9XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW0oKSB7XG5cdGZ1bmN0aW9uIHN0cmVhbSgpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSBIQUxUKSB1cGRhdGVTdHJlYW0oc3RyZWFtLCBhcmd1bWVudHNbMF0pXG5cdFx0cmV0dXJuIHN0cmVhbS5fc3RhdGUudmFsdWVcblx0fVxuXHRpbml0U3RyZWFtKHN0cmVhbSlcblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSBIQUxUKSB1cGRhdGVTdHJlYW0oc3RyZWFtLCBhcmd1bWVudHNbMF0pXG5cblx0cmV0dXJuIHN0cmVhbVxufVxuZnVuY3Rpb24gaW5pdFN0cmVhbShzdHJlYW0pIHtcblx0c3RyZWFtLmNvbnN0cnVjdG9yID0gY3JlYXRlU3RyZWFtXG5cdHN0cmVhbS5fc3RhdGUgPSB7aWQ6IGd1aWQrKywgdmFsdWU6IHVuZGVmaW5lZCwgc3RhdGU6IDAsIGRlcml2ZTogdW5kZWZpbmVkLCByZWNvdmVyOiB1bmRlZmluZWQsIGRlcHM6IHt9LCBwYXJlbnRzOiBbXSwgZW5kU3RyZWFtOiB1bmRlZmluZWQsIHVucmVnaXN0ZXI6IHVuZGVmaW5lZH1cblx0c3RyZWFtLm1hcCA9IHN0cmVhbVtcImZhbnRhc3ktbGFuZC9tYXBcIl0gPSBtYXAsIHN0cmVhbVtcImZhbnRhc3ktbGFuZC9hcFwiXSA9IGFwLCBzdHJlYW1bXCJmYW50YXN5LWxhbmQvb2ZcIl0gPSBjcmVhdGVTdHJlYW1cblx0c3RyZWFtLnZhbHVlT2YgPSB2YWx1ZU9mLCBzdHJlYW0udG9KU09OID0gdG9KU09OLCBzdHJlYW0udG9TdHJpbmcgPSB2YWx1ZU9mXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyZWFtLCB7XG5cdFx0ZW5kOiB7Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghc3RyZWFtLl9zdGF0ZS5lbmRTdHJlYW0pIHtcblx0XHRcdFx0dmFyIGVuZFN0cmVhbSA9IGNyZWF0ZVN0cmVhbSgpXG5cdFx0XHRcdGVuZFN0cmVhbS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdHVucmVnaXN0ZXJTdHJlYW0oc3RyZWFtKVxuXHRcdFx0XHRcdFx0ZW5kU3RyZWFtLl9zdGF0ZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24oKXt1bnJlZ2lzdGVyU3RyZWFtKGVuZFN0cmVhbSl9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRzdHJlYW0uX3N0YXRlLmVuZFN0cmVhbSA9IGVuZFN0cmVhbVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cmVhbS5fc3RhdGUuZW5kU3RyZWFtXG5cdFx0fX1cblx0fSlcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0cmVhbShzdHJlYW0sIHZhbHVlKSB7XG5cdHVwZGF0ZVN0YXRlKHN0cmVhbSwgdmFsdWUpXG5cdGZvciAodmFyIGlkIGluIHN0cmVhbS5fc3RhdGUuZGVwcykgdXBkYXRlRGVwZW5kZW5jeShzdHJlYW0uX3N0YXRlLmRlcHNbaWRdLCBmYWxzZSlcblx0aWYgKHN0cmVhbS5fc3RhdGUudW5yZWdpc3RlciAhPSBudWxsKSBzdHJlYW0uX3N0YXRlLnVucmVnaXN0ZXIoKVxuXHRmaW5hbGl6ZShzdHJlYW0pXG59XG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShzdHJlYW0sIHZhbHVlKSB7XG5cdHN0cmVhbS5fc3RhdGUudmFsdWUgPSB2YWx1ZVxuXHRzdHJlYW0uX3N0YXRlLmNoYW5nZWQgPSB0cnVlXG5cdGlmIChzdHJlYW0uX3N0YXRlLnN0YXRlICE9PSAyKSBzdHJlYW0uX3N0YXRlLnN0YXRlID0gMVxufVxuZnVuY3Rpb24gdXBkYXRlRGVwZW5kZW5jeShzdHJlYW0sIG11c3RTeW5jKSB7XG5cdHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGUsIHBhcmVudHMgPSBzdGF0ZS5wYXJlbnRzXG5cdGlmIChwYXJlbnRzLmxlbmd0aCA+IDAgJiYgcGFyZW50cy5ldmVyeShhY3RpdmUpICYmIChtdXN0U3luYyB8fCBwYXJlbnRzLnNvbWUoY2hhbmdlZCkpKSB7XG5cdFx0dmFyIHZhbHVlID0gc3RyZWFtLl9zdGF0ZS5kZXJpdmUoKVxuXHRcdGlmICh2YWx1ZSA9PT0gSEFMVCkgcmV0dXJuIGZhbHNlXG5cdFx0dXBkYXRlU3RhdGUoc3RyZWFtLCB2YWx1ZSlcblx0fVxufVxuZnVuY3Rpb24gZmluYWxpemUoc3RyZWFtKSB7XG5cdHN0cmVhbS5fc3RhdGUuY2hhbmdlZCA9IGZhbHNlXG5cdGZvciAodmFyIGlkIGluIHN0cmVhbS5fc3RhdGUuZGVwcykgc3RyZWFtLl9zdGF0ZS5kZXBzW2lkXS5fc3RhdGUuY2hhbmdlZCA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbWJpbmUoZm4sIHN0cmVhbXMpIHtcblx0aWYgKCFzdHJlYW1zLmV2ZXJ5KHZhbGlkKSkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoYXQgZWFjaCBpdGVtIHBhc3NlZCB0byBzdHJlYW0uY29tYmluZS9zdHJlYW0ubWVyZ2UgaXMgYSBzdHJlYW1cIilcblx0cmV0dXJuIGluaXREZXBlbmRlbmN5KGNyZWF0ZVN0cmVhbSgpLCBzdHJlYW1zLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgc3RyZWFtcy5jb25jYXQoW3N0cmVhbXMuZmlsdGVyKGNoYW5nZWQpXSkpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGluaXREZXBlbmRlbmN5KGRlcCwgc3RyZWFtcywgZGVyaXZlKSB7XG5cdHZhciBzdGF0ZSA9IGRlcC5fc3RhdGVcblx0c3RhdGUuZGVyaXZlID0gZGVyaXZlXG5cdHN0YXRlLnBhcmVudHMgPSBzdHJlYW1zLmZpbHRlcihub3RFbmRlZClcblxuXHRyZWdpc3RlckRlcGVuZGVuY3koZGVwLCBzdGF0ZS5wYXJlbnRzKVxuXHR1cGRhdGVEZXBlbmRlbmN5KGRlcCwgdHJ1ZSlcblxuXHRyZXR1cm4gZGVwXG59XG5mdW5jdGlvbiByZWdpc3RlckRlcGVuZGVuY3koc3RyZWFtLCBwYXJlbnRzKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHBhcmVudHNbaV0uX3N0YXRlLmRlcHNbc3RyZWFtLl9zdGF0ZS5pZF0gPSBzdHJlYW1cblx0XHRyZWdpc3RlckRlcGVuZGVuY3koc3RyZWFtLCBwYXJlbnRzW2ldLl9zdGF0ZS5wYXJlbnRzKVxuXHR9XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyU3RyZWFtKHN0cmVhbSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0cmVhbS5fc3RhdGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBwYXJlbnQgPSBzdHJlYW0uX3N0YXRlLnBhcmVudHNbaV1cblx0XHRkZWxldGUgcGFyZW50Ll9zdGF0ZS5kZXBzW3N0cmVhbS5fc3RhdGUuaWRdXG5cdH1cblx0Zm9yICh2YXIgaWQgaW4gc3RyZWFtLl9zdGF0ZS5kZXBzKSB7XG5cdFx0dmFyIGRlcGVuZGVudCA9IHN0cmVhbS5fc3RhdGUuZGVwc1tpZF1cblx0XHR2YXIgaW5kZXggPSBkZXBlbmRlbnQuX3N0YXRlLnBhcmVudHMuaW5kZXhPZihzdHJlYW0pXG5cdFx0aWYgKGluZGV4ID4gLTEpIGRlcGVuZGVudC5fc3RhdGUucGFyZW50cy5zcGxpY2UoaW5kZXgsIDEpXG5cdH1cblx0c3RyZWFtLl9zdGF0ZS5zdGF0ZSA9IDIgLy9lbmRlZFxuXHRzdHJlYW0uX3N0YXRlLmRlcHMgPSB7fVxufVxuXG5mdW5jdGlvbiBtYXAoZm4pIHtyZXR1cm4gY29tYmluZShmdW5jdGlvbihzdHJlYW0pIHtyZXR1cm4gZm4oc3RyZWFtKCkpfSwgW3RoaXNdKX1cbmZ1bmN0aW9uIGFwKHN0cmVhbSkge3JldHVybiBjb21iaW5lKGZ1bmN0aW9uKHMxLCBzMikge3JldHVybiBzMSgpKHMyKCkpfSwgW3N0cmVhbSwgdGhpc10pfVxuZnVuY3Rpb24gdmFsdWVPZigpIHtyZXR1cm4gdGhpcy5fc3RhdGUudmFsdWV9XG5mdW5jdGlvbiB0b0pTT04oKSB7cmV0dXJuIHRoaXMuX3N0YXRlLnZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHRoaXMuX3N0YXRlLnZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fc3RhdGUudmFsdWUudG9KU09OKCkgOiB0aGlzLl9zdGF0ZS52YWx1ZX1cblxuZnVuY3Rpb24gdmFsaWQoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUgfVxuZnVuY3Rpb24gYWN0aXZlKHN0cmVhbSkge3JldHVybiBzdHJlYW0uX3N0YXRlLnN0YXRlID09PSAxfVxuZnVuY3Rpb24gY2hhbmdlZChzdHJlYW0pIHtyZXR1cm4gc3RyZWFtLl9zdGF0ZS5jaGFuZ2VkfVxuZnVuY3Rpb24gbm90RW5kZWQoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUuc3RhdGUgIT09IDJ9XG5cbmZ1bmN0aW9uIG1lcmdlKHN0cmVhbXMpIHtcblx0cmV0dXJuIGNvbWJpbmUoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHN0cmVhbXMubWFwKGZ1bmN0aW9uKHMpIHtyZXR1cm4gcygpfSlcblx0fSwgc3RyZWFtcylcbn1cblxuZnVuY3Rpb24gc2NhbihyZWR1Y2VyLCBzZWVkLCBzdHJlYW0pIHtcblx0dmFyIG5ld1N0cmVhbSA9IGNvbWJpbmUoZnVuY3Rpb24gKHMpIHtcblx0XHRyZXR1cm4gc2VlZCA9IHJlZHVjZXIoc2VlZCwgcy5fc3RhdGUudmFsdWUpXG5cdH0sIFtzdHJlYW1dKVxuXG5cdGlmIChuZXdTdHJlYW0uX3N0YXRlLnN0YXRlID09PSAwKSBuZXdTdHJlYW0oc2VlZClcblxuXHRyZXR1cm4gbmV3U3RyZWFtXG59XG5cbmZ1bmN0aW9uIHNjYW5NZXJnZSh0dXBsZXMsIHNlZWQpIHtcblx0dmFyIHN0cmVhbXMgPSB0dXBsZXMubWFwKGZ1bmN0aW9uKHR1cGxlKSB7XG5cdFx0dmFyIHN0cmVhbSA9IHR1cGxlWzBdXG5cdFx0aWYgKHN0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDApIHN0cmVhbSh1bmRlZmluZWQpXG5cdFx0cmV0dXJuIHN0cmVhbVxuXHR9KVxuXG5cdHZhciBuZXdTdHJlYW0gPSBjb21iaW5lKGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGFuZ2VkID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuXG5cdFx0c3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbSwgaWR4KSB7XG5cdFx0XHRpZiAoY2hhbmdlZC5pbmRleE9mKHN0cmVhbSkgPiAtMSkge1xuXHRcdFx0XHRzZWVkID0gdHVwbGVzW2lkeF1bMV0oc2VlZCwgc3RyZWFtLl9zdGF0ZS52YWx1ZSlcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0cmV0dXJuIHNlZWRcblx0fSwgc3RyZWFtcylcblxuXHRyZXR1cm4gbmV3U3RyZWFtXG59XG5cbmNyZWF0ZVN0cmVhbVtcImZhbnRhc3ktbGFuZC9vZlwiXSA9IGNyZWF0ZVN0cmVhbVxuY3JlYXRlU3RyZWFtLm1lcmdlID0gbWVyZ2VcbmNyZWF0ZVN0cmVhbS5jb21iaW5lID0gY29tYmluZVxuY3JlYXRlU3RyZWFtLnNjYW4gPSBzY2FuXG5jcmVhdGVTdHJlYW0uc2Nhbk1lcmdlID0gc2Nhbk1lcmdlXG5jcmVhdGVTdHJlYW0uSEFMVCA9IEhBTFRcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBjcmVhdGVTdHJlYW1cbmVsc2UgaWYgKHR5cGVvZiB3aW5kb3cubSA9PT0gXCJmdW5jdGlvblwiICYmICEoXCJzdHJlYW1cIiBpbiB3aW5kb3cubSkpIHdpbmRvdy5tLnN0cmVhbSA9IGNyZWF0ZVN0cmVhbVxuZWxzZSB3aW5kb3cubSA9IHtzdHJlYW0gOiBjcmVhdGVTdHJlYW19XG5cbn0oKSk7XG4iLCIvLyEgbW9tZW50LmpzXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICAgICAgbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBhcmdzWzBdID0geSArIDQwMDtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMgKHdzLCBuKSB7XG4gICAgICAgIHJldHVybiB3cy5zbGljZShuLCA3KS5jb25jYXQod3Muc2xpY2UoMCwgbikpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWyhtICYmIG0gIT09IHRydWUgJiYgdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpKSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgcmV0dXJuIChtID09PSB0cnVlKSA/IHNoaWZ0V2Vla2RheXMod2Vla2RheXMsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB3ZWVrZGF5c1ttLmRheSgpXSA6IHdlZWtkYXlzO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAvL3dhcm4gdXNlciBpZiBhcmd1bWVudHMgYXJlIHBhc3NlZCBidXQgdGhlIGxvY2FsZSBjb3VsZCBub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTG9jYWxlICcgKyBrZXkgKyAgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShjb25maWcucGFyZW50TG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCB0bXBMb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIGV4cGVjdGVkV2Vla2RheSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVEMgPyBjb25maWcuX2QuZ2V0VVRDRGF5KCkgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5KSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgdmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG9ic09mZnNldHMgPSB7XG4gICAgICAgIFVUOiAwLFxuICAgICAgICBHTVQ6IDAsXG4gICAgICAgIEVEVDogLTQgKiA2MCxcbiAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgIENTVDogLTYgKiA2MCxcbiAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgIFBEVDogLTcgKiA2MCxcbiAgICAgICAgUFNUOiAtOCAqIDYwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIobG9jYWxGcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKGxvY2FsVG8sIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzOyBicmVhazsgLy8gMTAwMFxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6IG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZTtcbiAgICAgICAgdmFyIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgICAgICB2YXIgem9uZSA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICAgICAgdmFyIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIE1TX1BFUl9TRUNPTkQgPSAxMDAwO1xuICAgIHZhciBNU19QRVJfTUlOVVRFID0gNjAgKiBNU19QRVJfU0VDT05EO1xuICAgIHZhciBNU19QRVJfSE9VUiA9IDYwICogTVNfUEVSX01JTlVURTtcbiAgICB2YXIgTVNfUEVSXzQwMF9ZRUFSUyA9ICgzNjUgKiA0MDAgKyA5NykgKiAyNCAqIE1TX1BFUl9IT1VSO1xuXG4gICAgLy8gYWN0dWFsIG1vZHVsbyAtIGhhbmRsZXMgbmVnYXRpdmUgbnVtYmVycyAoZm9yIGRhdGVzIGJlZm9yZSAxOTcwKTpcbiAgICBmdW5jdGlvbiBtb2QkMShkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gKGRpdmlkZW5kICUgZGl2aXNvciArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSAtIHRoaXMubW9udGgoKSAlIDMsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksIE1TX1BFUl9IT1VSKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB2YXIgdGltZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCkgKyAxLCAwLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSAtIHRoaXMubW9udGgoKSAlIDMgKyAzLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDcpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9IT1VSIC0gbW9kJDEodGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksIE1TX1BFUl9IT1VSKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9NSU5VVEUgLSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9TRUNPTkQgLSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICBwcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xuICAgIHByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBwcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBwcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuICAgIHByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOiAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOiAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNRdWFydGVycyAgICAgPSBtYWtlQXMoJ1EnKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGNsb25lJDEgKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgICAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcbiAgICAgICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IHltU2lnbiArIE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBobXNTaWduICsgaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xuICAgIHByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBwcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIHByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgcHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIHByb3RvJDIuYXNRdWFydGVycyAgICAgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG4gICAgcHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lICAgICAgICAgID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG4gICAgcHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBwcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgcHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI0LjAnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuICAgIGhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICBob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgIGhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcbiAgICBob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIGhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuICAgIGhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xuICAgIGhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuICAgIGhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgICAgIFRJTUU6ICdISDptbScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMiBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL3Jhdy9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIFdpdGggcGFydHMgYnkgVHlsZXIgQ2xvc2VcbiAqIENvcHlyaWdodCAyMDA3LTIwMDkgVHlsZXIgQ2xvc2UgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgWCBsaWNlbnNlIGZvdW5kXG4gKiBhdCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLmh0bWxcbiAqIEZvcmtlZCBhdCByZWZfc2VuZC5qcyB2ZXJzaW9uOiAyMDA5LTA1LTExXG4gKlxuICogV2l0aCBwYXJ0cyBieSBNYXJrIE1pbGxlclxuICogQ29weXJpZ2h0IChDKSAyMDExIEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbihmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gVGhpcyBmaWxlIHdpbGwgZnVuY3Rpb24gcHJvcGVybHkgYXMgYSA8c2NyaXB0PiB0YWcsIG9yIGEgbW9kdWxlXG4gICAgLy8gdXNpbmcgQ29tbW9uSlMgYW5kIE5vZGVKUyBvciBSZXF1aXJlSlMgbW9kdWxlIGZvcm1hdHMuICBJblxuICAgIC8vIENvbW1vbi9Ob2RlL1JlcXVpcmVKUywgdGhlIG1vZHVsZSBleHBvcnRzIHRoZSBRIEFQSSBhbmQgd2hlblxuICAgIC8vIGV4ZWN1dGVkIGFzIGEgc2ltcGxlIDxzY3JpcHQ+LCBpdCBjcmVhdGVzIGEgUSBnbG9iYWwgaW5zdGVhZC5cblxuICAgIC8vIE1vbnRhZ2UgUmVxdWlyZVxuICAgIGlmICh0eXBlb2YgYm9vdHN0cmFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgYm9vdHN0cmFwKFwicHJvbWlzZVwiLCBkZWZpbml0aW9uKTtcblxuICAgIC8vIENvbW1vbkpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2VsZi5RID0gZGVmaW5pdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCB3YXMgbm90IGFudGljaWFwdGVkIGJ5IFEuIFBsZWFzZSBmaWxlIGEgYnVnLlwiKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB2YXIgdGFzayA9IGhlYWQudGFzaztcbiAgICAgICAgICAgIGhlYWQudGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBzeW5jaHJvbm91c2x5IHRvIGludGVycnVwdCBmbHVzaGluZyFcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgaW4gbmV4dCBldmVudCB0byBhdm9pZCB0aWNrIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBuZXh0VGljayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHRhaWwgPSB0YWlsLm5leHQgPSB7XG4gICAgICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICAgICAgZG9tYWluOiBpc05vZGVKUyAmJiBwcm9jZXNzLmRvbWFpbixcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICAgIC8vIE5vZGUuanMgYmVmb3JlIDAuOS4gTm90ZSB0aGF0IHNvbWUgZmFrZS1Ob2RlIGVudmlyb25tZW50cywgbGlrZSB0aGVcbiAgICAgICAgLy8gTW9jaGEgdGVzdCBydW5uZXIsIGludHJvZHVjZSBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2AuXG4gICAgICAgIGlzTm9kZUpTID0gdHJ1ZTtcblxuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gSW4gSUUxMCwgTm9kZS5qcyAwLjkrLCBvciBodHRwczovL2dpdGh1Yi5jb20vTm9ibGVKUy9zZXRJbW1lZGlhdGVcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gc2V0SW1tZWRpYXRlLmJpbmQod2luZG93LCBmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIC8vIEF0IGxlYXN0IFNhZmFyaSBWZXJzaW9uIDYuMC41ICg4NTM2LjMwLjEpIGludGVybWl0dGVudGx5IGNhbm5vdCBjcmVhdGVcbiAgICAgICAgLy8gd29ya2luZyBtZXNzYWdlIHBvcnRzIHRoZSBmaXJzdCB0aW1lIGEgcGFnZSBsb2Fkcy5cbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHJlcXVlc3RQb3J0VGljaztcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdFBvcnRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT3BlcmEgcmVxdWlyZXMgdXMgdG8gcHJvdmlkZSBhIG1lc3NhZ2UgcGF5bG9hZCwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSB1c2UgaXQuXG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgcmVxdWVzdFBvcnRUaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGQgYnJvd3NlcnNcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFRpY2s7XG59KSgpO1xuXG4vLyBBdHRlbXB0IHRvIG1ha2UgZ2VuZXJpY3Mgc2FmZSBpbiB0aGUgZmFjZSBvZiBkb3duc3RyZWFtXG4vLyBtb2RpZmljYXRpb25zLlxuLy8gVGhlcmUgaXMgbm8gc2l0dWF0aW9uIHdoZXJlIHRoaXMgaXMgbmVjZXNzYXJ5LlxuLy8gSWYgeW91IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsIHRoZXNlIHByaW1vcmRpYWxzIG5lZWQgdG8gYmVcbi8vIGRlZXBseSBmcm96ZW4gYW55d2F5LCBhbmQgaWYgeW91IGRvbuKAmXQgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSxcbi8vIHRoaXMgaXMganVzdCBwbGFpbiBwYXJhbm9pZC5cbi8vIEhvd2V2ZXIsIHRoaXMgKiptaWdodCoqIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemUgb2Zcbi8vIHRoZSBtaW5pZmllZCBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KClcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIGxvbmcgc3RhY2sgdHJhY2VzXG5cbnZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIjtcblxuZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUVxuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYHByb21pc2VgLiBTZWUgIzU3LlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgcHJvbWlzZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2sgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2suaW5kZXhPZihTVEFDS19KVU1QX1NFUEFSQVRPUikgPT09IC0xXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjaykge1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8vIGVuYWJsZSBsb25nIHN0YWNrcyBpZiBRX0RFQlVHIGlzIHNldFxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuUV9ERUJVRykge1xuICAgIFEubG9uZ1N0YWNrU3VwcG9ydCA9IHRydWU7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHtwcm9taXNlLCByZXNvbHZlLCByZWplY3R9IG9iamVjdC5cbiAqXG4gKiBgcmVzb2x2ZWAgaXMgYSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBhIG1vcmUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoZVxuICogcHJvbWlzZS4gVG8gZnVsZmlsbCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGFueSB2YWx1ZSB0aGF0IGlzXG4gKiBub3QgYSB0aGVuYWJsZS4gVG8gcmVqZWN0IHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYSByZWplY3RlZFxuICogdGhlbmFibGUsIG9yIGludm9rZSBgcmVqZWN0YCB3aXRoIHRoZSByZWFzb24gZGlyZWN0bHkuIFRvIHJlc29sdmUgdGhlXG4gKiBwcm9taXNlIHRvIGFub3RoZXIgdGhlbmFibGUsIHRodXMgcHV0dGluZyBpdCBpbiB0aGUgc2FtZSBzdGF0ZSwgaW52b2tlXG4gKiBgcmVzb2x2ZWAgd2l0aCB0aGF0IG90aGVyIHRoZW5hYmxlLlxuICovXG5RLmRlZmVyID0gZGVmZXI7XG5mdW5jdGlvbiBkZWZlcigpIHtcbiAgICAvLyBpZiBcIm1lc3NhZ2VzXCIgaXMgYW4gXCJBcnJheVwiLCB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSBwcm9taXNlIGhhcyBub3QgeWV0XG4gICAgLy8gYmVlbiByZXNvbHZlZC4gIElmIGl0IGlzIFwidW5kZWZpbmVkXCIsIGl0IGhhcyBiZWVuIHJlc29sdmVkLiAgRWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIG1lc3NhZ2VzIGFycmF5IGlzIGl0c2VsZiBhbiBhcnJheSBvZiBjb21wbGV0ZSBhcmd1bWVudHMgdG9cbiAgICAvLyBmb3J3YXJkIHRvIHRoZSByZXNvbHZlZCBwcm9taXNlLiAgV2UgY29lcmNlIHRoZSByZXNvbHV0aW9uIHZhbHVlIHRvIGFcbiAgICAvLyBwcm9taXNlIHVzaW5nIHRoZSBgcmVzb2x2ZWAgZnVuY3Rpb24gYmVjYXVzZSBpdCBoYW5kbGVzIGJvdGggZnVsbHlcbiAgICAvLyBub24tdGhlbmFibGUgdmFsdWVzIGFuZCBvdGhlciB0aGVuYWJsZXMgZ3JhY2VmdWxseS5cbiAgICB2YXIgbWVzc2FnZXMgPSBbXSwgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXSwgcmVzb2x2ZWRQcm9taXNlO1xuXG4gICAgdmFyIGRlZmVycmVkID0gb2JqZWN0X2NyZWF0ZShkZWZlci5wcm90b3R5cGUpO1xuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgb3BlcmFuZHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goYXJncyk7XG4gICAgICAgICAgICBpZiAob3AgPT09IFwid2hlblwiICYmIG9wZXJhbmRzWzFdKSB7IC8vIHByb2dyZXNzIG9wZXJhbmRcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVycy5wdXNoKG9wZXJhbmRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWFyZXJWYWx1ZSA9IG5lYXJlcihyZXNvbHZlZFByb21pc2UpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKG5lYXJlclZhbHVlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmVhcmVyVmFsdWU7IC8vIHNob3J0ZW4gY2hhaW5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVyVmFsdWU7XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBlbmRpbmdcIiB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFByb21pc2UuaW5zcGVjdCgpO1xuICAgIH07XG5cbiAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGRvbid0IHRyeSB0byB1c2UgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCBvciB0cmFuc2ZlciB0aGVcbiAgICAgICAgICAgIC8vIGFjY2Vzc29yIGFyb3VuZDsgdGhhdCBjYXVzZXMgbWVtb3J5IGxlYWtzIGFzIHBlciBHSC0xMTEuIEp1c3RcbiAgICAgICAgICAgIC8vIHJlaWZ5IHRoZSBzdGFjayB0cmFjZSBhcyBhIHN0cmluZyBBU0FQLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUsIGN1dCBvZmYgdGhlIGZpcnN0IGxpbmU7IGl0J3MgYWx3YXlzIGp1c3RcbiAgICAgICAgICAgIC8vIFwiW29iamVjdCBQcm9taXNlXVxcblwiLCBhcyBwZXIgdGhlIGB0b1N0cmluZ2AuXG4gICAgICAgICAgICBwcm9taXNlLnN0YWNrID0gZS5zdGFjay5zdWJzdHJpbmcoZS5zdGFjay5pbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuXG4gICAgICAgIGFycmF5X3JlZHVjZShtZXNzYWdlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLlByb21pc2UgPSBwcm9taXNlOyAvLyBFUzZcblEucHJvbWlzZSA9IHByb21pc2U7XG5mdW5jdGlvbiBwcm9taXNlKHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5wcm9taXNlLnJhY2UgPSByYWNlOyAvLyBFUzZcbnByb21pc2UuYWxsID0gYWxsOyAvLyBFUzZcbnByb21pc2UucmVqZWN0ID0gcmVqZWN0OyAvLyBFUzZcbnByb21pc2UucmVzb2x2ZSA9IFE7IC8vIEVTNlxuXG4vLyBYWFggZXhwZXJpbWVudGFsLiAgVGhpcyBtZXRob2QgaXMgYSB3YXkgdG8gZGVub3RlIHRoYXQgYSBsb2NhbCB2YWx1ZSBpc1xuLy8gc2VyaWFsaXphYmxlIGFuZCBzaG91bGQgYmUgaW1tZWRpYXRlbHkgZGlzcGF0Y2hlZCB0byBhIHJlbW90ZSB1cG9uIHJlcXVlc3QsXG4vLyBpbnN0ZWFkIG9mIHBhc3NpbmcgYSByZWZlcmVuY2UuXG5RLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucGFzc0J5Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0d28gcHJvbWlzZXMgZXZlbnR1YWxseSBmdWxmaWxsIHRvIHRoZSBzYW1lIHZhbHVlLCBwcm9taXNlcyB0aGF0IHZhbHVlLFxuICogYnV0IG90aGVyd2lzZSByZWplY3RzLlxuICogQHBhcmFtIHgge0FueSp9XG4gKiBAcGFyYW0geSB7QW55Kn1cbiAqIEByZXR1cm5zIHtBbnkqfSBhIHByb21pc2UgZm9yIHggYW5kIHkgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGJ1dCBhIHJlamVjdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqL1xuUS5qb2luID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gUSh4KS5qb2luKHkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgcmV0dXJuIFEoW3RoaXMsIHRoYXRdKS5zcHJlYWQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFwiPT09XCIgc2hvdWxkIGJlIE9iamVjdC5pcyBvciBlcXVpdlxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBqb2luOiBub3QgdGhlIHNhbWU6IFwiICsgeCArIFwiIFwiICsgeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBmaXJzdCBvZiBhbiBhcnJheSBvZiBwcm9taXNlcyB0byBiZWNvbWUgc2V0dGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIHNldHRsZWRcbiAqL1xuUS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoYW5zd2VyUHMpIHtcbiAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHRoaXMgb25jZSB3ZSBjYW4gYXNzdW1lIGF0IGxlYXN0IEVTNVxuICAgICAgICAvLyBhbnN3ZXJQcy5mb3JFYWNoKGZ1bmN0aW9uKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgZG9uZSA9IGZhbHNlOyAgIC8vIGVuc3VyZSB0aGUgdW50cnVzdGVkIHByb21pc2UgbWFrZXMgYXQgbW9zdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2FsbCB0byBvbmUgb2YgdGhlIGNhbGxiYWNrc1xuXG4gICAgZnVuY3Rpb24gX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0ZWQoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGV4Y2VwdGlvbiwgc2VsZik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZChleGNlcHRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFeGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcHJvZ3Jlc3NlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2dyZXNzZWQgPT09IFwiZnVuY3Rpb25cIiA/IHByb2dyZXNzZWQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5RLnRhcCA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRhcChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdvcmtzIGFsbW9zdCBsaWtlIFwiZmluYWxseVwiLCBidXQgbm90IGNhbGxlZCBmb3IgcmVqZWN0aW9ucy5cbiAqIE9yaWdpbmFsIHJlc29sdXRpb24gdmFsdWUgaXMgcGFzc2VkIHRocm91Z2ggY2FsbGJhY2sgdW5hZmZlY3RlZC5cbiAqIENhbGxiYWNrIG1heSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBhd2FpdGVkIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7US5Qcm9taXNlfVxuICogQGV4YW1wbGVcbiAqIGRvU29tZXRoaW5nKClcbiAqICAgLnRoZW4oLi4uKVxuICogICAudGFwKGNvbnNvbGUubG9nKVxuICogICAudGhlbiguLi4pO1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKHZhbHVlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuXG5RLmlzUHJvbWlzZUFsaWtlID0gaXNQcm9taXNlQWxpa2U7XG5mdW5jdGlvbiBpc1Byb21pc2VBbGlrZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwZW5kaW5nIHByb21pc2UsIG1lYW5pbmcgbm90XG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gKi9cblEuaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xuZnVuY3Rpb24gaXNQZW5kaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbHVlIG9yIGZ1bGZpbGxlZFxuICogcHJvbWlzZS5cbiAqL1xuUS5pc0Z1bGZpbGxlZCA9IGlzRnVsZmlsbGVkO1xuZnVuY3Rpb24gaXNGdWxmaWxsZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuICFpc1Byb21pc2Uob2JqZWN0KSB8fCBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cblEuaXNSZWplY3RlZCA9IGlzUmVqZWN0ZWQ7XG5mdW5jdGlvbiBpc1JlamVjdGVkKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59O1xuXG4vLy8vIEJFR0lOIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLy8gVGhpcyBwcm9taXNlIGxpYnJhcnkgY29uc3VtZXMgZXhjZXB0aW9ucyB0aHJvd24gaW4gaGFuZGxlcnMgc28gdGhleSBjYW4gYmVcbi8vIGhhbmRsZWQgYnkgYSBzdWJzZXF1ZW50IHByb21pc2UuICBUaGUgZXhjZXB0aW9ucyBnZXQgYWRkZWQgdG8gdGhpcyBhcnJheSB3aGVuXG4vLyB0aGV5IGFyZSBjcmVhdGVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZXkgYXJlIGhhbmRsZWQuICBOb3RlIHRoYXQgaW4gRVM2IG9yXG4vLyBzaGltbWVkIGVudmlyb25tZW50cywgdGhpcyB3b3VsZCBuYXR1cmFsbHkgYmUgYSBgU2V0YC5cbnZhciB1bmhhbmRsZWRSZWFzb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdCwgMSk7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICB9XG59XG5cblEucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zID0gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zO1xuXG5RLmdldFVuaGFuZGxlZFJlYXNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gdGhhdCBjb25zdW1lcnMgY2FuJ3QgaW50ZXJmZXJlIHdpdGggb3VyIGludGVybmFsIHN0YXRlLlxuICAgIHJldHVybiB1bmhhbmRsZWRSZWFzb25zLnNsaWNlKCk7XG59O1xuXG5RLnN0b3BVbmhhbmRsZWRSZWplY3Rpb25UcmFja2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8qKlxuICogQW5ub3RhdGVzIGFuIG9iamVjdCBzdWNoIHRoYXQgaXQgd2lsbCBuZXZlciBiZVxuICogdHJhbnNmZXJyZWQgYXdheSBmcm9tIHRoaXMgcHJvY2VzcyBvdmVyIGFueSBwcm9taXNlXG4gKiBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBwcm9taXNlIGEgd3JhcHBpbmcgb2YgdGhhdCBvYmplY3QgdGhhdFxuICogYWRkaXRpb25hbGx5IHJlc3BvbmRzIHRvIHRoZSBcImlzRGVmXCIgbWVzc2FnZVxuICogd2l0aG91dCBhIHJlamVjdGlvbi5cbiAqL1xuUS5tYXN0ZXIgPSBtYXN0ZXI7XG5mdW5jdGlvbiBtYXN0ZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcImlzRGVmXCI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2sob3AsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFEob2JqZWN0KS5pbnNwZWN0KCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gc3ByZWFkO1xuZnVuY3Rpb24gc3ByZWFkKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnNwcmVhZChmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkLmFwcGx5KHZvaWQgMCwgYXJyYXkpO1xuICAgIH0sIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuICBBbHRob3VnaCBnZW5lcmF0b3JzIGFyZSBvbmx5IHBhcnRcbiAqIG9mIHRoZSBuZXdlc3QgRUNNQVNjcmlwdCA2IGRyYWZ0cywgdGhpcyBjb2RlIGRvZXMgbm90IGNhdXNlIHN5bnRheFxuICogZXJyb3JzIGluIG9sZGVyIGVuZ2luZXMuICBUaGlzIGNvZGUgc2hvdWxkIGNvbnRpbnVlIHRvIHdvcmsgYW5kIHdpbGxcbiAqIGluIGZhY3QgaW1wcm92ZSBvdmVyIHRpbWUgYXMgdGhlIGxhbmd1YWdlIGltcHJvdmVzLlxuICpcbiAqIEVTNiBnZW5lcmF0b3JzIGFyZSBjdXJyZW50bHkgcGFydCBvZiBWOCB2ZXJzaW9uIDMuMTkgd2l0aCB0aGVcbiAqIC0taGFybW9ueS1nZW5lcmF0b3JzIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiAgU3BpZGVyTW9ua2V5IGhhcyBoYWQgdGhlbVxuICogZm9yIGxvbmdlciwgYnV0IHVuZGVyIGFuIG9sZGVyIFB5dGhvbi1pbnNwaXJlZCBmb3JtLiAgVGhpcyBmdW5jdGlvblxuICogd29ya3Mgb24gYm90aCBraW5kcyBvZiBnZW5lcmF0b3JzLlxuICpcbiAqIERlY29yYXRlcyBhIGdlbmVyYXRvciBmdW5jdGlvbiBzdWNoIHRoYXQ6XG4gKiAgLSBpdCBtYXkgeWllbGQgcHJvbWlzZXNcbiAqICAtIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHdoZW4gdGhhdCBwcm9taXNlIGlzIGZ1bGZpbGxlZFxuICogIC0gdGhlIHZhbHVlIG9mIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpbGwgYmUgdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogIC0gaXQgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgKHdoZW4gdGhlIGdlbmVyYXRvclxuICogICAgc3RvcHMgaXRlcmF0aW5nKVxuICogIC0gdGhlIGRlY29yYXRlZCBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogICAgb2YgdGhlIGdlbmVyYXRvciBvciB0aGUgZmlyc3QgcmVqZWN0ZWQgcHJvbWlzZSBhbW9uZyB0aG9zZVxuICogICAgeWllbGRlZC5cbiAqICAtIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgZ2VuZXJhdG9yLCBpdCBwcm9wYWdhdGVzIHRocm91Z2hcbiAqICAgIGV2ZXJ5IGZvbGxvd2luZyB5aWVsZCB1bnRpbCBpdCBpcyBjYXVnaHQsIG9yIHVudGlsIGl0IGVzY2FwZXNcbiAqICAgIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gYWx0b2dldGhlciwgYW5kIGlzIHRyYW5zbGF0ZWQgaW50byBhXG4gKiAgICByZWplY3Rpb24gZm9yIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgZ2VuZXJhdG9yLlxuICovXG5RLmFzeW5jID0gYXN5bmM7XG5mdW5jdGlvbiBhc3luYyhtYWtlR2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwic2VuZFwiLCBhcmcgaXMgYSB2YWx1ZVxuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJ0aHJvd1wiLCBhcmcgaXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlcih2ZXJiLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuICAgICAgICAgICAgLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbiAgICAgICAgICAgIC8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbiAgICAgICAgICAgIC8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhpcyBibG9jay5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdG9wSXRlcmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRVM2IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNwaWRlck1vbmtleSBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGNhc2Ugd2hlbiBTTSBkb2VzIEVTNiBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBRKGV4Y2VwdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IG1ha2VHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcIm5leHRcIik7XG4gICAgICAgIHZhciBlcnJiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcInRocm93XCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzcGF3biBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIGFzeW5jIHRoYXQgaW1tZWRpYXRlbHlcbiAqIGNhbGxzIHRoZSBnZW5lcmF0b3IgYW5kIGFsc28gZW5kcyB0aGUgcHJvbWlzZSBjaGFpbiwgc28gdGhhdCBhbnlcbiAqIHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIGZvcndhcmRlZCB0byB0aGUgZXJyb3JcbiAqIGhhbmRsZXIuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBleHRyZW1lbHkgY29tbW9uIHRvIHJ1blxuICogZ2VuZXJhdG9ycyBhdCB0aGUgdG9wLWxldmVsIHRvIHdvcmsgd2l0aCBsaWJyYXJpZXMuXG4gKi9cblEuc3Bhd24gPSBzcGF3bjtcbmZ1bmN0aW9uIHNwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRLmRvbmUoUS5hc3luYyhtYWtlR2VuZXJhdG9yKSgpKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGludGVyZmFjZSBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG4vKipcbiAqIFRocm93cyBhIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB0byBzdG9wIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3IuXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgYSBzdG9wLWdhcCBtZWFzdXJlIHRvIHN1cHBvcnQgZ2VuZXJhdG9yIHJldHVyblxuICogdmFsdWVzIGluIG9sZGVyIEZpcmVmb3gvU3BpZGVyTW9ua2V5LiAgSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEVTNlxuICogZ2VuZXJhdG9ycyBsaWtlIENocm9taXVtIDI5LCBqdXN0IHVzZSBcInJldHVyblwiIGluIHlvdXIgZ2VuZXJhdG9yXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoZSBzdXJyb3VuZGluZyBnZW5lcmF0b3JcbiAqIEB0aHJvd3MgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHdpdGggdGhlIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIEVTNiBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiogKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICByZXR1cm4gZm9vICsgYmFyO1xuICogfSlcbiAqIC8vIE9sZGVyIFNwaWRlck1vbmtleSBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIFEucmV0dXJuKGZvbyArIGJhcik7XG4gKiB9KVxuICovXG5RW1wicmV0dXJuXCJdID0gX3JldHVybjtcbmZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgUVJldHVyblZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IHByb21pc2VkO1xuZnVuY3Rpb24gcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkKFt0aGlzLCBhbGwoYXJndW1lbnRzKV0sIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogc2VuZHMgYSBtZXNzYWdlIHRvIGEgdmFsdWUgaW4gYSBmdXR1cmUgdHVyblxuICogQHBhcmFtIG9iamVjdCogdGhlIHJlY2lwaWVudFxuICogQHBhcmFtIG9wIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIG9wZXJhdGlvbiwgZS5nLiwgXCJ3aGVuXCIsXG4gKiBAcGFyYW0gYXJncyBmdXJ0aGVyIGFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgcmVzdWx0IHtQcm9taXNlfSBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5RLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5mdW5jdGlvbiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChvcCwgYXJncyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKG9wLCBhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGRlZmVycmVkLnJlc29sdmUsIG9wLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBnZXRcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHByb3BlcnR5IHZhbHVlXG4gKi9cblEuZ2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3Igb2JqZWN0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHZhbHVlICAgICBuZXcgdmFsdWUgb2YgcHJvcGVydHlcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic2V0XCIsIFtrZXksIHZhbHVlXSk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBkZWxldGVcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLmRlbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZGVsZXRlXCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gdmFsdWUgICAgIGEgdmFsdWUgdG8gcG9zdCwgdHlwaWNhbGx5IGFuIGFycmF5IG9mXG4gKiAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gYXJndW1lbnRzIGZvciBwcm9taXNlcyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgIGFyZSB1bHRpbWF0ZWx5IGJhY2tlZCB3aXRoIGByZXNvbHZlYCB2YWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgIGFzIG9wcG9zZWQgdG8gdGhvc2UgYmFja2VkIHdpdGggVVJMc1xuICogICAgICAgICAgICAgICAgICB3aGVyZWluIHRoZSBwb3N0ZWQgdmFsdWUgY2FuIGJlIGFueVxuICogICAgICAgICAgICAgICAgICBKU09OIHNlcmlhbGl6YWJsZSBvYmplY3QuXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuLy8gYm91bmQgbG9jYWxseSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgb3RoZXIgbWV0aG9kc1xuUS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBpbnZvY2F0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5RLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEuaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblByb21pc2UucHJvdG90eXBlLm1jYWxsID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gYXJncyAgICAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZhcHBseSA9IGZ1bmN0aW9uIChvYmplY3QsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RW1widHJ5XCJdID1cblEuZmNhbGwgPSBmdW5jdGlvbiAob2JqZWN0IC8qIC4uLmFyZ3MqLykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzKV0pO1xufTtcblxuLyoqXG4gKiBCaW5kcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24sIHRyYW5zZm9ybWluZyByZXR1cm4gdmFsdWVzIGludG8gYSBmdWxmaWxsZWRcbiAqIHByb21pc2UgYW5kIHRocm93biBlcnJvcnMgaW50byBhIHJlamVjdGVkIG9uZS5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmJpbmQgPSBmdW5jdGlvbiAob2JqZWN0IC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSBRKG9iamVjdCk7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuZmJpbmQgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBmYm91bmQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLmRpc3BhdGNoKFwiYXBwbHlcIiwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIF0pO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRoZSBuYW1lcyBvZiB0aGUgb3duZWQgcHJvcGVydGllcyBvZiBhIHByb21pc2VkXG4gKiBvYmplY3QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBrZXlzIG9mIHRoZSBldmVudHVhbGx5IHNldHRsZWQgb2JqZWN0XG4gKi9cblEua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwia2V5c1wiLCBbXSk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheS4gIElmIGFueSBvZlxuICogdGhlIHByb21pc2VzIGdldHMgcmVqZWN0ZWQsIHRoZSB3aG9sZSBhcnJheSBpcyByZWplY3RlZCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICovXG4vLyBCeSBNYXJrIE1pbGxlclxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9c3RyYXdtYW46Y29uY3VycmVuY3kmcmV2PTEzMDg3NzY1MjEjYWxsZnVsZmlsbGVkXG5RLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIGNvdW50RG93biA9IDA7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIGFycmF5X3JlZHVjZShwcm9taXNlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgcHJvbWlzZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpc1Byb21pc2UocHJvbWlzZSkgJiZcbiAgICAgICAgICAgICAgICAoc25hcHNob3QgPSBwcm9taXNlLmluc3BlY3QoKSkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHNuYXBzaG90LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICArK2NvdW50RG93bjtcbiAgICAgICAgICAgICAgICB3aGVuKFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tY291bnREb3duID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoeyBpbmRleDogaW5kZXgsIHZhbHVlOiBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIGlmIChjb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyB0byBiZSBzZXR0bGVkLCBlaXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZC4gIFRoaXMgaXMgZGlzdGluY3QgZnJvbSBgYWxsYCBzaW5jZSB0aGF0IHdvdWxkIHN0b3BcbiAqIHdhaXRpbmcgYXQgdGhlIGZpcnN0IHJlamVjdGlvbi4gIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gKiBgYWxsUmVzb2x2ZWRgIHdpbGwgbmV2ZXIgYmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0gcHJvbWlzZXMgYSBwcm9taXNlIGZvciBhbiBhcnJheSAob3IgYW4gYXJyYXkpIG9mIHByb21pc2VzXG4gKiAob3IgdmFsdWVzKVxuICogQHJldHVybiBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHByb21pc2VzXG4gKi9cblEuYWxsUmVzb2x2ZWQgPSBkZXByZWNhdGUoYWxsUmVzb2x2ZWQsIFwiYWxsUmVzb2x2ZWRcIiwgXCJhbGxTZXR0bGVkXCIpO1xuZnVuY3Rpb24gYWxsUmVzb2x2ZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHByb21pc2VzID0gYXJyYXlfbWFwKHByb21pc2VzLCBRKTtcbiAgICAgICAgcmV0dXJuIHdoZW4oYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGVuKHByb21pc2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbFJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGxSZXNvbHZlZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQHNlZSBQcm9taXNlI2FsbFNldHRsZWRcbiAqL1xuUS5hbGxTZXR0bGVkID0gYWxsU2V0dGxlZDtcbmZ1bmN0aW9uIGFsbFNldHRsZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gUShwcm9taXNlcykuYWxsU2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGVpciBzdGF0ZXMgKGFzXG4gKiByZXR1cm5lZCBieSBgaW5zcGVjdGApIHdoZW4gdGhleSBoYXZlIGFsbCBzZXR0bGVkLlxuICogQHBhcmFtIHtBcnJheVtBbnkqXX0gdmFsdWVzIGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIHtBcnJheVtTdGF0ZV19IGFuIGFycmF5IG9mIHN0YXRlcyBmb3IgdGhlIHJlc3BlY3RpdmUgdmFsdWVzLlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxTZXR0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiBhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFEocHJvbWlzZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZWdhcmRsZXNzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmluc3BlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVnYXJkbGVzcywgcmVnYXJkbGVzcyk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIGZhaWx1cmUgb2YgYSBwcm9taXNlLCBnaXZpbmcgYW4gb3BvcnR1bml0eSB0byByZWNvdmVyXG4gKiB3aXRoIGEgY2FsbGJhY2suICBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICogcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpZiB0aGVcbiAqIGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2tcbiAqL1xuUS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9iamVjdCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgbGlzdGVuZXIgdGhhdCBjYW4gcmVzcG9uZCB0byBwcm9ncmVzcyBub3RpZmljYXRpb25zIGZyb20gYVxuICogcHJvbWlzZSdzIG9yaWdpbmF0aW5nIGRlZmVycmVkLiBUaGlzIGxpc3RlbmVyIHJlY2VpdmVzIHRoZSBleGFjdCBhcmd1bWVudHNcbiAqIHBhc3NlZCB0byBgYGRlZmVycmVkLm5vdGlmeWBgLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIHJlY2VpdmUgYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm5zIHRoZSBnaXZlbiBwcm9taXNlLCB1bmNoYW5nZWRcbiAqL1xuUS5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZnVuY3Rpb24gcHJvZ3Jlc3Mob2JqZWN0LCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhbiBvcHBvcnR1bml0eSB0byBvYnNlcnZlIHRoZSBzZXR0bGluZyBvZiBhIHByb21pc2UsXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIG9yIHJlamVjdGVkLiAgRm9yd2FyZHNcbiAqIHRoZSByZXNvbHV0aW9uIHRvIHRoZSByZXR1cm5lZCBwcm9taXNlIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGRvbmUuXG4gKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIHByb21pc2UgdG8gZGVmZXIgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gb2JzZXJ2ZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW5cbiAqIHByb21pc2UsIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2Ugd2hlblxuICogYGBmaW5gYCBpcyBkb25lLlxuICovXG5RLmZpbiA9IC8vIFhYWCBsZWdhY3lcblFbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpW1wiZmluYWxseVwiXShjYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maW4gPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRPRE8gYXR0ZW1wdCB0byByZWN5Y2xlIHRoZSByZWplY3Rpb24gd2l0aCBcInRoaXNcIi5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUZXJtaW5hdGVzIGEgY2hhaW4gb2YgcHJvbWlzZXMsIGZvcmNpbmcgcmVqZWN0aW9ucyB0byBiZVxuICogdGhyb3duIGFzIGV4Y2VwdGlvbnMuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgYXQgdGhlIGVuZCBvZiBhIGNoYWluIG9mIHByb21pc2VzXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cblEuZG9uZSA9IGZ1bmN0aW9uIChvYmplY3QsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kb25lKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBmb3J3YXJkIHRvIGEgZnV0dXJlIHR1cm4gc28gdGhhdCBgYHdoZW5gYFxuICAgICAgICAvLyBkb2VzIG5vdCBjYXRjaCBpdCBhbmQgdHVybiBpdCBpbnRvIGEgcmVqZWN0aW9uLlxuICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBgbmV4dFRpY2tgaW5nIHZpYSBhbiB1bm5lY2Vzc2FyeSBgd2hlbmAuXG4gICAgdmFyIHByb21pc2UgPSBmdWxmaWxsZWQgfHwgcmVqZWN0ZWQgfHwgcHJvZ3Jlc3MgP1xuICAgICAgICB0aGlzLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIDpcbiAgICAgICAgdGhpcztcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3IgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbih2b2lkIDAsIG9uVW5oYW5kbGVkRXJyb3IpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kcyB0aW1lb3V0XG4gKiBAcGFyYW0ge0FueSp9IGN1c3RvbSBlcnJvciBtZXNzYWdlIG9yIEVycm9yIG9iamVjdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGlmIGl0IGlzXG4gKiBmdWxmaWxsZWQgYmVmb3JlIHRoZSB0aW1lb3V0LCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gKi9cblEudGltZW91dCA9IGZ1bmN0aW9uIChvYmplY3QsIG1zLCBlcnJvcikge1xuICAgIHJldHVybiBRKG9iamVjdCkudGltZW91dChtcywgZXJyb3IpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgZXJyb3IpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlcnJvciB8fCBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yIHx8IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgbXMgKyBcIiBtc1wiKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBcIkVUSU1FRE9VVFwiO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgfSwgbXMpO1xuXG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfSwgZGVmZXJyZWQubm90aWZ5KTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGdpdmVuIHZhbHVlIChvciBwcm9taXNlZCB2YWx1ZSksIHNvbWVcbiAqIG1pbGxpc2Vjb25kcyBhZnRlciBpdCByZXNvbHZlZC4gUGFzc2VzIHJlamVjdGlvbnMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgYWZ0ZXIgbWlsbGlzZWNvbmRzXG4gKiB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlLlxuICogSWYgdGhlIGdpdmVuIHByb21pc2UgcmVqZWN0cywgdGhhdCBpcyBwYXNzZWQgaW1tZWRpYXRlbHkuXG4gKi9cblEuZGVsYXkgPSBmdW5jdGlvbiAob2JqZWN0LCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lb3V0ID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBRKG9iamVjdCkuZGVsYXkodGltZW91dCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBhcyBhbiBhcnJheSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqICAgICAgUS5uZmFwcGx5KEZTLnJlYWRGaWxlLCBbX19maWxlbmFtZV0pXG4gKiAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiAgICAgIH0pXG4gKlxuICovXG5RLm5mYXBwbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGluZGl2aWR1YWxseSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZjYWxsKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKVxuICogLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqIH0pXG4gKlxuICovXG5RLm5mY2FsbCA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBOb2RlSlMgY29udGludWF0aW9uIHBhc3NpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudFxuICogdmVyc2lvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZiaW5kKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKShcInV0Zi04XCIpXG4gKiAudGhlbihjb25zb2xlLmxvZylcbiAqIC5kb25lKClcbiAqL1xuUS5uZmJpbmQgPVxuUS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBRKGNhbGxiYWNrKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYmluZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLmRlbm9kZWlmeS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuUS5uYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3AgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBRKGJvdW5kKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5iaW5kID0gZnVuY3Rpb24gKC8qdGhpc3AsIC4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEubmJpbmQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjayB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWQgY2FsbGJhY2suXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5ucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5wb3N0KG5hbWUsIGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5ucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyB8fCBbXSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrLCBmb3J3YXJkaW5nIHRoZSBnaXZlbiB2YXJpYWRpYyBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZFxuICogY2FsbGJhY2sgYXJndW1lbnQuXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0gLi4uYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2sgd2lsbFxuICogYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5RLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblEubmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUHJvbWlzZS5wcm90b3R5cGUubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUHJvbWlzZS5wcm90b3R5cGUubmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIElmIGEgZnVuY3Rpb24gd291bGQgbGlrZSB0byBzdXBwb3J0IGJvdGggTm9kZSBjb250aW51YXRpb24tcGFzc2luZy1zdHlsZSBhbmRcbiAqIHByb21pc2UtcmV0dXJuaW5nLXN0eWxlLCBpdCBjYW4gZW5kIGl0cyBpbnRlcm5hbCBwcm9taXNlIGNoYWluIHdpdGhcbiAqIGBub2RlaWZ5KG5vZGViYWNrKWAsIGZvcndhcmRpbmcgdGhlIG9wdGlvbmFsIG5vZGViYWNrIGFyZ3VtZW50LiAgSWYgdGhlIHVzZXJcbiAqIGVsZWN0cyB0byB1c2UgYSBub2RlYmFjaywgdGhlIHJlc3VsdCB3aWxsIGJlIHNlbnQgdGhlcmUuICBJZiB0aGV5IGRvIG5vdFxuICogcGFzcyBhIG5vZGViYWNrLCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IHByb21pc2UuXG4gKiBAcGFyYW0gb2JqZWN0IGEgcmVzdWx0IChvciBhIHByb21pc2UgZm9yIGEgcmVzdWx0KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbm9kZWJhY2sgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyBlaXRoZXIgdGhlIHByb21pc2Ugb3Igbm90aGluZ1xuICovXG5RLm5vZGVpZnkgPSBub2RlaWZ5O1xuZnVuY3Rpb24gbm9kZWlmeShvYmplY3QsIG5vZGViYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ub2RlaWZ5KG5vZGViYWNrKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaykge1xuICAgIGlmIChub2RlYmFjaykge1xuICAgICAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcbiIsIi8qXG4gKiBRYW5pbWF0aW9uZnJhbWUuanMgLSBQcm9taXNpZmllZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2l0aCBRXG4gKi9cbi8qanNsaW50IG5ld2NhcDogdHJ1ZSAqL1xuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5RYW5pbWF0aW9uRnJhbWUgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSkoZnVuY3Rpb24gKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBJbXBvcnQgUVxuICB2YXIgUSA9IHdpbmRvdy5RIHx8IHJlcXVpcmUoXCJxXCIpO1xuXG4gIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbFxuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgfTtcbiAgfSkoKTtcblxuICAvLyBRYW5pbWF0aW9uRnJhbWUoZjogZnVuY3Rpb24pID0+IHByb21pc2UgY29udGFpbmluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIGZcbiAgLy8gLS0tXG4gIC8vXG4gIHZhciBRYW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoZikge1xuICAgIHZhciBkID0gUS5kZWZlcigpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkLnJlc29sdmUoZigpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZC5yZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gUWFuaW1hdGlvbkZyYW1lO1xufSk7XG4iLCIvLyBUaGlzIGxpYnJhcnkgc3RhcnRlZCBhcyBhbiBleHBlcmltZW50IHRvIHNlZSBob3cgc21hbGwgSSBjb3VsZCBtYWtlXG4vLyBhIGZ1bmN0aW9uYWwgcm91dGVyLiBJdCBoYXMgc2luY2UgYmVlbiBvcHRpbWl6ZWQgKGFuZCB0aHVzIGdyb3duKS5cbi8vIFRoZSByZWR1bmRhbmN5IGFuZCBpbmVsZWdhbmNlIGhlcmUgaXMgZm9yIHRoZSBzYWtlIG9mIGVpdGhlciBzaXplXG4vLyBvciBzcGVlZC5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICB2YXIgZGVmaW5lID0gcm9vdC5kZWZpbmU7XG5cbiAgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdybGl0ZScsIFtdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuUmxpdGUgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJvdXRlcyA9IHt9LFxuICAgICAgICBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmdW5jdGlvbiBub29wKHMpIHsgcmV0dXJuIHM7IH1cblxuICAgIGZ1bmN0aW9uIHNhbml0aXplKHVybCkge1xuICAgICAgfnVybC5pbmRleE9mKCcvPycpICYmICh1cmwgPSB1cmwucmVwbGFjZSgnLz8nLCAnPycpKTtcbiAgICAgIHVybFswXSA9PSAnLycgJiYgKHVybCA9IHVybC5zbGljZSgxKSk7XG4gICAgICB1cmxbdXJsLmxlbmd0aCAtIDFdID09ICcvJyAmJiAodXJsID0gdXJsLnNsaWNlKDAsIC0xKSk7XG5cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1VybCh1cmwsIGVzYykge1xuICAgICAgdmFyIHBpZWNlcyA9IHVybC5zcGxpdCgnLycpLFxuICAgICAgICAgIHJ1bGVzID0gcm91dGVzLFxuICAgICAgICAgIHBhcmFtcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggJiYgcnVsZXM7ICsraSkge1xuICAgICAgICB2YXIgcGllY2UgPSBlc2MocGllY2VzW2ldKTtcbiAgICAgICAgcnVsZXMgPSBydWxlc1twaWVjZS50b0xvd2VyQ2FzZSgpXSB8fCBydWxlc1snOiddO1xuICAgICAgICBydWxlcyAmJiBydWxlc1snfiddICYmIChwYXJhbXNbcnVsZXNbJ34nXV0gPSBwaWVjZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydWxlcyAmJiB7XG4gICAgICAgIGNiOiBydWxlc1snQCddLFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUXVlcnkodXJsLCBjdHgsIGVzYykge1xuICAgICAgaWYgKHVybCAmJiBjdHguY2IpIHtcbiAgICAgICAgdmFyIGhhc2ggPSB1cmwuaW5kZXhPZignIycpLFxuICAgICAgICAgICAgcXVlcnkgPSAoaGFzaCA8IDAgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaCkpLnNwbGl0KCcmJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBuYW1lVmFsdWUgPSBxdWVyeVtpXS5zcGxpdCgnPScpO1xuXG4gICAgICAgICAgY3R4LnBhcmFtc1tuYW1lVmFsdWVbMF1dID0gZXNjKG5hbWVWYWx1ZVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29rdXAodXJsKSB7XG4gICAgICB2YXIgcXVlcnlTcGxpdCA9IHNhbml0aXplKHVybCkuc3BsaXQoJz8nKSxcbiAgICAgICAgICBlc2MgPSB+dXJsLmluZGV4T2YoJyUnKSA/IGRlY29kZSA6IG5vb3A7XG5cbiAgICAgIHJldHVybiBwcm9jZXNzUXVlcnkocXVlcnlTcGxpdFsxXSwgcHJvY2Vzc1VybChxdWVyeVNwbGl0WzBdLCBlc2MpIHx8IHt9LCBlc2MpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uKHJvdXRlLCBoYW5kbGVyKSB7XG5cbiAgICAgICAgdmFyIHBpZWNlcyA9IHJvdXRlLnNwbGl0KCcvJyksXG4gICAgICAgICAgICBydWxlcyA9IHJvdXRlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBwaWVjZSA9IHBpZWNlc1tpXSxcbiAgICAgICAgICAgICAgbmFtZSA9IHBpZWNlWzBdID09ICc6JyA/ICc6JyA6IHBpZWNlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBydWxlcyA9IHJ1bGVzW25hbWVdIHx8IChydWxlc1tuYW1lXSA9IHt9KTtcblxuICAgICAgICAgIG5hbWUgPT0gJzonICYmIChydWxlc1snfiddID0gcGllY2Uuc2xpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcnVsZXNbJ0AnXSA9IGhhbmRsZXI7XG4gICAgICB9LFxuXG4gICAgICBleGlzdHM6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuICEhbG9va3VwKHVybCkuY2I7XG4gICAgICB9LFxuXG4gICAgICBsb29rdXA6IGxvb2t1cCxcblxuICAgICAgcnVuOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cCh1cmwpO1xuXG4gICAgICAgIHJlc3VsdC5jYiAmJiByZXN1bHQuY2Ioe1xuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIHBhcmFtczogcmVzdWx0LnBhcmFtc1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gISFyZXN1bHQuY2I7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pKTtcbiIsIi8qanNsaW50IG9uZXZhcjp0cnVlLCB1bmRlZjp0cnVlLCBuZXdjYXA6dHJ1ZSwgcmVnZXhwOnRydWUsIGJpdHdpc2U6dHJ1ZSwgbWF4ZXJyOjUwLCBpbmRlbnQ6NCwgd2hpdGU6ZmFsc2UsIG5vbWVuOmZhbHNlLCBwbHVzcGx1czpmYWxzZSAqL1xuLypnbG9iYWwgZGVmaW5lOmZhbHNlLCByZXF1aXJlOmZhbHNlLCBleHBvcnRzOmZhbHNlLCBtb2R1bGU6ZmFsc2UsIHNpZ25hbHM6ZmFsc2UgKi9cblxuLyoqIEBsaWNlbnNlXG4gKiBKUyBTaWduYWxzIDxodHRwOi8vbWlsbGVybWVkZWlyb3MuZ2l0aHViLmNvbS9qcy1zaWduYWxzLz5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQXV0aG9yOiBNaWxsZXIgTWVkZWlyb3NcbiAqIFZlcnNpb246IDEuMC4wIC0gQnVpbGQ6IDI2OCAoMjAxMi8xMS8yOSAwNTo0OCBQTSlcbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKXtcblxuICAgIC8vIFNpZ25hbEJpbmRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGJpbmRpbmcgYmV0d2VlbiBhIFNpZ25hbCBhbmQgYSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgKiA8YnIgLz4tIDxzdHJvbmc+VGhpcyBpcyBhbiBpbnRlcm5hbCBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkbid0IGJlIGNhbGxlZCBieSByZWd1bGFyIHVzZXJzLjwvc3Ryb25nPlxuICAgICAqIDxiciAvPi0gaW5zcGlyZWQgYnkgSm9hIEViZXJ0IEFTMyBTaWduYWxCaW5kaW5nIGFuZCBSb2JlcnQgUGVubmVyJ3MgU2xvdCBjbGFzc2VzLlxuICAgICAqIEBhdXRob3IgTWlsbGVyIE1lZGVpcm9zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGludGVybmFsXG4gICAgICogQG5hbWUgU2lnbmFsQmluZGluZ1xuICAgICAqIEBwYXJhbSB7U2lnbmFsfSBzaWduYWwgUmVmZXJlbmNlIHRvIFNpZ25hbCBvYmplY3QgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgSGFuZGxlciBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2lnbmFsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlIElmIGJpbmRpbmcgc2hvdWxkIGJlIGV4ZWN1dGVkIGp1c3Qgb25jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpc3RlbmVyQ29udGV4dF0gQ29udGV4dCBvbiB3aGljaCBsaXN0ZW5lciB3aWxsIGJlIGV4ZWN1dGVkIChvYmplY3QgdGhhdCBzaG91bGQgcmVwcmVzZW50IHRoZSBgdGhpc2AgdmFyaWFibGUgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9uKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50IGxpc3RlbmVyLiAoZGVmYXVsdCA9IDApLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbEJpbmRpbmcoc2lnbmFsLCBsaXN0ZW5lciwgaXNPbmNlLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXIgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGJpbmRpbmcgc2hvdWxkIGJlIGV4ZWN1dGVkIGp1c3Qgb25jZS5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNPbmNlID0gaXNPbmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAgICAgKiBAbWVtYmVyT2YgU2lnbmFsQmluZGluZy5wcm90b3R5cGVcbiAgICAgICAgICogQG5hbWUgY29udGV4dFxuICAgICAgICAgKiBAdHlwZSBPYmplY3R8dW5kZWZpbmVkfG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGxpc3RlbmVyQ29udGV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIFNpZ25hbCBvYmplY3QgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICAgICAqIEB0eXBlIFNpZ25hbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2lnbmFsID0gc2lnbmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW5lciBwcmlvcml0eVxuICAgICAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcbiAgICB9XG5cbiAgICBTaWduYWxCaW5kaW5nLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYmluZGluZyBpcyBhY3RpdmUgYW5kIHNob3VsZCBiZSBleGVjdXRlZC5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlIDogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBwYXJhbWV0ZXJzIHBhc3NlZCB0byBsaXN0ZW5lciBkdXJpbmcgYFNpZ25hbC5kaXNwYXRjaGAgYW5kIGBTaWduYWxCaW5kaW5nLmV4ZWN1dGVgLiAoY3VycmllZCBwYXJhbWV0ZXJzKVxuICAgICAgICAgKiBAdHlwZSBBcnJheXxudWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbXMgOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIGxpc3RlbmVyIHBhc3NpbmcgYXJiaXRyYXJ5IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIDxwPklmIGJpbmRpbmcgd2FzIGFkZGVkIHVzaW5nIGBTaWduYWwuYWRkT25jZSgpYCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHNpZ25hbCBkaXNwYXRjaCBxdWV1ZSwgdGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGZvciB0aGUgc2lnbmFsIGRpc3BhdGNoLjwvcD5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtc0Fycl0gQXJyYXkgb2YgcGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGxpc3RlbmVyXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHJldHVybmVkIGJ5IHRoZSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGV4ZWN1dGUgOiBmdW5jdGlvbiAocGFyYW1zQXJyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlclJldHVybiwgcGFyYW1zO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICEhdGhpcy5fbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcz8gdGhpcy5wYXJhbXMuY29uY2F0KHBhcmFtc0FycikgOiBwYXJhbXNBcnI7XG4gICAgICAgICAgICAgICAgaGFuZGxlclJldHVybiA9IHRoaXMuX2xpc3RlbmVyLmFwcGx5KHRoaXMuY29udGV4dCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJSZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGFjaCBiaW5kaW5nIGZyb20gc2lnbmFsLlxuICAgICAgICAgKiAtIGFsaWFzIHRvOiBteVNpZ25hbC5yZW1vdmUobXlCaW5kaW5nLmdldExpc3RlbmVyKCkpO1xuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwgb3IgYG51bGxgIGlmIGJpbmRpbmcgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZXRhY2ggOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0JvdW5kKCk/IHRoaXMuX3NpZ25hbC5yZW1vdmUodGhpcy5fbGlzdGVuZXIsIHRoaXMuY29udGV4dCkgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYmluZGluZyBpcyBzdGlsbCBib3VuZCB0byB0aGUgc2lnbmFsIGFuZCBoYXZlIGEgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpc0JvdW5kIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICghIXRoaXMuX3NpZ25hbCAmJiAhIXRoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgU2lnbmFsQmluZGluZyB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzT25jZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc09uY2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMaXN0ZW5lciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7U2lnbmFsfSBTaWduYWwgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaWduYWwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgaW5zdGFuY2UgcHJvcGVydGllc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2Rlc3Ryb3kgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2lnbmFsO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbU2lnbmFsQmluZGluZyBpc09uY2U6JyArIHRoaXMuX2lzT25jZSArJywgaXNCb3VuZDonKyB0aGlzLmlzQm91bmQoKSArJywgYWN0aXZlOicgKyB0aGlzLmFjdGl2ZSArICddJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4vKmdsb2JhbCBTaWduYWxCaW5kaW5nOmZhbHNlKi9cblxuICAgIC8vIFNpZ25hbCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lciwgZm5OYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2xpc3RlbmVyIGlzIGEgcmVxdWlyZWQgcGFyYW0gb2Yge2ZufSgpIGFuZCBzaG91bGQgYmUgYSBGdW5jdGlvbi4nLnJlcGxhY2UoJ3tmbn0nLCBmbk5hbWUpICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnQgYnJvYWRjYXN0ZXJcbiAgICAgKiA8YnIgLz4tIGluc3BpcmVkIGJ5IFJvYmVydCBQZW5uZXIncyBBUzMgU2lnbmFscy5cbiAgICAgKiBAbmFtZSBTaWduYWxcbiAgICAgKiBAYXV0aG9yIE1pbGxlciBNZWRlaXJvc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIEFycmF5LjxTaWduYWxCaW5kaW5nPlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5mb3JjZSBkaXNwYXRjaCB0byBhd2F5cyB3b3JrIG9uIHNhbWUgY29udGV4dCAoIzQ3KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgU2lnbmFsLnByb3RvdHlwZS5kaXNwYXRjaC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIFNpZ25hbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ25hbHMgVmVyc2lvbiBOdW1iZXJcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKi9cbiAgICAgICAgVkVSU0lPTiA6ICcxLjAuMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIFNpZ25hbCBzaG91bGQga2VlcCByZWNvcmQgb2YgcHJldmlvdXNseSBkaXNwYXRjaGVkIHBhcmFtZXRlcnMgYW5kXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgZXhlY3V0ZSBsaXN0ZW5lciBkdXJpbmcgYGFkZCgpYC9gYWRkT25jZSgpYCBpZiBTaWduYWwgd2FzXG4gICAgICAgICAqIGFscmVhZHkgZGlzcGF0Y2hlZCBiZWZvcmUuXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG1lbW9yaXplIDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zaG91bGRQcm9wYWdhdGUgOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBTaWduYWwgaXMgYWN0aXZlIGFuZCBzaG91bGQgYnJvYWRjYXN0IGV2ZW50cy5cbiAgICAgICAgICogPHA+PHN0cm9uZz5JTVBPUlRBTlQ6PC9zdHJvbmc+IFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBkdXJpbmcgYSBkaXNwYXRjaCB3aWxsIG9ubHkgYWZmZWN0IHRoZSBuZXh0IGRpc3BhdGNoLCBpZiB5b3Ugd2FudCB0byBzdG9wIHRoZSBwcm9wYWdhdGlvbiBvZiBhIHNpZ25hbCB1c2UgYGhhbHQoKWAgaW5zdGVhZC48L3A+XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZSA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlZ2lzdGVyTGlzdGVuZXIgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGlzT25jZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSkge1xuXG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gdGhpcy5faW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQpLFxuICAgICAgICAgICAgICAgIGJpbmRpbmc7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMuX2JpbmRpbmdzW3ByZXZJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuaXNPbmNlKCkgIT09IGlzT25jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgYWRkJysgKGlzT25jZT8gJycgOiAnT25jZScpICsnKCkgdGhlbiBhZGQnKyAoIWlzT25jZT8gJycgOiAnT25jZScpICsnKCkgdGhlIHNhbWUgbGlzdGVuZXIgd2l0aG91dCByZW1vdmluZyB0aGUgcmVsYXRpb25zaGlwIGZpcnN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IG5ldyBTaWduYWxCaW5kaW5nKHRoaXMsIGxpc3RlbmVyLCBpc09uY2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMubWVtb3JpemUgJiYgdGhpcy5fcHJldlBhcmFtcyl7XG4gICAgICAgICAgICAgICAgYmluZGluZy5leGVjdXRlKHRoaXMuX3ByZXZQYXJhbXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTaWduYWxCaW5kaW5nfSBiaW5kaW5nXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYWRkQmluZGluZyA6IGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAvL3NpbXBsaWZpZWQgaW5zZXJ0aW9uIHNvcnRcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICAgICAgZG8geyAtLW47IH0gd2hpbGUgKHRoaXMuX2JpbmRpbmdzW25dICYmIGJpbmRpbmcuX3ByaW9yaXR5IDw9IHRoaXMuX2JpbmRpbmdzW25dLl9wcmlvcml0eSk7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5ncy5zcGxpY2UobiArIDEsIDAsIGJpbmRpbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaW5kZXhPZkxpc3RlbmVyIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXI7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gdGhpcy5fYmluZGluZ3Nbbl07XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5fbGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIGN1ci5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgbGlzdGVuZXIgd2FzIGF0dGFjaGVkIHRvIFNpZ25hbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiBTaWduYWwgaGFzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBoYXMgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleE9mTGlzdGVuZXIobGlzdGVuZXIsIGNvbnRleHQpICE9PSAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgU2lnbmFsIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XSBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50IGxpc3RlbmVyLiBMaXN0ZW5lcnMgd2l0aCBoaWdoZXIgcHJpb3JpdHkgd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgbGlzdGVuZXJzIHdpdGggbG93ZXIgcHJpb3JpdHkuIExpc3RlbmVycyB3aXRoIHNhbWUgcHJpb3JpdHkgbGV2ZWwgd2lsbCBiZSBleGVjdXRlZCBhdCB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IHdlcmUgYWRkZWQuIChkZWZhdWx0ID0gMClcbiAgICAgICAgICogQHJldHVybiB7U2lnbmFsQmluZGluZ30gQW4gT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBiZXR3ZWVuIHRoZSBTaWduYWwgYW5kIGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAnYWRkJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgbGlzdGVuZXIgdG8gdGhlIHNpZ25hbCB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGFmdGVyIGZpcnN0IGV4ZWN1dGlvbiAod2lsbCBiZSBleGVjdXRlZCBvbmx5IG9uY2UpLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBTaWduYWwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0ZW5lckNvbnRleHRdIENvbnRleHQgb24gd2hpY2ggbGlzdGVuZXIgd2lsbCBiZSBleGVjdXRlZCAob2JqZWN0IHRoYXQgc2hvdWxkIHJlcHJlc2VudCB0aGUgYHRoaXNgIHZhcmlhYmxlIGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbikuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldIFRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuIExpc3RlbmVycyB3aXRoIGhpZ2hlciBwcmlvcml0eSB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBsaXN0ZW5lcnMgd2l0aCBsb3dlciBwcmlvcml0eS4gTGlzdGVuZXJzIHdpdGggc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgd2VyZSBhZGRlZC4gKGRlZmF1bHQgPSAwKVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfSBBbiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIGJldHdlZW4gdGhlIFNpZ25hbCBhbmQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRPbmNlIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAnYWRkT25jZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXIobGlzdGVuZXIsIHRydWUsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBzaW5nbGUgbGlzdGVuZXIgZnJvbSB0aGUgZGlzcGF0Y2ggcXVldWUuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEhhbmRsZXIgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBFeGVjdXRpb24gY29udGV4dCAoc2luY2UgeW91IGNhbiBhZGQgdGhlIHNhbWUgaGFuZGxlciBtdWx0aXBsZSB0aW1lcyBpZiBleGVjdXRpbmcgaW4gYSBkaWZmZXJlbnQgY29udGV4dCkuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBMaXN0ZW5lciBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAncmVtb3ZlJyk7XG5cbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5faW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzW2ldLl9kZXN0cm95KCk7IC8vbm8gcmVhc29uIHRvIGEgU2lnbmFsQmluZGluZyBleGlzdCBpZiBpdCBpc24ndCBhdHRhY2hlZCB0byBhIHNpZ25hbFxuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgU2lnbmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ3Nbbl0uX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGxpc3RlbmVycyBhdHRhY2hlZCB0byB0aGUgU2lnbmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TnVtTGlzdGVuZXJzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQsIGJsb2NraW5nIHRoZSBkaXNwYXRjaCB0byBuZXh0IGxpc3RlbmVycyBvbiB0aGUgcXVldWUuXG4gICAgICAgICAqIDxwPjxzdHJvbmc+SU1QT1JUQU5UOjwvc3Ryb25nPiBzaG91bGQgYmUgY2FsbGVkIG9ubHkgZHVyaW5nIHNpZ25hbCBkaXNwYXRjaCwgY2FsbGluZyBpdCBiZWZvcmUvYWZ0ZXIgZGlzcGF0Y2ggd29uJ3QgYWZmZWN0IHNpZ25hbCBicm9hZGNhc3QuPC9wPlxuICAgICAgICAgKiBAc2VlIFNpZ25hbC5wcm90b3R5cGUuZGlzYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgaGFsdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaC9Ccm9hZGNhc3QgU2lnbmFsIHRvIGFsbCBsaXN0ZW5lcnMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJhbXNdIFBhcmFtZXRlcnMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIGVhY2ggaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoIDogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXNBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYmluZGluZ3M7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1lbW9yaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IHBhcmFtc0FycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEgbikge1xuICAgICAgICAgICAgICAgIC8vc2hvdWxkIGNvbWUgYWZ0ZXIgbWVtb3JpemVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3Muc2xpY2UoKTsgLy9jbG9uZSBhcnJheSBpbiBjYXNlIGFkZC9yZW1vdmUgaXRlbXMgZHVyaW5nIGRpc3BhdGNoXG4gICAgICAgICAgICB0aGlzLl9zaG91bGRQcm9wYWdhdGUgPSB0cnVlOyAvL2luIGNhc2UgYGhhbHRgIHdhcyBjYWxsZWQgYmVmb3JlIGRpc3BhdGNoIG9yIGR1cmluZyB0aGUgcHJldmlvdXMgZGlzcGF0Y2guXG5cbiAgICAgICAgICAgIC8vZXhlY3V0ZSBhbGwgY2FsbGJhY2tzIHVudGlsIGVuZCBvZiB0aGUgbGlzdCBvciB1bnRpbCBhIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCBvciBzdG9wcyBwcm9wYWdhdGlvblxuICAgICAgICAgICAgLy9yZXZlcnNlIGxvb3Agc2luY2UgbGlzdGVuZXJzIHdpdGggaGlnaGVyIHByaW9yaXR5IHdpbGwgYmUgYWRkZWQgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgZG8geyBuLS07IH0gd2hpbGUgKGJpbmRpbmdzW25dICYmIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSAmJiBiaW5kaW5nc1tuXS5leGVjdXRlKHBhcmFtc0FycikgIT09IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yZ2V0IG1lbW9yaXplZCBhcmd1bWVudHMuXG4gICAgICAgICAqIEBzZWUgU2lnbmFsLm1lbW9yaXplXG4gICAgICAgICAqL1xuICAgICAgICBmb3JnZXQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbGwgYmluZGluZ3MgZnJvbSBzaWduYWwgYW5kIGRlc3Ryb3kgYW55IHJlZmVyZW5jZSB0byBleHRlcm5hbCBvYmplY3RzIChkZXN0cm95IFNpZ25hbCBvYmplY3QpLlxuICAgICAgICAgKiA8cD48c3Ryb25nPklNUE9SVEFOVDo8L3N0cm9uZz4gY2FsbGluZyBhbnkgbWV0aG9kIG9uIHRoZSBzaWduYWwgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkaXNwb3NlIHdpbGwgdGhyb3cgZXJyb3JzLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JpbmRpbmdzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ByZXZQYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnW1NpZ25hbCBhY3RpdmU6JysgdGhpcy5hY3RpdmUgKycgbnVtTGlzdGVuZXJzOicrIHRoaXMuZ2V0TnVtTGlzdGVuZXJzKCkgKyddJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgLy8gTmFtZXNwYWNlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIG5hbWVzcGFjZVxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbmFtZSBzaWduYWxzXG4gICAgICovXG4gICAgdmFyIHNpZ25hbHMgPSBTaWduYWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnQgYnJvYWRjYXN0ZXJcbiAgICAgKiBAc2VlIFNpZ25hbFxuICAgICAqL1xuICAgIC8vIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2VlICNnaC00NClcbiAgICBzaWduYWxzLlNpZ25hbCA9IFNpZ25hbDtcblxuXG5cbiAgICAvL2V4cG9ydHMgdG8gbXVsdGlwbGUgZW52aXJvbm1lbnRzXG4gICAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKXsgLy9BTURcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hbHM7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpeyAvL25vZGVcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzaWduYWxzO1xuICAgIH0gZWxzZSB7IC8vYnJvd3NlclxuICAgICAgICAvL3VzZSBzdHJpbmcgYmVjYXVzZSBvZiBHb29nbGUgY2xvc3VyZSBjb21waWxlciBBRFZBTkNFRF9NT0RFXG4gICAgICAgIC8qanNsaW50IHN1Yjp0cnVlICovXG4gICAgICAgIGdsb2JhbFsnc2lnbmFscyddID0gc2lnbmFscztcbiAgICB9XG5cbn0odGhpcykpO1xuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJykuc3R5bGUsXG4gICAgcHJlZml4ZXMgPSAnTyBtcyBNb3ogd2Via2l0Jy5zcGxpdCgnICcpLFxuICAgIGhhc1ByZWZpeCA9IC9eKG98bXN8bW96fHdlYmtpdCkvLFxuICAgIHVwcGVyID0gLyhbQS1aXSkvZyxcbiAgICBtZW1vID0ge307XG5cbmZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHJldHVybiAoa2V5IGluIG1lbW8pID8gbWVtb1trZXldIDogbWVtb1trZXldID0gcHJlZml4KGtleSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpeChrZXkpe1xuICAgIHZhciBjYXBpdGFsaXplZEtleSA9IGtleS5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbihzLCBtYXRjaCl7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSksXG4gICAgICAgIGkgPSBwcmVmaXhlcy5sZW5ndGgsXG4gICAgICAgIG5hbWU7XG5cbiAgICBpZiAoc3R5bGVbY2FwaXRhbGl6ZWRLZXldICE9PSB1bmRlZmluZWQpIHJldHVybiBjYXBpdGFsaXplZEtleTtcblxuICAgIGNhcGl0YWxpemVkS2V5ID0gY2FwaXRhbGl6ZShrZXkpO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBuYW1lID0gcHJlZml4ZXNbaV0gKyBjYXBpdGFsaXplZEtleTtcbiAgICAgICAgaWYgKHN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIHByZWZpeCAnICsga2V5KTtcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpe1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cbmZ1bmN0aW9uIGRhc2hlZFByZWZpeChrZXkpe1xuICAgIHZhciBwcmVmaXhlZEtleSA9IGdldChrZXkpLFxuICAgICAgICB1cHBlciA9IC8oW0EtWl0pL2c7XG5cbiAgICBpZiAodXBwZXIudGVzdChwcmVmaXhlZEtleSkpIHtcbiAgICAgICAgcHJlZml4ZWRLZXkgPSAoaGFzUHJlZml4LnRlc3QocHJlZml4ZWRLZXkpID8gJy0nIDogJycpICsgcHJlZml4ZWRLZXkucmVwbGFjZSh1cHBlciwgJy0kMScpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXhlZEtleS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbm1vZHVsZS5leHBvcnRzLmRhc2ggPSBkYXNoZWRQcmVmaXg7XG4iLCIvLyBaYW5pbW8uanMgLSBQcm9taXNlIGJhc2VkIENTUzMgdHJhbnNpdGlvbnNcbi8vIChjKSAyMDExLTIwMTQgUGF1bCBQYW5zZXJyaWV1XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFEgPSByZXF1aXJlKCdxJyksXG4gICAgUWFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgncWFuaW1hdGlvbmZyYW1lJyksXG4gICAgcHJlZml4ID0gcmVxdWlyZSgndmVuZG9yLXByZWZpeCcpLFxuICAgIG5vcm1hbGl6ZVRyYW5zZm9ybVZhbHVlID0gcmVxdWlyZSgnLi4vc3JjL25vcm1hbGl6ZS10cmFuc2Zvcm0tdmFsdWUnKSxcbiAgICBzaG9ydGhhbmQgPSByZXF1aXJlKCcuLi9zcmMvdHJhbnNpdGlvbi1zaG9ydGhhbmQtcHJvcGVydHknKSxcbiAgICB0cmFuc2l0aW9uID0gcHJlZml4KCd0cmFuc2l0aW9uJyksXG4gICAgdHJhbnNpdGlvbmVuZCA9ICdXZWJraXRUcmFuc2l0aW9uJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlID8gJ3dlYmtpdFRyYW5zaXRpb25FbmQnIDogJ3RyYW5zaXRpb25lbmQnLFxuXG4gICAgaXNET00gPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBlbCAmJiBlbC5ub2RlVHlwZTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYWRkVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChlbHQsIGF0dHIsIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nKSB7XG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBlbHQuc3R5bGVbdHJhbnNpdGlvbl07XG4gICAgICAgIGF0dHIgPSBwcmVmaXguZGFzaChhdHRyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgZWx0LnN0eWxlW3RyYW5zaXRpb25dID0gY3VycmVudFZhbHVlICsgXCIsIFwiICsgc2hvcnRoYW5kKGF0dHIsIGR1cmF0aW9uLCBlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlW3RyYW5zaXRpb25dID0gc2hvcnRoYW5kKGF0dHIsIGR1cmF0aW9uLCBlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsdC5zdHlsZVtwcmVmaXgoYXR0cildID0gdmFsdWU7XG4gICAgfSxcblxuICAgIHJlbW92ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoZWwsIGF0dHIpIHtcbiAgICAgICAgZWwuc3R5bGVbdHJhbnNpdGlvbl0gPSBlbC5zdHlsZVt0cmFuc2l0aW9uXVxuICAgICAgICAgICAgLnNwbGl0KCcsJykuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXQubWF0Y2goYXR0cik7XG4gICAgICAgICAgICB9KS5qb2luKCcsJyk7XG4gICAgfSxcblxuICAgIGFwcGx5Y3NzID0gZnVuY3Rpb24gKGVsLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gUWFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBlbC5zdHlsZVtwcmVmaXguZGFzaChhdHRyKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNzcyA9IGZ1bmN0aW9uIChlbCwgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgaWYoZWwuX3phbmltbyAmJiBlbC5femFuaW1vLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICBlbC5femFuaW1vW2F0dHJdLmRlZmVyLnJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJaYW5pbW8gdHJhbnNpdGlvbiB3aXRoIHRyYW5zZm9ybT1cIiArXG4gICAgICAgICAgICAgICAgZWwuX3phbmltb1thdHRyXS52YWx1ZSArXG4gICAgICAgICAgICAgICAgXCIgc3RvcHBlZCBieSB0cmFuc2Zvcm09XCIgKyB2YWx1ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBlbC5femFuaW1vW2F0dHJdLmNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5Y3NzKGVsLCBhdHRyLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGFuaW1hdGUgPSBmdW5jdGlvbiAoZWwsIGF0dHIsIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nKSB7XG4gICAgICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeC5kYXNoKGF0dHIpLFxuICAgICAgICAgICAgZCA9IFEuZGVmZXIoKSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBjYiA9IGZ1bmN0aW9uIChjbGVhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7IGNsZWFyVGltZW91dCh0aW1lb3V0KTsgdGltZW91dCA9IG51bGw7IH1cbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uKGVsLCBhdHRyKTtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25lbmQsIGNiVHJhbnNpdGlvbmVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyKSB7IGRlbGV0ZSBlbC5femFuaW1vW2F0dHJdOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2JUcmFuc2l0aW9uZW5kID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIGlmKHByZWZpeChldnQucHJvcGVydHlOYW1lKSA9PT0gcHJlZml4KHByZWZpeGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjYih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbmVuZCwgY2JUcmFuc2l0aW9uZW5kKTtcblxuICAgICAgICBRYW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbihlbCwgYXR0ciwgbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUodmFsdWUpLCBkdXJhdGlvbiwgZWFzaW5nKTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF3VmFsID0gZWwuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcmVmaXhlZCksXG4gICAgICAgICAgICAgICAgICAgIGRvbVZhbCA9IG5vcm1hbGl6ZVRyYW5zZm9ybVZhbHVlKHJhd1ZhbCksXG4gICAgICAgICAgICAgICAgICAgIGdpdmVuVmFsID0gbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2IodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbVZhbCA9PT0gZ2l2ZW5WYWwpIHsgZC5yZXNvbHZlKGVsKTsgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkLnJlamVjdCggbmV3IEVycm9yKFwiWmFuaW1vIHRyYW5zaXRpb246IHdpdGggXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYXR0ciArIFwiID0gXCIgKyBnaXZlblZhbCArIFwiLCBET00gdmFsdWU9XCIgKyBkb21WYWxcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZHVyYXRpb24gKyAyMCApO1xuXG4gICAgICAgICAgICBlbC5femFuaW1vID0gZWwuX3phbmltbyB8fCB7IH07XG4gICAgICAgICAgICBpZihlbC5femFuaW1vW2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgZWwuX3phbmltb1thdHRyXS5kZWZlci5yZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlphbmltbyB0cmFuc2l0aW9uIHdpdGggXCIgK1xuICAgICAgICAgICAgICAgICAgICBhdHRyICsgXCI9XCIgKyBlbC5femFuaW1vW2F0dHJdLnZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgXCIgc3RvcHBlZCBieSB0cmFuc2l0aW9uIHdpdGggXCIgKyBhdHRyICsgXCI9XCIgKyB2YWx1ZVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIGVsLl96YW5pbW9bYXR0cl0uY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLl96YW5pbW9bYXR0cl0gPSB7Y2I6IGNiLCB2YWx1ZTogdmFsdWUsIGRlZmVyOiBkfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGQucHJvbWlzZTtcbiAgICB9O1xuXG4vKipcbiAqIFphbmltbyhlbCB8IHByb21pc2VbZWxdKVxuICogPiBSZXR1cm5zIGEgUHJvbWlzZSBvZiBlbC5cbiAqXG4gKiBaYW5pbW8oZWwgfCBwcm9taXNlW2VsXSwgYXR0ciwgdmFsdWUpXG4gKiA+IFNldHMgZWwuc3R5bGVbYXR0cl09dmFsdWUgYW5kIHJldHVybnMgdGhlIHByb21pc2Ugb2YgZWwuXG4gKlxuICogWmFuaW1vKGVsIHwgcHJvbWlzZVtlbF0sIGF0dHIsIHZhbHVlLCBkdXJhdGlvbiwgW2Vhc2luZ10pXG4gKiA+IFBlcmZvcm1zIGEgdHJhbnNpdGlvbi5cbiAqL1xudmFyIFphbmltbyA9IGZ1bmN0aW9uIChlbCwgYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgYXJpdHkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChhcml0eSA9PT0gMCB8fCBhcml0eSA9PT0gMiB8fCBhcml0eSA+IDUpIHtcbiAgICAgICAgcmV0dXJuIFEucmVqZWN0KG5ldyBFcnJvcihcIlphbmltbyBpbnZhbGlkIGFyZ3VtZW50c1wiKSk7XG4gICAgfVxuICAgIGlmIChRLmlzUHJvbWlzZShlbCkpIHtcbiAgICAgICAgcmV0dXJuIGVsLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIFphbmltby5hcHBseSh0aGlzLCBbdmFsXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaXNET00oZWwpKSB7XG4gICAgICAgIHJldHVybiBRLnJlamVjdChuZXcgRXJyb3IoXCJaYW5pbW8gcmVxdWlyZSBhbiBIVE1MRWxlbWVudCwgb3IgYSBwcm9taXNlIG9mIGFuIEhUTUxFbGVtZW50XCIpKTtcbiAgICB9XG4gICAgaWYgKGFyaXR5ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBRKGVsKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcHJlZml4LmRhc2goYXR0cik7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFEucmVqZWN0KG5ldyBFcnJvcihcIlphbmltbyB0cmFuc2l0aW9uOiBcIiArIGF0dHIgKyAnIGlzIG5vdCBzdXBwb3J0ZWQhJykpO1xuICAgIH07XG4gICAgaWYgKGFyaXR5ID09PSAzKSB7XG4gICAgICAgIHJldHVybiBjc3MoZWwsIGF0dHIsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYod2luZG93LmlzTmFOKHBhcnNlSW50KGR1cmF0aW9uLCAxMCkpKSB7XG4gICAgICAgIHJldHVybiBRLnJlamVjdChuZXcgRXJyb3IoXCJaYW5pbW8gdHJhbnNpdGlvbjogZHVyYXRpb24gbXVzdCBiZSBhbiBpbnRlZ2VyIVwiKSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRlKGVsLCBhdHRyLCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZyk7XG59O1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gd3JhcHBpbmcgYFphbmltbyhlbCwgLi4uKWAgYXMgYSBgZiguLi4pKGVsKWAgZm9yIGVhc3kgY2hhaW5pbmcgcHVycG9zZS5cbiAqL1xuWmFuaW1vLmYgPSBmdW5jdGlvbiAoYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gWmFuaW1vLmFwcGx5KHRoaXMsIFtlbF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBaYW5pbW87XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRjaFBhcmVudGhlc2lzID0gLyhcXCguKz9cXCkpL2csXG4gICAgc3BhY2UgPSAvICsvZyxcbiAgICBlbXB0eVN0cmluZyA9IFwiXCIsXG4gICAgd2hpdGVzcGFjZSA9IFwiIFwiLFxuXG4gICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHZhciBhcmdzID0gbWF0Y2guc3Vic3RyKDEsIG1hdGNoLmxlbmd0aC0yKS5zcGxpdChcIixcIiksXG4gICAgICAgICAgICByc3QgPSBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYXJnLnJlcGxhY2Uoc3BhY2UsIGVtcHR5U3RyaW5nKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgcnN0LmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAgdHlwZW9mIHQgPT09ICdzdHJpbmcnID8gdC5yZXBsYWNlKHNwYWNlLCB3aGl0ZXNwYWNlKS5yZXBsYWNlKG1hdGNoUGFyZW50aGVzaXMsIG5vcm1hbGl6ZSkgOiB0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbG9yID0gcmVxdWlyZSgnY29sb3InKSxcbiAgICBtYXRjaFBhcmVudGhlc2lzID0gLyhcXCguKz9cXCkpL2csXG4gICAgbWF0Y2hDb2xvcnMgPSAvKFxcYnJnYmFcXGJ8XFxiaHNsXFxifFxcYmhzbGFcXGIpKFxcKC4rP1xcKSkvZyxcbiAgICBzcGFjZSA9IC8gKy9nLFxuICAgIGVtcHR5U3RyaW5nID0gXCJcIixcbiAgICB3aGl0ZXNwYWNlID0gXCIgXCIsXG4gICAgemVyb3BpeGVsID0gL14wcHgkL2csXG4gICAgemVybyA9IFwiMFwiLFxuXG4gICAgbm9ybUFyZ3MgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5zdWJzdHIoMSwgbWF0Y2gubGVuZ3RoLTIpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICAgIHJzdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnJlcGxhY2Uoc3BhY2UsIGVtcHR5U3RyaW5nKS5yZXBsYWNlKHplcm9waXhlbCwgemVybyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgcnN0LmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfSxcblxuICAgIG5vcm1Db2xvcnMgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGMgPSBDb2xvcihtYXRjaCk7XG4gICAgICAgIGlmIChjLmFscGhhKCkgKSB7IGMuYWxwaGEoTWF0aC5yb3VuZChjLmFscGhhKCkgKiAxMCkgLyAxMCk7IH1cbiAgICAgICAgcmV0dXJuIGMucmdiU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5yZXBsYWNlKHNwYWNlLCB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgLnJlcGxhY2UobWF0Y2hDb2xvcnMsIG5vcm1Db2xvcnMpXG4gICAgICAgICAgICAucmVwbGFjZShtYXRjaFBhcmVudGhlc2lzLCBub3JtQXJncyk7XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGVtcHR5U3RyaW5nO1xuICAgIHJldHVybiB3aW5kb3cuaXNOYU4odmFsKSA/IG5vcm1hbGl6ZSh2YWwpIDogdmFsLnRvU3RyaW5nKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJlZml4ID0gcmVxdWlyZSgndmVuZG9yLXByZWZpeCcpLFxuICAgIG5vcm1hbGl6ZVRyYW5zZm9ybVZhbHVlID0gcmVxdWlyZSgnLi9ub3JtYWxpemUtdHJhbnNmb3JtLXZhbHVlJyksXG4gICAgbm9ybWFsaXplVGltaW5nRnVuY3Rpb24gPSByZXF1aXJlKCcuL25vcm1hbGl6ZS10aW1pbmctZnVuY3Rpb24nKSxcbiAgICB0cmFuc2l0aW9uID0gcHJlZml4LmRhc2goJ3RyYW5zaXRpb24nKSxcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHRlc3QgPSAnb3BhY2l0eSAxMDBtcyBsaW5lYXIgMHMnLFxuICAgIG5vcm1hbGl6ZWRUZXN0ID0gbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUodGVzdCksXG4gICAgc2hvcnRoYW5kID0gZnVuY3Rpb24gc2hvcnRoYW5kKHYsIGQsIHQpIHtcbiAgICAgICAgcmV0dXJuIHYgKyBcIiBcIiArIGQgKyBcIm1zIFwiICsgKHQgfHwgXCJsaW5lYXJcIik7XG4gICAgfTtcblxuZWwuc3R5bGVbdHJhbnNpdGlvbl0gPSBub3JtYWxpemVkVGVzdDtcblxuaWYobm9ybWFsaXplVHJhbnNmb3JtVmFsdWUoZWwuc3R5bGVbdHJhbnNpdGlvbl0pID09PSBub3JtYWxpemVkVGVzdCkge1xuICAgIHNob3J0aGFuZCA9IGZ1bmN0aW9uICh2LCBkLCB0KSB7XG4gICAgICAgIHJldHVybiB2ICsgXCIgXCIgKyBkICsgXCJtcyBcIiArIChub3JtYWxpemVUaW1pbmdGdW5jdGlvbih0KSB8fCBcImxpbmVhclwiKSArIFwiIDBzXCI7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydGhhbmQ7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICdsb2Rhc2gvaXNGdW5jdGlvbic7XG5pbXBvcnQgaTE4biBmcm9tICcuL2kxOG4nO1xuaW1wb3J0IHsgYmFja0hpc3RvcnkgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiYWNrYnV0dG9uKCkge1xuICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuICBpZiAoaXNGdW5jdGlvbihiKSkge1xuICAgIGIoJ2JhY2tidXR0b24nKTtcbiAgICBtLnJlZHJhdygpO1xuICB9IGVsc2UgaWYgKCEvXlxcLyQvLnRlc3QobS5yb3V0ZSgpKSkge1xuICAgIC8vIGlmIHBsYXlpbmcgYSBnYW1lIGFzIGFub24gYXNrIGZvciBjb25maXJtYXRpb25cbiAgICBpZiAoL15cXC9nYW1lXFwvW2EtekEtWjAtOV17MTJ9Ly50ZXN0KG0ucm91dGUoKSkpIHtcbiAgICAgIG5hdmlnYXRvci5ub3RpZmljYXRpb24uY29uZmlybShcbiAgICAgICAgaTE4bigndGhlcmVJc0FHYW1lSW5Qcm9ncmVzcycpLFxuICAgICAgICBpID0+IHsgaWYgKGk9PT0xKSBiYWNrSGlzdG9yeSgpOyB9XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrSGlzdG9yeSgpO1xuICAgIH1cbiAgfWVsc2Uge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgfVxufTtcblxuYmFja2J1dHRvbi5zdGFjayA9IHN0YWNrO1xuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5pbXBvcnQgc3Bpbm5lciBmcm9tICcuL3NwaW5uZXInO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBjb25zdCBhcGlWZXJzaW9uID0gMTtcblxuY29uc3QgYmFzZVVybCA9IHdpbmRvdy5veXVua2V5Zi5hcGlFbmRQb2ludDtcblxuZnVuY3Rpb24gb25TdWNjZXNzKGRhdGEpIHtcbiAgc3Bpbm5lci5zdG9wKCk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBvbkVycm9yKGRhdGEpIHtcbiAgc3Bpbm5lci5zdG9wKCk7XG4gIHRocm93IGRhdGE7XG59XG5cbmZ1bmN0aW9uIHhockNvbmZpZyh4aHIpIHtcbiAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcbiAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi92bmQub3l1bmtleWYudicgKyBhcGlWZXJzaW9uICsgJytqc29uJyk7XG4gIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICB4aHIudGltZW91dCA9IDgwMDA7XG59XG5cbi8vIGNvbnZlbmllbnQgd3JhcHBlciBhcm91bmQgbS5yZXF1ZXN0XG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdHMsIGZlZWRiYWNrLCB4aHJDb25mKSB7XG4gIHZhciBjZmcgPSB7XG4gICAgdXJsOiBiYXNlVXJsICsgdXJsLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgZGF0YTogeyB9LFxuICAgIGNvbmZpZzogeGhyQ29uZiB8fCB4aHJDb25maWcsXG4gICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyB7IHJlc3BvbnNlOiB7IGVycm9yOiAnQ2Fubm90IHJlYWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXInIH19O1xuICAgICAgfVxuICAgIH0sXG4gICAgdW53cmFwRXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlLCB4aHIpIHtcbiAgICAgIHJldHVybiB7IHJlc3BvbnNlLCBzdGF0dXM6IHhoci5zdGF0dXMgfTtcbiAgICB9XG4gIH07XG4gIG1lcmdlKGNmZywgb3B0cyk7XG5cbiAgaWYgKGNmZy5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgY2ZnLmRhdGEuXyA9IERhdGUubm93KCk7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG0ucmVxdWVzdChjZmcpO1xuXG4gIGlmIChmZWVkYmFjaykge1xuICAgIHNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5KTtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0gXG4iLCJpbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxudmFyIG1lc3NhZ2VzID0gW107XG5cbmNvbnN0IHVudHJhbnNsYXRlZCA9IHtcbn07XG5cbmNvbnN0IGRlZmF1bHRDb2RlID0gJ3RyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaTE4bihrZXkpIHtcbiAgdmFyIHN0ciA9IG1lc3NhZ2VzW2tleV0gfHwgdW50cmFuc2xhdGVkW2tleV18fCBrZXk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoJyVzJywgYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFByZWZlcnJlZExhbmd1YWdlKCkge1xuICBpZiAoc2V0dGluZ3MuZ2VuZXJhbC5sYW5nKCkpXG4gICAgcmV0dXJuIGxvYWRGcm9tU2V0dGluZ3MoKTtcblxuICAvLyB2YXIgZGVmZXJyZWQgPSBtLmRlZmVycmVkKCk7XG4gIC8vIHdpbmRvdy5uYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbi5nZXRQcmVmZXJyZWRMYW5ndWFnZShcbiAgLy8gICBsYW5ndWFnZSA9PiBkZWZlcnJlZC5yZXNvbHZlKGxhbmd1YWdlLnZhbHVlLnNwbGl0KCctJylbMF0pLFxuICAvLyAgICgpID0+IGRlZmVycmVkLnJlc29sdmUoZGVmYXVsdENvZGUpKTtcblxuICAvLyByZXR1cm4gZGVmZXJyZWQucHJvbWlzZS50aGVuKGNvZGUgPT4ge1xuICAvLyAgIHNldHRpbmdzLmdlbmVyYWwubGFuZyhjb2RlKTtcbiAgLy8gICByZXR1cm4gY29kZTtcbiAgLy8gfSlcbiAgLy8gICAudGhlbihsb2FkRmlsZSlcbiAgLy8gICAudGhlbihsb2FkTW9tZW50TG9jYWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF2YWlsYWJsZUxhbmd1YWdlcygpIHtcbiAgcmV0dXJuIG0ucmVxdWVzdCh7XG4gICAgdXJsOiAnaTE4bi9yZWZzLmpzb24nLFxuICAgIG1ldGhvZDogJ0dFVCdcbiAgfSkudGhlbihkYXRhID0+IHsgcmV0dXJuIGRhdGE7IH0sIGVycm9yID0+IHtcbiAgICAvLyBzYW1lIHdvcmthcm91bmQgZm9yIGlPUyBhcyBhYm92ZVxuICAgIGlmIChlcnJvciAmJiBlcnJvclswXVswXSA9PT0gJ3RyJylcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICBlbHNlXG4gICAgICB0aHJvdyB7IGVycm9yOiAnQ2Fubm90IGxvYWQgbGFuZ3VhZ2VzJyB9O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRGcm9tU2V0dGluZ3MoKSB7XG4gIHJldHVybiBsb2FkRmlsZShzZXR0aW5ncy5nZW5lcmFsLmxhbmcoKSkudGhlbihsb2FkTW9tZW50TG9jYWxlKTtcbn1cblxuZnVuY3Rpb24gbG9hZEZpbGUoY29kZSkge1xuICByZXR1cm4gbS5yZXF1ZXN0KHtcbiAgICB1cmw6ICdpMThuLycgKyBjb2RlICsgJy5qc29uJyxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgeyBlcnJvcjogJ0xhbmcgbm90IGF2YWlsYWJsZScgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgIG1lc3NhZ2VzID0gZGF0YTtcbiAgICByZXR1cm4gY29kZTtcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAvLyB3b3JrYXJvdW5kIGZvciBpT1M6IGJlY2F1c2UgeGhyIGZvciBsb2NhbCBmaWxlIGhhcyBhIDAgc3RhdHVzIGl0IHdpbGxcbiAgICAvLyByZWplY3QgdGhlIHByb21pc2UgYW5kIHN0aWxsIGhhdmUgdGhlIHJlc3BvbnNlIG9iamVjdFxuICAgIGlmIChlcnJvciAmJiBlcnJvci5wbGF5V2l0aEFGcmllbmQpIHtcbiAgICAgIG1lc3NhZ2VzID0gZXJyb3I7XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvZGUgPT09IGRlZmF1bHRDb2RlKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGxvYWRGaWxlKGRlZmF1bHRDb2RlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb2FkTW9tZW50TG9jYWxlKGNvZGUpIHtcbiAgaWYgKGNvZGUgIT09ICdlbicpIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnNyYyA9ICdtb21lbnQvbG9jYWxlLycgKyBjb2RlICsgJy5qcyc7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHdpbmRvdy5tb21lbnQubG9jYWxlKGNvZGUpO1xuICByZXR1cm4gY29kZTtcbn1cbiIsIi8qIGFwcGxpY2F0aW9uIGVudHJ5IHBvaW50ICovXG5cbi8vIGltcG9ydCAnLi9wb2x5ZmlsbHMnO1xuXG5cbi8vIGZvciBtb21lbnQgYSBnbG9iYWwgb2JqZWN0IG1ha2VzIGxvYWRpbmcgbG9jYWxlcyBlYXNpZXJcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbndpbmRvdy5tb21lbnQgPSBtb21lbnQ7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuL3Nlc3Npb24nO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgbG9hZFByZWZlcnJlZExhbmd1YWdlIH0gZnJvbSAnLi9pMThuJztcbmltcG9ydCB7IHN0YXR1cyBhcyB4aHJTdGF0dXMsIHNldFNlcnZlckxhbmcgfSBmcm9tICcuL3hocic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi91aS9oZWxwZXInO1xuaW1wb3J0IGJhY2tidXR0b24gZnJvbSAnLi9iYWNrYnV0dG9uJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi9zb2NrZXQnO1xuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcyc7XG5pbXBvcnQgeyBpc0ZvcmVncm91bmQsIHNldEZvcmVncm91bmQsIHNldEJhY2tncm91bmQgfSBmcm9tICcuL3V0aWxzL2FwcE1vZGUnO1xuXG5mdW5jdGlvbiBtYWluKCkge1xuICByb3V0ZXMuaW5pdCgpO1xuICAvLyBjYWNoZSB2aWV3cG9ydCBkaW1zXG4gIGhlbHBlci52aWV3cG9ydERpbSgpO1xuXG4gIC8vIHB1bGwgc2Vzc2lvbiBkYXRhIG9uY2UgKHRvIGxvZyBpbiB1c2VyIGF1dG9tYXRpY2FsbHkgdGhhbmtzIHRvIGNvb2tpZSlcbiAgLy8gYW5kIGFsc28gbGlzdGVuIHRvIG9ubGluZSBldmVudCBpbiBjYXNlIG5ldHdvcmsgd2FzIGRpc2Nvbm5lY3RlZCBhdCBhcHBcbiAgLy8gc3RhcnR1cFxuICBpZiAodXRpbHMuaGFzTmV0d29yaygpKSB7XG4gICAgLy8gb25PbmxpbmUoKTtcbiAgfVxuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIG9uT25saW5lLCBmYWxzZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBvbk9mZmxpbmUsIGZhbHNlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgb25SZXN1bWUsIGZhbHNlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBvblBhdXNlLCBmYWxzZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBiYWNrYnV0dG9uLCBmYWxzZSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBmdW5jdGlvbigpIHtcbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgIHNvY2tldC50ZXJtaW5hdGUoKTtcbiAgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSwgZmFsc2UpO1xuXG4gIGlmIChjb3Jkb3ZhLnBsYXRmb3JtSWQgPT09ICdhbmRyb2lkJykge1xuICAgIHdpbmRvdy5TdGF0dXNCYXIuYmFja2dyb3VuZENvbG9yQnlIZXhTdHJpbmcoJyMxNTFBMUUnKTtcbiAgfVxuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgd2luZG93Lm5hdmlnYXRvci5zcGxhc2hzY3JlZW4uaGlkZSgpO1xuICAgIHdpbmRvdy5TdGF0dXNCYXIuaGlkZSgpO1xuICAgIC8vIHhoclN0YXR1cygpO1xuICB9LCA1MDApO1xufVxuXG5mdW5jdGlvbiBvbk9ubGluZSgpIHtcbiAgaWYgKGlzRm9yZWdyb3VuZCgpKSB7XG4gICAgc2Vzc2lvbi5yZW1lbWJlckxvZ2luKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiBzZXRTZXJ2ZXJMYW5nKHNldHRpbmdzLmdlbmVyYWwubGFuZygpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25PZmZsaW5lKCkge1xuICBpZiAoaXNGb3JlZ3JvdW5kKCkpIHtcbiAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgIG0ucmVkcmF3KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gIGhlbHBlci5jbGVhckNhY2hlZFZpZXdwb3J0RGltKCk7XG4gIG0ucmVkcmF3KCk7XG59XG5cbmZ1bmN0aW9uIG9uUmVzdW1lKCkge1xuICBzZXRGb3JlZ3JvdW5kKCk7XG4gIHNvY2tldC5jb25uZWN0KCk7XG59XG5cbmZ1bmN0aW9uIG9uUGF1c2UoKSB7XG4gIHNldEJhY2tncm91bmQoKTtcbiAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbn1cblxuLy8gZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXZlbnQsIHNvdXJjZSwgZmlsZW5vLCBjb2x1bU51bWJlcikge1xuLy8gICB2YXIgZGVzY3JpcHRpb24gPSBldmVudCArICcgYXQgJyArIHNvdXJjZSArICcgWycgKyBmaWxlbm8gKyAnLCAnICsgY29sdW1OdW1iZXIgKyAnXSc7XG4vLyB9XG5cbi8vIHdpbmRvdy5vbmVycm9yID0gaGFuZGxlRXJyb3I7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gbWFpbigpLCAvL2xvYWRQcmVmZXJyZWRMYW5ndWFnZSgpLnRoZW4obWFpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiIsImltcG9ydCBpMThuIGZyb20gJy4uL2kxOG4nO1xuaW1wb3J0IHN0YXR1cyBmcm9tICcuL3N0YXR1cyc7XG5cbmZ1bmN0aW9uIHBsYXlhYmxlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuZ2FtZS5zdGF0dXMuaWQgPCBzdGF0dXMuaWRzLmFib3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzUGxheWVyUGxheWluZyhkYXRhKSB7XG4gIHJldHVybiBwbGF5YWJsZShkYXRhKSAmJiAhZGF0YS5wbGF5ZXIuc3BlY3RhdG9yO1xufVxuXG5mdW5jdGlvbiBpc1BsYXllclR1cm4oZGF0YSkge1xuICByZXR1cm4gaXNQbGF5ZXJQbGF5aW5nKGRhdGEpICYmIGRhdGEuZ2FtZS5wbGF5ZXIgPT09IGRhdGEucGxheWVyLnNpZGU7XG59XG5cbmZ1bmN0aW9uIGdldFBsYXllcihkYXRhLCBzaWRlKSB7XG4gIHJldHVybiBbJ3BsYXllcicsICdvcHBvbmVudExlZnQnLCAnb3Bwb25lbnRSaWdodCcsICdvcHBvbmVudFVwJ11cbiAgICAubWFwKGsgPT4gZGF0YVtrXSlcbiAgICAuZmlsdGVyKHBsYXllciA9PiBwbGF5ZXIuc2lkZSA9PT0gc2lkZSlbMF07XG59XG5cbmZ1bmN0aW9uIHJlc3VsdChkYXRhKSB7XG4gIGlmIChzdGF0dXMuYWJvcnRlZChkYXRhKSkge1xuICAgIHJldHVybiBpMThuKCdnYW1lQWJvcnRlZCcpO1xuICB9IGVsc2UgaWYgKHN0YXR1cy5maW5pc2hlZChkYXRhKSkge1xuICAgIHJldHVybiBpMThuKCdnYW1lRmluaXNoZWQnKTtcbiAgfVxufTtcblxuY29uc3Qgc2lkZXMgPSBbXCJlYXN0XCIsIFwibm9ydGhcIiwgXCJ3ZXN0XCIsIFwic291dGhcIl07XG5cbmZ1bmN0aW9uIHNpZGVCeVBseShwbHkpIHtcbiAgcmV0dXJuIHNpZGVzW3BseSAlIDRdO1xufVxuXG5mdW5jdGlvbiBzZXRPbkdhbWUoZGF0YSwgc2lkZSwgb25HYW1lKSB7XG4gIHZhciBwbGF5ZXIgPSBnZXRQbGF5ZXIoZGF0YSwgc2lkZSk7XG4gIHBsYXllci5vbkdhbWUgPSBvbkdhbWU7XG59XG5cbi8vIGZ1bmN0aW9uIHJvdW5kc09yU2NvcmVzKGdhbWUpIHtcbi8vICAgaWYgKGdhbWUucm91bmRzKSB7XG4vLyAgICAgcmV0dXJuIGRhdGEuXG4vLyAgIH0gZWxzZSBpZiAoZGF0YS5zY29yZXMpIHtcbiAgICBcbi8vICAgfSBlbHNlIHtcbi8vICAgICByZXR1cm4gJyc7XG4vLyAgIH1cbi8vIH1cblxuZnVuY3Rpb24gdGl0bGUoZGF0YSkge1xuICB2YXIgdGV4dDtcbiAgaWYgKGlzUGxheWVyVHVybihkYXRhKSkge1xuICAgIHRleHQgPSBpMThuKCd5b3VyVHVybicpO1xuICB9IGVsc2Uge1xuICAgIHRleHQgPSBpMThuKCd3YWl0aW5nRm9yT3Bwb25lbnQnKTtcbiAgfVxuICAvLyBjb25zdCB2YXJpYW50ID0gZ2V0VmFyaWFudChkYXRhLmdhbWUudmFyaWFudC5rZXkpO1xuICAvLyBjb25zdCBuYW1lID0gdmFyaWFudCA/ICh2YXJpYW50LnNob3J0TmFtZSB8fCB2YXJpYW50Lm5hbWUpIDogJyc7XG4gIHJldHVybiB0ZXh0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzUGxheWVyUGxheWluZyxcbiAgaXNQbGF5ZXJUdXJuLFxuICBnZXRQbGF5ZXIsXG4gIHNpZGVCeVBseSxcbiAgcGxheWFibGUsXG4gIHNldE9uR2FtZSxcbiAgdGl0bGUsXG4gIHJlc3VsdFxufTtcbiIsIi8vIHNjYWxhb2tleS9zcmMvbWFpbi9zY2FsYS9TdGF0dXMuc2NhbGFcblxuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5cbmNvbnN0IGlkcyA9IHtcbiAgY3JlYXRlZDogMTAsXG4gIHN0YXJ0ZWQ6IDIwLFxuICBhYm9ydGVkOiAyNSxcbiAgbWlkZGxlRW5kOiAzMCxcbiAgbm9ybWFsRW5kOiA0MCxcbiAgdmFyaWFudEVuZDogNzBcbn07XG5cbmZ1bmN0aW9uIHN0YXJ0ZWQoZGF0YSkge1xuICByZXR1cm4gZGF0YS5nYW1lLnN0YXR1cy5pZCA+PSBpZHMuc3RhcnRlZDtcbn1cblxuZnVuY3Rpb24gZmluaXNoZWQoZGF0YSkge1xuICByZXR1cm4gZGF0YS5nYW1lLnN0YXR1cy5pZCA+PSBpZHMubWlkZGxlRW5kO1xufVxuXG5mdW5jdGlvbiBhYm9ydGVkKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuZ2FtZS5zdGF0dXMuaWQgPT09IGlkcy5hYm9ydGVkO1xufVxuXG5mdW5jdGlvbiBtaWRkbGVFbmQoZGF0YSkge1xuICByZXR1cm4gZGF0YS5nYW1lLnN0YXR1cy5pZCA9PT0gaWRzLm1pZGRsZUVuZDtcbn1cblxuXG5mdW5jdGlvbiBwbGF5aW5nKGRhdGEpIHtcbiAgcmV0dXJuIHN0YXJ0ZWQoZGF0YSkgJiYgIWZpbmlzaGVkKGRhdGEpICYmICFhYm9ydGVkKGRhdGEpO1xufVxuXG5mdW5jdGlvbiB0b0xhYmVsKHN0YXR1cywgd2lubmVyLCB2YXJpYW50KSB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gIGNhc2UgJ3N0YXJ0ZWQnOlxuICAgIHJldHVybiBpMThuKCdwbGF5aW5nUmlnaHROb3cnKTtcbiAgY2FzZSAnYWJvcnRlZCc6XG4gICAgcmV0dXJuIGkxOG4oJ2dhbWVBYm9ydGVkJyk7XG4gIGNhc2UgJ21pZGRsZUVuZCc6XG4gICAgcmV0dXJuIGkxOG4oJ2dhbWVNaWRkbGVGaW5pc2hlZCcpO1xuICBjYXNlICdub3JtYWxFbmQnOlxuICAgIHJldHVybiBpMThuKCdnYW1lRmluaXNoZWQnKTtcbiAgY2FzZSAndmFyaWFudEVuZCc6XG4gICAgcmV0dXJuIGkxOG4oJ2dhbWVGaW5pc2hlZCcpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkcyxcbiAgc3RhcnRlZCxcbiAgZmluaXNoZWQsXG4gIGFib3J0ZWQsXG4gIHBsYXlpbmcsXG4gIG1pZGRsZUVuZCxcbiAgdG9MYWJlbFxufTtcbiIsImltcG9ydCBSbGl0ZSBmcm9tICdybGl0ZS1yb3V0ZXInO1xuaW1wb3J0ICogYXMgUmVuZGVyU2VydmljZSBmcm9tICdtaXRocmlsL3JlbmRlcic7XG5pbXBvcnQgVm5vZGUgZnJvbSAnbWl0aHJpbC9yZW5kZXIvdm5vZGUnO1xuaW1wb3J0IHNpZ25hbHMgZnJvbSAnLi9zaWduYWxzJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi91dGlscy9yZWRyYXcnO1xuXG5jb25zdCByb3V0ZXIgPSBuZXcgUmxpdGUoKTtcblxubGV0IGN1cnJlbnRTdGF0ZUlkID0gMDtcbmxldCB2aWV3U2xpZGVEaXJlY3Rpb24gPSAnZndkJztcblxubGV0IHByZXZpb3VzUGF0aCA9ICcvJztcblxuY29uc3QgYmFja2J1dHRvbiA9ICgoKSA9PiB7XG4gIGNvbnN0IHggPSAoKSA9PiB7XG5cbiAgICBjb25zdCBiID0gKHguc3RhY2subGVuZ3RoID09PSAwKSA/bnVsbDp4LnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oYikpIHtcbiAgICAgIGIoJ2JhY2tidXR0b24nKTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH0gZWxzZSBpZiAoIS9eXFwvJC8udGVzdChnZXQoKSkpIHtcbiAgICAgIGJhY2tIaXN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgICB9XG4gICAgXG4gIH07XG5cbiAgeC5zdGFjayA9IFtdO1xuICBcbiAgcmV0dXJuIHg7XG59KSgpO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUm91dGVzKG1vdW50UG9pbnQsIHJvdXRlcykge1xuXG4gIGZvciAobGV0IHJvdXRlIGluIHJvdXRlcykge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlc1tyb3V0ZV07XG4gICAgcm91dGVyLmFkZChyb3V0ZSwgZnVuY3Rpb24gb25Sb3V0ZU1hdGNoKHsgcGFyYW1zIH0pIHtcbiAgICAgIGNvbnN0IFJvdXRlQ29tcG9uZW50ID0geyB2aWV3KCkge1xuICAgICAgICB2YXIgbm9kZSA9IFZub2RlKGNvbXBvbmVudCwgdW5kZWZpbmVkLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH19O1xuXG4gICAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICAgIFJlbmRlclNlcnZpY2UucmVuZGVyKG1vdW50UG9pbnQsIFZub2RlKFJvdXRlQ29tcG9uZW50KSk7XG4gICAgICB9XG5cbiAgICAgIHNpZ25hbHMucmVkcmF3LnJlbW92ZUFsbCgpO1xuICAgICAgc2lnbmFscy5yZWRyYXcuYWRkKHJlZHJhdyk7XG4gICAgICB0cnkge1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2lnbmFscy5yZWRyYXcucmVtb3ZlQWxsKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgcHJvY2Vzc1F1ZXJ5c3RyaW5nKTtcbiAgcHJvY2Vzc1F1ZXJ5c3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NRdWVyeXN0cmluZyhlKSB7XG4gIGlmIChlICYmIGUuc3RhdGUpIHtcbiAgICBpZiAoZS5zdGF0ZS5pZCA8IGN1cnJlbnRTdGF0ZUlkKSB7XG4gICAgICB2aWV3U2xpZGVEaXJlY3Rpb24gPSAnYndkJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld1NsaWRlRGlyZWN0aW9uID0gJ2Z3ZCc7XG4gICAgfVxuICAgIGN1cnJlbnRTdGF0ZUlkID0gZS5zdGF0ZS5pZDtcbiAgfVxuICBwcmV2aW91c1BhdGggPSBnZXQoKTtcbiAgY29uc3QgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8ICc/PSc7XG4gIGNvbnN0IG1hdGNoZWQgPSByb3V0ZXIucnVuKHFzLnNsaWNlKDIpKTtcbiAgaWYgKCFtYXRjaGVkKSByb3V0ZXIucnVuKCcvJyk7XG59XG5cbmZ1bmN0aW9uIGdldCgpIHtcbiAgY29uc3QgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgJz89Lyc7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGF0aC5zdWJzdHJpbmcoMikpO1xufVxuXG5mdW5jdGlvbiBiYWNrSGlzdG9yeSgpIHtcbiAgd2luZG93Lmhpc3RvcnkuZ28oLTEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGJhY2tidXR0b25cbn07XG4iLCJpbXBvcnQgaG9tZSBmcm9tICcuL3VpL2hvbWUnO1xuaW1wb3J0IGdhbWUgZnJvbSAnLi91aS9nYW1lJztcbmltcG9ydCB1c2VyIGZyb20gJy4vdWkvdXNlcic7XG5pbXBvcnQgcGxheWVycyBmcm9tICcuL3VpL3BsYXllcnMnO1xuaW1wb3J0IG1hc2FEZXRhaWwgZnJvbSAnLi91aS9tYXNhL2RldGFpbCc7XG5pbXBvcnQgbWFzYSBmcm9tICcuL3VpL21hc2EnO1xuaW1wb3J0IHNldHRpbmdzVWkgZnJvbSAnLi91aS9zZXR0aW5ncyc7XG5pbXBvcnQgc2V0dGluZ3NMYW5nIGZyb20gJy4vdWkvc2V0dGluZ3MvbGFuZyc7XG5pbXBvcnQgeyBkZWZpbmVSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCgpIHtcbiAgICBkZWZpbmVSb3V0ZXMoZG9jdW1lbnQuYm9keSwge1xuICAgICAgJyc6IGhvbWUsXG4gICAgICAnL0AvOmlkJzogdXNlcixcbiAgICAgICcvcGxheWVycyc6IHBsYXllcnMsXG4gICAgICAnL2dhbWUvOmlkJzogZ2FtZSxcbiAgICAgICcvbWFzYSc6IG1hc2EsXG4gICAgICAnL21hc2EvOmlkJzogbWFzYURldGFpbCxcbiAgICAgICcvbWFzYS86bWFzYUlkL2dhbWUvOmlkJzogZ2FtZSxcbiAgICAgICcvc2V0dGluZ3MnOiBzZXR0aW5nc1VpLFxuICAgICAgJy9zZXR0aW5ncy9sYW5nJzogc2V0dGluZ3NMYW5nLFxuICAgIH0pO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJy4vaHR0cCc7XG5pbXBvcnQgeyBoYXNOZXR3b3JrLCBoYW5kbGVYaHJFcnJvciB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi9pMThuJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gvdGhyb3R0bGUnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbnZhciBzZXNzaW9uID0gbnVsbDtcblxuZnVuY3Rpb24gaXNDb25uZWN0ZWQoKSB7XG4gIHJldHVybiAhIXNlc3Npb247XG59XG5cbmZ1bmN0aW9uIGdldFNlc3Npb24oKSB7XG4gIHJldHVybiBzZXNzaW9uO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VySWQoKSB7XG4gIHJldHVybiAoc2Vzc2lvbiAmJiBzZXNzaW9uLmlkKSA/IHNlc3Npb24uaWQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBub3dQbGF5aW5nKCkge1xuICB2YXIgbnAgPSBzZXNzaW9uICYmIHNlc3Npb24ubm93UGxheWluZyB8fCBbXTtcbiAgcmV0dXJuIG5wLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHNldHRpbmdzLmdhbWUuc3VwcG9ydGVkVmFyaWFudHMuaW5kZXhPZihlLnZhcmlhbnQua2V5KSAhPT0gLTE7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgcmV0dXJuIHJlcXVlc3QoJy9sb2dpbicsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBkYXRhOiB7XG4gICAgICB1c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkXG4gICAgfVxuICB9LCB0cnVlKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBzZXNzaW9uID0gZGF0YTtcbiAgICByZXR1cm4gc2Vzc2lvbjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgcmV0dXJuIHJlcXVlc3QoJy9sb2dvdXQnLCB7fSwgdHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICBzZXNzaW9uID0gbnVsbDtcbiAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaGFuZGxlWGhyRXJyb3IoZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaWdudXAodXNlcm5hbWUsIGVtYWlsLCBwYXNzd29yZCkge1xuICByZXR1cm4gcmVxdWVzdCgnL3NpZ251cCcsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBkYXRhOiB7XG4gICAgICB1c2VybmFtZSxcbiAgICAgIGVtYWlsLFxuICAgICAgcGFzc3dvcmRcbiAgICB9XG4gIH0sIHRydWUpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgIHNlc3Npb24gPSBkYXRhO1xuICAgIHJldHVybiBzZXNzaW9uO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtZW1iZXJMb2dpbigpIHtcbiAgcmV0dXJuIHJlcXVlc3QoJy9hY2NvdW50L2luZm8nLCB7XG4gICAgYmFja2dyb3VuZDogdHJ1ZVxuICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBzZXNzaW9uID0gZGF0YTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gIGlmIChoYXNOZXR3b3JrKCkgJiYgaXNDb25uZWN0ZWQoKSkge1xuICAgIHJldHVybiByZXF1ZXN0KCcvYWNjb3VudC9pbmZvJywge1xuICAgICAgYmFja2dyb3VuZDogdHJ1ZVxuICAgIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgc2Vzc2lvbiA9IGRhdGE7XG4gICAgICBtLnJlZHJhdygpO1xuICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgfSwgZXJyID0+IHtcbiAgICAgIGlmIChzZXNzaW9uICYmIGVyci5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICBzZXNzaW9uID0gbnVsbDtcbiAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhpMThuKCdzaWduZWRPdXQnKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNDb25uZWN0ZWQsXG4gIHNpZ251cCxcbiAgbG9nb3V0LFxuICBsb2dpbjogdGhyb3R0bGUobG9naW4sIDEwMDApLFxuICByZW1lbWJlckxvZ2luOiB0aHJvdHRsZShyZW1lbWJlckxvZ2luLCAxMDAwKSxcbiAgcmVmcmVzaDogdGhyb3R0bGUocmVmcmVzaCwgMTAwMCksXG4gIGdldDogZ2V0U2Vzc2lvbixcbiAgZ2V0VXNlcklkLFxuICBub3dQbGF5aW5nOiBub3dQbGF5aW5nXG59O1xuIiwiaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmFnZSc7XG5pbXBvcnQgcmFuZ2UgZnJvbSAnbG9kYXNoL3JhbmdlJztcblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlcHJvcChrZXksIGluaXRpYWxWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHN0b3JlLnNldChrZXksIGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHJldCA9IHN0b3JlLmdldChrZXkpO1xuICAgIHJldHVybiAocmV0ICE9PSBudWxsKSA/IHJldCA6IGluaXRpYWxWYWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHVwbGVPZih4KSB7XG4gIHJldHVybiBbeC50b1N0cmluZygpLCB4LnRvU3RyaW5nKCldO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdlbmVyYWw6IHtcbiAgICBsYW5nOiBsb2NhbHN0b3JhZ2Vwcm9wKCdzZXR0aW5ncy5sYW5nJyksXG4gICAgdGhlbWU6IHtcbiAgICAgIGJhY2tncm91bmQ6IGxvY2Fsc3RvcmFnZXByb3AoJ3NldHRpbmdzLmJnVGhlbWUnLCAnZGFyaycpXG4gICAgfVxuICB9LFxuICBnYW1lOiB7XG4gICAgc3VwcG9ydGVkVmFyaWFudHM6IFsnc3RhbmRhcmQnLCAneXV6YmlyJywgJ2R1em9rZXknXVxuICB9LFxuICBnYW1lU2V0dXA6IHtcbiAgICBhdmFpbGFibGVSb3VuZHM6IFsxLCA1LCAxMCwgMTUsIDIwLCAyNSwgMzBdLm1hcCh0dXBsZU9mKSxcbiAgICBpc1JvdW5kVmFsaWQ6IGZ1bmN0aW9uKGdhbWVTZXR0aW5ncykge1xuICAgICAgcmV0dXJuIGdhbWVTZXR0aW5ncy5yb3VuZHMoKSAhPT0gJzAnO1xuICAgIH0sXG4gICAgaHVtYW46IHtcbiAgICAgIGF2YWlsYWJsZVZhcmlhbnRzOiBbXG4gICAgICAgIFsnMTAxIE9rZXknLCAnMSddLFxuICAgICAgICBbJ0TDvHogT2tleScsICczJ11cbiAgICAgIF0sXG4gICAgICB2YXJpYW50OiBsb2NhbHN0b3JhZ2Vwcm9wKCdzZXR0aW5ncy5nYW1lLmh1bWFuLnZhcmlhbnQnLCAnMScpLFxuICAgICAgcm91bmRzOiBsb2NhbHN0b3JhZ2Vwcm9wKCdzZXR0aW5ncy5nYW1lLmh1bWFuLnJvdW5kcycsICcxJyksXG4gICAgICBtb2RlOiBsb2NhbHN0b3JhZ2Vwcm9wKCdzZXR0aW5ncy5nYW1lLmh1bWFuLm1vZGUnLCAnMCcpLFxuICAgICAgbWVtYmVyc09ubHk6IGxvY2Fsc3RvcmFnZXByb3AoJ3NldHRpbmdzLmdhbWUuaHVtYW4ubWVtYmVyc09ubHknLCBmYWxzZSlcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBTaWduYWwgfSBmcm9tICdzaWduYWxzJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgcmVkcmF3OiBuZXcgU2lnbmFsKCksXG5cbiAgYWZ0ZXJMb2dpbjogbmV3IFNpZ25hbCgpLFxuXG4gIGFmdGVyTG9nb3V0OiBuZXcgU2lnbmFsKCksXG5cbiAgc2Vzc2lvblJlc3RvcmVkOiBuZXcgU2lnbmFsKClcblxufTtcbiIsImltcG9ydCBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZSc7XG5pbXBvcnQgeyBveXVua2V5ZlNyaSwgYXNrV29ya2VyLCB0ZWxsV29ya2VyLCBoYXNOZXR3b3JrIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcignbGliL3NvY2tldFdvcmtlci5qcycpO1xuXG5sZXQgc29ja2V0SGFuZGxlcnM7XG5sZXQgZXJyb3JEZXRlY3RlZCA9IGZhbHNlO1xubGV0IGNvbm5lY3RlZFdTID0gdHJ1ZTtcblxubGV0IGFscmVhZHlXYXJuZWQgPSBmYWxzZTtcbmxldCByZWRyYXdPbkRpc2Nvbm5lY3RlZFRpbWVvdXRJRDtcbmxldCBwcm94eUZhaWxUaW1lb3V0SUQ7XG5jb25zdCBwcm94eUZhaWxNc2cgPSBcIk95dW5rZXlmIHN1bnVjdWxhcsSxbmEgYmHEn2xhbnTEsSBrb3B0dS4gUHJvYmxlbSBzw7xyZWtsaSB5YcWfYW7EsXlvcnNhIHByb3h5IHlhZGEgbmV0d29yaydsYSBpbGdpbGkgb2xhYmlsaXIuXCI7XG5cbmNvbnN0IGRlZmF1bHRIYW5kbGVycyA9IHtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUdhbWUodXJsLCB2ZXJzaW9uLCBoYW5kbGVycywgZ2FtZVVybCkge1xuICBlcnJvckRldGVjdGVkID0gZmFsc2U7XG4gIHNvY2tldEhhbmRsZXJzID0ge1xuICAgIG9uRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gd2UgY2FuJ3QgZ2V0IHNvY2tldCBlcnJvciwgc28gd2Ugc2VuZCBhbiB4aHIgdG8gdGVzdCB3aGV0aGVyIHRoZVxuICAgICAgLy8gcmVqZWN0aW9uIGlzIGFuIGF1dGhvcml6YXRpb24gaXNzdWVcbiAgICAgIGlmICghZXJyb3JEZXRlY3RlZCkge1xuICAgICAgICAvLyBqdXN0IHRvIGJlIHN1cmUgdGhhdCB3ZSBkb24ndCBzZW5kIGFuIHhociBldmVyeSBzZWNvbmQgd2hlbiB0aGVcbiAgICAgICAgLy8gd2Vic29ja2V0IGlzIHRyeWluZyB0byByZWNvbm5lY3RcbiAgICAgICAgZXJyb3JEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIHhoci5nYW1lKGdhbWVVcmwuc3Vic3RyaW5nKDEpKS50aGVuKGZ1bmN0aW9uKCkge30sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bigndW5hdXRob3JpemVkRXJyb3InKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuICAgICAgICAgICAgbS5yb3V0ZSgnLycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBldmVudHM6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIYW5kbGVycywgaGFuZGxlcnMpXG4gIH07XG5cbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBuYW1lOiAnZ2FtZScsXG4gICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4gICAgfVxuICB9O1xuICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbiAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4gICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbiAgICB1cmwsXG4gICAgdmVyc2lvbixcbiAgICBvcHRzXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXNhKG1hc2FJZCwgdmVyc2lvbiwgaGFuZGxlcnMpIHtcbiAgbGV0IHVybCA9ICcvbWFzYS8nICsgbWFzYUlkICsgJy9zb2NrZXQvdjEnO1xuXG4gIHNvY2tldEhhbmRsZXJzID0ge1xuICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycylcbiAgfTtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBuYW1lOiAnbWFzYScsXG4gICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICBwaW5nRGVsYXk6IDIwMDAsXG4gICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4gICAgfVxuICB9O1xuICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbiAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4gICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbiAgICB1cmwsXG4gICAgdmVyc2lvbixcbiAgICBvcHRzXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXNhSG9tZShoYW5kbGVycykge1xuICBsZXQgdXJsID0gJy9zb2NrZXQnO1xuXG4gIHNvY2tldEhhbmRsZXJzID0ge1xuICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycylcbiAgfTtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBwYXJhbXM6IHsgZmxhZzogJ21hc2EnIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgbmFtZTogJ21hc2FIb21lJyxcbiAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgIHBpbmdEZWxheTogMjAwMCxcbiAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbiAgICB9XG4gIH07XG4gIHRlbGxXb3JrZXIod29ya2VyLCAnY3JlYXRlJywge1xuICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbiAgICBzb2NrZXRFbmRQb2ludDogd2luZG93Lm95dW5rZXlmLnNvY2tldEVuZFBvaW50LFxuICAgIHVybCxcbiAgICB2ZXJzaW9uOiAwLFxuICAgIG9wdHNcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvYmJ5KGxvYmJ5VmVyc2lvbiwgb25PcGVuLCBoYW5kbGVycykge1xuICBzb2NrZXRIYW5kbGVycyA9IHtcbiAgICBvbk9wZW4sXG4gICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGFuZGxlcnMsIGhhbmRsZXJzKVxuICB9O1xuICBjb25zdCBvcHRzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIG5hbWU6ICdsb2JieScsXG4gICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICBwaW5nRGVsYXk6IDIwMDAsXG4gICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4gICAgfVxuICB9O1xuICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbiAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4gICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbiAgICB1cmw6ICcvbG9iYnkvc29ja2V0L3YxJyxcbiAgICB2ZXJzaW9uOiBsb2JieVZlcnNpb24sXG4gICAgb3B0c1xuICB9KTtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0KCkge1xuICAvLyBkZWZhdWx0IHNvY2tldCBpcyB1c2VsZXNzIHdoZW4gYW5vbi4/XG4gIGlmIChoYXNOZXR3b3JrKCkpIHtcbiAgICBzb2NrZXRIYW5kbGVycyA9IHtcbiAgICAgIGV2ZW50czogZGVmYXVsdEhhbmRsZXJzXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICBuYW1lOiAnZGVmYXVsdCcsXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgcGluZ0RlbGF5OiAyMDAwLFxuICAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbiAgICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbiAgICAgIHNvY2tldEVuZFBvaW50OiB3aW5kb3cub3l1bmtleWYuc29ja2V0RW5kUG9pbnQsXG4gICAgICB1cmw6ICcvc29ja2V0JyxcbiAgICAgIHZlcnNpb246IDAsXG4gICAgICBvcHRzXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db25uZWN0ZWQoKSB7XG4gIGNvbnN0IHdhc09mZiA9ICFjb25uZWN0ZWRXUztcbiAgY29ubmVjdGVkV1MgPSB0cnVlO1xuICBjbGVhclRpbWVvdXQocHJveHlGYWlsVGltZW91dElEKTtcbiAgY2xlYXJUaW1lb3V0KHJlZHJhd09uRGlzY29ubmVjdGVkVGltZW91dElEKTtcbiAgaWYgKHdhc09mZikgbS5yZWRyYXcoKTtcbn1cblxuZnVuY3Rpb24gb25EaXNjb25uZWN0ZWQoKSB7XG4gIGNvbnN0IHdhc09uID0gY29ubmVjdGVkV1M7XG4gIGNvbm5lY3RlZFdTID0gZmFsc2U7XG4gIGlmICh3YXNPbikgcmVkcmF3T25EaXNjb25uZWN0ZWRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIG0ucmVkcmF3KCk7XG4gIH0sIDIwMDApO1xuICBpZiAod2FzT24gJiYgIWFscmVhZHlXYXJuZWQgJiYgIXN0b3JhZ2UuZ2V0KCdkb25vdHNob3dwcm94eWZhaWx3YXJuaW5nJykpIHByb3h5RmFpbFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIGNoZWNrIGlmIGRpc2Nvbm5lY3Rpb24gbGFzdHMsIGl0IGNvdWxkIG1lYW4gYSBwcm94eSBwcmV2ZW50c1xuICAgIC8vIGVzdGFibGlzaGluZyBhIHR1bm5lbFxuICAgIGlmIChoYXNOZXR3b3JrKCkgJiYgIWNvbm5lY3RlZFdTKSB7XG4gICAgICBhbHJlYWR5V2FybmVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3Iubm90aWZpY2F0aW9uLmFsZXJ0KHByb3h5RmFpbE1zZywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0KCdkb25vdHNob3dwcm94eWZhaWx3YXJuaW5nJywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIDIwMDAwKTtcbn1cblxud29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgc3dpdGNoKG1zZy5kYXRhLnRvcGljKSB7XG4gIGNhc2UgJ29uT3Blbic6XG4gICAgaWYgKHNvY2tldEhhbmRsZXJzLm9uT3Blbikgc29ja2V0SGFuZGxlcnMub25PcGVuKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgb25EaXNjb25uZWN0ZWQoKTtcbiAgICBicmVhaztcbiAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICBvbkNvbm5lY3RlZCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdvbkVycm9yJzpcbiAgICBpZiAoc29ja2V0SGFuZGxlcnMub25FcnJvcikgc29ja2V0SGFuZGxlcnMub25FcnJvcigpO1xuICAgIGJyZWFrO1xuICBjYXNlICdoYW5kbGUnOlxuICAgIHZhciBoID0gc29ja2V0SGFuZGxlcnMuZXZlbnRzW21zZy5kYXRhLnBheWxvYWQudF07XG4gICAgaWYgKGgpIGgobXNnLmRhdGEucGF5bG9hZC5kIHx8IG51bGwsIG1zZy5kYXRhLnBheWxvYWQpO1xuICAgIGJyZWFrO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjcmVhdGVEZWZhdWx0LFxuICBjcmVhdGVNYXNhLFxuICBjcmVhdGVNYXNhSG9tZSxcbiAgY3JlYXRlR2FtZSxcbiAgY3JlYXRlTG9iYnksXG4gIHNldFZlcnNpb24odmVyc2lvbikge1xuICAgIHRlbGxXb3JrZXIod29ya2VyLCAnc2V0VmVyc2lvbicsIHZlcnNpb24pO1xuICB9LFxuICBzZW5kKHR5cGUsIGRhdGEsIG9wdHMpIHtcbiAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ3NlbmQnLCBbdHlwZSwgZGF0YSwgb3B0c10pO1xuICB9LFxuICBjb25uZWN0KCkge1xuICAgIHRlbGxXb3JrZXIod29ya2VyLCAnY29ubmVjdCcpO1xuICB9LFxuICBkaXNjb25uZWN0KCkge1xuICAgIHRlbGxXb3JrZXIod29ya2VyLCAnZGlzY29ubmVjdCcpO1xuICB9LFxuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gY29ubmVjdGVkV1M7XG4gIH0sXG4gIGRlc3Ryb3koKSB7XG4gICAgdGVsbFdvcmtlcih3b3JrZXIsICdkZXN0cm95Jyk7XG4gIH0sXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAod29ya2VyKSB3b3JrZXIudGVybWluYXRlKCk7XG4gIH1cbn07XG4iLCJ2YXIgdGltZW91dElkO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNwaW4oKSB7XG4gICAgaWYgKHRpbWVvdXRJZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdnbG9iYWxTcGlubmVyJykubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzcGlubmVyLmNsYXNzTmFtZSA9ICdzcGlubmVyIGdsb2JhbFNwaW5uZXInO1xuICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsICcwIDAgNDAgNDAnKTtcbiAgICBjb25zdCBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2NpcmNsZScpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N4JywgJzIwJyk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3knLCAnMjAnKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdyJywgJzE4Jyk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKGNpcmNsZSk7XG4gICAgc3Bpbm5lci5hcHBlbmRDaGlsZChzdmcpO1xuXG4gICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwaW5uZXIpLCAyMDApO1xuICB9LFxuXG4gIHN0b3AoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgdGltZW91dElkID0gbnVsbDtcbiAgICBjb25zdCBzcGlubmVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2dsb2JhbFNwaW5uZXInKTtcbiAgICBpZiAoc3Bpbm5lcnMubGVuZ3RoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAoc3Bpbm5lcnNbMF0pIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3Bpbm5lcnNbMF0pO1xuICAgICAgfSwgNTAwKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VmRvbShjbGFzc2VzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9eydzcGlubmVyICcgKyBjbGFzc2VzfT5cbiAgICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDQwIDQwXCI+XG4gICAgICAgICAgPGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIyMFwiIHI9XCIxOFwiIGZpbGw9XCJub25lXCI+PC9jaXJjbGU+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiZnVuY3Rpb24gd2l0aFN0b3JhZ2UoZikge1xuICAvLyBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHN0b3JhZ2UgaXMgZnVsbFxuICB0cnkge1xuICAgIHJldHVybiAhIXdpbmRvdy5sb2NhbFN0b3JhZ2UgPyBmKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIDogbnVsbDtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIGdldDogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiB3aXRoU3RvcmFnZShmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShzLmdldEl0ZW0oaykpO1xuICAgIH0pO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gd2l0aFN0b3JhZ2UoZnVuY3Rpb24ocykge1xuICAgICAgcy5yZW1vdmVJdGVtKGspO1xuICAgIH0pO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICByZXR1cm4gd2l0aFN0b3JhZ2UoZnVuY3Rpb24ocykge1xuICAgICAgcy5yZW1vdmVJdGVtKGspO1xuICAgICAgcy5zZXRJdGVtKGssIEpTT04uc3RyaW5naWZ5KHYpKTtcbiAgICB9KTtcbiAgfVxufTtcbiIsImltcG9ydCB7IGhhc05ldHdvcmssIGhhbmRsZVhockVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2FtZSBhcyBnYW1lWGhyIH0gZnJvbSAnLi4vLi4veGhyJztcbmltcG9ydCByb3VuZEN0cmwgZnJvbSAnLi4vcm91bmQvcm91bmRDdHJsJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250cm9sbGVyKCkge1xuICB2YXIgZ2FtZURhdGE7XG4gIHZhciByb3VuZDtcblxuICBpZiAoaGFzTmV0d29yaygpKSB7XG4gICAgZ2FtZVhocihtLnJvdXRlLnBhcmFtKCdpZCcpKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGdhbWVEYXRhID0gZGF0YTtcbiAgICAgIHJvdW5kID0gbmV3IHJvdW5kQ3RybChkYXRhKTtcbiAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgaGFuZGxlWGhyRXJyb3IoZXJyb3IpO1xuICAgICAgbS5yb3V0ZSgnLycpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvbnVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocm91bmQpIHtcbiAgICAgICAgcm91bmQub251bmxvYWQoKTtcbiAgICAgICAgcm91bmQgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Um91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvdW5kO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCByb3VuZFZpZXcgZnJvbSAnLi4vcm91bmQvdmlldy9yb3VuZFZpZXcnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZpZXcoY3RybCkge1xuICBpZiAoY3RybC5nZXRSb3VuZCgpKSByZXR1cm4gcm91bmRWaWV3KGN0cmwuZ2V0Um91bmQoKSk7XG59XG4iLCJpbXBvcnQgY29udHJvbGxlciBmcm9tICcuL2dhbWVDdHJsJztcbmltcG9ydCB2aWV3IGZyb20gJy4vZ2FtZVZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXIsXG4gIHZpZXdcbn07XG4iLCJpbXBvcnQgcG9wdXBXaWRnZXQgZnJvbSAnLi9zaGFyZWQvcG9wdXAnO1xuaW1wb3J0IGZvcm1XaWRnZXRzIGZyb20gJy4vc2hhcmVkL2Zvcm0nO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4vaGVscGVyJztcbmltcG9ydCBpU2Nyb2xsIGZyb20gJ2lzY3JvbGwnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uL3NldHRpbmdzJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uL3Nlc3Npb24nO1xuaW1wb3J0IGJhY2tidXR0b24gZnJvbSAnLi4vYmFja2J1dHRvbic7XG5pbXBvcnQgbG9iYnkgZnJvbSAnLi9sb2JieSc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBWaWV3T25seUJvYXJkIGZyb20gJy4vc2hhcmVkL1ZpZXdPbmx5Qm9hcmQnO1xuXG52YXIgc2Nyb2xsZXIgPSBudWxsO1xuXG5jb25zdCBnYW1lc01lbnUgPSB7fTtcblxuZ2FtZXNNZW51LmlzT3BlbiA9IGZhbHNlO1xuXG5nYW1lc01lbnUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goZ2FtZXNNZW51LmNsb3NlKTtcbiAgZ2FtZXNNZW51LmlzT3BlbiA9IHRydWU7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWxzLmhhc05ldHdvcmsoKSAmJiBzY3JvbGxlcikgc2Nyb2xsZXIuZ29Ub1BhZ2UoMSwgMCk7XG4gIH0sIDQwMCk7XG4gIHNlc3Npb24ucmVmcmVzaCgpO1xufTtcblxuZ2FtZXNNZW51LmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBnYW1lc01lbnUuaXNPcGVuKSBiYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBnYW1lc01lbnUuaXNPcGVuID0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBqb2luR2FtZShnKSB7XG4gIGdhbWVzTWVudS5jbG9zZSgpO1xuICBtLnJvdXRlKCcvZ2FtZS8nICsgZy5mdWxsSWQpO1xufVxuXG5mdW5jdGlvbiBjYXJkRGltcygpIHtcbiAgY29uc3QgdnAgPSBoZWxwZXIudmlld3BvcnREaW0oKTtcblxuICAvLyBpZiB3ZSdyZSBoZXJlIGl0J3MgYSBwaG9uZVxuICBsZXQgd2lkdGggPSAyMDA7XG4gIGxldCBoZWlnaHQgPSB3aWR0aCAvICg0LzMpO1xuICBsZXQgbWFyZ2luID0gMTA7XG4gIHJldHVybiB7XG4gICAgdzogd2lkdGggKyBtYXJnaW4gKiAyLFxuICAgIGg6IGhlaWdodCArIDcwLFxuICAgIGlubmVyVzogd2lkdGgsXG4gICAgbWFyZ2luOiBtYXJnaW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVmlld09ubHlCb2FyZChjRGltLCBmZW4sIG9yaWVudGF0aW9uLCB2YXJpYW50KSB7XG4gIGNvbnN0IGlubmVySCA9IGNEaW0gPyBjRGltLmlubmVyVyAvICg0LzMpOiAwO1xuICBjb25zdCBpbm5lclcgPSBjRGltID8gY0RpbS5pbm5lclcgOiAwO1xuICBjb25zdCBzdHlsZSA9IGNEaW0gPyB7IGhlaWdodDogaW5uZXJIICsgJ3B4JyB9IDoge307XG4gIGNvbnN0IGJvdW5kcyA9IGNEaW0gPyB7IHdpZHRoOiBpbm5lclcsIGhlaWdodDogaW5uZXJIIH0gOiBudWxsO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9hcmRXcmFwcGVyXCIgc3R5bGU9e3N0eWxlfT5cbiAgICAgIHttLmNvbXBvbmVudChWaWV3T25seUJvYXJkLCB7IGJvdW5kcywgZmVuLCBvcmllbnRhdGlvbiwgdmFyaWFudH0pfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiB0aW1lTGVmdChnKSB7XG4gIGlmICghZy5pc015VHVybikgcmV0dXJuIGkxOG4oJ3dhaXRpbmdGb3JPcHBvbmVudCcpO1xuICByZXR1cm4gaTE4bigneW91clR1cm4nKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyR2FtZShnLCBjRGltLCBjYXJkU3R5bGUpIHtcbiAgY29uc3QgaWNvbiA9IHV0aWxzLmdhbWVJY29uKGcucGVyZik7XG4gIGNvbnN0IGNhcmRDbGFzcyA9IFtcbiAgICAnY2FyZCcsXG4gICAgJ3N0YW5kYXJkJ1xuICBdLmpvaW4oJyAnKTtcblxuICBjb25zdCB0aW1lQ2xhc3MgPSBbXG4gICAgJ3RpbWVJbmRpY2F0aW9uJyxcbiAgICBnLmlzTXlUdXJuID8gJ215VHVybic6ICdvcHBvbmVudFR1cm4nXG4gIF0uam9pbignICcpO1xuICBjb25zdCBjb25maWcgPSBoZWxwZXIub250b3VjaFgoKCkgPT4gam9pbkdhbWUoZykpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NhcmRDbGFzc30ga2V5PXsnZ2FtZS4nICsgZy5nYW1lSWR9IHN0eWxlPXtjYXJkU3R5bGV9XG4gICAgY29uZmlnPXtjb25maWd9PlxuICAgICAge3JlbmRlclZpZXdPbmx5Qm9hcmQoY0RpbSwgZy5mZW4sIGcuc2lkZSwgZy52YXJpYW50KX1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb3NcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZXNjcmlwdGlvblwiPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidmFyaWFudFwiPntnLnZhcmlhbnQubmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3RpbWVDbGFzc30+e3RpbWVMZWZ0KGcpfTwvc3Bhbj5cbiAgICAgICAgICA8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFsbEdhbWVzKGNEaW0pIHtcbiAgY29uc3Qgbm93UGxheWluZyA9IHNlc3Npb24ubm93UGxheWluZygpOyAvLyAuY29uY2F0KHNlc3Npb24ubm93UGxheWluZygpKTtcbiAgY29uc3QgY2FyZFN0eWxlID0gY0RpbSA/IHtcbiAgICB3aWR0aDogKGNEaW0udyAtIGNEaW0ubWFyZ2luICogMikgKyAncHgnLFxuICAgIGhlaWdodDogY0RpbS5oICsgJ3B4JyxcbiAgICBtYXJnaW5MZWZ0OiBjRGltLm1hcmdpbiArICdweCcsXG4gICAgbWFyZ2luUmlnaHQ6IGNEaW0ubWFyZ2luICsgJ3B4J1xuICB9IDoge307XG5cbiAgY29uc3QgbmJDYXJkcyA9IHV0aWxzLmhhc05ldHdvcmsoKSA/XG4gICAgICAgICAgICAgICAgICBub3dQbGF5aW5nLmxlbmd0aCArIDEgOlxuICAgICAgICAgICAgICAgICAgMDtcblxuICBsZXQgd3JhcHBlclN0eWxlLCB3cmFwcGVyV2lkdGg7XG4gIGlmIChjRGltKSB7XG4gICAgLy8gc2Nyb2xsZXIgd3JhcHBlciB3aWR0aFxuICAgIC8vIGNhbGN1bCBpczpcbiAgICAvLyAoKGNhcmRXaWR0aCArIHZpc2libGUgcGFydCBvZiBhZGphY2VudCBjYXJkKSAqIG5iIG9mIGNhcmRzKSArXG4gICAgLy8gd3JhcHBlcidzIG1hcmdpbkxlZnRcbiAgICB3cmFwcGVyV2lkdGggPSAoKGNEaW0udyArIGNEaW0ubWFyZ2luICogMikgKiBuYkNhcmRzKSArXG4gICAgICAgICAgICAgICAgICAgKGNEaW0ubWFyZ2luICogMik7XG4gICAgd3JhcHBlclN0eWxlID0ge1xuICAgICAgd2lkdGg6IHdyYXBwZXJXaWR0aCArICdweCcsXG4gICAgICBtYXJnaW5MZWZ0OiAoY0RpbS5tYXJnaW4gKiAzKSArICdweCdcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFsbENhcmRzID0gbm93UGxheWluZy5tYXAoZyA9PiByZW5kZXJHYW1lKGcsIGNEaW0sIGNhcmRTdHlsZSkpO1xuXG4gIGlmICghaGVscGVyLmlzV2lkZVNjcmVlbigpKSB7XG5cbiAgICBjb25zdCBuZXdHYW1lQ2FyZCA9IChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBzdGFuZGFyZFwiIGtleT1cImdhbWUubmV3LWdhbWVcIiBzdHlsZT17Y2FyZFN0eWxlfVxuICAgICAgICAgICBjb25maWc9e2hlbHBlci5vbnRvdWNoWCgoKSA9PiB7IGdhbWVzTWVudS5jbG9zZSgpOyBuZXdHYW1lRm9ybS5vcGVuKCk7IH0pfT5cbiAgICAgICAge3JlbmRlclZpZXdPbmx5Qm9hcmQoY0RpbSl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb3NcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGl0bGVcIj57aTE4bignY3JlYXRlQUdhbWUnKX08L2gyPlxuICAgICAgICAgICAgPHA+e2kxOG4oJ25ld09wcG9uZW50Jyl9PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gICAgaWYgKHV0aWxzLmhhc05ldHdvcmsoKSkgYWxsQ2FyZHMudW5zaGlmdChuZXdHYW1lQ2FyZCk7XG4gIH1cblxuICByZXR1cm4gbSgnZGl2I2FsbF9nYW1lcycsIHsgc3R5bGU6IHdyYXBwZXJTdHlsZSB9LCBhbGxDYXJkcyk7XG59XG5cblxuZ2FtZXNNZW51LnZpZXcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFnYW1lc01lbnUuaXNPcGVuKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCB2aCA9IGhlbHBlci52aWV3cG9ydERpbSgpLnZoXG4gIGNvbnN0IGNEaW0gPSBjYXJkRGltcygpO1xuICBjb25zdCB3cmFwcGVyU3R5bGUgPSBoZWxwZXIuaXNXaWRlU2NyZWVuKCkgPyB7fSA6IHsgdG9wOiAoKHZoIC0gY0RpbS5oKSAvIDIpICsgJ3B4JyB9O1xuICBjb25zdCB3cmFwcGVyQ29uZmlnID1cbiAgaGVscGVyLmlzV2lkZVNjcmVlbigpID8gdXRpbHMubm9vcCA6XG4gIGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuICAgIGlmICghaXNVcGRhdGUpIHtcbiAgICAgIHNjcm9sbGVyID0gbmV3IGlTY3JvbGwoZWwsIHtcbiAgICAgICAgc2Nyb2xsWDogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsWTogZmFsc2UsXG4gICAgICAgIG1vbWVudHVtOiBmYWxzZSxcbiAgICAgICAgc25hcDogJy5jYXJkJyxcbiAgICAgICAgc25hcFNwZWVkOiA0MDAsXG4gICAgICAgIHByZXZlbnREZWZhdWx0RXhjZXB0aW9uOiB7XG4gICAgICAgICAgdGFnTmFtZTogL14oSU5QVVR8VEVYVEFSRUF8QlVUVE9OfFNFTEVDVHxMQUJFTCkkL1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29udGV4dC51bm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2Nyb2xsZXIpIHtcbiAgICAgICAgICBzY3JvbGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgc2Nyb2xsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1YmlxL2lzY3JvbGwvaXNzdWVzLzQxMlxuICAgIHNjcm9sbGVyLm9wdGlvbnMuc25hcCA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkJyk7XG4gICAgc2Nyb2xsZXIucmVmcmVzaCgpO1xuICB9O1xuXG4gIGNvbnN0IGlzV2lkZVNjcmVlbiA9IGhlbHBlci5pc1dpZGVTY3JlZW4oKTtcblxuICBjb25zdCB3cmFwcGVyQ2xhc3MgPSBpc1dpZGVTY3JlZW4gPyAnb3ZlcmxheV9wb3B1cCcgOiAnJztcblxuICByZXR1cm4gKFxuICAgIDxkaXYgaWQ9XCJnYW1lc19tZW51XCIgY2xhc3NOYW1lPVwib3ZlcmxheV9wb3B1cF93cmFwcGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIndyYXBwZXJfb3ZlcmxheV9jbG9zZVwiXG4gICAgICAgICAgIGNvbmZpZz17aGVscGVyLm9udG91Y2goaGVscGVyLmZhZGVzT3V0KGdhbWVzTWVudS5jbG9zZSwgJy5vdmVybGF5X3BvcHVwX3dyYXBwZXInKSl9Lz5cbiAgICAgIDxkaXYgaWQ9XCJ3cmFwcGVyX2dhbWVzXCIgY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3N9IHN0eWxlPXt3cmFwcGVyU3R5bGV9IGNvbmZpZz17d3JhcHBlckNvbmZpZ30+XG4gICAgICAgIHsgaXNXaWRlU2NyZWVuID8gKFxuICAgICAgICAgIDxoZWFkZXI+XG4gICAgICAgICAgICB7aTE4bignbmJHYW1lc0luUGxheScsIHNlc3Npb24ubm93UGxheWluZygpLmxlbmd0aCl9XG4gICAgICAgICAgPC9oZWFkZXI+XG4gICAgICAgICkgOiBudWxsIH1cbiAgICAgICAgeyBpc1dpZGVTY3JlZW4gPyAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cF9jb250ZW50XCI+XG4gICAgICAgICAge3JlbmRlckFsbEdhbWVzKG51bGwpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogcmVuZGVyQWxsR2FtZXMoY0RpbSkgfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnYW1lc01lbnU7XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5cbnZhciBhbmltYXRpbmcgPSBmYWxzZTtcblxuLy8gQXV0aG9yIEJhcm5leSBDYXJvbGxcbi8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFybmV5Y2Fycm9sbC9jNjlmYmUwNzg2ZTM3Yzk0MWJhZlxuXG4vLyBEZWZpbmUgYW4gYW5pbWF0b3IgY29uc2lzdGluZyBvZiBvcHRpb25hbCBpbmNvbWluZyBhbmQgb3V0Z29pbmcgYW5pbWF0aW9ucy5cbi8vIGFsd2F5c0FuaW1hdGUgaXMgZmFsc2UgdW5sZXNzIHNwZWNpZmllZCBhcyB0cnVlOiBmYWxzZSBtZWFucyBhbiBpbmNvbWluZyBhbmltYXRpb24gd2lsbCBvbmx5IHRyaWdnZXIgaWYgYW4gb3V0Z29pbmcgYW5pbWF0aW9uIGlzIGFsc28gaW4gcHJvZ3Jlc3MuXG4vLyBmb3JjaW5nIGRvbnRDbG9uZSB0byB0cnVlIG1lYW5zIHRoZSBvdXR3YXJkIGFuaW1hdGlvbiB3aWxsIHVzZSB0aGUgb3JpZ2luYWwgZWxlbWVudCByYXRoZXIgdGhhbiBhIGNsb25lLiBUaGlzIGNvdWxkIGltcHJvdmUgcGVyZm9ybWFuY2UgYnkgcmVjeWNsaW5nIGVsZW1lbnRzLCBidXQgY2FuIGxlYWQgdG8gdHJvdWJsZTogY2xvbmVzIGhhdmUgdGhlIGFkdmFudGFnZSBvZiBiZWluZyBzdHJpcHBlZCBvZiBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYW5pbWF0b3IoaW5jb21pbmcsIG91dGdvaW5nLCBhbHdheXNBbmltYXRlLCBkb250Q2xvbmUpIHtcbiAgLy8gVGhlIHJlc3VsdGluZyBhbmltYXRvciBjYW4gYmUgYXBwbGllZCB0byBhbnkgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGUoIHgsIHksIHogKXtcbiAgICB2YXIgY29uZmlnO1xuICAgIHZhciBwYXJlbnQ7XG4gICAgdmFyIG5leHQ7XG5cbiAgICAvLyBXaGVuIHVzZWQgYXMgYSBjb25maWcgZnVuY3Rpb25cbiAgICBpZiAoIHgubm9kZVR5cGUgKSB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uQ29uZmlnKHgsIHksIHopO1xuICAgIH1cbiAgICAvLyBXaGVuIHBhc3NlZCBhIHZpcnR1YWwgRE9NIG5vZGUgKHRoZSBvdXRwdXQgb2YgbSlcbiAgICBlbHNlIGlmICggeC5hdHRycyApIHtcbiAgICAgIHJldHVybiBiaW5kQ29uZmlnVG8oIHggKTtcbiAgICB9XG4gICAgLy8gV2hlbiBhcHBsaWVkIHRvIGEgTWl0aHJpbCBtb2R1bGUgLyBjb21wb25lbnRcbiAgICBlbHNlIGlmICggeC52aWV3ICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJvbGxlcjogeC5jb250cm9sbGVyIHx8IG5vb3AsXG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uIGFuaW1hdGVkVmlldyhjdHJsKXtcbiAgICAgICAgICByZXR1cm4gYmluZENvbmZpZ1RvKHgudmlldyhjdHJsKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZENvbmZpZ1RvKCBub2RlICl7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25maWcgPSBub2RlLmF0dHJzLmNvbmZpZztcblxuICAgICAgbm9kZS5hdHRycy5jb25maWcgPSBhbmltYXRpb25Db25maWc7XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFuaW1hdGlvbkNvbmZpZyhlbCwgaW5pdCwgY29udGV4dCl7XG4gICAgICB2YXIgb3V0cHV0O1xuICAgICAgdmFyIG9udW5sb2FkO1xuXG4gICAgICBpZiAoY29uZmlnKXtcbiAgICAgICAgb3V0cHV0ID0gY29uZmlnKGVsLCBpbml0LCBjb250ZXh0KTtcbiAgICAgICAgLy8gSWYgdGhlIHJvb3QgZWxlbWVudCBhbHJlYWR5IGhhcyBhIGNvbmZpZywgaXQgbWF5IGFsc28gaGF2ZSBhbiBvbnVubG9hZCB3aGljaCB3ZSBzaG91bGQgdGFrZSBjYXJlIHRvIHByZXNlcnZlXG4gICAgICAgIG9udW5sb2FkID0gY29udGV4dC5vbnVubG9hZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhaW5pdCApe1xuICAgICAgICBpZiAoaW5jb21pbmcgJiYgYWx3YXlzQW5pbWF0ZSB8fCBhbmltYXRpbmcpIHtcbiAgICAgICAgICBpbmNvbWluZyhlbCwgbm9vcCwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm9udW5sb2FkID0gb3V0Z29pbmcgPyBvbnVubG9hZCA/IGZ1bmN0aW9uIG9udW5sb2FkV3JhcHBlcigpIHtcbiAgICAgICAgICB0ZWFyZG93bigpO1xuICAgICAgICAgIG9udW5sb2FkKCk7XG4gICAgICAgIH0gOiB0ZWFyZG93biA6IG9udW5sb2FkO1xuXG4gICAgICAgIHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIG5leHQgPSBlbC5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcblxuICAgICAgZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgICAgIHZhciBpbnNlcnRpb24gPSBkb250Q2xvbmUgPyBlbCA6IGVsLmNsb25lTm9kZSggdHJ1ZSApO1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gbnVsbDtcblxuICAgICAgICBpZiAoIG5leHQgJiYgcGFyZW50ICYmIG5leHQucGFyZW50Tm9kZSA9PT0gcGFyZW50ICl7XG4gICAgICAgICAgcmVmZXJlbmNlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGluZyA9IHRydWU7XG5cbiAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gcmVzZXRBbmltYXRpb25GbGFnKCl7XG4gICAgICAgICAgYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIH0sIDAgKTtcblxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKCBpbnNlcnRpb24sIHJlZmVyZW5jZSApO1xuXG4gICAgICAgIG91dGdvaW5nKCBpbnNlcnRpb24sIGZ1bmN0aW9uIGRlc3Ryb3koKXtcbiAgICAgICAgICBpZiAoIHBhcmVudC5jb250YWlucyggaW5zZXJ0aW9uICkgKXtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCggaW5zZXJ0aW9uICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjb250ZXh0ICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmNvbnN0IEhPTERfRFVSQVRJT04gPSA2MDA7XG5jb25zdCBSRVBFQVRfUkFURSA9IDIwO1xuY29uc3QgU0NST0xMX1RPTEVSQU5DRSA9IDg7XG5jb25zdCBBQ1RJVkVfQ0xBU1MgPSAnYWN0aXZlJztcblxuZnVuY3Rpb24gaGFzQ29udGV4dE1lbnUoKSB7XG4gIHJldHVybiB3aW5kb3cuY29yZG92YS5wbGF0Zm9ybUlkICE9PSAnaW9zJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnV0dG9uSGFuZGxlcihlbCxcbiAgdGFwSGFuZGxlcixcbiAgaG9sZEhhbmRsZXIsXG4gIHJlcGVhdEhhbmRsZXIsXG4gIHNjcm9sbFgsXG4gIHNjcm9sbFksXG4gIHRvdWNoRW5kRmVlZGJhY2spIHtcblxuICBsZXQgc3RhcnRYLCBzdGFydFksIGJvdW5kYXJpZXMsIGFjdGl2ZSwgaG9sZFRpbWVvdXRJRCwgcmVwZWF0VGltZW91dElkLCByZXBlYXRJbnRlcnZhbElEO1xuXG4gIGlmICh0eXBlb2YgdGFwSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1dHRvbkhhbmRsZXIgMm5kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiEnKTtcblxuICBpZiAoaG9sZEhhbmRsZXIgJiYgdHlwZW9mIGhvbGRIYW5kbGVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignQnV0dG9uSGFuZGxlciAzcmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuXG4gIGlmIChyZXBlYXRIYW5kbGVyICYmIHR5cGVvZiByZXBlYXRIYW5kbGVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignQnV0dG9uSGFuZGxlciA0cmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuXG4gIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ob3ctamF2YXNjcmlwdC10aW1lcnMtd29yay9cbiAgZnVuY3Rpb24gb25SZXBlYXQoKSB7XG4gICAgdmFyIHJlcyA9IHJlcGVhdEhhbmRsZXIoKTtcbiAgICByZXBlYXRJbnRlcnZhbElEID0gc2V0VGltZW91dChvblJlcGVhdCwgUkVQRUFUX1JBVEUpO1xuICAgIGlmICghcmVzKSBjbGVhclRpbWVvdXQocmVwZWF0SW50ZXJ2YWxJRCk7XG4gICAgbS5yZWRyYXcoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgbGV0IHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICBsZXQgYm91bmRpbmdSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgc3RhcnRYID0gdG91Y2guY2xpZW50WDtcbiAgICBzdGFydFkgPSB0b3VjaC5jbGllbnRZO1xuICAgIGJvdW5kYXJpZXMgPSB7XG4gICAgICBtaW5YOiBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgIG1heFg6IGJvdW5kaW5nUmVjdC5yaWdodCxcbiAgICAgIG1pblk6IGJvdW5kaW5nUmVjdC50b3AsXG4gICAgICBtYXhZOiBib3VuZGluZ1JlY3QuYm90dG9tXG4gICAgfTtcbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGFjdGl2ZSkgZWwuY2xhc3NMaXN0LmFkZChBQ1RJVkVfQ0xBU1MpO1xuICAgIH0sIDIwMCk7XG4gICAgaWYgKCFoYXNDb250ZXh0TWVudSgpKSBob2xkVGltZW91dElEID0gc2V0VGltZW91dChvbkhvbGQsIEhPTERfRFVSQVRJT04pO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRJbnRlcnZhbElEKTtcbiAgICBpZiAocmVwZWF0SGFuZGxlcikgcmVwZWF0VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXBlYXRJbnRlcnZhbElEID0gc2V0VGltZW91dChvblJlcGVhdCwgUkVQRUFUX1JBVEUpO1xuICAgIH0sIDE1MCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgLy8gaWYgZ29pbmcgb3V0IG9mIGJvdW5kcywgbm8gd2F5IHRvIHJlZW5hYmxlIHRoZSBidXR0b25cbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBsZXQgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgYWN0aXZlID0gaXNBY3RpdmUodG91Y2gpO1xuICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvbGRUaW1lb3V0SUQpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVwZWF0VGltZW91dElkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcGVhdEludGVydmFsSUQpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XG4gICAgaWYgKGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRUaW1lb3V0SWQpO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRJbnRlcnZhbElEKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaG9sZFRpbWVvdXRJRCk7XG4gICAgICBpZiAodG91Y2hFbmRGZWVkYmFjaykgZWwuY2xhc3NMaXN0LmFkZChBQ1RJVkVfQ0xBU1MpO1xuICAgICAgdGFwSGFuZGxlcihlKTtcbiAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyksIDgwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoQ2FuY2VsKCkge1xuICAgIGNsZWFyVGltZW91dChob2xkVGltZW91dElEKTtcbiAgICBjbGVhclRpbWVvdXQocmVwZWF0VGltZW91dElkKTtcbiAgICBjbGVhclRpbWVvdXQocmVwZWF0SW50ZXJ2YWxJRCk7XG4gICAgYWN0aXZlID0gZmFsc2U7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShBQ1RJVkVfQ0xBU1MpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Db250ZXh0TWVudShlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGhvbGRUaW1lb3V0SUQgPT09IHVuZGVmaW5lZCkgb25Ib2xkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkhvbGQoKSB7XG4gICAgaWYgKGhvbGRIYW5kbGVyKSB7XG4gICAgICBob2xkSGFuZGxlcigpO1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNBY3RpdmUodG91Y2gpIHtcbiAgICBsZXQgeCA9IHRvdWNoLmNsaWVudFgsXG4gICAgICB5ID0gdG91Y2guY2xpZW50WSxcbiAgICAgIGIgPSBib3VuZGFyaWVzLFxuICAgICAgZCA9IDA7XG4gICAgaWYgKHNjcm9sbFgpIGQgPSBNYXRoLmFicyh4IC0gc3RhcnRYKTtcbiAgICBpZiAoc2Nyb2xsWSkgZCA9IE1hdGguYWJzKHkgLSBzdGFydFkpO1xuICAgIHJldHVybiB4IDwgYi5tYXhYICYmIHggPiBiLm1pblggJiYgeSA8IGIubWF4WSAmJiB5ID4gYi5taW5ZICYmIGQgPCBTQ1JPTExfVE9MRVJBTkNFO1xuICB9XG5cbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBvblRvdWNoQ2FuY2VsLCBmYWxzZSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UpO1xufVxuIiwiaW1wb3J0IFphbmltbyBmcm9tICd6YW5pbW8nO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IEJ1dHRvbkhhbmRsZXIgZnJvbSAnLi9idXR0b24nO1xuaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhcEhhbmRsZXIodGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIHNjcm9sbFgsIHNjcm9sbFksIGdldEVsZW1lbnQsIHByZXZlbnRFbmREZWZhdWx0KSB7XG4gIHJldHVybiBmdW5jdGlvbih2bm9kZSkge1xuICAgIEJ1dHRvbkhhbmRsZXIodm5vZGUuZG9tLFxuICAgICAgICAgICAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGFwSGFuZGxlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgaG9sZEhhbmRsZXIgPyAoZSkgPT4gdXRpbHMuYXV0b3JlZHJhdygoKSA9PiBob2xkSGFuZGxlcihlKSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICByZXBlYXRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgIHNjcm9sbFksXG4gICAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgcHJldmVudEVuZERlZmF1bHQpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb250YXAodGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIGdldEVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZVRhcEhhbmRsZXIodGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIGZhbHNlLCBmYWxzZSwgZ2V0RWxlbWVudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbnRhcFhZKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCBnZXRFbGVtZW50LCBwcmV2ZW50RW5kRGVmYXVsdCA9IHRydWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVRhcEhhbmRsZXIodGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHVuZGVmaW5lZCwgdHJ1ZSwgdHJ1ZSwgZ2V0RWxlbWVudCwgcHJldmVudEVuZERlZmF1bHQpO1xufVxuXG5cbi8vc3RvcmUgdGVtcG9yYXJpbHkgbGFzdCByb3V0ZSB0byBkaXNhYmxlIGFuaW1hdGlvbnMgb24gc2FtZSByb3V0ZVxuLy8gVE9ETyBmaW5kIGEgYmV0dGVyIHdheSBjYXVzZSB0aGlzIGlzIHVnbHlcbmxldCBsYXN0Um91dGU7XG5cbi8vIHRoaXMgbXVzdCBiZSBjYWNoZWQgYmVjYXVzZSBvZiB0aGUgYWNjZXNzIHRvIGRvY3VtZW50LmJvZHkuc3R5bGVcbmxldCBjYWNoZWRUcmFuc2Zvcm1Qcm9wO1xubGV0IGNhY2hlZFZpZXdwb3J0RGltID0gbnVsbDtcblxuZnVuY3Rpb24gdmlld1NsaWRlSW4oZWwsIGNhbGxiYWNrKSB7XG4gIGlmIChtLnJvdXRlKCkgPT09IGxhc3RSb3V0ZSkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGFzdFJvdXRlID0gbS5yb3V0ZSgpO1xuXG4gIGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIHV0aWxzLnNldFZpZXdTbGlkZURpcmVjdGlvbignZndkJyk7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBjb25zdCBkaXJlY3Rpb24gPSB1dGlscy5nZXRWaWV3U2xpZGVEaXJlY3Rpb24oKSA9PT0gJ2Z3ZCcgPyAnMTAwJScgOiAnLTEwMCUnO1xuICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtkaXJlY3Rpb259LDAsMClgO1xuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gJ3RyYW5zZm9ybSAyMDBtcyBlYXNlLW91dCc7XG5cbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtPSAndHJhbnNsYXRlM2QoMCUsMCwwKSc7XG4gIH0pO1xuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBhZnRlciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiB2aWV3U2xpZGVPdXQoZWwsIGNhbGxiYWNrKSB7XG4gIGlmIChtLnJvdXRlKCkgPT09IGxhc3RSb3V0ZSkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgdXRpbHMuc2V0Vmlld1NsaWRlRGlyZWN0aW9uKCdmd2QnKTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgY29uc3QgZGlyZWN0aW9uID0gdXRpbHMuZ2V0Vmlld1NsaWRlRGlyZWN0aW9uKCkgPT09ICdmd2QnID8gJy0xMDAlJyA6ICcxMDAlJztcbiAgZWwuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDAlLDAsMCknO1xuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gJ3RyYW5zZm9ybSAyMDBtcyBlYXNlLW91dCc7XG5cbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtPSBgdHJhbnNsYXRlM2QoJHtkaXJlY3Rpb259LDAsMClgO1xuICB9KTtcblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgYWZ0ZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gdmlld0ZhZGVzSW4oZWwsIGNhbGxiYWNrKSB7XG4gIHZhciB0SWQ7XG5cbiAgZWwuc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICBlbC5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMjAwbXMgZWFzZS1vdXQnO1xuXG4gIHNldFRpbWVvdXQoKCk9PiB7XG4gICAgZWwuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRJZCk7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZWQnLCBhZnRlciwgZmFsc2UpO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVkJywgYWZ0ZXIsIGZhbHNlKTtcblxuICAvLyBpbiBjYXNlIHRyYW5zaXRpb25lZCBkb2VzIG5vdCBmaXJlXG4gIC8vIFRPRE8gZmluZCBhIHdheSB0byBhdm9pZCBpdFxuICB0SWQgPSBzZXRUaW1lb3V0KGFmdGVyLCAyNTApO1xufVxuXG5mdW5jdGlvbiB2aWV3RmFkZXNPdXQoZWwsIGNhbGxiYWNrKSB7XG4gIHZhciB0SWQ7XG5cbiAgZWwuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDIwMG1zIGVhc2Utb3V0LCB2aXNpYmlsaXR5IDBzIGxpbmVhciAyMDBtcyc7XG5cbiAgc2V0VGltZW91dCgoKT0+IHtcbiAgICBlbC5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRJZCk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lZCcsIGFmdGVyLCBmYWxzZSk7XG5cbiAgLy8gaW4gY2FzZSB0cmFuc2l0aW9uZWQgZG9lcyBub3QgZmlyZVxuICAvLyBUT0RPIGZpbmQgYSB3YXkgdG8gYXZvaWQgaXRcbiAgdElkID0gc2V0VGltZW91dChhZnRlciwgMjUwKTtcbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvbkhhcyhjb2xsLCBlbCkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29sbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChjb2xsW2ldID09PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaW5kUGFyZW50QnlTZWxlY3RvcihlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIG1hdGNoZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgdmFyIGN1ciA9IGVsLnBhcmVudE5vZGU7XG4gIHdoaWxlIChjdXIgJiYgIWNvbGxlY3Rpb25IYXMobWF0Y2hlcywgY3VyKSkge1xuICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBjdXI7XG59XG5cbmZ1bmN0aW9uIG9udG91Y2godGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIHNjcm9sbFgsIHNjcm9sbFksIHRvdWNoRW5kRmVlZGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSkge1xuICAgIGlmICghaXNVcGRhdGUpIHtcbiAgICAgIEJ1dHRvbkhhbmRsZXIoZWwsXG4gICAgICAgICAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIG0uc3RhcnRDb21wdXRhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXBIYW5kbGVyKGUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLmVuZENvbXB1dGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBob2xkSGFuZGxlciA/ICgpID0+IHV0aWxzLmF1dG9yZWRyYXcoaG9sZEhhbmRsZXIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWSxcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hFbmRGZWVkYmFja1xuICAgICAgICAgICAgICAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlVHJhbnNmb3JtUHJvcCgpIHtcbiAgcmV0dXJuICd0cmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUgP1xuICAgICd0cmFuc2Zvcm0nIDogJ3dlYmtpdFRyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSA/XG4gICAgJ3dlYmtpdFRyYW5zZm9ybScgOiAnbW96VHJhbnNmb3JtJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlID9cbiAgICAnbW96VHJhbnNmb3JtJyA6ICdvVHJhbnNmb3JtJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlID9cbiAgICAnb1RyYW5zZm9ybScgOiAnbXNUcmFuc2Zvcm0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlld3BvcnREaW0oKSB7XG4gIGlmIChjYWNoZWRWaWV3cG9ydERpbSkgcmV0dXJuIGNhY2hlZFZpZXdwb3J0RGltO1xuXG4gIGxldCBlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBsZXQgdnBkID0gY2FjaGVkVmlld3BvcnREaW0gPSB7XG4gICAgdnc6IGUuY2xpZW50V2lkdGgsXG4gICAgdmg6IGUuY2xpZW50SGVpZ2h0XG4gIH07XG4gIHJldHVybiB2cGQ7XG59XG5cbi8vIGV4cG9ydCBkZWZhdWx0IHtcbi8vICAgc2xpZGluZ1BhZ2U6IGFuaW1hdG9yKHZpZXdTbGlkZUluLCB2aWV3U2xpZGVPdXQpLFxuLy8gICBmYWRpbmdQYWdlOiBhbmltYXRvcih2aWV3RmFkZXNJbiwgdmlld0ZhZGVzT3V0KSxcbi8vICAgdmlld3BvcnREaW0sXG4vLyAgIGNsZWFyQ2FjaGVkVmlld3BvcnREaW0oKSB7XG4vLyAgICAgY2FjaGVkVmlld3BvcnREaW0gPSBudWxsO1xuLy8gICB9LFxuXG4vLyAgIHRyYW5zZm9ybVByb3A6IGZ1bmN0aW9uKCkge1xuLy8gICAgIGlmICghY2FjaGVkVHJhbnNmb3JtUHJvcCkgY2FjaGVkVHJhbnNmb3JtUHJvcCA9IGNvbXB1dGVUcmFuc2Zvcm1Qcm9wKCk7XG4vLyAgICAgcmV0dXJuIGNhY2hlZFRyYW5zZm9ybVByb3A7XG4vLyAgIH0sXG5cbi8vICAgc2xpZGVzSW5VcDogZnVuY3Rpb24oZWwsIGlzVXBkYXRlLCBjb250ZXh0KSB7XG4vLyAgICAgaWYgKCFpc1VwZGF0ZSkge1xuLy8gICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoMTAwJSknO1xuLy8gICAgICAgLy8gZm9yY2UgcmVmbG93IGJhY2tcbi8vICAgICAgIGNvbnRleHQubG9sID0gZWwub2Zmc2V0SGVpZ2h0O1xuLy8gICAgICAgWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoMCknLCAyNTAsICdlYXNlLW91dCcpXG4vLyAgICAgICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTtcbi8vICAgICB9XG4vLyAgIH0sXG4vLyAgIHNsaWRlc091dERvd246IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbElEKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbElEKTtcbi8vICAgICAgIG0ucmVkcmF3LnN0cmF0ZWd5KCdub25lJyk7XG4vLyAgICAgICByZXR1cm4gWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZVkoMTAwJSknLCAyNTAsICdlYXNlLW91dCcpXG4vLyAgICAgICAgIC50aGVuKHV0aWxzLmF1dG9yZWRyYXcuYmluZChudWxsLCBjYWxsYmFjaykpXG4vLyAgICAgICAgIC5jYXRjaChjYWxsYmFjayk7XG4vLyAgICAgfTtcbi8vICAgfSxcblxuLy8gICBmYWRlc091dDogZnVuY3Rpb24oY2FsbGJhY2ssIHNlbGVjdG9yLCB0aW1lID0gMTUwKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbi8vICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4vLyAgICAgICB2YXIgZWwgPSBzZWxlY3RvciA/IGZpbmRQYXJlbnRCeVNlbGVjdG9yKGUudGFyZ2V0LCBzZWxlY3RvcikgOiBlLnRhcmdldDtcbi8vICAgICAgIG0ucmVkcmF3LnN0cmF0ZWd5KCdub25lJyk7XG4vLyAgICAgICByZXR1cm4gWmFuaW1vKGVsLCAnb3BhY2l0eScsIDAsIHRpbWUpXG4vLyAgICAgICAgIC50aGVuKCgpID0+IHV0aWxzLmF1dG9yZWRyYXcoY2FsbGJhY2spKVxuLy8gICAgICAgICAuY2F0Y2goY29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7XG4vLyAgICAgfTtcbi8vICAgfSxcblxuLy8gICBvbnRvdWNoOiBmdW5jdGlvbih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgdG91Y2hFbmRGZWVkYmFjayA9IHRydWUpIHtcbi8vICAgICByZXR1cm4gb250b3VjaCh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgZmFsc2UsIGZhbHNlLCB0b3VjaEVuZEZlZWRiYWNrKTtcbi8vICAgfSxcbi8vICAgb250b3VjaFg6IGZ1bmN0aW9uKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCB0b3VjaEVuZEZlZWRiYWNrID0gdHJ1ZSkge1xuLy8gICAgIHJldHVybiBvbnRvdWNoKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCBudWxsLCB0cnVlLCBmYWxzZSwgdG91Y2hFbmRGZWVkYmFjayk7XG4vLyAgIH0sXG4vLyAgIG9udG91Y2hZOiBmdW5jdGlvbih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgdG91Y2hFbmRGZWVkYmFjayA9IHRydWUpIHtcbi8vICAgICByZXR1cm4gb250b3VjaCh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgbnVsbCwgZmFsc2UsIHRydWUsIHRvdWNoRW5kRmVlZGJhY2spO1xuLy8gICB9LFxuLy8gICBjbGFzc1NldDogZnVuY3Rpb24oY2xhc3Nlcykge1xuLy8gICAgIHZhciBhcnIgPSBbXTtcbi8vICAgICBmb3IgKHZhciBpIGluIGNsYXNzZXMpIHtcbi8vICAgICAgIGlmIChjbGFzc2VzW2ldKSBhcnIucHVzaChpKTtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIGFyci5qb2luKCcgJyk7XG4vLyAgIH0sXG5cbi8vICAgaXNXaWRlU2NyZWVuOiBmdW5jdGlvbigpIHtcbi8vICAgICByZXR1cm4gdmlld3BvcnREaW0oKS52dyA+PSA2MDA7XG4vLyAgIH0sXG4vLyAgIGlzSXBhZExpa2U6IGZ1bmN0aW9uKCkge1xuLy8gICAgIGNvbnN0IHsgdmgsIHZ3IH0gPSB2aWV3cG9ydERpbSgpO1xuLy8gICAgIHJldHVybiB2aCA+PSA3MDAgJiYgdncgPD0gMTA1MDtcbi8vICAgfSxcbi8vICAgaXNQb3J0cmFpdDogZnVuY3Rpb24oKSB7XG4vLyAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcob3JpZW50YXRpb246IHBvcnRyYWl0KScpLm1hdGNoZXM7XG4vLyAgIH0sXG4vLyAgIGlzTGFuZHNjYXBlOiBmdW5jdGlvbigpIHtcbi8vICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEoJyhvcmllbnRhdGlvbjogbGFuZHNjYXBlKScpLm1hdGNoZXM7XG4vLyAgIH0sXG4vLyAgIHByb2dyZXNzOiBmdW5jdGlvbiAocCkge1xuLy8gICAgIGlmIChwID09PSAwKSByZXR1cm4gbnVsbDtcbi8vICAgICByZXR1cm4gbSgnc3BhbicsIHtcbi8vICAgICAgIGNsYXNzTmFtZTogJ3Byb2dyZXNzICcgKyAocCA+IDAgPyAncG9zaXRpdmUnIDogJ25lZ2F0aXZlJyksXG4vLyAgICAgICAnZGF0YS1pY29uJzogcCA+IDAgPyAnTicgOiAnTSdcbi8vICAgICB9LCBNYXRoLmFicyhwKSk7XG4vLyAgIH1cbi8vIH07XG4iLCJpbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgeyBsb2JieSBhcyBsb2JieVhociB9IGZyb20gJy4uLy4uL3hocic7XG5pbXBvcnQgeyBoYXNOZXR3b3JrLCBub29wLCBoYW5kbGVYaHJFcnJvciB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGlzRm9yZWdyb3VuZCwgc2V0Rm9yZWdyb3VuZCB9IGZyb20gJy4uLy4uL3V0aWxzL2FwcE1vZGUnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhvbWVDdHJsKCkge1xuICBjb25zdCBuYkNvbm5lY3RlZFBsYXllcnMgPSBtLnByb3AoKTtcbiAgY29uc3QgbmJHYW1lc0luUGxheSA9IG0ucHJvcCgpO1xuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgaWYgKGlzRm9yZWdyb3VuZCgpKSB7XG4gICAgICBsb2JieVhocih0cnVlKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICBzb2NrZXQuY3JlYXRlTG9iYnkoZGF0YS5sb2JieS52ZXJzaW9uLCBub29wLCB7XG4gICAgICAgICAgbjogKF8sIGQpID0+IHtcbiAgICAgICAgICAgIG5iQ29ubmVjdGVkUGxheWVycyhkLmQpO1xuICAgICAgICAgICAgbmJHYW1lc0luUGxheShkLnIpO1xuICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXN1bWUoKSB7XG4gICAgc2V0Rm9yZWdyb3VuZCgpO1xuICAgIGluaXQoKTtcbiAgfVxuXG4gIGlmIChoYXNOZXR3b3JrKCkpIHtcbiAgICBpbml0KCk7XG4gIH1cblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBpbml0KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgb25SZXN1bWUpO1xuXG4gIHJldHVybiB7XG4gICAgbmJDb25uZWN0ZWRQbGF5ZXJzLFxuICAgIG5iR2FtZXNJblBsYXksXG4gICAgb251bmxvYWQoKSB7XG4gICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgaW5pdCk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXN1bWUnLCBvblJlc3VtZSk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgeyByZW5kZXJRdWlja1NldHVwIH0gZnJvbSAnLi4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IG5ld0dhbWVGb3JtIGZyb20gJy4uL25ld0dhbWVGb3JtJztcbmltcG9ydCB7IGhlYWRlciBhcyBoZWFkZXJXaWRnZXQgfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gYm9keShjdHJsKSB7XG4gIGNvbnN0IG5iUGxheWVycyA9IGkxOG4oJ25iQ29ubmVjdGVkUGxheWVycycsIGN0cmwubmJDb25uZWN0ZWRQbGF5ZXJzKCkgfHwgJz8nKTtcbiAgY29uc3QgbmJHYW1lcyA9IGkxOG4oJ25iR2FtZXNJblBsYXknLCBjdHJsLm5iR2FtZXNJblBsYXkoKSB8fCAnPycpO1xuXG4gIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5hdGl2ZV9zY3JvbGxlciBwYWdlXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaG9tZVwiPlxuICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInN0YXRzXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm51bVBsYXllcnNcIj57bmJQbGF5ZXJzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJudW1HYW1lc1wiPntuYkdhbWVzfTwvZGl2PlxuICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgIHsgcmVuZGVyUXVpY2tHYW1lKCkgfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICApO1xuXG4gIC8vIGNvbnN0IGhlYWRlciA9IGhlYWRlcldpZGdldC5iaW5kKG51bGwsICdveXVua2V5Zi5uZXQnKTtcblxuICAvLyByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCBib2R5KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUXVpY2tHYW1lKCkge1xuICByZXR1cm4gaCgnZGl2LmhvbWVDcmVhdGUnLCBbXG4gICAgaCgnaDIuaG9tZVRpdGxlJywgJ0hlbWVuIG95bmEnKSxcbiAgICByZW5kZXJRdWlja1NldHVwKCgpID0+IG5ld0dhbWVGb3JtLm9wZW5SZWFsdGltZSgnY3VzdG9tJykpXG4gIF0pO1xufVxuIiwiaW1wb3J0IHN0cmVhbSBmcm9tICdtaXRocmlsL3N0cmVhbSc7XG5pbXBvcnQgY29udHJvbGxlciBmcm9tICcuL2hvbWVDdHJsJztcbmltcG9ydCB7IGRyb3BTaGFkb3dIZWFkZXIgfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCB7IGJvZHkgfSBmcm9tICcuL2hvbWVWaWV3JztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQoKSB7XG4gICAgY29uc3QgbmJDb25uZWN0ZWRQbGF5ZXJzID0gc3RyZWFtKCk7XG4gICAgY29uc3QgbmJHYW1lc0luUGxheSA9IHN0cmVhbSgpO1xuICAgIFxuICAgIHRoaXMuY3RybCA9IHtcbiAgICAgIG5iQ29ubmVjdGVkUGxheWVycyxcbiAgICAgIG5iR2FtZXNJblBsYXlcbiAgICB9O1xuICB9LFxuICBcbiAgdmlldygpIHtcbiAgICBjb25zdCBoZWFkZXIgPSBkcm9wU2hhZG93SGVhZGVyKCdveXVua2V5Zi5uZXQnKTtcblxuICAgIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIsIGJvZHkodGhpcy5jdHJsKSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCAqIGFzIG1lbnUgZnJvbSAnLi9tZW51JztcbmltcG9ydCBNZW51VmlldyBmcm9tICcuL21lbnUvbWVudVZpZXcnO1xuaW1wb3J0IGdhbWVzTWVudSBmcm9tICcuL2dhbWVzTWVudSc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgbG9naW5Nb2RhbCBmcm9tICcuL2xvZ2luTW9kYWwnO1xuaW1wb3J0IHNpZ251cE1vZGFsIGZyb20gJy4vc2lnbnVwTW9kYWwnO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MnO1xuXG52YXIgYmFja2dyb3VuZDtcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIGZyZWU6IGZ1bmN0aW9uKGhlYWRlciwgY29udGVudCwgZm9vdGVyLCBvdmVybGF5KSB7XG4gICAgYmFja2dyb3VuZCA9IGJhY2tncm91bmQgfHwgc2V0dGluZ3MuZ2VuZXJhbC50aGVtZS5iYWNrZ3JvdW5kKCk7XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgIGgoJ2Rpdi52aWV3LWNvbnRhaW5lcicsIHsgY2xhc3NOYW1lOiBiZ0NsYXNzKGJhY2tncm91bmQpIH0sIFtcbiAgICAgICAgaCgnbWFpbiNwYWdlJywgeyBvbmNyZWF0ZTogaGFuZGxlTWVudU9wZW4gfSwgW1xuICAgICAgICAgIGgoJ2hlYWRlci5tYWluX2hlYWRlcicsIGhlYWRlciksXG4gICAgICAgICAgaCgnZGl2I2ZyZWVfY29udGVudC5jb250ZW50Lm5hdGl2ZV9zY3JvbGxlcicsIGNvbnRlbnQpLFxuICAgICAgICAgIGZvb3RlciA/IGgoJ2Zvb3Rlci5tYWluX2Zvb3RlcicsIGZvb3RlcikgOiBudWxsLFxuICAgICAgICAgIGgoJ2RpdiNtZW51LWNsb3NlLW92ZXJsYXkubWVudS1iYWNrZHJvcCcsIHsgb25jcmVhdGU6IG1lbnUuYmFja2Ryb3BDbG9zZUhhbmRsZXIgfSlcbiAgICAgICAgXSksXG4gICAgICAgIGgoTWVudVZpZXcpXG4gICAgICBdKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWVudU9wZW4oKSB7XG59XG5cbmZ1bmN0aW9uIGJnQ2xhc3MoYmdUaGVtZSkge1xuICByZXR1cm4gYmdUaGVtZSA9PT0gJ2RhcmsnIHx8IGJnVGhlbWUgPT09ICdsaWdodCcgPyBiZ1RoZW1lIDogJ3RyYW5zcCAnICsgYmdUaGVtZTtcbn1cbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuLi94aHInO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmxldCBuYlBsYXllcnMgPSAwO1xubGV0IG5iR2FtZXMgPSAwO1xuXG5jb25zdCBsb2JieSA9IHt9O1xubG9iYnkuaXNPcGVuID0gZmFsc2U7XG5cbmxvYmJ5LnN0YXJ0U2Vla2luZyA9IGZ1bmN0aW9uKCkge1xuICB4aHIubmV3R2FtZSgpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgIC8vIGFuYWx5dGljc1xuICAgIG0ucm91dGUoJy9tYXNhLycgKyBkYXRhLmlkKTtcbiAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB1dGlscy5oYW5kbGVYaHJFcnJvcihlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBsb2JieTtcbiIsImltcG9ydCBzZXNzaW9uIGZyb20gJy4uL3Nlc3Npb24nO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4vaGVscGVyJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uL2JhY2tidXR0b24nO1xuaW1wb3J0IHNpZ251cE1vZGFsIGZyb20gJy4vc2lnbnVwTW9kYWwnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmNvbnN0IGxvZ2luTW9kYWwgPSB7fTtcblxudmFyIGlzT3BlbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzdWJtaXQoZm9ybSkge1xuICBjb25zdCBsb2dpbiA9IGZvcm1bMF0udmFsdWUudHJpbSgpO1xuICBjb25zdCBwYXNzID0gZm9ybVsxXS52YWx1ZTtcbiAgaWYgKCFsb2dpbiB8fCAhcGFzcykgcmV0dXJuIGZhbHNlO1xuICB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmNsb3NlKCk7XG4gIHJldHVybiBzZXNzaW9uLmxvZ2luKGxvZ2luLCBwYXNzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIGxvZ2luTW9kYWwuY2xvc2UoKTtcbiAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ2xvZ2luU3VjY2Vzc2Z1bCcpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4gICAgLy8gcHVzaC5yZWdpc3RlcigpO1xuICAgIHNlc3Npb24ucmVmcmVzaCgpXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWxvY2UvbGljaG9iaWxlL2Jsb2IvbWFzdGVyL3Byb2plY3Qvc3JjL2pzL3VpL2xvZ2luTW9kYWwuanMjTDI4XG4gICAgICAgICAgd2luZG93Lm5hdmlnYXRvci5ub3RpZmljYXRpb24uYWxlcnQoJ295dW5rZXlmQXV0aGVudGljYXRpb25DYW5ub3RXb3JrV2l0aG91dENvb2tpZXMnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pXG4gICAgLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbn1cblxubG9naW5Nb2RhbC5vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGJhY2tidXR0b24uc3RhY2sucHVzaChoZWxwZXIuc2xpZGVzT3V0RG93bihsb2dpbk1vZGFsLmNsb3NlLCAnbG9naW5Nb2RhbCcpKTtcbiAgaXNPcGVuID0gdHJ1ZTtcbn07XG5cbmxvZ2luTW9kYWwuY2xvc2UgPSBmdW5jdGlvbihmcm9tQkIpIHtcbiAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5jbG9zZSgpO1xuICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgaXNPcGVuKSBiYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBpc09wZW4gPSBmYWxzZTtcbn07XG5cbmxvZ2luTW9kYWwudmlldyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWlzT3BlbikgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIG0oJ2Rpdi5tb2RhbCNsb2dpbk1vZGFsJywgeyBjb25maWc6IGhlbHBlci5zbGlkZXNJblVwIH0sIFtcbiAgICBtKCdoZWFkZXInLCBbXG4gICAgICBtKCdidXR0b24ubW9kYWxfY2xvc2VbZGF0YS1pY29uPUxdJywge1xuICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKGhlbHBlci5zbGlkZXNPdXREb3duKGxvZ2luTW9kYWwuY2xvc2UsICdsb2dpbk1vZGFsJykpXG4gICAgICB9KSxcbiAgICAgIG0oJ2gyJywgaTE4bignc2lnbkluJykpXG4gICAgXSksXG4gICAgbSgnZGl2Lm1vZGFsX2NvbnRlbnQnLCBbXG4gICAgICBtKCdmb3JtLmxvZ2luJywge1xuICAgICAgICBvbnN1Ym1pdDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gc3VibWl0KGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSwgW1xuICAgICAgICBtKCdpbnB1dCNwc2V1ZG9bdHlwZT10ZXh0XScsIHtcbiAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bigndXNlcm5hbWUnKSxcbiAgICAgICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiAnb2ZmJyxcbiAgICAgICAgICBhdXRvY29ycmVjdDogJ29mZicsXG4gICAgICAgICAgc3BlbGxjaGVjazogJ2ZhbHNlJyxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgbSgnaW5wdXQjcGFzc3dvcmRbdHlwZT1wYXNzd29yZF0nLCB7XG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3Bhc3N3b3JkJyksXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIG0oJ2J1dHRvbi5mYXQnLCBpMThuKCdzaWduSW4nKSlcbiAgICAgIF0pLFxuICAgICAgbSgnZGl2LnNpZ251cCcsIFtcbiAgICAgICAgbSgnYScsIHtcbiAgICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKHNpZ251cE1vZGFsLm9wZW4pXG4gICAgICAgIH0sIFtpMThuKCduZXdUb095dW5rZXlmJyksICcgJywgaTE4bignc2lnblVwJyldKVxuICAgICAgXSlcbiAgICBdKVxuICBdKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxvZ2luTW9kYWw7XG4iLCJpbXBvcnQgY29udHJvbGxlciBmcm9tICcuL21hc2FEZXRhaWxDdHJsJztcbmltcG9ydCB2aWV3IGZyb20gJy4vbWFzYURldGFpbFZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXIsXG4gIHZpZXdcbn07XG4iLCJpbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uLy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuLi9tYXNhWGhyJztcbmltcG9ydCBmYXEgZnJvbSAnLi4vZmFxJztcbmltcG9ydCBwbGF5ZXJJbmZvIGZyb20gJy4uL3BsYXllckluZm8nO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRyb2xsZXIoKSB7XG4gIGNvbnN0IG1hc2EgPSBtLnByb3AoKTtcbiAgY29uc3QgaGFzSm9pbmVkID0gbS5wcm9wKGZhbHNlKTtcbiAgY29uc3QgaXNMb2FkaW5nID0gbS5wcm9wKGZhbHNlKTtcbiAgY29uc3QgZmFxQ3RybCA9IGZhcS5jb250cm9sbGVyKG1hc2EpO1xuICBjb25zdCBwbGF5ZXJJbmZvQ3RybCA9IHBsYXllckluZm8uY29udHJvbGxlcihtYXNhKTtcblxuICBmdW5jdGlvbiByZWxvYWQoZGF0YSkge1xuICAgIGlzTG9hZGluZyhmYWxzZSk7XG4gICAgY29uc3Qgb2xkRGF0YSA9IG1hc2EoKTtcbiAgICBtYXNhKGRhdGEpO1xuICAgIGhhc0pvaW5lZChkYXRhLm1lICYmIGRhdGEubWUuYWN0aXZlKTtcblxuICAgIGlmIChkYXRhLnNvY2tldFZlcnNpb24pIHtcbiAgICAgIHNvY2tldC5zZXRWZXJzaW9uKGRhdGEuc29ja2V0VmVyc2lvbik7XG4gICAgfVxuXG4gICAgaWYgKG9sZERhdGEucGxheWVySWQgIT09IGRhdGEucGxheWVySWQpIHtcbiAgICAgIC8vIHJlY29ubmVjdCB3aXRoIG5ldyBwbGF5ZXJJZFxuICAgICAgLy8gVE9ETyBtaWdodCBtaXNzIHJlZGlyZWN0XG4gICAgICBzb2NrZXQuY29ubmVjdCgpO1xuICAgIH1cbiAgICBtLnJlZHJhdygpO1xuICB9XG5cbiAgZnVuY3Rpb24gam9pbihpZCwgc2lkZSkge1xuICAgIHhoci5qb2luKGlkLCBzaWRlKS50aGVuKCgpID0+IHtcbiAgICAgIGhhc0pvaW5lZCh0cnVlKTtcbiAgICAgIG0ucmVkcmF3KCk7XG4gICAgfSkuY2F0Y2godXRpbHMuaGFuZGxlWGhyRXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aGRyYXcoaWQpIHtcbiAgICB4aHIud2l0aGRyYXcoaWQpLnRoZW4oKCkgPT4ge1xuICAgICAgaGFzSm9pbmVkKGZhbHNlKTtcbiAgICAgIG0ucmVkcmF3KCk7XG4gICAgfSkuY2F0Y2godXRpbHMuaGFuZGxlWGhyRXJyb3IpO1xuICB9XG5cbiAgY29uc3QgaWQgPSBtLnJvdXRlLnBhcmFtKCdpZCcpO1xuXG4gIGNvbnN0IHRocm90dGxlUmVsb2FkID0gdGhyb3R0bGUoKG0pID0+IHtcbiAgICBpc0xvYWRpbmcodHJ1ZSk7XG4gICAgeGhyLnJlbG9hZChtKVxuICAgICAgLnRoZW4ocmVsb2FkKVxuICAgICAgLmNhdGNoKCgpID0+IGlzTG9hZGluZyhmYWxzZSkpO1xuICB9LCAxMDAwKTtcblxuICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICByZWxvYWQ6ICgpID0+IHRocm90dGxlUmVsb2FkKGlkKSxcbiAgICByZXN5bmM6ICgpID0+IHRocm90dGxlUmVsb2FkKGlkKSxcbiAgICByZWRpcmVjdDogZnVuY3Rpb24oZ2FtZUlkKSB7XG4gICAgICBtLnJvdXRlKCcvbWFzYS8nICsgbWFzYSgpLmlkICsgJy9nYW1lLycgKyBnYW1lSWQsIG51bGwsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB4aHIubWFzYShpZCkudGhlbihkYXRhID0+IHtcbiAgICBtYXNhKGRhdGEpO1xuICAgIGhhc0pvaW5lZChkYXRhLm1lKTtcbiAgICBzb2NrZXQuY3JlYXRlTWFzYShpZCwgbWFzYSgpLnNvY2tldFZlcnNpb24sIGhhbmRsZXJzKTtcbiAgfSlcbiAgICAuY2F0Y2godXRpbHMuaGFuZGxlWGhyRXJyb3IpO1xuXG4gIHJldHVybiB7XG4gICAgbWFzYSxcbiAgICBoYXNKb2luZWQsXG4gICAgZmFxQ3RybCxcbiAgICBwbGF5ZXJJbmZvQ3RybCxcbiAgICBqb2luOiB0aHJvdHRsZShqb2luLCAxMDAwKSxcbiAgICB3aXRoZHJhdzogdGhyb3R0bGUod2l0aGRyYXcsIDEwMDApLFxuICAgIGlzTG9hZGluZyxcbiAgICBvbnVubG9hZDogKCkgPT4ge1xuICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgbWFwVmFsdWVzIGZyb20gJ2xvZGFzaC9tYXBWYWx1ZXMnO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5pbXBvcnQgeyBoZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi8uLi9zZXNzaW9uJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vLi4vbGF5b3V0JztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uLy4uL2kxOG4nO1xuaW1wb3J0IGZhcSBmcm9tICcuLi9mYXEnO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuLi8uLi9oZWxwZXInO1xuaW1wb3J0IHsgZ2FtZUljb24gfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlldyhjdHJsKSB7XG4gIGNvbnN0IGhlYWRlckN0cmwgPSBoZWFkZXJXaWRnZXRcbiAgICAgICAgLmJpbmQobnVsbCwgbnVsbCxcbiAgICAgICAgICAgICAgYmFja0J1dHRvbihjdHJsLm1hc2EoKSA/IGN0cmwubWFzYSgpLmZ1bGxOYW1lIDogbnVsbCkpO1xuICBjb25zdCBib2R5ID0gbWFzYUJvZHkuYmluZChudWxsLCBjdHJsKTtcbiAgY29uc3QgZm9vdGVyID0gcmVuZGVyRm9vdGVyLmJpbmQobnVsbCwgY3RybCk7XG4gIGNvbnN0IGZhcU92ZXJsYXkgPSByZW5kZXJGQVFPdmVybGF5LmJpbmQobnVsbCwgY3RybCk7XG4gIGNvbnN0IG92ZXJsYXkgPSAoKSA9PiBbZmFxT3ZlcmxheSgpXTtcblxuICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyQ3RybCwgYm9keSwgZm9vdGVyLCBvdmVybGF5KTtcbn07XG5cbmZ1bmN0aW9uIHJlbmRlckZBUU92ZXJsYXkoY3RybCkge1xuICByZXR1cm4gW1xuICAgIGZhcS52aWV3KGN0cmwuZmFxQ3RybClcbiAgXTtcbn1cblxuZnVuY3Rpb24gbWFzYUJvZHkoY3RybCkge1xuICBjb25zdCBkYXRhID0gY3RybC5tYXNhKCk7XG4gIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IGJvZHk7XG4gIGlmIChkYXRhLmlzRmluaXNoZWQpIHtcbiAgICBib2R5ID0gbWFzYUNvbnRlbnRGaW5pc2hlZChjdHJsKTtcbiAgfSBlbHNlIGlmICghZGF0YS5pc1N0YXJ0ZWQpIHtcbiAgICBib2R5ID0gbWFzYUNvbnRlbnRDcmVhdGVkKGN0cmwpO1xuICB9IGVsc2Uge1xuICAgIGJvZHkgPSBtYXNhQ29udGVudFN0YXJ0ZWQoY3RybCk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJtYXNhQ29udGFpbmVyIG5hdGl2ZV9zY3JvbGxlciBwYWdlIHdpdGhGb290ZXJcIj5cbiAgICAgIHtib2R5fVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiBtYXNhQ29udGVudEZpbmlzaGVkKGN0cmwpIHtcbiAgY29uc3QgZGF0YSA9IGN0cmwubWFzYSgpO1xuICByZXR1cm4gW1xuICAgIG1hc2FIZWFkZXIoZGF0YSwgZGF0YS5yb3VuZHNUb0ZpbmlzaCwgJycpLFxuICAgIGRhdGEucG9kaXVtID8gbWFzYVBvZGl1bShkYXRhLnBvZGl1bS5tYXAocCA9PlxuICAgICAgbWVyZ2UocCwgZGF0YS5wbGF5ZXJzW3AuaWRdKVxuICAgICkpIDogbnVsbCxcbiAgICBtYXNhTGVhZGVyYm9hcmQoY3RybClcbiAgXTtcbn1cblxuZnVuY3Rpb24gY3VycmVudEdhbWVzKGRhdGEpIHtcbiAgdmFyIGlkcyA9IHtcbiAgICBjcmVhdGVkOiAxMCxcbiAgICBzdGFydGVkOiAyMCxcbiAgICBhYm9ydGVkOiAyNSxcbiAgICBtaWRkbGVFbmQ6IDMwLFxuICAgIG5vcm1hbEVuZDogNDAsXG4gICAgdmFyaWFudEVuZDogNzBcbiAgfTtcbiAgcmV0dXJuIGRhdGEucGFpcmluZ3MuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gcC5zIDwgaWRzLmFib3J0ZWRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG15Q3VycmVudEdhbWVJZChkYXRhKSB7XG4gIHZhciBwbGF5ZXJJZCA9IGRhdGEucGxheWVySWQ7XG4gIGlmICghcGxheWVySWQpIHJldHVybiBudWxsO1xuXG4gIHZhciBwYWlyaW5nID0gY3VycmVudEdhbWVzKGRhdGEpLmZpbHRlcihwID0+XG4gICAgcC51LmZpbHRlcigoaWQpID0+XG4gICAgICBpZC50b0xvd2VyQ2FzZSgpID09PSBwbGF5ZXJJZC50b0xvd2VyQ2FzZSgpKVswXVxuICApWzBdO1xuXG4gIHJldHVybiBwYWlyaW5nID8gcGFpcmluZy5pZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIG1hc2FDb250ZW50U3RhcnRlZChjdHJsKSB7XG4gIGNvbnN0IGRhdGEgPSBjdHJsLm1hc2EoKTtcbiAgY29uc3QgZ2FtZUlkID0gbXlDdXJyZW50R2FtZUlkKGRhdGEpO1xuICBjb25zdCBwbGF5aW5ncyA9IGN1cnJlbnRHYW1lcyhkYXRhKTtcbiAgY29uc3QgY3VycmVudEdhbWVJZCA9IHBsYXlpbmdzWzBdID8gcGxheWluZ3NbMF0uaWQgOiBudWxsO1xuICByZXR1cm4gW1xuICAgIG1hc2FIZWFkZXIoZGF0YSwgZGF0YS5yb3VuZHNUb0ZpbmlzaCwgJycpLFxuICAgIGdhbWVJZCA/IG0oJ2EucG92LmJ1dHRvbi5nbG93ZWQnLCB7XG4gICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKG0ucm91dGUuYmluZChudWxsLCBgL21hc2EvJHtkYXRhLmlkfS9nYW1lLyR7Z2FtZUlkfWApKVxuICAgIH0sIFtcbiAgICAgIGkxOG4oJ3lvdUFyZVBsYXlpbmcnKSxcbiAgICAgIG0oJ3NwYW4udGV4dFtkYXRhLWljb249R10nLCBpMThuKCdqb2luVGhlR2FtZScpKVxuICAgIF0pIDogKGN1cnJlbnRHYW1lSWQgPyBcbiAgICAgICAgbSgnYS5wb3Yuc3BlY3RhdG9yLmJ1dHRvbicsIHtcbiAgICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKG0ucm91dGUuYmluZChudWxsLCBgL21hc2EvJHtkYXRhLmlkfS9nYW1lLyR7Y3VycmVudEdhbWVJZH1gKSlcbiAgICAgICAgfSwgW1xuICAgICAgICAgIGkxOG4oJ3BsYXlpbmdSaWdodE5vdycpLFxuICAgICAgICAgIG0oJ3NwYW4udGV4dFtkYXRhLWljb249R10nLCBpMThuKCdzcGVjdGF0ZUdhbWUnKSlcbiAgICAgICAgXSkgOiBudWxsKSxcbiAgICBtYXNhTGVhZGVyYm9hcmQoY3RybClcbiAgXTtcbn1cblxuXG5mdW5jdGlvbiBtYXNhQ29udGVudENyZWF0ZWQoY3RybCkge1xuICBjb25zdCBkYXRhID0gY3RybC5tYXNhKCk7XG4gIHJldHVybiBbXG4gICAgbWFzYUhlYWRlcihkYXRhLCBkYXRhLnJvdW5kc1RvRmluaXNoLCAnJyksXG4gICAgbWFzYVNlYXRzKGN0cmwpLFxuICAgIG1hc2FMZWFkZXJib2FyZChjdHJsKVxuICBdO1xufVxuXG5mdW5jdGlvbiBtYXNhSGVhZGVyKGRhdGEsIHJvdW5kcywgcm91bmRzVGV4dCkge1xuICBjb25zdCB2YXJpYW50ID0gdmFyaWFudERpc3BsYXkoZGF0YSk7XG4gIGNvbnN0IGNvbnRyb2wgPSBpMThuKCdyYXRlZCcpO1xuICBjb25zdCBoYW5kUyA9IGkxOG4oJ2hhbmRzJyk7XG4gIGNvbnN0IHJvdW5kU3RyaW5nID0gZGF0YS5yb3VuZHMgPyBgJHtkYXRhLm5iUm91bmRzfS8ke2RhdGEucm91bmRzfSR7aGFuZFN9YCA6IGAke2RhdGEuc2NvcmVzfVBgO1xuICBcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGtleT1cImhlYWRlclwiIGNsYXNzTmFtZT1cIm1hc2FIZWFkZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWFzYUluZm9Sb3VuZHNcIj5cbiAgICAgICAgPHN0cm9uZyBjbGFzc05hbWU9XCJtYXNhSW5mb1wiIGRhdGEtaWNvbj17Z2FtZUljb24odmFyaWFudEtleShkYXRhKSl9PlxuICAgICAgICAgIHt2YXJpYW50ICsgJyDigKIgJyArIGNvbnRyb2wgKyAnIOKAoiAnICsgcm91bmRTdHJpbmcgfVxuICAgICAgICA8L3N0cm9uZz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhQ3JlYXRvckluZm9cIj5cbiAgICAgICAgeyBpMThuKCdieScsIGZvcm1hdENyZWF0ZWRCeShkYXRhKSkgfVxuICAgICAgICAmbmJzcDvigKImbmJzcDtcbiAgICAgICAge3dpbmRvdy5tb21lbnQoZGF0YS5jcmVhdGVkQXQpLmNhbGVuZGFyKCkgfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hc2FTZWF0cyhjdHJsKSB7XG4gIGNvbnN0IGRhdGEgPSBjdHJsLm1hc2EoKTtcbiAgY29uc3QgcGxheWVycyA9IGRhdGEucGxheWVycztcbiAgY29uc3QgYWN0aXZlcyA9IG1hcFZhbHVlcyhkYXRhLmFjdGl2ZXMsIChwKSA9PiBwbGF5ZXJzW3AuaWRdKTtcbiAgY29uc3QgbWUgPSBkYXRhLm1lID8gZGF0YS5tZS5zaWRlIDogJyc7XG4gIHJldHVybiAoXG4gICAgPGRpdiBrZXk9XCJzZWF0c1wiIGNsYXNzTmFtZT1cIm1hc2FTZWF0c1wiPlxuICAgICAge21hc2FTZWF0KGN0cmwsICdub3J0aCcsIGFjdGl2ZXMubm9ydGgsIG1lKX1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWlkZGxlXCI+XG4gICAgICAgIHttYXNhU2VhdChjdHJsLCAnd2VzdCcsIGFjdGl2ZXMud2VzdCwgbWUpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhYmxlXCIvPlxuICAgICAgICB7bWFzYVNlYXQoY3RybCwgJ2Vhc3QnLCBhY3RpdmVzLmVhc3QsIG1lKX1cbiAgICAgIDwvZGl2PlxuICAgICAge21hc2FTZWF0KGN0cmwsICdzb3V0aCcsIGFjdGl2ZXMuc291dGgsIG1lKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGxheWVyTmFtZShwKSB7XG4gIHJldHVybiBwLmFpID8gaTE4bignYWlCb3QnLCBwLmFpKSA6XG4gICAgICAgICBwLm5hbWUgPyBwLm5hbWUgOiBpMThuKCdhbm9ueW1vdXMnKTtcbn1cblxuZnVuY3Rpb24gbWFzYVNlYXQoY3RybCwgc2lkZSwgcCwgbWUpIHtcbiAgY29uc3QgcGxheWVyTmFtZSA9IHAgPyBnZXRQbGF5ZXJOYW1lKHApOiAnJztcbiAgY29uc3QgY2xhc3NlcyA9ICcgaW4nICsgKHAgPyAnJyA6ICcgZW1wdHknKSArICgobWUgPT09IHNpZGVbMF0pID8gJyBtZScgOiAnJyk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e1wibWFzYVNlYXRcIiArIGNsYXNzZXMgfT5cbiAgICAgIHtwbGF5ZXJOYW1lID8gPHNwYW4gY2xhc3NOYW1lPVwidGl0bGVcIj57cGxheWVyTmFtZX08L3NwYW4+OiBqb2luQnV0dG9uKGN0cmwsICcnLCBzaWRlKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFzYUxlYWRlcmJvYXJkKGN0cmwpIHtcbiAgY29uc3QgZGF0YSA9IGN0cmwubWFzYSgpO1xuICBjb25zdCBwbGF5ZXJzID0gZGF0YS5zdGFuZGluZy5wbGF5ZXJzLm1hcChwID0+XG4gICAgbWVyZ2UocCwgZGF0YS5wbGF5ZXJzW3AuaWRdKVxuICApO1xuICBjb25zdCB1c2VyID0gc2Vzc2lvbi5nZXQoKTtcbiAgY29uc3QgdXNlck5hbWUgPSB1c2VyID8gdXNlci51c2VybmFtZSA6ICcnO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBrZXk9XCJsZWFkZXJib2FyZFwiIGNsYXNzTmFtZT1cIm1hc2FMZWFkZXJib2FyZFwiPlxuICAgICAgPHAgY2xhc3NOYW1lPVwibWFzYVRpdGxlXCI+IHtpMThuKCdsZWFkZXJib2FyZCcpfSAoe2kxOG4oJ25iUGxheWVycycsIGRhdGEubmJQbGF5ZXJzKX0pPC9wPlxuICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cIm1hc2FTdGFuZGluZ3NcIj5cbiAgICAgICAge3BsYXllcnMubWFwKHJlbmRlckxlYWRlcmJvYXJkSXRlbS5iaW5kKG51bGwsIGN0cmwucGxheWVySW5mb0N0cmwsIHVzZXJOYW1lLCBkYXRhLnBsYXllcklkKSl9XG4gICAgICA8L3RhYmxlPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiBtYXNhUGFpcmluZ3MoY3RybCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYga2V5PVwicGFpcmluZ3NcIiBjbGFzc05hbWU9XCJtYXNhUGFpcmluZ3NcIj5cbiAgICAgIDxwIGNsYXNzTmFtZT1cIm1hc2FUaXRsZVwiPiB7aTE4bigncm91bmRzJyl9PC9wPlxuICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cIm1hc2FQYWlyaW5nc1wiPlxuICAgICAgPC90YWJsZT5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTGVhZGVyYm9hcmRJdGVtKHBsYXllckluZm9DdHJsLCB1c2VyTmFtZSwgcGxheWVySWQsIHBsYXllcikge1xuICBjb25zdCBpc01lID0gcGxheWVyLmlkID09PSBwbGF5ZXJJZDtcbiAgY29uc3QgcGxheWVyTmFtZSA9IHBsYXllci5uYW1lIHx8IGdldFBsYXllck5hbWUocGxheWVyKTtcbiAgY29uc3QgcGxheWVyUmF0aW5nID0gcGxheWVyLnJhdGluZyA/ICgnICgnICsgcGxheWVyLnJhdGluZyArICcpICcpIDogJyc7XG4gIGNvbnN0IHBsYXllcldpdGhSYXRpbmcgPSBwbGF5ZXJOYW1lICsgcGxheWVyUmF0aW5nO1xuXG4gIHJldHVybiAoXG4gICAgPHRyIGtleT17cGxheWVyLm5hbWV9IGNsYXNzTmFtZT17J2xpc3RfaXRlbScgKyAoaXNNZSA/ICcgbWUnIDogJycpfSBjb25maWc9e2hlbHBlci5vbnRvdWNoWShwbGF5ZXJJbmZvQ3RybC5vcGVuLmJpbmQobnVsbCwgcGxheWVyKSl9PlxuICAgICAgPHRkIGNsYXNzTmFtZT0nbWFzYVBsYXllcic+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nZmxhZ1JhbmsnIGRhdGEtaWNvbj17cGxheWVyLmFjdGl2ZSA/ICcnOiAnYid9PlxuICAgICAgICAgIHtwbGF5ZXIuYWN0aXZlID8gKHBsYXllci5yYW5rICsgJy4gJykgOiAnJ31cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8c3Bhbj4geyBwbGF5ZXJXaXRoUmF0aW5nIH0gPC9zcGFuPlxuICAgICAgPC90ZD5cbiAgICAgIDx0ZCBjbGFzc05hbWU9J21hc2FQb2ludHMnPlxuICAgICAgICA8c3BhbiBkYXRhLWljb249J1EnPntwbGF5ZXIuc2NvcmV9PC9zcGFuPlxuICAgICAgPC90ZD5cbiAgICA8L3RyPlxuICApO1xufVxuXG5mdW5jdGlvbiBtYXNhUG9kaXVtKHBvZGl1bSkge1xuICByZXR1cm4gKFxuICAgIDxkaXYga2V5PVwicG9kaXVtXCIgY2xhc3NOYW1lPVwicG9kaXVtXCI+XG4gICAgICB7IHJlbmRlclBsYWNlKHBvZGl1bVswXSkgfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQbGFjZShkYXRhKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgcmFuayA9IGRhdGEucmFuaztcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17J3BsYWNlJyArIHJhbmt9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0cm9waHlcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVzZXJuYW1lXCIgY29uZmlnPXtkYXRhLm5hbWUgPyBoZWxwZXIub250b3VjaCgoKSA9PiBtLnJvdXRlKCcvQC8nICsgZGF0YS5uYW1lKSkgOiBudWxsfT5cbiAgICAgICAge2dldFBsYXllck5hbWUoZGF0YSl9XG4gICAgICA8L2Rpdj5cbiAgICAgIHtkYXRhLnJhdGluZyA/XG4gICAgICAgPGRpdiBjbGFzc05hbWU9XCJyYXRpbmdcIj4ge2RhdGEucmF0aW5nfSB7aGVscGVyLnByb2dyZXNzKGRhdGEucmF0aW5nRGlmZil9IDwvZGl2PlxuICAgICAgIDogbnVsbFxuICAgICAgfVxuICAgICAgIDx0YWJsZSBjbGFzc05hbWU9XCJzdGF0c1wiPlxuICAgICAgIDwvdGFibGU+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckZvb3RlcihjdHJsKSB7XG4gIGlmICghY3RybC5tYXNhKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zX2JhclwiPlxuICAgICAgPGJ1dHRvbiBrZXk9XCJmYXFcIiBjbGFzc05hbWU9XCJhY3Rpb25fYmFyX2J1dHRvblwiIGNvbmZpZz17aGVscGVyLm9udG91Y2goY3RybC5mYXFDdHJsLm9wZW4pfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcXVlc3Rpb24tY2lyY2xlXCIvPlxuICAgICAgICB7aTE4bignZmFxJyl9XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIHsgY3RybC5oYXNKb2luZWQoKSA/IHdpdGhkcmF3QnV0dG9uKGN0cmwpOiBqb2luQnV0dG9uKGN0cmwsIFwiYWN0aW9uX2Jhcl9idXR0b25cIikgfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiBqb2luQnV0dG9uKGN0cmwsIGtsYXNzLCBzaWRlKSB7XG4gIC8vaWYgKCFzZXNzaW9uLmlzQ29ubmVjdGVkKCkgfHwgY3RybC5tYXNhKCkuaXNGaW5pc2hlZCkge1xuICBpZiAoY3RybC5tYXNhKCkuaXNGaW5pc2hlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAga2xhc3MgPSBrbGFzcyB8fCBcIlwiO1xuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvbiBrZXk9XCJqb2luXCIgY2xhc3NOYW1lPXtrbGFzc30gY29uZmlnPXtoZWxwZXIub250b3VjaCgoKSA9PiBjdHJsLmpvaW4oY3RybC5tYXNhKCkuaWQsIHNpZGUpKX0+XG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1wbGF5XCIvPlxuICAgICAge2kxOG4oJ2pvaW4nKX1cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gd2l0aGRyYXdCdXR0b24oY3RybCkge1xuICAvLyBpZiAoIXNlc3Npb24uaXNDb25uZWN0ZWQoKSB8fCBjdHJsLm1hc2EoKS5pc0ZpbmlzaGVkKSB7XG4gIGlmIChjdHJsLm1hc2EoKS5pc0ZpbmlzaGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxidXR0b24ga2V5PVwid2l0aGRyYXdcIiBjbGFzc05hbWU9XCJhY3Rpb25fYmFyX2J1dHRvblwiIGNvbmZpZz17aGVscGVyLm9udG91Y2goKCkgPT4gY3RybC53aXRoZHJhdyhjdHJsLm1hc2EoKS5pZCkpfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWZsYWdcIi8+XG4gICAgICB7aTE4bignd2l0aGRyYXcnKX1cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gdmFyaWFudERpc3BsYXkoZGF0YSkge1xuICBsZXQgdmFyaWFudCA9IHZhcmlhbnRLZXkoZGF0YSk7XG4gIC8vIHZhcmlhbnQgPSB2YXJpYW50LnNwbGl0KCcgJylbMF07IC8vIEN1dCBvZmYgbmFtZXMgdG8gZmlyc3Qgd29yZFxuXG4gIC8vIGlmICh2YXJpYW50Lmxlbmd0aCA+IDApIHtcbiAgLy8gICB2YXJpYW50ID0gdmFyaWFudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhcmlhbnQuc3Vic3RyaW5nKDEpO1xuICAvLyB9XG5cbiAgcmV0dXJuIGkxOG4odmFyaWFudCk7XG59XG5cbmZ1bmN0aW9uIHZhcmlhbnRLZXkoZGF0YSkge1xuICBsZXQgdmFyaWFudCA9IGRhdGEudmFyaWFudDtcbiAgcmV0dXJuIHZhcmlhbnQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENyZWF0ZWRCeShkYXRhKSB7XG4gIGNvbnN0IHBsYXllciA9IGRhdGEucGxheWVyc1tkYXRhLmNyZWF0ZWRCeV07XG5cbiAgcmV0dXJuIHBsYXllciA/IChwbGF5ZXIubmFtZSA/IHBsYXllci5uYW1lIDogaTE4bignYW5vbnltb3VzJykpIDogZGF0YS5jcmVhdGVkQnk7XG59XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uLy4uL2JhY2tidXR0b24nO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKG1hc2EpIHtcbiAgICBsZXQgaXNPcGVuID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgYmFja2J1dHRvbi5zdGFjay5wdXNoKGNsb3NlKTtcbiAgICAgIGlzT3BlbiA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb3NlKGZyb21CQikge1xuICAgICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgICAgIGlzT3BlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvcGVuLFxuICAgICAgY2xvc2UsXG4gICAgICBpc09wZW46IGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNPcGVuOyB9LFxuICAgICAgbWFzYVxuICAgIH07XG4gIH0sXG4gIHZpZXc6IGZ1bmN0aW9uKGN0cmwpIHtcbiAgICBpZiAoIWN0cmwuaXNPcGVuKCkpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG1hc2EgPSBjdHJsLm1hc2EoKTtcblxuICAgIGlmICghbWFzYSkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbFwiIGlkPVwibWFzYUZhcU1vZGFsXCIgY29uZmlnPXtoZWxwZXIuc2xpZGVzSW5VcH0+XG4gICAgICAgIDxoZWFkZXI+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJtb2RhbF9jbG9zZVwiIGRhdGEtaWNvbj1cIkxcIlxuICAgICAgICAgICAgICAgICAgY29uZmlnPXtoZWxwZXIub250b3VjaChoZWxwZXIuc2xpZGVzT3V0RG93bihjdHJsLmNsb3NlLCBcIm1hc2FGYXFNb2RhbFwiKSl9Lz5cbiAgICAgICAgICA8aDI+e2kxOG4oJ21hc2FGQVEnKX08L2gyPlxuICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbF9jb250ZW50XCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhRmFxXCI+XG5cbiAgICAgICAgICAgIDxoMj5QdWFubMSxIG3EsT88L2gyPlxuXG4gICAgICAgICAgICB7IG1hc2EucmF0ZWQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAnQmF6xLEgbWFzYWxhciBwdWFubMSxZMSxciB2ZSByZXl0aW5naW5pemkgZXRraWxlci4nIDpcbiAgICAgICAgICAgIG1hc2EucmF0ZWQgP1xuICAgICAgICAgICAgICAnQnUgbWFzYSBwdWFubMSxZMSxciB2ZSByZXl0aW5naW5pemkgZXRraWxlci4nIDpcbiAgICAgICAgICAgICAgJ0J1IG1hc2EgcHVhbmzEsSAqZGXEn2lsZGlyKiB2ZSByZXl0aW5naW5pemkgKmV0a2lsZW1leiouJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICA8aDI+IFB1YW5sYXIgbmFzxLFsIGhlc2FwbGFuxLFyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNheWEga2F0xLFsxLFtZGEgaGVyIG95dW5jdSBvcnRheWEgZWwgc2F5xLFzxLEga2FkYXIgcHVhbsSxbsSxIGtveWFyLiBNYXNhIHNvbnVuZGEgb3J0YWRha2kgcHVhbmxhciDFn8O2eWxlIGRhxJ/EsXTEsWzEsXI6XG5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgPGxpPjEuICU1MCBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjIuICUyNSBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjMuICUxNSBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjQuICUxMCBwdWFuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgIMOWcm5lxJ9pbiAxMCBlbGxpayBiaXIgb3l1bmRhIG95dW5jdWxhcsSxbiBwdWFubGFyxLEgMTUwMCBvbHN1bi5cblxuICAgICAgICAgICAgTWFzYXlhIGthdMSxbGTEsWtsYXLEsW5kYSBwdWFubGFyxLEgMTQ5MCBvbHVyLiBPcnRhZGEgdG9wbGFtIDQwIHB1YW4gdmFyZMSxciwgdmUgxZ/DtnlsZSBkYcSfxLF0xLFsxLFyOlxuXG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgIDxsaT4xLiArMjAgPSAxNTEwPC9saT5cbiAgICAgICAgICAgICAgPGxpPjIuICsxMCA9IDE1MDA8L2xpPlxuICAgICAgICAgICAgICA8bGk+My4gKzYgPSAxNDk2PC9saT5cbiAgICAgICAgICAgICAgPGxpPjQuICs0ID0gMTQ5NDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuXG4gICAgICAgICAgICBNYXNhIGJpdG1lZGVuIGF5csSxbGFuIG95dW5jdSBwdWFuIGFsYW1hei5cblxuICAgICAgICAgICAgPGgyPiBLYXphbmFuIG5hc8SxbCBiZWxpcmxlbmlyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNhZGEgYsO8dMO8biBlbGxlciBveW5hbmTEsWt0YW4gc29ucmEgZW4gYXogY2V6YXPEsSBvbGFuIG95dW5jdSBnYWxpcCBpbGFuIGVkaWxpci5cblxuICAgICAgICAgICAgPGgyPiBNYXNhZGEgZXNsZXN0aXJtZSBuYXNpbCB5YXBpbGlyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNheWEgNCBveXVuY3Uga2F0aWxkaWdpbmRhIGVsIGJhc2xhci4gQmlyIGVsIGJpdHRpa3RlbiBzb25yYSB5ZW5pIGVsIGJhc2xhciwgeWVuaSBlbGUga2F0aWxtYWsgaWNpbiBveXVuY3VsYXIgbWFzYXlhIGdlcmkgZG9ubWVsaWRpci5cblxuICAgICAgICAgICAgPGgyPiBNYXNhIG5lIHphbWFuIGJpdGVyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNhZGEgZWwgc2F5xLFzxLEga2FkYXIgb3l1biBveW5hbmTEscSfxLFuZGEgbWFzYSBiaXRlci5cblxuICAgICAgICAgICAgPGgyPiBPeXVuZGFuIGF5csSxbG1hIDwvaDI+XG5cbiAgICAgICAgICAgIE95dW4gZGV2YW0gZWRlcmtlbiBveXVuZGFuIGF5cmlsYW4gb3l1bmN1IG1hc2FkYW4gYXRpbGlyLCB2ZSBvIGVsIGlwdGFsIG9sdXIuIE1hc2EgYml0bWVkZW4gbWFzYWRhbiBheXLEsWxhbiBveXVuY3UgcHVhbiBhbGFtYXouXG5cbiAgICAgICAgICAgIDxoMj4gRGnEn2VyIMO2bmVtbGkga3VyYWxsYXIgPC9oMj5cblxuICAgICAgICAgICAgU2lyYW5peiBnZWxkaWdpbmRlLCBveWFuYW1hIHPDvHJlbml6aSBhxZ9hcnNhbsSxeiBzaXN0ZW0gc2l6aW4geWVyaW5pemUgb3luYXIuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufTtcbiIsImltcG9ydCBjb250cm9sbGVyIGZyb20gJy4vbWFzYUN0cmwnO1xuaW1wb3J0IHZpZXcgZnJvbSAnLi9tYXNhVmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29udHJvbGxlcixcbiAgdmlld1xufTtcbiIsImltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gvdGhyb3R0bGUnO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi9zb2NrZXQnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4vbWFzYVhocic7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250cm9sbGVyKCkge1xuXG4gIGNvbnN0IG1hc2FzID0gbS5wcm9wKCk7XG4gIGNvbnN0IGN1cnJlbnRUYWIgPSBtLnByb3AobS5yb3V0ZS5wYXJhbSgndGFiJykgfHwgJ2NyZWF0ZWQnKTtcblxuICBmdW5jdGlvbiByZWxvYWQoZGF0YSkge1xuICAgIGRhdGEuc3RhcnRlZCA9IGRhdGEuc3RhcnRlZC5maWx0ZXIoc3VwcG9ydGVkKTtcbiAgICBkYXRhLmNyZWF0ZWQgPSBkYXRhLmNyZWF0ZWQuZmlsdGVyKHN1cHBvcnRlZCk7XG4gICAgZGF0YS5maW5pc2hlZCA9IGRhdGEuZmluaXNoZWQuZmlsdGVyKHN1cHBvcnRlZCk7XG4gICAgbWFzYXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICByZWxvYWQ6IGZ1bmN0aW9uKGRhdGEpIHsgcmVsb2FkKGRhdGEpOyBtLnJlZHJhdygpOyB9XG4gIH07XG5cbiAgc29ja2V0LmNyZWF0ZU1hc2FIb21lKGhhbmRsZXJzKTtcblxuXG4gIGNvbnN0IHJlZnJlc2ggPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgeGhyLmN1cnJlbnRNYXNhcygpLnRoZW4ocmVsb2FkKS5jYXRjaCh1dGlscy5oYW5kbGVYaHJFcnJvcik7XG4gIH0sIDEwMDApO1xuXG4gIHJlZnJlc2goKTtcblxuXG4gIHJldHVybiB7XG4gICAgbWFzYXMsXG4gICAgY3VycmVudFRhYixcbiAgICByZWZyZXNoXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRlZCh0KSB7XG4gIHJldHVybiBzZXNzaW9uLmlzQ29ubmVjdGVkKCkgfHwgKCF0LnJhdGVkICYmICF0Lm1Pbmx5KTtcbn1cbiIsImltcG9ydCBoIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgeyBoZWFkZXIgfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCB7IHBhZCwgZm9ybWF0TWFzYUR1cmF0aW9uLCBjYXBpdGFsaXplIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCB0YWJzIGZyb20gJy4uL3NoYXJlZC90YWJzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlldyhjdHJsKSB7XG4gIGNvbnN0IGJvZHlDdHJsID0gbWFzYUxpc3RCb2R5LmJpbmQobnVsbCwgY3RybCk7XG5cbiAgcmV0dXJuIGxheW91dC5mcmVlKGhlYWRlci5iaW5kKG51bGwsIGkxOG4oJ21hc2FzJykpLCBib2R5Q3RybCk7XG59XG5cbmNvbnN0IFRBQlMgPSAoaTE4bikgPT4gW3tcbiAga2V5OiAnc3RhcnRlZCcsXG4gIGxhYmVsOiBpMThuKCdpblByb2dyZXNzVGFibGVzJylcbn0sIHtcbiAga2V5OiAnY3JlYXRlZCcsXG4gIGxhYmVsOiBpMThuKCdvcGVuVGFibGVzJylcbn0sIHtcbiAga2V5OiAnZmluaXNoZWQnLFxuICBsYWJlbDogaTE4bignY29tcGxldGVkJylcbn1dO1xuXG5mdW5jdGlvbiB0YWJOYXZpZ2F0aW9uKGN1cnJlbnRUYWJGbikge1xuICByZXR1cm4gbSgnLm5hdi1oZWFkZXInLCBtLmNvbXBvbmVudCh0YWJzLCB7XG4gICAgYnV0dG9uczogVEFCUyhpMThuKSxcbiAgICBzZWxlY3RlZFRhYjogY3VycmVudFRhYkZuKCksXG4gICAgb25UYWJDaGFuZ2U6IGsgPT4ge1xuICAgICAgY29uc3QgbG9jID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5yZXBsYWNlKC9cXD90YWJcXD1cXHcrJC8sICcnKTtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCBsb2MgKyAnP3RhYj0nICsgayk7XG4gICAgICBjdXJyZW50VGFiRm4oayk7XG4gICAgfVxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIG1hc2FMaXN0Qm9keShjdHJsKSB7XG4gIGlmICghY3RybC5tYXNhcygpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgdGFiQ29udGVudCA9IGN0cmwubWFzYXMoKVtjdHJsLmN1cnJlbnRUYWIoKV07XG5cbiAgcmV0dXJuIG0oJy5tb2R1bGUtdGFicy50YWJzLXJvdXRpbmcnLCBbXG4gICAgdGFiTmF2aWdhdGlvbihjdHJsLmN1cnJlbnRUYWIpLFxuICAgIG0oJy50YWItY29udGVudC5sYXlvdXQuY2VudGVyLWNlbnRlci5uYXRpdmVfc2Nyb2xsZXInLFxuICAgICAgcmVuZGVyTWFzYUxpc3QodGFiQ29udGVudCwgY3RybC5jdXJyZW50VGFiKCksIGN0cmwucmVmcmVzaClcbiAgICAgKVxuICBdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWFzYUxpc3QobGlzdCwgaWQsIG9uUmVmcmVzaCkge1xuICByZXR1cm4gbGlzdC5sZW5ndGggP1xuICAgIChcbiAgICAgICAgPHRhYmxlIGtleT17aWR9IGNsYXNzTmFtZT0nbWFzYUxpc3QnPlxuICAgICAgICB7bGlzdC5tYXAocmVuZGVyTWFzYUxpc3RJdGVtKX1cbiAgICAgIDwvdGFibGU+XG4gICAgKSA6XG4gIChcbiAgICA8ZGl2IGNsYXNzTmFtZT0ndmVydGljYWxfYWxpZ24gZW1wdHlfbWFzYXNfbGlzdCc+XG4gICAgPGRpdj57aTE4bignbm90aGluZ0hlcmUnKX08L2Rpdj5cbiAgICA8YnV0dG9uIGlkPSdyZWZyZXNoQnV0dG9uJyBjb25maWc9e2hlbHBlci5vbnRvdWNoWShvblJlZnJlc2gpfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT0nZmEgZmEtcmVmcmVzaCc+PC9zcGFuPlxuICAgICAge2kxOG4oJ3JlZnJlc2gnKX1cbiAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWFzYUxpc3RJdGVtKG1hc2EpIHtcbiAgY29uc3QgbW9kZSA9IG1hc2EucmF0ZWQgPyBpMThuKCdyYXRlZCcpIDogaTE4bignY2FzdWFsJyk7XG4gIGNvbnN0IGR1cmF0aW9uID0gZm9ybWF0TWFzYUR1cmF0aW9uKG1hc2Eucm91bmRzLCBtYXNhLnNjb3Jlcyk7XG4gIGNvbnN0IHZhcmlhbnQgPSBjYXBpdGFsaXplKG1hc2EudmFyaWFudC5zaG9ydCk7XG5cbiAgcmV0dXJuIChcbiAgICA8dHIga2V5PXttYXNhLmlkfVxuICAgIGNsYXNzTmFtZT17J2xpc3RfaXRlbSBtYXNhX2l0ZW0nfVxuICAgIGNvbmZpZz17aC5vbnRvdWNoWSgoKSA9PiBtLnJvdXRlKCcvbWFzYS8nICsgbWFzYS5pZCkpfT5cbiAgICAgIDx0ZCBjbGFzc05hbWU9XCJtYXNhTGlzdE5hbWVcIiBkYXRhLWljb249e21hc2EucGVyZiA/IG1hc2EucGVyZi5pY29uOiAnOCd9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZ1bGxOYW1lXCI+e21hc2EuZnVsbE5hbWV9PC9kaXY+XG4gICAgICAgIDxzbWFsbCBjbGFzc05hbWU9XCJpbmZvc1wiPiB7dmFyaWFudH0ge21vZGV9IOKAoiB7ZHVyYXRpb259IDwvc21hbGw+XG4gICAgICA8L3RkPlxuICAgICAgPHRkIGNsYXNzTmFtZT1cIm1hc2FMaXN0VGltZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRpbWVcIj57Zm9ybWF0VGltZShtYXNhLmNyZWF0ZWRBdCl9PC9kaXY+XG4gICAgICAgIDxzbWFsbCBjbGFzc05hbWU9XCJuYlVzZXJzIHdpdGhJY29uXCIgZGF0YS1pY29uPVwiclwiPnttYXNhLm5iUGxheWVyc308L3NtYWxsPlxuICAgICAgPC90ZD5cbiAgICAgIDx0ZCBjbGFzc05hbWU9XCJtYXNhTGlzdE5hdlwiPlxuICAgICAgICAmI3hmMDU0O1xuICAgICAgPC90ZD5cbiAgICA8L3RyPlxuICApO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lKHRpbWVJbk1pbGxpcykge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZUluTWlsbGlzKTtcbiAgY29uc3QgaG91cnMgPSBwYWQoZGF0ZS5nZXRIb3VycygpLnRvU3RyaW5nKCksIDIpO1xuICBjb25zdCBtaW5zID0gcGFkKGRhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCksIDIpO1xuICByZXR1cm4gaG91cnMgKyAnOicgKyBtaW5zO1xufVxuIiwiaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJy4uLy4uL2h0dHAnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudE1hc2FzKCkge1xuICByZXR1cm4gcmVxdWVzdCgnL21hc2EnLCB7fSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXNhKGlkKSB7XG4gIHJldHVybiByZXF1ZXN0KCcvbWFzYS8nICsgaWQsIHsgZGF0YToge3NvY2tldFZlcnNpb246IDF9fSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWxvYWQoaWQpIHtcbiAgcmV0dXJuIHJlcXVlc3QoJy9tYXNhLycgKyBpZCxcbiAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogdHJ1ZVxuICAgICAgICAgICAgICAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpvaW4oaWQsIHNpZGUpIHtcbiAgc2lkZSA9IHNpZGUgPyBgP3NpZGU9JHtzaWRlfWA6ICcnO1xuICByZXR1cm4gcmVxdWVzdCgnL21hc2EvJyArIGlkICsgJy9qb2luJyArIHNpZGUsIHsgbWV0aG9kOiAnUE9TVCcgfSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoZHJhdyhpZCkge1xuICByZXR1cm4gcmVxdWVzdCgnL21hc2EvJyArIGlkICsgJy93aXRoZHJhdycsIHsgbWV0aG9kOiAnUE9TVCcgfSwgdHJ1ZSk7XG59XG4iLCJpbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi8uLi9iYWNrYnV0dG9uJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKG1hc2EpIHtcbiAgICBsZXQgaXNPcGVuID0gZmFsc2U7XG4gICAgY29uc3QgcGxheWVyRGF0YSA9IG0ucHJvcCgpO1xuXG4gICAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIGJhY2tidXR0b24uc3RhY2sucHVzaChjbG9zZSk7XG4gICAgICBpc09wZW4gPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZShmcm9tQkIpIHtcbiAgICAgIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIGJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4gICAgICBpc09wZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3BlbixcbiAgICAgIGNsb3NlLFxuICAgICAgaXNPcGVuOiBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT3BlbjsgfSxcbiAgICAgIG1hc2FcbiAgICB9O1xuICB9LFxuICB2aWV3OiBmdW5jdGlvbihjdHJsKSB7XG4gICAgXG4gIH1cbn07XG4iLCJpbXBvcnQgc3RyZWFtIGZyb20gJ21pdGhyaWwvc3RyZWFtJztcbmltcG9ydCBaYW5pbW8gZnJvbSAnemFuaW1vJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uLy4uL2JhY2tidXR0b24nO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgU2lkZU1lbnVDdHJsIGZyb20gJy4uL3NoYXJlZC9zaWRlTWVudS9TaWRlTWVudUN0cmwnO1xuaW1wb3J0IHsgb250YXAgfSBmcm9tICcuLi9oZWxwZXInO1xuXG5cbmV4cG9ydCBjb25zdCBwcm9maWxlTWVudU9wZW4gPSBzdHJlYW0oZmFsc2UpO1xuXG5mdW5jdGlvbiBvbk1lbnVPcGVuKCkge1xufVxuXG5mdW5jdGlvbiBvbk1lbnVDbG9zZSgpIHtcbn1cblxuXG5leHBvcnQgY29uc3QgbWFpbk1lbnVDdHJsID0gbmV3IFNpZGVNZW51Q3RybChcbiAgJ2xlZnQnLFxuICAnc2lkZV9tZW51JyxcbiAgJ21lbnUtY2xvc2Utb3ZlcmxheScsXG4gIG9uTWVudU9wZW4sXG4gIG9uTWVudUNsb3NlXG4pO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1haW5NZW51Q3RybC5jbG9zZSgpLnRoZW4oKCkgPT4gcm91dGVyLnNldChyb3V0ZSkpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBiYWNrZHJvcENsb3NlSGFuZGxlciA9IG9udGFwKCgpID0+IHtcbiAgbWFpbk1lbnVDdHJsLmNsb3NlKCk7XG59KTtcblxuY29uc3QgbWVudSA9IHt9O1xuXG4vKiBwcm9wZXJ0aWVzICovXG5tZW51LmlzT3BlbiA9IGZhbHNlO1xuLy8gbWVudS5oZWFkZXJPcGVuID0gbS5wcm9wKGZhbHNlKTtcblxubWVudS5yb3V0ZSA9IGZ1bmN0aW9uKHJvdXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWVudS5jbG9zZSgpLnRoZW4obS5yb3V0ZS5iaW5kKG51bGwsIHJvdXRlKSk7XG4gIH07XG59O1xuXG5tZW51LnBvcHVwID0gZnVuY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWVudS5jbG9zZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgYWN0aW9uKCk7XG4gICAgICBtLnJlZHJhdygpO1xuICAgIH0pO1xuICB9O1xufTtcblxubWVudS50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKG1lbnUuaXNPcGVuKSBtZW51LmNsb3NlKCk7XG4gIGVsc2UgbWVudS5vcGVuKCk7XG59O1xuXG5tZW51Lm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgYmFja2J1dHRvbi5zdGFjay5wdXNoKG1lbnUuY2xvc2UpO1xuICBtZW51LmlzT3BlbiA9IHRydWU7XG59O1xuXG5tZW51LndpbGxDbG9zZSA9IGZhbHNlO1xubWVudS5jbG9zZSA9IGZ1bmN0aW9uKGZyb21CQikge1xuICBjb25zdCBzaWRlTWVudSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaWRlX21lbnUnKTtcblxuICBpZiAobWVudS53aWxsQ2xvc2UgfHwgIXNpZGVNZW51KSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuXG4gIG1lbnUud2lsbENsb3NlID0gdHJ1ZTtcbiAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIG1lbnUuaXNPcGVuKSBiYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBtLnJlZHJhdy5zdHJhdGVneSgnbm9uZScpO1xuICByZXR1cm4gWmFuaW1vKFxuICAgIHNpZGVNZW51LFxuICAgICd0cmFuc2Zvcm0nLFxuICAgICd0cmFuc2xhdGUzZCgtMTAwJSwwLDAnLCAyNTAsICdlYXNlLW91dCdcbiAgKS50aGVuKCgpID0+IHtcbiAgICBtZW51LmhlYWRlck9wZW4oZmFsc2UpO1xuICAgIG1lbnUuaXNPcGVuID0gZmFsc2U7XG4gICAgbWVudS53aWxsQ2xvc2UgPSBmYWxzZTtcbiAgICBtLnJlZHJhdygpO1xuICB9KVxuICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICBtZW51LmhlYWRlck9wZW4oZmFsc2UpO1xuICAgICAgbWVudS5pc09wZW4gPSBmYWxzZTtcbiAgICAgIG1lbnUud2lsbENsb3NlID0gZmFsc2U7XG4gICAgICBtLnJlZHJhdygpO1xuICAgIH0pO1xufTtcblxubWVudS50b2dnbGVIZWFkZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG1lbnUuaGVhZGVyT3BlbigpID8gbWVudS5oZWFkZXJPcGVuKGZhbHNlKSA6IG1lbnUuaGVhZGVyT3Blbih0cnVlKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1lbnU7XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uLy4uL3Nlc3Npb24nO1xuaW1wb3J0IGxvZ2luTW9kYWwgZnJvbSAnLi4vbG9naW5Nb2RhbCc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IHsgaGFzTmV0d29yaywgbm9vcCB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IFphbmltbyBmcm9tICd6YW5pbW8nO1xuaW1wb3J0ICogYXMgbWVudSBmcm9tICcuJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmJlZm9yZXVwZGF0ZSgpIHtcbiAgICByZXR1cm4gbWVudS5tYWluTWVudUN0cmwuaXNPcGVuO1xuICB9LFxuXG4gIHZpZXcoKSB7XG4gICAgY29uc3QgdXNlciA9IHNlc3Npb24uZ2V0KCk7XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgIDxhc2lkZSBpZD1cInNpZGVfbWVudVwiPlxuICAgICAgICB7cmVuZGVySGVhZGVyKCl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibmF0aXZlX3Njcm9sbGVyIHNpZGVfbWVudV9zY3JvbGxlclwiPlxuICAgICAgICAgIHt1c2VyICYmIG1lbnUucHJvZmlsZU1lbnVPcGVuKCkgPyByZW5kZXJQcm9maWxlQWN0aW9ucyh1c2VyKSA6IHJlbmRlckxpbmtzKHVzZXIpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvYXNpZGU+XG5cbiAgICApO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZW5kZXJIZWFkZXIodXNlcikge1xuICBjb25zdCBwcm9maWxlTGluayA9IHVzZXIgPyBtZW51LnJvdXRlKCcvQC8nICsgdXNlci5pZCkgOiBub29wO1xuXG4gIHJldHVybiAoXG4gICAgPGhlYWRlciBjbGFzc05hbWU9XCJzaWRlX21lbnVfaGVhZGVyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInNpZ25JbkJ1dHRvblwiPlxuICAgICAgICB7aTE4bignc2lnbkluJyl9XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2hlYWRlcj5cbiAgKTtcbn1cblxuXG5mdW5jdGlvbiBzbGlkZXNJblVwKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuICBpZiAoIWlzVXBkYXRlKSB7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKSc7XG4gICAgLy8gZm9yY2UgcmVmbG93IGJhY2tcbiAgICBjb250ZXh0LmxvbCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICBaYW5pbW8oZWwsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJywgMjUwLCAnZWFzZS1vdXQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJQcm9maWxlQWN0aW9uc09MRCh1c2VyKSB7XG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT1cInNpZGVfbGlua3MgcHJvZmlsZUFjdGlvbnNcIj5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRhcFhZKG1lbnUucm91dGUoJy9ALycgKyB1c2VyLmlkKSl9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS11c2VyXCIvPntpMThuKCdwcm9maWxlJyl9XG4gICAgPC9saT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRhcFhZKG1lbnUucm91dGUoJy9zZXR0aW5ncy9wcmVmZXJlbmNlcycpKX0+XG4gICAgICAgIDxzcGFuIGRhdGEtaWNvbj1cIiVcIiAvPntpMThuKCdwcmVmZXJlbmNlcycpfVxuICAgICAgPC9saT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRhcFhZKCgpID0+IHtcbiAgICAgICAgc2Vzc2lvbi5sb2dvdXQoKTtcbiAgICAgICAgbWVudS5wcm9maWxlTWVudU9wZW4oZmFsc2UpO1xuICAgICAgfSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCJ3XCIgLz5cbiAgICAgICAge2kxOG4oJ2xvZ091dCcpfVxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaW5rcyh1c2VyKSB7XG5cbiAgcmV0dXJuIChcbiAgICA8dWwgY2xhc3NOYW1lPVwic2lkZV9saW5rc1wiPlxuICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGtleT1cImhvbWVcIiBjb25maWc9e2hlbHBlci5vbnRhcFhZKG1lbnUucm91dGUoJy8nKSl9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1ob21lXCIgLz57aTE4bignaG9tZScpfVxuICAgICAgPC9saT5cbiAgICAgIHtoYXNOZXR3b3JrKCkgPyBcbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cInNlcF9saW5rXCIga2V5PVwic2VwX2xpbmtfb25saW5lXCI+e2kxOG4oJ3BsYXlPbmxpbmUnKX08L2xpPiA6IG51bGwgXG4gICAgICB9XG4gICAgICB7aGFzTmV0d29yaygpID9cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGRhdGEtcG9wdXA9XCJjcmVhdGVBR2FtZVwiPlxuICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcGx1cy1jaXJjbGVcIi8+e2kxOG4oJ2NyZWF0ZUFHYW1lJyl9XG4gICAgICAgIDwvbGk+IDogbnVsbCB9XG4gICAgICB7aGFzTmV0d29yaygpID8gPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGRhdGEtcm91dGU9XCIvbWFzYXNcIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXRyb3BoeVwiLz57aTE4bignbWFzYXMnKX1cbiAgICAgICA8L2xpPiA6IG51bGwgfVxuICAgICAge2hhc05ldHdvcmsoKSA/IDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBkYXRhLXJvdXRlPVwiL3BsYXllcnNcIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWF0XCIvPntpMThuKCdwbGF5ZXJzJyl9XG4gICAgICAgPC9saT4gOiBudWxsIH1cbiAgICAgIHtoYXNOZXR3b3JrKCkgPyA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgZGF0YS1yb3V0ZT1cIi9yYW5raW5nXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWN1YmVzXCIvPntpMThuKCdsZWFkZXJib2FyZCcpfVxuICAgICAgIDwvbGk+IDogbnVsbCB9XG4gICAgICAgPGxpIGNsYXNzTmFtZT1cImhyXCI+PC9saT5cbiAgICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgZGF0YS1yb3V0ZT1cIi9zZXR0aW5nc1wiPlxuICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtY29nXCIvPntpMThuKCdzZXR0aW5ncycpfVxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICApO1xufVxuXG5cbi8vIE9MRFxuXG5mdW5jdGlvbiByZW5kZXJQcm9maWxlQWN0aW9uc09MRCh1c2VyKSB7XG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT1cInNpZGVfbGlua3MgcHJvZmlsZUFjdGlvbnNcIj5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRvdWNoKG1lbnUucm91dGUoJy9ALycgKyB1c2VyLmlkKSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCJyXCIgLz5cbiAgICAgICAge2kxOG4oJ3Byb2ZpbGUnKX1cbiAgICAgIDwvbGk+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250b3VjaChtZW51LnJvdXRlKCcvc2V0dGluZ3MvcHJlZmVyZW5jZXMnKSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCIlXCIgLz5cbiAgICAgICAge2kxOG4oJ3ByZWZlcmVuY2VzJyl9XG4gICAgICA8L2xpPlxuICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGNvbmZpZz17aGVscGVyLm9udG91Y2goKCkgPT4ge1xuICAgICAgICBzZXNzaW9uLmxvZ291dCgpO1xuICAgICAgICBtZW51LmhlYWRlck9wZW4oZmFsc2UpO1xuICAgICAgfSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCJ3XCIgLz5cbiAgICAgICAge2kxOG4oJ2xvZ091dCcpfVxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaW5rc09MRCh1c2VyKSB7XG5cbiAgcmV0dXJuIChcbiAgICA8dWwgY2xhc3NOYW1lPVwic2lkZV9saW5rc1wiPlxuICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGtleT1cImhvbWVcIiBjb25maWc9e2hlbHBlci5vbnRvdWNoWShtZW51LnJvdXRlKCcvJykpfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtaG9tZVwiIC8+e2kxOG4oJ2hvbWUnKX1cbiAgICA8L2xpPlxuICAgIHtoYXNOZXR3b3JrKCkgPyA8bGkgY2xhc3NOYW1lPVwic2VwX2xpbmtcIiBrZXk9XCJzZXBfbGlua19vbmxpbmVcIj57aTE4bigncGxheU9ubGluZScpfTwvbGk+IDogbnVsbCB9XG4gICAge2hhc05ldHdvcmsoKSA/IDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBrZXk9XCJwbGF5X3JlYWxfdGltZVwiIGNvbmZpZz17aGVscGVyLm9udG91Y2hZKG1lbnUucG9wdXAobmV3R2FtZUZvcm0ub3BlblJlYWx0aW1lKSl9PlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcGx1cy1jaXJjbGVcIi8+e2kxOG4oJ2NyZWF0ZUFHYW1lJyl9XG4gICAgPC9saT4gOiBudWxsIH1cbiAgICB7aGFzTmV0d29yaygpID8gPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGtleT1cIm1hc2FzXCIgY29uZmlnPXtoZWxwZXIub250b3VjaFkobWVudS5yb3V0ZSgnL21hc2EnKSl9PlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtdHJvcGh5XCIvPntpMThuKCdtYXNhcycpfVxuICAgIDwvbGk+IDogbnVsbCB9XG4gICAge2hhc05ldHdvcmsoKSA/IDxsaSBjbGFzc05hbWU9XCJzZXBfbGlua1wiIGtleT1cInNlcF9saW5rX2NvbW11bml0eVwiPlxuICAgICAge2kxOG4oJ2NvbW11bml0eScpfVxuICAgIDwvbGk+IDogbnVsbCB9XG4gICAge2hhc05ldHdvcmsoKSA/IDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBrZXk9XCJwbGF5ZXJzXCIgY29uZmlnPXtoZWxwZXIub250b3VjaFkobWVudS5yb3V0ZSgnL3BsYXllcnMnKSl9PlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtYXRcIi8+e2kxOG4oJ3BsYXllcnMnKX1cbiAgICA8L2xpPiA6IG51bGwgfVxuICAgIHtoYXNOZXR3b3JrKCkgPyA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIga2V5PVwicmFua2luZ1wiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtY3ViZXNcIi8+e2kxOG4oJ2xlYWRlcmJvYXJkJyl9XG4gICAgPC9saT4gOiBudWxsIH1cbiAgICA8bGkgY2xhc3NOYW1lPVwiaHJcIiBrZXk9XCJzZXRfbGlua19zZXR0aW5nc1wiPjwvbGk+XG4gICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGtleT1cInNldHRpbmdzXCIgY29uZmlnPXtoZWxwZXIub250b3VjaFkobWVudS5yb3V0ZSgnL3NldHRpbmdzJykpfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWNvZ1wiLz57aTE4bignc2V0dGluZ3MnKX1cbiAgICA8L2xpPlxuICAgIDwvdWw+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1lbnUoKSB7XG4gIGNvbnN0IHVzZXIgPSBzZXNzaW9uLmdldCgpO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibmF0aXZlX3Njcm9sbGVyXCI+XG4gICAgICB7cmVuZGVySGVhZGVyKHVzZXIpfVxuICAgICAgeyB1c2VyICYmIG1lbnUuaGVhZGVyT3BlbigpID8gcmVuZGVyUHJvZmlsZUFjdGlvbnModXNlcikgOiByZW5kZXJMaW5rcyh1c2VyKSB9XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCBwb3B1cFdpZGdldCBmcm9tICcuL3NoYXJlZC9wb3B1cCc7XG5pbXBvcnQgZm9ybVdpZGdldHMgZnJvbSAnLi9zaGFyZWQvZm9ybSc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi9zZXR0aW5ncyc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi9zZXNzaW9uJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uL2JhY2tidXR0b24nO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4uL3hocic7XG5pbXBvcnQgbG9iYnkgZnJvbSAnLi9sb2JieSc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclF1aWNrU2V0dXAoKSB7XG4gIHJldHVybiBoKCdkaXYubmV3R2FtZS1wb29scycsIHsga2V5OiAncXVpY2tTZXR1cCcgfSxcbiAgICAgICAgICAgeGhyLmNhY2hlZFBvb2xzLm1hcChwID0+IHJlbmRlclBvb2wocCkpXG4gICAgICAgICAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUG9vbChwKSB7XG4gIHJldHVybiBoKCdkaXYubmV3R2FtZS1wb29sJywge1xuICAgIGtleTogJ3Bvb2wtJyArIHAuaWQsXG4gICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcCgoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnb25jcmVhdGUnKTtcbiAgICB9KVxuICB9LCBbaCgnZGl2Lm5ld0dhbWUtcm91bmRzJywgcC5pZCksXG4gICAgICBoKCdkaXYubmV3R2FtZS1wZXJmJywgcC5wZXJmKVxuICAgICBdKTtcbn1cblxuY29uc3QgbmV3R2FtZUZvcm0gPSB7fTtcblxubmV3R2FtZUZvcm0uaXNPcGVuID0gZmFsc2U7XG5cbm5ld0dhbWVGb3JtLm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgYmFja2J1dHRvbi5zdGFjay5wdXNoKG5ld0dhbWVGb3JtLmNsb3NlKTtcbiAgbmV3R2FtZUZvcm0uaXNPcGVuID0gdHJ1ZTtcbn07XG5cbm5ld0dhbWVGb3JtLmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBuZXdHYW1lRm9ybS5pc09wZW4pIGJhY2tidXR0b24uc3RhY2sucG9wKCk7XG4gIG5ld0dhbWVGb3JtLmlzT3BlbiA9IGZhbHNlO1xufTtcblxubmV3R2FtZUZvcm0ub3BlblJlYWx0aW1lID0gZnVuY3Rpb24oKSB7XG4gIG5ld0dhbWVGb3JtLm9wZW4oKTtcbn07XG5cbmZ1bmN0aW9uIHNlZWtIdW1hbkdhbWUoKSB7XG4gIG5ld0dhbWVGb3JtLmNsb3NlKCk7XG4gIGxvYmJ5LnN0YXJ0U2Vla2luZygpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJGb3JtKGZvcm1OYW1lLCBhY3Rpb24sIHNldHRpbmdzT2JqLCB2YXJpYW50cykge1xuICB2YXIgZ2VuZXJhbEZpZWxkc2V0ID0gW1xuICAgIG0oJ2Rpdi5zZWxlY3RfaW5wdXQnLCB7XG4gICAgICBrZXk6IGZvcm1OYW1lICsgJ3ZhcmlhbnQnXG4gICAgfSwgW1xuICAgICAgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCd2YXJpYW50JywgZm9ybU5hbWUgKyAnIHZhcmlhbnQnLCB2YXJpYW50cywgc2V0dGluZ3NPYmoudmFyaWFudClcbiAgICBdKVxuICBdO1xuICBcblxuICAvLyBIdW1hbiBvbmx5XG4gIGlmIChzZXR0aW5nc09iai5tb2RlKSB7XG4gICAgdmFyIG1vZGVzID0gKHNlc3Npb24uaXNDb25uZWN0ZWQoKSkgPyBbXG4gICAgICBbJ2Nhc3VhbCcsICcwJ10sXG4gICAgICBbJ3JhdGVkJywgJzEnXVxuICAgIF0gOiBbIFsnY2FzdWFsJywgJzAnXSBdO1xuXG4gICAgZ2VuZXJhbEZpZWxkc2V0LnB1c2gobSgnZGl2LnNlbGVjdF9pbnB1dCcsIHtcbiAgICAgIGtleTogZm9ybU5hbWUgKyAnbW9kZSdcbiAgICB9LCBbXG4gICAgICBmb3JtV2lkZ2V0cy5yZW5kZXJTZWxlY3QoJ21vZGUnLCBmb3JtTmFtZSArICdtb2RlJywgbW9kZXMsIHNldHRpbmdzT2JqLm1vZGUpXG4gICAgXSkpO1xuXG4gICAgaWYgKHNlc3Npb24uaXNDb25uZWN0ZWQoKSAmJiBzZXR0aW5nc09iai5tb2RlKCkgPT09ICcwJykge1xuICAgICAgZ2VuZXJhbEZpZWxkc2V0LnB1c2goXG4gICAgICAgIGZvcm1XaWRnZXRzLnJlbmRlckNoZWNrYm94KGkxOG4oJ21lbWJlcnNPbmx5JyksICdtZW1iZXJzT25seScsIHNldHRpbmdzT2JqLm1lbWJlcnNPbmx5KSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYm90aCBodW1hblxuICB2YXIgcm91bmRGaWVsZHNldCA9IFtcbiAgICAvLyBtKCdkaXYuc2VsZWN0X2lucHV0Jywge1xuICAgIC8vICAga2V5OiBmb3JtTmFtZSArICdyb3VuZHMnXG4gICAgLy8gfSwgW1xuICAgIC8vICAgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCdyb3VuZCcsIGZvcm1OYW1lICsgJ3JvdW5kcycsIHJvdW5kTW9kZXMsIHNldHRpbmdzT2JqLnJvdW5kTW9kZSlcbiAgICAvLyBdKVxuICBdO1xuXG4gIGlmICh0cnVlKSB7XG4gICAgcm91bmRGaWVsZHNldC5wdXNoKFxuICAgICAgbSgnZGl2LnNlbGVjdF9pbnB1dCcsIHtcbiAgICAgICAga2V5OiBmb3JtTmFtZSArICdyb3VuZHMnXG4gICAgICB9LCBbXG4gICAgICAgIGZvcm1XaWRnZXRzLnJlbmRlclNlbGVjdCgncm91bmRzJywgZm9ybU5hbWUgKyAncm91bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2FtZVNldHVwLmF2YWlsYWJsZVJvdW5kcywgc2V0dGluZ3NPYmoucm91bmRzLCBmYWxzZSlcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBtKCdmb3JtI25ld19nYW1lX2Zvcm0uZ2FtZV9mb3JtJywge1xuICAgIG9uc3VibWl0OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIXNldHRpbmdzLmdhbWVTZXR1cC5pc1JvdW5kVmFsaWQoc2V0dGluZ3NPYmopKSByZXR1cm47XG4gICAgICBuZXdHYW1lRm9ybS5jbG9zZSgpO1xuICAgICAgYWN0aW9uKCk7XG4gICAgfVxuICB9LCBbXG4gICAgbSgnZmllbGRzZXQnLCBbXG4gICAgXSksXG4gICAgbSgnZmllbGRzZXQnLCBnZW5lcmFsRmllbGRzZXQpLFxuICAgIG0oJ2ZpZWxkc2V0I3JvdW5kJywgcm91bmRGaWVsZHNldCksXG4gICAgbSgnYnV0dG9uW2RhdGEtaWNvbj1FXVt0eXBlPXN1Ym1pdF0ubmV3R2FtZUJ1dHRvbicsIGkxOG4oJ2NyZWF0ZUFHYW1lJykpXG4gIF0pO1xufVxuXG5uZXdHYW1lRm9ybS52aWV3ID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGZvcm0oKSB7XG4gICAgcmV0dXJuIHJlbmRlckZvcm0oXG4gICAgICAnaHVtYW4nLFxuICAgICAgc2Vla0h1bWFuR2FtZSxcbiAgICAgIHNldHRpbmdzLmdhbWVTZXR1cC5odW1hbixcbiAgICAgIHNldHRpbmdzLmdhbWVTZXR1cC5odW1hbi5hdmFpbGFibGVWYXJpYW50cyk7XG59O1xuXG4gIHJldHVybiBwb3B1cFdpZGdldChcbiAgICAnbmV3X2dhbWVfZm9ybV9wb3B1cCBnYW1lX2Zvcm1fcG9wdXAnLFxuICAgIG51bGwsXG4gICAgZm9ybSxcbiAgICBuZXdHYW1lRm9ybS5pc09wZW4sXG4gICAgbmV3R2FtZUZvcm0uY2xvc2VcbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5ld0dhbWVGb3JtO1xuIiwiaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSAnLi9wbGF5ZXJzQ3RybCc7XG5pbXBvcnQgdmlldyBmcm9tICcuL3BsYXllcnNWaWV3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb250cm9sbGVyLFxuICB2aWV3XG59O1xuIiwiaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJy4uLy4uL2h0dHAnO1xuXG5leHBvcnQgZnVuY3Rpb24gb25saW5lUGxheWVycygpIHtcbiAgcmV0dXJuIHJlcXVlc3QoJy9wbGF5ZXIvb25saW5lJywge30sIHRydWUpO1xufVxuIiwiaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi9zb2NrZXQnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4vcGxheWVyWGhyJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250cm9sbGVyKCkge1xuICBzb2NrZXQuY3JlYXRlRGVmYXVsdCgpO1xuXG4gIGNvbnN0IHBsYXllcnMgPSBtLnByb3AoW10pO1xuXG4gIHhoci5vbmxpbmVQbGF5ZXJzKCkudGhlbihwbGF5ZXJzLCBlcnIgPT4gdXRpbHMuaGFuZGxlWGhyRXJyb3IoZXJyKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwbGF5ZXJzLFxuICAgIGdvVG9Qcm9maWxlKHUpIHtcbiAgICAgIG0ucm91dGUoJy9ALycgKyB1KTtcbiAgICB9LFxuICAgIG9udW5sb2FkOiAoKSA9PiB7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbScuLi8uLi91dGlscyc7XG5pbXBvcnQgaCBmcm9tICcuLi9oZWxwZXInXG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgeyBtZW51QnV0dG9uLCB1c2VyU3RhdHVzIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZpZXcoY3RybCkge1xuXG4gIGNvbnN0IGhlYWRlckN0cmwgPSBoZWFkZXIuYmluZChudWxsLCBjdHJsKTtcbiAgY29uc3QgYm9keUN0cmwgPSBib2R5LmJpbmQobnVsbCwgY3RybCk7XG5cbiAgcmV0dXJuIGxheW91dC5mcmVlKGhlYWRlckN0cmwsIGJvZHlDdHJsLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gaGVhZGVyKGN0cmwpIHtcbiAgcmV0dXJuIChcbiAgICA8bmF2PlxuICAgICAge21lbnVCdXR0b24oKX1cbiAgICAgIDxoMT57aTE4bigncGxheWVycycpfTwvaDE+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbnNcIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJtYWluX2hlYWRlcl9idXR0b25cIiBrZXk9XCJzZWFyY2hQbGF5ZXJzXCIgZGF0YS1pY29uPVwieVwiLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvbmF2PlxuICApO1xufVxuXG5mdW5jdGlvbiBib2R5KGN0cmwpIHtcbiAgcmV0dXJuIChcbiAgICA8dWwgY2xhc3NOYW1lPVwicGxheWVyc1N1Z2dlc3Rpb24gbmF0aXZlX3Njcm9sbGVyX3BhZ2VcIj5cbiAgICAgIHtjdHJsLnBsYXllcnMoKS5tYXAocmVuZGVyUGxheWVyKX1cbiAgICA8L3VsPlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQbGF5ZXIodXNlcikge1xuICAvLyBmaW5kIGJlc3QgcGVyZlxuICBjb25zdCBwZXJmID0gT2JqZWN0LmtleXModXNlci5wZXJmcykucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XG4gICAgaWYgKCFwcmV2KSByZXR1cm4gY3VycjtcbiAgICBpZiAodXNlci5wZXJmc1twcmV2XS5yYXRpbmcgPCB1c2VyLnBlcmZzW2N1cnJdLnJhdGluZylcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBwcmV2O1xuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxsaSBjbGFzc05hbWU9XCJsaXN0X2l0ZW0gcGxheWVyU3VnZ2VzdGlvbiBuYXZcIiBjb25maWc9e2gub250b3VjaFkoKCkgPT4gbS5yb3V0ZSgnL0AvJyArIHVzZXIuaWQpKX0+XG4gICAgICB7dXNlclN0YXR1cyh1c2VyKX1cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInJhdGluZ1wiIGRhdGEtaWNvbj17dXRpbHMuZ2FtZUljb24ocGVyZil9PlxuICAgICAgICB7dXNlci5wZXJmc1twZXJmXS5yYXRpbmd9XG4gICAgICA8L3NwYW4+XG4gICAgPC9saT5cbiAgKTtcbn1cbiIsImltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IHN0b3JhZ2UgZnJvbSAnLi4vLi4vc3RvcmFnZSc7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi8uLi9iYWNrYnV0dG9uJztcbmltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uL295dW5rZXlmL2dhbWUnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29udHJvbGxlcjogZnVuY3Rpb24ocm9vdCkge1xuICAgIGNvbnN0IHN0b3JhZ2VJZCA9ICdjaGF0LicgKyByb290LmRhdGEuZ2FtZS5pZDtcblxuICAgIGxldCBjaGF0SGVpZ2h0O1xuXG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLnNob3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLm1lc3NhZ2VzID0gcm9vdC5kYXRhLmNoYXQgfHwgW107XG4gICAgdGhpcy5pbnB1dFZhbHVlID0gJyc7XG4gICAgdGhpcy51bnJlYWQgPSBmYWxzZTtcblxuICAgIHZhciBjaGVja1VucmVhZEZyb21TdG9yYWdlID0gKCkgPT4ge1xuICAgICAgdmFyIG5iTWVzc2FnZXMgPSBzdG9yYWdlLmdldChzdG9yYWdlSWQpO1xuICAgICAgaWYgKHRoaXMubWVzc2FnZXMgJiYgbmJNZXNzYWdlcyA8IHRoaXMubWVzc2FnZXMubGVuZ3RoKVxuICAgICAgICB0aGlzLnVucmVhZCA9IHRydWU7XG4gICAgfTtcbiAgICBjaGVja1VucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgc3RvcmFnZS5zZXQoc3RvcmFnZUlkLCB0aGlzLm1lc3NhZ2VzLmxlbmd0aCk7XG5cbiAgICB0aGlzLm9wZW4gPSAoKSA9PiB7XG4gICAgICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24odGhpcy5jbG9zZSwgJ2NoYXQnKSk7XG4gICAgICB0aGlzLnNob3dpbmcgPSB0cnVlO1xuICAgIH07XG5cbiAgICB0aGlzLmNsb3NlID0gKGZyb21CQikgPT4ge1xuICAgICAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5jbG9zZSgpO1xuICAgICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIHRoaXMuc2hvd2luZykgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgICAgIHRoaXMuc2hvd2luZyA9IGZhbHNlO1xuICAgICAgdGhpcy51bnJlYWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5vblJlbG9hZCA9IChtZXNzYWdlcykgPT4ge1xuICAgICAgaWYgKCFtZXNzYWdlcykgeyByZXR1cm47IH1cbiAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgIGNoZWNrVW5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgIHN0b3JhZ2Uuc2V0KHN0b3JhZ2VJZCwgdGhpcy5tZXNzYWdlcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICB0aGlzLmFwcGVuZCA9IChtc2cpID0+IHtcbiAgICAgIHRoaXMubWVzc2FnZXMucHVzaChtc2cpO1xuICAgICAgc3RvcmFnZS5zZXQoc3RvcmFnZUlkLCB0aGlzLm1lc3NhZ2VzLmxlbmd0aCk7XG4gICAgICBpZiAobXNnLnUgIT09ICdveXVua2V5ZicpIHRoaXMudW5yZWFkID0gdHJ1ZTtcbiAgICAgIG0ucmVkcmF3KCk7XG4gICAgfTtcblxuICAgIC8vIGZ1bmN0aW9uIG9uS2V5Ym9hcmRTaG93KGUpIHtcbiAgICAvLyB9XG5cbiAgICAvLyBmdW5jdGlvbiBvbktleWJvYXJkSGlkZShlKSB7XG4gICAgLy8gfVxuXG4gICAgLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZGhpZGUnLCBvbktleWJvYXJkSGlkZSk7XG4gICAgLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZHNob3cnLCBvbktleWJvYXJkU2hvdyk7XG5cbiAgICB0aGlzLm9udW5sb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKGdhbWVBcGkucGxheWFibGUodGhpcy5yb290LmRhdGEpKSBzdG9yYWdlLnJlbW92ZShzdG9yYWdlSWQpO1xuICAgICAgLy8gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkaGlkZScsIG9uS2V5Ym9hcmRIaWRlKTtcbiAgICAgIC8vIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZHNob3cnLCBvbktleWJvYXJkU2hvdyk7XG4gICAgfTtcbiAgfSxcbiAgdmlldzogZnVuY3Rpb24oY3RybCkge1xuICAgIGlmICghY3RybC5zaG93aW5nKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gbSgnZGl2I2NoYXQubW9kYWwnLCB7IGNvbmZpZzogaGVscGVyLnNsaWRlc0luVXAgfSwgW1xuICAgICAgbSgnaGVhZGVyJywgW1xuICAgICAgICBtKCdidXR0b24ubW9kYWxfY2xvc2VbZGF0YS1pY29uPUxdJywge1xuICAgICAgICAgIGNvbmZpZzogaGVscGVyLm9udG91Y2goaGVscGVyLnNsaWRlc091dERvd24oY3RybC5jbG9zZSwgJ2NoYXQnKSlcbiAgICAgICAgfSksXG4gICAgICAgIG0oJ2gyJywgaTE4bignY2hhdCcpKVxuICAgICAgXSksXG4gICAgICBtKCdkaXYubW9kYWxfY29udGVudCcsIFtcbiAgICAgICAgbSgnZGl2I2NoYXRfc2Nyb2xsZXIubmF0aXZlX3Njcm9sbGVyJywge1xuICAgICAgICAgIGNvbmZpZzogZWwgPT4ge1xuICAgICAgICAgICAgZWwuc2Nyb2xsVG9wID0gZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgIG0oJ3VsLmNoYXRfbWVzc2FnZXMnLCBjdHJsLm1lc3NhZ2VzLm1hcChmdW5jdGlvbihtc2csIGksIGFsbCkge1xuICAgICAgICAgICAgdmFyIHBsYXllciA9IGN0cmwucm9vdC5kYXRhLnBsYXllcjtcblxuICAgICAgICAgICAgdmFyIG95dW5rZXlmVGFsa2luZyA9IG1zZy51ID09PSAnb3l1bmtleWYnO1xuICAgICAgICAgICAgdmFyIHBsYXllclRhbGtpbmcgPSBtc2cucyA/IG1zZy5zID09PSBwbGF5ZXIuc2lkZSA6XG4gICAgICAgICAgICAgICAgcGxheWVyLnVzZXIgJiYgbXNnLnUgPT09IHBsYXllci51c2VyLnVzZXJuYW1lO1xuICAgICAgICAgICAgdmFyIGNsb3NlQmFsbG9vbiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGFsbFtpICsgMV07XG4gICAgICAgICAgICB2YXIgbmV4dFRhbGtpbmc7XG5cbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgIG5leHRUYWxraW5nID0gbmV4dC5zID8gbmV4dC5zID09PSBwbGF5ZXIuc2lkZSA6XG4gICAgICAgICAgICAgICAgcGxheWVyLnVzZXIgJiYgbmV4dC51ID09PSBwbGF5ZXIudXNlci51c2VybmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghIW5leHRUYWxraW5nKSBjbG9zZUJhbGxvb24gPSBuZXh0VGFsa2luZyAhPT0gcGxheWVyVGFsa2luZztcblxuICAgICAgICAgICAgcmV0dXJuIG0oJ2xpLmNoYXRfbXNnLmFsbG93X3NlbGVjdCcsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBoZWxwZXIuY2xhc3NTZXQoe1xuICAgICAgICAgICAgICAgIHN5c3RlbTogb3l1bmtleWZUYWxraW5nLFxuICAgICAgICAgICAgICAgIHBsYXllcjogcGxheWVyVGFsa2luZyxcbiAgICAgICAgICAgICAgICBvcHBvbmVudDogIW95dW5rZXlmVGFsa2luZyAmJiAhcGxheWVyVGFsa2luZyxcbiAgICAgICAgICAgICAgICAnY2xvc2VfYmFsbG9vbic6IGNsb3NlQmFsbG9vblxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICBtLnRydXN0KG1zZy50KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSkpXG4gICAgICAgIF0pLFxuICAgICAgICBtKCdmb3JtLmNoYXRfZm9ybScsIHtcbiAgICAgICAgICBvbnN1Ym1pdDogZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBlLnRhcmdldFswXS52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIW1zZykgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG1zZy5sZW5ndGggPiAxNDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3RybC5pbnB1dFZhbHVlID0gJyc7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZCgndGFsaycsIG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgbSgnaW5wdXQjY2hhdF9pbnB1dC5jaGF0X2lucHV0W3R5cGU9dGV4dF0nLCB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bigndGFsa0luQ2hhdCcpLFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgICAgIHZhbHVlOiBjdHJsLmlucHV0VmFsdWUsXG4gICAgICAgICAgICBjb25maWc6IGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBpbnB1dExpc3RlbmVyLmJpbmQobnVsbCwgY3RybCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbSgnYnV0dG9uLmNoYXRfc2VuZFtkYXRhLWljb249el0nKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5wdXRMaXN0ZW5lcihjdHJsLCBlKSB7XG4gIGN0cmwuaW5wdXRWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xufVxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGN0cmwoZGF0YSwgb3V0T2ZUaW1lLCBzb3VuZFNpZGUsIHJlZHJhd0JvYXJkKSB7XG4gIHZhciBsYXN0VXBkYXRlID0ge307XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5kYXRhLmJhclRpbWUgPSBNYXRoLm1heCh0aGlzLmRhdGEuaW5pdGlhbCwgMik7XG5cbiAgZnVuY3Rpb24gc2V0TGFzdFVwZGF0ZSgpIHtcbiAgICBsYXN0VXBkYXRlID0ge1xuICAgICAgZWFzdDogZGF0YS5zaWRlc1snZWFzdCddLFxuICAgICAgd2VzdDogZGF0YS5zaWRlc1snd2VzdCddLFxuICAgICAgbm9ydGg6IGRhdGEuc2lkZXNbJ25vcnRoJ10sXG4gICAgICBzb3V0aDogZGF0YS5zaWRlc1snc291dGgnXSxcbiAgICAgIGF0OiBuZXcgRGF0ZSgpXG4gICAgfTtcbiAgfVxuICBzZXRMYXN0VXBkYXRlKCk7XG5cbiAgdGhpcy51cGRhdGUgPSAoc2lkZXMpID0+IHtcbiAgICB0aGlzLmRhdGEuc2lkZXMgPSBzaWRlcztcbiAgICBzZXRMYXN0VXBkYXRlKCk7XG4gIH07XG5cbiAgdGhpcy50aWNrID0gKHNpZGUpID0+IHtcbiAgICB0aGlzLmRhdGEuc2lkZXNbc2lkZV0gPVxuICAgICAgTWF0aC5tYXgoMCwgbGFzdFVwZGF0ZVtzaWRlXSAtIChuZXcgRGF0ZSgpIC0gbGFzdFVwZGF0ZS5hdCkgLyAxMDAwKTtcbiAgICBpZiAodGhpcy5kYXRhLnNpZGVzW3NpZGVdID09PSAwKSBvdXRPZlRpbWUoKTtcbiAgICByZWRyYXdCb2FyZCgpO1xuICB9O1xufVxuIiwiaW1wb3J0IGhlbHBlciBmcm9tICcuLi8uLi9oZWxwZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gdmlldyhjdHJsLCBzaWRlLCBydW5uaW5nU2lkZSwgcG9zaXRpb24pIHtcbiAgY29uc3QgdGltZSA9IGN0cmwuZGF0YS5zaWRlc1tzaWRlXTtcbiAgY29uc3QgaXNSdW5uaW5nID0gcnVubmluZ1NpZGUgPT09IHNpZGU7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGBjbG9jayBjbG9ja18ke3NpZGV9IGNsb2NrXyR7cG9zaXRpb259IGAgK1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIuY2xhc3NTZXQoe1xuICAgICAgICAgICAgICAgICAgICAgIG91dG9mdGltZTogIXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcnVubmluZzogaXNSdW5uaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIGVtZXJnOiB0aW1lIDwgY3RybC5kYXRhLmVtZXJnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICB7c2hvd0JhcihjdHJsLCB0aW1lKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gc2hvd0JhcihjdHJsLCB0aW1lKSB7XG4gIGNvbnN0IGJhclN0eWxlID0ge1xuICAgIHdpZHRoOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsICh0aW1lIC8gY3RybC5kYXRhLmJhclRpbWUpICogMTAwKSkgKyAnJSdcbiAgfTtcbiAgcmV0dXJuICg8ZGl2IGNsYXNzTmFtZT0nYmFyJz5cbiAgICAgIDxzcGFuIHN0eWxlPXtiYXJTdHlsZX0+XG4gICAgICA8L3NwYW4+XG4gIDwvZGl2Pik7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkYXRhKSB7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiaW1wb3J0IG9rZXlncm91bmQgZnJvbSAnb2tleWdyb3VuZC1tb2JpbGUnO1xuaW1wb3J0IGdhbWVBcGkgZnJvbSAnLi4vLi4vb3l1bmtleWYvZ2FtZSc7XG5cbmZ1bmN0aW9uIG1ha2VDb25maWcoZGF0YSwgZmVuKSB7XG4gIHJldHVybiB7XG4gICAgZmVuOiBmZW4sXG4gICAgdHVyblNpZGU6IGRhdGEuZ2FtZS5wbGF5ZXIsXG4gICAgcG92U2lkZTogZGF0YS5wbGF5ZXIuc2lkZSxcbiAgICBzcGVjdGF0b3I6IGRhdGEucGxheWVyLnNwZWN0YXRvcixcbiAgICB3aXRoVG9yZTogISFkYXRhLmdhbWUudmFyaWFudC5rZXkubWF0Y2goL2R1em9rZXkvKSxcbiAgICBtb3ZhYmxlOiB7XG4gICAgICBmcmVlOiBmYWxzZSxcbiAgICAgIGJvYXJkOiBnYW1lQXBpLmlzUGxheWVyUGxheWluZyhkYXRhKSxcbiAgICAgIGRlc3RzOiBnYW1lQXBpLmlzUGxheWVyUGxheWluZyhkYXRhKSA/IGRhdGEucG9zc2libGVNb3ZlcyA6IFtdXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlKGRhdGEsIGZlbiwgdXNlck1vdmUsIG9uTW92ZSkge1xuICB2YXIgY29uZmlnID0gbWFrZUNvbmZpZyhkYXRhLCBmZW4pO1xuICBjb25maWcubW92YWJsZS5ldmVudHMgPSB7XG4gICAgYWZ0ZXI6IHVzZXJNb3ZlXG4gIH07XG4gIGNvbmZpZy5ldmVudHMgPSB7XG4gICAgbW92ZTogb25Nb3ZlXG4gIH07XG4gIHJldHVybiBuZXcgb2tleWdyb3VuZC5jb250cm9sbGVyKGNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGVuZChncm91bmQpIHtcbiAgZ3JvdW5kLnN0b3AoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBtYWtlLFxuICBlbmRcbn07XG4iLCJpbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IG9rZXlncm91bmQgZnJvbSAnb2tleWdyb3VuZC1tb2JpbGUnO1xuaW1wb3J0IG1ha2VEYXRhIGZyb20gJy4vZGF0YSc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBmb3JJbiBmcm9tICdsb2Rhc2gvZm9ySW4nO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi9zb2NrZXQnO1xuaW1wb3J0IHNvY2tldEhhbmRsZXIgZnJvbSAnLi9zb2NrZXRIYW5kbGVyJztcbmltcG9ydCBncm91bmQgZnJvbSAnLi9ncm91bmQnO1xuaW1wb3J0IGNsb2NrQ3RybCBmcm9tICcuL2Nsb2NrL2Nsb2NrQ3RybCc7XG5pbXBvcnQgbXV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBjaGF0IGZyb20gJy4vY2hhdCc7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi8uLi9iYWNrYnV0dG9uJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuL3JvdW5kWGhyJztcbmltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uL295dW5rZXlmL2dhbWUnO1xuaW1wb3J0IGdhbWVTdGF0dXMgZnJvbSAnLi4vLi4vb3l1bmtleWYvc3RhdHVzJztcbmltcG9ydCBaYW5pbW8gZnJvbSAnemFuaW1vJztcblxuY29uc3QgeyB1dGlsIH0gPSBva2V5Z3JvdW5kO1xuY29uc3QgeyB3cmFwR3JvdXAsIHdyYXBQaWVjZSwgd3JhcERyb3AsIHBhcnRpYWwgfSA9IHV0aWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNmZykge1xuICB0aGlzLmRhdGEgPSBtYWtlRGF0YShjZmcpO1xuXG4gIHRoaXMuZGF0YS5nYW1lLm9zY29yZXMgPSB7XG4gICAgZWFzdDoge1xuICAgICAgc2VyaWVzOiAxMDEsXG4gICAgICBuZXc6IHRydWVcbiAgICB9LFxuICAgIHdlc3Q6IHtcbiAgICAgIHBhaXJzOiA1XG4gICAgfSxcbiAgICBub3J0aDoge1xuICAgICAgcGFpcnM6IDVcbiAgICB9LFxuICAgIHNvdXRoOiB7XG4gICAgICBwYWlyczogNVxuICAgIH1cbiAgfTtcblxuICB0aGlzLmNoYXQgPSBuZXcgY2hhdC5jb250cm9sbGVyKHRoaXMpO1xuXG4gIHRoaXMudm0gPSB7XG4gICAgc2hvd2luZ0FjdGlvbnM6IGZhbHNlXG4gIH07XG5cbiAgdGhpcy5zZXRUaXRsZSA9ICh0ZXh0KSA9PiB7XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICBpZiAoZ2FtZVN0YXR1cy5zdGFydGVkKHRoaXMuZGF0YSkpIHtcbiAgICAgICAgdGV4dCA9IGdhbWVBcGkudGl0bGUodGhpcy5kYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2FtZVN0YXR1cy5maW5pc2hlZCh0aGlzLmRhdGEpKSB7XG4gICAgICAgIHRleHQgPSBpMThuKCdnYW1lT3ZlcicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0ID0gJ295dW5rZXlmLm5ldCc7XG4gICAgfVxuICAgIHRoaXMudGl0bGUgPSB0ZXh0O1xuICB9O1xuICB0aGlzLnNldFRpdGxlKCk7XG5cbiAgY29uc3QgY29ubmVjdFNvY2tldCA9ICgpID0+IHtcbiAgICBpZiAodXRpbHMuaGFzTmV0d29yaygpKSB7XG4gICAgICBzb2NrZXQuY3JlYXRlR2FtZShcbiAgICAgICAgdGhpcy5kYXRhLnVybC5zb2NrZXQsXG4gICAgICAgIHRoaXMuZGF0YS5wbGF5ZXIudmVyc2lvbixcbiAgICAgICAgc29ja2V0SGFuZGxlcih0aGlzKSxcbiAgICAgICAgdGhpcy5kYXRhLnVybC5yb3VuZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgY29ubmVjdFNvY2tldCgpO1xuXG4gIHRoaXMudG9nZ2xlVXNlclBvcHVwID0gKHBvc2l0aW9uLCB1c2VySWQpID0+IHtcbiAgICBjb25zb2xlLmxvZygndXNlcicsIHVzZXJJZCk7XG4gIH07XG5cblxuICB0aGlzLnNob3dBY3Rpb25zID0gKCkgPT4ge1xuICAgIGJhY2tidXR0b24uc3RhY2sucHVzaCh0aGlzLmhpZGVBY3Rpb25zKTtcbiAgICB0aGlzLnZtLnNob3dpbmdBY3Rpb25zID0gdHJ1ZTtcbiAgfTtcblxuICB0aGlzLmhpZGVBY3Rpb25zID0gKGZyb21CQikgPT4ge1xuICAgIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiB0aGlzLnZtLnNob3dpbmdBY3Rpb25zKSBiYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICAgIHRoaXMudm0uc2hvd2luZ0FjdGlvbnMgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgdXNlck1vdmUgPSAoa2V5LCBtb3ZlKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gb2tleWdyb3VuZC5tb3ZlLmxlYXZlVGFrZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZW5kTW92ZShrZXksIG1vdmUpO1xuICB9O1xuXG4gIHZhciBvbk1vdmUgPSAoa2V5LCBwaWVjZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdzb3VuZC5tb3ZlJywga2V5LCBwaWVjZSk7XG4gICAgaWYgKGtleSA9PT0gb2tleWdyb3VuZC5tb3ZlLmRyYXdNaWRkbGUpIHtcbiAgICAgIHRoaXMuc2VuZE1vdmUoa2V5KTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gb2tleWdyb3VuZC5tb3ZlLmRpc2NhcmQpIHtcbiAgICAgIHRoaXMudm0uaGFzUGxheWVkRGlzY2FyZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc2VuZE1vdmUgPSAoa2V5LCBhcmdzID0ge30pID0+IHtcbiAgICB2YXIgbW92ZSA9IGFyZ3M7XG4gICAgYXJncy5rZXkgPSBrZXk7XG4gICAgc29ja2V0LnNlbmQoJ21vdmUnLCBtb3ZlLCB7XG4gICAgICBhY2thYmxlOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5hcGlNb3ZlID0gKG8pID0+IHtcbiAgICBjb25zdCBkID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHBsYXlpbmcgPSBnYW1lQXBpLmlzUGxheWVyUGxheWluZyhkKTtcblxuICAgIGQuZ2FtZS50dXJucyA9IG8ucGx5O1xuICAgIGQuZ2FtZS5wbGF5ZXIgPSBnYW1lQXBpLnNpZGVCeVBseShvLnBseSk7XG4gICAgZC5nYW1lLm9zY29yZXMgPSBvLm9zY29yZXM7XG4gICAgZC5wb3NzaWJsZU1vdmVzID0gZC5wbGF5ZXIuc2lkZSA9PT0gZC5nYW1lLnBsYXllciA/IG8uZGVzdHMgOiBbXTtcbiAgICB0aGlzLnNldFRpdGxlKCk7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIGlmIChvLmlzTW92ZSkge1xuICAgICAgICBpZiAoby5kcmF3bWlkZGxlKSB7XG4gICAgICAgICAgdGhpcy5va2V5Z3JvdW5kLmFwaU1vdmUoby5rZXksIHdyYXBQaWVjZShvLmRyYXdtaWRkbGUucGllY2UpKTtcbiAgICAgICAgfSBlbHNlIGlmIChvLmRpc2NhcmQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMudm0uaGFzUGxheWVkRGlzY2FyZCkge1xuICAgICAgICAgICAgdGhpcy5va2V5Z3JvdW5kLmFwaU1vdmUoby5rZXksIHdyYXBQaWVjZShvLmRpc2NhcmQucGllY2UpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZtLmhhc1BsYXllZERpc2NhcmQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChvLm9wZW5zKSB7XG4gICAgICAgICAgdGhpcy5va2V5Z3JvdW5kLmFwaU1vdmUoby5rZXksIHdyYXBHcm91cChvLm9wZW5zLmdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoby5kcm9wKSB7XG4gICAgICAgICAgdGhpcy5va2V5Z3JvdW5kLmFwaU1vdmUoby5rZXksIHdyYXBEcm9wKG8uZHJvcC5waWVjZSwgby5kcm9wLnBvcykpO1xuICAgICAgICB9IGVsc2UgaWYgKG8ua2V5ID09PSBva2V5Z3JvdW5kLm1vdmUuY29sbGVjdE9wZW4pIHtcbiAgICAgICAgICB0aGlzLnJlc3RvcmVGZW4oby5mZW4sIG9rZXlncm91bmQubW92ZS5jb2xsZWN0T3Blbik7XG4gICAgICAgIH0gZWxzZSBpZiAoby5rZXkgPT09IG9rZXlncm91bmQubW92ZS5sZWF2ZVRha2VuKSB7XG4gICAgICAgICAgLy8gdGhpcy5yZXN0b3JlRmVuKG8uZmVuKTtcbiAgICAgICAgICB0aGlzLm9rZXlncm91bmQuYXBpTW92ZShvLmtleSwgd3JhcFBpZWNlKG8ubGVhdmV0YWtlbi5waWVjZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub2tleWdyb3VuZC5hcGlNb3ZlKG8ua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm9rZXlncm91bmQuc2V0KHtcbiAgICAgICAgdHVyblNpZGU6IGQuZ2FtZS5wbGF5ZXIsXG4gICAgICAgIG1vdmFibGU6IHtcbiAgICAgICAgICBkZXN0czogcGxheWluZyA/IGQucG9zc2libGVNb3ZlcyA6IFtdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvLmNsb2NrKSB7XG4gICAgICB2YXIgYyA9IG8uY2xvY2s7XG4gICAgICBpZiAodGhpcy5jbG9jaykgdGhpcy5jbG9jay51cGRhdGUoYyk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlR2FtZUFjdGlvbnMoKTtcbiAgfTtcblxuICB0aGlzLnJlc3RvcmVGZW4gPSAoZmVuLCBoaW50KSA9PiB7XG4gICAgdmFyIG9sZEJvYXJkID0gdGhpcy5va2V5Z3JvdW5kLmdldEZlbigpO1xuXG4gICAgLy8gbWFrZSBhIGhhY2sgZmVuIHRvIHNwbGl0XG4gICAgdmFyIG9sZEZlbiA9IFwiLy9cIiArIG9sZEJvYXJkICsgXCIvXCI7XG5cbiAgICB0aGlzLm9rZXlncm91bmQuc2V0KHtcbiAgICAgIGZlbjogbXV0aWwucGVyc2lzdGVudEZlbihmZW4sIG9sZEZlbiksXG4gICAgICBhbmltYXRpb25IaW50OiBoaW50XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5zYXZlQm9hcmQgPSAoKSA9PiB7XG4gICAgdmFyIGJvYXJkRmVuID0gdGhpcy5va2V5Z3JvdW5kLmdldEZlbigpO1xuICAgIG11dGlsLmZlblN0b3JlLnNldChib2FyZEZlbik7XG4gIH07XG5cbiAgdGhpcy5va2V5Z3JvdW5kID0gZ3JvdW5kLm1ha2UodGhpcy5kYXRhLCBjZmcuZ2FtZS5mZW4sIHVzZXJNb3ZlLCBvbk1vdmUpO1xuXG4gIHRoaXMucmVkcmF3Qm9hcmQgPSAoKSA9PiB7XG4gICAgbS5yZWRyYXcoKTtcbiAgICB0aGlzLm9rZXlncm91bmQuZGF0YS5yZW5kZXJSQUYoKTtcbiAgfTtcblxuICB0aGlzLmNsb2NrID0gdGhpcy5kYXRhLmNsb2NrID8gbmV3IGNsb2NrQ3RybChcbiAgICB0aGlzLmRhdGEuY2xvY2ssXG4gICAgdGhpcy5kYXRhLnBsYXllci5zcGVjdGF0b3IgPyB1dGlscy5ub29wIDpcbiAgICAgIHRocm90dGxlKCgpID0+IHNvY2tldC5zZW5kKCdvdXRvZnRpbWUnLCAxMDAwKSksXG4gICAgdGhpcy5kYXRhLnBsYXllci5zcGVjdGF0b3IgPyBudWxsIDogdGhpcy5kYXRhLnBsYXllci5zaWRlLFxuICAgIHRoaXMucmVkcmF3Qm9hcmRcbiAgKSA6IGZhbHNlO1xuXG4gIHRoaXMuaXNDbG9ja1J1bm5pbmcgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jbG9jayAmJiBnYW1lQXBpLnBsYXlhYmxlKHRoaXMuZGF0YSkgJiZcbiAgICAgICh0aGlzLmRhdGEuZ2FtZS50dXJucyA+IDAgfHwgdGhpcy5kYXRhLmNsb2NrLnJ1bm5pbmcpO1xuICB9O1xuXG4gIHRoaXMuY2xvY2tUaWNrID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlzQ2xvY2tSdW5uaW5nKCkpIHRoaXMuY2xvY2sudGljayh0aGlzLmRhdGEuZ2FtZS5wbGF5ZXIpO1xuICB9O1xuXG4gIHZhciBjbG9ja0ludGVydmFsSWQ7XG4gIGlmICh0aGlzLmNsb2NrKSBjbG9ja0ludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh0aGlzLmNsb2NrVGljaywgMTAwKTtcblxuICB0aGlzLm9wZW5TZXJpZXMgPSAoKSA9PiB7XG4gICAgdGhpcy5va2V5Z3JvdW5kLnBsYXlPcGVuU2VyaWVzKCk7XG4gIH07XG4gIHRoaXMub3BlblBhaXJzID0gKCkgPT4ge1xuICAgIHRoaXMub2tleWdyb3VuZC5wbGF5T3BlblBhaXJzKCk7XG4gIH07XG4gIHRoaXMuY29sbGVjdE9wZW4gPSAoKSA9PiB7XG4gICAgdGhpcy5zZW5kTW92ZShva2V5Z3JvdW5kLm1vdmUuY29sbGVjdE9wZW4pO1xuICB9O1xuICB0aGlzLmxlYXZlVGFrZW4gPSAoKSA9PiB7XG4gICAgdGhpcy5zZW5kTW92ZShva2V5Z3JvdW5kLm1vdmUubGVhdmVUYWtlbik7XG4gIH07XG5cbiAgdGhpcy5mb2xsb3dVcCA9ICgpID0+IHtcbiAgICBtLnJvdXRlKCcvbWFzYS8nICsgdGhpcy5kYXRhLm1hc2EuaWQpO1xuICB9O1xuXG4gIHRoaXMucmVtb3ZlR2FtZUFjdGlvbiA9IChpZCwgZikgPT4ge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIGlmICghZWwpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBaYW5pbW8oXG4gICAgICBlbCxcbiAgICAgIC8vICdvcGFjaXR5JywgMCwgMjUwLCAnZWFzZS1vdXQnXG4gICAgICAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsIC0xMDAlLCAwKScsIDI1MCwgJ2Vhc2Utb3V0J1xuICAgICkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnZtW2lkXSA9IGZhbHNlO1xuICAgICAgbS5yZWRyYXcoKTtcbiAgICB9KVxuICAgICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO1xuICB9O1xuXG4gIHRoaXMudXBkYXRlR2FtZUFjdGlvbnMgPSAoKSA9PiB7XG4gICAgZm9ySW4oe1xuICAgICAgJ29wZW5QYWlycyc6IHRoaXMub2tleWdyb3VuZC5jYW5PcGVuUGFpcnMoKSxcbiAgICAgICdvcGVuU2VyaWVzJzogdGhpcy5va2V5Z3JvdW5kLmNhbk9wZW5TZXJpZXMoKSxcbiAgICAgICdjb2xsZWN0T3Blbic6IHRoaXMub2tleWdyb3VuZC5jYW5Db2xsZWN0T3BlbigpLFxuICAgICAgJ2xlYXZlVGFrZW4nOiB0aGlzLm9rZXlncm91bmQuY2FuTGVhdmVUYWtlbigpXG4gICAgfSwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZtW2tleV0gPSB0cnVlO1xuICAgICAgfSBlbHNlIHRoaXMucmVtb3ZlR2FtZUFjdGlvbihrZXkpO1xuICAgIH0pO1xuICB9O1xuICB0aGlzLnVwZGF0ZUdhbWVBY3Rpb25zKCk7XG5cbiAgdGhpcy5yZWxvYWQgPSAockNmZykgPT4ge1xuICAgIHRoaXMuZGF0YSA9IG1ha2VEYXRhKHJDZmcpO1xuICAgIHRoaXMuc2V0VGl0bGUoKTtcblxuICAgIC8vIGdyb3VuZC5yZWxvYWQodGhpcy5va2V5Z3JvdW5kLCB0aGlzLmRhdGEsIHJDZmcuZ2FtZS5mZW4pO1xuICAgIG0ucmVkcmF3KCk7XG4gIH07XG5cbiAgY29uc3QgcmVsb2FkR2FtZURhdGEgPSAoKSA9PiB7XG4gICAgeGhyLnJlbG9hZCh0aGlzKS50aGVuKHRoaXMucmVsb2FkKTtcbiAgfTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXN1bWUnLCByZWxvYWRHYW1lRGF0YSk7XG4gIHdpbmRvdy5wbHVnaW5zLmluc29tbmlhLmtlZXBBd2FrZSgpO1xuXG4gIHRoaXMub251bmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgIGNsZWFySW50ZXJ2YWwoY2xvY2tJbnRlcnZhbElkKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXN1bWUnLCByZWxvYWRHYW1lRGF0YSk7XG4gICAgd2luZG93LnBsdWdpbnMuaW5zb21uaWEuYWxsb3dTbGVlcEFnYWluKCk7XG4gICAgaWYgKHRoaXMuY2hhdCkgdGhpcy5jaGF0Lm9udW5sb2FkKCk7XG4gICAgaWYgKHRoaXMub2tleWdyb3VuZCkge1xuICAgICAgdGhpcy5va2V5Z3JvdW5kLm9udW5sb2FkKCk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IHsgcmVxdWVzdCB9IGZyb20gJy4uLy4uL2h0dHAnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVsb2FkKGN0cmwpIHtcbiAgcmV0dXJuIHJlcXVlc3QoY3RybC5kYXRhLnVybC5yb3VuZCwgeyBiYWNrZ3JvdW5kOiB0cnVlIH0pO1xufVxuIiwiaW1wb3J0IGdhbWVBcGkgZnJvbSAnLi4vLi4vb3l1bmtleWYvZ2FtZSc7XG5pbXBvcnQgZ3JvdW5kIGZyb20gJy4vZ3JvdW5kJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuL3JvdW5kWGhyJztcbmltcG9ydCB7IGhhbmRsZVhockVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHNvY2tldCBmcm9tICcuLi8uLi9zb2NrZXQnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGN0cmwpIHtcbiAgcmV0dXJuIHtcbiAgICBtb3ZlOiBmdW5jdGlvbihvKSB7XG4gICAgICBvLmlzTW92ZSA9IHRydWU7XG4gICAgICBjdHJsLmFwaU1vdmUobyk7XG4gICAgICBtLnJlZHJhdyhmYWxzZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgeGhyLnJlbG9hZChjdHJsKS50aGVuKGN0cmwucmVsb2FkKTtcbiAgICB9LFxuICAgIHJlc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmxvZygncmVzeW5jJyk7XG4gICAgICB4aHIucmVsb2FkKGN0cmwpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzb2NrZXQuc2V0VmVyc2lvbihkYXRhLnBsYXllci52ZXJzaW9uKTtcbiAgICAgICAgY3RybC5yZWxvYWQoZGF0YSk7XG4gICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaGFuZGxlWGhyRXJyb3IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbihzY29yZXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKHNjb3Jlcyk7XG4gICAgICBjdHJsLmRhdGEuZ2FtZS5zY29yZXMgPSBzY29yZXMucmVzdWx0O1xuICAgICAgZ3JvdW5kLmVuZChjdHJsLm9rZXlncm91bmQpO1xuICAgICAgLy8gYWxsb3cgc2xlZXAgYWdhaW5cbiAgICAgIGN0cmwuc2F2ZUJvYXJkKCk7XG4gICAgICAvLyBjdHJsLnNldExvYWRpbmcodHJ1ZSk7XG4gICAgICB4aHIucmVsb2FkKGN0cmwpLnRoZW4oY3RybC5yZWxvYWQpO1xuICAgICAgd2luZG93LnBsdWdpbnMuaW5zb21uaWEuYWxsb3dTbGVlcEFnYWluKCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBjdHJsLnNob3dBY3Rpb25zKCk7XG4gICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICB9LCA1MDApO1xuICAgIH0sXG4gICAgbWVzc2FnZTogZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAoY3RybC5jaGF0KSBjdHJsLmNoYXQuYXBwZW5kKG1zZyk7XG4gICAgfSxcbiAgICBjcm93ZDogZnVuY3Rpb24obykge1xuICAgICAgWydlYXN0JywgJ3dlc3QnLCAnbm9ydGgnLCAnc291dGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHNpZGUpIHtcbiAgICAgICAgZ2FtZUFwaS5zZXRPbkdhbWUoY3RybC5kYXRhLCBzaWRlLCBvW3NpZGVdKTtcbiAgICAgIH0pO1xuICAgICAgbS5yZWRyYXcoZmFsc2UsIHRydWUpO1xuICAgICAgLy8gdG9wIGhvb2tzXG4gICAgICBjdHJsLm9rZXlncm91bmQuZGF0YS5yZW5kZXJSQUYoKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgc3RvcmFnZSBmcm9tICcuLi8uLi9zdG9yYWdlJztcblxuY29uc3Qgc2sgPSAncm91bmQuJyArICdib2FyZCc7XG5cbmZ1bmN0aW9uIGFzc2VydEVxdWFsKGExLCBhMikge1xuICByZXR1cm4gYTEuZXZlcnkoKGssIGkpID0+IGsgPT09IGEyW2ldKTtcbn1cblxuY29uc3QgZmVuUyA9IChmZW4pID0+IFwifFwiICsgZmVuICsgXCJ8XCI7XG5jb25zdCByZWdQaWVjZSA9IC9bZnxyfGx8YnxnXVxcZFxcZD8vZztcblxuZnVuY3Rpb24gYm9hcmREaWZmVGVzdCgpIHtcbiAgZnVuY3Rpb24gdGVzdChmZW4xLCBmZW4yKSB7XG4gICAgY29uc3QgZGlmZiA9IGJvYXJkRGlmZihmZW4xLCBmZW4yKTtcbiAgICBjb25zdCBkaWZmTGVuZ3RoID0gZGlmZi5tYXRjaChyZWdQaWVjZSkubGVuZ3RoICsgKGRpZmYubWF0Y2goL1xccy9nKSB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnNvbGUubG9nKFwidGVzdCBcXG5cIiwgZmVuUyhmZW4xKSwgXCJcXG5cIiwgZmVuUyhmZW4yKSk7XG4gICAgY29uc29sZS5sb2coZmVuUyhkaWZmKSwgZGlmZkxlbmd0aCk7XG4gIH1cbiAgY29uc3Qgc291cmNlID0gXCJnN2I4ZzEzcjEycjFyMWIzYjEwcjhyOWcxMmIxM2IxM2c0ZzVyMTBsNGc2YjEyZzExZzFnOFwiO1xuICB0ZXN0KHNvdXJjZSwgc291cmNlKTtcbiAgdGVzdChcImc3ZzhnMTNcIiwgc291cmNlKTtcbiAgdGVzdChcIiAgICAgICAgICAgICAgIGc3ZzhnMTNcIiwgc291cmNlKTtcbiAgdGVzdChcIiAgICAgICAgICAgICAgICAgICAgZzdnOGcxM1wiLCBzb3VyY2UpO1xuICB0ZXN0KFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIGc3ZzhnMTNcIiwgc291cmNlKTtcbiAgdGVzdChcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiNyBnOCBnMTMgcjFcIiwgc291cmNlKTtcbiAgdGVzdChcIiAgICAgICAgICAgICAgIGIxM2IxM2c0ZzVyMTBsNGc2YjEyZzExICAgYjcgZzggZzEzIHIxXCIsIHNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIGJvYXJkRGlmZihvbGRGZW4sIG5ld0Zlbikge1xuICBpZiAoIW9sZEZlbiB8fCAhbmV3RmVuIHx8IG5ld0ZlbiA9PT0gXCJcIikge1xuICAgIHJldHVybiBuZXdGZW47XG4gIH1cblxuICB2YXIgcGllY2VzID0gbmV3RmVuLm1hdGNoKHJlZ1BpZWNlKTtcbiAgdmFyIHVudXNlZEluZGV4ZXMgPSBwaWVjZXMubWFwKChrLCBpKSA9PiBpKTtcblxuICB2YXIgb2xkUGllY2VzID0gb2xkRmVuLm1hdGNoKC9bZnxyfGx8Z3xiXVxcZFxcZD98Li9nKTtcblxuICB2YXIgcGllY2VzTGVuZ3RoID0gcGllY2VzLmxlbmd0aDtcblxuICBwaWVjZXMuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgIHZhciBvbGRJID0gb2xkUGllY2VzLmluZGV4T2YocCk7XG4gICAgaWYgKG9sZEkgIT09IC0xKVxuICAgICAgb2xkUGllY2VzLnNwbGljZShvbGRJLCAxLCB7IGY6IHRydWUsIGk6IGkgfSk7XG4gIH0pO1xuXG4gIG9sZFBpZWNlcyA9IG9sZFBpZWNlcy5tYXAoa2V5ID0+IHtcbiAgICBpZiAoa2V5ICYmIGtleS5mKSB7XG4gICAgICB1bnVzZWRJbmRleGVzLnNwbGljZSh1bnVzZWRJbmRleGVzLmluZGV4T2Yoa2V5LmkpLCAxKTtcbiAgICAgIHJldHVybiBwaWVjZXNba2V5LmldO1xuICAgIH1cbiAgICByZXR1cm4gXCIgXCI7XG4gIH0pO1xuXG4gIG9sZFBpZWNlcyA9IG9sZFBpZWNlcy5qb2luKFwiXCIpO1xuXG4gIG9sZFBpZWNlcyA9IG9sZFBpZWNlcy5yZXBsYWNlKC9cXHMqJC8sIFwiICBcIik7XG5cbiAgLy8gdmFyIHJlc3QgPSB1bnVzZWRJbmRleGVzLm1hcChfID0+IHBpZWNlc1tfXSkuam9pbihcIlwiKTtcbiAgLy8gdmFyIHJlc3VsdCA9IG9sZFBpZWNlcyArIHJlc3Q7XG4gIC8vIHZhciBzcGFjZXMgPSBNYXRoLmNlaWwocmVzdWx0Lm1hdGNoKC9cXHMvZykubGVuZ3RoIC8gMik7XG4gIC8vIHNwYWNlcyArPSBwaWVjZXNMZW5ndGg7XG4gIC8vIHdoaWxlIChzcGFjZXMtLSA+IDM0KSB7XG4gIC8vICAgLy9yZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFxzLywgXCJcIik7XG4gIC8vICAgLy9yZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFxzKFteXFxzXSopJC8sIFwiJDFcIik7XG4gIC8vIH1cblxuICB2YXIgcmVzdCA9IHVudXNlZEluZGV4ZXMubWFwKF8gPT4gcGllY2VzW19dKTtcbiAgdmFyIHJlc3VsdCA9IG9sZFBpZWNlcyArIHJlc3Quc2xpY2UoMCkuZmlsbCgnICAnKS5qb2luKFwiXCIpO1xuXG4gIC8vIGluZGV4IDAgbm90IGFsbG93ZWQgcGllY2Ugc2hpZnQgaGFja1xuICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXlxccy8sIFwiXCIpO1xuXG4gIHJlc3QuZm9yRWFjaChwID0+IHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXHNcXHMvLCBwKSk7XG5cbiAgaWYgKCFhc3NlcnRFcXVhbChyZXN1bHQubWF0Y2gocmVnUGllY2UpLnNvcnQoKSwgbmV3RmVuLm1hdGNoKHJlZ1BpZWNlKS5zb3J0KCkpKSB7XG4gICAgY29uc29sZS53YXJuKFwiYm9hcmQgZGlmZiBmYWlsZWRcXG5cIiwgZmVuUyhyZXN1bHQpLCBcIlxcblwiLCBmZW5TKG9sZEZlbiksIFwiXFxuXCIsIGZlblMobmV3RmVuKSk7XG4gICAgcmVzdWx0ID0gbmV3RmVuO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYm9hcmREaWZmMihvbGRGZW4sIG5ld0Zlbikge1xuXG4gIGlmICghb2xkRmVuKSB7XG4gICAgcmV0dXJuIG5ld0ZlbjtcbiAgfVxuXG4gIHZhciBwaWVjZXMgPSBuZXdGZW4ubWF0Y2gocmVnUGllY2UpO1xuICB2YXIgdW51c2VkSW5kZXhlcyA9IHBpZWNlcy5tYXAoKGssIGkpID0+IGkpO1xuXG4gIHZhciBvbGRGZW5JbmRleGVkID0gb2xkRmVuO1xuXG4gIHZhciBwaWVjZXNMZW5ndGggPSBwaWVjZXMubGVuZ3RoO1xuXG4gIHBpZWNlcy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgdmFyIHJlZ1AgPSBuZXcgUmVnRXhwKHApO1xuICAgIG9sZEZlbkluZGV4ZWQgPSBvbGRGZW5JbmRleGVkLnJlcGxhY2UocmVnUCwgXCIke1wiICsgaSArIFwifVwiKTtcbiAgfSk7XG5cbiAgb2xkRmVuSW5kZXhlZCA9IG9sZEZlbkluZGV4ZWQucmVwbGFjZShyZWdQaWVjZSwgXCJcIik7XG5cbiAgb2xkRmVuSW5kZXhlZC5tYXRjaCgvXFwke1xcZFxcZD99L2cpLmZvckVhY2goa2V5ID0+IHtcbiAgICB2YXIgaSA9IHBhcnNlSW50KGtleS5tYXRjaCgvXFxkXFxkPy8pKTtcbiAgICB1bnVzZWRJbmRleGVzLnNwbGljZSh1bnVzZWRJbmRleGVzLmluZGV4T2YoaSksIDEpO1xuICAgIG9sZEZlbkluZGV4ZWQgPSBvbGRGZW5JbmRleGVkLnJlcGxhY2Uoa2V5LCBwaWVjZXNbaV0pO1xuICB9KTtcblxuICBvbGRGZW5JbmRleGVkID0gb2xkRmVuSW5kZXhlZC5yZXBsYWNlKC9cXHMqJC8sIFwiICBcIik7XG5cbiAgdmFyIHJlc3QgPSB1bnVzZWRJbmRleGVzLm1hcChfID0+IHBpZWNlc1tfXSkuam9pbihcIlwiKTtcblxuICB2YXIgcmVzdWx0ID0gb2xkRmVuSW5kZXhlZCArIHJlc3Q7XG5cbiAgdmFyIHNwYWNlcyA9IHJlc3VsdC5tYXRjaCgvXFxzL2cpLmxlbmd0aCArIHBpZWNlc0xlbmd0aDtcblxuICB3aGlsZSAoc3BhY2VzLS0gPiAzMikge1xuICAgIC8vcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xccy8sIFwiXCIpO1xuXG4gICAgLy9yZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFxzKFteXFxzXSopJC8sIFwiJDFcIik7XG4gIH1cblxuICBpZiAoIWFzc2VydEVxdWFsKHJlc3VsdC5tYXRjaChyZWdQaWVjZSkuc29ydCgpLCBuZXdGZW4ubWF0Y2gocmVnUGllY2UpLnNvcnQoKSkpIHtcbiAgICBjb25zb2xlLndhcm4oXCJib2FyZCBkaWZmIGZhaWxlZFxcblwiLCBmZW5TKHJlc3VsdCksIFwiXFxuXCIsIGZlblMob2xkRmVuKSwgXCJcXG5cIiwgZmVuUyhuZXdGZW4pKTtcbiAgICByZXN1bHQgPSBuZXdGZW47XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgaUJvYXJkID0gMjtcblxuZnVuY3Rpb24gcGVyc2lzdGVudEZlbihmZW4sIG9sZEZlbikge1xuICB2YXIgb2xkQm9hcmQgPSBvbGRGZW4uc3BsaXQoJy8nKVtpQm9hcmRdO1xuICB2YXIgYm9hcmQgPSBmZW4uc3BsaXQoJy8nKVtpQm9hcmRdO1xuICB2YXIgcmVzdCA9IGZlbi5zdWJzdHIoYm9hcmQubGVuZ3RoKTtcblxuICB2YXIgbmV3Qm9hcmQgPSBib2FyZDtcblxuICB2YXIgZGlmZiA9IGJvYXJkRGlmZihvbGRCb2FyZCwgbmV3Qm9hcmQpO1xuXG4gIC8vIGZlbiA9IGRpZmYgKyByZXN0O1xuXG4gIGZlbiA9IGZlbi5yZXBsYWNlKGJvYXJkLCBkaWZmKTtcblxuICByZXR1cm4gZmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGVyc2lzdGVudEZlbjogcGVyc2lzdGVudEZlbixcbiAgZmVuU3RvcmU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGZlbikge1xuICAgICAgdmFyIG9sZEJvYXJkID0gc3RvcmFnZS5nZXQoc2spO1xuXG4gICAgICAvLyBtYWtlIGEgaGFjayBmZW4gdG8gc3BsaXRcbiAgICAgIHZhciBvbGRGZW4gPSBcIi8vXCIgKyBvbGRCb2FyZCArIFwiL1wiO1xuXG4gICAgICByZXR1cm4gcGVyc2lzdGVudEZlbihmZW4sIG9sZEZlbik7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGZlbikge1xuICAgICAgLy92YXIgYm9hcmQgPSBmZW4uc3BsaXQoJy8nKVtpQm9hcmRdO1xuICAgICAgdmFyIGJvYXJkID0gZmVuO1xuICAgICAgc3RvcmFnZS5zZXQoc2ssIGJvYXJkKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uLy4uL295dW5rZXlmL2dhbWUnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vLi4vaTE4bic7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uLy4uL2hlbHBlcic7XG5pbXBvcnQgWmFuaW1vIGZyb20gJ3phbmltbyc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZnVuY3Rpb24gbWFrZUFjdGlvbkJhckJ1dHRvbihrZXksIGljb24sIG5hbWUsIGFjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oY3RybCwgY29uZmlnKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gaGVscGVyLmNsYXNzU2V0KHtcbiAgICAgICdnYW1lX2FjdGlvbl9iYXJfYnV0dG9uJzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKCFjdHJsLnZtW2FjdGlvbl0pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJnYW1lX2FjdGlvbl9iYXJfYnV0dG9uIGVtcHR5XCIvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8YnV0dG9uIGlkPXtuYW1lfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0ga2V5PXtrZXl9IGRhdGEtaWNvbj17aWNvbn0gY29uZmlnPXtib3RoKHNsaWRlc0luRG93biwgaGVscGVyLm9udG91Y2goZ2FtZUFjdGlvbkhhbmRsZXIoY3RybCwgYWN0aW9uKSkpfT5cbiAgICAgICAge2kxOG4obmFtZSl9XG4gICAgICA8L2J1dHRvbj5cbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9wZW5TZXJpZXM6IG1ha2VBY3Rpb25CYXJCdXR0b24oJ29wZW5TZXJpZXMnLCAnTCcsICdvcGVuU2VyaWVzJywgJ29wZW5TZXJpZXMnKSxcbiAgb3BlblBhaXJzOiBtYWtlQWN0aW9uQmFyQnV0dG9uKCdvcGVuUGFpcnMnLCAnTCcsICdvcGVuUGFpcnMnLCAnb3BlblBhaXJzJyksXG4gIGxlYXZlVGFrZW46IG1ha2VBY3Rpb25CYXJCdXR0b24oJ2xlYXZlVGFrZW4nLCAnTCcsICdsZWF2ZVRha2VuJywgJ2xlYXZlVGFrZW4nKSxcbiAgY29sbGVjdE9wZW46IG1ha2VBY3Rpb25CYXJCdXR0b24oJ2NvbGxlY3RPcGVuJywgJ0wnLCAnY29sbGVjdE9wZW4nLCAnY29sbGVjdE9wZW4nKSxcbiAgZm9sbG93VXA6IGZ1bmN0aW9uKGN0cmwpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBoZWxwZXIuY2xhc3NTZXQoe1xuICAgICAgJ2dhbWVfYWN0aW9uX2Jhcl9idXR0b24nOiB0cnVlLFxuICAgICAgJ2dsb3cnOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZihnYW1lQXBpLnBsYXlhYmxlKGN0cmwuZGF0YSkpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGJ1dHRvbiBpZD1cImZvbGxvd1VwXCIgY2xhc3NOYW1lPXtjbGFzc05hbWV9IGtleT1cImZvbGxvd1VwXCIgZGF0YS1pY29uPVwiR1wiIGNvbmZpZz17Ym90aChzbGlkZXNJbkRvd24sIGhlbHBlci5vbnRvdWNoKCgpID0+IGN0cmwuZm9sbG93VXAoKSkpfT5cbiAgICAgICAge2kxOG4oJ2JhY2tUb01hc2EnKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgICk7XG4gIH0sXG4gIHJldHVyblRvTWFzYTogZnVuY3Rpb24oY3RybCkge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICBjdHJsLmhpZGVBY3Rpb25zKCk7XG4gICAgICBtLnJvdXRlKCcvbWFzYS8nICsgY3RybC5kYXRhLmdhbWUubWFzYUlkLCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b24ga2V5PVwicmV0dXJuVG9NYXNhXCIgY29uZmlnPXtoZWxwZXIub250b3VjaChoYW5kbGVyKX0+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXRyb3BoeVwiLz5cbiAgICAgICAge2kxOG4oJ2JhY2tUb01hc2EnKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgICk7XG4gIH0sXG4gIHdpdGhkcmF3RnJvbU1hc2E6IGZ1bmN0aW9uKGN0cmwpIHtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgY3RybC5oaWRlQWN0aW9ucygpO1xuICAgICAgbWFzYVhoci53aXRoZHJhdyhjdHJsLmRhdGEuZ2FtZS5tYXNhSWQpO1xuICAgICAgbS5yb3V0ZSgnL21hc2EvJyArIGN0cmwuZGF0YS5nYW1lLm1hc2FJZCk7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8YnV0dG9uIGtleT1cIndpdGhkcmF3RnJvbU1hc2FcIiBjb25maWc9e2hlbHBlci5vbnRvdWNoKGhhbmRsZXIpfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtZmxhZ1wiLz5cbiAgICAgICAge2kxOG4oJ3dpdGhkcmF3Jyl9XG4gICAgICA8L2J1dHRvbj5cbiAgICApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnYW1lQWN0aW9uSGFuZGxlcihjdHJsLCBhY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChjdHJsW2FjdGlvbl0pIGN0cmxbYWN0aW9uXS5jYWxsKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNsaWRlc0luVXAoZWwsIGlzVXBkYXRlLCBjb250ZXh0KSB7XG4gIGlmICghaXNVcGRhdGUpIHtcbiAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknO1xuICAgIC8vIGZvcmNlIHJlZmxvdyBoYWNrXG4gICAgY29udGV4dC5sb2wgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScsIDI1MCwgJ2Vhc2Utb3V0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2xpZGVzSW5Eb3duKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuICBpZiAoIWlzVXBkYXRlKSB7XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDAsIC0xMDAlLCAwKSc7XG4gICAgLy8gZm9yY2UgcmVmbG93IGhhY2tcbiAgICBjb250ZXh0LmxvbCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICBaYW5pbW8oZWwsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJywgMjUwLCAnZWFzZS1vdXQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmYWRlc0luKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuICBpZiAoIWlzVXBkYXRlKSB7XG4gICAgZWwuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgLy8gZm9yY2UgcmVmbG93IGhhY2tcbiAgICBjb250ZXh0LmxvbCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICBaYW5pbW8oZWwsICdvcGFjaXR5JywgMSwgMjUwLCAnZWFzZS1vdXQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBib3RoKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbmZpZzEuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBjb25maWcyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBva2V5Z3JvdW5kIGZyb20gJ29rZXlncm91bmQtbW9iaWxlJztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uLy4uL2kxOG4nO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi8uLi9sYXlvdXQnO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuLi8uLi9oZWxwZXInO1xuaW1wb3J0IHsgbWVudUJ1dHRvbiB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IGNoYXQgZnJvbSAnLi4vY2hhdCc7XG5pbXBvcnQgYnV0dG9uIGZyb20gJy4vYnV0dG9uJztcbmltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uLy4uL295dW5rZXlmL2dhbWUnO1xuaW1wb3J0IGdhbWVTdGF0dXMgZnJvbSAnLi4vLi4vLi4vb3l1bmtleWYvc3RhdHVzJztcbmltcG9ydCBCb2FyZCBmcm9tICcuLi8uLi9zaGFyZWQvQm9hcmQnO1xuaW1wb3J0IHBvcHVwV2lkZ2V0IGZyb20gJy4uLy4uL3NoYXJlZC9wb3B1cCc7XG5pbXBvcnQgWmFuaW1vIGZyb20gJ3phbmltbyc7XG5cbmNvbnN0IHsgdXRpbCB9ID0gb2tleWdyb3VuZDtcbmNvbnN0IHsgcGFydGlhbCB9ID0gdXRpbDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlldyhjdHJsKSB7XG4gIGNvbnN0IGlzUG9ydHJhaXQgPSBoZWxwZXIuaXNQb3J0cmFpdCgpO1xuXG4gIHJldHVybiBsYXlvdXQuYm9hcmQoXG4gICAgKCkgPT4gcmVuZGVySGVhZGVyKGN0cmwpLFxuICAgICgpID0+IHJlbmRlckNvbnRlbnQoY3RybCwgaXNQb3J0cmFpdCksXG4gICAgKCkgPT4gb3ZlcmxheShjdHJsKVxuICApO1xufVxuXG5mdW5jdGlvbiBvdmVybGF5KGN0cmwpIHtcbiAgcmV0dXJuIFtcbiAgICBjdHJsLmNoYXQgPyBjaGF0LnZpZXcoY3RybC5jaGF0KSA6IG51bGwsXG4gICAgcmVuZGVyR2FtZVBvcHVwKGN0cmwpXG4gIF07XG59XG5cbmZ1bmN0aW9uIHJlbmRlckhlYWRlcihjdHJsKSB7IHJldHVybiBudWxsOyB9XG5cbmZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoY3RybCwgaXNQb3J0cmFpdCkge1xuICBjb25zdCBib3VuZHMgPSB1dGlscy5nZXRCb2FyZEJvdW5kcyhoZWxwZXIudmlld3BvcnREaW0oKSwgaXNQb3J0cmFpdCwgaGVscGVyLmlzSXBhZExpa2UoKSwgJ2dhbWUnKTtcbiAgY29uc3QgYm9hcmQgPSBCb2FyZChcbiAgICBjdHJsLFxuICAgIGN0cmwub2tleWdyb3VuZCxcbiAgICBib3VuZHMsXG4gICAgaXNQb3J0cmFpdCxcbiAgICBudWxsXG4gICk7XG5cbiAgcmV0dXJuIFtcbiAgICBib2FyZCxcbiAgICA8c2VjdGlvbiBrZXk9XCJ0YWJsZVwiIGNsYXNzTmFtZT1cInRhYmxlXCI+XG4gICAgICA8aGVhZGVyIGtleT1cInRhYmxlLWhlYWRlclwiIGNsYXNzTmFtZT1cInRhYmxlSGVhZGVyXCI+XG4gICAgICAgIHttZW51QnV0dG9uKCl9XG4gICAgICAgIHtnYW1lSW5mb3MoY3RybCl9XG4gICAgICA8L2hlYWRlcj5cbiAgICAgIHtyZW5kZXJSZXBsYXkoY3RybCl9XG4gICAgICB7cmVuZGVyR2FtZUFjdGlvbnNCYXIoY3RybCl9XG4gICAgPC9zZWN0aW9uPlxuICBdO1xufVxuXG5mdW5jdGlvbiByZW5kZXJSZXBsYXkoY3RybCkge1xuICBjb25zdCBnbUNsYXNzID0gKFsnZmEnLFxuICAgICAgICAgICAgICAgICAgICAnZmEtZWxsaXBzaXMtaCddKS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICdnYW1lX2Jhcl9idXR0b24nXG4gICAgICAgICAgICAgICAgICAgIF0pLmpvaW4oJyAnKTtcbiAgY29uc3QgZ21CdXR0b24gPVxuICA8YnV0dG9uIGNsYXNzTmFtZT17Z21DbGFzc30ga2V5PVwiZ2FtZU1lbnVcIiBjb25maWc9e2hlbHBlci5vbnRvdWNoKGN0cmwuc2hvd0FjdGlvbnMpfS8+O1xuXG4gIGNvbnN0IGNoYXRDbGFzcyA9IFtcbiAgICAnZ2FtZV9iYXJfYnV0dG9uJyxcbiAgICBjdHJsLmNoYXQgJiYgY3RybC5jaGF0LnVucmVhZCA/ICdnbG93JyA6ICcnXG4gIF0uam9pbignICcpO1xuICBjb25zdCBjaGF0QnV0dG9uID0gY3RybC5jaGF0ID9cbiAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjaGF0Q2xhc3N9IGRhdGEtaWNvbj1cImNcIlxuICBrZXk9XCJjaGF0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnPXtoZWxwZXIub250b3VjaChjdHJsLmNoYXQub3Blbil9Lz4gOiBudWxsO1xuXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPVwicmVwbGF5XCI+XG4gICAgICB7Z21CdXR0b259XG4gICAgICB7Y2hhdEJ1dHRvbn1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUmVzdWx0KGN0cmwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGdhbWVTdGF0dXMuZmluaXNoZWQoY3RybC5kYXRhKSkgc3dpdGNoKGN0cmwuZGF0YS5nYW1lLndpbm5lcikge1xuICAgICAgZGVmYXVsdDpcbiAgICAgIHJlc3VsdCA9IGkxOG4oJ2dhbWVFbmRlZCcpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAocmVzdWx0IHx8IGdhbWVTdGF0dXMuYWJvcnRlZChjdHJsLmRhdGEpKSB7XG4gICAgdmFyIHdpbm5lciA9IGdhbWVBcGkuZ2V0UGxheWVyKGN0cmwuZGF0YSwgY3RybC5kYXRhLmdhbWUud2lubmVyKTtcbiAgICByZXR1cm4gW1xuICAgICAgbSgncC5yZXN1bHQnLCByZXN1bHQpLFxuICAgICAgbSgncC5zdGF0dXMnLCBbXG4gICAgICAgIHdpbm5lciA/ICcsICcgKyBpMThuKCdpc1ZpY3Rvcm91cycpOiBudWxsXG4gICAgICBdKVxuICAgIF07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2FtZUluZm9zKGN0cmwpIHtcbiAgY29uc3QgZGF0YSA9IGN0cmwuZGF0YTtcblxuICAvLyBjb25zdCByb3VuZFN0cmluZyA9IGdhbWVBcGkucm91bmRzT3JTY29yZXMoZGF0YSk7XG4gIGNvbnN0IG1vZGUgPSBkYXRhLmdhbWUucmF0ZWQgPyBpMThuKCdyYXRlZCcpOiBpMThuKCdjYXN1YWwnKTtcbiAgY29uc3QgaWNvbiA9IHV0aWxzLmdhbWVJY29uKGRhdGEuZ2FtZS5wZXJmKTtcbiAgY29uc3QgdmFyaWFudCA9IG0oJ3NwYW4udmFyaWFudCcsIHtcbiAgfSwgZGF0YS5nYW1lLnZhcmlhbnQubmFtZSk7XG4gIGNvbnN0IGluZm9zID0gW3ZhcmlhbnQsIG0oJ2JyJyksIG1vZGVdO1xuICByZXR1cm4gW1xuICAgIG0oJ2Rpdi5pY29uLWdhbWUnLCB7XG4gICAgICAnZGF0YS1pY29uJzogaWNvbiA/IGljb24gOiAnJ1xuICAgIH0pLFxuICAgIG0oJ2Rpdi5nYW1lLXRpdGxlLm5vX3NlbGVjdCcsIGluZm9zKVxuICBdO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHYW1lQWN0aW9uc0JhcihjdHJsKSB7XG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiZ2FtZV9hY3Rpb25zX2JhclwiIGtleT1cImdhbWUtYWN0aW9ucy1iYXJcIj5cbiAgICAgIHtidXR0b24ubGVhdmVUYWtlbihjdHJsKX1cbiAgICAgIHtidXR0b24uY29sbGVjdE9wZW4oY3RybCl9XG4gICAgICB7YnV0dG9uLm9wZW5QYWlycyhjdHJsKX1cbiAgICAgIHtidXR0b24ub3BlblNlcmllcyhjdHJsKX1cbiAgICAgIHtidXR0b24uZm9sbG93VXAoY3RybCl9XG4gICAgPC9zZWN0aW9uPlxuICApO1xufVxuXG5cbmZ1bmN0aW9uIHJlbmRlckdhbWVQb3B1cChjdHJsKSB7XG4gIHJldHVybiBwb3B1cFdpZGdldChcbiAgICAncGxheWVyX2NvbnRyb2xzJyxcbiAgICAoKSA9PiBnYW1lSW5mb3MoY3RybCksXG4gICAgZ2FtZUFwaS5wbGF5YWJsZShjdHJsLmRhdGEpID9cbiAgICAgICgpID0+IHJlbmRlckdhbWVSdW5uaW5nQWN0aW9ucyhjdHJsKSA6XG4gICAgICAgICAgKCkgPT4gcmVuZGVyR2FtZUVuZGVkQWN0aW9ucyhjdHJsKSxcbiAgICBjdHJsLnZtLnNob3dpbmdBY3Rpb25zLFxuICAgIGN0cmwuaGlkZUFjdGlvbnNcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyR2FtZVJ1bm5pbmdBY3Rpb25zKGN0cmwpIHtcbiAgY29uc3QgZ2FtZUNvbnRyb2xzID0gW1xuICAgICAgYnV0dG9uLnJldHVyblRvTWFzYShjdHJsKVxuICBdO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJnYW1lX2NvbnRyb2xzXCI+XG4gICAgICB7Z2FtZUNvbnRyb2xzfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHYW1lRW5kZWRBY3Rpb25zKGN0cmwpIHtcbiAgY29uc3QgbmJIYW5kID0gY3RybC5kYXRhLmdhbWUucm91bmRBdCArIDE7XG4gIGNvbnN0IHJlc3VsdCA9IGdhbWVBcGkucmVzdWx0KGN0cmwuZGF0YSk7XG4gIGNvbnN0IHdpbm5lciA9IGdhbWVBcGkuZ2V0UGxheWVyKGN0cmwuZGF0YSwgY3RybC5kYXRhLmdhbWUud2lubmVyKTtcbiAgY29uc3Qgc3RhdHVzID0gZ2FtZVN0YXR1cy50b0xhYmVsKGN0cmwuZGF0YS5nYW1lLnN0YXR1cy5uYW1lLCBjdHJsLmRhdGEuZ2FtZS53aW5uZXIsIGN0cmwuZGF0YS5nYW1lLnZhcmlhbnQua2V5KTtcbiAgY29uc3QgcmVzdWx0RE9NID0gZ2FtZVN0YXR1cy5hYm9ydGVkKGN0cmwuZGF0YSkgPyBbXSA6IFtcbiAgICBtKCdzdHJvbmcnLCBgJHtuYkhhbmR9LiBgICsgcmVzdWx0KSwgbSgnYnInKVxuICBdO1xuXG4gIHJlc3VsdERPTS5wdXNoKG0oJ2VtLnJlc3VsdFN0YXR1cycsIHN0YXR1cykpO1xuICBsZXQgYnV0dG9ucyA9IG51bGw7XG4gIGlmIChjdHJsLmRhdGEuZ2FtZS5tYXNhSWQpIHtcbiAgICBidXR0b25zID0gW1xuICAgICAgYnV0dG9uLnJldHVyblRvTWFzYShjdHJsKSxcbiAgICAgIGJ1dHRvbi53aXRoZHJhd0Zyb21NYXNhKGN0cmwpXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJnYW1lX2NvbnRyb2xzXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlc3VsdFwiPntyZXN1bHRET019PC9kaXY+XG4gICAgICB7cmVuZGVyU2NvcmVzKGN0cmwpfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250cm9sIGJ1dHRvbnNcIj57YnV0dG9uc308L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU2NvcmVzKGN0cmwpIHtcbiAgdmFyIGQgPSBjdHJsLmRhdGE7XG4gIHZhciBzaWRlcyA9IFsnZWFzdCcsICd3ZXN0JywgJ25vcnRoJywgJ3NvdXRoJ107XG4gIHZhciBzY29yZXMgPSBzaWRlcy5tYXAoc2lkZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYXllcjogZ2FtZUFwaS5nZXRQbGF5ZXIoZCwgc2lkZSksXG4gICAgICBzY29yZXM6IGQuZ2FtZS5zY29yZXMgPyBkLmdhbWUuc2NvcmVzW3NpZGVdIDogeyBzY29yZXM6IFtdIH0sXG4gICAgICBvcGVuczogZC5nYW1lLm9zY29yZXMgPyBkLmdhbWUub3Njb3Jlc1tzaWRlXSA6IG51bGxcbiAgICB9O1xuICB9KTtcblxuICB2YXIgdGFibGVCb2R5ID0gc2NvcmVzLm1hcChwYXJ0aWFsKGR1elBsYXllclRyLCBjdHJsKSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjcm9zc3RhYmxlXCI+XG4gICAgICAgIDx0YWJsZT5cbiAgICAgICAgICA8dGhlYWQ+PHRyPjwvdHI+PC90aGVhZD5cbiAgICAgICAgICA8dGJvZHk+e3RhYmxlQm9keX08L3Rib2R5PlxuICAgICAgICA8L3RhYmxlPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gZHV6UGxheWVyVHIoY3RybCwgeyBwbGF5ZXIsIHNjb3JlcyB9KSB7XG4gIGNvbnN0IG15U2lkZSA9IGN0cmwuZGF0YS5wbGF5ZXIuc2lkZTtcblxuICBjb25zdCB0ckNsYXNzID0gaGVscGVyLmNsYXNzU2V0KHtcbiAgICAnbWUnOiBwbGF5ZXIuc2lkZSA9PT0gbXlTaWRlXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPHRyIGtleT17cGxheWVyLnNpZGV9IGNsYXNzTmFtZT17dHJDbGFzc30+XG4gICAgICA8dGggY2xhc3NOYW1lPVwic2NvcmVcIj57c2NvcmVzLnRvdGFsfTwvdGg+XG4gICAgICA8dGggY2xhc3NOYW1lPVwidXNlclwiPnt1dGlsUGxheWVyKHBsYXllciwgJ2EnKX08L3RoPlxuICAgIDwvdHI+KTtcbn1cblxuXG5mdW5jdGlvbiB1dGlsUGxheWVyKHAsIHRhZykge1xuICB2YXIgZnVsbE5hbWUgPSBwLnVzZXIgPyBwLnVzZXIudXNlcm5hbWUgOiAocC5haSA/IGkxOG4oJ2FpQm90JywgcC5haSkgOiBpMThuKHAuc2lkZSkpO1xuICB2YXIgYXR0cnMgPSB7XG4gICAgY2xhc3M6ICd1c2VyX2xpbmsnXG4gIH07XG4gIGlmIChwLnVzZXIgJiYgcC51c2VyLnVzZXJuYW1lKSBhdHRyc1t0YWcgPT09ICdhJyA/ICdocmVmJyA6ICdkYXRhLWhyZWYnXSA9ICcvQC8nICsgcC51c2VyLnVzZXJuYW1lO1xuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLFxuICAgIGF0dHJzOiBhdHRycyxcbiAgICBjaGlsZHJlbjogZnVsbE5hbWVcbiAgfTtcbn1cbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCB7IGhlYWRlciBhcyBoZWFkZXJXaWRnZXQsIGJhY2tCdXR0b24gfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCBmb3JtV2lkZ2V0cyBmcm9tICcuLi9zaGFyZWQvZm9ybSc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vc2V0dGluZ3MnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIGNvbnRyb2xsZXIoKSB7XG4gICAgc29ja2V0LmNyZWF0ZURlZmF1bHQoKTtcbiAgfSxcblxuICB2aWV3KCkge1xuICAgIGNvbnN0IGhlYWRlciA9IHV0aWxzLnBhcnRpYWxmKGhlYWRlcldpZGdldCwgbnVsbCwgYmFja0J1dHRvbihpMThuKCdzZXR0aW5ncycpKSk7XG5cbiAgICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCByZW5kZXJCb2R5KTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiByZW5kZXJCb2R5KCkge1xuICByZXR1cm4gbSgnZGl2Jywge1xuICAgIHN0eWxlOiB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH1cbiAgfSwgW1xuICAgIG0oJ3VsLnNldHRpbmdzX2xpc3QuZ2VuZXJhbC5uYXRpdmVfc2Nyb2xsZXIucGFnZScsIFtcbiAgICAgIG0oJ2xpLmxpc3RfaXRlbS5uYXYnLCB7XG4gICAgICAgIGtleTogJ2xhbmcnLFxuICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoWSh1dGlscy5mKG0ucm91dGUsICcvc2V0dGluZ3MvbGFuZycpKVxuICAgICAgfSwgaTE4bignbGFuZ3VhZ2UnKSksXG4gICAgICBtKCdsaS5saXN0X2l0ZW0uc2V0dGluZ3NDaG9pY2VzSW5saW5lJywge1xuICAgICAgICBrZXk6ICdiYWNrZ3JvdW5kVGhlbWUnXG4gICAgICB9LCBbXG4gICAgICAgIG0oJ2xhYmVsJywgaTE4bignYmFja2dyb3VuZCcpKSxcbiAgICAgICAgbSgnZmllbGRzZXQnLCBbXG4gICAgICAgICAgbSgnZGl2Lm5pY2UtcmFkaW8nLCBmb3JtV2lkZ2V0cy5yZW5kZXJSYWRpbyhcbiAgICAgICAgICAgIGkxOG4oJ2RhcmsnKSxcbiAgICAgICAgICAgICdiZ1RoZW1lJyxcbiAgICAgICAgICAgICdkYXJrJyxcbiAgICAgICAgICAgIHNldHRpbmdzLmdlbmVyYWwudGhlbWUuYmFja2dyb3VuZCgpID09PSAnZGFyaycsXG4gICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuZ2VuZXJhbC50aGVtZS5iYWNrZ3JvdW5kKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgbGF5b3V0Lm9uQmFja2dyb3VuZENoYW5nZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgbSgnZGl2Lm5pY2UtcmFkaW8nLCBmb3JtV2lkZ2V0cy5yZW5kZXJSYWRpbyhcbiAgICAgICAgICAgIGkxOG4oJ2xpZ2h0JyksXG4gICAgICAgICAgICAnYmdUaGVtZScsXG4gICAgICAgICAgICAnbGlnaHQnLFxuICAgICAgICAgICAgc2V0dGluZ3MuZ2VuZXJhbC50aGVtZS5iYWNrZ3JvdW5kKCkgPT09ICdsaWdodCcsXG4gICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuZ2VuZXJhbC50aGVtZS5iYWNrZ3JvdW5kKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgbGF5b3V0Lm9uQmFja2dyb3VuZENoYW5nZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIF0pXSlcbiAgICBdKSxcbiAgICB3aW5kb3cub3l1bmtleWYudmVyc2lvbiA/IG0oJ3NlY3Rpb24uYXBwX3ZlcnNpb24nLCAndicgKyB3aW5kb3cub3l1bmtleWYudmVyc2lvbikgOiBudWxsXG4gIF0pO1xufVxuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgaGVhZGVyIGFzIGhlYWRlcldpZGdldCwgYmFja0J1dHRvbiB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuaW1wb3J0IGZvcm1XaWRnZXRzIGZyb20gJy4uL3NoYXJlZC9mb3JtJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgaTE4biwgeyBsb2FkRnJvbVNldHRpbmdzLCBnZXRBdmFpbGFibGVMYW5ndWFnZXMgfSBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCB7IHNldFNlcnZlckxhbmcgfSBmcm9tICcuLi8uLi94aHInO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgbGFuZ3MgPSBtLnByb3AoW10pO1xuICAgIGdldEF2YWlsYWJsZUxhbmd1YWdlcygpLnRoZW4obGFuZ3MpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmdzXG4gICAgfTtcbiAgfSxcbiAgdmlldzogZnVuY3Rpb24oY3RybCkge1xuICAgIGNvbnN0IGhlYWRlciA9IHV0aWxzLnBhcnRpYWxmKGhlYWRlcldpZGdldCwgbnVsbCwgYmFja0J1dHRvbihpMThuKCdsYW5ndWFnZScpKVxuICAgICAgKTtcblxuICAgIGZ1bmN0aW9uIHJlbmRlckxhbmcobCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cImxpc3RfaXRlbVwiPlxuICAgICAgICB7Zm9ybVdpZGdldHMucmVuZGVyUmFkaW8obFsxXSwgJ2xhbmcnLCBsWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2VuZXJhbC5sYW5nKCkgPT09IGxbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZ2VuZXJhbC5sYW5nKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VydmVyTGFuZyhlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRGcm9tU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgKX1cbiAgICAgICAgPC9saT5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyQm9keSgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJuYXRpdmVfc2Nyb2xsZXIgcGFnZSBzZXR0aW5nc19saXN0IHJhZGlvX2xpc3RcIj5cbiAgICAgICAgICB7Y3RybC5sYW5ncygpLm1hcChsID0+IHJlbmRlckxhbmcobCkpfVxuICAgICAgICA8L3VsPlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxheW91dC5mcmVlKGhlYWRlciwgcmVuZGVyQm9keSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBva2V5Z3JvdW5kIGZyb20gJ29rZXlncm91bmQtbW9iaWxlJztcbmltcG9ydCB7IG1lbnVCdXR0b24gfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyByZW5kZXJQbGF5ZXIgfSBmcm9tICcuL1BsYXllcnMnO1xuaW1wb3J0IHsgdmlldyBhcyByZW5kZXJDbG9jayB9IGZyb20gJy4uL3JvdW5kL2Nsb2NrL2Nsb2NrVmlldyc7XG5cbmZ1bmN0aW9uIHJlbmRlclRvcE1lbnUoKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzcz1cImRpc3BsYXlfbWVudVwiPlxuICAgICAge21lbnVCdXR0b24oKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGxheWVySW5mbyhjdHJsLCBwbGF5ZXIsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IHdyYXBwZXJDbGFzcyA9IGhlbHBlci5jbGFzc1NldCh7XG4gICAgJ3BsYXllckluZm9zJzogdHJ1ZSxcbiAgfSkgKyBgICR7cG9zaXRpb259YDtcblxuICBjb25zdCBwbGF5ZXJOYW1lID0gcGxheWVyLmFpID9cbiAgICAgICAgICAgICAgICAgICAgIGkxOG4oJ2FpQm90JywgcGxheWVyLmFpKSA6XG4gICAgICAgICAgICAgICAgICAgICB1dGlscy5wbGF5ZXJOYW1lKHBsYXllcik7XG4gIGNvbnN0IHBsYXllck9uR2FtZSA9IChwbGF5ZXIub25HYW1lIHx8IHBsYXllci5haSA/XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJvbmdhbWUgeWVzXCIgZGF0YS1pY29uPVwiM1wiLz4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwib25nYW1lIG5vXCIgZGF0YS1pY29uPVwiMFwiLz5cbiAgKTtcblxuICBjb25zdCB0b2dnbGVQb3B1cCA9IGN0cmwudG9nZ2xlVXNlclBvcHVwLmJpbmQoY3RybCwgcG9zaXRpb24sIHBsYXllci51c2VyKTtcbiAgY29uc3QgdkNvbmYgPSBoZWxwZXIub250b3VjaCh0b2dnbGVQb3B1cCk7XG5cbiAgY29uc3QgcnVubmluZ1NpZGUgPSBjdHJsLmlzQ2xvY2tSdW5uaW5nKCkgPyBjdHJsLmRhdGEuZ2FtZS5wbGF5ZXIgOiBudWxsO1xuICBjb25zdCBydW5uaW5nID0gY3RybC5kYXRhLmdhbWUucGxheWVyID09PSBwbGF5ZXIuc2lkZTtcblxuICBjb25zdCBvcGVucyA9IGN0cmwuZGF0YS5nYW1lLm9zY29yZXMgPyBjdHJsLmRhdGEuZ2FtZS5vc2NvcmVzW3BsYXllci5zaWRlXSA6IG51bGw7XG4gIGNvbnN0IG9wZW5zSGludCA9IG9wZW5zID8gKG9wZW5zLnNlcmllcyA/ICdvcGVuZWRTZXJpZXMnIDogJ29wZW5lZFBhaXJzJykgOiBudWxsO1xuICBjb25zdCBvcGVuc0NsYXNzID0gXCJvcGVuc1wiICsgKChvcGVucyAmJiBvcGVucy5uZXcpID8gXCIgbmV3XCIgOiBcIlwiKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3N9IGNvbmZpZz17dkNvbmZ9PlxuICAgICAgPGRpdiBjbGFzcz1cIndyYXBfaW5mb1wiPlxuICAgICAgICB7b3BlbnMgP1xuICAgICAgICAgPGRpdiBjbGFzcz17b3BlbnNDbGFzc30+XG4gICAgICAgICAgIHsob3BlbnMuc2VyaWVzID8gb3BlbnMuc2VyaWVzIDogb3BlbnMucGFpcnMpfVxuICAgICAgICAgICB7JyAnfVxuICAgICAgICAgICB7aTE4bihvcGVuc0hpbnQpLnNwbGl0KCcgJylbMF19XG4gICAgICAgICA8L2Rpdj46IG51bGxcbiAgICAgICAgfVxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwid3JhcF91c2VyXCI+XG4gICAgICAgIDxoMiBjbGFzc05hbWU9XCJwbGF5ZXJVc2VyXCI+XG4gICAgICAgICAge3BsYXllck5hbWV9XG4gICAgICAgICAge3BsYXllck9uR2FtZX1cbiAgICAgICAgPC9oMj5cbiAgICAgICAgeyAoY3RybC5jbG9jayAmJiBydW5uaW5nKSA/XG4gICAgICAgICAgcmVuZGVyQ2xvY2soY3RybC5jbG9jaywgcGxheWVyLnNpZGUsIHJ1bm5pbmdTaWRlLCBwb3NpdGlvbikgOiBudWxsXG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihcbiAgY3RybCxcbiAgb2tleWdyb3VuZEN0cmwsXG4gIGJvdW5kcyxcbiAgaXNQb3J0cmFpdCxcbiAgd3JhcHBlckNsYXNzZXMpIHtcbiAgICBjb25zdCBkYXRhID0gY3RybC5kYXRhO1xuXG4gICAgY29uc3QgYm9hcmRDbGFzcyA9IFtcbiAgICAgICdkaXNwbGF5X2JvYXJkJyxcbiAgICBdLmpvaW4oJyAnKTtcblxuICAgIGNvbnN0IGtleSA9ICdib2FyZCcgKyAoaXNQb3J0cmFpdCA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJyk7XG4gICAgbGV0IHdyYXBwZXJDbGFzcyA9ICdnYW1lX2JvYXJkX3dyYXBwZXInO1xuXG4gICAgaWYgKHdyYXBwZXJDbGFzc2VzKSB7XG4gICAgICB3cmFwcGVyQ2xhc3MgKz0gJyAnICsgd3JhcHBlckNsYXNzZXM7XG4gICAgfVxuXG4gICAgY29uc3Qgd3JhcHBlclN0eWxlID0gYm91bmRzID8ge1xuICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0ICsgJ3B4JyxcbiAgICAgIHdpZHRoOiBib3VuZHMud2lkdGggKyAncHgnXG4gICAgfSA6IHt9O1xuXG5cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29uZmlnKGVsLCBpc1VwZGF0ZSkge1xuICAgICAgaWYgKCFpc1VwZGF0ZSkge1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJvYXJkQ29uZmlnKGVsLCBpc1VwZGF0ZSkge1xuICAgICAgaWYgKCFpc1VwZGF0ZSkge1xuICAgICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICB9XG4gICAgICAgIG9rZXlncm91bmQucmVuZGVyKGVsLCBva2V5Z3JvdW5kQ3RybCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2tleWdyb3VuZEN0cmwuZGF0YS50b3BIb29rcyA9IFtcbiAgICAgIC8vIHJlbmRlclRvcE1lbnUoKSxcbiAgICAgIHJlbmRlclBsYXllckluZm8oY3RybCwgZGF0YS5vcHBvbmVudFVwLCAndG9wJyksXG4gICAgICByZW5kZXJQbGF5ZXJJbmZvKGN0cmwsIGRhdGEub3Bwb25lbnRMZWZ0LCAnbGVmdCcpLFxuICAgICAgcmVuZGVyUGxheWVySW5mbyhjdHJsLCBkYXRhLnBsYXllciwgJ2JvdHRvbScpLFxuICAgICAgcmVuZGVyUGxheWVySW5mbyhjdHJsLCBkYXRhLm9wcG9uZW50UmlnaHQsICdyaWdodCcpXG4gICAgXTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT17d3JhcHBlckNsYXNzfSBjb25maWc9e3dyYXBwZXJDb25maWd9XG4gICAgICAgICAgICAgICBzdHlsZT17d3JhcHBlclN0eWxlfSBrZXk9e2tleX0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtib2FyZENsYXNzfSBjb25maWc9e2JvYXJkQ29uZmlnfSAvPlxuICAgICAgPC9zZWN0aW9uPlxuICAgICk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcmVuZGVyUGxheWVyKHBvc2l0aW9uKSB7XG4gIGNvbnN0IHBsYXllckNsYXNzID0gW1xuICAgICdwbGF5ZXInLFxuICAgIHBvc2l0aW9uXG4gIF0uam9pbignICcpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3BsYXllckNsYXNzfT5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXG4gIGRhdGEsXG4gIGJvdW5kcykge1xuXG4gICAgY29uc3QgcGxheWVyQ2xhc3MgPSBbXG4gICAgICAnZGlzcGxheV9wbGF5ZXInXG4gICAgXS5qb2luKCcgJyk7XG5cbiAgICBjb25zdCBrZXkgPSAncGxheWVycyc7XG5cbiAgICBjb25zdCB0b3BQbGF5ZXIgPSByZW5kZXJQbGF5ZXIoJ3RvcCcpXG4gICAgY29uc3QgbGVmdFBsYXllciA9IHJlbmRlclBsYXllcignbGVmdCcpXG4gICAgY29uc3QgcmlnaHRQbGF5ZXIgPSByZW5kZXJQbGF5ZXIoJ3JpZ2h0JylcbiAgICBjb25zdCBib3R0b21QbGF5ZXIgPSByZW5kZXJQbGF5ZXIoJ2JvdHRvbScpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3BsYXllckNsYXNzfT5cbiAgICAgICAge3RvcFBsYXllcn1cbiAgICAgICAge2xlZnRQbGF5ZXJ9XG4gICAgICAgIHtyaWdodFBsYXllcn1cbiAgICAgICAge2JvdHRvbVBsYXllcn1cbiAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iLCJpbXBvcnQgb2tleWdyb3VuZCBmcm9tICdva2V5Z3JvdW5kLW1vYmlsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmlldyhfLCBhcmdzKSB7XG4gICAgY29uc3QgYm9hcmRDbGFzcyA9IFtcbiAgICAgICdkaXNwbGF5X2JvYXJkJyxcbiAgICAgIGFyZ3MudmFyaWFudCA/IGFyZ3MudmFyaWFudC5rZXkgOiAnJ1xuICAgIF0uam9pbignICcpO1xuXG4gICAgZnVuY3Rpb24gYm9hcmRDb25mKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuICAgICAgY29uc3QgY29uZmlnID0gbWFrZUNvbmZpZyhhcmdzKTtcbiAgICAgIGlmIChjb250ZXh0Lmdyb3VuZCkge1xuICAgICAgICBjb250ZXh0Lmdyb3VuZC5zZXQoY29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE8gdHJ5IHRvIGF2b2lkIHRoYXRcbiAgICAgICAgaWYgKCFjb25maWcuYm91bmRzKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ25vIGJvYXJkIGJvdW5kcycpO1xuICAgICAgICAgIC8vIGNvbmZpZy5ib3VuZHMgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lmdyb3VuZCA9IG9rZXlncm91bmQoZWwsIGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtib2FyZENsYXNzfSBjb25maWc9e2JvYXJkQ29uZn0vPlxuICAgICk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1ha2VDb25maWcoYXJncykge1xuICBjb25zdCB7IGZlbiwgb3JpZW50YXRpb24sIGJvdW5kcyB9ID0gYXJncztcbiAgY29uc3QgY29uZiA9IHtcbiAgICB2aWV3T25seTogdHJ1ZSxcbiAgICBtaW5pbWFsRG9tOiB0cnVlLFxuICAgIGZlblxuICB9O1xuXG4gIC8vIGlmIChib3VuZHMpIGNvbmYuYm91bmRzID0gYm91bmRzO1xuXG4gIHJldHVybiBjb25mO1xufVxuIiwiaW1wb3J0ICogYXMgbWVudSBmcm9tICcuLi9tZW51JztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBnYW1lc01lbnUgZnJvbSAnLi4vZ2FtZXNNZW51JztcbmltcG9ydCBuZXdHYW1lRm9ybSBmcm9tICcuLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgVmlld09ubHlCb2FyZCBmcm9tICcuL1ZpZXdPbmx5Qm9hcmQnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWVudUJ1dHRvbigpIHtcbiAgcmV0dXJuIGgoJ2J1dHRvbi5mYS5mYS1uYXZpY29uLm1haW5faGVhZGVyX2J1dHRvbi5tZW51X2J1dHRvbicsIHtcbiAgICBrZXk6ICdtYWluLW1lbnUnLFxuICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXAobWVudS5tYWluTWVudUN0cmwudG9nZ2xlKVxuICB9KTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGVhZGVyQnRucygpIHtcblxuICBpZiAodXRpbHMuaGFzTmV0d29yaygpICYmIHNlc3Npb24uaXNDb25uZWN0ZWQoKSkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT1cImJ1dHRvbnNcIiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT1cImJ1dHRvbnNcIiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4gIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJvcFNoYWRvd0hlYWRlcih0aXRsZSwgbGVmdEJ1dHRvbikge1xuXG4gIHJldHVybiBbXG4gICAgaCgnbmF2JywgW1xuICAgICAgbGVmdEJ1dHRvbiA/IGxlZnRCdXR0b24gOiBtZW51QnV0dG9uKCksXG4gICAgICB0aXRsZSA/IDxkaXYgY2xhc3NOYW1lPVwibWFpbl9oZWFkZXJfdGl0bGVcIiBrZXk9XCJ0aXRsZVwiPnt0aXRsZX08L2Rpdj46IG51bGwsXG4gICAgICBoZWFkZXJCdG5zKClcbiAgICBdKSxcbiAgICBoKCdkaXYubWFpbl9oZWFkZXJfZHJvcF9zaGFkb3cnKVxuICBdO1xuICBcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIG1lbnVCdXR0b24oKSB7XG4vLyAgIHJldHVybiAoXG4vLyAgICAgICA8YnV0dG9uIGtleT1cIm1haW4tbWVudVwiIGNsYXNzTmFtZT1cImZhIGZhLW5hdmljb24gbWFpbl9oZWFkZXJfYnV0dG9uIG1lbnVfYnV0dG9uXCIgY29uZmlnPXtoZWxwZXIub250b3VjaChtZW51LnRvZ2dsZSl9PlxuLy8gICAgIDwvYnV0dG9uPlxuLy8gICApO1xuLy8gfVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja0J1dHRvbih0aXRsZSkge1xuICByZXR1cm4gKFxuICAgICAgPGJ1dHRvbiBrZXk9XCJkZWZhdWx0LWhpc3RvcnktYmFja2J1dHRvblwiIGNsYXNzTmFtZT1cImJhY2tfYnV0dG9uIG1haW5faGVhZGVyX2J1dHRvblwiIGNvbmZpZz17aGVscGVyLm9udG91Y2godXRpbHMuYmFja0hpc3RvcnkpfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWFycm93LWxlZnRcIi8+XG4gICAgICB7dGl0bGUgPyA8ZGl2IGNsYXNzTmFtZT1cInRpdGxlXCI+e3RpdGxlfTwvZGl2PiA6IG51bGwgfVxuICAgIDwvYnV0dG9uPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtZXNCdXR0b24oKSB7XG4gIGxldCBrZXksIGFjdGlvbjtcblxuICBrZXk9J2dhbWVzLW1lbnUnO1xuXG4gIGlmIChzZXNzaW9uLm5vd1BsYXlpbmcoKS5sZW5ndGgpIHtcbiAgICBrZXkgPSAnZ2FtZXMtbWVudSc7XG4gICAgYWN0aW9uID0gZ2FtZXNNZW51Lm9wZW47XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gJ25ldy1nYW1lLWZvcm0nO1xuICAgIGFjdGlvbiA9IG5ld0dhbWVGb3JtLm9wZW47XG4gIH1cblxuICBjb25zdCBjbGFzc05hbWUgPSBbXG4gICAgJ21haW5faGVhZGVyX2J1dHRvbicsXG4gICAgJ2dhbWVfbWVudV9idXR0b24nLFxuICAgICF1dGlscy5oYXNOZXR3b3JrKCkgPyAnaW52aXNpYmxlJyA6ICcnXG4gIF0uam9pbignICcpO1xuXG4gIGNvbnN0IGxvbmdBY3Rpb24gPSAoKSA9PiB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ25iR2FtZXNJblBsYXknLCBzZXNzaW9uLm5vd1BsYXlpbmcoKS5sZW5ndGgpLCAnc2hvcnQnLCAndG9wJyk7XG5cbiAgcmV0dXJuIChcbiAgICAgIDxidXR0b24ga2V5PXtrZXl9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBjb25maWc9e2hlbHBlci5vbnRvdWNoKGFjdGlvbiwgbG9uZ0FjdGlvbil9PlxuICAgIDwvYnV0dG9uPlxuICApO1xufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gaGVhZGVyQnRucygpIHtcbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IGtleT1cImJ1dHRvbnNcIiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4vLyAgICAgICB7Z2FtZXNCdXR0b24oKX1cbi8vICAgICA8L2Rpdj5cbi8vICAgKTtcbi8vIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGhlYWRlcih0aXRsZSwgbGVmdEJ1dHRvbikge1xuICByZXR1cm4gKFxuICAgIDxuYXY+XG4gICAgICB7bGVmdEJ1dHRvbiA/IGxlZnRCdXR0b24gOiBtZW51QnV0dG9uKCl9XG4gICAgICB7dGl0bGUgPyA8aDEga2V5PVwidGl0bGVcIj57dGl0bGV9PC9oMT4gOiBudWxsIH1cbiAgICAgIHtoZWFkZXJCdG5zKCl9XG4gICAgPC9uYXY+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2aWV3T25seUJvYXJkQ29udGVudCgpIHtcbiAgY29uc3QgaXNQb3J0cmFpdCA9IGZhbHNlO1xuICBjb25zdCB7IHZ3LCB2aCB9ID0geyB2dzogMTAsIHZoOiAxMCB9XG4gIGNvbnN0IGJvYXJkU3R5bGUgPSBpc1BvcnRyYWl0ID8geyB3aWR0aDogdncgKyAncHgnLCBoZWlnaHQ6IHZ3ICsgJ3B4JyB9IDoge307XG4gIGNvbnN0IGJvYXJkS2V5ID0gJ3ZpZXdvbmx5Ym9hcmQnXG4gIGNvbnN0IGNsYXNzTmFtZSA9ICdib2FyZF93cmFwcGVyJ1xuICBjb25zdCBib2FyZCA9IChcbiAgICA8c2VjdGlvbiBrZXk9e2JvYXJkS2V5fSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gc3R5bGU9e2JvYXJkU3R5bGV9PlxuICAgICAge20uY29tcG9uZW50KFZpZXdPbmx5Qm9hcmQpfVxuICAgIDwvc2VjdGlvbj5cbiAgKTtcbiAgcmV0dXJuIFtcbiAgICBib2FyZFxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZXJTdGF0dXModXNlcikge1xuICBjb25zdCBzdGF0dXMgPSB1c2VyLm9ubGluZSA/ICdvbmxpbmUnIDogJ29mZmxpbmUnO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidXNlclwiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPXsndXNlclN0YXR1cyAnICsgc3RhdHVzfSBkYXRhLWljb249XCJyXCIgLz5cbiAgICAgIHt1c2VyLnVzZXJuYW1lfVxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZnVuY3Rpb24gcmVuZGVyT3B0aW9uKGxhYmVsLCB2YWx1ZSwgc3RvcmVkVmFsdWUsIGxhYmVsQXJnLCBsYWJlbEFyZzIpIHtcbiAgcmV0dXJuIG0oJ29wdGlvbicsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc2VsZWN0ZWQ6IHN0b3JlZFZhbHVlID09PSB2YWx1ZVxuICB9LCBpMThuKGxhYmVsLCBsYWJlbEFyZywgbGFiZWxBcmcyKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmVuZGVyUmFkaW86IGZ1bmN0aW9uKGxhYmVsLCBuYW1lLCB2YWx1ZSwgY2hlY2tlZCwgb25jaGFuZ2UpIHtcbiAgICB2YXIgaWQgPSBuYW1lICsgJ18nICsgdmFsdWU7XG4gICAgcmV0dXJuIFtcbiAgICAgIG0oJ2lucHV0LnJhZGlvW3R5cGU9cmFkaW9dJywge1xuICAgICAgICBuYW1lLFxuICAgICAgICBpZCxcbiAgICAgICAgY2xhc3NOYW1lOiB2YWx1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIG9uY2hhbmdlXG4gICAgICB9KSxcbiAgICAgIG0oJ2xhYmVsJywge1xuICAgICAgICAnZm9yJzogaWRcbiAgICAgIH0sIGkxOG4obGFiZWwpKVxuICAgIF07XG4gIH0sXG5cbiAgcmVuZGVyU2VsZWN0OiBmdW5jdGlvbihsYWJlbCwgbmFtZSwgb3B0aW9ucywgc2V0dGluZ3NQcm9wLCBpc0Rpc2FibGVkLCBvbkNoYW5nZUNhbGxiYWNrKSB7XG4gICAgdmFyIHN0b3JlZFZhbHVlID0gc2V0dGluZ3NQcm9wKCk7XG4gICAgcmV0dXJuIFtcbiAgICAgIG0oJ2xhYmVsJywge1xuICAgICAgICAnZm9yJzogJ3NlbGVjdF8nICsgbmFtZVxuICAgICAgfSwgaTE4bihsYWJlbCkpLFxuICAgICAgbSgnc2VsZWN0Jywge1xuICAgICAgICBpZDogJ3NlbGVjdF8nICsgbmFtZSxcbiAgICAgICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgIGNvbmZpZzogZnVuY3Rpb24oZWwsIGlzVXBkYXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKCFpc1VwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIG9uQ2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICBzZXR0aW5nc1Byb3AoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICBpZiAob25DaGFuZ2VDYWxsYmFjaykgb25DaGFuZ2VDYWxsYmFjayhlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgICBjb250ZXh0Lm9udW5sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIG9wdGlvbnMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlck9wdGlvbihlWzBdLCBlWzFdLCBzdG9yZWRWYWx1ZSwgZVsyXSwgZVszXSk7XG4gICAgICB9KSlcbiAgICBdO1xuICB9LFxuICByZW5kZXJDaGVja2JveDogZnVuY3Rpb24obGFiZWwsIG5hbWUsIHNldHRpbmdzUHJvcCwgY2FsbGJhY2ssIGRpc2FibGVkKSB7XG4gICAgdmFyIGlzT24gPSBzZXR0aW5nc1Byb3AoKTtcbiAgICByZXR1cm4gbSgnZGl2LmNoZWNrX2NvbnRhaW5lcicsIHtcbiAgICAgIGNsYXNzTmFtZTogZGlzYWJsZWQgPyAnZGlzYWJsZWQnOiAnJ1xuICAgIH0sIFtcbiAgICAgIG0oJ2xhYmVsJywge1xuICAgICAgICAnZm9yJzogbmFtZVxuICAgICAgfSwgbGFiZWwpLFxuICAgICAgbSgnaW5wdXRbdHlwZT1jaGVja2JveF0nLCB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBjaGVja2VkOiBpc09uLFxuICAgICAgICBvbmNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc3QgbmV3VmFsID0gIWlzT247XG4gICAgICAgICAgc2V0dGluZ3NQcm9wKG5ld1ZhbCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF0pO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgZ2FtZUljb24gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oa2V5LCBuYW1lLCBwZXJmLCB1c2VyKSB7XG4gIHZhciBvcHRpb25zID0geyBjbGFzc05hbWU6ICdwcm9maWxlUGVyZicsICdkYXRhLWljb24nOiBnYW1lSWNvbihrZXkpIH07XG5cbiAgaWYgKHZhcmlhbnRQZXJmQXZhaWxhYmxlKGtleSwgcGVyZikpIHtcbiAgICBvcHRpb25zLmNsYXNzTmFtZSArPSAnIG5hdic7XG4gICAgb3B0aW9ucy5jb25maWcgPSBoZWxwZXIub250b3VjaFkoZ29Ub1ZhcmlhbnRQZXJmKHVzZXIsIGtleSkpO1xuICB9XG5cbiAgcmV0dXJuIG0oJ2RpdicsIG9wdGlvbnMsIFtcbiAgICBtKCdzcGFuLm5hbWUnLCBuYW1lKSxcbiAgICBtKCdkaXYucmF0aW5nJywgW1xuICAgICAgcGVyZi5yYXRpbmcsXG4gICAgICBoZWxwZXIucHJvZ3Jlc3MocGVyZi5wcm9nKSxcbiAgICAgIG0oJ3NwYW4ubmInLCAnLyAnICsgcGVyZi5nYW1lcylcbiAgICBdKVxuICBdKTtcbn1cblxuZnVuY3Rpb24gZ29Ub1ZhcmlhbnRQZXJmKHVzZXIsIGtleSkge1xuICByZXR1cm4gKCkgPT4gbS5yb3V0ZSgnL0AvJHt1c2VyLmlkfS8ke2tleX0vcGVyZicpO1xufVxuXG5mdW5jdGlvbiB2YXJpYW50UGVyZkF2YWlsYWJsZShrZXksIHBlcmYpIHtcbiAgcmV0dXJuIHBlcmYuZ2FtZXMgPiAwO1xufVxuIiwiaW1wb3J0IGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuXG5mdW5jdGlvbiBzdHlsZUNvbmYoZWwpIHtcbiAgY29uc3QgdmggPSBoZWxwZXIudmlld3BvcnREaW0oKS52aDtcbiAgY29uc3QgaCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgY29uc3QgdG9wID0gKHZoIC0gaCkgLyAyO1xuICAvLyBlbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjbGFzc2VzLCBoZWFkZXJGLCBjb250ZW50RiwgaXNTaG93aW5nLCBjbG9zZUYpIHtcbiAgaWYgKCFpc1Nob3dpbmcpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuICAgIG92ZXJsYXlfcG9wdXA6IHRydWUsXG4gICAgbmF0aXZlX3Njcm9sbGVyOiB0cnVlXG4gIH07XG5cbiAgbGV0IGNsYXNzTmFtZTtcblxuICBpZiAodHlwZW9mIGNsYXNzZXMgPT09ICdvYmplY3QnKSB7XG4gICAgY2xhc3NOYW1lID0gaGVscGVyLmNsYXNzU2V0KE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDbGFzc2VzLCBjbGFzc2VzKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY2xhc3NOYW1lID0gaGVscGVyLmNsYXNzU2V0KGRlZmF1bHRDbGFzc2VzKSArICcgJyArIGNsYXNzZXM7XG4gIH0gZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcG9wdXAgYXJndW1lbnQgbXVzdCBiZSBlaXRoZXIgc3RyaW5nIG9yIGFuIG9iamVjdCcpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJvdmVybGF5X3BvcHVwX3dyYXBwZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9wdXBfb3ZlcmxheV9jbG9zZVwiXG4gICAgICAgICAgIGNvbmZpZz17Y2xvc2VGID8gaGVscGVyLm9udG91Y2goaGVscGVyLmZhZGVzT3V0KGNsb3NlRiwgJy5vdmVybGF5X3BvcHVwX3dyYXBwZXInKSkgOiB1dGlscy5ub29wIH0gLz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9IGNvbmZpZz17c3R5bGVDb25mfT5cbiAgICAgICAge2hlYWRlckYgPyA8aGVhZGVyPntoZWFkZXJGKCl9PC9oZWFkZXI+IDogbnVsbCB9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9wdXBfY29udGVudFwiPlxuICAgICAgICAgIHtjb250ZW50RigpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFphbmltbyBmcm9tICd6YW5pbW8nO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi8uLi9yb3V0ZXInO1xuXG5pbXBvcnQgeyBCQUNLRFJPUF9PUEFDSVRZIH0gZnJvbSAnLic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNpZGVNZW51Q3RybChzaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbnVJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcElELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uT3BlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlKSB7XG4gIHRoaXMuaXNPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5zaWRlID0gc2lkZTtcbiAgdGhpcy5tZW51SUQgPSBtZW51SUQ7XG4gIHRoaXMuYmFja2Ryb3BJRCA9IGJhY2tkcm9wSUQ7XG4gIHRoaXMub25PcGVuID0gb25PcGVuO1xuICB0aGlzLm9uQ2xvc2UgPSBvbkNsb3NlO1xuXG5cbiAgdGhpcy5vcGVuID0gKCkgPT4ge1xuICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wdXNoKHRoaXMuY2xvc2UpO1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tZW51SUQpO1xuICAgIGNvbnN0IGJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5iYWNrZHJvcElEKTtcbiAgICBpZiAodGhpcy5vbk9wZW4pIHRoaXMub25PcGVuKCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgIFphbmltbyhiZCwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScsIDApLFxuICAgICAgWmFuaW1vKGJkLCAnb3BhY2l0eScsIEJBQ0tEUk9QX09QQUNJVFksIDI1MCwgJ2xpbmVhcicpLFxuICAgICAgWmFuaW1vKGVsLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJywgMCksXG4gICAgICBaYW5pbW8oXG4gICAgICAgIGVsLFxuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgJ3RyYW5zbGF0ZTNkKDAsMCwwKScsIDI1MCwgJ2Vhc2Utb3V0J1xuICAgICAgKVxuICAgICAgXG4gICAgXSkudGhlbihyZWRyYXcpXG4gICAgICAuY2F0Y2goY29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7XG4gIH07XG5cbiAgdGhpcy5jbG9zZSA9IChmcm9tQkIpID0+IHtcbiAgICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgdGhpcy5pc09wZW4pIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm1lbnVJRCk7XG4gICAgY29uc3QgYmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmJhY2tkcm9wSUQpO1xuICAgIGlmICh0aGlzLm9uQ2xvc2UpIHRoaXMub25DbG9zZSgpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBaYW5pbW8oYmQsICdvcGFjaXR5JywgMCwgMjUwLCAnbGluZWFyJyksXG4gICAgICBaYW5pbW8oXG4gICAgICAgIGVsLFxuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgdGhpcy5jbG9zZVRyYW5zbGF0ZSgpLCAyNTAsICdlYXNlLW91dCcpXG4gICAgXSkudGhlbigoKSA9PiB7XG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIFphbmltbyhlbCwgJ3Zpc2liaWxpdHknLCAnaGlkZGVuJywgMCksXG4gICAgICAgIFphbmltbyhiZCwgJ3Zpc2liaWxpdHknLCAnaGlkZGVuJywgMCksXG4gICAgICBdKTtcbiAgICB9KS5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTtcbiAgfTtcblxuICB0aGlzLnRvZ2dsZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5pc09wZW4pIHRoaXMuY2xvc2UoKTtcbiAgICBlbHNlIHRoaXMub3BlbigpO1xuICB9O1xuICBcbiAgdGhpcy5jbG9zZVRyYW5zbGF0ZSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5zaWRlID09PSAnbGVmdCcgPyAndHJhbnNsYXRlM2QoLTEwMCUsMCwwKSc6J3RyYW5zbGF0ZTNkKDEwMCUsMCwwKSc7XG4gIH07XG5cbn07XG4iLCJleHBvcnQgY29uc3QgQkFDS0RST1BfT1BBQ0lUWSA9IDAuNztcbiIsImltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2aWV3KF8sIGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBidXR0b25zLFxuICAgICAgc2VsZWN0ZWRUYWIsXG4gICAgICBvblRhYkNoYW5nZVxuICAgIH0gPSBhcmdzO1xuXG4gICAgY29uc3QgaVdpZHRoID0gMTAwIC8gYnV0dG9ucy5sZW5ndGg7XG4gICAgY29uc3QgaW5kZXggPSBidXR0b25zLmZpbmRJbmRleChlID0+IGUua2V5ID09PSBzZWxlY3RlZFRhYik7XG4gICAgY29uc3Qgc2hpZnQgPSBpbmRleCAqIChpV2lkdGggKiBidXR0b25zLmxlbmd0aCk7XG5cbiAgICBjb25zdCBpbmRpY2F0b3JTdHlsZSA9IHtcbiAgICAgIHdpZHRoOiBpV2lkdGggKyAnJScsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7c2hpZnR9JSlgXG4gICAgfTtcblxuICAgIGNvbnN0IGJ1dHRvblN0eWxlID0ge1xuICAgICAgd2lkdGg6IGlXaWR0aCArICclJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZW5kZXJUYWIoYikge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gW1xuICAgICAgICAndGFiJyxcbiAgICAgICAgc2VsZWN0ZWRUYWIgPT09IGIua2V5ID8gJ3NlbGVjdGVkJyA6ICcnXG4gICAgICBdLmpvaW4oJyAnKTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGhlbHBlci5vbnRvdWNoKG9uVGFiQ2hhbmdlLmJpbmQobnVsbCwgYi5rZXkpKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGNvbmZpZz17Y29uZmlnfSBzdHlsZT17YnV0dG9uU3R5bGV9PlxuICAgICAgICAgIHtiLmxhYmVsfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGFic1wiPlxuICAgICAgICB7IGJ1dHRvbnMubWFwKHJlbmRlclRhYikgfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhYkluZGljYXRvclwiIHN0eWxlPXtpbmRpY2F0b3JTdHlsZX0gLz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn07XG4iLCJpbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi9zZXNzaW9uJztcbmltcG9ydCBpMThuIGZyb20gJy4uL2kxOG4nO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgbG9naW5Nb2RhbCBmcm9tICcuL2xvZ2luTW9kYWwnO1xuaW1wb3J0IGJhY2tidXR0b24gZnJvbSAnLi4vYmFja2J1dHRvbic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuY29uc3Qgc2lnbnVwTW9kYWwgPSB7fTtcblxudmFyIGlzT3BlbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzdWJtaXQoZm9ybSkge1xuICB2YXIgbG9naW4gPSBmb3JtWzBdLnZhbHVlLnRyaW0oKTtcbiAgdmFyIGVtYWlsID0gZm9ybVsxXS52YWx1ZS50cmltKCk7XG4gIHZhciBwYXNzID0gZm9ybVsyXS52YWx1ZS50cmltKCk7XG4gIGlmICghbG9naW4gfHwgIWVtYWlsIHx8ICFwYXNzKSByZXR1cm4gZmFsc2U7XG4gIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuY2xvc2UoKTtcbiAgcmV0dXJuIHNlc3Npb24uc2lnbnVwKGxvZ2luLCBlbWFpbCwgcGFzcykudGhlbihmdW5jdGlvbigpIHtcbiAgICBzaWdudXBNb2RhbC5jbG9zZSgpO1xuICAgIGxvZ2luTW9kYWwuY2xvc2UoKTtcbiAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ2xvZ2luU3VjY2Vzc2Z1bGwnKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIHZhciBkYXRhID0gZXJyb3IucmVzcG9uc2U7XG4gICAgaWYgKGRhdGEuZXJyb3IudXNlcm5hbWUpIHtcbiAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coZGF0YS5lcnJvci51c2VybmFtZVswXSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvci5wYXNzd29yZCkge1xuICAgICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhkYXRhLmVycm9yLnBhc3N3b3JkWzBdLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4gICAgfVxuICB9KTtcbn1cblxuc2lnbnVwTW9kYWwub3BlbiA9IGZ1bmN0aW9uKCkge1xuICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24oc2lnbnVwTW9kYWwuY2xvc2UsICdzaWdudXBNb2RhbCcpKTtcbiAgaXNPcGVuID0gdHJ1ZTtcbn07XG5cbnNpZ251cE1vZGFsLmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4gIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuY2xvc2UoKTtcbiAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgaXNPcGVuID0gZmFsc2U7XG59O1xuXG5zaWdudXBNb2RhbC52aWV3ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghaXNPcGVuKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gbSgnZGl2Lm1vZGFsI3NpZ251cE1vZGFsJywgeyBjb25maWc6IGhlbHBlci5zbGlkZXNJblVwIH0sIFtcbiAgICBtKCdoZWFkZXInLCBbXG4gICAgICBtKCdidXR0b24ubW9kYWxfY2xvc2VbZGF0YS1pY29uPUxdJywge1xuICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKGhlbHBlci5zbGlkZXNPdXREb3duKHNpZ251cE1vZGFsLmNsb3NlLCAnc2lnbnVwTW9kYWwnKSlcbiAgICAgIH0pLFxuICAgICAgbSgnaDInLCBpMThuKCdzaWduVXAnKSlcbiAgICBdKSxcbiAgICBtKCdkaXYubW9kYWxfY29udGVudCcsIFtcbiAgICAgIG0oJ3Auc2lnbnVwV2FybmluZy53aXRoSWNvbltkYXRhLWljb249IV0nLCBbXG4gICAgICAgIGkxOG4oJ2NvbXB1dGVyc0FyZU5vdEFsbG93ZWRUb1BsYXknKVxuICAgICAgXSksXG4gICAgICBtKCdwLnRvc1dhcm5pbmcnLCBbXG4gICAgICAgIGkxOG4oJ2J5UmVnaXN0ZXJpbmdZb3VBZ3JlZVRvQmVCb3VuZEJ5T3VyJyksXG4gICAgICAgIG0oJ2EnLCB7XG4gICAgICAgIH0sIGkxOG4oJ3Rlcm1zT2ZTZXJ2aWNlJykpLCAnLidcbiAgICAgIF0pLFxuICAgICAgbSgnZm9ybS5sb2dpbicsIHtcbiAgICAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHN1Ym1pdChlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtcbiAgICAgICAgbSgnaW5wdXQjcHNldWRvW3R5cGU9dGV4dF0nLCB7XG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4gICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsXG4gICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgICAgIHNwZWxsY2hlY2s6ICdmYWxzZScsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIG0oJ2lucHV0I2VtYWlsW3R5cGU9ZW1haWxdJywge1xuICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdlbWFpbCcpLFxuICAgICAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4gICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuICAgICAgICAgIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbiAgICAgICAgICBzcGVsbGNoZWNrOiAnZmFsc2UnLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBtKCdpbnB1dCNwYXNzd29yZFt0eXBlPXBhc3N3b3JkXScsIHtcbiAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bigncGFzc3dvcmQnKSxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgICAgbSgnYnV0dG9uLmZhdCcsIGkxOG4oJ3NpZ25VcCcpKVxuICAgICAgXSlcbiAgICBdKVxuICBdKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNpZ251cE1vZGFsO1xuIiwiaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSAnLi91c2VyQ3RybCc7XG5pbXBvcnQgdmlldyBmcm9tICcuL3VzZXJWaWV3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb250cm9sbGVyLFxuICB2aWV3XG59O1xuIiwiaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi91c2VyWGhyJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vc29ja2V0JztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250cm9sbGVyKCkge1xuICBzb2NrZXQuY3JlYXRlRGVmYXVsdCgpO1xuXG4gIGNvbnN0IHVzZXIgPSBtLnByb3AoKTtcblxuICB4aHIudXNlcihtLnJvdXRlLnBhcmFtKCdpZCcpKS50aGVuKHVzZXIsIGVycm9yID0+IHtcbiAgICB1dGlscy5oYW5kbGVYaHJFcnJvcihlcnJvcik7XG4gICAgbS5yb3V0ZSgnLycpO1xuICB9KS50aGVuKHNlc3Npb24ucmVmcmVzaCk7XG5cbiAgcmV0dXJuIHtcbiAgICB1c2VyLFxuICAgIGlzTWU6ICgpID0+IHNlc3Npb24uZ2V0VXNlcklkKCkgPT09IHVzZXIoKS5pZFxuICB9O1xufVxuIiwiLy8gaW1wb3J0IHVzZXJQZXJmcyBmcm9tICcuLi8uLi9veXVua2V5Zi9wZXJmcyc7XG5pbXBvcnQgcGVyZiBmcm9tICcuLi9zaGFyZWQvcGVyZic7XG5pbXBvcnQgeyBoZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uLy4uL3Nlc3Npb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2aWV3KGN0cmwpIHtcbiAgY29uc3QgdXNlciA9IGN0cmwudXNlcigpO1xuXG4gIGlmICghdXNlcikgcmV0dXJuIG51bGw7XG5cbiAgZnVuY3Rpb24gaGVhZGVyKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdXNlci51c2VybmFtZTtcbiAgICByZXR1cm4gaGVhZGVyV2lkZ2V0KG51bGwsIGJhY2tCdXR0b24odGl0bGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2ZpbGUoKSB7XG4gICAgLy8gVE9ET1xuICAgIC8vIHN0YXRzXG4gICAgLy8gcmF0aW5nc1xuICAgIC8vIGFjdGlvbnNcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD1cInVzZXJQcm9maWxlXCIgY2xhc3NOYW1lPVwibmF0aXZlX3Njcm9sbGVyIHBhZ2VcIj5cbiAgICAgICAge3JlbmRlclN0YXR1cyh1c2VyKX1cbiAgICAgICAge3JlbmRlclByb2ZpbGUodXNlcil9XG4gICAgICAgIHtyZW5kZXJSYXRpbmdzKHVzZXIpfVxuICAgICAgICB7cmVuZGVyQWN0aW9ucyhjdHJsKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCBwcm9maWxlKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU3RhdHVzKHVzZXIpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlci5vbmxpbmUgPyAnb25saW5lJyA6ICdvZmZsaW5lJztcbiAgcmV0dXJuIChcbiAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJvbmxpbmVTdGF0dXNcIj5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17J3VzZXJTdGF0dXMgJyArIHN0YXR1c30gZGF0YS1pY29uPSdyJyAvPlxuICAgICAge2kxOG4oc3RhdHVzKX1cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclByb2ZpbGUodXNlcikge1xuICBpZiAoIXVzZXIucHJvZmlsZSkgcmV0dXJuIG51bGw7XG4gIFxuICBsZXQgZnVsbE5hbWUgPSAnJztcbiAgaWYgKHVzZXIucHJvZmlsZS5maXJzdE5hbWUpIGZ1bGxOYW1lICs9IHVzZXIucHJvZmlsZS5maXJzdE5hbWU7XG4gIGlmICh1c2VyLnByb2ZpbGUubGFzdE5hbWUpIGZ1bGxOYW1lICs9ICh1c2VyLnByb2ZpbGUuZmlyc3ROYW1lID8gJyAnIDonJykgKyB1c2VyLnByb2ZpbGUubGFzdE5hbWU7XG4gIC8vIGNvbnN0IGNvdW50cnkgPSBjb3VudHJpZXNbdXNlci5wcm9maWxlLmNvdW50cnldO1xuICBjb25zdCBsb2NhdGlvbiA9IHVzZXIucHJvZmlsZS5sb2NhdGlvbjtcbiAgY29uc3QgbWVtYmVyU2luY2UgPSBpMThuKCdtZW1iZXJTaW5jZScpICsgJyAnICsgd2luZG93Lm1vbWVudCh1c2VyLmNyZWF0ZWRBdCkuZm9ybWF0KCdMTCcpO1xuICBjb25zdCBzZWVuQXQgPSB1c2VyLnNlZW5BdCA/IGkxOG4oJ2xhc3RMb2dpbicpICsgJyAnICsgd2luZG93Lm1vbWVudCh1c2VyLnNlZW5BdCkuY2FsZW5kYXIoKSA6IG51bGw7XG5cbiAgcmV0dXJuIChcbiAgICA8c2VjdGlvbiBjbGFzc25hbWU9XCJwcm9maWxlXCI+XG4gICAgICB7ZnVsbE5hbWUgP1xuICAgICAgIDxoMyBjbGFzc05hbWU9XCJmdWxsbmFtZVwiPntmdWxsTmFtZX08L2gzPjogbnVsbFxuICAgICAgfVxuICAgICAge3VzZXIucHJvZmlsZS5iaW8gP1xuICAgICAgIDxwIGNsYXNzTmFtZT1cInByb2ZpbGVCaW9cIj57dXNlci5wcm9maWxlLmJpb308L3A+OiBudWxsXG4gICAgICB9XG4gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1c2VySW5mb3NcIj5cbiAgICAgICAgIHtcbiAgICAgICAgICAgdXNlci5sYW5ndWFnZSA/XG4gICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImxhbmd1YWdlIHdpdGhJY29uXCI+XG4gICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtY29tbWVudC1vXCI+XG4gICAgICAgICAgICAgICB7Z2V0TGFuZ3VhZ2VOYXRpdmVOYW1lKHVzZXIubGFuZ3VhZ2UpfVxuICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgPC9wPiA6IG51bGxcbiAgICAgICAgIH1cbiAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibG9jYXRpb25cIj57bG9jYXRpb259PC9wPlxuICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtZW1iZXJTaW5jZVwiPnttZW1iZXJTaW5jZX08L3A+XG4gICAgICAgICAgIHtzZWVuQXQgP1xuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibGFzdFNlZW5cIj57c2VlbkF0fTwvcD46IG51bGxcbiAgICAgICAgICAgfVxuICAgICAgIDwvZGl2PlxuICAgIDwvc2VjdGlvbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUmF0aW5ncyh1c2VyKSB7XG4gIGZ1bmN0aW9uIGlzU2hvd2luZyhwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICd5dXpiaXInLCAnZHV6b2tleSdcbiAgICBdLmluZGV4T2YocC5rZXkpIT09IC0xIHx8IHAucGVyZi5nYW1lcyA+IDA7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxzZWN0aW9uIGlkPVwidXNlclByb2ZpbGVSYXRpbmdzXCIgY2xhc3NOYW1lPVwicGVyZnNcIj5cbiAgICAgIC8vIHt1c2VyUGVyZnModXNlcikuZmlsdGVyKGlzU2hvd2luZykubWFwKHAgPT4gcGVyZihwLmtleSwgcC5uYW1lLCBwLnBlcmYsIHVzZXIpKX1cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFjdGlvbnMoY3RybCkge1xuICBjb25zdCB1c2VyID0gY3RybC51c2VyKCk7XG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gaWQ9XCJ1c2VyUHJvZmlsZUFjdGlvbnNcIiBjbGFzcz1cIm5vUGFkZGluZ1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJsaXN0X2l0ZW1fbmF2XCJcbiAgICAgICAgICAgY29uZmlnPXtoZWxwZXIub250b3VjaFkoY3RybC5nb1RvR2FtZXMpfVxuICAgICAgICAgICBrZXk9XCJ2aWV3X2FsbF9nYW1lc1wiPlxuICAgICAgICB7aTE4bigndmlld0FsbE5iR2FtZXMnLCB1c2VyLmNvdW50LmFsbCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG4iLCJpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi4vLi4vaHR0cCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VyKGlkKSB7XG4gIHZhciB1cmwgPSAnL2FwaS91c2VyLycgKyBpZDtcbiAgcmV0dXJuIHJlcXVlc3QodXJsLCB7fSwgdHJ1ZSk7XG59XG4iLCJsZXQgZm9yZWdyb3VuZCA9IHRydWU7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZvcmVncm91bmQoKSB7XG4gIHJldHVybiBmb3JlZ3JvdW5kO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Rm9yZWdyb3VuZCgpIHtcbiAgZm9yZWdyb3VuZCA9IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRCYWNrZ3JvdW5kKCkge1xuICBmb3JlZ3JvdW5kID0gZmFsc2U7XG59XG4iLCJsZXQgY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGJhdGNoaW5nID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXRjaFJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBjYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgaWYgKCFiYXRjaGluZykge1xuICAgIGJhdGNoaW5nID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRzKSA9PiB7XG4gICAgICBjb25zdCBiYXRjaCA9IGNhbGxiYWNrcztcbiAgICAgIGJhdGNoaW5nID0gZmFsc2U7XG4gICAgICBjYWxsYmFja3MgPSBuZXcgU2V0KCk7XG4gICAgICBiYXRjaC5mb3JFYWNoKGYgPT4gZih0cykpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBjb25zdCBveXVua2V5ZlNyaSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRlbGxXb3JrZXIod29ya2VyLCB0b3BpYywgcGF5bG9hZCkge1xuICBpZiAocGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdG9waWMsIHBheWxvYWQgfSk7XG4gIH0gZWxzZSB7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdG9waWMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFza1dvcmtlcih3b3JrZXIsIG1zZywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICBmdW5jdGlvbiBsaXN0ZW4oZSkge1xuICAgICAgaWYgKGUuZGF0YS50b3BpYyA9PT0gbXNnLnRvcGljKSB7XG4gICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZS5kYXRhLnBheWxvYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZS5kYXRhLnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuKTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc05ldHdvcmsoKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLmNvbm5lY3Rpb24udHlwZSAhPT0gQ29ubmVjdGlvbi5OT05FO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlWGhyRXJyb3IoZXJyb3IpIHtcbiAgdmFyIHtyZXNwb25zZTogZGF0YSwgc3RhdHVzfSA9IGVycm9yO1xuICBpZiAoIWhhc05ldHdvcmsoKSkge1xuICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bignbm9JbnRlcm5ldENvbm5lY3Rpb24nKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuICB9IGVsc2Uge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGlmICghc3RhdHVzIHx8IHN0YXR1cyA9PT0gMCkge1xuICAgICAgbWVzc2FnZSA9ICdveXVua2V5ZklzVW5yZWFjaGFibGUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDEpIHtcbiAgICAgIG1lc3NhZ2UgPSAndW5hdXRob3JpemVkRXJyb3InO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIG1lc3NhZ2UgPSAncmVzb3VyY2VOb3RGb3VuZEVycm9yJztcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNTAzKSB7XG4gICAgICBtZXNzYWdlID0gJ295dW5rZXlmSXNVbmF2YWlsYWJsZUVycm9yJztcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA+PSA1MDApIHtcbiAgICAgIG1lc3NhZ2UgPSAnc2VydmVyRXJyb3InO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0gJ0Vycm9yLic7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGkxOG4obWVzc2FnZSk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtZXNzYWdlICs9IGAgJHtkYXRhfWA7XG4gICAgfSBlbHNlIGlmIChkYXRhLmdsb2JhbCAmJiBkYXRhLmdsb2JhbC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYCAke2RhdGEuZ2xvYmFsWzBdfWA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YS5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYCAke2RhdGEuZXJyb3J9YDtcbiAgICB9XG5cbiAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KG1lc3NhZ2UsICdzaG9ydCcsICdjZW50ZXInKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aWFsQXBwbHkoZm4sIGFyZ3MpIHtcbiAgcmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIFtudWxsXS5jb25jYXQoYXJncykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbGYoKSB7XG4gIHJldHVybiBwYXJ0aWFsQXBwbHkoYXJndW1lbnRzWzBdLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGYoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgZm4gPSBhcmd1bWVudHNbMF07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmbi5hcHBseShmbiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGxheWVyTmFtZShwbGF5ZXIsIHdpdGhSYXRpbmcpIHtcbiAgaWYgKHBsYXllci51c2VybmFtZSB8fCBwbGF5ZXIudXNlcikge1xuICAgIHZhciBuYW1lID0gcGxheWVyLnVzZXJuYW1lIHx8IHBsYXllci51c2VyLnVzZXJuYW1lO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGlmIChwbGF5ZXIuYWkpIHtcbiAgICByZXR1cm4gYWlOYW1lKHBsYXllci5haSk7XG4gIH1cblxuICBpZiAocGxheWVyLnNpZGUpIHtcbiAgICByZXR1cm4gaTE4bihwbGF5ZXIuc2lkZSk7XG4gIH1cblxuICByZXR1cm4gaTE4bignYW5vbnltb3VzJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhaU5hbWUobGV2ZWwpIHtcbiAgcmV0dXJuIGkxOG4oJ2FpQm90JywgbGV2ZWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja0hpc3RvcnkoKSB7XG4gIHNldFZpZXdTbGlkZURpcmVjdGlvbignYndkJyk7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLmFwcCAmJiB3aW5kb3cubmF2aWdhdG9yLmFwcC5iYWNrSGlzdG9yeSkge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3IuYXBwLmJhY2tIaXN0b3J5KCk7XG4gIH1cbiAgZWxzZVxuICAgIHdpbmRvdy5oaXN0b3J5LmdvKC0xKTtcbn1cblxuLy8gc2ltcGxlIHdheSB0byBkZXRlcm1pbmUgdmlld3MgYW5pbWF0aW9uIGRpcmVjdGlvblxudmFyIHZpZXdTbGlkZURpcmVjdGlvbiA9ICdmd2QnO1xuZXhwb3J0IGZ1bmN0aW9uIHNldFZpZXdTbGlkZURpcmVjdGlvbihkKSB7XG4gIHZpZXdTbGlkZURpcmVjdGlvbiA9IGQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld1NsaWRlRGlyZWN0aW9uKCkge1xuICByZXR1cm4gdmlld1NsaWRlRGlyZWN0aW9uO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb2FyZEJvdW5kcyh2aWV3cG9ydERpbSwgaXNQb3J0cmFpdCwgaXNJcGFkTGlrZSwgbW9kZSkge1xuICBjb25zdCB7IHZoLCB2dyB9ID0gdmlld3BvcnREaW07XG4gIGNvbnN0IHRvcCA9IDUwO1xuXG4gIGlmIChpc1BvcnRyYWl0KSB7XG4gICAgLy8gY29uc3QgY29udGVudEhlaWdodCA9IHZoIC0gNTA7XG4gICAgLy8gY29uc3QgcFRvcCA9IDUwICsgKG1vZGUgPT09ICdnYW1lJyA/ICgoY29udGVudEhlaWdodCAtIHZ3IC0gNDApIC8gMikgOiAwKTtcbiAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gdmg7XG4gICAgY29uc3QgcFRvcCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcFRvcCxcbiAgICAgIHJpZ2h0OiB2dyxcbiAgICAgIGJvdHRvbTogcFRvcCArIHZ3LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiB2dyxcbiAgICAgIGhlaWdodDogdndcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGNvbnN0IGxTaWRlID0gdmggLSB0b3A7XG4gICAgY29uc3QgbFNpZGUgPSB2aCAtIDU7XG4gICAgY29uc3QgbFdpZHRoID0gdncgLSA1OyAvLyBsU2lkZSAqICg0LzMpO1xuICAgIGNvbnN0IHNwYWNlQ2VudGVyID0gdncgLSBsV2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0OiBsU2lkZSxcbiAgICAgIGJvdHRvbTogdG9wICsgbFNpZGUsXG4gICAgICBsZWZ0OiBzcGFjZUNlbnRlciAvIDIsXG4gICAgICB3aWR0aDogbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBsU2lkZVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF1dG9yZWRyYXcoYWN0aW9uKSB7XG4gIG0uc3RhcnRDb21wdXRhdGlvbigpO1xuICB0cnkge1xuICAgIHJldHVybiBhY3Rpb24oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBtLmVuZENvbXB1dGF0aW9uKCk7XG4gIH1cbn1cblxuY29uc3QgcGVyZkljb25zTWFwID0ge1xuICB5dXpiaXI6ICdUJyxcbiAgZHV6b2tleTogJysnXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2FtZUljb24ocGVyZikge1xuICByZXR1cm4gcGVyZkljb25zTWFwW3BlcmZdIHx8ICc4Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE1hc2FEdXJhdGlvbihyb3VuZHMsIHNjb3Jlcykge1xuICByZXR1cm4gcm91bmRzID8gcm91bmRzICsgaTE4bignaGFuZHMnKSA6IHNjb3JlcyArIGkxOG4oJ3Njb3JlcycpWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkKG51bSwgc2l6ZSkge1xuICB2YXIgcyA9IG51bSArICcnO1xuICB3aGlsZSAocy5sZW5ndGggPCBzaXplKSBzID0gJzAnICsgcztcbiAgcmV0dXJuIHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuIiwiaW1wb3J0IHNpZ25hbHMgZnJvbSAnLi4vc2lnbmFscyc7XG5pbXBvcnQgeyBiYXRjaFJlcXVlc3RBbmltYXRpb25GcmFtZSB9IGZyb20gJy4vYmF0Y2hSQUYnO1xuXG5leHBvcnQgY29uc3QgcmVkcmF3U3luYyA9IHNpZ25hbHMucmVkcmF3LmRpc3BhdGNoO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWRyYXcoKSB7XG4gIGNvbnNvbGUudHJhY2UoKTtcbiAgYmF0Y2hSZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVkcmF3U3luYyk7XG59XG4iLCJpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi9odHRwJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4vc2Vzc2lvbic7XG5cbmV4cG9ydCBsZXQgY2FjaGVkUG9vbHMgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0dhbWUoKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHNldHRpbmdzLmdhbWVTZXR1cC5odW1hbjtcblxuICBjb25zdCBkYXRhID0ge1xuICAgIHZhcmlhbnQ6IGNvbmZpZy52YXJpYW50KCksXG4gICAgcm91bmRzOiBjb25maWcucm91bmRzKCksXG4gICAgbW9kZTogc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpID8gY29uZmlnLm1vZGUoKSA6ICcwJyxcbiAgICBtZW1iZXJzT25seTogc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpID8gY29uZmlnLm1lbWJlcnNPbmx5KCkgOiBmYWxzZVxuICB9O1xuXG4gIHJldHVybiByZXF1ZXN0KCcvbWFzYS9uZXcnLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgZGF0YVxuICB9LCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYmJ5KGZlZWRiYWNrKSB7XG4gIHJldHVybiByZXF1ZXN0KCcvJywgbnVsbCwgZmVlZGJhY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtZShpZCwgYmFja2dyb3VuZCkge1xuICB2YXIgdXJsID0gJy8nICsgaWQ7XG4gIHJldHVybiByZXF1ZXN0KHVybCwgeyBiYWNrZ3JvdW5kIH0sIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2VydmVyTGFuZyhsYW5nKSB7XG4gIGlmIChzZXNzaW9uLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAvLyByZXR1cm4gcmVxdWVzdCgnL3RyYW5zbGF0aW9uL3NlbGVjdCcsIHtcbiAgICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIC8vICAgZGF0YTogeyBsYW5nIH1cbiAgICAvLyB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG4iXX0=
