(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.Okeyground=e()}}(function(){var e;return function(){function e(t,n,r){function a(o,u){if(!n[o]){if(!t[o]){var l="function"==typeof require&&require;if(!u&&l)return l(o,!0);if(i)return i(o,!0);var d=new Error("Cannot find module '"+o+"'");throw d.code="MODULE_NOT_FOUND",d}var s=n[o]={exports:{}};t[o][0].call(s.exports,function(e){var n=t[o][1][e];return a(n||e)},s,s.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)a(r[o]);return a}return e}()({1:[function(e,t,n){!function(e){function n(e,t){if("object"!==a(e))return t;for(var r in t)"object"===a(e[r])&&"object"===a(t[r])?e[r]=n(e[r],t[r]):e[r]=t[r];return e}function r(e,t,r){var o=r[0],u=r.length;(e||"object"!==a(o))&&(o={});for(var l=0;l<u;++l){var d=r[l],s=a(d);if("object"===s)for(var c in d)if("__proto__"!==c){var f=e?i.clone(d[c]):d[c];t?o[c]=n(o[c],f):o[c]=f}}return o}function a(e){return{}.toString.call(e).slice(8,-1).toLowerCase()}var i=function(e){return r(e===!0,!1,arguments)},o="merge";i.recursive=function(e){return r(e===!0,!0,arguments)},i.clone=function(e){var t,n,r=e,o=a(e);if("array"===o)for(r=[],n=e.length,t=0;t<n;++t)r[t]=i.clone(e[t]);else if("object"===o){r={};for(t in e)r[t]=i.clone(e[t])}return r},e?t.exports=i:window[o]=i}("object"==typeof t&&t&&"object"==typeof t.exports&&t.exports)},{}],2:[function(t,n,r){!function(t,r){"use strict";var a=r(t);"undefined"==typeof window&&a.deps({document:"undefined"!=typeof document?document:{},location:"undefined"!=typeof location?location:{},clearTimeout:clearTimeout,setTimeout:setTimeout}),"object"==typeof n&&null!=n&&n.exports?n.exports=a:"function"==typeof e&&e.amd?e(function(){return a}):t.m=a}("undefined"!=typeof window?window:this,function a(e,t){"use strict";function n(e){return"function"==typeof e}function r(e){return"[object Object]"===Ke.call(e)}function i(e){return"[object String]"===Ke.call(e)}function o(){}function u(e){xe=e.document,Se=e.location,Me=e.cancelAnimationFrame||e.clearTimeout,Ee=e.requestAnimationFrame||e.setTimeout}function l(e,t){for(var n,r=[],a=/(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;n=a.exec(t);)if(""===n[1]&&n[2])e.tag=n[2];else if("#"===n[1])e.attrs.id=n[2];else if("."===n[1])r.push(n[2]);else if("["===n[3].charAt(0)){var i=n[6];i&&(i=i.replace(/\\(["'])/g,"$1")),"class"===n[4]?r.push(i):e.attrs[n[4]]=i||!0}return r}function d(e,t){var n=t?e.slice(1):e;return 1===n.length&&Te(n[0])?n[0]:n}function s(e,t,n){var r="class"in t?"class":"className";for(var a in t)Ce.call(t,a)&&(a===r&&null!=t[a]&&""!==t[a]?(n.push(t[a]),e[a]=""):e[a]=t[a]);n.length&&(e[r]=n.join(" "))}function c(e,t){for(var a=[],o=1,u=arguments.length;o<u;o++)a[o-1]=arguments[o];if(e&&n(e.view))return ae(e,a);if(!i(e))throw new Error("selector in m(selector, attrs, children) should be a string");var c=null!=t&&r(t)&&!("tag"in t||"view"in t||"subtree"in t),f=c?t:{},p={tag:"div",attrs:{},children:d(a,c)};return s(p.attrs,f,l(p,e)),p}function f(e,t){for(var n=0;n<e.length&&!t(e[n],n++););}function p(e,t){f(e,function(e,n){return(e=e&&e.attrs)&&null!=e.key&&t(e,n)})}function v(e){try{if("boolean"!=typeof e&&null!=e&&null!=e.toString())return e}catch(t){}return""}function m(e,t,n,r){try{h(e,t,n),t.nodeValue=r}catch(a){}}function g(e){for(var t=0;t<e.length;t++)Te(e[t])&&(e=e.concat.apply([],e),t--);return e}function h(e,t,n){e.insertBefore(t,e.childNodes[n]||null)}function y(e,t,n,r){p(e,function(e,r){t[e=e.key]=t[e]?{action:je,index:r,from:t[e].index,element:n.nodes[t[e].index]||xe.createElement("div")}:{action:Be,index:r}});var a=[];for(var i in t)Ce.call(t,i)&&a.push(t[i]);var o=a.sort(q),u=new Array(n.length);return u.nodes=n.nodes.slice(),f(o,function(t){var a=t.index;if(t.action===De&&(V(n[a].nodes,n[a]),u.splice(a,1)),t.action===Be){var i=xe.createElement("div");i.key=e[a].attrs.key,h(r,i,a),u.splice(a,0,{attrs:{key:e[a].attrs.key},nodes:[i]}),u.nodes[a]=i}if(t.action===je){var o=t.element,l=r.childNodes[a];l!==o&&null!==o&&r.insertBefore(o,l||null),u[a]=n[t.from],u.nodes[a]=o}}),u}function w(e,t,n,r){var a=e.length!==t.length;return a||p(e,function(e,n){var r=t[n];return a=r&&r.attrs&&r.attrs.key!==e.key}),a?y(e,n,t,r):t}function b(e,t,n){f(e,function(e,r){null!=t[r]&&n.push.apply(n,t[r].nodes)}),f(t.nodes,function(e,r){null!=e.parentNode&&n.indexOf(e)<0&&V([e],[t[r]])}),e.length<t.length&&(t.length=e.length),t.nodes=n}function P(e){var t=0;p(e,function(){return f(e,function(e){(e=e&&e.attrs)&&null==e.key&&(e.key="__mithril__"+t++)}),1})}function k(e,t,n){return e.tag!==t.tag||(n.sort().join()!==Object.keys(t.attrs).sort().join()||(e.attrs.id!==t.attrs.id||(e.attrs.key!==t.attrs.key||("all"===c.redraw.strategy()?!t.configContext||t.configContext.retain!==!0:"diff"===c.redraw.strategy()&&(t.configContext&&t.configContext.retain===!1)))))}function O(e,t,r){k(e,t,r)&&(t.nodes.length&&V(t.nodes),t.configContext&&n(t.configContext.onunload)&&t.configContext.onunload(),t.controllers&&f(t.controllers,function(e){e.onunload&&e.onunload({preventDefault:o})}))}function x(e,t){return e.attrs.xmlns?e.attrs.xmlns:"svg"===e.tag?"http://www.w3.org/2000/svg":"math"===e.tag?"http://www.w3.org/1998/Math/MathML":t}function S(e,t,n){n.length&&(e.views=t,e.controllers=n,f(n,function(e){if(e.onunload&&e.onunload.$old&&(e.onunload=e.onunload.$old),Re&&e.onunload){var t=e.onunload;e.onunload=function(){},e.onunload.$old=t}}))}function E(e,t,r,a,i){if(n(t.attrs.config)){var o=i.configContext=i.configContext||{};e.push(function(){return t.attrs.config.call(t,r,!a,o,i)})}}function M(e,n,r,a,i,o,u,l){var d=e.nodes[0];return a&&J(d,n.tag,n.attrs,e.attrs,i),e.children=U(d,n.tag,t,t,n.children,e.children,!1,0,n.attrs.contenteditable?d:r,i,u),e.nodes.intact=!0,l.length&&(e.views=o,e.controllers=l),d}function C(e,t,n){var r;e.$trusted?r=ee(t,n,e):(r=[xe.createTextNode(e)],t.nodeName in Ae||h(t,r[0],n));var a;return a="string"==typeof e||"number"==typeof e||"boolean"==typeof e?new e.constructor(e):e,a.nodes=r,a}function K(e,t,n,r,a,i){var o=t.nodes;return r&&r===xe.activeElement&&e===t||(e.$trusted?(V(o,t),o=ee(n,a,e)):"textarea"===i?n.value=e:r?(r.innerHTML=e,o=[].slice.call(r.childNodes)):((1===o[0].nodeType||o.length>1||o[0].nodeValue.trim&&!o[0].nodeValue.trim())&&(V(t.nodes,t),o=[xe.createTextNode(e)]),m(n,o[0],a,e))),t=new e.constructor(e),t.nodes=o,t.$trusted=e.$trusted,t}function T(e,t,n,r,a,i,o){return e.nodes.length?e.valueOf()!==t.valueOf()||a?K(t,e,r,i,n,o):(e.nodes.intact=!0,e):C(t,r,n)}function A(e){return e.$trusted?e.nodes.length:Te(e)?e.length:1}function D(e,n,r,a,i,o,u,l,d){e=g(e);var s=[],c=n.length===e.length,f=0,v={},m=!1;p(n,function(e,t){m=!0,v[n[t].attrs.key]={action:De,index:t}}),P(e),m&&(n=w(e,n,v,r));for(var h=0,y=0,k=e.length;y<k;y++){var O=U(r,i,n,a,e[y],n[h],o,a+f||f,u,l,d);O!==t&&(c=c&&O.nodes.intact,f+=A(O),n[h++]=O)}return c||b(e,n,s),n}function B(e,t,n,r,a){if(null!=t){if(Ke.call(t)===Ke.call(e))return t;if(a&&a.nodes){var i=n-r,o=i+(Te(e)?e:t.nodes).length;V(a.nodes.slice(i,o),a.slice(i,o))}else t.nodes&&V(t.nodes,t)}return t=new e.constructor,t.tag&&(t={}),t.nodes=[],t}function j(e,t){return e.attrs.is?null==t?xe.createElement(e.tag,e.attrs.is):xe.createElementNS(t,e.tag,e.attrs.is):null==t?xe.createElement(e.tag):xe.createElementNS(t,e.tag)}function R(e,t,n,r){return r?J(t,e.tag,e.attrs,{},n):e.attrs}function L(e,n,r,a,i,o){return null!=e.children&&e.children.length>0?U(n,e.tag,t,t,e.children,r.children,!0,0,e.attrs.contenteditable?n:a,i,o):e.children}function G(e,t,n,r,a,i,o){var u={tag:e.tag,attrs:t,children:n,nodes:[r]};return S(u,i,o),u.children&&!u.children.nodes&&(u.children.nodes=[]),u}function F(e,t,r,a){var i;return i="diff"===c.redraw.strategy()&&e?e.indexOf(t):-1,i>-1?r[i]:n(a)?new a:{}}function N(e,t,n,r){null!=r.onunload&&Ge.map(function(e){return e.handler}).indexOf(r.onunload)<0&&Ge.push({controller:r,handler:r.onunload}),e.push(n),t.push(r)}function _(e,t,n,r,a,i){var o=F(n.views,t,r,e.controller),u=e&&e.attrs&&e.attrs.key;return e=0===Re||Fe||r&&r.indexOf(o)>-1?e.view(o):{tag:"placeholder"},"retain"===e.subtree?e:(e.attrs=e.attrs||{},e.attrs.key=u,N(i,a,t,o),e)}function I(e,t,n,r){for(var a=t&&t.controllers;null!=e.view;)e=_(e,e.view.$original||e.view,t,a,r,n);return e}function H(e,t,n,r,a,o,u,l){var d=[],s=[];if(e=I(e,t,d,s),"retain"===e.subtree)return t;if(!e.tag&&s.length)throw new Error("Component template must return a virtual element, not an array, string, etc.");e.attrs=e.attrs||{},t.attrs=t.attrs||{};var c=Object.keys(e.attrs),f=c.length>("key"in e.attrs?1:0);if(O(e,t,c),i(e.tag)){var p=0===t.nodes.length;u=x(e,u);var v;if(p){v=j(e,u);var m=R(e,v,u,f);h(r,v,a);var g=L(e,v,t,n,u,l);t=G(e,m,g,v,u,d,s)}else v=M(t,e,n,f,u,d,l,s);return"select"===e.tag&&"value"in e.attrs&&J(v,e.tag,{value:e.attrs.value},{},u),p||o!==!0||null==v||h(r,v,a),E(l,e,v,p,t),t}}function U(e,t,a,i,o,u,l,d,s,c,f){return o=v(o),"retain"===o.subtree?u:(u=B(o,u,d,i,a),Te(o)?D(o,u,e,d,t,l,s,c,f):null!=o&&r(o)?H(o,u,s,e,d,l,c,f):n(o)?u:T(u,o,d,e,l,s,t))}function q(e,t){return e.action-t.action||e.index-t.index}function X(e,t,n){n===t&&(e.style="",n={});for(var r in t)Ce.call(t,r)&&(null!=n&&n[r]===t[r]||(e.style[r]=t[r]));for(r in n)Ce.call(n,r)&&(Ce.call(t,r)||(e.style[r]=""))}function z(e,t,a,i,o,u){if("config"===t||"key"===t)return!0;if(n(a)&&"on"===t.slice(0,2))e[t]=te(a,e);else if("style"===t&&null!=a&&r(a))X(e,a,i);else if(null!=u)"href"===t?e.setAttributeNS("http://www.w3.org/1999/xlink","href",a):e.setAttribute("className"===t?"class":t,a);else if(t in e&&!Ne[t])try{("input"!==o&&!e.isContentEditable||e[t]!=a)&&(e[t]=a)}catch(l){e.setAttribute(t,a)}else try{e.setAttribute(t,a)}catch(l){}}function $(e,t,n,r,a,i,o){if(t in a&&r===n&&"object"!=typeof n&&xe.activeElement!==e)"value"===t&&"input"===i&&e.value!=n&&(e.value=n);else{a[t]=n;try{return z(e,t,n,r,i,o)}catch(u){if(u.message.indexOf("Invalid argument")<0)throw u}}}function J(e,t,n,r,a){for(var i in n)!Ce.call(n,i)||!$(e,i,n[i],r[i],r,t,a);return r}function V(e,t){for(var n=e.length-1;n>-1;n--)if(e[n]&&e[n].parentNode){try{e[n].parentNode.removeChild(e[n])}catch(r){}t=[].concat(t),t[n]&&Y(t[n])}e.length&&(e.length=0)}function Y(e){e.configContext&&n(e.configContext.onunload)&&(e.configContext.onunload(),e.configContext.onunload=null),e.controllers&&f(e.controllers,function(e){n(e.onunload)&&e.onunload({preventDefault:o})}),e.children&&(Te(e.children)?f(e.children,Y):e.children.tag&&Y(e.children))}function Q(e,t){try{e.appendChild(xe.createRange().createContextualFragment(t))}catch(n){e.insertAdjacentHTML("beforeend",t),W(e)}}function W(e){if("SCRIPT"===e.tagName)e.parentNode.replaceChild(Z(e),e);else{var t=e.childNodes;if(t&&t.length)for(var n=0;n<t.length;n++)W(t[n])}return e}function Z(e){for(var t=document.createElement("script"),n=e.attributes,r=0;r<n.length;r++)t.setAttribute(n[r].name,n[r].value);return t.text=e.innerHTML,t}function ee(e,t,n){var r=e.childNodes[t];if(r){var a=1!==r.nodeType,i=xe.createElement("span");a?(e.insertBefore(i,r||null),i.insertAdjacentHTML("beforebegin",n),e.removeChild(i)):r.insertAdjacentHTML("beforebegin",n)}else Q(e,n);for(var o=[];e.childNodes[t]!==r;)o.push(e.childNodes[t]),t++;return o}function te(e,t){return function(n){n=n||event,c.redraw.strategy("diff"),c.startComputation();try{return e.call(t,n)}finally{le()}}}function ne(e){var t=Ie.indexOf(e);return t<0?Ie.push(e)-1:t}function re(e){function t(){return arguments.length&&(e=arguments[0]),e}return t.toJSON=function(){return e&&n(e.toJSON)?e.toJSON():e},t}function ae(e,t){function n(){return(e.controller||o).apply(this,t)||this}function r(n){for(var r=[n].concat(t),a=1;a<arguments.length;a++)r.push(arguments[a]);return e.view.apply(e,r)}e.controller&&(n.prototype=e.controller.prototype),r.$original=e.view;var a={controller:n,view:r};return t[0]&&null!=t[0].key&&(a.attrs={key:t[0].key}),a}function ie(e,t,n,r){if(!r){c.redraw.strategy("all"),c.startComputation(),qe[n]=t;var a;a=Ue=e?e:e={controller:o};var i=new(e.controller||o);return a===Ue&&(ze[n]=i,Xe[n]=e),le(),null===e&&oe(t,n),ze[n]}null==e&&oe(t,n),Ze&&(We=Ze)}function oe(e,t){qe.splice(t,1),ze.splice(t,1),Xe.splice(t,1),me(e),Ie.splice(ne(e),1),Ge=[]}function ue(){Ve&&(Ve(),Ve=null),f(qe,function(e,t){var n=Xe[t];if(ze[t]){var r=[ze[t]];c.render(e,n.view?n.view(ze[t],r):"")}}),Ye&&(Ye(),Ye=null),$e=null,Je=new Date,c.redraw.strategy("diff")}function le(){"none"===c.redraw.strategy()?(Re--,c.redraw.strategy("diff")):c.endComputation()}function de(e){return e.slice(nt[c.route.mode].length)}function se(e,t,n){tt={};var r=n.indexOf("?");r!==-1&&(tt=ve(n.substr(r+1,n.length)),n=n.substr(0,r));var a=Object.keys(t),i=a.indexOf(n);if(i!==-1)return c.mount(e,t[a[i]]),!0;for(var o in t)if(Ce.call(t,o)){if(o===n)return c.mount(e,t[o]),!0;var u=new RegExp("^"+o.replace(/:[^\/]+?\.{3}/g,"(.*?)").replace(/:[^\/]+/g,"([^\\/]+)")+"/?$");if(u.test(n))return n.replace(u,function(){var n=o.match(/:[^\/]+/g)||[],r=[].slice.call(arguments,1,-2);f(n,function(e,t){tt[e.replace(/:|\./g,"")]=decodeURIComponent(r[t])}),c.mount(e,t[o])}),!0}}function ce(e){if(e=e||event,!(e.ctrlKey||e.metaKey||e.shiftKey||2===e.which)){e.preventDefault?e.preventDefault():e.returnValue=!1;var t,n=e.currentTarget||e.srcElement;for(t="pathname"===c.route.mode&&n.search?ve(n.search.slice(1)):{};n&&!/a/i.test(n.nodeName);)n=n.parentNode;Re=0,c.route(n[c.route.mode].slice(nt[c.route.mode].length),t)}}function fe(){"hash"!==c.route.mode&&Se.hash?Se.hash=Se.hash:e.scrollTo(0,0)}function pe(e,n){var a={},i=[];for(var o in e)if(Ce.call(e,o)){var u=n?n+"["+o+"]":o,l=e[o];if(null===l)i.push(encodeURIComponent(u));else if(r(l))i.push(pe(l,u));else if(Te(l)){var d=[];a[u]=a[u]||{},f(l,function(e){a[u][e]||(a[u][e]=!0,d.push(encodeURIComponent(u)+"="+encodeURIComponent(e)))}),i.push(d.join("&"))}else l!==t&&i.push(encodeURIComponent(u)+"="+encodeURIComponent(l))}return i.join("&")}function ve(e){if(""===e||null==e)return{};"?"===e.charAt(0)&&(e=e.slice(1));var t=e.split("&"),n={};return f(t,function(e){var t=e.split("="),r=decodeURIComponent(t[0]),a=2===t.length?decodeURIComponent(t[1]):null;null!=n[r]?(Te(n[r])||(n[r]=[n[r]]),n[r].push(a)):n[r]=a}),n}function me(e){var n=ne(e);V(e.childNodes,He[n]),He[n]=t}function ge(e,t){var n=c.prop(t);return e.then(n),n.then=function(n,r){return ge(e.then(n,r),t)},n["catch"]=n.then.bind(null,null),n}function he(e,t){function a(e){l=e||lt,s.map(function(e){l===ut?e.resolve(d):e.reject(d)})}function i(e,t,a,i){if((null!=d&&r(d)||n(d))&&n(e))try{var o=0;e.call(d,function(e){o++||(d=e,t())},function(e){o++||(d=e,a())})}catch(u){c.deferred.onerror(u),d=u,a()}else i()}function o(){var r;try{r=d&&d.then}catch(s){return c.deferred.onerror(s),d=s,l=ot,o()}l===ot&&c.deferred.onerror(d),i(r,function(){l=it,o()},function(){l=ot,o()},function(){try{l===it&&n(e)?d=e(d):l===ot&&n(t)&&(d=t(d),l=it)}catch(o){return c.deferred.onerror(o),d=o,a()}d===u?(d=TypeError(),a()):i(r,function(){a(ut)},a,function(){a(l===it&&ut)})})}var u=this,l=0,d=0,s=[];u.promise={},u.resolve=function(e){return l||(d=e,l=it,o()),u},u.reject=function(e){return l||(d=e,l=ot,o()),u},u.promise.then=function(e,t){var n=new he(e,t);return l===ut?n.resolve(d):l===lt?n.reject(d):s.push(n),n.promise}}function ye(e){return e}function we(n){var r=n.callbackName||"mithril_callback_"+(new Date).getTime()+"_"+Math.round(1e16*Math.random()).toString(36),a=xe.createElement("script");e[r]=function(i){a.parentNode.removeChild(a),n.onload({type:"load",target:{responseText:i}}),e[r]=t},a.onerror=function(){return a.parentNode.removeChild(a),n.onerror({type:"error",target:{status:500,responseText:JSON.stringify({error:"Error making jsonp request"})}}),e[r]=t,!1},a.onload=function(){return!1},a.src=n.url+(n.url.indexOf("?")>0?"&":"?")+(n.callbackKey?n.callbackKey:"callback")+"="+r+"&"+pe(n.data||{}),xe.body.appendChild(a)}function be(t){var a=new e.XMLHttpRequest;if(a.open(t.method,t.url,!0,t.user,t.password),a.onreadystatechange=function(){4===a.readyState&&(a.status>=200&&a.status<300?t.onload({type:"load",target:a}):t.onerror({type:"error",target:a}))},t.serialize===JSON.stringify&&t.data&&"GET"!==t.method&&a.setRequestHeader("Content-Type","application/json; charset=utf-8"),t.deserialize===JSON.parse&&a.setRequestHeader("Accept","application/json, text/*"),r(t.headers))for(var o in t.headers)Ce.call(t.headers,o)&&a.setRequestHeader(o,t.headers[o]);if(n(t.config)){var u=t.config(a,t);null!=u&&(a=u)}var l="GET"!==t.method&&t.data?t.data:"";if(l&&!i(l)&&l.constructor!==e.FormData)throw new Error("Request data should be either be a string or FormData. Check the `serialize` option in `m.request`");return a.send(l),a}function Pe(e){return e.dataType&&"jsonp"===e.dataType.toLowerCase()?we(e):be(e)}function ke(e,t,n){if("GET"===e.method&&"jsonp"!==e.dataType){var r=e.url.indexOf("?")<0?"?":"&",a=pe(t);e.url+=a?r+a:""}else e.data=n(t)}function Oe(e,t){return t&&(e=e.replace(/:[a-z]\w+/gi,function(e){var n=e.slice(1),r=t[n]||e;return delete t[n],r})),e}c.version=function(){return"v0.2.8"};var xe,Se,Ee,Me,Ce={}.hasOwnProperty,Ke={}.toString,Te=Array.isArray||function(e){return"[object Array]"===Ke.call(e)},Ae={AREA:1,BASE:1,BR:1,COL:1,COMMAND:1,EMBED:1,HR:1,IMG:1,INPUT:1,KEYGEN:1,LINK:1,META:1,PARAM:1,SOURCE:1,TRACK:1,WBR:1};c.deps=function(t){return u(e=t||window),e},c.deps.factory=c.factory=a,c.deps(e);var De=1,Be=2,je=3,Re=0;c.startComputation=function(){Re++},c.endComputation=function(){Re>1?Re--:(Re=0,c.redraw())};var Le,Ge=[],Fe=!1,Ne={list:1,style:1,form:1,type:1,width:1,height:1},_e={appendChild:function(e){Le===t&&(Le=xe.createElement("html")),xe.documentElement&&xe.documentElement!==e?xe.replaceChild(e,xe.documentElement):xe.appendChild(e),this.childNodes=xe.childNodes},insertBefore:function(e){this.appendChild(e)},childNodes:[]},Ie=[],He={};c.render=function(e,n,r){if(!e)throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");var a,i=[],o=ne(e),u=e===xe;a=u||e===xe.documentElement?_e:e,u&&"html"!==n.tag&&(n={tag:"html",attrs:{},children:n}),He[o]===t&&V(a.childNodes),r===!0&&me(e),He[o]=U(a,null,t,t,n,He[o],!1,0,null,t,i),f(i,function(e){e()})},c.trust=function(e){return e=new String(e),e.$trusted=!0,e},c.prop=function(e){return(null!=e&&(r(e)||n(e))||"undefined"!=typeof Promise&&e instanceof Promise)&&n(e.then)?ge(e):re(e)};var Ue,qe=[],Xe=[],ze=[],$e=null,Je=0,Ve=null,Ye=null,Qe=16;c.component=function(e){for(var t=new Array(arguments.length-1),n=1;n<arguments.length;n++)t[n-1]=arguments[n];return ae(e,t)};var We,Ze;c.mount=c.module=function(e,t){if(!e)throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");var r=qe.indexOf(e);r<0&&(r=qe.length);var a=!1,i={preventDefault:function(){a=!0,Ve=Ye=null}};return f(Ge,function(e){e.handler.call(e.controller,i),e.controller.onunload=null}),a?f(Ge,function(e){e.controller.onunload=e.handler}):Ge=[],ze[r]&&n(ze[r].onunload)&&ze[r].onunload(i),ie(t,e,r,a)};var et=!1;c.redraw=function(t){if(!et){et=!0,t&&(Fe=!0);try{$e&&!t?(Ee===e.requestAnimationFrame||new Date-Je>Qe)&&($e>0&&Me($e),$e=Ee(ue,Qe)):(ue(),$e=Ee(function(){$e=null},Qe))}finally{et=Fe=!1}}},c.redraw.strategy=c.prop(),c.withAttr=function(e,t,n){return function(r){r=r||window.event;var a=r.currentTarget||this,i=n||this,o=e in a?a[e]:a.getAttribute(e);t.call(i,o)}};var tt,nt={pathname:"",hash:"#",search:"?"},rt=o,at=!1;c.route=function(t,n,r,a){if(0===arguments.length)return We;if(3===arguments.length&&i(n)){rt=function(e){var a=We=de(e);if(!se(t,r,a)){if(at)throw new Error("Ensure the default route matches one of the routes defined in m.route");at=!0,c.route(n,!0),at=!1}};var o="hash"===c.route.mode?"onhashchange":"onpopstate";return e[o]=function(){var e=Se[c.route.mode];"pathname"===c.route.mode&&(e+=Se.search),We!==de(e)&&rt(e)},Ve=fe,void e[o]()}if(t.addEventListener||t.attachEvent){var u="pathname"!==c.route.mode?Se.pathname:"";return t.href=u+nt[c.route.mode]+a.attrs.href,void(t.addEventListener?(t.removeEventListener("click",ce),t.addEventListener("click",ce)):(t.detachEvent("onclick",ce),t.attachEvent("onclick",ce)))}if(i(t)){Ze=We,We=t;var l,d=n||{},s=We.indexOf("?");l=s>-1?ve(We.slice(s+1)):{};for(var f in d)Ce.call(d,f)&&(l[f]=d[f]);var p,v=pe(l);p=s>-1?We.slice(0,s):We,v&&(We=p+(p.indexOf("?")===-1?"?":"&")+v);var m=(3===arguments.length?r:n)===!0||Ze===We;if(e.history.pushState){var g=m?"replaceState":"pushState";Ve=fe,Ye=function(){try{e.history[g](null,xe.title,nt[c.route.mode]+We)}catch(t){Se[c.route.mode]=We}},rt(nt[c.route.mode]+We)}else Se[c.route.mode]=We,rt(nt[c.route.mode]+We);Ze=null}},c.route.param=function(e){if(!tt)throw new Error("You must call m.route(element, defaultRoute, routes) before calling m.route.param()");return e?tt[e]:tt},c.route.mode="search",c.route.buildQueryString=pe,c.route.parseQueryString=ve,c.deferred=function(){var e=new he;return e.promise=ge(e.promise),e};var it=1,ot=2,ut=3,lt=4;return c.deferred.onerror=function(e){if("[object Error]"===Ke.call(e)&&!/ Error/.test(e.constructor.toString()))throw Re=0,e},c.sync=function(e){function t(e,t){return function(o){return a[e]=o,t||(i="reject"),0===--r&&(n.promise(a),n[i](a)),o}}var n=c.deferred(),r=e.length,a=[],i="resolve";return e.length>0?f(e,function(e,n){e.then(t(n,!0),t(n,!1))}):n.resolve([]),n.promise},c.request=function(e){e.background!==!0&&c.startComputation();var t,n,r,a=new he,i=e.dataType&&"jsonp"===e.dataType.toLowerCase();return i?(t=e.serialize=n=e.deserialize=ye,r=function(e){return e.responseText}):(t=e.serialize=e.serialize||JSON.stringify,n=e.deserialize=e.deserialize||JSON.parse,r=e.extract||function(e){return e.responseText.length||n!==JSON.parse?e.responseText:null}),e.method=(e.method||"GET").toUpperCase(),e.url=Oe(e.url,e.data),ke(e,e.data,t),e.onload=e.onerror=function(t){try{t=t||event;var i=n(r(t.target,e));"load"===t.type?(e.unwrapSuccess&&(i=e.unwrapSuccess(i,t.target)),Te(i)&&e.type?f(i,function(t,n){i[n]=new e.type(t)}):e.type&&(i=new e.type(i)),a.resolve(i)):(e.unwrapError&&(i=e.unwrapError(i,t.target)),a.reject(i))}catch(o){a.reject(o),c.deferred.onerror(o)}finally{e.background!==!0&&c.endComputation()}},Pe(e),a.promise=ge(a.promise,e.initialValue),a.promise},c})},{}],3:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){var n=.7*e.width,r=.7*e.height,a=p["default"].miniKey2pos(t),i=[a[0]*(n/p["default"].miniColumns),a[1]*(r/p["default"].miniRows)];return i}function i(e,t,n){var r=p["default"].key2pos(n),a=[r[0]*(e.width/p["default"].columns),r[1]*e.height*.5],i=[e.left-t.left,e.top-t.top];return[i[0]+a[0],i[1]+a[1]]}function o(e,t){return[e[0]-t[0],e[1]-t[1]]}function u(e,t){return t[0]}function l(e,t,n){return{key:e,distance:n,color:t.color,number:t.number}}function d(e,t){var n,r,d,s,c=t.animation.current,f=p["default"].findPov(t.povSide,t.turnSide),m=p["default"].vectorByPov(f),g=(t.bounds(),t.topBounds()),h=t.boardBounds(),y=h.width,w=(h.height,g.width),b=g.height,P=.0625*w,k=.14*b,O=.0625*y,x={},S=[],E={},M={},C=p["default"].discardByPov(f),K=p["default"].drawByPov(f),T=p["default"].topKey2pos(K),A=p["default"].topKey2pos(C),D=[w*m[0],b*m[1]+("up"===f?-k:"left"===f?-k/2:0)],B=[12*P,b-k],j=[P*A[0],k*A[1]],R=[P*T[0],k*T[1]],L=[1*P,1*k],G=[],F=[],N=[],_=[];for(n=0;n<p["default"].allAllowedBoardKeys.length;n++){r=p["default"].allAllowedBoardKeys[n],d=t.pieces[r],s=e.pieces[r];var I=i(h,g,r);!d&&s?G.push(l(r,s,I)):d&&!s&&F.push(l(r,d,I))}for(n=0;n<p["default"].miniAllKeys.length;n++){r=p["default"].miniAllKeys[n],d=t.opens.layout?t.opens.layout.layout[r]:null,s=e.opens.layout?e.opens.layout.layout[r]:null;var H=a(g,r);d&&!s?_.push(l(r,d,H)):!d&&s&&N.push(l(r,s,H))}var U,q,X;return"down"!==f||t.spectator?c.hint===v["default"].drawMiddle?(U=[12*P,b],q=D,X=[q[0]-U[0],q[1]-U[1]],x[p["default"].middleCount]=[X,X,!0]):c.hint===v["default"].discard?(U=[P*A[0],k*A[1]],q=D,X=[q[0]-U[0],q[1]-U[1]],x[C]=[X,X]):c.hint===v["default"].drawLeft?(U=[P*T[0],k*T[1]],q=D,X=[q[0]-U[0],q[1]-U[1]],x[v["default"].drawLeft+K]=[X,X,!0],M.piece=e.discards[K]):c.hint===v["default"].leaveTaken?(U=[P*T[0],k*T[1]],q=D,X=[q[0]-U[0],q[1]-U[1]],x[K]=[X,X]):c.hint===v["default"].openSeries?_.forEach(function(e,t){q=D,q=o(q,L),q=o(q,e.distance),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[e.key]=[X,X],E[e.key]=[1.75,1.75]}):c.hint===v["default"].collectOpen&&N.forEach(function(e,t){q=D,q=o(q,L),q=o(q,e.distance),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[e.key]=[X,X,!0],M[e.key]=e}):c.hint===v["default"].drawMiddle&&F[0]?(r=F[0].key,U=F[0].distance,U=o(U,B),q=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[r]=[X,X]):c.hint===v["default"].discard&&G[0]?(q=G[0].distance,q=o(q,j),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[C]=[X,X]):c.hint===v["default"].leaveTaken?G[0]?(q=G[0].distance,q=o(q,R),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[K]=[X,X]):(U=[P*T[0],k*T[1]],q=D,X=[q[0]-U[0],q[1]-U[1]],x[K]=[X,X]):c.hint===v["default"].openSeries&&_.forEach(function(e,t){var n=u(e,G.filter(p["default"].partial(p["default"].pieceEqual,e)));G.splice(G.indexOf(n),1),n&&(q=n.distance,q=o(n.distance,[O,0]),q=o(q,L),q=o(q,e.distance),U=[0,0],X=[q[0]-U[0],q[1]-U[1]],x[e.key]=[X,X],E[e.key]=[1.75,1.75])}),{anims:x,fadings:S,scales:E,extra:M}}function s(e,t){return Math.round(e*t)/t}function c(e){if(e.animation.current.start){var t=1-((new Date).getTime()-e.animation.current.start)/e.animation.current.duration;if(t<=0)e.animation.current={},e.render();else{var n,r=m.easeInOutCubic(t);for(var a in e.animation.current.anims)n=e.animation.current.anims[a],n[1]=[s(n[0][0]*r,10),s(n[0][1]*r,10)],n[2]&&(n[1]=[n[0][0]-n[1][0],n[0][1]-n[1][1]]);var i;for(i in e.animation.current.fadings)e.animations.current.fadings[i].opacity=s(r,100);for(i in e.animation.current.scales)n=e.animation.current.scales[i],n[0]=1+s(.7*r,10),n[1]=1+s(.7*r,10);e.render(),p["default"].requestAnimationFrame(function(){c(e)})}}}function f(e,t){var n,r={pieces:{},opens:{},middles:{},discards:{}};for(n in t.pieces)t.pieces[n]&&(r.pieces[n]={color:t.pieces[n].color,number:t.pieces[n].number});for(n in t.discards)t.discards[n]&&t.discards[n][0]&&(r.discards[n]={color:t.discards[n][0].color,number:t.discards[n][0].number});if(t.opens.layout){var a;r.opens.layout={layout:{}};for(n in t.opens.layout.layout)a=t.opens.layout.layout[n],r.opens.layout.layout[n]={color:a.color,number:a.number}}var i=e(),o=d(r,t);if(Object.keys(o.anims).length>0||o.fadings.length>0){var u=t.animation.current.start;t.animation.current={start:(new Date).getTime(),duration:t.animation.duration,anims:o.anims,fadings:o.fadings,scales:o.scales,extra:o.extra},u||c(t)}else t.renderRAF();return i}var p=r(e("./util")),v=r(e("./move")),m={easeInOutCubic:function(e){return e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1}};t.exports=function(e,t){return function(){var n=[t].concat(Array.prototype.slice.call(arguments,0));if(t.animation.enabled)return f(p["default"].partialApply(e,n),t);var r=e.apply(null,n);return t.renderRAF(),r}}},{"./move":12,"./util":17}],4:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=r(e("mithril")),i=r(e("./view")),o=r(e("./board"));t.exports=function(e){return{set:e.set,getPieceGroups:function(){return o["default"].getPieceGroups(e.data)},attach:function(t){a["default"].render(t,(0,i["default"])(e),!0)},detach:function(){},sortPairs:e.sortPairs,sortSeries:e.sortSeries,apiMove:e.apiMove,apiDrawMiddleEnd:e.apiDrawMiddleEnd,playOpenSeries:e.playOpenSeries,playOpenPairs:e.playOpenPairs,playLeaveTaken:e.playLeaveTaken,canOpenSeries:e.canOpenSeries,canOpenPairs:e.canOpenPairs,canCollectOpen:e.canCollectOpen,canLeaveTaken:e.canLeaveTaken,stop:e.stop,getPieceGroupSeries:e.getPieceGroupSeries,getPieceGroupPairs:e.getPieceGroupPairs,getFen:e.getFen}}},{"./board":5,"./view":18,mithril:2}],5:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){return l(e)||u(e,t)||o()}function o(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function u(e,t){var n=[],r=!0,a=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(r=(o=u.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(l){a=!0,i=l}finally{try{r||null==u["return"]||u["return"]()}finally{if(a)throw i}}return n}function l(e){if(Array.isArray(e))return e}function d(e){if(F(e)){var t=e.middles[ne["default"].gosterge],n=ee(e);if(n=n.filter(function(n){return ie["default"].series(n.map(function(t){return e.pieces[t]}),t)}),n.length>0){var r=Y(n.map(function(t){return t.map(function(t){return e.pieces[t]})}));return m(e,n),ue(ne["default"].partial(e.movable.events.after,re["default"].openSeries,oe(r))),e.animation.current.hint=re["default"].openSeries,!0}}return!1}function s(e){if(N(e)){var t=e.middles[ne["default"].gosterge],n=ee(e);if(n=n.filter(function(n){return ie["default"].pairs(n.map(function(t){return e.pieces[t]}),t)}),n.length>0){var r=Y(n.map(function(t){return t.map(function(t){return e.pieces[t]})}));return v(e,n),ue(ne["default"].partial(e.movable.events.after,re["default"].openPairs,oe(r))),e.animation.current.hint=re["default"].openSeries,!0}}return!1}function c(e,t){return t=ae["default"].readPiece(t).piece,!(!_(e)||!O(e,t))&&(ue(ne["default"].partial(e.movable.events.after,re["default"].leaveTaken)),e.animation.current.hint=re["default"].leaveTaken,!0)}function f(e,t){var n=ne["default"].middleCount;w(e,n),p(e,t)}function p(e,t){"string"==typeof t&&(t=ae["default"].readPiece(t).piece),e.middleHolder.piece=t,g(e)}function v(e,t){var n=t.map(function(t){return t.map(function(t){return e.pieces[t]})}),r=Y(n);ue(ne["default"].partial(e.events.move,re["default"].openPairs,oe(r))),t.forEach(function(t){return t.map(function(t){return delete e.pieces[t]})});var a=e.opens.pairs.concat(n);e.opens.pairs=a,e.opens.relayout(e)}function m(e,t){var n=t.map(function(t){return t.map(function(t){return e.pieces[t]})}),r=Y(n);ue(ne["default"].partial(e.events.move,re["default"].openSeries,oe(r))),t.forEach(function(t){return t.map(function(t){return delete e.pieces[t]})});var a=e.opens.series.concat(n);e.opens.series=a,e.opens.relayout(e)}function g(e){var t=e.middleHolder.key,n=e.middleHolder.piece;t&&n&&(e.pieces[t]=n,e.lastMove=[ne["default"].middleCount],e.middleHolder.current=!1,e.middleHolder.key=null,e.middleHolder.piece=null)}function h(e,t,n){var r=X(e,t);if(r.length>0){var a=r[0].map(function(t,a){var i=r[0].length-a-1,o=ne["default"].decBoardKey(n,2*i);return[t,o,e.pieces[t]]}),o=a.every(function(t){var n=i(t,3),r=(n[0],n[1]);n[2];return ne["default"].isAllAllowedBoardKey(r)&&[r,ne["default"].decBoardKey(r,-1)].every(function(t){return!e.pieces[t]||a.filter(function(e){var n=i(e,3),r=n[0];n[1],n[2];return r===t}).length>0})});return!!o&&(a.map(function(t){var n=i(t,3),r=n[0],a=n[1],o=n[2];return delete e.pieces[r],[r,a,o]}).map(function(t){var n=i(t,3),r=(n[0],n[1]),a=n[2];e.pieces[r]=a}),!0)}return!1}function y(e,t,n){if(t===n||!e.pieces[t])return!1;var r=e.pieces[n];return e.pieces[n]=e.pieces[t],e.pieces[t]=r,!0}function w(e,t){e.middles[ne["default"].middleCount]--,e.middleHolder.current=!0;var n=z(e);return e.middleHolder.key=n,!0}function b(e,t,n){if(!n||e.pieces[n]){var r=z(e);n=r}return ue(ne["default"].partial(e.events.move,re["default"].drawMiddleEnd)),e.middleHolder.key=n,g(e),!0}function P(e,t){return ue(ne["default"].partial(e.events.move,re["default"].drawMiddle)),e.middles[ne["default"].middleCount]--,e.middleHolder.current=!0,!0}function k(e,t,n){return!e.pieces[n]&&(ue(ne["default"].partial(e.events.move,re["default"].drawLeft)),e.pieces[n]=e.discards[ne["default"].discards[1]][0],e.discards[ne["default"].discards[1]].shift(),
!0)}function O(e,t){var n=$(e,t);if(!n)return!1;ue(ne["default"].partial(e.events.move,re["default"].leaveTaken));var r=ne["default"].findPov(e.povSide,e.turnSide);return delete e.pieces[n],e.discards[ne["default"].drawByPov(r)].unshift(t),!0}function x(e,t,n){if(n&&ne["default"].isBoardKey(t)&&ne["default"].isBoardKey(n)&&B(e,t,n)){if(h(e,t,n))return!0;if(y(e,t,n))return!0}}function S(e,t){if(ne["default"].isMiddleKey(t)&&R(e,t))return P(e,t),!0}function E(e,t,n){if(ne["default"].isMiddleKey(t)&&L(e,t))return b(e,t,n),!0}function M(e,t,n){if(n&&ne["default"].isBoardKey(n)&&ne["default"].isDrawLeftKey(t)&&G(e,t,n)&&k(e,t,n))return ue(ne["default"].partial(e.movable.events.after,re["default"].drawLeft)),!0}function C(e,t,n){n||(ne["default"].isMiddleKey(t)?S(e,t)&&T(e,t):ne["default"].isDrawLeftKey(t)&&G(e)&&T(e,t))}function K(e,t){e.selected?(t?e.selected!==t&&(x(e,e.selected,t)||M(e,e.selected,t)||E(e,e.selected,t)):E(e,e.selected,t),T(e,null)):D(e,t)&&T(e,t)}function T(e,t){if(e.selected=t,t&&ne["default"].isBoardKey(t))if(q(e,t)){var n=e.middles[ne["default"].gosterge];e.openable.dests=ie["default"].compute(e.opens,e.pieces[t],n)}else e.openable.dests=[];else e.openable.dests=[]}function A(e){return e.povSide===e.turnSide}function D(e,t){var n=e.pieces[t];return n&&e.movable.board}function B(e,t,n){return t!=n&&D(e,t)}function j(e){return A(e)}function R(e,t){return j(e)&&!e.middleHolder.current&&ne["default"].containsX(e.movable.dests,re["default"].drawMiddle)}function L(e){return e.middleHolder.current}function G(e,t,n){return j(e)&&!L(e)&&ne["default"].containsX(e.movable.dests,re["default"].drawLeft)}function F(e){return A(e)&&ne["default"].containsX(e.movable.dests,re["default"].openSeries)}function N(e){return A(e)&&ne["default"].containsX(e.movable.dests,re["default"].openPairs)}function _(e){return A(e)&&ne["default"].containsX(e.movable.dests,re["default"].leaveTaken)}function I(e){return A(e)&&ne["default"].containsX(e.movable.dests,re["default"].collectOpen)}function H(e){K(e,null)}function U(e){e.movable.side=null,e.movable.dests=[],e.openable.dests=[],e.movable.board=!1,H(e)}function q(e,t){var n=e.pieces[t];return!(!n||e.povSide!==e.turnSide)}function X(e,t){var n=e.middles[ne["default"].gosterge],r=ee(e);return r=r.filter(function(e){return e[e.length-1]===t}),r=r.filter(function(t){return ie["default"].series(t.map(function(t){return e.pieces[t]}),n)||ie["default"].pairs(t.map(function(t){return e.pieces[t]}),n)})}function z(e){var t=ne["default"].allAllowedBoardKeys.slice(1),n=ne["default"].allAllowedBoardKeys.slice(2),r=ne["default"].allAllowedBoardKeys.map(function(e,r){return[e,t[r],n[r]]}).filter(function(t){var n=i(t,3),r=n[0],a=n[1],o=n[2];return r&&a&&o&&!e.pieces[r]&&!e.pieces[a]&&!e.pieces[o]});return r[r.length-1][1]}function $(e,t){return ne["default"].allAllowedBoardKeys.filter(function(n){return e.pieces[n]&&ne["default"].pieceEqual(e.pieces[n],t)})[0]}function J(e,t,n,r){var a=V(e,t,n);if(!a)return a;var i=ne["default"].decBoardKey(a);return i!==r&&e.pieces[i]&&(a=i),ne["default"].notAllowedBoardKeys.indexOf(a)!==-1?null:a}function V(e,t,n){if(n||e.bounds){n=n||e.bounds();var r=Math.floor(ne["default"].columns*((t[0]-n.left)/n.width)),a=Math.floor(ne["default"].rows*((t[1]-n.top)/n.height));return a>=0&&a<ne["default"].rows&&r>=0&&r<ne["default"].columns?ne["default"].pos2key([r,a]):void 0}}function Y(e){return e.map(function(e){return e.map(function(e){return e.key}).join("")}).join(" ")}function Q(e){var t=e.middles[ne["default"].gosterge],n=e.withTore,r=Z(e).filter(function(e){return ie["default"].series(e,t,n)});return Y(r)}function W(e){var t=e.middles[ne["default"].gosterge],n=Z(e).filter(function(e){return ie["default"].pairs(e,t)});return Y(n)}function Z(e){return ee(e).map(function(t){return t.map(function(t){return e.pieces[t]})})}function ee(e){var t=ne["default"].pos2key([ne["default"].columns-1,0]),n=ne["default"].allKeys.slice(1),r=ne["default"].allKeys.map(function(e,t){return[e,n[t]]}).reduce(function(n,r){var a=i(n,2),o=a[0],u=a[1],l=i(r,2),d=l[0],s=l[1];return e.pieces[d]&&o.push(d),(d&&!e.pieces[d]&&s&&!e.pieces[s]||d===t)&&0!==o.length&&(u.push(o),o=[]),[o,u]},[[],[]]),a=i(r,2),o=a[0],u=a[1];return 0!==o.length&&u.push(o),u}var te,ne=r(e("./util")),re=r(e("./move")),ae=r(e("./pieces")),ie=r(e("./open")),oe=ne["default"].wrapGroup,ue=ne["default"].callUserFunction;t.exports=(te={playOpenSeries:d,playOpenPairs:s,playLeaveTaken:c,apiDrawMiddleEnd:p},a(te,"apiDrawMiddleEnd",p),a(te,"apiForceDrawMiddleEnd",f),a(te,"apiForceDrawMiddleEnd",f),a(te,"userMove",x),a(te,"userDrawLeft",M),a(te,"userBeginDrawMiddle",S),a(te,"userEndDrawMiddle",E),a(te,"selectSquare",K),a(te,"selectTop",C),a(te,"setSelected",T),a(te,"canOpenSeries",F),a(te,"canOpenPairs",N),a(te,"canLeaveTaken",_),a(te,"canCollectOpen",I),a(te,"stop",U),a(te,"cancelMove",H),a(te,"isDroppableOpens",q),a(te,"findBoardDragGroup",X),a(te,"getKeyAtDomPos",V),a(te,"getKeyAtDomPosOnPiece",J),a(te,"getPieceGroups",Z),a(te,"getPieceGroupSeries",Q),a(te,"getPieceGroupPairs",W),te)},{"./move":12,"./open":13,"./pieces":14,"./util":17}],6:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=r(e("merge")),i=r(e("./pieces"));t.exports=function(e,t){if(t)if(a["default"].recursive(e,t),e.fen){e.spectator&&(e.fen=e.povSide[0]+e.fen.slice(1)),e.animationHint?(e.animation.current.hint=e.animationHint,delete e.animationHint):e.animation.current.hint="";var n=i["default"].read(e.fen);e.pieces=n.pieces,e.discards=n.discards,e.opens=n.opens,e.middles=n.middles,delete e.fen}else e.animation.current.hint=""}},{"./pieces":14,merge:1}],7:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=r(e("./table")),i=r(e("./board")),o=r(e("./sorter")),u=r(e("./data")),l=r(e("./configure")),d=r(e("./util")),s=r(e("./anim")),c=r(e("./drag")),f=r(e("./pieces"));t.exports=function(e){var t=this;this.data=(0,u["default"])(e),this.data.flipPiece=function(e,t){var n=this;t&&!this.flippable.current.orig&&(this.flippable.current={orig:e},this.renderRAF(),setTimeout(function(){n.flippable.current.flip=!0,n.renderRAF(),setTimeout(function(){t.flip=!t.flip,n.flippable.current={},n.renderRAF()},600)},10))}.bind(this.data),this.getFen=function(){return f["default"].write(t.data.pieces)},this.getPieceGroupSeries=function(){return i["default"].getPieceGroupSeries(t.data)},this.getPieceGroupPairs=function(){return i["default"].getPieceGroupPairs(t.data)},this.set=(0,s["default"])(l["default"],this.data),this.apiMove=(0,s["default"])(a["default"].apiMove,this.data),this.apiDrawMiddleEnd=(0,s["default"])(i["default"].apiDrawMiddleEnd,this.data),this.playOpenSeries=(0,s["default"])(i["default"].playOpenSeries,this.data),this.playOpenPairs=(0,s["default"])(i["default"].playOpenPairs,this.data),this.playLeaveTaken=(0,s["default"])(i["default"].playLeaveTaken,this.data),this.sortPairs=(0,s["default"])(o["default"].sortPairs,this.data),this.sortSeries=(0,s["default"])(o["default"].sortSeries,this.data),this.canLeaveTaken=d["default"].partial(i["default"].canLeaveTaken,this.data),this.canCollectOpen=d["default"].partial(i["default"].canCollectOpen,this.data),this.canOpenSeries=d["default"].partial(i["default"].canOpenSeries,this.data),this.canOpenPairs=d["default"].partial(i["default"].canOpenPairs,this.data),this.stop=(0,s["default"])(function(e){i["default"].stop(e),c["default"].cancel(e)},this.data),this.onunload=function(){}}},{"./anim":3,"./board":5,"./configure":6,"./data":8,"./drag":9,"./pieces":14,"./sorter":15,"./table":16,"./util":17}],8:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}var a=(r(e("merge")),r(e("./pieces"))),i=r(e("./configure"));t.exports=function(e){var t={povSide:"east",turnSide:"east",lastMove:null,withTore:!1,pieces:a["default"].readBoard(a["default"].mixed),discards:a["default"].readDiscards(a["default"].initialDiscards,"east"),opens:a["default"].readOpenGroups(a["default"].initialOpenGroups),middles:a["default"].readMiddles(a["default"].initialMiddles),selected:null,middleHolder:{current:!1,key:null,piece:null},viewOnly:!1,animation:{enabled:!0,duration:500,current:{}},draggable:{enabled:!0,distance:3,current:{}},movable:{board:!0,free:!0,events:{after:function(e,t){}}},flippable:{enabled:!0,current:{}},openable:{dests:[]},events:{move:function(e,t){}}};return(0,i["default"])(t,e||{}),t}},{"./configure":6,"./pieces":14,merge:1}],9:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p["default"].rows,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:p["default"].columns;return{left:t.left+t.width*n[0]/a,top:t.top+t.height*n[1]/r,width:t.width/a,height:t.height/r}}function i(e,t){if((void 0===t.button||0===t.button)&&(t.stopPropagation(),t.preventDefault(),!e.viewOnly)){s=t.target;var n=e.selected,r=p["default"].eventPosition(t),i=e.boardBounds(),u=e.opensBounds(),l=e.topBounds(),d=c["default"].getKeyAtDomPosOnPiece(e,r,i);c["default"].selectSquare(e,d),d||(d=f["default"].getDrawKeyAtDomPos(e,r,l))&&c["default"].selectTop(e,d,n),!d&&n&&((d=f["default"].getOpensKeyAtDomPos(e,r,u))?f["default"].dropOpens(e,n,d):(d=f["default"].getDiscardKeyAtDomPos(e,r,l))&&f["default"].dropTop(e,n,d));var v=e.selected===d;if(v&&f["default"].isDraggable(e,d)){var m=p["default"].isBoardKey(d)?a(e,i,p["default"].key2pos(d)):a(e,l,p["default"].topKey2pos(d),p["default"].topRows,p["default"].topColumns),g=c["default"].findBoardDragGroup(e,d)[0];e.draggable.current={dragGroup:g,orig:d,rel:r,epos:r,pos:[0,0],dec:[r[0]-(m.left+m.width/2),r[1]-(m.top+m.height/2)],boardBounds:i,opensBounds:u,topBounds:l,started:!1}}o(e)}}function o(e){p["default"].requestAnimationFrame(function(){var t=e.draggable.current;t.orig&&(!t.started&&p["default"].distance(t.epos,t.rel)>=e.draggable.distance&&(t.started=!0),t.started&&(t.pos=[t.epos[0]-t.rel[0],t.epos[1]-t.rel[1]],t.over=c["default"].getKeyAtDomPosOnPiece(e,t.epos,t.boardBounds,t.orig),!t.over&&p["default"].isBoardKey(t.orig)&&(t.over=f["default"].getOpensKeyAtDomPos(e,t.epos,t.opensBounds)||f["default"].getDiscardKeyAtDomPos(e,t.epos,t.topBounds)))),e.render(),t.orig&&o(e)})}function u(e,t){e.draggable.current.orig&&(e.draggable.current.epos=p["default"].eventPosition(t))}function l(e,t){var n=e.draggable,r=n.current?n.current.orig:null;if(r){var a=n.current.over;n.current.started&&(c["default"].setSelected(e,null),c["default"].userMove(e,r,a)||f["default"].dropOpens(e,r,a)||f["default"].dropTop(e,r,a)||c["default"].userDrawLeft(e,r,a)||c["default"].userEndDrawMiddle(e,r,a)),n.current={}}}function d(e){e.draggable.current.orig&&(e.draggable.current={},c["default"].selectSquare(e,null))}var s,c=r(e("./board")),f=r(e("./table")),p=r(e("./util"));t.exports={start:i,move:u,end:l,cancel:d}},{"./board":5,"./table":16,"./util":17}],10:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){t.stopPropagation(),t.preventDefault(),u["default"].cancelMove(e);var n=l["default"].eventPosition(t),r=e.boardBounds(),a=u["default"].getKeyAtDomPosOnPiece(e,n,r),i=e.pieces[a];e.flipPiece(a,i)}function i(e,t){}function o(e,t){}var u=r(e("./board")),l=r(e("./util"));t.exports={start:a,move:i,end:o}},{"./board":5,"./util":17}],11:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){var t=new i["default"](e);return(0,l["default"])(t)}var i=r(e("./ctrl")),o=r(e("./util")),u=r(e("./move")),l=r(e("./api")),d=r(e("./anim")),s=r(e("./drag"));t.exports=a,t.exports.controller=i["default"],t.exports.util=o["default"],t.exports.move=u["default"],t.exports.anim=d["default"],t.exports.drag=s["default"]},{"./anim":3,"./api":4,"./ctrl":7,"./drag":9,"./move":12,"./util":17}],12:[function(e,t,n){"use strict";var r="dm",a="dl",i="dd",o="lt",u="ss",l="os",d="op",s="co",c="dos",f="dop",p="dds",v="ddp",m="l",g="r",h="p";t.exports={drawMiddle:r,drawLeft:a,discard:i,leaveTaken:o,sign:u,openSeries:l,openPairs:d,collectOpen:s,dropOpenSeries:c,dropOpenPairs:f,dropLeft:m,dropRight:g,dropReplace:h,discardEndSeries:p,discardEndPairs:v}},{}],13:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){return u(e)||o(e,t)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e,t){var n=[],r=!0,a=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(r=(o=u.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(l){a=!0,i=l}finally{try{r||null==u["return"]||u["return"]()}finally{if(a)throw i}}return n}function u(e){if(Array.isArray(e))return e}function l(e,t){return e.length===t.length&&e.every(function(e,n){return e===t[n]})}function d(e,t){return t.every(function(t,n){return t.color===e[n]})}function s(e,t){if(e.length<3)return!1;var n=e.length,r=e[0].color,a=e.map(function(e){return e.key}),i=a.slice(0).reverse(),o=w["default"].seriesByColor(r);t&&(o=o.slice(0),o.push(o[0]));for(var u=0;u<=o.length-n;u++){var d=o.slice(u,u+n);if(l(d,a)|l(d,i))return!0}return!1}function c(e){var t=e.length,n=e[0].number;return!!(3===t|4===t)&&(!!e.every(function(e){return e.number===n})&&b.some(function(t){return d(t.slice(0,e.length),e)}))}function f(e,t){var n=w["default"].makePiece(t.c,t.n);return n.isFake=!0,w["default"].pieceFake(e)?n:e}function p(e,t){return!e.isFake&&e.key===t.key}function v(e,t){function n(e,t){return e.filter(function(e){return t.indexOf(e)<0})}function r(e,t){return e.key===t.key}function i(e,t){var r=["r","g","b","l"],a=e.filter(function(e){return!p(e,t)}),i=n(r,a.map(function(e){return e.c}));if(i.length<1)return e;if(a.length<1)return e;if(!(a.length<e.length))return e;var o=i[0],u=a[0].n,l=w["default"].makePiece(o,u);return a.push(l),a}function o(e,t){var n;if(0===e.length)return e;if(e.length<3)return e;var i=a(e,3),u=i[0],l=i[1],d=i[2],s=[u,l,d];if(n=e.slice(3,e.length),p(u,t))r(w["default"].pieceUp(l),d)?s=[w["default"].pieceDown(l),l,d]:r(w["default"].pieceDown(l),d)&&(s=[w["default"].pieceUp(l),l,d]);else if(p(l,t))r(w["default"].pieceUp(w["default"].pieceUp(u)),d)?s=[u,w["default"].pieceUp(u),d]:r(w["default"].pieceDown(w["default"].pieceDown(u)),d)&&(s=[u,w["default"].pieceDown(u),d]);else{if(!p(d,t))return n=o(e.slice(1,e.length),t),n.unshift(e[0]),n;r(w["default"].pieceUp(u),l)?s=[u,l,w["default"].pieceUp(l)]:r(w["default"].pieceDown(u),l)&&(s=[u,l,w["default"].pieceDown(l)])}return s.concat(n)}function u(e,t){if(2!=e.length)return e;var n=a(e,2),r=n[0],i=n[1];return p(r,t)?[i,i]:p(i,t)?[r,r]:e}if(e.filter(function(e){return p(e,t)}).length>1)return e;if(e.length<3)return u(e,t);var l=e.filter(function(e){return!p(e,t)});return l.every(function(e){return e.n===l[0].n})?i(e,t):l.every(function(e){return e.c===l[0].c})?o(e,t):e}function m(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=w["default"].pieceUp(t),a=e.map(function(e){return f(e,r)}),i=v(a,r);return s(i,n)|c(i)}function g(e,t){if(2!==e.length)return!1;var n=w["default"].pieceUp(t),r=e.map(function(e){return f(e,n)}),i=v(r,n),o=a(i,2),u=o[0],l=o[1];return u.key===l.key}function h(e,t,n){var r=[],a=w["default"].pieceUp(n);return t=f(t,a),e.series.forEach(function(i,o){var u=i.slice(0),l=i.slice(0);u.splice(0,0,t),l.splice(i.length,0,t),m(u,n)&&r.push(w["default"].getOpenSerieKeyFromGroupIndex(e,o,0)),m(l,n)&&r.push(w["default"].getOpenSerieKeyFromGroupIndex(e,o,i.length+1));var d=i.map(function(e){return p(e,a)?t:e});if(m(d,n)){var s;i.forEach(function(e,t){p(e,a)&&(s=t)}),r.push(w["default"].getOpenSerieKeyFromGroupIndex(e,o,s+1))}}),e.pairs.forEach(function(i,o){var u=i.map(function(e){return p(e,a)?t:e});if(g(u,n)){var l=y(i,a);r.push(w["default"].getOpenPairKeyFromGroupIndex(e,o,l))}}),r}function y(e,t){var n;return e.forEach(function(e,r){p(e,t)&&(n=r)}),n}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=void 0;var w=r(e("./pieces")),b=function(){var e=w["default"].colors,t=[];for(var n in e)for(var r in e)for(var a in e)for(var i in e)n!==r&&n!==a&&n!==i&&r!==a&&r!==i&&a!==i&&t.push([e[n],e[r],e[a],e[i]]);return t}(),P={compute:h,series:m,pairs:g,findOkeyIndex:y};n["default"]=P},{"./pieces":14}],14:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){return u(e)||o(e,t)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e,t){var n=[],r=!0,a=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(r=(o=u.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(l){a=!0,i=l}finally{try{r||null==u["return"]||u["return"]()}finally{if(a)throw i}}return n}function u(e){if(Array.isArray(e))return e}function l(e){var t=[];for(var n in B)t.push(E(e,n).key);return t}function d(e){var t={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9},n=t[e[0]],r=t[e[1]];return void 0===r?void 0===n?{left:e.slice(1)}:{number:n,left:e.slice(1)}:{number:10*n+r,left:e.slice(2)}}function s(e){var t=/([l|r|p])(\d\d?)/,n=e.match(t),r=n[1],a=parseInt(n[2]);return{type:r,groupIndex:a}}function c(e){var t=e[0],n=e[1],r=e[2],a=2;return D[t]?(B[n+r]&&(n+=r,a=3),{piece:E(t,n),left:e.slice(a)}):{left:e.slice(1)}}function f(e){var t=[],n=[];for(e+="\n";e.length>0;){var r=c(e);r.piece?n.push(r.piece):(n.length>0&&t.push(n),n=[]),e=r.left}return t}function p(e){for(var t=[],n=0;e.length>0;){var r=c(e);r.piece&&(t[n]=r.piece),n++,e=r.left}return t}function v(e){var t={};e=p(e);for(var n=0,r=0;r<e.length;r++){if(e[r]){for(;n<100&&!A["default"].isAllowedBoardKey(A["default"].encodeKey(n,"b"));)n++;t[A["default"].encodeKey(n,"b")]=e[r],n++}n++}return t}function m(e,t){e=e.split(" ");var n={};return A["default"].allSides.map(function(e){return A["default"].findPov(t,e)}).forEach(function(t,r){var a=p(e[r]||"");n[A["default"].discardByPov(t)]=a}),n}function g(e){var t=e.split("/"),n=a(t,2),r=n[0],i=n[1];r=f(r),i=f(i);var o=h(r,i);return{series:r,pairs:i,layout:o,relayout:function(e){e.opens.layout=h(e.opens.series,e.opens.pairs)}}}function h(e,t){var n,r,a,i,o,u={},l={series:{},pairs:{}},d=[],s=0;for(n=0;n<e.length;n++){var c=e[n];i=(d[s]||1)-1,o=s,l.series[A["default"].miniPos2key([i,o])]=n;for(var f=0;f<c.length;f++)a=d[s]||1,r=A["default"].miniPos2key([a,s]),u[r]=c[f],d[s]=a+1;d[s]+=2,s++,s>=A["default"].miniRows&&(s=0)}for(d=[],n=0,f=0,r=0,a=0,s=0,n=0;n<t.length;n++){var p=t[n];for(i=(d[s]||A["default"].miniColumns-1)-1,o=s,l.pairs[A["default"].miniPos2key([i,o])]=n,f=p.length-1;f>=0;f--)a=d[s]||A["default"].miniColumns-1,r=A["default"].miniPos2key([a,s]),u[r]=p[f],d[s]=a-1;d[s]-=1,s++,s>=A["default"].miniRows&&(s=0)}return{layout:u,groupMap:l}}function y(e,t,n){for(var r in e)if(e[r]===t){var i=A["default"].miniKey2pos(r),o=a(i,2),u=o[0],l=o[1],d=[u+n,l];return A["default"].miniPos2key(d)}}function w(e,t,n){var r=e.layout.groupMap.pairs;return y(r,t,n)}function b(e,t,n){var r=e.layout.groupMap.series;return y(r,t,n)}function P(e,t){var n=e.opens,r=n.series,i=n.layout.groupMap,o=a(t,2),u=o[0],l=o[1];for(var d in i.series){var s=i.series[d],c=r[s],f=A["default"].miniKey2pos(d),p=a(f,2),v=p[0],m=p[1],g=u-v;if(!(g<0||g>c.length+1||l!=m))return[s,g]}}function k(e,t){var n=e.opens,r=n.pairs,i=n.layout.groupMap,o=a(t,2),u=o[0],l=o[1];for(var d in i.pairs){var s=i.pairs[d],c=(r[s],A["default"].miniKey2pos(d)),f=a(c,2),p=f[0],v=f[1],m=u-p;if(!(m<0||m>1||l!=v))return[s,m]}}function O(e){var t={},n=d(e);return t[A["default"].middleCount]=n.number,n=c(n.left),t[A["default"].gosterge]=n.piece,t}function x(e){e=e.split("/");var t=2,n=3,r=4,a=1,i=0,o={e:"east",w:"west",n:"north",s:"south"}[e[i]];return{pieces:v(e[t]),discards:m(e[n],o),opens:g([e[r],e[r+1]].join("/")),middles:O(e[a])}}function S(e){var t=A["default"].allKeys.map(function(t){return e[t]}).map(function(e){return e&&e.key||" "}).join("");return t.replace(/([^\s])\s/g,"$1")}function E(e,t){return{color:D[e],number:B[t],c:e,n:parseInt(t),key:e+t}}function M(e){var t=e.c,n=e.n%13+1;return E(t,n)}function C(e){var t=e.c,n=(e.n+11)%13+1;return E(t,n)}function K(e){return"fake"===e.color}function T(e){return e.length>0&&14===e.match(j).length}var A=r(e("./util")),D={b:"blue",r:"red",g:"green",l:"black",f:"fake"},B={1:"one",2:"two",3:"three",4:"four",5:"five",6:"six",7:"seven",8:"eight",9:"nine",10:"ten",11:"eleven",12:"twelve",13:"thirteen"},j=/[f|r|l|b|g]\d\d?/g,R=function(){var e={};for(var t in D)e[D[t]]=l(t);return e}(),L=function(e){return R[e]},G="g7r7b7l7 g8r8b8l8 g13r13b13l13 l12 r6r5r4r12r13 g9g8g13 g6 l8l7l12",F="r1g1l1b1 r2g2l2b2 r3g3l3b3 r4g4l4b4 r13g13l13b13 r1g1l1b1",N="r1r2 r3r4r5r6r7r8r9r10r11r12r13l1l2l3l4l5l6l7   g1g2  l3",_="20l3",I="b1  r1r2 g1",H="r8l8b8\nb1b2b3\nb9b10b11b12\nl13r13b13\nr12b12g12\nr7r8r9r10\ng10g11g12\nl6b6r6\nl9l10l11\nb7l7r7g7\nr13l13b13g13\nl10r10b10g10\nl6r6g6\nl1b1g1\n/r1r1\ng1g1\ng2g2\ng3g3\ng4g4\ng5g5\ng6g6\ng7g7\ng8g8\ng9g9\ng10g10\ng11g11\ng12g12\n\n";t.exports={validDuzOkeyGroupFen:T,initial:N,rainbow:F,mixed:G,write:S,read:x,readDropPos:s,readPiece:c,readBoard:v,initialMiddles:_,initialDiscards:I,initialOpenGroups:H,readMiddles:O,readDiscards:m,readPieceGroup:f,readOpenGroups:g,layoutOpens:h,seriesByColor:L,makePiece:E,pieceUp:M,pieceDown:C,pieceFake:K,colors:D,getOpenSerieKeyFromGroupIndex:b,getOpenPairKeyFromGroupIndex:w,getOpenSerieFromPos:P,getOpenPairFromPos:k}},{"./util":17}],15:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){return u(e)||o(e)||i()}function i(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function o(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function u(e){if(Array.isArray(e)){for(var t=0,n=new Array(e.length);t<e.length;t++)n[t]=e[t];return n}}function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function d(e){function t(e,n,r){for(var i in r){var o=r[i];if(i!==n&&o.c===e.c){if(1===o.n&&2===e.n)return[l({},i,o)];if(13===o.n&&1===e.n||o.n===e.n-1)return[l({},i,o)].concat(a(t(o,i,r)))}}return[]}function n(e,t,r){for(var i in r){var o=r[i];if(i!==t&&o.c===e.c){if(1===o.n&&13===e.n)return[l({},i,o)];if(o.n===e.n+1)return[l({},i,o)].concat(a(n(o,i,r)))}}return[]}function r(e,t,n){var r={};for(var a in n){var i=n[a];a!==t&&i.n===e.n&&i.c!==e.c&&(r[i.c]=l({},a,i))}return Object.values(r)}function i(e){var a={};for(var i in e){var o=e[i];o&&(a[i]={downs:t(o,i,e),ups:n(o,i,e),same:r(o,i,e)})}var u={type:null,key:null,value:0};for(var d in a){var s=a[d];["downs","ups","same"].map(function(e){s[e].length>=u.value&&(u.type=e,u.key=d,u.value=s[e].length)})}var c=a[u.key][u.type];return"downs"===u.type?c.unshift(l({},u.key,e[u.key])):c.unshift(l({},u.key,e[u.key])),c}for(var o in e.pieces)e.pieces[o]||delete e.pieces[o];var u=Object.assign({},e.pieces);for(o in e.pieces)e.pieces[o]=void 0,delete e.pieces[o];for(var d=1;Object.keys(u).length>0;){var s=i(u),c=s.length;d=f["default"].nextIteratorForGroup(d,c),s.forEach(function(t,n){for(var r in t){var a=t[r];e.pieces[f["default"].iterator2Key(d+2*n)]=a,u[r]=void 0,delete u[r]}}),d+=2*c+1}console.log(e.pieces)}function s(e){var t={};for(var n in e.pieces){var r=e.pieces[n];r&&(t[r.key]?t[r.key]++:t[r.key]=1,delete e.pieces[n])}var a=1;for(var i in t){var o=t[i];a=f["default"].nextIteratorForGroup(a,o);for(var u=0;u<o;u++)e.pieces[f["default"].iterator2Key(a+2*u)]=c["default"].readPiece(i).piece;a+=2*o+1}}var c=r(e("./pieces")),f=r(e("./util"));t.exports={sortPairs:s,sortSeries:d}},{"./pieces":14,"./util":17}],16:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,t){return u(e)||o(e,t)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function o(e,t){var n=[],r=!0,a=!1,i=void 0;try{for(var o,u=e[Symbol.iterator]();!(r=(o=u.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(l){a=!0,i=l}finally{try{r||null==u["return"]||u["return"]()}finally{if(a)throw i}}return n}function u(e){if(Array.isArray(e))return e}function l(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.piece,a=n.group,i=n.pos,o=R["default"].findPov(e.povSide,e.turnSide);if(e.turnSide!==e.povSide||e.spectator)switch(t){case L["default"].drawMiddle:v(e),e.animation.current.hint=L["default"].drawMiddle;break;case L["default"].drawLeft:m(e,R["default"].drawByPov(o)),e.animation.current.hint=L["default"].drawLeft;break;case L["default"].discard:r=G["default"].readPiece(r).piece,p(e,R["default"].discardByPov(o),r),e.animation.current.hint=L["default"].discard;break;case L["default"].leaveTaken:r=G["default"].readPiece(r).piece,g(e,R["default"].drawByPov(o),r),e.animation.current.hint=L["default"].leaveTaken;break;case L["default"].openSeries:a=G["default"].readPieceGroup(a),c(e,a),e.animation.current.hint=L["default"].openSeries;break;case L["default"].openPairs:a=G["default"].readPieceGroup(a),f(e,a),e.animation.current.hint=L["default"].openSeries;break;case L["default"].dropOpenSeries:r=G["default"].readPiece(r).piece,i=G["default"].readDropPos(i),d(e,r,i);break;case L["default"].dropOpenPairs:r=G["default"].readPiece(r).piece,i=G["default"].readDropPos(i),s(e,r,i);break;default:console.error("unknown move")}else if(e.spectator)t===L["default"].leaveTaken&&(r=G["default"].readPiece(r).piece,g(e,R["default"].drawByPov(o),r),e.animation.current.hint=L["default"].leaveTaken);else switch(t){case L["default"].discard:r=G["default"].readPiece(r).piece,w(e,r,R["default"].discards[2]),e.animation.current.hint=L["default"].discard;break;case L["default"].drawMiddle:r=G["default"].readPiece(r).piece,e.middleHolder.current?N["default"].apiDrawMiddleEnd(e,r):N["default"].apiForceDrawMiddleEnd(e,r),e.animation.current.hint=L["default"].drawMiddle;break;case L["default"].leaveTaken:N["default"].playLeaveTaken(e,r)}}function d(e,t,n){var r=n.type,a=n.groupIndex,i=e.opens.series[a],o=r!==L["default"].dropReplace?0:1,u=0;if(r===L["default"].dropLeft)u=0;else if(r===L["default"].dropRight)u=i.length+1;else{var l=G["default"].pieceUp(e.middles[R["default"].gosterge]);u=F["default"].findOkeyIndex(i,l)+1}i.splice(u-o,o,t),e.opens.relayout(e)}function s(e,t,n){var r=n.groupIndex,a=e.opens.pairs[r],i=G["default"].pieceUp(e.middles[R["default"].gosterge]),o=F["default"].findOkeyIndex(a,i);a.splice(o,1,t),e.opens.relayout(e)}function c(e,t){var n=t,r=e.opens.series.concat(n);e.opens.series=r,e.opens.relayout(e)}function f(e,t){var n=t,r=e.opens.pairs.concat(n);e.opens.pairs=r,e.opens.relayout(e)}function p(e,t,n){return e.discards[t].unshift(n),e.lastMove=[t],!0}function v(e){return e.middles[R["default"].middleCount]--,e.lastMove=[R["default"].middleCount],!0}function m(e,t){return e.discards[t].shift(),!0}function g(e,t,n){return e.discards[t].unshift(n),!0}function h(e,t,n,r){if(!e.pieces[t]||!r)return!1;var i=e.pieces[t];U(R["default"].partial(e.events.move,L["default"].dropOpenSeries,I(i.key)));var o=a(r,2),u=o[0],l=o[1],d=e.opens.series[u],s=O(d,l),c=s!==L["default"].dropReplace?0:1;if(d.splice(l-c,c,i),e.opens.relayout(e),delete e.pieces[t],s===L["default"].dropReplace){var f=G["default"].pieceUp(e.middles[R["default"].gosterge]);e.pieces[t]=f}return!0}function y(e,t,n,r){if(!e.pieces[t]||!r)return!1;var i=e.pieces[t];U(R["default"].partial(e.events.move,L["default"].dropOpenPairs,I(i.key)));var o=a(r,2),u=o[0],l=o[1],d=e.opens.pairs[u];d.splice(l,1,i),e.opens.relayout(e),delete e.pieces[t];var s=G["default"].pieceUp(e.middles[R["default"].gosterge]);return e.pieces[t]=s,!0}function w(e,t,n){for(var r in e.pieces){var a=e.pieces[r];if(a&&R["default"].pieceEqual(t,a))return b(e,r,n),!0}return!1}function b(e,t,n){var r=e.pieces[t];return!!r&&(U(R["default"].partial(e.events.move,L["default"].discard,I(r.key))),e.discards[n].unshift(e.pieces[t]),delete e.pieces[t],e.lastMove=[n],!0)}function P(e,t){var n=e.pieces[t];return!!n&&(!!R["default"].pieceEqual(n,e.middles[R["default"].gosterge])&&(U(R["default"].partial(e.events.move,L["default"].sign,I(n.key))),!0))}function k(e,t){var n=e.pieces[t];if(!n)return!1;delete e.pieces[t];var r=(G["default"].write(e.pieces),N["default"].getPieceGroupSeries(e)),a=N["default"].getPieceGroupPairs(e);if(G["default"].validDuzOkeyGroupFen(r))U(R["default"].partial(e.events.move,L["default"].discardEndSeries,H(r)));else{if(!G["default"].validDuzOkeyGroupFen(a))return e.pieces[t]=n,!1;U(R["default"].partial(e.events.move,L["default"].discardEndPairs,H(a)))}return!0}function O(e,t){return 0===t?L["default"].dropLeft:t===e.length+1?L["default"].dropRight:L["default"].dropReplace}function x(e,t,n){if(n&&R["default"].isOpensKey(n)&&T(e,t,n)){var r,i,o,u,l,d=e.pieces[t],s=G["default"].getOpenSerieFromPos(e,R["default"].miniKey2pos(n));if(s){var c=a(s,2);r=c[0],i=c[1],o=e.opens.series[r],u=O(o,i),l=u+r}if(h(e,t,n,s))return U(R["default"].partial(e.movable.events.after,L["default"].dropOpenSeries,_(d.key,l))),!0;var f=G["default"].getOpenPairFromPos(e,R["default"].miniKey2pos(n));if(f){var p=a(f,2);r=p[0],i=p[1],o=e.opens.pairs[r],u=O(o,i),l=u+r}if(y(e,t,n,f))return U(R["default"].partial(e.movable.events.after,L["default"].dropOpenPairs,_(d.key,l))),!0}return!1}function S(e,t,n){var r=e.pieces[t];if(n&&n===R["default"].discards[2]){if(A(e,t,n)&&b(e,t,n))return U(R["default"].partial(e.movable.events.after,L["default"].discard,I(r.key))),!0}else if(n===R["default"].gosterge){if(B(e,t)&&P(e,t))return U(R["default"].partial(e.movable.events.after,L["default"].sign,I(r.key))),!0;if(D(e,t)&&k(e,t)){var a=(G["default"].write(e.pieces),N["default"].getPieceGroupSeries(e)),i=N["default"].getPieceGroupPairs(e);return G["default"].validDuzOkeyGroupFen(a)?U(R["default"].partial(e.movable.events.after,L["default"].discardEndSeries,H(a))):G["default"].validDuzOkeyGroupFen(i)&&U(R["default"].partial(e.movable.events.after,L["default"].discardEndPairs,H(i))),!0}}return!1}function E(e,t){M(e,t)}function M(e,t){e.selected=t}function C(e,t){return R["default"].isMiddleKey(t)||R["default"].isDrawLeftKey(t)?e.povSide===e.turnSide:R["default"].isBoardKey(t)}function K(e){return e.povSide===e.turnSide}function T(e,t,n){var r=e.middles[R["default"].gosterge];return N["default"].isDroppableOpens(e,t)&&R["default"].isBoardKey(t)&&R["default"].isOpensKey(n)&&R["default"].containsX(e.movable.dests,L["default"].dropOpenSeries)&&R["default"].containsX(e.movable.dests,L["default"].dropOpenPairs)&&R["default"].containsX(F["default"].compute(e.opens,e.pieces[t],r),n)}function A(e,t,n){return K(e)&&R["default"].containsX(e.movable.dests,L["default"].discard)}function D(e,t){return K(e)&&R["default"].containsX(e.movable.dests,L["default"].discardEndSeries)}function B(e,t){return K(e)&&R["default"].containsX(e.movable.dests,L["default"].showSign)}function j(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R["default"].topColumns,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:R["default"].topRows;return function(r,a,i){if(i||r.bounds){i=i||r.bounds();var o=Math.floor(t*((a[0]-i.left)/i.width)),u=Math.floor(n*((a[1]-i.top)/i.height));return u>=0&&u<n&&o>=0&&o<t?e(u,o):void 0}}}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=void 0;var R=r(e("./util")),L=r(e("./move")),G=r(e("./pieces")),F=r(e("./open")),N=r(e("./board")),_=R["default"].wrapDrop,I=R["default"].wrapPiece,H=R["default"].wrapGroup,U=R["default"].callUserFunction,q=j(function(e,t){return R["default"].miniPos2key([t,e])},R["default"].miniColumns,R["default"].miniRows),X=j(function(e,t){if(e===R["default"].topRows-1){if(0===t)return R["default"].discards[1];if(t===R["default"].topColumns-4)return R["default"].middleCount}}),z=j(function(e,t){if(e===R["default"].topRows-1){if(t===R["default"].topColumns-1)return R["default"].discards[2];if(t===R["default"].topColumns-3)return R["default"].gosterge}}),$={apiMove:l,selectTop:E,dropTop:S,dropOpens:x,isDraggable:C,getDrawKeyAtDomPos:X,
getDiscardKeyAtDomPos:z,getOpensKeyAtDomPos:q};n["default"]=$},{"./board":5,"./move":12,"./open":13,"./pieces":14,"./util":17}],17:[function(e,t,n){"use strict";function r(e,t){return _[e][t]}function a(e,t){return e.color===t.color&&e.number===t.number}function i(e,t){for(var n=[],r=0;r<e;r++)for(var a=0;a<t;a++)n.push([a,r]);return n}function o(e,t){return t+e}function u(e,t){return parseInt(e.slice(1))}function l(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return o(u(e)-t,W)}function d(e){return e[0]===W}function s(e){return e[0]===Z}function c(e){return e===J}function f(e){return e===$[1]}function p(e){var t=e[1]*B+e[0];return o(t,W)}function v(e){return e=u(e),[e%B,Math.floor(e/B)]}function m(e){return o(e,W)}function g(e,t){function n(e){var t=Math.floor(e/B),n=e%B;return[n,t]}function r(e){return e[1]*B+e[0]}var a=n(e),i=n(e+2*t);return a[1]!==i[1]?r([1,1]):(1===a[1]&&0===a[0]&&(a[0]=1),r(a))}function h(e){return Y[e]}function y(e){var t=e[1]*G+e[0];return o(t,Z)}function w(e){return e=u(e),[e%G,Math.floor(e/G)]}function b(e){var t=[];for(var n in e)e[n]&&t.push(n);return t.join(" ")}function P(e,t){return e&&e.indexOf(t)!==-1}function k(e){return e.touches?[e.targetTouches[0].clientX,e.targetTouches[0].clientY]:[e.clientX,e.clientY]}function O(e,t){return Math.sqrt(Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2))}function x(){return"transform"in document.body.style?"transform":"webkitTransform"in document.body.style?"webkitTransform":"mozTransform"in document.body.style?"mozTransform":"oTransform"in document.body.style?"oTransform":"msTransform"}function S(){return D||(D=x()),D}function E(e){return"translate("+e[0]+"px,"+e[1]+"px)"}function M(e,t){return e.bind.apply(e,[null].concat(t))}function C(){return M(arguments[0],Array.prototype.slice.call(arguments,1))}function K(e){return 2===e.buttons||2===e.button}function T(e){var t,n=function(){return void 0===t&&(t=e()),t};return n.clear=function(){t=void 0},n}function A(e){setTimeout(e,1)}var D,B=32,j=2,R=16,L=7,G=20,F=8,N=["east","west","north","south"],_={east:{east:"down",west:"up",north:"right",south:"left"},west:{east:"up",west:"down",north:"left",south:"right"},north:{east:"left",west:"right",north:"down",south:"up"},south:{east:"right",west:"left",north:"up",south:"down"}},I={up:0,left:1,down:2,right:3},H={up:3,left:0,down:1,right:2},U={up:[.5,0],left:[0,.5],right:[1,.5],down:[.5,1]},q=function(e){return U[e]},X=function(e){return $[I[e]]},z=function(e){return $[H[e]]},$=["dup","dleft","ddown","dright"],J="mmiddleCount",V="mgosterge",Y={dup:[0,0],dleft:[0,L-1],ddown:[R-1,L-1],dright:[R-1,0],mmiddleCount:[R-4,L-1],mgosterge:[R-3,L-1]},Q={color:"empty",number:1},W="b",Z="o",ee=i(j,B),te=i(F,G),ne=[[0,0],[30,0],[31,0],[32,0],[62,0],[63,0]].map(p),re=function(e){return ne.indexOf(e)===-1},ae=ee.map(p),ie=ae.filter(re),oe=function(e){return ie.indexOf(e)!==-1},ue=te.map(y),le=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t.piece=e,t},de=function(e){return{group:e}},se=function(e,t){return{piece:e,pos:t}};t.exports={topColumns:R,topRows:L,columns:B,rows:j,emptyPiece:Q,pieceEqual:a,allSides:N,allPos:ee,allKeys:ae,topKey2pos:h,pos2key:p,key2pos:v,iterator2Key:m,nextIteratorForGroup:g,miniColumns:G,miniRows:F,miniAllPos:te,miniAllKeys:ue,miniPos2key:y,miniKey2pos:w,encodeKey:o,decBoardKey:l,notAllowedBoardKeys:ne,isAllowedBoardKey:re,isAllAllowedBoardKey:oe,allAllowedBoardKeys:ie,isBoardKey:d,isOpensKey:s,isMiddleKey:c,isDrawLeftKey:f,findPov:r,vectorByPov:q,drawByPov:z,discardByPov:X,discards:$,middleCount:J,gosterge:V,classSet:b,containsX:P,eventPosition:k,distance:O,transformProp:S,translate:E,requestAnimationFrame:(window.requestAnimationFrame||window.setTimeout).bind(window),partialApply:M,partial:C,isRightButton:K,memo:T,wrapPiece:le,wrapGroup:de,wrapDrop:se,callUserFunction:A}},{}],18:[function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){return e.color+" "+e.number}function i(e){return{left:e[0]*(100/T["default"].columns)+"%",top:e[1]*(100/T["default"].rows)+"%"}}function o(e){return{left:e[0]*(100/T["default"].miniColumns)+"%",top:e[1]*(100/T["default"].miniRows)+"%"}}function u(e,t,n,r){var i=(e.data,{key:n,style:o(t),"class":a(r)+" mini"});if(e.data.animation.current.anims){var u=e.data.animation.current.anims[n],l=e.data.animation.current.scales[n];u&&(i["class"]+=" animating",i.style[T["default"].transformProp()]=T["default"].translate(u[1]),l&&(i.style[T["default"].transformProp()]+=" scale(".concat(l[0],", ").concat(l[1],")"),i.style.transformOrigin="center"))}return{tag:"piece",attrs:i}}function l(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=e.data,o=T["default"].classSet({selected:i.selected===t,"last-move":i.lastMove&&T["default"].containsX(i.lastMove,t)}),u={style:{},"class":[a(n),t,o].join(" "),"data-middle-count":e.data.middles[t]},l=e.data.draggable.current;if(r&&l.orig===t)u.style[T["default"].transformProp()]=T["default"].translate([l.pos[0]+l.dec[0],l.pos[1]+l.dec[1]]),u["class"]+=" dragging";else if(!r&&e.data.animation.current.anims){var d=e.data.animation.current.anims[t];d&&(u["class"]+=" animating",u.style[T["default"].transformProp()]=T["default"].translate(d[1]))}return{tag:"piece",attrs:u}}function d(e,t,n,r){var i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:t,u=e.data,l=T["default"].classSet({selected:u.selected===t}),d={style:{},"class":[a(n),t,l].join(" ")};r&&(d["class"]+=" "+r);var s=e.data.draggable.current;if(i&&s.orig===t)d.style[T["default"].transformProp()]=T["default"].translate([s.pos[0]+s.dec[0],s.pos[1]+s.dec[1]]),d["class"]+=" dragging";else if(i&&e.data.animation.current.anims){var c=e.data.animation.current.anims[o];c&&(d["class"]+=" animating",d.style[T["default"].transformProp()]=T["default"].translate(c[1]))}return{tag:"piece",attrs:d}}function s(e,t,n){var r=(e.data,T["default"].classSet({"piece-holder":!0})),a={style:{},"class":[t,r,n].join(" ")};return{tag:"div",attrs:a}}function c(e,t,n,r){var a="flipper"+(n?" hover":"")+" "+r,i={top:0,left:0},o=e.attrs.style;e.attrs.style=i,t.attrs.style=i;var u={"class":a,style:o};return{tag:"div",attrs:u,children:[{tag:"div",attrs:{"class":"front"},children:[e]},{tag:"div",attrs:{"class":"back"},children:[t]}]}}function f(e,t,n,r,o){var u=e.data,l=T["default"].classSet({selected:u.selected===n}),d={key:n,style:i(t),"class":[a(r),l].join(" ")};o&&(d["class"]+=" "+o);var s=e.data.draggable.current;if(s.dragGroup&&s.dragGroup.indexOf(n)!==-1?(d.style[T["default"].transformProp()]=T["default"].translate([s.pos[0]+s.dec[0],s.pos[1]+s.dec[1]]),d["class"]+=" group dragging"):s.orig===n&&(s.over&&T["default"].isOpensKey(s.over)&&(d.style.width=s.opensBounds.width/T["default"].miniColumns+"px",d.style.height=s.opensBounds.height/T["default"].miniRows+"px"),d.style[T["default"].transformProp()]=T["default"].translate([s.pos[0]+s.dec[0],s.pos[1]+s.dec[1]]),d["class"]+=" dragging"),e.data.animation.current.anims){var c=e.data.animation.current.anims[n];c&&(d["class"]+=" animating",d.style[T["default"].transformProp()]=T["default"].translate(c[1]))}return{tag:"piece",attrs:d}}function p(e,t,n){return{tag:"div",attrs:{"class":e+" oc "+n}}}function v(e,t,n){return{tag:"div",attrs:{style:o(n),"class":e+" oc"}}}function m(e,t,n){return{tag:"div",attrs:{style:i(n),"class":e}}}function g(e){function t(e){return{tag:"div",attrs:{"class":"wood "+e}}}var n,r=e.data,a=T["default"].allPos,i=[];i.push(t("left"),t("right"));for(var o=0;o<a.length;o++){var u=T["default"].pos2key(a[o]),l=r.pieces[u];if(l){var d=f(e,a[o],u,l);if(r.flippable.current.orig===u){var s,p,v=r.flippable.current.flip,g=f(e,a[o],u,T["default"].emptyPiece);l.flip?(s=g,p=d):(s=d,p=g),i.push(c(s,p,v))}else l.flip&&(d=f(e,a[o],u,T["default"].emptyPiece)),i.push(d)}r.draggable.current.over===u&&(n=m("drag-over",e,a[o]))}return r.middleHolder.key&&i.push(f(e,T["default"].key2pos(r.middleHolder.key),r.middleHolder.key,T["default"].emptyPiece,"loading")),n&&i.push(n),{tag:"div",attrs:{config:function(t,n,r){n||(e.data.boardBounds=T["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-board"},children:i}}function h(e,t){for(var n=e.data,r=T["default"].miniAllPos,a=[],i=[],o=0;o<r.length;o++){var l=T["default"].miniPos2key(r[o]),d=t[l];if(d&&a.push(u(e,r[o],l,d)),e.data.animation.current.anims){var s=e.data.animation.current.anims[l];d=e.data.animation.current.extra[l],s&&d&&a.push(u(e,r[o],l,d))}var c=T["default"].classSet({"drag-over":n.draggable.current.over===l,"move-dest":T["default"].containsX(n.openable.dests,l)});""!==c&&i.push(v(c,e,r[o]))}return a.push(i),a}function y(e){var t=e.data,n=h(e,t.opens.layout.layout);return{tag:"div",attrs:{config:function(t,n,r){n||(e.data.opensBounds=T["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-opens"},children:n}}function w(e){var t=e.data,n=[],r=[];for(var a in t.discards){var i=t.discards[a][0],o=T["default"].classSet({"drag-over":t.draggable.current.over===a,"move-dest":"ddown"===a&&t.selected&&T["default"].isBoardKey(t.selected)&&T["default"].containsX(t.movable.dests,A["default"].discard),"last-move":t.lastMove&&T["default"].containsX(t.lastMove,a)});if(i){t.discards[a][1]&&r.push(d(e,a,t.discards[a][1],"fake",!1)),r.push(d(e,a,i,o));var u=A["default"].drawLeft+a,l=!!e.data.animation.current.anims&&e.data.animation.current.anims[u];if(l){var c=e.data.animation.current.extra.piece;r.push(d(e,a,c,o,!0,u))}}else n.push(s(e,a,o))}return n.push(r),n}function b(e){var t=e.data,n=[],r=t.middleHolder.piece||T["default"].emptyPiece;if(n.push(d(e,T["default"].gosterge,t.middles[T["default"].gosterge])),n.push(l(e,T["default"].middleCount,T["default"].emptyPiece)),T["default"].isMiddleKey(t.draggable.current.orig)||t.animation.current.anims&&t.animation.current.anims[T["default"].middleCount]){var a=l(e,T["default"].middleCount,r,!0);n.push(a)}return t.draggable.current.over===T["default"].gosterge&&n.push(p("drag-over",e,T["default"].gosterge)),n}function P(e){var t=[],n=e.data.topHooks;return n&&t.push(n),t}function k(e){var t=[b(e),w(e),y(e),P(e)];return{tag:"div",attrs:{config:function(t,n,r){n||(e.data.topBounds=T["default"].memo(t.getBoundingClientRect.bind(t)))},"class":"og-top"},children:t}}function O(e){return[k(e),g(e)]}function x(e,t,n){return function(r){T["default"].isRightButton(r)?n(e,r):e.viewOnly||t(e,r)}}function S(e,t,n){var r=e.data,a=x(r,C["default"].start,K["default"].start),i=x(r,C["default"].move,K["default"].move),o=x(r,C["default"].end,K["default"].end),u=["touchstart","mousedown"],l=["touchmove","mousemove"],d=["touchend","mouseup"];u.forEach(function(e){t.addEventListener(e,a)}),l.forEach(function(e){document.addEventListener(e,i)}),d.forEach(function(e){document.addEventListener(e,o)}),n.onunload=function(){u.forEach(function(e){t.removeEventListener(e,a)}),l.forEach(function(e){document.removeEventListener(e,i)}),d.forEach(function(e){document.removeEventListener(e,o)})}}function E(e){return{tag:"div",attrs:{"class":"og-table",config:function(t,n,r){n||(e.data.viewOnly||S(e,t,r),e.data.render=function(){M["default"].render(t,O(e))},e.data.renderRAF=function(){T["default"].requestAnimationFrame(e.data.render)},e.data.bounds=T["default"].memo(t.getBoundingClientRect.bind(t)),e.data.element=t,e.data.render())}},children:[]}}var M=r(e("mithril")),C=r(e("./drag")),K=r(e("./draw")),T=r(e("./util")),A=r(e("./move"));t.exports=function(e){return{tag:"div",attrs:{config:function(t,n){n||(t.addEventListener("contextmenu",function(e){return e.preventDefault(),!1}),["onscroll","onresize"].forEach(function(t){var n=window[t];window[t]=function(){n&&n(),e.data.bounds.clear(),e.data.boardBounds.clear(),e.data.opensBounds.clear(),e.data.topBounds.clear()}}))},"class":["og-table-wrap"].join(" ")},children:[E(e)]}}},{"./drag":9,"./draw":10,"./move":12,"./util":17,mithril:2}]},{},[11])(11)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
/* MIT license */

module.exports = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2keyword: rgb2keyword,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2keyword: hsl2keyword,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2keyword: hsv2keyword,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  keyword2rgb: keyword2rgb,
  keyword2hsl: keyword2hsl,
  keyword2hsv: keyword2hsv,
  keyword2hwb: keyword2hwb,
  keyword2cmyk: keyword2cmyk,
  keyword2lab: keyword2lab,
  keyword2xyz: keyword2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  lab2xyz: lab2xyz,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


function rgb2hsl(rgb) {
  var r = rgb[0]/255,
      g = rgb[1]/255,
      b = rgb[2]/255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, l;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g)/ delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  l = (min + max) / 2;

  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);

  return [h, s * 100, l * 100];
}

function rgb2hsv(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h, s, v;

  if (max == 0)
    s = 0;
  else
    s = (delta/max * 1000)/10;

  if (max == min)
    h = 0;
  else if (r == max)
    h = (g - b) / delta;
  else if (g == max)
    h = 2 + (b - r) / delta;
  else if (b == max)
    h = 4 + (r - g) / delta;

  h = Math.min(h * 60, 360);

  if (h < 0)
    h += 360;

  v = ((max / 255) * 1000) / 10;

  return [h, s, v];
}

function rgb2hwb(rgb) {
  var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  return [h, w * 100, b * 100];
}

function rgb2cmyk(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c, m, y, k;

  k = Math.min(1 - r, 1 - g, 1 - b);
  c = (1 - r - k) / (1 - k) || 0;
  m = (1 - g - k) / (1 - k) || 0;
  y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
}

function rgb2keyword(rgb) {
  return reverseKeywords[JSON.stringify(rgb)];
}

function rgb2xyz(rgb) {
  var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

  // assume sRGB
  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

  return [x * 100, y *100, z * 100];
}

function rgb2lab(rgb) {
  var xyz = rgb2xyz(rgb),
        x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function rgb2lch(args) {
  return lab2lch(rgb2lab(args));
}

function hsl2rgb(hsl) {
  var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }

  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;

    rgb[i] = val * 255;
  }

  return rgb;
}

function hsl2hsv(hsl) {
  var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv, v;

  if(l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
  }

  l *= 2;
  s *= (l <= 1) ? l : 2 - l;
  v = (l + s) / 2;
  sv = (2 * s) / (l + s);
  return [h, sv * 100, v * 100];
}

function hsl2hwb(args) {
  return rgb2hwb(hsl2rgb(args));
}

function hsl2cmyk(args) {
  return rgb2cmyk(hsl2rgb(args));
}

function hsl2keyword(args) {
  return rgb2keyword(hsl2rgb(args));
}


function hsv2rgb(hsv) {
  var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - (s * f)),
      t = 255 * v * (1 - (s * (1 - f))),
      v = 255 * v;

  switch(hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
}

function hsv2hsl(hsv) {
  var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl, l;

  l = (2 - s) * v;
  sl = s * v;
  sl /= (l <= 1) ? l : 2 - l;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
}

function hsv2hwb(args) {
  return rgb2hwb(hsv2rgb(args))
}

function hsv2cmyk(args) {
  return rgb2cmyk(hsv2rgb(args));
}

function hsv2keyword(args) {
  return rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function hwb2rgb(hwb) {
  var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i, v, f, n;

  // wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  i = Math.floor(6 * h);
  v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) != 0) {
    f = 1 - f;
  }
  n = wh + f * (v - wh);  // linear interpolation

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
}

function hwb2hsl(args) {
  return rgb2hsl(hwb2rgb(args));
}

function hwb2hsv(args) {
  return rgb2hsv(hwb2rgb(args));
}

function hwb2cmyk(args) {
  return rgb2cmyk(hwb2rgb(args));
}

function hwb2keyword(args) {
  return rgb2keyword(hwb2rgb(args));
}

function cmyk2rgb(cmyk) {
  var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r, g, b;

  r = 1 - Math.min(1, c * (1 - k) + k);
  g = 1 - Math.min(1, m * (1 - k) + k);
  b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
}

function cmyk2hsl(args) {
  return rgb2hsl(cmyk2rgb(args));
}

function cmyk2hsv(args) {
  return rgb2hsv(cmyk2rgb(args));
}

function cmyk2hwb(args) {
  return rgb2hwb(cmyk2rgb(args));
}

function cmyk2keyword(args) {
  return rgb2keyword(cmyk2rgb(args));
}


function xyz2rgb(xyz) {
  var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r, g, b;

  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

  // assume sRGB
  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    : r = (r * 12.92);

  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    : g = (g * 12.92);

  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    : b = (b * 12.92);

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
}

function xyz2lab(xyz) {
  var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l, a, b;

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

  l = (116 * y) - 16;
  a = 500 * (x - y);
  b = 200 * (y - z);

  return [l, a, b];
}

function xyz2lch(args) {
  return lab2lch(xyz2lab(args));
}

function lab2xyz(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      x, y, z, y2;

  if (l <= 8) {
    y = (l * 100) / 903.3;
    y2 = (7.787 * (y / 100)) + (16 / 116);
  } else {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

  return [x, y, z];
}

function lab2lch(lab) {
  var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr, h, c;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  c = Math.sqrt(a * a + b * b);
  return [l, c, h];
}

function lab2rgb(args) {
  return xyz2rgb(lab2xyz(args));
}

function lch2lab(lch) {
  var l = lch[0],
      c = lch[1],
      h = lch[2],
      a, b, hr;

  hr = h / 360 * 2 * Math.PI;
  a = c * Math.cos(hr);
  b = c * Math.sin(hr);
  return [l, a, b];
}

function lch2xyz(args) {
  return lab2xyz(lch2lab(args));
}

function lch2rgb(args) {
  return lab2rgb(lch2lab(args));
}

function keyword2rgb(keyword) {
  return cssKeywords[keyword];
}

function keyword2hsl(args) {
  return rgb2hsl(keyword2rgb(args));
}

function keyword2hsv(args) {
  return rgb2hsv(keyword2rgb(args));
}

function keyword2hwb(args) {
  return rgb2hwb(keyword2rgb(args));
}

function keyword2cmyk(args) {
  return rgb2cmyk(keyword2rgb(args));
}

function keyword2lab(args) {
  return rgb2lab(keyword2rgb(args));
}

function keyword2xyz(args) {
  return rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  aliceblue:  [240,248,255],
  antiquewhite: [250,235,215],
  aqua: [0,255,255],
  aquamarine: [127,255,212],
  azure:  [240,255,255],
  beige:  [245,245,220],
  bisque: [255,228,196],
  black:  [0,0,0],
  blanchedalmond: [255,235,205],
  blue: [0,0,255],
  blueviolet: [138,43,226],
  brown:  [165,42,42],
  burlywood:  [222,184,135],
  cadetblue:  [95,158,160],
  chartreuse: [127,255,0],
  chocolate:  [210,105,30],
  coral:  [255,127,80],
  cornflowerblue: [100,149,237],
  cornsilk: [255,248,220],
  crimson:  [220,20,60],
  cyan: [0,255,255],
  darkblue: [0,0,139],
  darkcyan: [0,139,139],
  darkgoldenrod:  [184,134,11],
  darkgray: [169,169,169],
  darkgreen:  [0,100,0],
  darkgrey: [169,169,169],
  darkkhaki:  [189,183,107],
  darkmagenta:  [139,0,139],
  darkolivegreen: [85,107,47],
  darkorange: [255,140,0],
  darkorchid: [153,50,204],
  darkred:  [139,0,0],
  darksalmon: [233,150,122],
  darkseagreen: [143,188,143],
  darkslateblue:  [72,61,139],
  darkslategray:  [47,79,79],
  darkslategrey:  [47,79,79],
  darkturquoise:  [0,206,209],
  darkviolet: [148,0,211],
  deeppink: [255,20,147],
  deepskyblue:  [0,191,255],
  dimgray:  [105,105,105],
  dimgrey:  [105,105,105],
  dodgerblue: [30,144,255],
  firebrick:  [178,34,34],
  floralwhite:  [255,250,240],
  forestgreen:  [34,139,34],
  fuchsia:  [255,0,255],
  gainsboro:  [220,220,220],
  ghostwhite: [248,248,255],
  gold: [255,215,0],
  goldenrod:  [218,165,32],
  gray: [128,128,128],
  green:  [0,128,0],
  greenyellow:  [173,255,47],
  grey: [128,128,128],
  honeydew: [240,255,240],
  hotpink:  [255,105,180],
  indianred:  [205,92,92],
  indigo: [75,0,130],
  ivory:  [255,255,240],
  khaki:  [240,230,140],
  lavender: [230,230,250],
  lavenderblush:  [255,240,245],
  lawngreen:  [124,252,0],
  lemonchiffon: [255,250,205],
  lightblue:  [173,216,230],
  lightcoral: [240,128,128],
  lightcyan:  [224,255,255],
  lightgoldenrodyellow: [250,250,210],
  lightgray:  [211,211,211],
  lightgreen: [144,238,144],
  lightgrey:  [211,211,211],
  lightpink:  [255,182,193],
  lightsalmon:  [255,160,122],
  lightseagreen:  [32,178,170],
  lightskyblue: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  lightsteelblue: [176,196,222],
  lightyellow:  [255,255,224],
  lime: [0,255,0],
  limegreen:  [50,205,50],
  linen:  [250,240,230],
  magenta:  [255,0,255],
  maroon: [128,0,0],
  mediumaquamarine: [102,205,170],
  mediumblue: [0,0,205],
  mediumorchid: [186,85,211],
  mediumpurple: [147,112,219],
  mediumseagreen: [60,179,113],
  mediumslateblue:  [123,104,238],
  mediumspringgreen:  [0,250,154],
  mediumturquoise:  [72,209,204],
  mediumvioletred:  [199,21,133],
  midnightblue: [25,25,112],
  mintcream:  [245,255,250],
  mistyrose:  [255,228,225],
  moccasin: [255,228,181],
  navajowhite:  [255,222,173],
  navy: [0,0,128],
  oldlace:  [253,245,230],
  olive:  [128,128,0],
  olivedrab:  [107,142,35],
  orange: [255,165,0],
  orangered:  [255,69,0],
  orchid: [218,112,214],
  palegoldenrod:  [238,232,170],
  palegreen:  [152,251,152],
  paleturquoise:  [175,238,238],
  palevioletred:  [219,112,147],
  papayawhip: [255,239,213],
  peachpuff:  [255,218,185],
  peru: [205,133,63],
  pink: [255,192,203],
  plum: [221,160,221],
  powderblue: [176,224,230],
  purple: [128,0,128],
  rebeccapurple: [102, 51, 153],
  red:  [255,0,0],
  rosybrown:  [188,143,143],
  royalblue:  [65,105,225],
  saddlebrown:  [139,69,19],
  salmon: [250,128,114],
  sandybrown: [244,164,96],
  seagreen: [46,139,87],
  seashell: [255,245,238],
  sienna: [160,82,45],
  silver: [192,192,192],
  skyblue:  [135,206,235],
  slateblue:  [106,90,205],
  slategray:  [112,128,144],
  slategrey:  [112,128,144],
  snow: [255,250,250],
  springgreen:  [0,255,127],
  steelblue:  [70,130,180],
  tan:  [210,180,140],
  teal: [0,128,128],
  thistle:  [216,191,216],
  tomato: [255,99,71],
  turquoise:  [64,224,208],
  violet: [238,130,238],
  wheat:  [245,222,179],
  white:  [255,255,255],
  whitesmoke: [245,245,245],
  yellow: [255,255,0],
  yellowgreen:  [154,205,50]
};

var reverseKeywords = {};
for (var key in cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}

},{}],3:[function(require,module,exports){
var conversions = require("./conversions");

var convert = function() {
   return new Converter();
}

for (var func in conversions) {
  // export Raw versions
  convert[func + "Raw"] =  (function(func) {
    // accept array or plain args
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      return conversions[func](arg);
    }
  })(func);

  var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

  // export rgb2hsl and ["rgb"]["hsl"]
  convert[from] = convert[from] || {};

  convert[from][to] = convert[func] = (function(func) { 
    return function(arg) {
      if (typeof arg == "number")
        arg = Array.prototype.slice.call(arguments);
      
      var val = conversions[func](arg);
      if (typeof val == "string" || val === undefined)
        return val; // keyword

      for (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      return val;
    }
  })(func);
}


/* Converter does lazy conversion and caching */
var Converter = function() {
   this.convs = {};
};

/* Either get the values for a space or
  set the values for a space, depending on args */
Converter.prototype.routeSpace = function(space, args) {
   var values = args[0];
   if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof values == "number") {
      values = Array.prototype.slice.call(args);        
   }

   return this.setValues(space, values);
};
  
/* Set the values for a space, invalidating cache */
Converter.prototype.setValues = function(space, values) {
   this.space = space;
   this.convs = {};
   this.convs[space] = values;
   return this;
};

/* Get the values for a space. If there's already
  a conversion for the space, fetch it, otherwise
  compute it */
Converter.prototype.getValues = function(space) {
   var vals = this.convs[space];
   if (!vals) {
      var fspace = this.space,
          from = this.convs[fspace];
      vals = convert[fspace][space](from);

      this.convs[space] = vals;
   }
  return vals;
};

["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
   Converter.prototype[space] = function(vals) {
      return this.routeSpace(space, arguments);
   }
});

module.exports = convert;
},{"./conversions":2}],4:[function(require,module,exports){
module.exports={
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
}
},{}],5:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');

module.exports = {
   getRgba: getRgba,
   getHsla: getHsla,
   getRgb: getRgb,
   getHsl: getHsl,
   getHwb: getHwb,
   getAlpha: getAlpha,

   hexString: hexString,
   rgbString: rgbString,
   rgbaString: rgbaString,
   percentString: percentString,
   percentaString: percentaString,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   keyword: keyword
}

function getRgba(string) {
   if (!string) {
      return;
   }
   var abbr =  /^#([a-fA-F0-9]{3})$/,
       hex =  /^#([a-fA-F0-9]{6})$/,
       rgba = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d\.]+)\s*)?\)$/,
       per = /^rgba?\(\s*([\d\.]+)\%\s*,\s*([\d\.]+)\%\s*,\s*([\d\.]+)\%\s*(?:,\s*([\d\.]+)\s*)?\)$/,
       keyword = /(\D+)/;

   var rgb = [0, 0, 0],
       a = 1,
       match = string.match(abbr);
   if (match) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   }
   else if (match = string.match(hex)) {
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   }
   else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
   }
   else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
         return [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      if (!rgb) {
         return;
      }
   }

   for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
   }
   if (!a && a != 0) {
      a = 1;
   }
   else {
      a = scale(a, 0, 1);
   }
   rgb[3] = a;
   return rgb;
}

function getHsla(string) {
   if (!string) {
      return;
   }
   var hsl = /^hsla?\(\s*(\d+)(?:deg)?\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*(?:,\s*([\d\.]+)\s*)?\)/;
   var match = string.match(hsl);
   if (match) {
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(parseFloat(match[4]) || 1, 0, 1);
      return [h, s, l, a];
   }
}

function getHwb(string) {
   if (!string) {
      return;
   }
   var hwb = /^hwb\(\s*(\d+)(?:deg)?\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*(?:,\s*([\d\.]+)\s*)?\)/;
   var match = string.match(hwb);
   if (match) {
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(parseFloat(match[4]) || 1, 0, 1);
      return [h, w, b, a];
   }
}

function getRgb(string) {
   var rgba = getRgba(string);
   return rgba && rgba.slice(0, 3);
}

function getHsl(string) {
  var hsla = getHsla(string);
  return hsla && hsla.slice(0, 3);
}

function getAlpha(string) {
   var vals = getRgba(string);
   if (vals) {
      return vals[3];
   }
   else if (vals = getHsla(string)) {
      return vals[3];
   }
   else if (vals = getHwb(string)) {
      return vals[3];
   }
}

// generators
function hexString(rgb) {
   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
              + hexDouble(rgb[2]);
}

function rgbString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return rgbaString(rgba, alpha);
   }
   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

function rgbaString(rgba, alpha) {
   if (alpha === undefined) {
      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
   }
   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + alpha + ")";
}

function percentString(rgba, alpha) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      return percentaString(rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);

   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

function percentaString(rgba, alpha) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Math.round(rgba[1]/255 * 100),
       b = Math.round(rgba[2]/255 * 100);
   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}

function hslString(hsla, alpha) {
   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
      return hslaString(hsla, alpha);
   }
   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

function hslaString(hsla, alpha) {
   if (alpha === undefined) {
      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
   }
   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + alpha + ")";
}

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function hwbString(hwb, alpha) {
   if (alpha === undefined) {
      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}

function keyword(rgb) {
  return reverseNames[rgb.slice(0, 3)];
}

// helpers
function scale(num, min, max) {
   return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
  var str = num.toString(16).toUpperCase();
  return (str.length < 2) ? "0" + str : str;
}


//create a list of reverse color names
var reverseNames = {};
for (var name in colorNames) {
   reverseNames[colorNames[name]] = name;
}
},{"color-name":4}],6:[function(require,module,exports){
/* MIT license */
var convert = require("color-convert"),
    string = require("color-string");

var Color = function(cssString) {
  if (cssString instanceof Color) return cssString;
  if (! (this instanceof Color)) return new Color(cssString);

   this.values = {
      rgb: [0, 0, 0],
      hsl: [0, 0, 0],
      hsv: [0, 0, 0],
      hwb: [0, 0, 0],
      cmyk: [0, 0, 0, 0],
      alpha: 1
   }

   // parse Color() argument
   if (typeof cssString == "string") {
      var vals = string.getRgba(cssString);
      if (vals) {
         this.setValues("rgb", vals);
      }
      else if(vals = string.getHsla(cssString)) {
         this.setValues("hsl", vals);
      }
      else if(vals = string.getHwb(cssString)) {
         this.setValues("hwb", vals);
      }
      else {
        throw new Error("Unable to parse color from string \"" + cssString + "\"");
      }
   }
   else if (typeof cssString == "object") {
      var vals = cssString;
      if(vals["r"] !== undefined || vals["red"] !== undefined) {
         this.setValues("rgb", vals)
      }
      else if(vals["l"] !== undefined || vals["lightness"] !== undefined) {
         this.setValues("hsl", vals)
      }
      else if(vals["v"] !== undefined || vals["value"] !== undefined) {
         this.setValues("hsv", vals)
      }
      else if(vals["w"] !== undefined || vals["whiteness"] !== undefined) {
         this.setValues("hwb", vals)
      }
      else if(vals["c"] !== undefined || vals["cyan"] !== undefined) {
         this.setValues("cmyk", vals)
      }
      else {
        throw new Error("Unable to parse color from object " + JSON.stringify(cssString));
      }
   }
}

Color.prototype = {
   rgb: function (vals) {
      return this.setSpace("rgb", arguments);
   },
   hsl: function(vals) {
      return this.setSpace("hsl", arguments);
   },
   hsv: function(vals) {
      return this.setSpace("hsv", arguments);
   },
   hwb: function(vals) {
      return this.setSpace("hwb", arguments);
   },
   cmyk: function(vals) {
      return this.setSpace("cmyk", arguments);
   },

   rgbArray: function() {
      return this.values.rgb;
   },
   hslArray: function() {
      return this.values.hsl;
   },
   hsvArray: function() {
      return this.values.hsv;
   },
   hwbArray: function() {
      if (this.values.alpha !== 1) {
        return this.values.hwb.concat([this.values.alpha])
      }
      return this.values.hwb;
   },
   cmykArray: function() {
      return this.values.cmyk;
   },
   rgbaArray: function() {
      var rgb = this.values.rgb;
      return rgb.concat([this.values.alpha]);
   },
   hslaArray: function() {
      var hsl = this.values.hsl;
      return hsl.concat([this.values.alpha]);
   },
   alpha: function(val) {
      if (val === undefined) {
         return this.values.alpha;
      }
      this.setValues("alpha", val);
      return this;
   },

   red: function(val) {
      return this.setChannel("rgb", 0, val);
   },
   green: function(val) {
      return this.setChannel("rgb", 1, val);
   },
   blue: function(val) {
      return this.setChannel("rgb", 2, val);
   },
   hue: function(val) {
      return this.setChannel("hsl", 0, val);
   },
   saturation: function(val) {
      return this.setChannel("hsl", 1, val);
   },
   lightness: function(val) {
      return this.setChannel("hsl", 2, val);
   },
   saturationv: function(val) {
      return this.setChannel("hsv", 1, val);
   },
   whiteness: function(val) {
      return this.setChannel("hwb", 1, val);
   },
   blackness: function(val) {
      return this.setChannel("hwb", 2, val);
   },
   value: function(val) {
      return this.setChannel("hsv", 2, val);
   },
   cyan: function(val) {
      return this.setChannel("cmyk", 0, val);
   },
   magenta: function(val) {
      return this.setChannel("cmyk", 1, val);
   },
   yellow: function(val) {
      return this.setChannel("cmyk", 2, val);
   },
   black: function(val) {
      return this.setChannel("cmyk", 3, val);
   },

   hexString: function() {
      return string.hexString(this.values.rgb);
   },
   rgbString: function() {
      return string.rgbString(this.values.rgb, this.values.alpha);
   },
   rgbaString: function() {
      return string.rgbaString(this.values.rgb, this.values.alpha);
   },
   percentString: function() {
      return string.percentString(this.values.rgb, this.values.alpha);
   },
   hslString: function() {
      return string.hslString(this.values.hsl, this.values.alpha);
   },
   hslaString: function() {
      return string.hslaString(this.values.hsl, this.values.alpha);
   },
   hwbString: function() {
      return string.hwbString(this.values.hwb, this.values.alpha);
   },
   keyword: function() {
      return string.keyword(this.values.rgb, this.values.alpha);
   },

   rgbNumber: function() {
      return (this.values.rgb[0] << 16) | (this.values.rgb[1] << 8) | this.values.rgb[2];
   },

   luminosity: function() {
      // http://www.w3.org/TR/WCAG20/#relativeluminancedef
      var rgb = this.values.rgb;
      var lum = [];
      for (var i = 0; i < rgb.length; i++) {
         var chan = rgb[i] / 255;
         lum[i] = (chan <= 0.03928) ? chan / 12.92
                  : Math.pow(((chan + 0.055) / 1.055), 2.4)
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
   },

   contrast: function(color2) {
      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
         return (lum1 + 0.05) / (lum2 + 0.05)
      };
      return (lum2 + 0.05) / (lum1 + 0.05);
   },

   level: function(color2) {
     var contrastRatio = this.contrast(color2);
     return (contrastRatio >= 7.1)
       ? 'AAA'
       : (contrastRatio >= 4.5)
        ? 'AA'
        : '';
   },

   dark: function() {
      // YIQ equation from http://24ways.org/2010/calculating-color-contrast
      var rgb = this.values.rgb,
          yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
   	return yiq < 128;
   },

   light: function() {
      return !this.dark();
   },

   negate: function() {
      var rgb = []
      for (var i = 0; i < 3; i++) {
         rgb[i] = 255 - this.values.rgb[i];
      }
      this.setValues("rgb", rgb);
      return this;
   },

   lighten: function(ratio) {
      this.values.hsl[2] += this.values.hsl[2] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   darken: function(ratio) {
      this.values.hsl[2] -= this.values.hsl[2] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   saturate: function(ratio) {
      this.values.hsl[1] += this.values.hsl[1] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   desaturate: function(ratio) {
      this.values.hsl[1] -= this.values.hsl[1] * ratio;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   whiten: function(ratio) {
      this.values.hwb[1] += this.values.hwb[1] * ratio;
      this.setValues("hwb", this.values.hwb);
      return this;
   },

   blacken: function(ratio) {
      this.values.hwb[2] += this.values.hwb[2] * ratio;
      this.setValues("hwb", this.values.hwb);
      return this;
   },

   greyscale: function() {
      var rgb = this.values.rgb;
      // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      this.setValues("rgb", [val, val, val]);
      return this;
   },

   clearer: function(ratio) {
      this.setValues("alpha", this.values.alpha - (this.values.alpha * ratio));
      return this;
   },

   opaquer: function(ratio) {
      this.setValues("alpha", this.values.alpha + (this.values.alpha * ratio));
      return this;
   },

   rotate: function(degrees) {
      var hue = this.values.hsl[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      this.values.hsl[0] = hue;
      this.setValues("hsl", this.values.hsl);
      return this;
   },

   mix: function(color2, weight) {
      weight = 1 - (weight == null ? 0.5 : weight);

      // algorithm from Sass's mix(). Ratio of first color in mix is
      // determined by the alphas of both colors and the weight
      var t1 = weight * 2 - 1,
          d = this.alpha() - color2.alpha();

      var weight1 = (((t1 * d == -1) ? t1 : (t1 + d) / (1 + t1 * d)) + 1) / 2;
      var weight2 = 1 - weight1;

      var rgb = this.rgbArray();
      var rgb2 = color2.rgbArray();

      for (var i = 0; i < rgb.length; i++) {
         rgb[i] = rgb[i] * weight1 + rgb2[i] * weight2;
      }
      this.setValues("rgb", rgb);

      var alpha = this.alpha() * weight + color2.alpha() * (1 - weight);
      this.setValues("alpha", alpha);

      return this;
   },

   toJSON: function() {
     return this.rgb();
   },

   clone: function() {
     return new Color(this.rgb());
   }
}


Color.prototype.getValues = function(space) {
   var vals = {};
   for (var i = 0; i < space.length; i++) {
      vals[space[i]] = this.values[space][i];
   }
   if (this.values.alpha != 1) {
      vals["a"] = this.values.alpha;
   }
   // {r: 255, g: 255, b: 255, a: 0.4}
   return vals;
}

Color.prototype.setValues = function(space, vals) {
   var spaces = {
      "rgb": ["red", "green", "blue"],
      "hsl": ["hue", "saturation", "lightness"],
      "hsv": ["hue", "saturation", "value"],
      "hwb": ["hue", "whiteness", "blackness"],
      "cmyk": ["cyan", "magenta", "yellow", "black"]
   };

   var maxes = {
      "rgb": [255, 255, 255],
      "hsl": [360, 100, 100],
      "hsv": [360, 100, 100],
      "hwb": [360, 100, 100],
      "cmyk": [100, 100, 100, 100]
   };

   var alpha = 1;
   if (space == "alpha") {
      alpha = vals;
   }
   else if (vals.length) {
      // [10, 10, 10]
      this.values[space] = vals.slice(0, space.length);
      alpha = vals[space.length];
   }
   else if (vals[space[0]] !== undefined) {
      // {r: 10, g: 10, b: 10}
      for (var i = 0; i < space.length; i++) {
        this.values[space][i] = vals[space[i]];
      }
      alpha = vals.a;
   }
   else if (vals[spaces[space][0]] !== undefined) {
      // {red: 10, green: 10, blue: 10}
      var chans = spaces[space];
      for (var i = 0; i < space.length; i++) {
        this.values[space][i] = vals[chans[i]];
      }
      alpha = vals.alpha;
   }
   this.values.alpha = Math.max(0, Math.min(1, (alpha !== undefined ? alpha : this.values.alpha) ));
   if (space == "alpha") {
      return;
   }

   // cap values of the space prior converting all values
   for (var i = 0; i < space.length; i++) {
      var capped = Math.max(0, Math.min(maxes[space][i], this.values[space][i]));
      this.values[space][i] = Math.round(capped);
   }

   // convert to all the other color spaces
   for (var sname in spaces) {
      if (sname != space) {
         this.values[sname] = convert[space][sname](this.values[space])
      }

      // cap values
      for (var i = 0; i < sname.length; i++) {
         var capped = Math.max(0, Math.min(maxes[sname][i], this.values[sname][i]));
         this.values[sname][i] = Math.round(capped);
      }
   }
   return true;
}

Color.prototype.setSpace = function(space, args) {
   var vals = args[0];
   if (vals === undefined) {
      // color.rgb()
      return this.getValues(space);
   }
   // color.rgb(10, 10, 10)
   if (typeof vals == "number") {
      vals = Array.prototype.slice.call(args);
   }
   this.setValues(space, vals);
   return this;
}

Color.prototype.setChannel = function(space, index, val) {
   if (val === undefined) {
      // color.red()
      return this.values[space][index];
   }
   // color.red(100)
   this.values[space][index] = val;
   this.setValues(space, this.values[space]);
   return this;
}

module.exports = Color;

},{"color-convert":3,"color-string":5}],7:[function(require,module,exports){
/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
(function (window, document, Math) {
var rAF = window.requestAnimationFrame	||
	window.webkitRequestAnimationFrame	||
	window.mozRequestAnimationFrame		||
	window.oRequestAnimationFrame		||
	window.msRequestAnimationFrame		||
	function (callback) { window.setTimeout(callback, 1000 / 60); };

var utils = (function () {
	var me = {};

	var _elementStyle = document.createElement('div').style;
	var _vendor = (function () {
		var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			transform,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			transform = vendors[i] + 'ransform';
			if ( transform in _elementStyle ) return vendors[i].substr(0, vendors[i].length-1);
		}

		return false;
	})();

	function _prefixStyle (style) {
		if ( _vendor === false ) return false;
		if ( _vendor === '' ) return style;
		return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
	}

	me.getTime = Date.now || function getTime () { return new Date().getTime(); };

	me.extend = function (target, obj) {
		for ( var i in obj ) {
			target[i] = obj[i];
		}
	};

	me.addEvent = function (el, type, fn, capture) {
		el.addEventListener(type, fn, !!capture);
	};

	me.removeEvent = function (el, type, fn, capture) {
		el.removeEventListener(type, fn, !!capture);
	};

	me.prefixPointerEvent = function (pointerEvent) {
		return window.MSPointerEvent ?
			'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8):
			pointerEvent;
	};

	me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
		var distance = current - start,
			speed = Math.abs(distance) / time,
			destination,
			duration;

		deceleration = deceleration === undefined ? 0.0006 : deceleration;

		destination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance < 0 ? -1 : 1 );
		duration = speed / deceleration;

		if ( destination < lowerMargin ) {
			destination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin;
			distance = Math.abs(destination - current);
			duration = distance / speed;
		} else if ( destination > 0 ) {
			destination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0;
			distance = Math.abs(current) + destination;
			duration = distance / speed;
		}

		return {
			destination: Math.round(destination),
			duration: duration
		};
	};

	var _transform = _prefixStyle('transform');

	me.extend(me, {
		hasTransform: _transform !== false,
		hasPerspective: _prefixStyle('perspective') in _elementStyle,
		hasTouch: 'ontouchstart' in window,
		hasPointer: !!(window.PointerEvent || window.MSPointerEvent), // IE10 is prefixed
		hasTransition: _prefixStyle('transition') in _elementStyle
	});

	/*
	This should find all Android browsers lower than build 535.19 (both stock browser and webview)
	- galaxy S2 is ok
    - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`
    - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S3 is badAndroid (stock brower, webview)
     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S4 is badAndroid (stock brower, webview)
     `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
   - galaxy S5 is OK
     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
   - galaxy S6 is OK
     `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
  */
	me.isBadAndroid = (function() {
		var appVersion = window.navigator.appVersion;
		// Android browser is not a chrome browser.
		if (/Android/.test(appVersion) && !(/Chrome\/\d/.test(appVersion))) {
			var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);
			if(safariVersion && typeof safariVersion === "object" && safariVersion.length >= 2) {
				return parseFloat(safariVersion[1]) < 535.19;
			} else {
				return true;
			}
		} else {
			return false;
		}
	})();

	me.extend(me.style = {}, {
		transform: _transform,
		transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
		transitionDuration: _prefixStyle('transitionDuration'),
		transitionDelay: _prefixStyle('transitionDelay'),
		transformOrigin: _prefixStyle('transformOrigin')
	});

	me.hasClass = function (e, c) {
		var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
		return re.test(e.className);
	};

	me.addClass = function (e, c) {
		if ( me.hasClass(e, c) ) {
			return;
		}

		var newclass = e.className.split(' ');
		newclass.push(c);
		e.className = newclass.join(' ');
	};

	me.removeClass = function (e, c) {
		if ( !me.hasClass(e, c) ) {
			return;
		}

		var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
		e.className = e.className.replace(re, ' ');
	};

	me.offset = function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;

		// jshint -W084
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		// jshint +W084

		return {
			left: left,
			top: top
		};
	};

	me.preventDefaultException = function (el, exceptions) {
		for ( var i in exceptions ) {
			if ( exceptions[i].test(el[i]) ) {
				return true;
			}
		}

		return false;
	};

	me.extend(me.eventType = {}, {
		touchstart: 1,
		touchmove: 1,
		touchend: 1,

		mousedown: 2,
		mousemove: 2,
		mouseup: 2,

		pointerdown: 3,
		pointermove: 3,
		pointerup: 3,

		MSPointerDown: 3,
		MSPointerMove: 3,
		MSPointerUp: 3
	});

	me.extend(me.ease = {}, {
		quadratic: {
			style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
			fn: function (k) {
				return k * ( 2 - k );
			}
		},
		circular: {
			style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',	// Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
			fn: function (k) {
				return Math.sqrt( 1 - ( --k * k ) );
			}
		},
		back: {
			style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
			fn: function (k) {
				var b = 4;
				return ( k = k - 1 ) * k * ( ( b + 1 ) * k + b ) + 1;
			}
		},
		bounce: {
			style: '',
			fn: function (k) {
				if ( ( k /= 1 ) < ( 1 / 2.75 ) ) {
					return 7.5625 * k * k;
				} else if ( k < ( 2 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;
				} else if ( k < ( 2.5 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;
				} else {
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;
				}
			}
		},
		elastic: {
			style: '',
			fn: function (k) {
				var f = 0.22,
					e = 0.4;

				if ( k === 0 ) { return 0; }
				if ( k == 1 ) { return 1; }

				return ( e * Math.pow( 2, - 10 * k ) * Math.sin( ( k - f / 4 ) * ( 2 * Math.PI ) / f ) + 1 );
			}
		}
	});

	me.tap = function (e, eventName) {
		var ev = document.createEvent('Event');
		ev.initEvent(eventName, true, true);
		ev.pageX = e.pageX;
		ev.pageY = e.pageY;
		e.target.dispatchEvent(ev);
	};

	me.click = function (e) {
		var target = e.target,
			ev;

		if ( !(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName) ) {
			ev = document.createEvent('MouseEvents');
			ev.initMouseEvent('click', true, true, e.view, 1,
				target.screenX, target.screenY, target.clientX, target.clientY,
				e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
				0, null);

			ev._constructed = true;
			target.dispatchEvent(ev);
		}
	};

	return me;
})();
function IScroll (el, options) {
	this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
	this.scroller = this.wrapper.children[0];
	this.scrollerStyle = this.scroller.style;		// cache style for better performance

	this.options = {

		resizeScrollbars: true,

		mouseWheelSpeed: 20,

		snapThreshold: 0.334,

// INSERT POINT: OPTIONS
		disablePointer : !utils.hasPointer,
		disableTouch : utils.hasPointer || !utils.hasTouch,
		disableMouse : utils.hasPointer || utils.hasTouch,
		startX: 0,
		startY: 0,
		scrollY: true,
		directionLockThreshold: 5,
		momentum: true,

		bounce: true,
		bounceTime: 600,
		bounceEasing: '',

		preventDefault: true,
		preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

		HWCompositing: true,
		useTransition: true,
		useTransform: true,
		bindToWrapper: typeof window.onmousedown === "undefined"
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	// Normalize options
	this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

	this.options.useTransition = utils.hasTransition && this.options.useTransition;
	this.options.useTransform = utils.hasTransform && this.options.useTransform;

	this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
	this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

	// If you want eventPassthrough I have to lock one of the axes
	this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
	this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

	// With eventPassthrough we also need lockDirection mechanism
	this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
	this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

	this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

	this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

	if ( this.options.tap === true ) {
		this.options.tap = 'tap';
	}

	if ( this.options.shrinkScrollbars == 'scale' ) {
		this.options.useTransition = false;
	}

	this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

// INSERT POINT: NORMALIZATION

	// Some defaults
	this.x = 0;
	this.y = 0;
	this.directionX = 0;
	this.directionY = 0;
	this._events = {};

// INSERT POINT: DEFAULTS

	this._init();
	this.refresh();

	this.scrollTo(this.options.startX, this.options.startY);
	this.enable();
}

IScroll.prototype = {
	version: '5.2.0',

	_init: function () {
		this._initEvents();

		if ( this.options.scrollbars || this.options.indicators ) {
			this._initIndicators();
		}

		if ( this.options.mouseWheel ) {
			this._initWheel();
		}

		if ( this.options.snap ) {
			this._initSnap();
		}

		if ( this.options.keyBindings ) {
			this._initKeys();
		}

// INSERT POINT: _init

	},

	destroy: function () {
		this._initEvents(true);
		clearTimeout(this.resizeTimeout);
 		this.resizeTimeout = null;
		this._execEvent('destroy');
	},

	_transitionEnd: function (e) {
		if ( e.target != this.scroller || !this.isInTransition ) {
			return;
		}

		this._transitionTime();
		if ( !this.resetPosition(this.options.bounceTime) ) {
			this.isInTransition = false;
			this._execEvent('scrollEnd');
		}
	},

	_start: function (e) {
		// React to left mouse button only
		if ( utils.eventType[e.type] != 1 ) {
		  // for button property
		  // http://unixpapa.com/js/mouse.html
		  var button;
	    if (!e.which) {
	      /* IE case */
	      button = (e.button < 2) ? 0 :
	               ((e.button == 4) ? 1 : 2);
	    } else {
	      /* All others */
	      button = e.button;
	    }
			if ( button !== 0 ) {
				return;
			}
		}

		if ( !this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated) ) {
			return;
		}

		if ( this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.touches ? e.touches[0] : e,
			pos;

		this.initiated	= utils.eventType[e.type];
		this.moved		= false;
		this.distX		= 0;
		this.distY		= 0;
		this.directionX = 0;
		this.directionY = 0;
		this.directionLocked = 0;

		this.startTime = utils.getTime();

		if ( this.options.useTransition && this.isInTransition ) {
			this._transitionTime();
			this.isInTransition = false;
			pos = this.getComputedPosition();
			this._translate(Math.round(pos.x), Math.round(pos.y));
			this._execEvent('scrollEnd');
		} else if ( !this.options.useTransition && this.isAnimating ) {
			this.isAnimating = false;
			this._execEvent('scrollEnd');
		}

		this.startX    = this.x;
		this.startY    = this.y;
		this.absStartX = this.x;
		this.absStartY = this.y;
		this.pointX    = point.pageX;
		this.pointY    = point.pageY;

		this._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault ) {	// increases performance on Android? TODO: check!
			e.preventDefault();
		}

		var point		= e.touches ? e.touches[0] : e,
			deltaX		= point.pageX - this.pointX,
			deltaY		= point.pageY - this.pointY,
			timestamp	= utils.getTime(),
			newX, newY,
			absDistX, absDistY;

		this.pointX		= point.pageX;
		this.pointY		= point.pageY;

		this.distX		+= deltaX;
		this.distY		+= deltaY;
		absDistX		= Math.abs(this.distX);
		absDistY		= Math.abs(this.distY);

		// We need to move at least 10 pixels for the scrolling to initiate
		if ( timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10) ) {
			return;
		}

		// If you are scrolling in one direction lock the other
		if ( !this.directionLocked && !this.options.freeScroll ) {
			if ( absDistX > absDistY + this.options.directionLockThreshold ) {
				this.directionLocked = 'h';		// lock horizontally
			} else if ( absDistY >= absDistX + this.options.directionLockThreshold ) {
				this.directionLocked = 'v';		// lock vertically
			} else {
				this.directionLocked = 'n';		// no lock
			}
		}

		if ( this.directionLocked == 'h' ) {
			if ( this.options.eventPassthrough == 'vertical' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'horizontal' ) {
				this.initiated = false;
				return;
			}

			deltaY = 0;
		} else if ( this.directionLocked == 'v' ) {
			if ( this.options.eventPassthrough == 'horizontal' ) {
				e.preventDefault();
			} else if ( this.options.eventPassthrough == 'vertical' ) {
				this.initiated = false;
				return;
			}

			deltaX = 0;
		}

		deltaX = this.hasHorizontalScroll ? deltaX : 0;
		deltaY = this.hasVerticalScroll ? deltaY : 0;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		// Slow down if outside of the boundaries
		if ( newX > 0 || newX < this.maxScrollX ) {
			newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
		}
		if ( newY > 0 || newY < this.maxScrollY ) {
			newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
		}

		this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if ( !this.moved ) {
			this._execEvent('scrollStart');
		}

		this.moved = true;

		this._translate(newX, newY);

/* REPLACE START: _move */

		if ( timestamp - this.startTime > 300 ) {
			this.startTime = timestamp;
			this.startX = this.x;
			this.startY = this.y;
		}

/* REPLACE END: _move */

	},

	_end: function (e) {
		if ( !this.enabled || utils.eventType[e.type] !== this.initiated ) {
			return;
		}

		if ( this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException) ) {
			e.preventDefault();
		}

		var point = e.changedTouches ? e.changedTouches[0] : e,
			momentumX,
			momentumY,
			duration = utils.getTime() - this.startTime,
			newX = Math.round(this.x),
			newY = Math.round(this.y),
			distanceX = Math.abs(newX - this.startX),
			distanceY = Math.abs(newY - this.startY),
			time = 0,
			easing = '';

		this.isInTransition = 0;
		this.initiated = 0;
		this.endTime = utils.getTime();

		// reset if we are outside of the boundaries
		if ( this.resetPosition(this.options.bounceTime) ) {
			return;
		}

		this.scrollTo(newX, newY);	// ensures that the last position is rounded

		// we scrolled less than 10 pixels
		if ( !this.moved ) {
			if ( this.options.tap ) {
				utils.tap(e, this.options.tap);
			}

			if ( this.options.click ) {
				utils.click(e);
			}

			this._execEvent('scrollCancel');
			return;
		}

		if ( this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100 ) {
			this._execEvent('flick');
			return;
		}

		// start momentum animation if needed
		if ( this.options.momentum && duration < 300 ) {
			momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
			momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
			newX = momentumX.destination;
			newY = momentumY.destination;
			time = Math.max(momentumX.duration, momentumY.duration);
			this.isInTransition = 1;
		}


		if ( this.options.snap ) {
			var snap = this._nearestSnap(newX, newY);
			this.currentPage = snap;
			time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(newX - snap.x), 1000),
						Math.min(Math.abs(newY - snap.y), 1000)
					), 300);
			newX = snap.x;
			newY = snap.y;

			this.directionX = 0;
			this.directionY = 0;
			easing = this.options.bounceEasing;
		}

// INSERT POINT: _end

		if ( newX != this.x || newY != this.y ) {
			// change easing function when scroller goes out of the boundaries
			if ( newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY ) {
				easing = utils.ease.quadratic;
			}

			this.scrollTo(newX, newY, time, easing);
			return;
		}

		this._execEvent('scrollEnd');
	},

	_resize: function () {
		var that = this;

		clearTimeout(this.resizeTimeout);

		this.resizeTimeout = setTimeout(function () {
			that.refresh();
		}, this.options.resizePolling);
	},

	resetPosition: function (time) {
		var x = this.x,
			y = this.y;

		time = time || 0;

		if ( !this.hasHorizontalScroll || this.x > 0 ) {
			x = 0;
		} else if ( this.x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( !this.hasVerticalScroll || this.y > 0 ) {
			y = 0;
		} else if ( this.y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		if ( x == this.x && y == this.y ) {
			return false;
		}

		this.scrollTo(x, y, time, this.options.bounceEasing);

		return true;
	},

	disable: function () {
		this.enabled = false;
	},

	enable: function () {
		this.enabled = true;
	},

	refresh: function () {
		var rf = this.wrapper.offsetHeight;		// Force reflow

		this.wrapperWidth	= this.wrapper.clientWidth;
		this.wrapperHeight	= this.wrapper.clientHeight;

/* REPLACE START: refresh */

		this.scrollerWidth	= this.scroller.offsetWidth;
		this.scrollerHeight	= this.scroller.offsetHeight;

		this.maxScrollX		= this.wrapperWidth - this.scrollerWidth;
		this.maxScrollY		= this.wrapperHeight - this.scrollerHeight;

/* REPLACE END: refresh */

		this.hasHorizontalScroll	= this.options.scrollX && this.maxScrollX < 0;
		this.hasVerticalScroll		= this.options.scrollY && this.maxScrollY < 0;

		if ( !this.hasHorizontalScroll ) {
			this.maxScrollX = 0;
			this.scrollerWidth = this.wrapperWidth;
		}

		if ( !this.hasVerticalScroll ) {
			this.maxScrollY = 0;
			this.scrollerHeight = this.wrapperHeight;
		}

		this.endTime = 0;
		this.directionX = 0;
		this.directionY = 0;

		this.wrapperOffset = utils.offset(this.wrapper);

		this._execEvent('refresh');

		this.resetPosition();

// INSERT POINT: _refresh

	},

	on: function (type, fn) {
		if ( !this._events[type] ) {
			this._events[type] = [];
		}

		this._events[type].push(fn);
	},

	off: function (type, fn) {
		if ( !this._events[type] ) {
			return;
		}

		var index = this._events[type].indexOf(fn);

		if ( index > -1 ) {
			this._events[type].splice(index, 1);
		}
	},

	_execEvent: function (type) {
		if ( !this._events[type] ) {
			return;
		}

		var i = 0,
			l = this._events[type].length;

		if ( !l ) {
			return;
		}

		for ( ; i < l; i++ ) {
			this._events[type][i].apply(this, [].slice.call(arguments, 1));
		}
	},

	scrollBy: function (x, y, time, easing) {
		x = this.x + x;
		y = this.y + y;
		time = time || 0;

		this.scrollTo(x, y, time, easing);
	},

	scrollTo: function (x, y, time, easing) {
		easing = easing || utils.ease.circular;

		this.isInTransition = this.options.useTransition && time > 0;
		var transitionType = this.options.useTransition && easing.style;
		if ( !time || transitionType ) {
				if(transitionType) {
					this._transitionTimingFunction(easing.style);
					this._transitionTime(time);
				}
			this._translate(x, y);
		} else {
			this._animate(x, y, time, easing.fn);
		}
	},

	scrollToElement: function (el, time, offsetX, offsetY, easing) {
		el = el.nodeType ? el : this.scroller.querySelector(el);

		if ( !el ) {
			return;
		}

		var pos = utils.offset(el);

		pos.left -= this.wrapperOffset.left;
		pos.top  -= this.wrapperOffset.top;

		// if offsetX/Y are true we center the element to the screen
		if ( offsetX === true ) {
			offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
		}
		if ( offsetY === true ) {
			offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
		}

		pos.left -= offsetX || 0;
		pos.top  -= offsetY || 0;

		pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
		pos.top  = pos.top  > 0 ? 0 : pos.top  < this.maxScrollY ? this.maxScrollY : pos.top;

		time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x-pos.left), Math.abs(this.y-pos.top)) : time;

		this.scrollTo(pos.left, pos.top, time, easing);
	},

	_transitionTime: function (time) {
		time = time || 0;

		var durationProp = utils.style.transitionDuration;
		this.scrollerStyle[durationProp] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.scrollerStyle[durationProp] = '0.0001ms';
			// remove 0.0001ms
			var self = this;
			rAF(function() {
				if(self.scrollerStyle[durationProp] === '0.0001ms') {
					self.scrollerStyle[durationProp] = '0s';
				}
			});
		}


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTime(time);
			}
		}


// INSERT POINT: _transitionTime

	},

	_transitionTimingFunction: function (easing) {
		this.scrollerStyle[utils.style.transitionTimingFunction] = easing;


		if ( this.indicators ) {
			for ( var i = this.indicators.length; i--; ) {
				this.indicators[i].transitionTimingFunction(easing);
			}
		}


// INSERT POINT: _transitionTimingFunction

	},

	_translate: function (x, y) {
		if ( this.options.useTransform ) {

/* REPLACE START: _translate */

			this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

/* REPLACE END: _translate */

		} else {
			x = Math.round(x);
			y = Math.round(y);
			this.scrollerStyle.left = x + 'px';
			this.scrollerStyle.top = y + 'px';
		}

		this.x = x;
		this.y = y;


	if ( this.indicators ) {
		for ( var i = this.indicators.length; i--; ) {
			this.indicators[i].updatePosition();
		}
	}


// INSERT POINT: _translate

	},

	_initEvents: function (remove) {
		var eventType = remove ? utils.removeEvent : utils.addEvent,
			target = this.options.bindToWrapper ? this.wrapper : window;

		eventType(window, 'orientationchange', this);
		eventType(window, 'resize', this);

		if ( this.options.click ) {
			eventType(this.wrapper, 'click', this, true);
		}

		if ( !this.options.disableMouse ) {
			eventType(this.wrapper, 'mousedown', this);
			eventType(target, 'mousemove', this);
			eventType(target, 'mousecancel', this);
			eventType(target, 'mouseup', this);
		}

		if ( utils.hasPointer && !this.options.disablePointer ) {
			eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
			eventType(target, utils.prefixPointerEvent('pointermove'), this);
			eventType(target, utils.prefixPointerEvent('pointercancel'), this);
			eventType(target, utils.prefixPointerEvent('pointerup'), this);
		}

		if ( utils.hasTouch && !this.options.disableTouch ) {
			eventType(this.wrapper, 'touchstart', this);
			eventType(target, 'touchmove', this);
			eventType(target, 'touchcancel', this);
			eventType(target, 'touchend', this);
		}

		eventType(this.scroller, 'transitionend', this);
		eventType(this.scroller, 'webkitTransitionEnd', this);
		eventType(this.scroller, 'oTransitionEnd', this);
		eventType(this.scroller, 'MSTransitionEnd', this);
	},

	getComputedPosition: function () {
		var matrix = window.getComputedStyle(this.scroller, null),
			x, y;

		if ( this.options.useTransform ) {
			matrix = matrix[utils.style.transform].split(')')[0].split(', ');
			x = +(matrix[12] || matrix[4]);
			y = +(matrix[13] || matrix[5]);
		} else {
			x = +matrix.left.replace(/[^-\d.]/g, '');
			y = +matrix.top.replace(/[^-\d.]/g, '');
		}

		return { x: x, y: y };
	},
	_initIndicators: function () {
		var interactive = this.options.interactiveScrollbars,
			customStyle = typeof this.options.scrollbars != 'string',
			indicators = [],
			indicator;

		var that = this;

		this.indicators = [];

		if ( this.options.scrollbars ) {
			// Vertical scrollbar
			if ( this.options.scrollY ) {
				indicator = {
					el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenX: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}

			// Horizontal scrollbar
			if ( this.options.scrollX ) {
				indicator = {
					el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
					interactive: interactive,
					defaultScrollbars: true,
					customStyle: customStyle,
					resize: this.options.resizeScrollbars,
					shrink: this.options.shrinkScrollbars,
					fade: this.options.fadeScrollbars,
					listenY: false
				};

				this.wrapper.appendChild(indicator.el);
				indicators.push(indicator);
			}
		}

		if ( this.options.indicators ) {
			// TODO: check concat compatibility
			indicators = indicators.concat(this.options.indicators);
		}

		for ( var i = indicators.length; i--; ) {
			this.indicators.push( new Indicator(this, indicators[i]) );
		}

		// TODO: check if we can use array.map (wide compatibility and performance issues)
		function _indicatorsMap (fn) {
			if (that.indicators) {
				for ( var i = that.indicators.length; i--; ) {
					fn.call(that.indicators[i]);
				}
			}
		}

		if ( this.options.fadeScrollbars ) {
			this.on('scrollEnd', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollCancel', function () {
				_indicatorsMap(function () {
					this.fade();
				});
			});

			this.on('scrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1);
				});
			});

			this.on('beforeScrollStart', function () {
				_indicatorsMap(function () {
					this.fade(1, true);
				});
			});
		}


		this.on('refresh', function () {
			_indicatorsMap(function () {
				this.refresh();
			});
		});

		this.on('destroy', function () {
			_indicatorsMap(function () {
				this.destroy();
			});

			delete this.indicators;
		});
	},

	_initWheel: function () {
		utils.addEvent(this.wrapper, 'wheel', this);
		utils.addEvent(this.wrapper, 'mousewheel', this);
		utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

		this.on('destroy', function () {
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = null;
			utils.removeEvent(this.wrapper, 'wheel', this);
			utils.removeEvent(this.wrapper, 'mousewheel', this);
			utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
		});
	},

	_wheel: function (e) {
		if ( !this.enabled ) {
			return;
		}

		e.preventDefault();

		var wheelDeltaX, wheelDeltaY,
			newX, newY,
			that = this;

		if ( this.wheelTimeout === undefined ) {
			that._execEvent('scrollStart');
		}

		// Execute the scrollEnd event after 400ms the wheel stopped scrolling
		clearTimeout(this.wheelTimeout);
		this.wheelTimeout = setTimeout(function () {
			if(!that.options.snap) {
				that._execEvent('scrollEnd');
			}
			that.wheelTimeout = undefined;
		}, 400);

		if ( 'deltaX' in e ) {
			if (e.deltaMode === 1) {
				wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
				wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
			} else {
				wheelDeltaX = -e.deltaX;
				wheelDeltaY = -e.deltaY;
			}
		} else if ( 'wheelDeltaX' in e ) {
			wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
			wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
		} else if ( 'wheelDelta' in e ) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
		} else if ( 'detail' in e ) {
			wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
		} else {
			return;
		}

		wheelDeltaX *= this.options.invertWheelDirection;
		wheelDeltaY *= this.options.invertWheelDirection;

		if ( !this.hasVerticalScroll ) {
			wheelDeltaX = wheelDeltaY;
			wheelDeltaY = 0;
		}

		if ( this.options.snap ) {
			newX = this.currentPage.pageX;
			newY = this.currentPage.pageY;

			if ( wheelDeltaX > 0 ) {
				newX--;
			} else if ( wheelDeltaX < 0 ) {
				newX++;
			}

			if ( wheelDeltaY > 0 ) {
				newY--;
			} else if ( wheelDeltaY < 0 ) {
				newY++;
			}

			this.goToPage(newX, newY);

			return;
		}

		newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
		newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

		this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
		this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;

		if ( newX > 0 ) {
			newX = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
		}

		if ( newY > 0 ) {
			newY = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
		}

		this.scrollTo(newX, newY, 0);

// INSERT POINT: _wheel
	},

	_initSnap: function () {
		this.currentPage = {};

		if ( typeof this.options.snap == 'string' ) {
			this.options.snap = this.scroller.querySelectorAll(this.options.snap);
		}

		this.on('refresh', function () {
			var i = 0, l,
				m = 0, n,
				cx, cy,
				x = 0, y,
				stepX = this.options.snapStepX || this.wrapperWidth,
				stepY = this.options.snapStepY || this.wrapperHeight,
				el;

			this.pages = [];

			if ( !this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight ) {
				return;
			}

			if ( this.options.snap === true ) {
				cx = Math.round( stepX / 2 );
				cy = Math.round( stepY / 2 );

				while ( x > -this.scrollerWidth ) {
					this.pages[i] = [];
					l = 0;
					y = 0;

					while ( y > -this.scrollerHeight ) {
						this.pages[i][l] = {
							x: Math.max(x, this.maxScrollX),
							y: Math.max(y, this.maxScrollY),
							width: stepX,
							height: stepY,
							cx: x - cx,
							cy: y - cy
						};

						y -= stepY;
						l++;
					}

					x -= stepX;
					i++;
				}
			} else {
				el = this.options.snap;
				l = el.length;
				n = -1;

				for ( ; i < l; i++ ) {
					if ( i === 0 || el[i].offsetLeft <= el[i-1].offsetLeft ) {
						m = 0;
						n++;
					}

					if ( !this.pages[m] ) {
						this.pages[m] = [];
					}

					x = Math.max(-el[i].offsetLeft, this.maxScrollX);
					y = Math.max(-el[i].offsetTop, this.maxScrollY);
					cx = x - Math.round(el[i].offsetWidth / 2);
					cy = y - Math.round(el[i].offsetHeight / 2);

					this.pages[m][n] = {
						x: x,
						y: y,
						width: el[i].offsetWidth,
						height: el[i].offsetHeight,
						cx: cx,
						cy: cy
					};

					if ( x > this.maxScrollX ) {
						m++;
					}
				}
			}

			this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

			// Update snap threshold if needed
			if ( this.options.snapThreshold % 1 === 0 ) {
				this.snapThresholdX = this.options.snapThreshold;
				this.snapThresholdY = this.options.snapThreshold;
			} else {
				this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
				this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
			}
		});

		this.on('flick', function () {
			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.x - this.startX), 1000),
						Math.min(Math.abs(this.y - this.startY), 1000)
					), 300);

			this.goToPage(
				this.currentPage.pageX + this.directionX,
				this.currentPage.pageY + this.directionY,
				time
			);
		});
	},

	_nearestSnap: function (x, y) {
		if ( !this.pages.length ) {
			return { x: 0, y: 0, pageX: 0, pageY: 0 };
		}

		var i = 0,
			l = this.pages.length,
			m = 0;

		// Check if we exceeded the snap threshold
		if ( Math.abs(x - this.absStartX) < this.snapThresholdX &&
			Math.abs(y - this.absStartY) < this.snapThresholdY ) {
			return this.currentPage;
		}

		if ( x > 0 ) {
			x = 0;
		} else if ( x < this.maxScrollX ) {
			x = this.maxScrollX;
		}

		if ( y > 0 ) {
			y = 0;
		} else if ( y < this.maxScrollY ) {
			y = this.maxScrollY;
		}

		for ( ; i < l; i++ ) {
			if ( x >= this.pages[i][0].cx ) {
				x = this.pages[i][0].x;
				break;
			}
		}

		l = this.pages[i].length;

		for ( ; m < l; m++ ) {
			if ( y >= this.pages[0][m].cy ) {
				y = this.pages[0][m].y;
				break;
			}
		}

		if ( i == this.currentPage.pageX ) {
			i += this.directionX;

			if ( i < 0 ) {
				i = 0;
			} else if ( i >= this.pages.length ) {
				i = this.pages.length - 1;
			}

			x = this.pages[i][0].x;
		}

		if ( m == this.currentPage.pageY ) {
			m += this.directionY;

			if ( m < 0 ) {
				m = 0;
			} else if ( m >= this.pages[0].length ) {
				m = this.pages[0].length - 1;
			}

			y = this.pages[0][m].y;
		}

		return {
			x: x,
			y: y,
			pageX: i,
			pageY: m
		};
	},

	goToPage: function (x, y, time, easing) {
		easing = easing || this.options.bounceEasing;

		if ( x >= this.pages.length ) {
			x = this.pages.length - 1;
		} else if ( x < 0 ) {
			x = 0;
		}

		if ( y >= this.pages[x].length ) {
			y = this.pages[x].length - 1;
		} else if ( y < 0 ) {
			y = 0;
		}

		var posX = this.pages[x][y].x,
			posY = this.pages[x][y].y;

		time = time === undefined ? this.options.snapSpeed || Math.max(
			Math.max(
				Math.min(Math.abs(posX - this.x), 1000),
				Math.min(Math.abs(posY - this.y), 1000)
			), 300) : time;

		this.currentPage = {
			x: posX,
			y: posY,
			pageX: x,
			pageY: y
		};

		this.scrollTo(posX, posY, time, easing);
	},

	next: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x++;

		if ( x >= this.pages.length && this.hasVerticalScroll ) {
			x = 0;
			y++;
		}

		this.goToPage(x, y, time, easing);
	},

	prev: function (time, easing) {
		var x = this.currentPage.pageX,
			y = this.currentPage.pageY;

		x--;

		if ( x < 0 && this.hasVerticalScroll ) {
			x = 0;
			y--;
		}

		this.goToPage(x, y, time, easing);
	},

	_initKeys: function (e) {
		// default key bindings
		var keys = {
			pageUp: 33,
			pageDown: 34,
			end: 35,
			home: 36,
			left: 37,
			up: 38,
			right: 39,
			down: 40
		};
		var i;

		// if you give me characters I give you keycode
		if ( typeof this.options.keyBindings == 'object' ) {
			for ( i in this.options.keyBindings ) {
				if ( typeof this.options.keyBindings[i] == 'string' ) {
					this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
				}
			}
		} else {
			this.options.keyBindings = {};
		}

		for ( i in keys ) {
			this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
		}

		utils.addEvent(window, 'keydown', this);

		this.on('destroy', function () {
			utils.removeEvent(window, 'keydown', this);
		});
	},

	_key: function (e) {
		if ( !this.enabled ) {
			return;
		}

		var snap = this.options.snap,	// we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			newY = snap ? this.currentPage.pageY : this.y,
			now = utils.getTime(),
			prevTime = this.keyTime || 0,
			acceleration = 0.250,
			pos;

		if ( this.options.useTransition && this.isInTransition ) {
			pos = this.getComputedPosition();

			this._translate(Math.round(pos.x), Math.round(pos.y));
			this.isInTransition = false;
		}

		this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

		switch ( e.keyCode ) {
			case this.options.keyBindings.pageUp:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX += snap ? 1 : this.wrapperWidth;
				} else {
					newY += snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.pageDown:
				if ( this.hasHorizontalScroll && !this.hasVerticalScroll ) {
					newX -= snap ? 1 : this.wrapperWidth;
				} else {
					newY -= snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.end:
				newX = snap ? this.pages.length-1 : this.maxScrollX;
				newY = snap ? this.pages[0].length-1 : this.maxScrollY;
				break;
			case this.options.keyBindings.home:
				newX = 0;
				newY = 0;
				break;
			case this.options.keyBindings.left:
				newX += snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.up:
				newY += snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.right:
				newX -= snap ? -1 : 5 + this.keyAcceleration>>0;
				break;
			case this.options.keyBindings.down:
				newY -= snap ? 1 : 5 + this.keyAcceleration>>0;
				break;
			default:
				return;
		}

		if ( snap ) {
			this.goToPage(newX, newY);
			return;
		}

		if ( newX > 0 ) {
			newX = 0;
			this.keyAcceleration = 0;
		} else if ( newX < this.maxScrollX ) {
			newX = this.maxScrollX;
			this.keyAcceleration = 0;
		}

		if ( newY > 0 ) {
			newY = 0;
			this.keyAcceleration = 0;
		} else if ( newY < this.maxScrollY ) {
			newY = this.maxScrollY;
			this.keyAcceleration = 0;
		}

		this.scrollTo(newX, newY, 0);

		this.keyTime = now;
	},

	_animate: function (destX, destY, duration, easingFn) {
		var that = this,
			startX = this.x,
			startY = this.y,
			startTime = utils.getTime(),
			destTime = startTime + duration;

		function step () {
			var now = utils.getTime(),
				newX, newY,
				easing;

			if ( now >= destTime ) {
				that.isAnimating = false;
				that._translate(destX, destY);

				if ( !that.resetPosition(that.options.bounceTime) ) {
					that._execEvent('scrollEnd');
				}

				return;
			}

			now = ( now - startTime ) / duration;
			easing = easingFn(now);
			newX = ( destX - startX ) * easing + startX;
			newY = ( destY - startY ) * easing + startY;
			that._translate(newX, newY);

			if ( that.isAnimating ) {
				rAF(step);
			}
		}

		this.isAnimating = true;
		step();
	},
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
			case 'orientationchange':
			case 'resize':
				this._resize();
				break;
			case 'transitionend':
			case 'webkitTransitionEnd':
			case 'oTransitionEnd':
			case 'MSTransitionEnd':
				this._transitionEnd(e);
				break;
			case 'wheel':
			case 'DOMMouseScroll':
			case 'mousewheel':
				this._wheel(e);
				break;
			case 'keydown':
				this._key(e);
				break;
			case 'click':
				if ( this.enabled && !e._constructed ) {
					e.preventDefault();
					e.stopPropagation();
				}
				break;
		}
	}
};
function createDefaultScrollbar (direction, interactive, type) {
	var scrollbar = document.createElement('div'),
		indicator = document.createElement('div');

	if ( type === true ) {
		scrollbar.style.cssText = 'position:absolute;z-index:9999';
		indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
	}

	indicator.className = 'iScrollIndicator';

	if ( direction == 'h' ) {
		if ( type === true ) {
			scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
			indicator.style.height = '100%';
		}
		scrollbar.className = 'iScrollHorizontalScrollbar';
	} else {
		if ( type === true ) {
			scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
			indicator.style.width = '100%';
		}
		scrollbar.className = 'iScrollVerticalScrollbar';
	}

	scrollbar.style.cssText += ';overflow:hidden';

	if ( !interactive ) {
		scrollbar.style.pointerEvents = 'none';
	}

	scrollbar.appendChild(indicator);

	return scrollbar;
}

function Indicator (scroller, options) {
	this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
	this.wrapperStyle = this.wrapper.style;
	this.indicator = this.wrapper.children[0];
	this.indicatorStyle = this.indicator.style;
	this.scroller = scroller;

	this.options = {
		listenX: true,
		listenY: true,
		interactive: false,
		resize: true,
		defaultScrollbars: false,
		shrink: false,
		fade: false,
		speedRatioX: 0,
		speedRatioY: 0
	};

	for ( var i in options ) {
		this.options[i] = options[i];
	}

	this.sizeRatioX = 1;
	this.sizeRatioY = 1;
	this.maxPosX = 0;
	this.maxPosY = 0;

	if ( this.options.interactive ) {
		if ( !this.options.disableTouch ) {
			utils.addEvent(this.indicator, 'touchstart', this);
			utils.addEvent(window, 'touchend', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
			utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(this.indicator, 'mousedown', this);
			utils.addEvent(window, 'mouseup', this);
		}
	}

	if ( this.options.fade ) {
		this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
		var durationProp = utils.style.transitionDuration;
		this.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms';
		// remove 0.0001ms
		var self = this;
		if(utils.isBadAndroid) {
			rAF(function() {
				if(self.wrapperStyle[durationProp] === '0.0001ms') {
					self.wrapperStyle[durationProp] = '0s';
				}
			});
		}
		this.wrapperStyle.opacity = '0';
	}
}

Indicator.prototype = {
	handleEvent: function (e) {
		switch ( e.type ) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
		}
	},

	destroy: function () {
		if ( this.options.fadeScrollbars ) {
			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;
		}
		if ( this.options.interactive ) {
			utils.removeEvent(this.indicator, 'touchstart', this);
			utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
			utils.removeEvent(this.indicator, 'mousedown', this);

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			utils.removeEvent(window, 'touchend', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
			utils.removeEvent(window, 'mouseup', this);
		}

		if ( this.options.defaultScrollbars ) {
			this.wrapper.parentNode.removeChild(this.wrapper);
		}
	},

	_start: function (e) {
		var point = e.touches ? e.touches[0] : e;

		e.preventDefault();
		e.stopPropagation();

		this.transitionTime();

		this.initiated = true;
		this.moved = false;
		this.lastPointX	= point.pageX;
		this.lastPointY	= point.pageY;

		this.startTime	= utils.getTime();

		if ( !this.options.disableTouch ) {
			utils.addEvent(window, 'touchmove', this);
		}
		if ( !this.options.disablePointer ) {
			utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
		}
		if ( !this.options.disableMouse ) {
			utils.addEvent(window, 'mousemove', this);
		}

		this.scroller._execEvent('beforeScrollStart');
	},

	_move: function (e) {
		var point = e.touches ? e.touches[0] : e,
			deltaX, deltaY,
			newX, newY,
			timestamp = utils.getTime();

		if ( !this.moved ) {
			this.scroller._execEvent('scrollStart');
		}

		this.moved = true;

		deltaX = point.pageX - this.lastPointX;
		this.lastPointX = point.pageX;

		deltaY = point.pageY - this.lastPointY;
		this.lastPointY = point.pageY;

		newX = this.x + deltaX;
		newY = this.y + deltaY;

		this._pos(newX, newY);

// INSERT POINT: indicator._move

		e.preventDefault();
		e.stopPropagation();
	},

	_end: function (e) {
		if ( !this.initiated ) {
			return;
		}

		this.initiated = false;

		e.preventDefault();
		e.stopPropagation();

		utils.removeEvent(window, 'touchmove', this);
		utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
		utils.removeEvent(window, 'mousemove', this);

		if ( this.scroller.options.snap ) {
			var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

			var time = this.options.snapSpeed || Math.max(
					Math.max(
						Math.min(Math.abs(this.scroller.x - snap.x), 1000),
						Math.min(Math.abs(this.scroller.y - snap.y), 1000)
					), 300);

			if ( this.scroller.x != snap.x || this.scroller.y != snap.y ) {
				this.scroller.directionX = 0;
				this.scroller.directionY = 0;
				this.scroller.currentPage = snap;
				this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
			}
		}

		if ( this.moved ) {
			this.scroller._execEvent('scrollEnd');
		}
	},

	transitionTime: function (time) {
		time = time || 0;
		var durationProp = utils.style.transitionDuration;
		this.indicatorStyle[durationProp] = time + 'ms';

		if ( !time && utils.isBadAndroid ) {
			this.indicatorStyle[durationProp] = '0.0001ms';
			// remove 0.0001ms
			var self = this;
			rAF(function() {
				if(self.indicatorStyle[durationProp] === '0.0001ms') {
					self.indicatorStyle[durationProp] = '0s';
				}
			});
		}
	},

	transitionTimingFunction: function (easing) {
		this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
	},

	refresh: function () {
		this.transitionTime();

		if ( this.options.listenX && !this.options.listenY ) {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
		} else if ( this.options.listenY && !this.options.listenX ) {
			this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
		} else {
			this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
		}

		if ( this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ) {
			utils.addClass(this.wrapper, 'iScrollBothScrollbars');
			utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '8px';
				} else {
					this.wrapper.style.bottom = '8px';
				}
			}
		} else {
			utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
			utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

			if ( this.options.defaultScrollbars && this.options.customStyle ) {
				if ( this.options.listenX ) {
					this.wrapper.style.right = '2px';
				} else {
					this.wrapper.style.bottom = '2px';
				}
			}
		}

		var r = this.wrapper.offsetHeight;	// force refresh

		if ( this.options.listenX ) {
			this.wrapperWidth = this.wrapper.clientWidth;
			if ( this.options.resize ) {
				this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
				this.indicatorStyle.width = this.indicatorWidth + 'px';
			} else {
				this.indicatorWidth = this.indicator.clientWidth;
			}

			this.maxPosX = this.wrapperWidth - this.indicatorWidth;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryX = -this.indicatorWidth + 8;
				this.maxBoundaryX = this.wrapperWidth - 8;
			} else {
				this.minBoundaryX = 0;
				this.maxBoundaryX = this.maxPosX;
			}

			this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));
		}

		if ( this.options.listenY ) {
			this.wrapperHeight = this.wrapper.clientHeight;
			if ( this.options.resize ) {
				this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
				this.indicatorStyle.height = this.indicatorHeight + 'px';
			} else {
				this.indicatorHeight = this.indicator.clientHeight;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;

			if ( this.options.shrink == 'clip' ) {
				this.minBoundaryY = -this.indicatorHeight + 8;
				this.maxBoundaryY = this.wrapperHeight - 8;
			} else {
				this.minBoundaryY = 0;
				this.maxBoundaryY = this.maxPosY;
			}

			this.maxPosY = this.wrapperHeight - this.indicatorHeight;
			this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
		}

		this.updatePosition();
	},

	updatePosition: function () {
		var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

		if ( !this.options.ignoreBoundaries ) {
			if ( x < this.minBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth + x, 8);
					this.indicatorStyle.width = this.width + 'px';
				}
				x = this.minBoundaryX;
			} else if ( x > this.maxBoundaryX ) {
				if ( this.options.shrink == 'scale' ) {
					this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
					this.indicatorStyle.width = this.width + 'px';
					x = this.maxPosX + this.indicatorWidth - this.width;
				} else {
					x = this.maxBoundaryX;
				}
			} else if ( this.options.shrink == 'scale' && this.width != this.indicatorWidth ) {
				this.width = this.indicatorWidth;
				this.indicatorStyle.width = this.width + 'px';
			}

			if ( y < this.minBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight + y * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
				}
				y = this.minBoundaryY;
			} else if ( y > this.maxBoundaryY ) {
				if ( this.options.shrink == 'scale' ) {
					this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
					this.indicatorStyle.height = this.height + 'px';
					y = this.maxPosY + this.indicatorHeight - this.height;
				} else {
					y = this.maxBoundaryY;
				}
			} else if ( this.options.shrink == 'scale' && this.height != this.indicatorHeight ) {
				this.height = this.indicatorHeight;
				this.indicatorStyle.height = this.height + 'px';
			}
		}

		this.x = x;
		this.y = y;

		if ( this.scroller.options.useTransform ) {
			this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
		} else {
			this.indicatorStyle.left = x + 'px';
			this.indicatorStyle.top = y + 'px';
		}
	},

	_pos: function (x, y) {
		if ( x < 0 ) {
			x = 0;
		} else if ( x > this.maxPosX ) {
			x = this.maxPosX;
		}

		if ( y < 0 ) {
			y = 0;
		} else if ( y > this.maxPosY ) {
			y = this.maxPosY;
		}

		x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
		y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

		this.scroller.scrollTo(x, y);
	},

	fade: function (val, hold) {
		if ( hold && !this.visible ) {
			return;
		}

		clearTimeout(this.fadeTimeout);
		this.fadeTimeout = null;

		var time = val ? 250 : 500,
			delay = val ? 0 : 300;

		val = val ? '1' : '0';

		this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

		this.fadeTimeout = setTimeout((function (val) {
			this.wrapperStyle.opacity = val;
			this.visible = +val;
		}).bind(this, val), delay);
	}
};

IScroll.utils = utils;

if ( typeof module != 'undefined' && module.exports ) {
	module.exports = IScroll;
} else if ( typeof define == 'function' && define.amd ) {
        define( function () { return IScroll; } );
} else {
	window.IScroll = IScroll;
}

})(window, document, Math);

},{}],8:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":51,"./_hashDelete":52,"./_hashGet":53,"./_hashHas":54,"./_hashSet":55}],9:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":62,"./_listCacheDelete":63,"./_listCacheGet":64,"./_listCacheHas":65,"./_listCacheSet":66}],10:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":47,"./_root":78}],11:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":67,"./_mapCacheDelete":68,"./_mapCacheGet":69,"./_mapCacheHas":70,"./_mapCacheSet":71}],12:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":9,"./_stackClear":82,"./_stackDelete":83,"./_stackGet":84,"./_stackHas":85,"./_stackSet":86}],13:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":78}],14:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":78}],15:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],16:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":33,"./_isIndex":57,"./isArguments":92,"./isArray":93,"./isBuffer":96,"./isTypedArray":103}],17:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":20,"./eq":90}],18:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":20,"./eq":90}],19:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":90}],20:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":44}],21:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":99}],22:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":42}],23:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":13,"./_getRawTag":49,"./_objectToString":75}],24:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":23,"./isObjectLike":100}],25:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":60,"./_toSource":87,"./isFunction":97,"./isObject":99}],26:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":23,"./isLength":98,"./isObjectLike":100}],27:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":61,"./_nativeKeysIn":73,"./isObject":99}],28:[function(require,module,exports){
var Stack = require('./_Stack'),
    assignMergeValue = require('./_assignMergeValue'),
    baseFor = require('./_baseFor'),
    baseMergeDeep = require('./_baseMergeDeep'),
    isObject = require('./isObject'),
    keysIn = require('./keysIn'),
    safeGet = require('./_safeGet');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":12,"./_assignMergeValue":17,"./_baseFor":22,"./_baseMergeDeep":29,"./_safeGet":79,"./isObject":99,"./keysIn":104}],29:[function(require,module,exports){
var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    safeGet = require('./_safeGet'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":17,"./_cloneBuffer":36,"./_cloneTypedArray":37,"./_copyArray":38,"./_initCloneObject":56,"./_safeGet":79,"./isArguments":92,"./isArray":93,"./isArrayLikeObject":95,"./isBuffer":96,"./isFunction":97,"./isObject":99,"./isPlainObject":101,"./isTypedArray":103,"./toPlainObject":112}],30:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;

},{}],31:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":77,"./_setToString":80,"./identity":91}],32:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":44,"./constant":88,"./identity":91}],33:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],34:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],35:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":14}],36:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":78}],37:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":35}],38:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],39:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":18,"./_baseAssignValue":20}],40:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":78}],41:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":31,"./_isIterateeCall":58}],42:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],43:[function(require,module,exports){
var baseRange = require('./_baseRange'),
    isIterateeCall = require('./_isIterateeCall'),
    toFinite = require('./toFinite');

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;

},{"./_baseRange":30,"./_isIterateeCall":58,"./toFinite":110}],44:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":47}],45:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],46:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":59}],47:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":25,"./_getValue":50}],48:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":76}],49:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":13}],50:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],51:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":72}],52:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],53:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":72}],54:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":72}],55:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":72}],56:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":21,"./_getPrototype":48,"./_isPrototype":61}],57:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],58:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":57,"./eq":90,"./isArrayLike":94,"./isObject":99}],59:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],60:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":40}],61:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],62:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],63:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":19}],64:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":19}],65:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":19}],66:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":19}],67:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":8,"./_ListCache":9,"./_Map":10}],68:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":46}],69:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":46}],70:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":46}],71:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":46}],72:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":47}],73:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],74:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":45}],75:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],76:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],77:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":15}],78:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":45}],79:[function(require,module,exports){
/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

},{}],80:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":32,"./_shortOut":81}],81:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],82:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":9}],83:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],84:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],85:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],86:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":9,"./_Map":10,"./_MapCache":11}],87:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],88:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],89:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":99,"./now":106,"./toNumber":111}],90:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],91:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],92:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":24,"./isObjectLike":100}],93:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],94:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":97,"./isLength":98}],95:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":94,"./isObjectLike":100}],96:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":78,"./stubFalse":108}],97:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":23,"./isObject":99}],98:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],99:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],100:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],101:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":23,"./_getPrototype":48,"./isObjectLike":100}],102:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":23,"./isObjectLike":100}],103:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":26,"./_baseUnary":34,"./_nodeUtil":74}],104:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":16,"./_baseKeysIn":27,"./isArrayLike":94}],105:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":28,"./_createAssigner":41}],106:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":78}],107:[function(require,module,exports){
var createRange = require('./_createRange');

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;

},{"./_createRange":43}],108:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],109:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":89,"./isObject":99}],110:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":111}],111:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":99,"./isSymbol":102}],112:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":39,"./keysIn":104}],113:[function(require,module,exports){
"use strict"

var hyperscript = require("./render/hyperscript")

hyperscript.trust = require("./render/trust")
hyperscript.fragment = require("./render/fragment")

module.exports = hyperscript

},{"./render/fragment":116,"./render/hyperscript":117,"./render/trust":119}],114:[function(require,module,exports){
(function (global,setImmediate){
;(function() {
"use strict"
function Vnode(tag, key, attrs0, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
}
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i])
	}
	return children
}
var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty
function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}
function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}
function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text
	var className = attrs.className || attrs.class
	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}
		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key]
			}
		}
		attrs = newAttrs
	}
	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key]
		}
	}
	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined
			attrs.className = className
		}
		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className
		}
	}
	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true
			break
		}
	}
	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children
	} else {
		childList = children
	}
	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}
function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children
	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}
	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector)
	}
	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = 1
	}
	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}
	var normalized = Vnode.normalizeChildren(children)
	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}
hyperscript.trust = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}
hyperscript.fragment = function(attrs1, children) {
	return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)
}
var m = hyperscript
/** @constructor */
var PromisePolyfill = function(executor) {
	if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")
	if (typeof executor !== "function") throw new TypeError("executor must be a function")
	var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)
	var instance = self._instance = {resolvers: resolvers, rejectors: rejectors}
	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
	function handler(list, shouldAbsorb) {
		return function execute(value) {
			var then
			try {
				if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
					if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
					executeOnce(then.bind(value))
				}
				else {
					callAsync(function() {
						if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)
						for (var i = 0; i < list.length; i++) list[i](value)
						resolvers.length = 0, rejectors.length = 0
						instance.state = shouldAbsorb
						instance.retry = function() {execute(value)}
					})
				}
			}
			catch (e) {
				rejectCurrent(e)
			}
		}
	}
	function executeOnce(then) {
		var runs = 0
		function run(fn) {
			return function(value) {
				if (runs++ > 0) return
				fn(value)
			}
		}
		var onerror = run(rejectCurrent)
		try {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}
	}
	executeOnce(executor)
}
PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
	var self = this, instance = self._instance
	function handle(callback, list, next, state) {
		list.push(function(value) {
			if (typeof callback !== "function") next(value)
			else try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}
		})
		if (typeof instance.retry === "function" && state === instance.state) instance.retry()
	}
	var resolveNext, rejectNext
	var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})
	handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)
	return promise
}
PromisePolyfill.prototype.catch = function(onRejection) {
	return this.then(null, onRejection)
}
PromisePolyfill.resolve = function(value) {
	if (value instanceof PromisePolyfill) return value
	return new PromisePolyfill(function(resolve) {resolve(value)})
}
PromisePolyfill.reject = function(value) {
	return new PromisePolyfill(function(resolve, reject) {reject(value)})
}
PromisePolyfill.all = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		var total = list.length, count = 0, values = []
		if (list.length === 0) resolve([])
		else for (var i = 0; i < list.length; i++) {
			(function(i) {
				function consume(value) {
					count++
					values[i] = value
					if (count === total) resolve(values)
				}
				if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
					list[i].then(consume, reject)
				}
				else consume(list[i])
			})(i)
		}
	})
}
PromisePolyfill.race = function(list) {
	return new PromisePolyfill(function(resolve, reject) {
		for (var i = 0; i < list.length; i++) {
			list[i].then(resolve, reject)
		}
	})
}
if (typeof window !== "undefined") {
	if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill
	var PromisePolyfill = window.Promise
} else if (typeof global !== "undefined") {
	if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill
	var PromisePolyfill = global.Promise
} else {
}
var buildQueryString = function(object) {
	if (Object.prototype.toString.call(object) !== "[object Object]") return ""
	var args = []
	for (var key0 in object) {
		destructure(key0, object[key0])
	}
	return args.join("&")
	function destructure(key0, value) {
		if (Array.isArray(value)) {
			for (var i = 0; i < value.length; i++) {
				destructure(key0 + "[" + i + "]", value[i])
			}
		}
		else if (Object.prototype.toString.call(value) === "[object Object]") {
			for (var i in value) {
				destructure(key0 + "[" + i + "]", value[i])
			}
		}
		else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))
	}
}
var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")
var _8 = function($window, Promise) {
	var callbackCount = 0
	var oncompletion
	function setCompletionCallback(callback) {oncompletion = callback}
	function finalizer() {
		var count = 0
		function complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}
		return function finalize(promise0) {
			var then0 = promise0.then
			promise0.then = function() {
				count++
				var next = then0.apply(promise0, arguments)
				next.then(complete, function(e) {
					complete()
					if (count === 0) throw e
				})
				return finalize(next)
			}
			return promise0
		}
	}
	function normalize(args, extra) {
		if (typeof args === "string") {
			var url = args
			args = extra || {}
			if (args.url == null) args.url = url
		}
		return args
	}
	function request(args, extra) {
		var finalize = finalizer()
		args = normalize(args, extra)
		var promise0 = new Promise(function(resolve, reject) {
			if (args.method == null) args.method = "GET"
			args.method = args.method.toUpperCase()
			var useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)
			if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify
			if (typeof args.deserialize !== "function") args.deserialize = deserialize
			if (typeof args.extract !== "function") args.extract = extract
			args.url = interpolate(args.url, args.data)
			if (useBody) args.data = args.serialize(args.data)
			else args.url = assemble(args.url, args.data)
			var xhr = new $window.XMLHttpRequest(),
				aborted = false,
				_abort = xhr.abort
			xhr.abort = function abort() {
				aborted = true
				_abort.call(xhr)
			}
			xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)
			if (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty("Content-Type"))) {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
			}
			if (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty("Accept"))) {
				xhr.setRequestHeader("Accept", "application/json, text/*")
			}
			if (args.withCredentials) xhr.withCredentials = args.withCredentials
			for (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {
				xhr.setRequestHeader(key, args.headers[key])
			}
			if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr
			xhr.onreadystatechange = function() {
				// Don't throw errors on xhr.abort().
				if(aborted) return
				if (xhr.readyState === 4) {
					try {
						var response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))
						if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
							resolve(cast(args.type, response))
						}
						else {
							var error = new Error(xhr.responseText)
							for (var key in response) error[key] = response[key]
							reject(error)
						}
					}
					catch (e) {
						reject(e)
					}
				}
			}
			if (useBody && (args.data != null)) xhr.send(args.data)
			else xhr.send()
		})
		return args.background === true ? promise0 : finalize(promise0)
	}
	function jsonp(args, extra) {
		var finalize = finalizer()
		args = normalize(args, extra)
		var promise0 = new Promise(function(resolve, reject) {
			var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++
			var script = $window.document.createElement("script")
			$window[callbackName] = function(data) {
				script.parentNode.removeChild(script)
				resolve(cast(args.type, data))
				delete $window[callbackName]
			}
			script.onerror = function() {
				script.parentNode.removeChild(script)
				reject(new Error("JSONP request failed"))
				delete $window[callbackName]
			}
			if (args.data == null) args.data = {}
			args.url = interpolate(args.url, args.data)
			args.data[args.callbackKey || "callback"] = callbackName
			script.src = assemble(args.url, args.data)
			$window.document.documentElement.appendChild(script)
		})
		return args.background === true? promise0 : finalize(promise0)
	}
	function interpolate(url, data) {
		if (data == null) return url
		var tokens = url.match(/:[^\/]+/gi) || []
		for (var i = 0; i < tokens.length; i++) {
			var key = tokens[i].slice(1)
			if (data[key] != null) {
				url = url.replace(tokens[i], data[key])
			}
		}
		return url
	}
	function assemble(url, data) {
		var querystring = buildQueryString(data)
		if (querystring !== "") {
			var prefix = url.indexOf("?") < 0 ? "?" : "&"
			url += prefix + querystring
		}
		return url
	}
	function deserialize(data) {
		try {return data !== "" ? JSON.parse(data) : null}
		catch (e) {throw new Error(data)}
	}
	function extract(xhr) {return xhr.responseText}
	function cast(type0, data) {
		if (typeof type0 === "function") {
			if (Array.isArray(data)) {
				for (var i = 0; i < data.length; i++) {
					data[i] = new type0(data[i])
				}
			}
			else return new type0(data)
		}
		return data
	}
	return {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}
}
var requestService = _8(window, PromisePolyfill)
var coreRenderer = function($window) {
	var $doc = $window.document
	var $emptyFragment = $doc.createDocumentFragment()
	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}
	var onevent
	function setEventCallback(callback) {return onevent = callback}
	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}
	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match1 = vnode.children.match(/^\s*?<(\w+)/im) || []
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"
		var temp = $doc.createElement(parent1)
		temp.innerHTML = vnode.children
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodes(fragment, children, 0, children.length, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs2 = vnode.attrs
		var is = attrs2 && attrs2.is
		ns = getNameSpace(vnode) || ns
		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element
		if (attrs2 != null) {
			setAttrs(vnode, attrs2, ns)
		}
		insertNode(parent, element, nextSibling)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(element, children, 0, children.length, hooks, null, ns)
				setLateAttrs(vnode)
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		vnode._state = vnode.state
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		initLifecycle(vnode._state, vnode, hooks)
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
			insertNode(parent, element, nextSibling)
			return element
		}
		else {
			vnode.domSize = 0
			return $emptyFragment
		}
	}
	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes)
			if (recycling) {
				var pool = old.pool
				old = old.concat(old.pool)
			}
			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start]
				if (o === v && !recycling) oldStart++, start++
				else if (o == null) oldStart++
				else if (v == null) start++
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
					oldStart++, start++
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
				}
				else {
					var o = old[oldEnd]
					if (o === v && !recycling) oldEnd--, start++
					else if (o == null) oldEnd--
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
						oldEnd--, start++
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end]
				if (o === v && !recycling) oldEnd--, end--
				else if (o == null) oldEnd--
				else if (v == null) end--
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					if (o.dom != null) nextSibling = o.dom
					oldEnd--, end--
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd)
					if (v != null) {
						var oldIndex = map[v.key]
						if (oldIndex != null) {
							var movable = old[oldIndex]
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
							insertNode(parent, toFragment(movable), nextSibling)
							old[oldIndex].skip = true
							if (movable.dom != null) nextSibling = movable.dom
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling)
							nextSibling = dom
						}
					}
					end--
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
			removeNodes(old, oldStart, oldEnd + 1, vnodes)
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode._state = old._state
			vnode.events = old.events
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {}
						initLifecycle(vnode.attrs, vnode, hooks)
					}
					else updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
		}
		else {
			removeNode(old, null)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns
		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle0 multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks)
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
			updateLifecycle(vnode._state, vnode, hooks)
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance, null)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				var key2 = vnode.key
				if (key2 != null) map[key2] = i
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count0 = vnode.domSize
		if (count0 != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count0 > 0) {
				var dom = vnode.dom
				while (--count0) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}
	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}
	function setContentEditable(vnode) {
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}
	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false
				else removeNode(vnode, context)
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				onremove(vnode)
				if (vnode.dom) {
					var count0 = vnode.domSize || 1
					if (count0 > 1) {
						var dom = vnode.dom
						while (--count0) {
							removeNodeFromDOM(dom.nextSibling)
						}
					}
					removeNodeFromDOM(vnode.dom)
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode]
						else context.pool.push(vnode)
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode
		if (parent != null) parent.removeChild(node)
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}
	//attrs2
	function setAttrs(vnode, attrs2, ns) {
		for (var key2 in attrs2) {
			setAttr(vnode, key2, null, attrs2[key2], ns)
		}
	}
	function setAttr(vnode, key2, old, value, ns) {
		var element = vnode.dom
		if (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return
		var nsLastIndex = key2.indexOf(":")
		if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)
		}
		else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)
		else if (key2 === "style") updateStyle(element, old, value)
		else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
			if (key2 === "value") {
				var normalized0 = "" + value // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return
			}
			// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
			if (vnode.tag === "input" && key2 === "type") {
				element.setAttribute(key2, value)
				return
			}
			element[key2] = value
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key2, "")
				else element.removeAttribute(key2)
			}
			else element.setAttribute(key2 === "className" ? "class" : key2, value)
		}
	}
	function setLateAttrs(vnode) {
		var attrs2 = vnode.attrs
		if (vnode.tag === "select" && attrs2 != null) {
			if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)
			if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)
		}
	}
	function updateAttrs(vnode, old, attrs2, ns) {
		if (attrs2 != null) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, old && old[key2], attrs2[key2], ns)
			}
		}
		if (old != null) {
			for (var key2 in old) {
				if (attrs2 == null || !(key2 in attrs2)) {
					if (key2 === "className") key2 = "class"
					if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)
					else if (key2 !== "key") vnode.dom.removeAttribute(key2)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}
	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null
		if (style == null) element.style.cssText = ""
		else if (typeof style === "string") element.style.cssText = style
		else {
			if (typeof old === "string") element.style.cssText = ""
			for (var key2 in style) {
				element.style[key2] = style[key2]
			}
			if (old != null && typeof old !== "string") {
				for (var key2 in old) {
					if (!(key2 in style)) element.style[key2] = ""
				}
			}
		}
	}
	//event
	function updateEvent(vnode, key2, value) {
		var element = vnode.dom
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e)
			onevent.call(element, e)
			return result
		}
		if (key2 in element) element[key2] = typeof value === "function" ? callback : null
		else {
			var eventName = key2.slice(2)
			if (vnode.events === undefined) vnode.events = {}
			if (vnode.events[key2] === callback) return
			if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)
			if (typeof value === "function") {
				vnode.events[key2] = callback
				element.addEventListener(eventName, vnode.events[key2], false)
			}
		}
	}
	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
			vnode.instance = old.instance
			return true
		}
		return false
	}
	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = $doc.activeElement
		var namespace = dom.namespaceURI
		// First time0 rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""
		if (!Array.isArray(vnodes)) vnodes = [vnodes]
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}
	return {render: render, setEventCallback: setEventCallback}
}
function throttle(callback) {
	//60fps translates to 16.6ms, round it down since setTimeout requires int
	var time = 16
	var last = 0, pending = null
	var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout
	return function() {
		var now = Date.now()
		if (last === 0 || now - last >= time) {
			last = now
			callback()
		}
		else if (pending === null) {
			pending = timeout(function() {
				pending = null
				callback()
				last = Date.now()
			}, time - (now - last))
		}
	}
}
var _11 = function($window) {
	var renderService = coreRenderer($window)
	renderService.setEventCallback(function(e) {
		if (e.redraw === false) e.redraw = undefined
		else redraw()
	})
	var callbacks = []
	function subscribe(key1, callback) {
		unsubscribe(key1)
		callbacks.push(key1, throttle(callback))
	}
	function unsubscribe(key1) {
		var index = callbacks.indexOf(key1)
		if (index > -1) callbacks.splice(index, 2)
	}
	function redraw() {
		for (var i = 1; i < callbacks.length; i += 2) {
			callbacks[i]()
		}
	}
	return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
}
var redrawService = _11(window)
requestService.setCompletionCallback(redrawService.redraw)
var _16 = function(redrawService0) {
	return function(root, component) {
		if (component === null) {
			redrawService0.render(root, [])
			redrawService0.unsubscribe(root)
			return
		}
		
		if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")
		
		var run0 = function() {
			redrawService0.render(root, Vnode(component))
		}
		redrawService0.subscribe(root, run0)
		redrawService0.redraw()
	}
}
m.mount = _16(redrawService)
var Promise = PromisePolyfill
var parseQueryString = function(string) {
	if (string === "" || string == null) return {}
	if (string.charAt(0) === "?") string = string.slice(1)
	var entries = string.split("&"), data0 = {}, counters = {}
	for (var i = 0; i < entries.length; i++) {
		var entry = entries[i].split("=")
		var key5 = decodeURIComponent(entry[0])
		var value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""
		if (value === "true") value = true
		else if (value === "false") value = false
		var levels = key5.split(/\]\[?|\[/)
		var cursor = data0
		if (key5.indexOf("[") > -1) levels.pop()
		for (var j = 0; j < levels.length; j++) {
			var level = levels[j], nextLevel = levels[j + 1]
			var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))
			var isValue = j === levels.length - 1
			if (level === "") {
				var key5 = levels.slice(0, j).join()
				if (counters[key5] == null) counters[key5] = 0
				level = counters[key5]++
			}
			if (cursor[level] == null) {
				cursor[level] = isValue ? value : isNumber ? [] : {}
			}
			cursor = cursor[level]
		}
	}
	return data0
}
var coreRouter = function($window) {
	var supportsPushState = typeof $window.history.pushState === "function"
	var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout
	function normalize1(fragment0) {
		var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)
		if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data
		return data
	}
	var asyncId
	function debounceAsync(callback0) {
		return function() {
			if (asyncId != null) return
			asyncId = callAsync0(function() {
				asyncId = null
				callback0()
			})
		}
	}
	function parsePath(path, queryData, hashData) {
		var queryIndex = path.indexOf("?")
		var hashIndex = path.indexOf("#")
		var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length
		if (queryIndex > -1) {
			var queryEnd = hashIndex > -1 ? hashIndex : path.length
			var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))
			for (var key4 in queryParams) queryData[key4] = queryParams[key4]
		}
		if (hashIndex > -1) {
			var hashParams = parseQueryString(path.slice(hashIndex + 1))
			for (var key4 in hashParams) hashData[key4] = hashParams[key4]
		}
		return path.slice(0, pathEnd)
	}
	var router = {prefix: "#!"}
	router.getPath = function() {
		var type2 = router.prefix.charAt(0)
		switch (type2) {
			case "#": return normalize1("hash").slice(router.prefix.length)
			case "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")
			default: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")
		}
	}
	router.setPath = function(path, data, options) {
		var queryData = {}, hashData = {}
		path = parsePath(path, queryData, hashData)
		if (data != null) {
			for (var key4 in data) queryData[key4] = data[key4]
			path = path.replace(/:([^\/]+)/g, function(match2, token) {
				delete queryData[token]
				return data[token]
			})
		}
		var query = buildQueryString(queryData)
		if (query) path += "?" + query
		var hash = buildQueryString(hashData)
		if (hash) path += "#" + hash
		if (supportsPushState) {
			var state = options ? options.state : null
			var title = options ? options.title : null
			$window.onpopstate()
			if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)
			else $window.history.pushState(state, title, router.prefix + path)
		}
		else $window.location.href = router.prefix + path
	}
	router.defineRoutes = function(routes, resolve, reject) {
		function resolveRoute() {
			var path = router.getPath()
			var params = {}
			var pathname = parsePath(path, params, params)
			var state = $window.history.state
			if (state != null) {
				for (var k in state) params[k] = state[k]
			}
			for (var route0 in routes) {
				var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$")
				if (matcher.test(pathname)) {
					pathname.replace(matcher, function() {
						var keys = route0.match(/:[^\/]+/g) || []
						var values = [].slice.call(arguments, 1, -2)
						for (var i = 0; i < keys.length; i++) {
							params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i])
						}
						resolve(routes[route0], params, path, route0)
					})
					return
				}
			}
			reject(path, params)
		}
		if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)
		else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute
		resolveRoute()
	}
	return router
}
var _20 = function($window, redrawService0) {
	var routeService = coreRouter($window)
	var identity = function(v) {return v}
	var render1, component, attrs3, currentPath, lastUpdate
	var route = function(root, defaultRoute, routes) {
		if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
		var run1 = function() {
			if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))
		}
		var bail = function(path) {
			if (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})
			else throw new Error("Could not resolve default route " + defaultRoute)
		}
		routeService.defineRoutes(routes, function(payload, params, path) {
			var update = lastUpdate = function(routeResolver, comp) {
				if (update !== lastUpdate) return
				component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"
				attrs3 = params, currentPath = path, lastUpdate = null
				render1 = (routeResolver.render || identity).bind(routeResolver)
				run1()
			}
			if (payload.view || typeof payload === "function") update({}, payload)
			else {
				if (payload.onmatch) {
					Promise.resolve(payload.onmatch(params, path)).then(function(resolved) {
						update(payload, resolved)
					}, bail)
				}
				else update(payload, "div")
			}
		}, bail)
		redrawService0.subscribe(root, run1)
	}
	route.set = function(path, data, options) {
		if (lastUpdate != null) {
			options = options || {}
			options.replace = true
		}
		lastUpdate = null
		routeService.setPath(path, data, options)
	}
	route.get = function() {return currentPath}
	route.prefix = function(prefix0) {routeService.prefix = prefix0}
	route.link = function(vnode1) {
		vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)
		vnode1.dom.onclick = function(e) {
			if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return
			e.preventDefault()
			e.redraw = false
			var href = this.getAttribute("href")
			if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)
			route.set(href, undefined, undefined)
		}
	}
	route.param = function(key3) {
		if(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]
		return attrs3
	}
	return route
}
m.route = _20(window, redrawService)
m.withAttr = function(attrName, callback1, context) {
	return function(e) {
		callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))
	}
}
var _28 = coreRenderer(window)
m.render = _28.render
m.redraw = redrawService.redraw
m.request = requestService.request
m.jsonp = requestService.jsonp
m.parseQueryString = parseQueryString
m.buildQueryString = buildQueryString
m.version = "1.1.6"
m.vnode = Vnode
if (typeof module !== "undefined") module["exports"] = m
else window.m = m
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":129}],115:[function(require,module,exports){
"use strict"

module.exports = require("./render/render")(window)

},{"./render/render":118}],116:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function(attrs, children) {
	return Vnode("[", attrs.key, attrs, Vnode.normalizeChildren(children), undefined, undefined)
}

},{"../render/vnode":120}],117:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
var selectorCache = {}
var hasOwn = {}.hasOwnProperty

function isEmpty(object) {
	for (var key in object) if (hasOwn.call(object, key)) return false
	return true
}

function compileSelector(selector) {
	var match, tag = "div", classes = [], attrs = {}
	while (match = selectorParser.exec(selector)) {
		var type = match[1], value = match[2]
		if (type === "" && value !== "") tag = value
		else if (type === "#") attrs.id = value
		else if (type === ".") classes.push(value)
		else if (match[3][0] === "[") {
			var attrValue = match[6]
			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
			if (match[4] === "class") classes.push(attrValue)
			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
		}
	}
	if (classes.length > 0) attrs.className = classes.join(" ")
	return selectorCache[selector] = {tag: tag, attrs: attrs}
}

function execSelector(state, attrs, children) {
	var hasAttrs = false, childList, text
	var className = attrs.className || attrs.class

	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
		var newAttrs = {}

		for(var key in attrs) {
			if (hasOwn.call(attrs, key)) {
				newAttrs[key] = attrs[key]
			}
		}

		attrs = newAttrs
	}

	for (var key in state.attrs) {
		if (hasOwn.call(state.attrs, key)) {
			attrs[key] = state.attrs[key]
		}
	}

	if (className !== undefined) {
		if (attrs.class !== undefined) {
			attrs.class = undefined
			attrs.className = className
		}

		if (state.attrs.className != null) {
			attrs.className = state.attrs.className + " " + className
		}
	}

	for (var key in attrs) {
		if (hasOwn.call(attrs, key) && key !== "key") {
			hasAttrs = true
			break
		}
	}

	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
		text = children[0].children
	} else {
		childList = children
	}

	return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
}

function hyperscript(selector) {
	// Because sloppy mode sucks
	var attrs = arguments[1], start = 2, children

	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
		throw Error("The selector must be either a string or a component.");
	}

	if (typeof selector === "string") {
		var cached = selectorCache[selector] || compileSelector(selector)
	}

	if (attrs == null) {
		attrs = {}
	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
		attrs = {}
		start = 1
	}

	if (arguments.length === start + 1) {
		children = arguments[start]
		if (!Array.isArray(children)) children = [children]
	} else {
		children = []
		while (start < arguments.length) children.push(arguments[start++])
	}

	var normalized = Vnode.normalizeChildren(children)

	if (typeof selector === "string") {
		return execSelector(cached, attrs, normalized)
	} else {
		return Vnode(selector, attrs.key, attrs, normalized)
	}
}

module.exports = hyperscript

},{"../render/vnode":120}],118:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function($window) {
	var $doc = $window.document
	var $emptyFragment = $doc.createDocumentFragment()

	var nameSpace = {
		svg: "http://www.w3.org/2000/svg",
		math: "http://www.w3.org/1998/Math/MathML"
	}

	var onevent
	function setEventCallback(callback) {return onevent = callback}

	function getNameSpace(vnode) {
		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
	}

	//create
	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
	}
	function createNode(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		if (typeof tag === "string") {
			vnode.state = {}
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			switch (tag) {
				case "#": return createText(parent, vnode, nextSibling)
				case "<": return createHTML(parent, vnode, nextSibling)
				case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
				default: return createElement(parent, vnode, hooks, ns, nextSibling)
			}
		}
		else return createComponent(parent, vnode, hooks, ns, nextSibling)
	}
	function createText(parent, vnode, nextSibling) {
		vnode.dom = $doc.createTextNode(vnode.children)
		insertNode(parent, vnode.dom, nextSibling)
		return vnode.dom
	}
	function createHTML(parent, vnode, nextSibling) {
		var match = vnode.children.match(/^\s*?<(\w+)/im) || []
		var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match[1]] || "div"
		var temp = $doc.createElement(parent1)

		temp.innerHTML = vnode.children
		vnode.dom = temp.firstChild
		vnode.domSize = temp.childNodes.length
		var fragment = $doc.createDocumentFragment()
		var child
		while (child = temp.firstChild) {
			fragment.appendChild(child)
		}
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createFragment(parent, vnode, hooks, ns, nextSibling) {
		var fragment = $doc.createDocumentFragment()
		if (vnode.children != null) {
			var children = vnode.children
			createNodes(fragment, children, 0, children.length, hooks, null, ns)
		}
		vnode.dom = fragment.firstChild
		vnode.domSize = fragment.childNodes.length
		insertNode(parent, fragment, nextSibling)
		return fragment
	}
	function createElement(parent, vnode, hooks, ns, nextSibling) {
		var tag = vnode.tag
		var attrs = vnode.attrs
		var is = attrs && attrs.is

		ns = getNameSpace(vnode) || ns

		var element = ns ?
			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
		vnode.dom = element

		if (attrs != null) {
			setAttrs(vnode, attrs, ns)
		}

		insertNode(parent, element, nextSibling)

		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else {
			if (vnode.text != null) {
				if (vnode.text !== "") element.textContent = vnode.text
				else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			}
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(element, children, 0, children.length, hooks, null, ns)
				setLateAttrs(vnode)
			}
		}
		return element
	}
	function initComponent(vnode, hooks) {
		var sentinel
		if (typeof vnode.tag.view === "function") {
			vnode.state = Object.create(vnode.tag)
			sentinel = vnode.state.view
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
		} else {
			vnode.state = void 0
			sentinel = vnode.tag
			if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
			sentinel.$$reentrantLock$$ = true
			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
		}
		vnode._state = vnode.state
		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
		initLifecycle(vnode._state, vnode, hooks)
		vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
		sentinel.$$reentrantLock$$ = null
	}
	function createComponent(parent, vnode, hooks, ns, nextSibling) {
		initComponent(vnode, hooks)
		if (vnode.instance != null) {
			var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
			insertNode(parent, element, nextSibling)
			return element
		}
		else {
			vnode.domSize = 0
			return $emptyFragment
		}
	}

	//update
	function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
		if (old === vnodes || old == null && vnodes == null) return
		else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
		else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
		else {
			if (old.length === vnodes.length) {
				var isUnkeyed = false
				for (var i = 0; i < vnodes.length; i++) {
					if (vnodes[i] != null && old[i] != null) {
						isUnkeyed = vnodes[i].key == null && old[i].key == null
						break
					}
				}
				if (isUnkeyed) {
					for (var i = 0; i < old.length; i++) {
						if (old[i] === vnodes[i]) continue
						else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
						else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
						else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
					}
					return
				}
			}
			recycling = recycling || isRecyclable(old, vnodes)
			if (recycling) {
				var pool = old.pool
				old = old.concat(old.pool)
			}

			var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldStart], v = vnodes[start]
				if (o === v && !recycling) oldStart++, start++
				else if (o == null) oldStart++
				else if (v == null) start++
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
					oldStart++, start++
					updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
				}
				else {
					var o = old[oldEnd]
					if (o === v && !recycling) oldEnd--, start++
					else if (o == null) oldEnd--
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
						oldEnd--, start++
					}
					else break
				}
			}
			while (oldEnd >= oldStart && end >= start) {
				var o = old[oldEnd], v = vnodes[end]
				if (o === v && !recycling) oldEnd--, end--
				else if (o == null) oldEnd--
				else if (v == null) end--
				else if (o.key === v.key) {
					var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
					updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
					if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					if (o.dom != null) nextSibling = o.dom
					oldEnd--, end--
				}
				else {
					if (!map) map = getKeyMap(old, oldEnd)
					if (v != null) {
						var oldIndex = map[v.key]
						if (oldIndex != null) {
							var movable = old[oldIndex]
							var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
							insertNode(parent, toFragment(movable), nextSibling)
							old[oldIndex].skip = true
							if (movable.dom != null) nextSibling = movable.dom
						}
						else {
							var dom = createNode(parent, v, hooks, ns, nextSibling)
							nextSibling = dom
						}
					}
					end--
				}
				if (end < start) break
			}
			createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
			removeNodes(old, oldStart, oldEnd + 1, vnodes)
		}
	}
	function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		var oldTag = old.tag, tag = vnode.tag
		if (oldTag === tag) {
			vnode.state = old.state
			vnode._state = old._state
			vnode.events = old.events
			if (!recycling && shouldNotUpdate(vnode, old)) return
			if (typeof oldTag === "string") {
				if (vnode.attrs != null) {
					if (recycling) {
						vnode.state = {}
						initLifecycle(vnode.attrs, vnode, hooks)
					}
					else updateLifecycle(vnode.attrs, vnode, hooks)
				}
				switch (oldTag) {
					case "#": updateText(old, vnode); break
					case "<": updateHTML(parent, old, vnode, nextSibling); break
					case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
					default: updateElement(old, vnode, recycling, hooks, ns)
				}
			}
			else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
		}
		else {
			removeNode(old, null)
			createNode(parent, vnode, hooks, ns, nextSibling)
		}
	}
	function updateText(old, vnode) {
		if (old.children.toString() !== vnode.children.toString()) {
			old.dom.nodeValue = vnode.children
		}
		vnode.dom = old.dom
	}
	function updateHTML(parent, old, vnode, nextSibling) {
		if (old.children !== vnode.children) {
			toFragment(old)
			createHTML(parent, vnode, nextSibling)
		}
		else vnode.dom = old.dom, vnode.domSize = old.domSize
	}
	function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
		updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
		var domSize = 0, children = vnode.children
		vnode.dom = null
		if (children != null) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i]
				if (child != null && child.dom != null) {
					if (vnode.dom == null) vnode.dom = child.dom
					domSize += child.domSize || 1
				}
			}
			if (domSize !== 1) vnode.domSize = domSize
		}
	}
	function updateElement(old, vnode, recycling, hooks, ns) {
		var element = vnode.dom = old.dom
		ns = getNameSpace(vnode) || ns

		if (vnode.tag === "textarea") {
			if (vnode.attrs == null) vnode.attrs = {}
			if (vnode.text != null) {
				vnode.attrs.value = vnode.text //FIXME handle multiple children
				vnode.text = undefined
			}
		}
		updateAttrs(vnode, old.attrs, vnode.attrs, ns)
		if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
			setContentEditable(vnode)
		}
		else if (old.text != null && vnode.text != null && vnode.text !== "") {
			if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
		}
		else {
			if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
			if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
			updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
		}
	}
	function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
		if (recycling) {
			initComponent(vnode, hooks)
		} else {
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
			updateLifecycle(vnode._state, vnode, hooks)
		}
		if (vnode.instance != null) {
			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
			vnode.dom = vnode.instance.dom
			vnode.domSize = vnode.instance.domSize
		}
		else if (old.instance != null) {
			removeNode(old.instance, null)
			vnode.dom = undefined
			vnode.domSize = 0
		}
		else {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
		}
	}
	function isRecyclable(old, vnodes) {
		if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
			var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
			var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
			var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
			if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
				return true
			}
		}
		return false
	}
	function getKeyMap(vnodes, end) {
		var map = {}, i = 0
		for (var i = 0; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				var key = vnode.key
				if (key != null) map[key] = i
			}
		}
		return map
	}
	function toFragment(vnode) {
		var count = vnode.domSize
		if (count != null || vnode.dom == null) {
			var fragment = $doc.createDocumentFragment()
			if (count > 0) {
				var dom = vnode.dom
				while (--count) fragment.appendChild(dom.nextSibling)
				fragment.insertBefore(dom, fragment.firstChild)
			}
			return fragment
		}
		else return vnode.dom
	}
	function getNextSibling(vnodes, i, nextSibling) {
		for (; i < vnodes.length; i++) {
			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
		}
		return nextSibling
	}

	function insertNode(parent, dom, nextSibling) {
		if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
		else parent.appendChild(dom)
	}

	function setContentEditable(vnode) {
		var children = vnode.children
		if (children != null && children.length === 1 && children[0].tag === "<") {
			var content = children[0].children
			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
		}
		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
	}

	//remove
	function removeNodes(vnodes, start, end, context) {
		for (var i = start; i < end; i++) {
			var vnode = vnodes[i]
			if (vnode != null) {
				if (vnode.skip) vnode.skip = false
				else removeNode(vnode, context)
			}
		}
	}
	function removeNode(vnode, context) {
		var expected = 1, called = 0
		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
			var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
			var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
			if (result != null && typeof result.then === "function") {
				expected++
				result.then(continuation, continuation)
			}
		}
		continuation()
		function continuation() {
			if (++called === expected) {
				onremove(vnode)
				if (vnode.dom) {
					var count = vnode.domSize || 1
					if (count > 1) {
						var dom = vnode.dom
						while (--count) {
							removeNodeFromDOM(dom.nextSibling)
						}
					}
					removeNodeFromDOM(vnode.dom)
					if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
						if (!context.pool) context.pool = [vnode]
						else context.pool.push(vnode)
					}
				}
			}
		}
	}
	function removeNodeFromDOM(node) {
		var parent = node.parentNode
		if (parent != null) parent.removeChild(node)
	}
	function onremove(vnode) {
		if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
		if (typeof vnode.tag !== "string") {
			if (typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
		} else {
			var children = vnode.children
			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null) onremove(child)
				}
			}
		}
	}

	//attrs
	function setAttrs(vnode, attrs, ns) {
		for (var key in attrs) {
			setAttr(vnode, key, null, attrs[key], ns)
		}
	}
	function setAttr(vnode, key, old, value, ns) {
		var element = vnode.dom
		if (key === "key" || key === "is" || (old === value && !isFormAttribute(vnode, key)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key)) return
		var nsLastIndex = key.indexOf(":")
		if (nsLastIndex > -1 && key.substr(0, nsLastIndex) === "xlink") {
			element.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(nsLastIndex + 1), value)
		}
		else if (key[0] === "o" && key[1] === "n" && typeof value === "function") updateEvent(vnode, key, value)
		else if (key === "style") updateStyle(element, old, value)
		else if (key in element && !isAttribute(key) && ns === undefined && !isCustomElement(vnode)) {
			if (key === "value") {
				var normalized = "" + value // eslint-disable-line no-implicit-coercion
				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized && vnode.dom === $doc.activeElement) return
				//setting select[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "select") {
					if (value === null) {
						if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
					} else {
						if (old !== null && vnode.dom.value === normalized && vnode.dom === $doc.activeElement) return
					}
				}
				//setting option[value] to same value while having select open blinks select dropdown in Chrome
				if (vnode.tag === "option" && old != null && vnode.dom.value === normalized) return
			}
			// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
			if (vnode.tag === "input" && key === "type") {
				element.setAttribute(key, value)
				return
			}
			element[key] = value
		}
		else {
			if (typeof value === "boolean") {
				if (value) element.setAttribute(key, "")
				else element.removeAttribute(key)
			}
			else element.setAttribute(key === "className" ? "class" : key, value)
		}
	}
	function setLateAttrs(vnode) {
		var attrs = vnode.attrs
		if (vnode.tag === "select" && attrs != null) {
			if ("value" in attrs) setAttr(vnode, "value", null, attrs.value, undefined)
			if ("selectedIndex" in attrs) setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, undefined)
		}
	}
	function updateAttrs(vnode, old, attrs, ns) {
		if (attrs != null) {
			for (var key in attrs) {
				setAttr(vnode, key, old && old[key], attrs[key], ns)
			}
		}
		if (old != null) {
			for (var key in old) {
				if (attrs == null || !(key in attrs)) {
					if (key === "className") key = "class"
					if (key[0] === "o" && key[1] === "n" && !isLifecycleMethod(key)) updateEvent(vnode, key, undefined)
					else if (key !== "key") vnode.dom.removeAttribute(key)
				}
			}
		}
	}
	function isFormAttribute(vnode, attr) {
		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
	}
	function isLifecycleMethod(attr) {
		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
	}
	function isAttribute(attr) {
		return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
	}
	function isCustomElement(vnode){
		return vnode.attrs.is || vnode.tag.indexOf("-") > -1
	}
	function hasIntegrationMethods(source) {
		return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
	}

	//style
	function updateStyle(element, old, style) {
		if (old === style) element.style.cssText = "", old = null
		if (style == null) element.style.cssText = ""
		else if (typeof style === "string") element.style.cssText = style
		else {
			if (typeof old === "string") element.style.cssText = ""
			for (var key in style) {
				element.style[key] = style[key]
			}
			if (old != null && typeof old !== "string") {
				for (var key in old) {
					if (!(key in style)) element.style[key] = ""
				}
			}
		}
	}

	//event
	function updateEvent(vnode, key, value) {
		var element = vnode.dom
		var callback = typeof onevent !== "function" ? value : function(e) {
			var result = value.call(element, e)
			onevent.call(element, e)
			return result
		}
		if (key in element) element[key] = typeof value === "function" ? callback : null
		else {
			var eventName = key.slice(2)
			if (vnode.events === undefined) vnode.events = {}
			if (vnode.events[key] === callback) return
			if (vnode.events[key] != null) element.removeEventListener(eventName, vnode.events[key], false)
			if (typeof value === "function") {
				vnode.events[key] = callback
				element.addEventListener(eventName, vnode.events[key], false)
			}
		}
	}

	//lifecycle
	function initLifecycle(source, vnode, hooks) {
		if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
		if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
	}
	function updateLifecycle(source, vnode, hooks) {
		if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
	}
	function shouldNotUpdate(vnode, old) {
		var forceVnodeUpdate, forceComponentUpdate
		if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
		if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
		if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
			vnode.dom = old.dom
			vnode.domSize = old.domSize
			vnode.instance = old.instance
			return true
		}
		return false
	}

	function render(dom, vnodes) {
		if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
		var hooks = []
		var active = $doc.activeElement
		var namespace = dom.namespaceURI

		// First time rendering into a node clears it out
		if (dom.vnodes == null) dom.textContent = ""

		if (!Array.isArray(vnodes)) vnodes = [vnodes]
		updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
		dom.vnodes = vnodes
		// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
		if (active != null && $doc.activeElement !== active) active.focus()
		for (var i = 0; i < hooks.length; i++) hooks[i]()
	}

	return {render: render, setEventCallback: setEventCallback}
}

},{"../render/vnode":120}],119:[function(require,module,exports){
"use strict"

var Vnode = require("../render/vnode")

module.exports = function(html) {
	if (html == null) html = ""
	return Vnode("<", undefined, undefined, html, undefined, undefined)
}

},{"../render/vnode":120}],120:[function(require,module,exports){
"use strict"

function Vnode(tag, key, attrs, children, text, dom) {
	return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
}
Vnode.normalize = function(node) {
	if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
	if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
	return node
}
Vnode.normalizeChildren = function normalizeChildren(children) {
	for (var i = 0; i < children.length; i++) {
		children[i] = Vnode.normalize(children[i])
	}
	return children
}

module.exports = Vnode

},{}],121:[function(require,module,exports){
"use strict"

module.exports = require("./stream/stream")

},{"./stream/stream":122}],122:[function(require,module,exports){
/* eslint-disable */
;(function() {
"use strict"
/* eslint-enable */

var guid = 0, HALT = {}
function createStream() {
	function stream() {
		if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])
		return stream._state.value
	}
	initStream(stream)

	if (arguments.length > 0 && arguments[0] !== HALT) updateStream(stream, arguments[0])

	return stream
}
function initStream(stream) {
	stream.constructor = createStream
	stream._state = {id: guid++, value: undefined, state: 0, derive: undefined, recover: undefined, deps: {}, parents: [], endStream: undefined, unregister: undefined}
	stream.map = stream["fantasy-land/map"] = map, stream["fantasy-land/ap"] = ap, stream["fantasy-land/of"] = createStream
	stream.valueOf = valueOf, stream.toJSON = toJSON, stream.toString = valueOf

	Object.defineProperties(stream, {
		end: {get: function() {
			if (!stream._state.endStream) {
				var endStream = createStream()
				endStream.map(function(value) {
					if (value === true) {
						unregisterStream(stream)
						endStream._state.unregister = function(){unregisterStream(endStream)}
					}
					return value
				})
				stream._state.endStream = endStream
			}
			return stream._state.endStream
		}}
	})
}
function updateStream(stream, value) {
	updateState(stream, value)
	for (var id in stream._state.deps) updateDependency(stream._state.deps[id], false)
	if (stream._state.unregister != null) stream._state.unregister()
	finalize(stream)
}
function updateState(stream, value) {
	stream._state.value = value
	stream._state.changed = true
	if (stream._state.state !== 2) stream._state.state = 1
}
function updateDependency(stream, mustSync) {
	var state = stream._state, parents = state.parents
	if (parents.length > 0 && parents.every(active) && (mustSync || parents.some(changed))) {
		var value = stream._state.derive()
		if (value === HALT) return false
		updateState(stream, value)
	}
}
function finalize(stream) {
	stream._state.changed = false
	for (var id in stream._state.deps) stream._state.deps[id]._state.changed = false
}

function combine(fn, streams) {
	if (!streams.every(valid)) throw new Error("Ensure that each item passed to stream.combine/stream.merge is a stream")
	return initDependency(createStream(), streams, function() {
		return fn.apply(this, streams.concat([streams.filter(changed)]))
	})
}

function initDependency(dep, streams, derive) {
	var state = dep._state
	state.derive = derive
	state.parents = streams.filter(notEnded)

	registerDependency(dep, state.parents)
	updateDependency(dep, true)

	return dep
}
function registerDependency(stream, parents) {
	for (var i = 0; i < parents.length; i++) {
		parents[i]._state.deps[stream._state.id] = stream
		registerDependency(stream, parents[i]._state.parents)
	}
}
function unregisterStream(stream) {
	for (var i = 0; i < stream._state.parents.length; i++) {
		var parent = stream._state.parents[i]
		delete parent._state.deps[stream._state.id]
	}
	for (var id in stream._state.deps) {
		var dependent = stream._state.deps[id]
		var index = dependent._state.parents.indexOf(stream)
		if (index > -1) dependent._state.parents.splice(index, 1)
	}
	stream._state.state = 2 //ended
	stream._state.deps = {}
}

function map(fn) {return combine(function(stream) {return fn(stream())}, [this])}
function ap(stream) {return combine(function(s1, s2) {return s1()(s2())}, [stream, this])}
function valueOf() {return this._state.value}
function toJSON() {return this._state.value != null && typeof this._state.value.toJSON === "function" ? this._state.value.toJSON() : this._state.value}

function valid(stream) {return stream._state }
function active(stream) {return stream._state.state === 1}
function changed(stream) {return stream._state.changed}
function notEnded(stream) {return stream._state.state !== 2}

function merge(streams) {
	return combine(function() {
		return streams.map(function(s) {return s()})
	}, streams)
}

function scan(reducer, seed, stream) {
	var newStream = combine(function (s) {
		return seed = reducer(seed, s._state.value)
	}, [stream])

	if (newStream._state.state === 0) newStream(seed)

	return newStream
}

function scanMerge(tuples, seed) {
	var streams = tuples.map(function(tuple) {
		var stream = tuple[0]
		if (stream._state.state === 0) stream(undefined)
		return stream
	})

	var newStream = combine(function() {
		var changed = arguments[arguments.length - 1]

		streams.forEach(function(stream, idx) {
			if (changed.indexOf(stream) > -1) {
				seed = tuples[idx][1](seed, stream._state.value)
			}
		})

		return seed
	}, streams)

	return newStream
}

createStream["fantasy-land/of"] = createStream
createStream.merge = merge
createStream.combine = combine
createStream.scan = scan
createStream.scanMerge = scanMerge
createStream.HALT = HALT

if (typeof module !== "undefined") module["exports"] = createStream
else if (typeof window.m === "function" && !("stream" in window.m)) window.m.stream = createStream
else window.m = {stream : createStream}

}());

},{}],123:[function(require,module,exports){
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],124:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],125:[function(require,module,exports){
(function (process,setImmediate){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof self !== "undefined") {
        self.Q = definition();

    } else {
        throw new Error("This environment was not anticiapted by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":124,"timers":129}],126:[function(require,module,exports){
/*
 * Qanimationframe.js - Promisified requestAnimationFrame with Q
 */
/*jslint newcap: true */
(function (definition) {
    if (typeof exports === "object") {
        module.exports = definition();
    } else {
        window.QanimationFrame = definition();
    }
})(function () {
  "use strict";

  // Import Q
  var Q = window.Q || require("q");

  // requestAnimationFrame polyfill
  var requestAnimationFrame = (function(){
    return window.requestAnimationFrame       ||
           window.oRequestAnimationFrame      ||
           window.msRequestAnimationFrame     ||
           window.mozRequestAnimationFrame    ||
           window.webkitRequestAnimationFrame ||
           function (callback) {
             window.setTimeout(callback, 1000 / 60);
           };
  })();

  // QanimationFrame(f: function) => promise containing the return value of f
  // ---
  //
  var QanimationFrame = function (f) {
    var d = Q.defer();
    requestAnimationFrame(function () {
      try {
        d.resolve(f());
      } catch (e) {
        d.reject(e);
      }
    });
    return d.promise;
  };

  return QanimationFrame;
});

},{"q":125}],127:[function(require,module,exports){
// This library started as an experiment to see how small I could make
// a functional router. It has since been optimized (and thus grown).
// The redundancy and inelegance here is for the sake of either size
// or speed.
(function (root, factory) {
  var define = root.define;

  if (define && define.amd) {
    define('rlite', [], factory);
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = factory();
  } else {
    root.Rlite = factory();
  }
}(this, function () { return function() {
    var routes = {},
        decode = decodeURIComponent;

    function noop(s) { return s; }

    function sanitize(url) {
      ~url.indexOf('/?') && (url = url.replace('/?', '?'));
      url[0] == '/' && (url = url.slice(1));
      url[url.length - 1] == '/' && (url = url.slice(0, -1));

      return url;
    }

    function processUrl(url, esc) {
      var pieces = url.split('/'),
          rules = routes,
          params = {};

      for (var i = 0; i < pieces.length && rules; ++i) {
        var piece = esc(pieces[i]);
        rules = rules[piece.toLowerCase()] || rules[':'];
        rules && rules['~'] && (params[rules['~']] = piece);
      }

      return rules && {
        cb: rules['@'],
        params: params
      };
    }

    function processQuery(url, ctx, esc) {
      if (url && ctx.cb) {
        var hash = url.indexOf('#'),
            query = (hash < 0 ? url : url.slice(0, hash)).split('&');

        for (var i = 0; i < query.length; ++i) {
          var nameValue = query[i].split('=');

          ctx.params[nameValue[0]] = esc(nameValue[1]);
        }
      }

      return ctx;
    }

    function lookup(url) {
      var querySplit = sanitize(url).split('?'),
          esc = ~url.indexOf('%') ? decode : noop;

      return processQuery(querySplit[1], processUrl(querySplit[0], esc) || {}, esc);
    }

    return {
      add: function(route, handler) {

        var pieces = route.split('/'),
            rules = routes;

        for (var i = 0; i < pieces.length; ++i) {
          var piece = pieces[i],
              name = piece[0] == ':' ? ':' : piece.toLowerCase();

          rules = rules[name] || (rules[name] = {});

          name == ':' && (rules['~'] = piece.slice(1));
        }

        rules['@'] = handler;
      },

      exists: function (url) {
        return !!lookup(url).cb;
      },

      lookup: lookup,

      run: function(url) {
        var result = lookup(url);

        result.cb && result.cb({
          url: url,
          params: result.params
        });

        return !!result.cb;
      }
    };
  };
}));

},{}],128:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],129:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":124,"timers":129}],130:[function(require,module,exports){
'use strict';

var style = document.createElement('p').style,
    prefixes = 'O ms Moz webkit'.split(' '),
    hasPrefix = /^(o|ms|moz|webkit)/,
    upper = /([A-Z])/g,
    memo = {};

function get(key){
    return (key in memo) ? memo[key] : memo[key] = prefix(key);
}

function prefix(key){
    var capitalizedKey = key.replace(/-([a-z])/g, function(s, match){
            return match.toUpperCase();
        }),
        i = prefixes.length,
        name;

    if (style[capitalizedKey] !== undefined) return capitalizedKey;

    capitalizedKey = capitalize(key);

    while (i--) {
        name = prefixes[i] + capitalizedKey;
        if (style[name] !== undefined) return name;
    }

    throw new Error('unable to prefix ' + key);
}

function capitalize(str){
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function dashedPrefix(key){
    var prefixedKey = get(key),
        upper = /([A-Z])/g;

    if (upper.test(prefixedKey)) {
        prefixedKey = (hasPrefix.test(prefixedKey) ? '-' : '') + prefixedKey.replace(upper, '-$1');
    }

    return prefixedKey.toLowerCase();
}

module.exports = get;
module.exports.dash = dashedPrefix;

},{}],131:[function(require,module,exports){
// Zanimo.js - Promise based CSS3 transitions
// (c) 2011-2014 Paul Panserrieu

'use strict';

var Q = require('q'),
    QanimationFrame = require('qanimationframe'),
    prefix = require('vendor-prefix'),
    normalizeTransformValue = require('../src/normalize-transform-value'),
    shorthand = require('../src/transition-shorthand-property'),
    transition = prefix('transition'),
    transitionend = 'WebkitTransition' in document.body.style ? 'webkitTransitionEnd' : 'transitionend',

    isDOM = function (el) {
        try {
            return el && el.nodeType;
        } catch(err) {
            return false;
        };
    },

    addTransition = function (elt, attr, value, duration, easing) {
        var currentValue = elt.style[transition];
        attr = prefix.dash(attr);
        if (currentValue) {
            elt.style[transition] = currentValue + ", " + shorthand(attr, duration, easing);
        }
        else {
            elt.style[transition] = shorthand(attr, duration, easing);
        }
        elt.style[prefix(attr)] = value;
    },

    removeTransition = function (el, attr) {
        el.style[transition] = el.style[transition]
            .split(',').filter(function(t) {
                return !t.match(attr);
            }).join(',');
    },

    applycss = function (el, attr, value) {
        return QanimationFrame(function(){
            el.style[prefix.dash(attr)] = value;
            return el;
        });
    },

    css = function (el, attr, value) {
        if(el._zanimo && el._zanimo.hasOwnProperty(attr)) {
            el._zanimo[attr].defer.reject(new Error(
                "Zanimo transition with transform=" +
                el._zanimo[attr].value +
                " stopped by transform=" + value
            ));
            el._zanimo[attr].cb();
        }
        return applycss(el, attr, value);
    },

    animate = function (el, attr, value, duration, easing) {
        var prefixed = prefix.dash(attr),
            d = Q.defer(),
            timeout,
            cb = function (clear) {
                if (timeout) { clearTimeout(timeout); timeout = null; }
                removeTransition(el, attr);
                el.removeEventListener(transitionend, cbTransitionend);
                if (clear) { delete el._zanimo[attr]; }
            },
            cbTransitionend = function (evt) {
                if(prefix(evt.propertyName) === prefix(prefixed)) {
                    cb(true);
                    d.resolve(el);
                }
            };

        el.addEventListener(transitionend, cbTransitionend);

        QanimationFrame(function () {
            addTransition(el, attr, normalizeTransformValue(value), duration, easing);
            timeout = setTimeout(function () {
                var rawVal = el.style.getPropertyValue(prefixed),
                    domVal = normalizeTransformValue(rawVal),
                    givenVal = normalizeTransformValue(value);

                cb(true);
                if (domVal === givenVal) { d.resolve(el); }
                else {
                    d.reject( new Error("Zanimo transition: with "
                        + attr + " = " + givenVal + ", DOM value=" + domVal
                    ));
                }
            }, duration + 20 );

            el._zanimo = el._zanimo || { };
            if(el._zanimo[attr]) {
                el._zanimo[attr].defer.reject(new Error(
                    "Zanimo transition with " +
                    attr + "=" + el._zanimo[attr].value +
                    " stopped by transition with " + attr + "=" + value
                ));
                el._zanimo[attr].cb();
            }
            el._zanimo[attr] = {cb: cb, value: value, defer: d};
        });

        return d.promise;
    };

/**
 * Zanimo(el | promise[el])
 * > Returns a Promise of el.
 *
 * Zanimo(el | promise[el], attr, value)
 * > Sets el.style[attr]=value and returns the promise of el.
 *
 * Zanimo(el | promise[el], attr, value, duration, [easing])
 * > Performs a transition.
 */
var Zanimo = function (el, attr, value, duration, easing) {
    var args = arguments,
        arity = arguments.length;
    if (arity === 0 || arity === 2 || arity > 5) {
        return Q.reject(new Error("Zanimo invalid arguments"));
    }
    if (Q.isPromise(el)) {
        return el.then(function (val) {
            return Zanimo.apply(this, [val].concat(Array.prototype.slice.call(args, 1)));
        });
    }
    if (!isDOM(el)) {
        return Q.reject(new Error("Zanimo require an HTMLElement, or a promise of an HTMLElement"));
    }
    if (arity === 1) {
        return Q(el);
    }
    try {
        prefix.dash(attr);
    } catch(err) {
        return Q.reject(new Error("Zanimo transition: " + attr + ' is not supported!'));
    };
    if (arity === 3) {
        return css(el, attr, value);
    }
    if(window.isNaN(parseInt(duration, 10))) {
        return Q.reject(new Error("Zanimo transition: duration must be an integer!"));
    }
    return animate(el, attr, value, duration, easing);
};

/**
 * A function wrapping `Zanimo(el, ...)` as a `f(...)(el)` for easy chaining purpose.
 */
Zanimo.f = function (attr, value, duration, easing) {
    var args = Array.prototype.slice.call(arguments);
    return function (el) {
        return Zanimo.apply(this, [el].concat(args));
    };
};

module.exports = Zanimo;

},{"../src/normalize-transform-value":133,"../src/transition-shorthand-property":134,"q":125,"qanimationframe":126,"vendor-prefix":130}],132:[function(require,module,exports){
'use strict';

var matchParenthesis = /(\(.+?\))/g,
    space = / +/g,
    emptyString = "",
    whitespace = " ",

    normalize = function (match) {
        var args = match.substr(1, match.length-2).split(","),
            rst = args.map(function (arg) {
                return parseFloat(arg.replace(space, emptyString));
            });
        return "(" + rst.join(",") + ")";
    };

module.exports = function (t) {
    return  typeof t === 'string' ? t.replace(space, whitespace).replace(matchParenthesis, normalize) : t;
};

},{}],133:[function(require,module,exports){
'use strict';

var Color = require('color'),
    matchParenthesis = /(\(.+?\))/g,
    matchColors = /(\brgba\b|\bhsl\b|\bhsla\b)(\(.+?\))/g,
    space = / +/g,
    emptyString = "",
    whitespace = " ",
    zeropixel = /^0px$/g,
    zero = "0",

    normArgs = function (match) {
        var args = match.substr(1, match.length-2).split(","),
            rst = args.map(function (arg) {
                return arg.replace(space, emptyString).replace(zeropixel, zero);
            });
        return "(" + rst.join(",") + ")";
    },

    normColors = function (match) {
        var c = Color(match);
        if (c.alpha() ) { c.alpha(Math.round(c.alpha() * 10) / 10); }
        return c.rgbString();
    },

    normalize = function (val) {
        return val.replace(space, whitespace)
            .replace(matchColors, normColors)
            .replace(matchParenthesis, normArgs);
    };

module.exports = function (val) {
    if (val === null || val === undefined) return emptyString;
    return window.isNaN(val) ? normalize(val) : val.toString();
};

},{"color":6}],134:[function(require,module,exports){
'use strict';

var prefix = require('vendor-prefix'),
    normalizeTransformValue = require('./normalize-transform-value'),
    normalizeTimingFunction = require('./normalize-timing-function'),
    transition = prefix.dash('transition'),
    el = document.createElement('div'),
    test = 'opacity 100ms linear 0s',
    normalizedTest = normalizeTransformValue(test),
    shorthand = function shorthand(v, d, t) {
        return v + " " + d + "ms " + (t || "linear");
    };

el.style[transition] = normalizedTest;

if(normalizeTransformValue(el.style[transition]) === normalizedTest) {
    shorthand = function (v, d, t) {
        return v + " " + d + "ms " + (normalizeTimingFunction(t) || "linear") + " 0s";
    };
}

module.exports = shorthand;

},{"./normalize-timing-function":132,"./normalize-transform-value":133,"vendor-prefix":130}],135:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = backbutton;

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('./utils');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stack = [];

function backbutton() {
  var b = stack.pop();
  if ((0, _isFunction2.default)(b)) {
    b('backbutton');
    _mithril2.default.redraw();
  } else if (!/^\/$/.test(_mithril2.default.route())) {
    // if playing a game as anon ask for confirmation
    if (/^\/game\/[a-zA-Z0-9]{12}/.test(_mithril2.default.route())) {
      navigator.notification.confirm((0, _i18n2.default)('thereIsAGameInProgress'), function (i) {
        if (i === 1) (0, _utils.backHistory)();
      });
    } else {
      (0, _utils.backHistory)();
    }
  } else {
    window.navigator.app.exitApp();
  }
};

backbutton.stack = stack;

},{"./i18n":138,"./utils":210,"lodash/isFunction":97,"mithril":114}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var defaults = {
  apiVersion: 1,
  fetchTimeoutMs: 10000
};

var config = Object.assign({}, defaults, window.oyunkeyf);

exports.default = config;

},{}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.apiVersion = exports.SESSION_ID_KEY = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.fetchJSON = fetchJSON;

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _spinner = require('./spinner');

var _spinner2 = _interopRequireDefault(_spinner);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _querystring = require('./utils/querystring');

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SESSION_ID_KEY = exports.SESSION_ID_KEY = 'sessionId';

var baseUrl = _config2.default.apiEndPoint;

function addQueryString(url, queryString) {
  var prefix = url.indexOf('?') < 0 ? '?' : '&';
  var res = url + prefix + queryString;
  return res;
}

function request(url, type, opts, feedback) {

  var timeoutId = void 0;

  function onComplete() {
    clearTimeout(timeoutId);
    if (feedback) _spinner2.default.stop();
  }

  if (opts && opts.query) {
    var query = (0, _querystring.buildQueryString)(opts.query);
    if (query !== '') {
      url = addQueryString(url, query);
    }
    delete opts.query;
  }

  var cfg = {
    method: 'GET',
    headers: {
      'X-Requested-With': 'XMLHttpRequest',
      'Accept': 'application/vnd.oyunkeyf.v' + _config2.default.apiVersion + '+json'
    }
  };

  (0, _merge2.default)(cfg, opts);

  var init = _extends({}, cfg, {
    credentials: 'include',
    headers: new Headers(cfg.headers)
  });

  if ((init.method === 'POST' || init.method === 'PUT') && !init.headers.get('Content-Type')) {
    init.headers.append('Content-Type', 'application/json; charset=UTF-8');
    if (!init.body) {
      init.body = '{}';
    }
  }

  var sid = _storage2.default.get(SESSION_ID_KEY);
  if (sid !== null) {
    init.headers.append(SESSION_ID_KEY, sid);
  }

  var fullUrl = url.indexOf('http') > -1 ? url : baseUrl + url;

  var timeoutPromise = new Promise(function (_, reject) {
    timeoutId = setTimeout(function () {
      return reject(new Error('Request timeout'));
    }, _config2.default.fetchTimeoutMs);
  });

  var respOrTimeout = Promise.race([fetch(fullUrl, init), timeoutPromise]);

  if (feedback) {
    _spinner2.default.spin();
  }

  return new Promise(function (resolve, reject) {
    respOrTimeout.then(function (r) {
      onComplete();
      if (r.ok) {
        resolve(r[type]());
      } else {
        r.text().then(function (bodyText) {
          try {
            reject({
              status: r.status,
              body: JSON.parse(bodyText)
            });
          } catch (_) {
            reject({
              status: r.status,
              body: r.statusText
            });
          }
        });
      }
    }).catch(function (err) {
      console.log('error ' + err);
      onComplete();
      reject({
        status: 0,
        body: err.message
      });
    });
  });
}

function fetchJSON(url, opts) {
  var feedback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  return request(url, 'json', opts, feedback);
}

var apiVersion = exports.apiVersion = 1;

// const baseUrl = window.oyunkeyf.apiEndPoint;

function onSuccess(data) {
  _spinner2.default.stop();
  return data;
}

function onError(data) {
  _spinner2.default.stop();
  throw data;
}

function xhrConfig(xhr) {
  xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
  xhr.setRequestHeader('Accept', 'application/vnd.oyunkeyf.v' + apiVersion + '+json');
  xhr.withCredentials = true;
  xhr.timeout = 8000;
}

// convenient wrapper around m.request
// export function request(url, opts, feedback, xhrConf) {
//   var cfg = {
//     url: baseUrl + url,
//     method: 'GET',
//     data: { },
//     config: xhrConf || xhrConfig,
//     deserialize: function(text) {
//       try {
//         return JSON.parse(text);
//       } catch (e) {
//         throw { response: { error: 'Cannot read data from the server' }};
//       }
//     },
//     unwrapError: function(response, xhr) {
//       return { response, status: xhr.status };
//     }
//   };
//   merge(cfg, opts);

//   if (cfg.method === 'GET') {
//     cfg.data._ = Date.now();
//   }

//   var promise = m.request(cfg);

//   if (feedback) {
//     spinner.spin(document.body);
//     return promise.then(onSuccess, onError);
//   } else {
//     return promise;
//   }
// }

},{"./config":136,"./spinner":151,"./storage":152,"./utils/querystring":211,"lodash/merge":105}],138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLang = getLang;
exports.default = i18n;
exports.loadPreferredLanguage = loadPreferredLanguage;
exports.loadLanguage = loadLanguage;

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultCode = 'tr-TR';

var lang = defaultCode;
var messages = {};

var untranslated = {};

function getLang() {
  return lang;
}

function i18n(key) {
  var str = messages[key] || untranslated[key] || key;

  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  args.forEach(function (a) {
    str = str.replace('%s', String(a));
  });

  return str;
}

function loadPreferredLanguage() {
  var fromSettings = _settings2.default.general.lang();
  if (fromSettings) {
    return loadLanguage(fromSettings);
  }

  return new Promise(function (resolve) {
    window.navigator.globalization.getPreferredLanguage(function (l) {
      return resolve(l.value.split('-')[0]);
    }, function () {
      return resolve(defaultCode);
    });
  }).then(function (code) {
    _settings2.default.general.lang(code);
    return code;
  }).then(loadFile).then(loadMomentLocale);
}

function loadLanguage(lang) {
  return loadFile(lang).then(loadMomentLocale);
}

function loadFile(code) {
  return (0, _utils.loadLocalJsonFile)('i18n/' + code + '.json').then(function (data) {
    lang = code;
    messages = data;
    return code;
  }).catch(function (error) {
    if (code === defaultCode) throw new Error(error);
    return loadFile(defaultCode);
  });
}

// export function getAvailableLanguages() {
//   return m.request({
//     url: 'i18n/refs.json',
//     method: 'GET'
//   }).then(data => { return data; }, error => {
//     // same workaround for iOS as above
//     if (error && error[0][0] === 'tr')
//       return error;
//     else
//       throw { error: 'Cannot load languages' };
//   });
// }


// export function loadFromSettings() {
//   return loadFile(settings.general.lang()).then(loadMomentLocale);
// }

// function loadFile(code) {
//   return m.request({
//     url: 'i18n/' + code + '.json',
//     method: 'GET',
//     deserialize: function(text) {
//       try {
//         return JSON.parse(text);
//       } catch (e) {
//         throw { error: 'Lang not available' };
//       }
//     }
//   }).then(function(data) {
//     messages = data;
//     return code;
//   }, function(error) {
//     // workaround for iOS: because xhr for local file has a 0 status it will
//     // reject the promise and still have the response object
//     if (error && error.playWithAFriend) {
//       messages = error;
//       return code;
//     } else {
//       if (code === defaultCode) throw new Error(error);
//       return loadFile(defaultCode);
//     }
//   });
// }

function loadMomentLocale(code) {
  if (code !== 'en') {
    var script = document.createElement('script');
    script.src = 'moment/locale/' + code + '.js';
    document.head.appendChild(script);
  }
  window.moment.locale(code);
  return code;
}

},{"./settings":148,"./utils":210}],139:[function(require,module,exports){
'use strict';

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('./i18n');

var _xhr = require('./xhr');

var xhr = _interopRequireWildcard(_xhr);

var _helper = require('./ui/helper');

var helper = _interopRequireWildcard(_helper);

var _backbutton = require('./backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _socket = require('./socket');

var _socket2 = _interopRequireDefault(_socket);

var _routes = require('./routes');

var _routes2 = _interopRequireDefault(_routes);

var _router = require('./router');

var _router2 = _interopRequireDefault(_router);

var _appMode = require('./utils/appMode');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.moment = _moment2.default; /* application entry point */

// import './polyfills';


// for moment a global object makes loading locales easier


var firstConnection = true;

function main() {
  _routes2.default.init();
  // cache viewport dims
  helper.viewportDim();

  // pull session data once (to log in user automatically thanks to cookie)
  // and also listen to online event in case network was disconnected at app
  // startup
  if (utils.hasNetwork()) {
    onOnline();
  }

  document.addEventListener('online', onOnline, false);
  document.addEventListener('offline', onOffline, false);
  document.addEventListener('resume', onResume, false);
  document.addEventListener('pause', onPause, false);
  document.addEventListener('backbutton', _router2.default.backbutton, false);
  window.addEventListener('unload', function () {
    _socket2.default.destroy();
    _socket2.default.terminate();
  });
  window.addEventListener('resize', onResize, false);

  if (cordova.platformId === 'android') {
    window.StatusBar.backgroundColorByHexString('#151A1E');
  }

  setTimeout(function () {
    window.navigator.splashscreen.hide();
    window.StatusBar.hide();
    // xhrStatus();
  }, 500);
}

function onOnline() {
  if ((0, _appMode.isForeground)()) {
    if (firstConnection) {
      firstConnection = false;
      // xhr.status();

      _session2.default.rememberLogin().then(function (user) {
        var serverLang = user.language && user.language.split('-')[0];
        if (serverLang) {
          (0, _i18n.ensureLangIsAvailable)(serverLang).then(function (lang) {
            _settings2.default.general.lang(lang);
            (0, _i18n.loadLanguage)(lang);
          });
        }
        (0, _redraw2.default)();
      }).catch(function () {
        console.log('connected as anonymous');
      });
    } else {
      _socket2.default.connect();
      _session2.default.refresh();
    }
  }
}

function onOffline() {
  if ((0, _appMode.isForeground)() && !hasNetwork()) {
    _socket2.default.disconnect();
    (0, _redraw2.default)();
  }
}

function onResize() {
  helper.clearCachedViewportDim();
  (0, _redraw2.default)();
}

function onResume() {
  (0, _appMode.setForeground)();
  _session2.default.refresh();
  _socket2.default.connect();
  (0, _redraw2.default)();
}

function onPause() {
  (0, _appMode.setBackground)();
  _socket2.default.disconnect();
}

// function handleError(event, source, fileno, columNumber) {
//   var description = event + ' at ' + source + ' [' + fileno + ', ' + columNumber + ']';
// }

// window.onerror = handleError;

document.addEventListener('deviceready', function () {
  return (0, _i18n.loadPreferredLanguage)().then(main);
}, false);

},{"./backbutton":135,"./i18n":138,"./router":145,"./routes":146,"./session":147,"./settings":148,"./socket":150,"./ui/helper":157,"./utils":210,"./utils/appMode":208,"./utils/redraw":212,"./xhr":215,"moment":123}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _status = require('./status');

var _status2 = _interopRequireDefault(_status);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function playable(data) {
  return data.game.status.id < _status2.default.ids.aborted;
}

function isPlayerPlaying(data) {
  return playable(data) && !data.player.spectator;
}

function isPlayerTurn(data) {
  return isPlayerPlaying(data) && data.game.player === data.player.side;
}

function getPlayer(data, side) {
  return ['player', 'opponentLeft', 'opponentRight', 'opponentUp'].map(function (k) {
    return data[k];
  }).filter(function (player) {
    return player.side === side;
  })[0];
}

function result(data) {
  if (_status2.default.aborted(data)) {
    return (0, _i18n2.default)('gameAborted');
  } else if (_status2.default.finished(data)) {
    return (0, _i18n2.default)('gameFinished');
  }
};

var sides = ["east", "north", "west", "south"];

function sideByPly(ply) {
  return sides[ply % 4];
}

function setOnGame(data, side, onGame) {
  var player = getPlayer(data, side);
  player.onGame = onGame;
}

// function roundsOrScores(game) {
//   if (game.rounds) {
//     return data.
//   } else if (data.scores) {

//   } else {
//     return '';
//   }
// }

function title(data) {
  var text;
  if (isPlayerTurn(data)) {
    text = (0, _i18n2.default)('yourTurn');
  } else {
    text = (0, _i18n2.default)('waitingForOpponent');
  }
  // const variant = getVariant(data.game.variant.key);
  // const name = variant ? (variant.shortName || variant.name) : '';
  return text;
}

exports.default = {
  isPlayerPlaying: isPlayerPlaying,
  isPlayerTurn: isPlayerTurn,
  getPlayer: getPlayer,
  sideByPly: sideByPly,
  playable: playable,
  setOnGame: setOnGame,
  title: title,
  result: result
};

},{"../i18n":138,"./status":143}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.playerName = playerName;
exports.aiName = aiName;

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function playerName(player) {
  if (player.name || player.username || player.user) {
    var name = player.name || player.username || player.user.username;
    return name;
  }
  if (player.ai) {
    return aiName(player);
  }
  return 'Anonymous';
}

function aiName(player) {
  return (0, _i18n2.default)('aiBot', 1);
}

},{"../i18n":138}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.humanSetupFromSettings = humanSetupFromSettings;
function humanSetupFromSettings(settingsObj) {
  return {
    mode: settingsObj.mode(),
    variant: settingsObj.variant(),
    rounds: settingsObj.rounds()
  };
}

},{}],143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ids = {
  created: 10,
  started: 20,
  aborted: 25,
  middleEnd: 30,
  normalEnd: 40,
  variantEnd: 70
}; // scalaokey/src/main/scala/Status.scala

function started(data) {
  return data.game.status.id >= ids.started;
}

function finished(data) {
  return data.game.status.id >= ids.middleEnd;
}

function aborted(data) {
  return data.game.status.id === ids.aborted;
}

function middleEnd(data) {
  return data.game.status.id === ids.middleEnd;
}

function playing(data) {
  return started(data) && !finished(data) && !aborted(data);
}

function toLabel(status, winner, variant) {
  switch (status) {
    case 'started':
      return (0, _i18n2.default)('playingRightNow');
    case 'aborted':
      return (0, _i18n2.default)('gameAborted');
    case 'middleEnd':
      return (0, _i18n2.default)('gameMiddleFinished');
    case 'normalEnd':
      return (0, _i18n2.default)('gameFinished');
    case 'variantEnd':
      return (0, _i18n2.default)('gameFinished');
  }
};

exports.default = {
  ids: ids,
  started: started,
  finished: finished,
  aborted: aborted,
  playing: playing,
  middleEnd: middleEnd,
  toLabel: toLabel
};

},{"../i18n":138}],144:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVariant = getVariant;
var variantMap = {
  yuzbir: {
    name: 'Yzbir',
    id: 1
  },
  yuzbirtest: {
    name: 'Yuzbir Test',
    id: 2
  },
  duzokey: {
    name: 'Dz Okey',
    id: 3
  },
  duzokeytest: {
    name: 'Dz Okey Test',
    id: 4
  }
};

function getVariant(key) {
  return variantMap[key];
}

},{}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineRoutes = defineRoutes;

var _rliteRouter = require('rlite-router');

var _rliteRouter2 = _interopRequireDefault(_rliteRouter);

var _render = require('mithril/render');

var RenderService = _interopRequireWildcard(_render);

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _vnode = require('mithril/render/vnode');

var _vnode2 = _interopRequireDefault(_vnode);

var _signals = require('./signals');

var _signals2 = _interopRequireDefault(_signals);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var router = new _rliteRouter2.default();

var currentStateId = 0;
var viewSlideDirection = 'fwd';

var previousPath = '/';

var uid = function () {
  var id = 0;
  return function () {
    return id++;
  };
}();

var backbutton = function () {
  var x = function x() {

    var b = x.stack.length === 0 ? null : x.stack.pop();

    if ((0, _isFunction2.default)(b)) {
      b('backbutton');
      (0, _redraw2.default)();
    } else if (!/^\/$/.test(get())) {
      backHistory();
    } else {
      window.navigator.app.exitApp();
    }
  };

  x.stack = [];

  return x;
}();

function defineRoutes(mountPoint, routes) {
  var _loop = function _loop(route) {
    var component = routes[route];
    router.add(route, function onRouteMatch(_ref) {
      var params = _ref.params;

      var RouteComponent = {
        view: function view() {
          var node = (0, _vnode2.default)(component, undefined, params);
          return node;
        }
      };

      function redraw() {
        RenderService.render(mountPoint, (0, _vnode2.default)(RouteComponent));
      }

      _signals2.default.redraw.removeAll();
      _signals2.default.redraw.add(redraw);
      try {
        redraw();
      } catch (e) {
        _signals2.default.redraw.removeAll();
        throw e;
      }
    });
  };

  for (var route in routes) {
    _loop(route);
  }
  window.addEventListener('popstate', processQuerystring);
  processQuerystring();
}

function processQuerystring(e) {
  if (e && e.state) {
    if (e.state.id < currentStateId) {
      viewSlideDirection = 'bwd';
    } else {
      viewSlideDirection = 'fwd';
    }
    currentStateId = e.state.id;
  }
  previousPath = get();
  var qs = window.location.search || '?=';
  var matched = router.run(qs.slice(2));
  if (!matched) router.run('/');
}

function assignState(state, path) {
  try {
    var newState = state ? Object.assign({}, window.history.state, state) : window.history.state;

    if (path !== undefined) {
      window.history.replaceState(newState, '', '?=' + path);
    } else {
      window.history.replaceState(newState, '');
    }
  } catch (e) {
    console.error(e);
  }
}

function replacePath(path) {
  assignState(undefined, path);
}

function doSet(path) {
  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  backbutton.stack = [];
  previousPath = get();
  if (replace) {
    replacePath(path);
  } else {
    var stateId = uid();
    currentStateId = stateId;
    viewSlideDirection = 'fwd';
    try {
      window.history.pushState({ id: stateId }, '', '?=' + path);
    } catch (e) {
      console.error(e);
    }
  }
  var matched = router.run(path);
  if (!matched) router.run('/');
}

function set(path) {
  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  setTimeout(function () {
    return doSet(path, replace);
  }, 0);
}

function get() {
  var path = window.location.search || '?=/';
  return decodeURIComponent(path.substring(2));
}

function backHistory() {
  window.history.go(-1);
}

exports.default = {
  get: get,
  set: set,
  backbutton: backbutton,
  backHistory: backHistory
};

},{"./signals":149,"./utils/redraw":212,"lodash/isFunction":97,"mithril/render":115,"mithril/render/vnode":120,"rlite-router":127}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _home = require('./ui/home');

var _home2 = _interopRequireDefault(_home);

var _game = require('./ui/game');

var _game2 = _interopRequireDefault(_game);

var _user = require('./ui/user');

var _user2 = _interopRequireDefault(_user);

var _players = require('./ui/players');

var _players2 = _interopRequireDefault(_players);

var _detail = require('./ui/masa/detail');

var _detail2 = _interopRequireDefault(_detail);

var _masa = require('./ui/masa');

var _masa2 = _interopRequireDefault(_masa);

var _todo = require('./ui/todo');

var _todo2 = _interopRequireDefault(_todo);

var _settings = require('./ui/settings');

var _settings2 = _interopRequireDefault(_settings);

var _lang = require('./ui/settings/lang');

var _lang2 = _interopRequireDefault(_lang);

var _router = require('./router');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  init: function init() {
    (0, _router.defineRoutes)(document.body, {
      '': _home2.default,
      '@/:id': _user2.default,
      'players': _players2.default,
      'game/:id': _game2.default,
      'masa/:masaId/game/:id': _game2.default,
      'masas': _masa2.default,
      'masa/:id': _detail2.default,
      'settings': _settings2.default,
      'settings/lang': _lang2.default,
      'todo': _todo2.default
    });
  }
};

},{"./router":145,"./ui/game":153,"./ui/home":159,"./ui/masa":169,"./ui/masa/detail":165,"./ui/players":175,"./ui/settings":179,"./ui/settings/lang":180,"./ui/todo":203,"./ui/user":204}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _http = require('./http');

var _utils = require('./utils');

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var session = void 0;

function isConnected() {
  return session !== undefined;
}

function getSession() {
  return session;
}

function isSession(data) {
  return data.id !== undefined;
}

function storeSession(d) {}

function login(username, password) {
  return (0, _http.fetchJSON)('/login', {
    method: 'POST',
    body: JSON.stringify({
      username: username,
      password: password
    })
  }, true).then(function (data) {
    if (isSession(data)) {
      session = data;
      if (session.sessionId) {
        _storage2.default.set(_http.SESSION_ID_KEY, session.sessionId);
      }
      // storeSession(data);
      return session;
    }
    return false;
  });
}

function signup(username, email, password) {
  return (0, _http.fetchJSON)('/signup', {
    method: 'POST',
    body: JSON.stringify({
      username: username,
      email: email,
      password: password
    })
  }, true).then(function (d) {
    if (isSession(d)) {
      session = d;
      if (session.sessionId) {
        _storage2.default.set(_http.SESSION_ID_KEY, session.sessionId);
      }
    }
    return d;
  });
}

function rememberLogin() {
  return (0, _http.fetchJSON)('/account/info').then(function (data) {
    session = data;
    storeSession(data);
    return data;
  });
}

function refresh() {
  return (0, _http.fetchJSON)('/account/info', { cache: 'reload' }).then(function (data) {
    session = data;
    storeSession(data);
    (0, _redraw2.default)();
  }).catch(function (err) {
    if (session !== undefined && err.status === 401) {
      session = undefined;
      onLogout();
      (0, _redraw2.default)();
      window.plugins.toast.show((0, _i18n2.default)('signedOut'), 'short', 'center');
    }
  });
}

function onLogout() {
  _storage2.default.remove(_http.SESSION_ID_KEY);
  signals.afterLogout.dispatch();
}

function logout() {
  return (0, _http.fetchJSON)('/logout', { method: 'GET' }, true).then(function () {
    session = undefined;
    (0, _redraw2.default)();
  }).catch(_utils.handleXhrError);
};

exports.default = {
  isConnected: isConnected,
  signup: signup,
  logout: logout,
  login: (0, _throttle2.default)(login, 1000),
  rememberLogin: (0, _throttle2.default)(rememberLogin, 1000),
  get: getSession,
  refresh: (0, _throttle2.default)(refresh, 1000)
};

},{"./http":137,"./i18n":138,"./settings":148,"./storage":152,"./utils":210,"./utils/redraw":212,"lodash/throttle":109}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

var _range = require('lodash/range');

var _range2 = _interopRequireDefault(_range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function tupleOf(x) {
  return [x.toString(), x.toString()];
}

exports.default = {
  general: {
    lang: _storage2.default.prop('settings.lang', null),
    theme: {
      background: _storage2.default.prop('settings.bgTheme', 'dark')
    }
  },
  game: {
    supportedVariants: ['standard', 'yuzbir', 'duzokey']
  },
  gameSetup: {
    availableRounds: [1, 5, 10, 15, 20, 25, 30].map(tupleOf),
    isRoundValid: function isRoundValid(gameSettings) {
      return gameSettings.rounds() !== '0';
    },
    human: {
      availableVariants: [['101 Okey', '1'], ['Dz Okey', '3']],
      variant: _storage2.default.prop('settings.game.human.variant', '1'),
      rounds: _storage2.default.prop('settings.game.human.rounds', '1'),
      mode: _storage2.default.prop('settings.game.human.mode', '0'),
      membersOnly: _storage2.default.prop('settings.game.human.membersOnly', false)
    }
  }
};

},{"./storage":152,"lodash/range":107}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _signals = require('signals');

exports.default = {

  redraw: new _signals.Signal(),

  afterLogin: new _signals.Signal(),

  afterLogout: new _signals.Signal(),

  sessionRestored: new _signals.Signal()

};

},{"signals":128}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _redraw = require('./utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _storage = require('./storage');

var _storage2 = _interopRequireDefault(_storage);

var _http = require('./http');

var _utils = require('./utils');

var _worker = require('./utils/worker');

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function setupConnection(setup, socketHandlers) {
  var sid = _storage2.default.get(_http.SESSION_ID_KEY);
  if (sid !== null) {
    if (setup.opts.params) {
      setup.opts.params[_http.SESSION_ID_KEY] = sid;
    } else {
      setup.opts.params = _defineProperty({}, _http.SESSION_ID_KEY, sid);
    }
  } else if (setup.opts.params) {
    delete setup.opts.params.sessionId;
  }
  setup.opts.options.isAuth = !!sid;
  worker.onmessage = function (msg) {
    switch (msg.data.topic) {
      case 'onOpen':
        if (socketHandlers.onOpen) socketHandlers.onOpen();
        break;
      case 'disconnected':
        onDisconnected();
        break;
      case 'connected':
        onConnected();
        break;
      case 'onError':
        if (socketHandlers.onError) socketHandlers.onError();
        break;
      case 'handle':
        var h = socketHandlers.events[msg.data.payload.t];
        if (h) h(msg.data.payload.d, msg.data.payload);
        break;
    }
  };

  (0, _worker.tellWorker)(worker, 'create', setup);
}

function onConnected() {
  if (!connectedWS) {
    connectedWS = true;
    (0, _redraw2.default)();
  }
}

function onDisconnected() {
  if (connectedWS) {
    connectedWS = false;
    (0, _redraw2.default)();
  }
}

function reconnectCurrent() {}

var connectedWS = false;

var worker = new Worker('lib/socketWorker.js');
var defaultHandlers = {};

function createLobby(name, _onOpen, handlers) {
  var socketHandlers = {
    onOpen: function onOpen() {
      _session2.default.refresh();
      _onOpen();
    },
    events: Object.assign({}, defaultHandlers, handlers)
  };
  var opts = {
    options: {
      name: name,
      debug: _config2.default.mode === 'dev',
      pingDelay: 2000,
      sendOnOpen: [],
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  var setup = {
    clientId: (0, _utils.newSri)(),
    socketEndPoint: _config2.default.socketEndPoint,
    url: '/lobby/socket/v' + _config2.default.apiVersion,
    opts: opts
  };
  setupConnection(setup, socketHandlers);
}

function createMasa(masaId, version, handlers) {
  var url = '/masa/' + masaId + ('/socket/v' + _config2.default.apiVersion);
  var socketHandlers = {
    events: Object.assign({}, defaultHandlers, handlers),
    onOpen: _session2.default.backgroundRefresh
  };
  var opts = {
    options: {
      name: 'masa',
      debug: _config2.default.mode === 'dev',
      pingDelay: 2000,
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  var setup = {
    clientId: (0, _utils.newSri)(),
    socketEndPoint: _config2.default.socketEndPoint,
    url: url,
    version: version,
    opts: opts
  };
  setupConnection(setup, socketHandlers);
}

function createGame(url, version, handlers, gameUrl) {
  var socketHandlers = {
    onOpen: _session2.default.backgroundRefresh,
    events: Object.assign({}, defaultHandlers, handlers)
  };
  var opts = {
    options: {
      name: 'game',
      debug: _config2.default.mode === 'dev',
      sendOnOpen: [],
      registeredEvents: Object.keys(socketHandlers.events)
    }
  };
  var setup = {
    clientId: (0, _utils.newSri)(),
    socketEndPoint: _config2.default.socketEndPoint,
    url: url,
    version: version,
    opts: opts
  };

  setupConnection(setup, socketHandlers);
}

exports.default = {
  createGame: createGame,
  createLobby: createLobby,
  createMasa: createMasa,
  reconnectCurrent: reconnectCurrent,
  setVersion: function setVersion(version) {
    (0, _worker.tellWorker)(worker, 'setVersion', version);
  },

  send: function send(t, data, opts) {
    (0, _worker.tellWorker)(worker, 'send', [t, data, opts]);
  },
  isConnected: function isConnected() {
    return connectedWS;
  },
  connect: function connect() {
    (0, _worker.tellWorker)(worker, 'connect');
  },
  destroy: function destroy() {
    (0, _worker.tellWorker)(worker, 'destroy');
  }
};

/// OLD


// const worker = new Worker('lib/socketWorker.js');

// let socketHandlers;
// let errorDetected = false;
// let connectedWS = true;

// let alreadyWarned = false;
// let redrawOnDisconnectedTimeoutID;
// let proxyFailTimeoutID;
// const proxyFailMsg = "Oyunkeyf sunucularna balant koptu. Problem srekli yaanyorsa proxy yada network'la ilgili olabilir.";

// const defaultHandlers = {
// };

// function createGame(url, version, handlers, gameUrl) {
//   errorDetected = false;
//   socketHandlers = {
//     onError: function() {
//       // we can't get socket error, so we send an xhr to test whether the
//       // rejection is an authorization issue
//       if (!errorDetected) {
//         // just to be sure that we don't send an xhr every second when the
//         // websocket is trying to reconnect
//         errorDetected = true;
//         xhr.game(gameUrl.substring(1)).then(function() {}, function(err) {
//           if (err.status === 401) {
//             window.plugins.toast.show(i18n('unauthorizedError'), 'short', 'center');
//             m.route('/');
//           }
//         });
//       }
//     },
//     events: Object.assign({}, defaultHandlers, handlers)
//   };

//   const opts = {
//     options: {
//       name: 'game',
//       debug: false,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version,
//     opts
//   });
// }

// function createMasa(masaId, version, handlers) {
//   let url = '/masa/' + masaId + '/socket/v1';

//   socketHandlers = {
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     options: {
//       name: 'masa',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version,
//     opts
//   });
// }

// function createMasaHome(handlers) {
//   let url = '/socket';

//   socketHandlers = {
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     params: { flag: 'masa' },
//     options: {
//       name: 'masaHome',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url,
//     version: 0,
//     opts
//   });
// }

// function createLobby(lobbyVersion, onOpen, handlers) {
//   socketHandlers = {
//     onOpen,
//     events: Object.assign({}, defaultHandlers, handlers)
//   };
//   const opts = {
//     options: {
//       name: 'lobby',
//       debug: false,
//       pingDelay: 2000,
//       registeredEvents: Object.keys(socketHandlers.events)
//     }
//   };
//   tellWorker(worker, 'create', {
//     clientId: oyunkeyfSri,
//     socketEndPoint: window.oyunkeyf.socketEndPoint,
//     url: '/lobby/socket/v1',
//     version: lobbyVersion,
//     opts
//   });
// }


// function createDefault() {
//   // default socket is useless when anon.?
//   if (hasNetwork()) {
//     socketHandlers = {
//       events: defaultHandlers
//     };
//     const opts = {
//       options: {
//         name: 'default',
//         debug: false,
//         pingDelay: 2000,
//         registeredEvents: Object.keys(socketHandlers.events)
//       }
//     };
//     tellWorker(worker, 'create', {
//       clientId: oyunkeyfSri,
//       socketEndPoint: window.oyunkeyf.socketEndPoint,
//       url: '/socket',
//       version: 0,
//       opts
//     });
//   }
// }

// function onConnected() {
//   const wasOff = !connectedWS;
//   connectedWS = true;
//   clearTimeout(proxyFailTimeoutID);
//   clearTimeout(redrawOnDisconnectedTimeoutID);
//   if (wasOff) m.redraw();
// }

// function onDisconnected() {
//   const wasOn = connectedWS;
//   connectedWS = false;
//   if (wasOn) redrawOnDisconnectedTimeoutID = setTimeout(function() {
//     m.redraw();
//   }, 2000);
//   if (wasOn && !alreadyWarned && !storage.get('donotshowproxyfailwarning')) proxyFailTimeoutID = setTimeout(() => {
//     // check if disconnection lasts, it could mean a proxy prevents
//     // establishing a tunnel
//     if (hasNetwork() && !connectedWS) {
//       alreadyWarned = true;
//       window.navigator.notification.alert(proxyFailMsg, function() {
//         storage.set('donotshowproxyfailwarning', true);
//       });
//     }
//   }, 20000);
// }

// worker.addEventListener('message', function(msg) {
//   switch(msg.data.topic) {
//   case 'onOpen':
//     if (socketHandlers.onOpen) socketHandlers.onOpen();
//     break;
//   case 'disconnected':
//     onDisconnected();
//     break;
//   case 'connected':
//     onConnected();
//     break;
//   case 'onError':
//     if (socketHandlers.onError) socketHandlers.onError();
//     break;
//   case 'handle':
//     var h = socketHandlers.events[msg.data.payload.t];
//     if (h) h(msg.data.payload.d || null, msg.data.payload);
//     break;
//   }
// });

// // export default {
// //   createDefault,
// //   createMasa,
// //   createMasaHome,
// //   createGame,
// //   createLobby,
// //   setVersion(version) {
// //     tellWorker(worker, 'setVersion', version);
// //   },
// //   send(type, data, opts) {
// //     tellWorker(worker, 'send', [type, data, opts]);
// //   },
// //   connect() {
// //     tellWorker(worker, 'connect');
// //   },
// //   disconnect() {
// //     tellWorker(worker, 'disconnect');
// //   },
// //   isConnected() {
// //     return connectedWS;
// //   },
// //   destroy() {
// //     tellWorker(worker, 'destroy');
// //   },
// //   terminate() {
// //     if (worker) worker.terminate();
// //   }
// // };

},{"./config":136,"./http":137,"./session":147,"./storage":152,"./utils":210,"./utils/redraw":212,"./utils/worker":214}],151:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var timeoutId;

exports.default = {
  spin: function spin() {
    if (timeoutId || document.getElementsByClassName('globalSpinner').length > 0) {
      return false;
    }

    var spinner = document.createElement('div');
    spinner.className = 'spinner globalSpinner';
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 40 40');
    var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', '20');
    circle.setAttribute('cy', '20');
    circle.setAttribute('r', '18');
    circle.setAttribute('fill', 'none');
    svg.appendChild(circle);
    spinner.appendChild(svg);

    timeoutId = setTimeout(function () {
      return document.body.appendChild(spinner);
    }, 200);
  },
  stop: function stop() {
    clearTimeout(timeoutId);
    timeoutId = null;
    var spinners = document.getElementsByClassName('globalSpinner');
    if (spinners.length) {
      setTimeout(function () {
        while (spinners[0]) {
          document.body.removeChild(spinners[0]);
        }
      }, 500);
    }
  },
  getVdom: function getVdom(classes) {
    return h(
      'div',
      { 'class': 'spinner ' + classes },
      h(
        'svg',
        { viewBox: '0 0 40 40' },
        h('circle', { cx: '20', cy: '20', r: '18', fill: 'none' })
      )
    );
  }
};

},{"mithril/hyperscript":113}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function withStorage(f) {
  // can throw an exception if storage is full
  try {
    return !!window.localStorage ? f(window.localStorage) : null;
  } catch (e) {}
}

function get(k) {
  return withStorage(function (s) {
    return JSON.parse(s.getItem(k));
  });
}
function remove(k) {
  return withStorage(function (s) {
    s.removeItem(k);
  });
}
function set(k, v) {
  return withStorage(function (s) {
    s.removeItem(k);
    s.setItem(k, JSON.stringify(v));
  });
}

function prop(key, initialValue) {
  return function () {
    if (arguments.length) set(key, arguments[0]);
    var ret = get(key);
    return ret !== null && ret !== undefined ? ret : initialValue;
  };
}

exports.default = {
  get: get,
  set: set,
  remove: remove,
  prop: prop
};

},{}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _utils = require('../../utils');

var _xhr = require('../../xhr');

var _sleep = require('../../utils/sleep');

var sleepUtils = _interopRequireWildcard(_sleep);

var _OnlineRound = require('../shared/round/OnlineRound');

var _OnlineRound2 = _interopRequireDefault(_OnlineRound);

var _roundView = require('../shared/round/view/roundView');

var _roundView2 = _interopRequireDefault(_roundView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  oninit: function oninit(_ref) {
    var _this = this;

    var attrs = _ref.attrs;

    var gameData = void 0;

    sleepUtils.keepAwake();

    if ((0, _utils.hasNetwork)()) {
      (0, _xhr.game)(attrs.id).then(function (data) {
        gameData = data;

        setTimeout(function () {
          _this.round = new _OnlineRound2.default(attrs.id, data);
        }, 400);
      }).catch(function (error) {
        (0, _utils.handleXhrError)(error);
        _router2.default.set('/');
      });
    }
  },
  oncreate: function oncreate(vnode) {
    if (vnode.dom) helper.elFadeIn(vnode.dom);
  },
  onremove: function onremove() {
    sleepUtils.allowSleepAgain();
    _socket2.default.destroy();
    if (this.round) {
      this.round.unload();
    }
  },
  view: function view(_ref2) {
    var attrs = _ref2.attrs;

    if (this.round) return (0, _roundView2.default)(this.round);

    return null;
  }
};

},{"../../i18n":138,"../../router":145,"../../socket":150,"../../utils":210,"../../utils/sleep":213,"../../xhr":215,"../helper":157,"../shared/round/OnlineRound":192,"../shared/round/view/roundView":199}],154:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _popup = require('./shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _form = require('./shared/form');

var _form2 = _interopRequireDefault(_form);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _newGameForm = require('./newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _iscroll = require('iscroll');

var _iscroll2 = _interopRequireDefault(_iscroll);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _lobby = require('./lobby');

var _lobby2 = _interopRequireDefault(_lobby);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _ViewOnlyBoard = require('./shared/ViewOnlyBoard');

var _ViewOnlyBoard2 = _interopRequireDefault(_ViewOnlyBoard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var scroller = null;

var gamesMenu = {};

gamesMenu.isOpen = false;

gamesMenu.open = function () {
  _backbutton2.default.stack.push(gamesMenu.close);
  gamesMenu.isOpen = true;
  setTimeout(function () {
    if (utils.hasNetwork() && scroller) scroller.goToPage(1, 0);
  }, 400);
  _session2.default.refresh();
};

gamesMenu.close = function (fromBB) {
  if (fromBB !== 'backbutton' && gamesMenu.isOpen) _backbutton2.default.stack.pop();
  gamesMenu.isOpen = false;
};

function joinGame(g) {
  gamesMenu.close();
  _mithril2.default.route('/game/' + g.fullId);
}

function cardDims() {
  var vp = _helper2.default.viewportDim();

  // if we're here it's a phone
  var width = 200;
  var height = width / (4 / 3);
  var margin = 10;
  return {
    w: width + margin * 2,
    h: height + 70,
    innerW: width,
    margin: margin
  };
}

function renderViewOnlyBoard(cDim, fen, orientation, variant) {
  var innerH = cDim ? cDim.innerW / (4 / 3) : 0;
  var innerW = cDim ? cDim.innerW : 0;
  var style = cDim ? { height: innerH + 'px' } : {};
  var bounds = cDim ? { width: innerW, height: innerH } : null;
  return h(
    'div',
    { className: 'boardWrapper', style: style },
    _mithril2.default.component(_ViewOnlyBoard2.default, { bounds: bounds, fen: fen, orientation: orientation, variant: variant })
  );
}

function timeLeft(g) {
  if (!g.isMyTurn) return (0, _i18n2.default)('waitingForOpponent');
  return (0, _i18n2.default)('yourTurn');
}

function renderGame(g, cDim, cardStyle) {
  var icon = utils.gameIcon(g.perf);
  var cardClass = ['card', 'standard'].join(' ');

  var timeClass = ['timeIndication', g.isMyTurn ? 'myTurn' : 'opponentTurn'].join(' ');
  var config = _helper2.default.ontouchX(function () {
    return joinGame(g);
  });

  return h(
    'div',
    { className: cardClass, key: 'game.' + g.gameId, style: cardStyle,
      config: config },
    renderViewOnlyBoard(cDim, g.fen, g.side, g.variant),
    h(
      'div',
      { className: 'infos' },
      h(
        'div',
        { className: 'description' },
        h(
          'p',
          null,
          h(
            'span',
            { className: 'variant' },
            g.variant.name
          ),
          h(
            'span',
            { className: timeClass },
            timeLeft(g)
          )
        )
      )
    )
  );
}

function renderAllGames(cDim) {
  var nowPlaying = _session2.default.nowPlaying(); // .concat(session.nowPlaying());
  var cardStyle = cDim ? {
    width: cDim.w - cDim.margin * 2 + 'px',
    height: cDim.h + 'px',
    marginLeft: cDim.margin + 'px',
    marginRight: cDim.margin + 'px'
  } : {};

  var nbCards = utils.hasNetwork() ? nowPlaying.length + 1 : 0;

  var wrapperStyle = void 0,
      wrapperWidth = void 0;
  if (cDim) {
    // scroller wrapper width
    // calcul is:
    // ((cardWidth + visible part of adjacent card) * nb of cards) +
    // wrapper's marginLeft
    wrapperWidth = (cDim.w + cDim.margin * 2) * nbCards + cDim.margin * 2;
    wrapperStyle = {
      width: wrapperWidth + 'px',
      marginLeft: cDim.margin * 3 + 'px'
    };
  }

  var allCards = nowPlaying.map(function (g) {
    return renderGame(g, cDim, cardStyle);
  });

  if (!_helper2.default.isWideScreen()) {

    var newGameCard = h(
      'div',
      { className: 'card standard', key: 'game.new-game', style: cardStyle,
        config: _helper2.default.ontouchX(function () {
          gamesMenu.close();_newGameForm2.default.open();
        }) },
      renderViewOnlyBoard(cDim),
      h(
        'div',
        { className: 'infos' },
        h(
          'div',
          { className: 'description' },
          h(
            'h2',
            { className: 'title' },
            (0, _i18n2.default)('createAGame')
          ),
          h(
            'p',
            null,
            (0, _i18n2.default)('newOpponent')
          )
        )
      )
    );
    if (utils.hasNetwork()) allCards.unshift(newGameCard);
  }

  return (0, _mithril2.default)('div#all_games', { style: wrapperStyle }, allCards);
}

gamesMenu.view = function () {
  if (!gamesMenu.isOpen) return null;

  var vh = _helper2.default.viewportDim().vh;
  var cDim = cardDims();
  var wrapperStyle = _helper2.default.isWideScreen() ? {} : { top: (vh - cDim.h) / 2 + 'px' };
  var wrapperConfig = _helper2.default.isWideScreen() ? utils.noop : function (el, isUpdate, context) {
    if (!isUpdate) {
      scroller = new _iscroll2.default(el, {
        scrollX: true,
        scrollY: false,
        momentum: false,
        snap: '.card',
        snapSpeed: 400,
        preventDefaultException: {
          tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|LABEL)$/
        }
      });

      context.unonload = function () {
        if (scroller) {
          scroller.destroy();
          scroller = null;
        }
      };
    }
    // see https://github.com/cubiq/iscroll/issues/412
    scroller.options.snap = el.querySelectorAll('.card');
    scroller.refresh();
  };

  var isWideScreen = _helper2.default.isWideScreen();

  var wrapperClass = isWideScreen ? 'overlay_popup' : '';

  return h(
    'div',
    { id: 'games_menu', className: 'overlay_popup_wrapper' },
    h('div', { className: 'wrapper_overlay_close',
      config: _helper2.default.ontouch(_helper2.default.fadesOut(gamesMenu.close, '.overlay_popup_wrapper')) }),
    h(
      'div',
      { id: 'wrapper_games', className: wrapperClass, style: wrapperStyle, config: wrapperConfig },
      isWideScreen ? h(
        'header',
        null,
        (0, _i18n2.default)('nbGamesInPlay', _session2.default.nowPlaying().length)
      ) : null,
      isWideScreen ? h(
        'div',
        { className: 'popup_content' },
        renderAllGames(null)
      ) : renderAllGames(cDim)
    )
  );
};

exports.default = gamesMenu;

},{"../backbutton":135,"../i18n":138,"../session":147,"../settings":148,"../utils":210,"./helper":157,"./lobby":161,"./newGameForm":174,"./shared/ViewOnlyBoard":185,"./shared/form":187,"./shared/popup":191,"iscroll":7,"mithril":114,"mithril/hyperscript":113}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = animator;

var _utils = require('../../utils');

var animating = false;

// Author Barney Caroll
// taken from https://gist.github.com/barneycarroll/c69fbe0786e37c941baf

// Define an animator consisting of optional incoming and outgoing animations.
// alwaysAnimate is false unless specified as true: false means an incoming animation will only trigger if an outgoing animation is also in progress.
// forcing dontClone to true means the outward animation will use the original element rather than a clone. This could improve performance by recycling elements, but can lead to trouble: clones have the advantage of being stripped of all event listeners.
function animator(incoming, outgoing, alwaysAnimate, dontClone) {
  // The resulting animator can be applied to any number of components
  return function animate(x, y, z) {
    var config;
    var parent;
    var next;

    // When used as a config function
    if (x.nodeType) {
      return animationConfig(x, y, z);
    }
    // When passed a virtual DOM node (the output of m)
    else if (x.attrs) {
        return bindConfigTo(x);
      }
      // When applied to a Mithril module / component
      else if (x.view) {
          return {
            controller: x.controller || _utils.noop,
            view: function animatedView(ctrl) {
              return bindConfigTo(x.view(ctrl));
            }
          };
        }

    function bindConfigTo(node) {
      if (!node) return null;

      config = node.attrs.config;

      node.attrs.config = animationConfig;

      return node;
    }

    function animationConfig(el, init, context) {
      var output;
      var onunload;

      if (config) {
        output = config(el, init, context);
        // If the root element already has a config, it may also have an onunload which we should take care to preserve
        onunload = context.onunload;
      }

      if (!init) {
        if (incoming && alwaysAnimate || animating) {
          incoming(el, _utils.noop, context);
        }

        context.onunload = outgoing ? onunload ? function onunloadWrapper() {
          teardown();
          onunload();
        } : teardown : onunload;

        parent = el.parentElement;
        next = el.nextSibling;
      }

      return output;

      function teardown() {
        var insertion = dontClone ? el : el.cloneNode(true);
        var reference = null;

        if (next && parent && next.parentNode === parent) {
          reference = next;
        }

        animating = true;

        setTimeout(function resetAnimationFlag() {
          animating = false;
        }, 0);

        parent.insertBefore(insertion, reference);

        outgoing(insertion, function destroy() {
          if (parent.contains(insertion)) {
            parent.removeChild(insertion);
          }
        }, context);
      }
    }
  };
}

},{"../../utils":210}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ButtonHandler;

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HOLD_DURATION = 600;
var REPEAT_RATE = 20;
var SCROLL_TOLERANCE = 8;
var ACTIVE_CLASS = 'active';

function hasContextMenu() {
  return window.cordova.platformId !== 'ios';
}

function ButtonHandler(el, tapHandler, holdHandler, repeatHandler, scrollX, scrollY, touchEndFeedback) {

  var startX = void 0,
      startY = void 0,
      boundaries = void 0,
      active = void 0,
      holdTimeoutID = void 0,
      repeatTimeoutId = void 0,
      repeatIntervalID = void 0;

  if (typeof tapHandler !== 'function') throw new Error('ButtonHandler 2nd argument must be a function!');

  if (holdHandler && typeof holdHandler !== 'function') throw new Error('ButtonHandler 3rd argument must be a function!');

  if (repeatHandler && typeof repeatHandler !== 'function') throw new Error('ButtonHandler 4rd argument must be a function!');

  // http://ejohn.org/blog/how-javascript-timers-work/
  function onRepeat() {
    var res = repeatHandler();
    repeatIntervalID = setTimeout(onRepeat, REPEAT_RATE);
    if (!res) clearTimeout(repeatIntervalID);
    _mithril2.default.redraw();
  }

  function onTouchStart(e) {
    var touch = e.changedTouches[0];
    var boundingRect = el.getBoundingClientRect();
    startX = touch.clientX;
    startY = touch.clientY;
    boundaries = {
      minX: boundingRect.left,
      maxX: boundingRect.right,
      minY: boundingRect.top,
      maxY: boundingRect.bottom
    };
    active = true;
    setTimeout(function () {
      if (active) el.classList.add(ACTIVE_CLASS);
    }, 200);
    if (!hasContextMenu()) holdTimeoutID = setTimeout(onHold, HOLD_DURATION);
    clearTimeout(repeatIntervalID);
    if (repeatHandler) repeatTimeoutId = setTimeout(function () {
      repeatIntervalID = setTimeout(onRepeat, REPEAT_RATE);
    }, 150);
  }

  function onTouchMove(e) {
    // if going out of bounds, no way to reenable the button
    if (active) {
      var touch = e.changedTouches[0];
      active = isActive(touch);
      if (!active) {
        clearTimeout(holdTimeoutID);
        clearTimeout(repeatTimeoutId);
        clearTimeout(repeatIntervalID);
        el.classList.remove(ACTIVE_CLASS);
      }
    }
  }

  function onTouchEnd(e) {
    if (e.cancelable) e.preventDefault();
    clearTimeout(repeatTimeoutId);
    clearTimeout(repeatIntervalID);
    if (active) {
      clearTimeout(holdTimeoutID);
      if (touchEndFeedback) el.classList.add(ACTIVE_CLASS);
      tapHandler(e);
      active = false;
      setTimeout(function () {
        return el.classList.remove(ACTIVE_CLASS);
      }, 80);
    }
  }

  function onTouchCancel() {
    clearTimeout(holdTimeoutID);
    clearTimeout(repeatTimeoutId);
    clearTimeout(repeatIntervalID);
    active = false;
    el.classList.remove(ACTIVE_CLASS);
  }

  function onContextMenu(e) {
    e.preventDefault();
    e.stopPropagation();
    if (holdTimeoutID === undefined) onHold();
  }

  function onHold() {
    if (holdHandler) {
      holdHandler();
      active = false;
      el.classList.remove(ACTIVE_CLASS);
    }
  }

  function isActive(touch) {
    var x = touch.clientX,
        y = touch.clientY,
        b = boundaries,
        d = 0;
    if (scrollX) d = Math.abs(x - startX);
    if (scrollY) d = Math.abs(y - startY);
    return x < b.maxX && x > b.minX && y < b.maxY && y > b.minY && d < SCROLL_TOLERANCE;
  }

  el.addEventListener('touchstart', onTouchStart, false);
  el.addEventListener('touchmove', onTouchMove, false);
  el.addEventListener('touchend', onTouchEnd, false);
  el.addEventListener('touchcancel', onTouchCancel, false);
  el.addEventListener('contextmenu', onContextMenu, false);
}

},{"mithril":114}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ontap = ontap;
exports.ontapXY = ontapXY;
exports.slidesInUp = slidesInUp;
exports.slidesOutDown = slidesOutDown;
exports.elFadeIn = elFadeIn;
exports.getButton = getButton;
exports.viewportDim = viewportDim;
exports.findParentBySelector = findParentBySelector;
exports.getLI = getLI;
exports.classSet = classSet;
exports.clearCachedViewportDim = clearCachedViewportDim;

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _button = require('./button');

var _button2 = _interopRequireDefault(_button);

var _animator = require('./animator');

var _animator2 = _interopRequireDefault(_animator);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animDuration = 250;

function createTapHandler(tapHandler, holdHandler, repeatHandler, scrollX, scrollY, getElement, preventEndDefault) {
  return function (vnode) {
    (0, _button2.default)(vnode.dom, function (e) {
      tapHandler(e);
      (0, _redraw2.default)();
    }, holdHandler ? function (e) {
      return utils.autoredraw(function () {
        return holdHandler(e);
      });
    } : undefined, repeatHandler, scrollX, scrollY, getElement, preventEndDefault);
  };
}

function ontap(tapHandler, holdHandler, repeatHandler, getElement) {
  return createTapHandler(tapHandler, holdHandler, repeatHandler, false, false, getElement);
}

function ontapXY(tapHandler, holdHandler, getElement) {
  var preventEndDefault = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  return createTapHandler(tapHandler, holdHandler, undefined, true, true, getElement, preventEndDefault);
}

function slidesInUp(vnode) {
  var el = vnode.dom;
  el.style.transform = 'translateY(100%)';
  vnode.state.lol = el.offsetHeight;
  return (0, _zanimo2.default)(el, 'transform', 'translateY(0)', 250, 'ease-out').catch(console.log.bind(console));
}

function slidesOutDown(callback, elID) {
  return function (fromBB) {
    var el = document.getElementById(elID);
    return (0, _zanimo2.default)(el, 'transform', 'translateY(100%)', 250, 'ease-out').then(function () {
      return utils.autoredraw(function () {
        return callback(fromBB);
      });
    }).catch(console.log.bind(console));
  };
}

// el fade in transition, can be applied to any element
function elFadeIn(el) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : animDuration;
  var origOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0.5';
  var endOpacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '1';

  var tId = void 0;

  el.style.opacity = origOpacity;
  el.style.transition = 'opacity ' + duration + 'ms ease-out';

  setTimeout(function () {
    el.style.opacity = endOpacity;
  });

  function after() {
    clearTimeout(tId);
    if (el) {
      el.removeAttribute('style');
      el.removeEventListener('transitionend', after, false);
    }
  }

  el.addEventListener('transitionend', after, false);
  // in case transitionend does not fire
  tId = setTimeout(after, duration + 10);
}

function getButton(e) {
  var target = e.target;
  return target.tagName === 'BUTTON' ? target : findParentBySelector(target, 'button');
}

// OLD

//store temporarily last route to disable animations on same route
// TODO find a better way cause this is ugly
var lastRoute = void 0;

// this must be cached because of the access to document.body.style
var cachedTransformProp = void 0;
var cachedViewportDim = null;

function viewSlideIn(el, callback) {
  if (_mithril2.default.route() === lastRoute) {
    callback();
    return;
  }

  lastRoute = _mithril2.default.route();

  function after() {
    utils.setViewSlideDirection('fwd');
    el.removeAttribute('style');
    callback();
  }

  var direction = utils.getViewSlideDirection() === 'fwd' ? '100%' : '-100%';
  el.style.transform = 'translate3d(' + direction + ',0,0)';
  el.style.transition = 'transform 200ms ease-out';

  setTimeout(function () {
    el.style.transform = 'translate3d(0%,0,0)';
  });

  el.addEventListener('transitionend', after, false);
}

function viewSlideOut(el, callback) {
  if (_mithril2.default.route() === lastRoute) {
    callback();
    return;
  }

  function after() {
    utils.setViewSlideDirection('fwd');
    callback();
  }

  var direction = utils.getViewSlideDirection() === 'fwd' ? '-100%' : '100%';
  el.style.transform = 'translate3d(0%,0,0)';
  el.style.transition = 'transform 200ms ease-out';

  setTimeout(function () {
    el.style.transform = 'translate3d(' + direction + ',0,0)';
  });

  el.addEventListener('transitionend', after, false);
}

function viewFadesIn(el, callback) {
  var tId;

  el.style.opacity = '0.5';
  el.style.transition = 'opacity 200ms ease-out';

  setTimeout(function () {
    el.style.opacity = '1';
  });

  function after() {
    clearTimeout(tId);
    if (el) {
      el.removeAttribute('style');
      el.removeEventListener('transitioned', after, false);
    }
    callback();
  }

  el.addEventListener('transitioned', after, false);

  // in case transitioned does not fire
  // TODO find a way to avoid it
  tId = setTimeout(after, 250);
}

function viewFadesOut(el, callback) {
  var tId;

  el.style.opacity = '1';
  el.style.transition = 'opacity 200ms ease-out, visibility 0s linear 200ms';

  setTimeout(function () {
    el.style.opacity = '0';
    el.style.visibility = 'hidden';
  });

  function after() {
    clearTimeout(tId);
    callback();
  }

  el.addEventListener('transitioned', after, false);

  // in case transitioned does not fire
  // TODO find a way to avoid it
  tId = setTimeout(after, 250);
}

function collectionHas(coll, el) {
  for (var i = 0, len = coll.length; i < len; i++) {
    if (coll[i] === el) return true;
  }
  return false;
}

function findParentBySelector(el, selector) {
  var matches = document.querySelectorAll(selector);
  var cur = el.parentNode;
  while (cur && !collectionHas(matches, cur)) {
    cur = cur.parentNode;
  }
  return cur;
}

function ontouch(tapHandler, holdHandler, repeatHandler, scrollX, scrollY, touchEndFeedback) {
  return function (el, isUpdate) {
    if (!isUpdate) {
      (0, _button2.default)(el, function (e) {
        _mithril2.default.startComputation();
        try {
          tapHandler(e);
        } finally {
          _mithril2.default.endComputation();
        }
      }, holdHandler ? function () {
        return utils.autoredraw(holdHandler);
      } : null, repeatHandler, scrollX, scrollY, touchEndFeedback);
    }
  };
}

function computeTransformProp() {
  return 'transform' in document.body.style ? 'transform' : 'webkitTransform' in document.body.style ? 'webkitTransform' : 'mozTransform' in document.body.style ? 'mozTransform' : 'oTransform' in document.body.style ? 'oTransform' : 'msTransform';
}

function viewportDim() {
  if (cachedViewportDim) return cachedViewportDim;

  var e = document.documentElement;
  var vpd = cachedViewportDim = {
    vw: e.clientWidth,
    vh: e.clientHeight
  };
  return vpd;
}

function collectionHas(coll, el) {
  for (var i = 0, len = coll.length; i < len; i++) {
    if (coll[i] === el) return true;
  }
  return false;
}

function findParentBySelector(el, selector) {
  var matches = document.querySelectorAll(selector);
  var cur = el;
  while (cur && !collectionHas(matches, cur)) {
    cur = cur.parentNode;
  }
  return cur;
}

function getLI(e) {
  var target = e.target;
  return target.tagName === 'LI' ? target : findParentBySelector(target, 'LI');
}

function classSet(classes) {
  var arr = [];
  for (var i in classes) {
    if (classes[i]) arr.push(i);
  }
  return arr.join(' ');
}

function clearCachedViewportDim() {
  cachedViewportDim = null;
}

// export default {
//   slidingPage: animator(viewSlideIn, viewSlideOut),
//   fadingPage: animator(viewFadesIn, viewFadesOut),
//   viewportDim,
//   clearCachedViewportDim() {
//     cachedViewportDim = null;
//   },

//   transformProp: function() {
//     if (!cachedTransformProp) cachedTransformProp = computeTransformProp();
//     return cachedTransformProp;
//   },

//   slidesInUp: function(el, isUpdate, context) {
//     if (!isUpdate) {
//       el.style.transform = 'translateY(100%)';
//       // force reflow back
//       context.lol = el.offsetHeight;
//       Zanimo(el, 'transform', 'translateY(0)', 250, 'ease-out')
//         .catch(console.log.bind(console));
//     }
//   },
//   slidesOutDown: function(callback, elID) {
//     return function() {
//       const el = document.getElementById(elID);
//       m.redraw.strategy('none');
//       return Zanimo(el, 'transform', 'translateY(100%)', 250, 'ease-out')
//         .then(utils.autoredraw.bind(null, callback))
//         .catch(callback);
//     };
//   },

//   fadesOut: function(callback, selector, time = 150) {
//     return function(e) {
//       e.stopPropagation();
//       var el = selector ? findParentBySelector(e.target, selector) : e.target;
//       m.redraw.strategy('none');
//       return Zanimo(el, 'opacity', 0, time)
//         .then(() => utils.autoredraw(callback))
//         .catch(console.log.bind(console));
//     };
//   },

//   ontouch: function(tapHandler, holdHandler, repeatHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, repeatHandler, false, false, touchEndFeedback);
//   },
//   ontouchX: function(tapHandler, holdHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, null, true, false, touchEndFeedback);
//   },
//   ontouchY: function(tapHandler, holdHandler, touchEndFeedback = true) {
//     return ontouch(tapHandler, holdHandler, null, false, true, touchEndFeedback);
//   },
//   classSet: function(classes) {
//     var arr = [];
//     for (var i in classes) {
//       if (classes[i]) arr.push(i);
//     }
//     return arr.join(' ');
//   },

//   isWideScreen: function() {
//     return viewportDim().vw >= 600;
//   },
//   isIpadLike: function() {
//     const { vh, vw } = viewportDim();
//     return vh >= 700 && vw <= 1050;
//   },
//   isPortrait: function() {
//     return window.matchMedia('(orientation: portrait)').matches;
//   },
//   isLandscape: function() {
//     return window.matchMedia('(orientation: landscape)').matches;
//   },
//   progress: function (p) {
//     if (p === 0) return null;
//     return m('span', {
//       className: 'progress ' + (p > 0 ? 'positive' : 'negative'),
//       'data-icon': p > 0 ? 'N' : 'M'
//     }, Math.abs(p));
//   }
// };

},{"../../utils":210,"../../utils/redraw":212,"./animator":155,"./button":156,"mithril":114,"zanimo":131}],158:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.body = body;

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _common = require('../shared/common');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function body(ctrl) {
  var nbPlayers = (0, _i18n2.default)('nbConnectedPlayers', ctrl.nbConnectedPlayers() || '?');
  var nbGames = (0, _i18n2.default)('nbGamesInPlay', ctrl.nbGamesInPlay() || '?');

  return h(
    'div',
    { className: 'native_scroller page' },
    h(
      'div',
      { className: 'home' },
      h(
        'section',
        { className: 'stats' },
        h(
          'div',
          { className: 'numPlayers' },
          nbPlayers
        ),
        h(
          'div',
          { className: 'numGames' },
          nbGames
        )
      ),
      renderQuickGame()
    )
  );

  // const header = headerWidget.bind(null, 'oyunkeyf.net');

  // return layout.free(header, body);
}

function renderQuickGame() {
  return h('div.homeCreate', [h('h2.homeTitle', 'Hemen oyna'), (0, _newGameForm.renderQuickSetup)(function () {
    return _newGameForm2.default.openRealtime('custom');
  })]);
}

},{"../../i18n":138,"../helper":157,"../layout":160,"../newGameForm":174,"../shared/common":186,"mithril":114,"mithril/hyperscript":113}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stream = require('mithril/stream');

var _stream2 = _interopRequireDefault(_stream);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _utils = require('../../utils');

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _appMode = require('../../utils/appMode');

var _common = require('../shared/common');

var _homeView = require('./homeView');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit() {
    var nbConnectedPlayers = (0, _stream2.default)();
    var nbGamesInPlay = (0, _stream2.default)();

    function init() {
      if ((0, _appMode.isForeground)()) {
        _socket2.default.createLobby('homeLobby', _utils.noop, {
          n: function n(_, d) {
            nbConnectedPlayers(d.d);
            nbGamesInPlay(d.r);
            (0, _redraw2.default)();
          }
        });
      }
    }

    function onResume() {
      (0, _appMode.setForeground)();
      init();
    }

    if ((0, _utils.hasNetwork)()) {
      init();
    }

    document.addEventListener('online', init);
    document.addEventListener('resume', onResume);

    this.ctrl = {
      nbConnectedPlayers: nbConnectedPlayers,
      nbGamesInPlay: nbGamesInPlay,
      init: init,
      onResume: onResume
    };
  },
  onremove: function onremove() {
    _socket2.default.destroy();
    document.removeEventListener('online', this.ctrl.init);
    document.removeEventListener('resume', this.ctrl.onResume);
  },
  view: function view() {
    var header = (0, _common.dropShadowHeader)('oyunkeyf.net');

    return _layout2.default.free(header, (0, _homeView.body)(this.ctrl));
  }
};

},{"../../socket":150,"../../utils":210,"../../utils/appMode":208,"../../utils/redraw":212,"../layout":160,"../shared/common":186,"./homeView":158,"mithril/stream":121}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _menu = require('./menu');

var menu = _interopRequireWildcard(_menu);

var _menuView = require('./menu/menuView');

var _menuView2 = _interopRequireDefault(_menuView);

var _MainBoard = require('./shared/layout/MainBoard');

var _MainBoard2 = _interopRequireDefault(_MainBoard);

var _gamesMenu = require('./gamesMenu');

var _gamesMenu2 = _interopRequireDefault(_gamesMenu);

var _newGameForm = require('./newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _loginModal = require('./loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _signupModal = require('./signupModal');

var _signupModal2 = _interopRequireDefault(_signupModal);

var _helper = require('./helper');

var _helper2 = _interopRequireDefault(_helper);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var background;

exports.default = {

  board: function board(header, content, overlay) {
    background = background;

    return (0, _hyperscript2.default)('div.view-container', { className: bgClass(background) }, [(0, _hyperscript2.default)(_MainBoard2.default, { header: header }, content),
    // h(MenuView),
    overlay]);
  },

  free: function free(header, content, footer, overlay) {
    background = background || _settings2.default.general.theme.background();

    return (0, _hyperscript2.default)('div.view-container', { className: bgClass(background) }, [(0, _hyperscript2.default)('main#page', { oncreate: handleMenuOpen }, [(0, _hyperscript2.default)('header.main_header', header), (0, _hyperscript2.default)('div#free_content.content.native_scroller', content), footer ? (0, _hyperscript2.default)('footer.main_footer', footer) : null, (0, _hyperscript2.default)('div#menu-close-overlay.menu-backdrop', { oncreate: menu.backdropCloseHandler })]), (0, _hyperscript2.default)(_menuView2.default), _loginModal2.default.view(), _signupModal2.default.view(), _newGameForm2.default.view(), overlay]);
  }
};


function handleMenuOpen() {}

function bgClass(bgTheme) {
  return bgTheme === 'dark' || bgTheme === 'light' ? bgTheme : 'transp ' + bgTheme;
}

},{"../settings":148,"./gamesMenu":154,"./helper":157,"./loginModal":162,"./menu":172,"./menu/menuView":173,"./newGameForm":174,"./shared/layout/MainBoard":189,"./signupModal":202,"mithril/hyperscript":113}],161:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _xhr = require('../xhr');

var xhr = _interopRequireWildcard(_xhr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  startSeeking: function startSeeking(conf) {
    doStartSeeking(conf);
  }
};


function doStartSeeking(conf) {
  // router.backbutton.stack.push(userCancelSeeking);

  sendHook(conf);
}

function sendHook(setup) {
  xhr.seekGame(setup).then(function (data) {
    // console.log(data);
    _router2.default.set('/masa/' + data.id);
  }).catch(utils.handleXhrError);
}

// import * as utils from '../utils';
// import * as xhr from '../xhr';
// import m from 'mithril';

// let nbPlayers = 0;
// let nbGames = 0;

// const lobby = {};
// lobby.isOpen = false;

// lobby.startSeeking = function() {
//   xhr.newGame().then(function(data) {
//     // analytics
//     m.route('/masa/' + data.id);
//   }, function(error) {
//     utils.handleXhrError(error);
//     throw error;
//   });
// };


// export default lobby;

},{"../router":145,"../utils":210,"../utils/redraw":212,"../xhr":215}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('../utils');

var utils = _interopRequireWildcard(_utils);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _signals = require('../signals');

var _signals2 = _interopRequireDefault(_signals);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _signupModal = require('./signupModal');

var _signupModal2 = _interopRequireDefault(_signupModal);

var _icons = require('./shared/icons');

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;
var formError = null;

exports.default = {
  open: open,
  close: close,
  view: function view() {
    if (!isOpen) return null;

    return (0, _hyperscript2.default)('div.modal#loginModal', { oncreate: helper.slidesInUp }, [(0, _hyperscript2.default)('header', [(0, _hyperscript2.default)('button.modal_close', {
      oncreate: helper.ontap(helper.slidesOutDown(close, 'loginModal'))
    }, _icons.closeIcon), (0, _hyperscript2.default)('h2', (0, _i18n2.default)('signIn'))]), (0, _hyperscript2.default)('div.modal_content', [(0, _hyperscript2.default)('form.login', {
      onsubmit: function onsubmit(e) {
        e.preventDefault();
        submit(e.target);
      }
    }, [formError ? (0, _hyperscript2.default)('div.form-error', formError) : null, (0, _hyperscript2.default)('div.field', [(0, _hyperscript2.default)('input#username', {
      type: 'text',
      className: formError ? 'form-error' : '',
      placeholder: (0, _i18n2.default)('username'),
      autocomplete: 'off',
      autocapitalize: 'off',
      autocorrect: 'off',
      spellcheck: false,
      required: true
    })]), (0, _hyperscript2.default)('div.field', [(0, _hyperscript2.default)('input#password', {
      type: 'password',
      className: formError ? 'form-error' : '',
      placeholder: (0, _i18n2.default)('password'),
      required: true
    })]), (0, _hyperscript2.default)('div.submit', [(0, _hyperscript2.default)('button.submitButton[data-icon=F]', (0, _i18n2.default)('signIn'))])]), (0, _hyperscript2.default)('div.signup', [(0, _i18n2.default)('newToOyunkeyf') + ' ', (0, _hyperscript2.default)('br'), (0, _hyperscript2.default)('a', {
      oncreate: helper.ontap(_signupModal2.default.open)
    }, [(0, _i18n2.default)('signUp')])])])]);
  }
};


function open() {
  _router2.default.backbutton.stack.push(helper.slidesOutDown(close, 'loginModal'));
  isOpen = true;
  formError = null;
}

function close(fromBB) {
  window.Keyboard.hide();
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

function submit(form) {
  var username = form['username'].value;
  var password = form['password'].value;
  if (!username || !password) return;

  (0, _redraw2.default)();
  window.Keyboard.hide();
  _session2.default.login(username, password).then(function () {
    close();
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    _signals2.default.afterLogin.dispatch();
    (0, _redraw2.default)();
    socket.reconnectCurrent();
    _session2.default.refresh();
  }).catch(function (err) {
    if (err.status !== 400 && err.status !== 401) (0, _utils.handleXhrError)(err);else {
      if (err.body.global) {
        formError = err.body.global[0];
        (0, _redraw2.default)();
      }
    }
  });
}

// OLD

var loginModal = {};

function submitOLD(form) {
  var login = form[0].value.trim();
  var pass = form[1].value;
  if (!login || !pass) return false;
  window.cordova.plugins.Keyboard.close();
  return _session2.default.login(login, pass).then(function () {
    loginModal.close();
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    // push.register();
    _session2.default.refresh().catch(function (err) {
      if (err.status === 401) {
        // https://github.com/veloce/lichobile/blob/master/project/src/js/ui/loginModal.js#L28
        window.navigator.notification.alert('oyunkeyfAuthenticationCannotWorkWithoutCookies');
      }
    });
  }).catch(utils.handleXhrError);
}

loginModal.open = function () {
  _backbutton2.default.stack.push(helper.slidesOutDown(loginModal.close, 'loginModal'));
  isOpen = true;
};

loginModal.close = function (fromBB) {
  window.cordova.plugins.Keyboard.close();
  if (fromBB !== 'backbutton' && isOpen) _backbutton2.default.stack.pop();
  isOpen = false;
};

loginModal.view = function () {
  if (!isOpen) return null;

  return m('div.modal#loginModal', { config: helper.slidesInUp }, [m('header', [m('button.modal_close[data-icon=L]', {
    config: helper.ontouch(helper.slidesOutDown(loginModal.close, 'loginModal'))
  }), m('h2', (0, _i18n2.default)('signIn'))]), m('div.modal_content', [m('form.login', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      return submit(e.target);
    }
  }, [m('input#pseudo[type=text]', {
    placeholder: (0, _i18n2.default)('username'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: 'false',
    required: true
  }), m('input#password[type=password]', {
    placeholder: (0, _i18n2.default)('password'),
    required: true
  }), m('button.fat', (0, _i18n2.default)('signIn'))]), m('div.signup', [m('a', {
    config: helper.ontouch(_signupModal2.default.open)
  }, [(0, _i18n2.default)('newToOyunkeyf'), ' ', (0, _i18n2.default)('signUp')])])])]);
};

// export default loginModal;

},{"../backbutton":135,"../i18n":138,"../router":145,"../session":147,"../signals":149,"../utils":210,"../utils/redraw":212,"./helper":157,"./shared/icons":188,"./signupModal":202,"mithril/hyperscript":113}],163:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MasasListCtrl;

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _utils = require('../../utils');

var _masaXhr = require('./masaXhr');

var xhr = _interopRequireWildcard(_masaXhr);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MasasListCtrl(defaultTab) {
  var _this = this;

  this.currentTab = defaultTab || 0;

  this.refresh = function () {
    xhr.currentMasas().then(function (data) {
      _this.masas = data;
      (0, _redraw2.default)();
    }).catch(_utils.handleXhrError);
  };

  this.refresh();

  this.onTabChange = function (tabIndex) {
    var loc = window.location.search.replace(/\?tab\=\w+$/, '');

    try {
      window.history.replaceState(window.history.state, '', loc + '?tab=' + tabIndex);
    } catch (e) {
      console.error(e);
    }
    _this.currentTab = tabIndex;
    (0, _redraw2.default)();
  };
}

},{"../../utils":210,"../../utils/redraw":212,"./masaXhr":170}],164:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = MasaCtrl;

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _utils = require('../../../utils');

var utils = _interopRequireWildcard(_utils);

var _masaXhr = require('../masaXhr');

var xhr = _interopRequireWildcard(_masaXhr);

var _faq = require('../faq');

var _faq2 = _interopRequireDefault(_faq);

var _socketHandler = require('./socketHandler');

var _socketHandler2 = _interopRequireDefault(_socketHandler);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MasaCtrl(id) {
  var _this = this;

  this.id = id;

  this.faqCtrl = _faq2.default.controller(this);

  xhr.masa(id).then(function (data) {
    _this.masa = data;
    _this.seatId = data.seatId;

    _this.startsAt = window.moment(data.startsAt).calendar();
    loadCurrentPage(_this.masa.standing);
    _this.hasJoined = !!(data.me && !data.me.withdraw);

    _socket2.default.createMasa(_this.id, _this.masa.socketVersion, (0, _socketHandler2.default)(_this));

    (0, _redraw2.default)();
  }).catch(function (err) {
    if (err.status === 404) {
      _this.notFound = true;
      (0, _redraw2.default)();
    } else {
      utils.handleXhrError(err);
    }
  });

  this.invite = (0, _throttle2.default)(function () {
    xhr.invite(_this.masa.id).then(function () {
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.join = (0, _throttle2.default)(function () {
    xhr.join(_this.masa.id).then(function () {
      _this.hasJoined = true;
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.withdraw = (0, _throttle2.default)(function () {
    xhr.withdraw(_this.masa.id).then(function () {
      _this.hasJoined = false;
      (0, _redraw2.default)();
    }).catch(utils.handleXhrError);
  }, 1000);

  this.reload = (0, _throttle2.default)(function () {
    xhr.reload(_this.id).then(onReload).catch(onXhrError);
  }, 2000);

  this.unload = function () {
    document.removeEventListener('resume', _this.reload);
  };

  var onReload = function onReload(data) {
    var oldData = _this.masa;
    _this.masa = data;
    _this.seatId = data.seatId;
    loadCurrentPage(data.standing);
    _this.hasJoined = !!(data.me && !data.me.withdraw);
    redirectToMyGame();
    (0, _redraw2.default)();
  };

  var redirectToMyGame = function redirectToMyGame() {
    var gameId = myCurrentGameId(_this);
    if (gameId) _router2.default.set('/masa/' + _this.masa.id + '/game/' + gameId, true);
  };

  var myCurrentGameId = function myCurrentGameId(ctrl) {
    var ids = {
      created: 10,
      started: 20,
      aborted: 25
    };

    var seatId = ctrl.seatId;
    if (!seatId) return null;
    var pairing = ctrl.masa.pairings.filter(function (p) {
      return p.s < ids.aborted && p.u.filter(function (id) {
        return id.toLowerCase() === seatId.toLowerCase();
      })[0];
    })[0];
    return pairing ? pairing.id : null;
  };

  var onXhrError = function onXhrError(err) {
    if (err.status === 404) {
      _this.notFound = true;
    }
    (0, _redraw2.default)();
  };

  var loadCurrentPage = function loadCurrentPage(data) {
    _this.currentPageResults = data.players;
  };
}

},{"../../../router":145,"../../../socket":150,"../../../utils":210,"../../../utils/redraw":212,"../faq":168,"../masaXhr":170,"./socketHandler":167,"lodash/throttle":109}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _common = require('../../shared/common');

var _helper = require('../../helper');

var helper = _interopRequireWildcard(_helper);

var _layout = require('../../layout');

var _layout2 = _interopRequireDefault(_layout);

var _masaView = require('./masaView');

var _MasaCtrl = require('./MasaCtrl');

var _MasaCtrl2 = _interopRequireDefault(_MasaCtrl);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    this.ctrl = new _MasaCtrl2.default(attrs.id);
  },

  oncreate: helper.viewSlideIn,
  onremove: function onremove() {
    _socket2.default.destroy();
    this.ctrl.unload();
  },
  view: function view() {
    if (this.ctrl.notFound) {
      return _layout2.default.free((0, _common.dropShadowHeader)(null, (0, _common.backButton)((0, _i18n2.default)('masaNotFound'))), (0, _hyperscript2.default)('div.masaNotFound', { key: 'masa-not-found' }, [(0, _hyperscript2.default)('p', (0, _i18n2.default)('masaDoesNotExist')), (0, _hyperscript2.default)('p', (0, _i18n2.default)('masaMayHaveBeenCanceled'))]));
    }

    var masa = this.ctrl.masa;
    var header = void 0;

    if (masa) {
      header = (0, _common.dropShadowHeader)(null, (0, _common.backButton)((0, _hyperscript2.default)('div.main_header_title.withSub', [(0, _hyperscript2.default)('h1', [(0, _hyperscript2.default)('span.fa.fa-trophy'), this.ctrl.masa.fullName]), (0, _hyperscript2.default)('h2.header-subTitle.masa-subTitle', !masa.isFinished && !masa.isStarted ? (0, _masaView.timeInfo)('created', masa.playersToStart, 'Oyuncu bekleniyor') : (0, _masaView.timeInfo)('started', masa.roundsToFinish, ''))])));
    } else {
      header = (0, _common.connectingDropShadowHeader)();
    }

    var body = (0, _masaView.masaBody)(this.ctrl);
    var footer = (0, _masaView.renderFooter)(this.ctrl);
    var faqOverlay = (0, _masaView.renderFAQOverlay)(this.ctrl);
    var overlay = [faqOverlay];

    return _layout2.default.free(header, body, footer, overlay);
  }
};

},{"../../../i18n":138,"../../../socket":150,"../../helper":157,"../../layout":160,"../../shared/common":186,"./MasaCtrl":164,"./masaView":166,"mithril/hyperscript":113}],166:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderFAQOverlay = renderFAQOverlay;
exports.masaBody = masaBody;
exports.renderFooter = renderFooter;
exports.timeInfo = timeInfo;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _session = require('../../../session');

var _session2 = _interopRequireDefault(_session);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../../helper');

var helper = _interopRequireWildcard(_helper);

var _settings = require('../../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _variant = require('../../../oyunkeyf/variant');

var variantApi = _interopRequireWildcard(_variant);

var _faq = require('../faq');

var _faq2 = _interopRequireDefault(_faq);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function renderFAQOverlay(ctrl) {
  return [_faq2.default.view(ctrl.faqCtrl)];
}

function masaBody(ctrl) {
  var data = ctrl.masa;
  if (!data) return null;

  return (0, _hyperscript2.default)('div.masaContainer.native_scroller.page', [masaHeader(data, ctrl), data.podium ? masaPodium(data.podium) : null, masaLeaderboard(ctrl)]);
}

function renderFooter(ctrl) {
  var m = ctrl.masa;
  if (!m) return null;
  var mUrl = 'https://oyunkeyf.net/masa/' + m.id;

  return (0, _hyperscript2.default)(
    'div',
    { className: 'actions_bar' },
    (0, _hyperscript2.default)(
      'button',
      { key: 'faq', className: 'action_bar_button', oncreate: helper.ontap(ctrl.faqCtrl.open) },
      (0, _hyperscript2.default)('span', { className: 'fa fa-question-circle' }),
      'SSS'
    ),
    ctrl.hasJoined ? withdrawButton(ctrl, m) : joinButton(ctrl, m)
  );
}

function timeInfo(key, rounds, preceedingText) {
  if (rounds === undefined) return null;

  return [preceedingText ? preceedingText + ' ' : null];
}

function masaHeader(data, ctrl) {
  return (0, _hyperscript2.default)(
    'div',
    { key: 'header', className: 'masaHeader' },
    masaTimeInfo(data),
    masaCreatorInfo(data, ctrl.startsAt)
  );
}

function masaTimeInfo(data) {
  var variant = variantApi.getVariant(data.variant).name;
  var control = data.scores ? data.scores + ' ' + (0, _i18n2.default)('scores') : data.rounds + ' ' + (0, _i18n2.default)('rounds');
  return (0, _hyperscript2.default)(
    'div',
    { className: 'masaTimeInfo' },
    (0, _hyperscript2.default)(
      'strong',
      { className: 'masaInfo withIcon' },
      variant + '  ' + control
    )
  );
}

function masaCreatorInfo(data, startsAt) {
  return (0, _hyperscript2.default)(
    'div',
    { className: 'masaCreatorInfo' },
    (0, _i18n2.default)('by', data.createdBy),
    '\xA0\u2022\xA0',
    startsAt
  );
}

function joinButton(ctrl, m) {
  if (!_session2.default.isConnected() || m.isFinished) {
    return null;
  }
  var action = function action() {
    return ctrl.join();
  };
  return (0, _hyperscript2.default)(
    'button',
    { key: 'join', className: 'action_bar_button', oncreate: helper.ontap(action) },
    (0, _hyperscript2.default)('span', { className: 'fa fa-play' }),
    (0, _i18n2.default)('join')
  );
}

function withdrawButton(ctrl, m) {
  if (m.isFinished) {
    return null;
  }
  return (0, _hyperscript2.default)(
    'button',
    { key: 'withdraw', className: 'action_bar_button', oncreate: helper.ontap(ctrl.withdraw) },
    (0, _hyperscript2.default)('span', { className: 'fa fa-flag' }),
    (0, _i18n2.default)('withdraw')
  );
}

function masaLeaderboard(ctrl) {

  var data = ctrl.masa;
  var players = ctrl.currentPageResults;
  var user = _session2.default.get();
  var userName = user ? user.username : '';

  return (0, _hyperscript2.default)(
    'div',
    { key: 'leaderboard', className: 'masaLeaderboard' },
    data.nbPlayers > 0 ? (0, _hyperscript2.default)(
      'p',
      { className: 'masaTitle' },
      ' ',
      (0, _i18n2.default)("leaderboard"),
      ' (',
      (0, _i18n2.default)('nbConnectedPlayers', data.nbPlayers),
      ')'
    ) : null,
    (0, _hyperscript2.default)(
      'ul',
      { className: 'masaStandings' },
      players.map(function (p) {
        return renderPlayerEntry(ctrl, userName, p);
      })
    )
  );
}

function renderPlayerEntry(ctrl, userName, player) {
  var isMe = player.name === userName;

  return !player.active ? (0, _hyperscript2.default)(
    'li',
    { key: player.id, className: 'list-item masa-list-player' },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaPlayer' },
      (0, _hyperscript2.default)(
        'span',
        { className: 'flagRank', 'data-icon': player.withdraw ? 'b' : '' },
        ' ',
        player.withdraw ? '' : player.rank + '. '
      ),
      (0, _hyperscript2.default)(
        'span',
        null,
        ' ',
        (0, _i18n2.default)('emptySeat')
      ),
      (0, _hyperscript2.default)(
        'button',
        { oncreate: helper.ontap(ctrl.invite) },
        (0, _i18n2.default)('inviteBot')
      )
    ),
    (0, _hyperscript2.default)(
      'span',
      { className: 'masaPoints ', 'data-icon': 'Q' },
      player.score
    )
  ) : (0, _hyperscript2.default)(
    'li',
    { className: 'list-item masa-list-player ' + (isMe ? 'masa-me' : '') },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaPlayer' },
      (0, _hyperscript2.default)(
        'span',
        { className: 'flagRank', 'data-icon': player.withdraw ? 'b' : '' },
        ' ',
        player.withdraw ? '' : player.rank + '. '
      ),
      (0, _hyperscript2.default)(
        'span',
        null,
        ' ',
        !player.name ? 'Anonymous' : player.name + ' (' + player.rating + ') '
      )
    ),
    (0, _hyperscript2.default)(
      'span',
      { className: 'masaPoints ', 'data-icon': 'Q' },
      player.score
    )
  );
}

},{"../../../i18n":138,"../../../oyunkeyf/variant":144,"../../../router":145,"../../../session":147,"../../../settings":148,"../../helper":157,"../faq":168,"mithril/hyperscript":113}],167:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ctrl) {
  return {
    reload: ctrl.reload,
    redirect: function redirect(gameId) {
      // doesn't fire for new join
      console.log("redirect" + gameId);
    }
  };
};

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"../../../router":145,"../../../utils/redraw":212}],168:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: function controller(masa) {
    var _isOpen = false;

    function open() {
      _router2.default.backbutton.stack.push(close);
      _isOpen = true;
    }
    function close(fromBB) {
      if (fromBB !== 'backbutton' && _isOpen) _router2.default.backbutton.stack.pop();
      _isOpen = false;
    }

    return {
      open: open,
      close: close,
      isOpen: function isOpen() {
        return _isOpen;
      },
      masa: masa
    };
  },
  view: function view(ctrl) {
    if (!ctrl.isOpen()) return null;
    var masa = ctrl.masa;

    if (!masa) return null;

    return h(
      'div',
      { className: 'modal', id: 'masaFaqModal', config: helper.slidesInUp },
      h(
        'header',
        null,
        h('button', { className: 'modal_close', 'data-icon': 'L',
          oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, "masaFaqModal")) }),
        h(
          'h2',
          null,
          (0, _i18n2.default)('masaFAQ')
        )
      ),
      h(
        'div',
        { className: 'modal_content' },
        h(
          'div',
          { className: 'masaFaq' },
          h(
            'h2',
            null,
            'Puanl\u0131 m\u0131?'
          ),
          masa.rated === undefined ? 'Baz masalar puanldr ve reytinginizi etkiler.' : masa.rated ? 'Bu masa puanldr ve reytinginizi etkiler.' : 'Bu masa puanl *deildir* ve reytinginizi *etkilemez*.',
          h(
            'h2',
            null,
            ' Puanlar nas\u0131l hesaplan\u0131r? '
          ),
          'Masaya kat\u0131l\u0131mda her oyuncu ortaya el say\u0131s\u0131 kadar puan\u0131n\u0131 koyar. Masa sonunda ortadaki puanlar \u015F\xF6yle da\u011F\u0131t\u0131l\u0131r:',
          h(
            'ul',
            null,
            h(
              'li',
              null,
              '1. %50 puan'
            ),
            h(
              'li',
              null,
              '2. %25 puan'
            ),
            h(
              'li',
              null,
              '3. %15 puan'
            ),
            h(
              'li',
              null,
              '4. %10 puan'
            )
          ),
          '\xD6rne\u011Fin 10 ellik bir oyunda oyuncular\u0131n puanlar\u0131 1500 olsun. Masaya kat\u0131ld\u0131klar\u0131nda puanlar\u0131 1490 olur. Ortada toplam 40 puan vard\u0131r, ve \u015F\xF6yle da\u011F\u0131t\u0131l\u0131r:',
          h(
            'ul',
            null,
            h(
              'li',
              null,
              '1. +20 = 1510'
            ),
            h(
              'li',
              null,
              '2. +10 = 1500'
            ),
            h(
              'li',
              null,
              '3. +6 = 1496'
            ),
            h(
              'li',
              null,
              '4. +4 = 1494'
            )
          ),
          'Masa bitmeden ayr\u0131lan oyuncu puan alamaz.',
          h(
            'h2',
            null,
            ' Kazanan nas\u0131l belirlenir? '
          ),
          'Masada b\xFCt\xFCn eller oynand\u0131ktan sonra en az cezas\u0131 olan oyuncu galip ilan edilir.',
          h(
            'h2',
            null,
            ' Masada eslestirme nasil yapilir? '
          ),
          'Masaya 4 oyuncu katildiginda el baslar. Bir el bittikten sonra yeni el baslar, yeni ele katilmak icin oyuncular masaya geri donmelidir.',
          h(
            'h2',
            null,
            ' Masa ne zaman biter? '
          ),
          'Masada el say\u0131s\u0131 kadar oyun oynand\u0131\u011F\u0131nda masa biter.',
          h(
            'h2',
            null,
            ' Oyundan ayr\u0131lma '
          ),
          'Oyun devam ederken oyundan ayrilan oyuncu masadan atilir, ve o el iptal olur. Masa bitmeden masadan ayr\u0131lan oyuncu puan alamaz.',
          h(
            'h2',
            null,
            ' Di\u011Fer \xF6nemli kurallar '
          ),
          'Siraniz geldiginde, oyanama s\xFCrenizi a\u015Farsan\u0131z sistem sizin yerinize oynar.'
        )
      )
    );
  }
};

},{"../../backbutton":135,"../../i18n":138,"../../router":145,"../helper":157,"mithril/hyperscript":113}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _utils = require('../../utils');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _MasasListCtrl = require('./MasasListCtrl');

var _MasasListCtrl2 = _interopRequireDefault(_MasasListCtrl);

var _masasListView = require('./masasListView');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

  oncreate: helper.viewFadeIn,

  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    // socket.createDefault()

    this.ctrl = new _MasasListCtrl2.default((0, _utils.safeStringToNum)(attrs.tab));
  },
  view: function view() {
    var ctrl = this.ctrl;

    var body = (0, _masasListView.renderMasasList)(ctrl);
    var footer = (0, _masasListView.renderFooter)(ctrl);
    var overlay = null;

    return _layout2.default.free((0, _common.header)((0, _i18n2.default)('masas')), body, footer, overlay);
  }
};

},{"../../i18n":138,"../../session":147,"../../utils":210,"../helper":157,"../layout":160,"../shared/common":186,"./MasasListCtrl":163,"./masasListView":171}],170:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.currentMasas = currentMasas;
exports.masa = masa;
exports.reload = reload;
exports.join = join;
exports.invite = invite;
exports.withdraw = withdraw;

var _http = require('../../http');

function currentMasas() {
  return (0, _http.fetchJSON)('/masa', {}, true);
}

function masa(id) {
  return (0, _http.fetchJSON)('/masa/' + id, { query: { socketVersion: 1 } }, true);
}

function reload(id, page) {
  return (0, _http.fetchJSON)('/masa/' + id, { method: 'GET', query: page ? { page: page } : {} });
}

function join(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/join', { method: 'POST' }, true);
}

function invite(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/invite', { method: 'POST' }, true);
}

function withdraw(id) {
  return (0, _http.fetchJSON)('/masa/' + id + '/withdraw', { method: 'POST' }, true);
}

// import { request } from '../../http';

// export function currentMasas() {
//   return request('/masa', {}, true);
// }

// export function masa(id) {
//   return request('/masa/' + id, { data: {socketVersion: 1}}, true);
// }

// export function reload(id) {
//   return request('/masa/' + id,
//                  {
//                    method: 'GET',
//                    data: {},
//                    background: true
//                  });
// }

// export function join(id, side) {
//   side = side ? `?side=${side}`: '';
//   return request('/masa/' + id + '/join' + side, { method: 'POST' }, true);
// }

// export function withdraw(id) {
//   return request('/masa/' + id + '/withdraw', { method: 'POST' }, true);
// }

},{"../../http":137}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderMasasList = renderMasasList;
exports.renderMasaList = renderMasaList;
exports.renderFooter = renderFooter;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _utils = require('../../utils');

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _TabNavigation = require('../shared/TabNavigation');

var _TabNavigation2 = _interopRequireDefault(_TabNavigation);

var _TabView = require('../shared/TabView');

var _TabView2 = _interopRequireDefault(_TabView);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TABS = [{
  label: 'Ak'
}, {
  label: 'Oynanan'
}, {
  label: 'Biten'
}];

function onMasaTap(e) {
  var el = helper.getLI(e);
  var ds = el.dataset;
  if (el && ds.id) {
    _router2.default.set('/masa/' + ds.id);
  }
}

function renderMasasList(ctrl) {
  if (!ctrl.masas) return null;

  var tabsContent = [ctrl.masas['created'], ctrl.masas['started'], ctrl.masas['finished']];

  return [(0, _hyperscript2.default)('div.tabs-nav-header.subHeader', (0, _hyperscript2.default)(_TabNavigation2.default, {
    buttons: TABS,
    selectedIndex: ctrl.currentTab,
    onTabChange: ctrl.onTabChange
  }), (0, _hyperscript2.default)('div.main_header_drop_shadow')), (0, _hyperscript2.default)(_TabView2.default, {
    className: 'masaTabsWrapper',
    selectedIndex: ctrl.currentTab,
    content: tabsContent,
    renderer: renderMasaList,
    onTabChange: ctrl.onTabChange
  })];
}

function renderMasaList(list) {
  return (0, _hyperscript2.default)('ul.native_scroller.masaList', {
    oncreate: helper.ontapXY(onMasaTap, undefined, helper.getLI)
  }, list.map(renderMasaListItem));
}

function renderMasaListItem(masa, index) {
  var mode = masa.rated ? (0, _i18n2.default)('rated') : (0, _i18n2.default)('casual');
  var variant = (0, _utils.capitalize)(masa.variant.short);
  var evenOrOdd = index % 2 === 0 ? ' even ' : ' odd ';
  var scores = masa.scores;
  var rounds = masa.rounds;

  return (0, _hyperscript2.default)(
    'li',
    { key: masa.id,
      className: 'list_item masa_item' + evenOrOdd,
      'data-id': masa.id
    },
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaListName' },
      (0, _hyperscript2.default)(
        'div',
        { className: 'fullName' },
        masa.fullName
      ),
      (0, _hyperscript2.default)(
        'small',
        { className: 'infos' },
        variant,
        ' ',
        mode,
        ' \u2022 ',
        scores ? scores + ' ' + (0, _i18n2.default)('points') : (0, _i18n2.default)('rounds', rounds)
      )
    ),
    (0, _hyperscript2.default)(
      'div',
      { className: 'masaListTime' },
      (0, _hyperscript2.default)(
        'small',
        { className: 'nbUsers withIcon', 'data-icon': 'r' },
        masa.nbPlayers
      )
    )
  );
}

function renderFooter(ctrl) {
  return (0, _hyperscript2.default)(
    'div',
    { className: 'actions_bar' },
    (0, _hyperscript2.default)(
      'button',
      { key: 'createMasa', className: 'action_create_button', oncreate: helper.ontap(_newGameForm2.default.openRealtime) },
      (0, _hyperscript2.default)('span', { className: 'fa fa-plus-circle' }),
      (0, _i18n2.default)('createANewMasa')
    ),
    (0, _hyperscript2.default)(
      'button',
      { key: 'refreshMasa', className: 'action_refresh_button',
        oncreate: helper.ontap(ctrl.refresh) },
      (0, _hyperscript2.default)('span', { className: 'fa fa-refresh' }),
      (0, _i18n2.default)('refresh')
    )
  );
}

},{"../../i18n":138,"../../router":145,"../../utils":210,"../helper":157,"../newGameForm":174,"../shared/TabNavigation":183,"../shared/TabView":184,"mithril/hyperscript":113}],172:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backdropCloseHandler = exports.mainMenuCtrl = exports.profileMenuOpen = undefined;
exports.route = route;
exports.popup = popup;

var _stream = require('mithril/stream');

var _stream2 = _interopRequireDefault(_stream);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _backbutton = require('../../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

var _SideMenuCtrl = require('../shared/sideMenu/SideMenuCtrl');

var _SideMenuCtrl2 = _interopRequireDefault(_SideMenuCtrl);

var _helper = require('../helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var profileMenuOpen = exports.profileMenuOpen = (0, _stream2.default)(false);

function onMenuOpen() {}

function onMenuClose() {}

var mainMenuCtrl = exports.mainMenuCtrl = new _SideMenuCtrl2.default('left', 'side_menu', 'menu-close-overlay', onMenuOpen, onMenuClose);

function route(route) {
  return function () {
    return mainMenuCtrl.close().then(function () {
      return _router2.default.set(route);
    });
  };
}

function popup(action) {
  return function () {
    return mainMenuCtrl.close().then(function () {
      action();
      (0, _redraw2.default)();
    });
  };
}

var backdropCloseHandler = exports.backdropCloseHandler = (0, _helper.ontap)(function () {
  mainMenuCtrl.close();
});

var menu = {};

/* properties */
menu.isOpen = false;
// menu.headerOpen = m.prop(false);

menu.route = function (route) {
  return function () {
    return menu.close().then(_mithril2.default.route.bind(null, route));
  };
};

menu.popup = function (action) {
  return function () {
    return menu.close().then(function () {
      action();
      _mithril2.default.redraw();
    });
  };
};

menu.toggle = function () {
  if (menu.isOpen) menu.close();else menu.open();
};

menu.open = function () {
  _backbutton2.default.stack.push(menu.close);
  menu.isOpen = true;
};

menu.willClose = false;
menu.close = function (fromBB) {
  var sideMenu = document.getElementById('side_menu');

  if (menu.willClose || !sideMenu) return Promise.resolve(null);

  menu.willClose = true;
  if (fromBB !== 'backbutton' && menu.isOpen) _backbutton2.default.stack.pop();
  _mithril2.default.redraw.strategy('none');
  return (0, _zanimo2.default)(sideMenu, 'transform', 'translate3d(-100%,0,0', 250, 'ease-out').then(function () {
    menu.headerOpen(false);
    menu.isOpen = false;
    menu.willClose = false;
    _mithril2.default.redraw();
  }).catch(function (err) {
    console.error(err);
    menu.headerOpen(false);
    menu.isOpen = false;
    menu.willClose = false;
    _mithril2.default.redraw();
  });
};

menu.toggleHeader = function () {
  return menu.headerOpen() ? menu.headerOpen(false) : menu.headerOpen(true);
};

exports.default = menu;

},{"../../backbutton":135,"../../router":145,"../../utils/redraw":212,"../helper":157,"../shared/sideMenu/SideMenuCtrl":200,"mithril":114,"mithril/stream":121,"zanimo":131}],173:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _loginModal = require('../loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _utils = require('../../utils');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _ = require('.');

var menu = _interopRequireWildcard(_);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  onbeforeupdate: function onbeforeupdate() {
    return menu.mainMenuCtrl.isOpen;
  },
  view: function view() {
    var user = _session2.default.get();

    return h(
      'aside',
      { id: 'side_menu' },
      renderHeader(user),
      h(
        'div',
        { className: 'native_scroller side_menu_scroller' },
        user && menu.profileMenuOpen() ? renderProfileActions(user) : renderLinks(user)
      )
    );
  }
};


function renderHeader(user) {
  var profileLink = user ? menu.route('/@/' + user.id) : _utils.noop;

  return h(
    'header',
    { className: 'side_menu_header' },
    (0, _utils.hasNetwork)() && !user ? h(
      'button',
      { className: 'signInButton', oncreate: helper.ontapXY(_loginModal2.default.open) },
      (0, _i18n2.default)('signIn')
    ) : null,
    user ? h(
      'h2',
      { className: 'username', oncreate: helper.ontapXY(profileLink) },
      user.username
    ) : null
  );
}

function slidesInUp(el, isUpdate, context) {
  if (!isUpdate) {
    el.style.transform = 'translate3d(-100%, 0, 0)';
    // force reflow back
    context.lol = el.offsetHeight;
    (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out');
  }
}

function renderLinks(user) {

  return h(
    'ul',
    { className: 'side_links',
      oncreate: helper.ontapXY(onLinkTap, undefined, helper.getLI) },
    h(
      'li',
      { className: 'side_link', 'data-route': '/' },
      h('span', { className: 'fa fa-home' }),
      (0, _i18n2.default)('home')
    ),
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'sep_link', key: 'sep_link_online' },
      (0, _i18n2.default)('playOnline')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-popup': 'createAGame' },
      h('span', { className: 'fa fa-plus-circle' }),
      (0, _i18n2.default)('createAGame')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/masas' },
      h('span', { className: 'fa fa-trophy' }),
      (0, _i18n2.default)('masas')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/todo' },
      h('span', { className: 'fa fa-at' }),
      (0, _i18n2.default)('players')
    ) : null,
    (0, _utils.hasNetwork)() ? h(
      'li',
      { className: 'side_link', 'data-route': '/todo' },
      h('span', { className: 'fa fa-cubes' }),
      (0, _i18n2.default)('leaderboard')
    ) : null,
    h('li', { className: 'hr' }),
    h(
      'li',
      { className: 'side_link', 'data-route': '/settings' },
      h('span', { className: 'fa fa-cog' }),
      (0, _i18n2.default)('settings')
    ),
    h(
      'li',
      { className: 'side_link', oncreate: helper.ontapXY(function () {
          _session2.default.logout();
          // menu.mainMenuCtrl.close(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

function renderProfileActions(user) {
  return h(
    'ul',
    { className: 'side_links profileActions' },
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(menu.route('/@/' + user.id)) },
      h('span', { 'data-icon': 'r' }),
      (0, _i18n2.default)('profile')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(menu.route('/settings/preferences')) },
      h('span', { 'data-icon': '%' }),
      (0, _i18n2.default)('preferences')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontouch(function () {
          _session2.default.logout();
          menu.headerOpen(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

var popupActionMap = {
  'createAGame': function createAGame() {
    return _newGameForm2.default.openRealtime();
  }
};

function onLinkTap(e) {
  var el = helper.getLI(e);
  var ds = el.dataset;
  if (el && ds.route) {
    menu.route(ds.route)();
  } else if (el && ds.popup) {
    menu.popup(popupActionMap[ds.popup])();
  }
}

// OLD

function renderProfileActionsOLD(user) {
  return h(
    'ul',
    { className: 'side_links profileActions' },
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(menu.route('/@/' + user.id)) },
      h('span', { className: 'fa fa-user' }),
      (0, _i18n2.default)('profile')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(menu.route('/settings/preferences')) },
      h('span', { 'data-icon': '%' }),
      (0, _i18n2.default)('preferences')
    ),
    h(
      'li',
      { className: 'side_link', config: helper.ontapXY(function () {
          _session2.default.logout();
          menu.profileMenuOpen(false);
        }) },
      h('span', { 'data-icon': 'w' }),
      (0, _i18n2.default)('logOut')
    )
  );
}

function renderMenu() {
  var user = _session2.default.get();
  return h(
    'div',
    { className: 'native_scroller' },
    renderHeader(user),
    user && menu.headerOpen() ? renderProfileActions(user) : renderLinks(user)
  );
}

},{".":172,"../../i18n":138,"../../session":147,"../../utils":210,"../helper":157,"../loginModal":162,"../newGameForm":174,"mithril/hyperscript":113,"zanimo":131}],174:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderQuickSetup = renderQuickSetup;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _setup = require('../oyunkeyf/setup');

var _popup = require('./shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _form = require('./shared/form');

var _form2 = _interopRequireDefault(_form);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _settings = require('../settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _xhr = require('../xhr');

var xhr = _interopRequireWildcard(_xhr);

var _lobby = require('./lobby');

var _lobby2 = _interopRequireDefault(_lobby);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;

var humanSetup = _settings2.default.gameSetup.human;

exports.default = {
  open: open,
  close: close,
  openRealtime: function openRealtime() {
    open();
  },
  view: function view() {
    return (0, _popup2.default)('new_game_form_popup game_form_popup', undefined, renderContent, isOpen, close);
  }
};


function open() {
  _router2.default.backbutton.stack.push(close);
  isOpen = true;
}

function close(fromBB) {
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

function renderContent() {
  var conf = humanSetup;

  return (0, _hyperscript2.default)('div', [(0, _hyperscript2.default)('div.newGame-preset_switch', [renderCustomSetup('human', conf, conf.availableVariants)])]);
}

function renderCustomSetup(formName, settingsObj, variants) {
  var generalFieldset = [(0, _hyperscript2.default)('div.select_input', {
    key: formName + 'variant'
  }, _form2.default.renderSelect('variant', formName + 'variant', variants, settingsObj.variant))];

  var modes = [['casual', '0'], ['rated', '1']];

  generalFieldset.push((0, _hyperscript2.default)('div.select_input', {
    key: formName + 'mode'
  }, _form2.default.renderSelect('mode', formName + 'mode', modes, settingsObj.mode)));

  var timeFieldset = [];

  timeFieldset.push((0, _hyperscript2.default)('div.select_input.inline', {
    key: formName + 'round'
  }, _form2.default.renderSelect('rounds', formName + 'rounds', _settings2.default.gameSetup.availableRounds, settingsObj.rounds, false)));

  return (0, _hyperscript2.default)('form.game_form', {
    key: 'customSetup',
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      close();
      goSeek((0, _setup.humanSetupFromSettings)(settingsObj));
    }
  }, [(0, _hyperscript2.default)('fieldset', generalFieldset), (0, _hyperscript2.default)('fieldset', timeFieldset), (0, _hyperscript2.default)('div.popupActionWrapper', [(0, _hyperscript2.default)('button[data-icon=E][type=submit].popupAction', (0, _i18n2.default)('createAGame'))])]);
}

function renderQuickSetup(onCustom) {
  return (0, _hyperscript2.default)('div.newGame-pools', { key: 'quickSetup' }, (0, _hyperscript2.default)('div.newGame-pool', {
    key: 'pool-custom',
    oncreate: helper.ontap(onCustom)
  }, (0, _hyperscript2.default)('div.newGame-custom', 'zel')));
}

function goSeek(conf) {
  close();

  _lobby2.default.startSeeking(conf);
}

// export function renderQuickSetup() {
//   return h('div.newGame-pools', { key: 'quickSetup' },
//            xhr.cachedPools.map(p => renderPool(p))
//           );
// }

// function renderPool(p) {
//   return h('div.newGame-pool', {
//     key: 'pool-' + p.id,
//     oncreate: helper.ontap(() => {
//       console.log('oncreate');
//     })
//   }, [h('div.newGame-rounds', p.id),
//       h('div.newGame-perf', p.perf)
//      ]);
// }

// const newGameForm = {};

// newGameForm.isOpen = false;

// newGameForm.open = function() {
//   backbutton.stack.push(newGameForm.close);
//   newGameForm.isOpen = true;
// };

// newGameForm.close = function(fromBB) {
//   if (fromBB !== 'backbutton' && newGameForm.isOpen) backbutton.stack.pop();
//   newGameForm.isOpen = false;
// };

// newGameForm.openRealtime = function() {
//   newGameForm.open();
// };

// function seekHumanGame() {
//   newGameForm.close();
//   lobby.startSeeking();
// }

// function renderForm(formName, action, settingsObj, variants) {
//   var generalFieldset = [
//     m('div.select_input', {
//       key: formName + 'variant'
//     }, [
//       formWidgets.renderSelect('variant', formName + ' variant', variants, settingsObj.variant)
//     ])
//   ];


//   // Human only
//   if (settingsObj.mode) {
//     var modes = (session.isConnected()) ? [
//       ['casual', '0'],
//       ['rated', '1']
//     ] : [ ['casual', '0'] ];

//     generalFieldset.push(m('div.select_input', {
//       key: formName + 'mode'
//     }, [
//       formWidgets.renderSelect('mode', formName + 'mode', modes, settingsObj.mode)
//     ]));

//     if (session.isConnected() && settingsObj.mode() === '0') {
//       generalFieldset.push(
//         formWidgets.renderCheckbox(i18n('membersOnly'), 'membersOnly', settingsObj.membersOnly));
//     }
//   }

//   // both human
//   var roundFieldset = [
//     // m('div.select_input', {
//     //   key: formName + 'rounds'
//     // }, [
//     //   formWidgets.renderSelect('round', formName + 'rounds', roundModes, settingsObj.roundMode)
//     // ])
//   ];

//   if (true) {
//     roundFieldset.push(
//       m('div.select_input', {
//         key: formName + 'rounds'
//       }, [
//         formWidgets.renderSelect('rounds', formName + 'round',
//                                  settings.gameSetup.availableRounds, settingsObj.rounds, false)
//       ])
//     );
//   }

//   return m('form#new_game_form.game_form', {
//     onsubmit: function(e) {
//       e.preventDefault();
//       if (!settings.gameSetup.isRoundValid(settingsObj)) return;
//       newGameForm.close();
//       action();
//     }
//   }, [
//     m('fieldset', [
//     ]),
//     m('fieldset', generalFieldset),
//     m('fieldset#round', roundFieldset),
//     m('button[data-icon=E][type=submit].newGameButton', i18n('createAGame'))
//   ]);
// }

// newGameForm.view = function() {
//   function form() {
//     return renderForm(
//       'human',
//       seekHumanGame,
//       settings.gameSetup.human,
//       settings.gameSetup.human.availableVariants);
// };

//   return popupWidget(
//     'new_game_form_popup game_form_popup',
//     null,
//     form,
//     newGameForm.isOpen,
//     newGameForm.close
//   );
// };

// export default newGameForm;

},{"../backbutton":135,"../i18n":138,"../oyunkeyf/setup":142,"../router":145,"../session":147,"../settings":148,"../xhr":215,"./helper":157,"./lobby":161,"./shared/form":187,"./shared/popup":191,"mithril":114,"mithril/hyperscript":113}],175:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _playersCtrl = require('./playersCtrl');

var _playersCtrl2 = _interopRequireDefault(_playersCtrl);

var _playersView = require('./playersView');

var _playersView2 = _interopRequireDefault(_playersView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _playersCtrl2.default,
  view: _playersView2.default
};

},{"./playersCtrl":177,"./playersView":178}],176:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onlinePlayers = onlinePlayers;

var _http = require('../../http');

function onlinePlayers() {
  return (0, _http.request)('/player/online', {}, true);
}

},{"../../http":137}],177:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _playerXhr = require('./playerXhr');

var xhr = _interopRequireWildcard(_playerXhr);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  _socket2.default.createDefault();

  var players = _mithril2.default.prop([]);

  xhr.onlinePlayers().then(players, function (err) {
    return utils.handleXhrError(err);
  });

  return {
    players: players,
    goToProfile: function goToProfile(u) {
      _mithril2.default.route('/@/' + u);
    },

    onunload: function onunload() {}
  };
}

},{"../../socket":150,"../../utils":210,"./playerXhr":176,"mithril":114}],178:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _common = require('../shared/common');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function view(ctrl) {

  var headerCtrl = header.bind(null, ctrl);
  var bodyCtrl = body.bind(null, ctrl);

  return _layout2.default.free(headerCtrl, bodyCtrl, null);
}

function header(ctrl) {
  return (0, _helper2.default)(
    'nav',
    null,
    (0, _common.menuButton)(),
    (0, _helper2.default)(
      'h1',
      null,
      (0, _i18n2.default)('players')
    ),
    (0, _helper2.default)(
      'div',
      { className: 'buttons' },
      (0, _helper2.default)('button', { className: 'main_header_button', key: 'searchPlayers', 'data-icon': 'y' })
    )
  );
}

function body(ctrl) {
  return (0, _helper2.default)(
    'ul',
    { className: 'playersSuggestion native_scroller_page' },
    ctrl.players().map(renderPlayer)
  );
}

function renderPlayer(user) {
  // find best perf
  var perf = Object.keys(user.perfs).reduce(function (prev, curr) {
    if (!prev) return curr;
    if (user.perfs[prev].rating < user.perfs[curr].rating) return curr;else return prev;
  });

  return (0, _helper2.default)(
    'li',
    { className: 'list_item playerSuggestion nav', config: _helper2.default.ontouchY(function () {
        return _mithril2.default.route('/@/' + user.id);
      }) },
    (0, _common.userStatus)(user),
    (0, _helper2.default)(
      'span',
      { className: 'rating', 'data-icon': utils.gameIcon(perf) },
      user.perfs[perf].rating
    )
  );
}

},{"../../i18n":138,"../../utils":210,"../helper":157,"../layout":160,"../shared/common":186,"mithril":114,"mithril/hyperscript":113}],179:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _form = require('../shared/form');

var _form2 = _interopRequireDefault(_form);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  controller: function controller() {
    _socket2.default.createDefault();
  },
  view: function view() {
    var header = utils.partialf(_common.header, null, (0, _common.backButton)((0, _i18n2.default)('settings')));

    return _layout2.default.free(header, renderBody);
  }
};


function renderBody() {
  return (0, _mithril2.default)('div', {
    style: { width: '100%', height: '100%' }
  }, [(0, _mithril2.default)('ul.settings_list.general.native_scroller.page', [(0, _mithril2.default)('li.list_item.nav', {
    key: 'lang',
    config: _helper2.default.ontouchY(utils.f(_mithril2.default.route, '/settings/lang'))
  }, (0, _i18n2.default)('language')), (0, _mithril2.default)('li.list_item.settingsChoicesInline', {
    key: 'backgroundTheme'
  }, [(0, _mithril2.default)('label', (0, _i18n2.default)('background')), (0, _mithril2.default)('fieldset', [(0, _mithril2.default)('div.nice-radio', _form2.default.renderRadio((0, _i18n2.default)('dark'), 'bgTheme', 'dark', _settings2.default.general.theme.background() === 'dark', function (e) {
    _settings2.default.general.theme.background(e.target.value);
    _layout2.default.onBackgroundChange(e.target.value);
  })), (0, _mithril2.default)('div.nice-radio', _form2.default.renderRadio((0, _i18n2.default)('light'), 'bgTheme', 'light', _settings2.default.general.theme.background() === 'light', function (e) {
    _settings2.default.general.theme.background(e.target.value);
    _layout2.default.onBackgroundChange(e.target.value);
  }))])])]), window.oyunkeyf.version ? (0, _mithril2.default)('section.app_version', 'v' + window.oyunkeyf.version) : null]);
}

},{"../../i18n":138,"../../settings":148,"../../socket":150,"../../utils":210,"../helper":157,"../layout":160,"../shared/common":186,"../shared/form":187,"mithril":114}],180:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _form = require('../shared/form');

var _form2 = _interopRequireDefault(_form);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _xhr = require('../../xhr');

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  controller: function controller() {
    var langs = _mithril2.default.prop([]);
    (0, _i18n.getAvailableLanguages)().then(langs);

    return {
      langs: langs
    };
  },
  view: function view(ctrl) {
    var header = utils.partialf(_common.header, null, (0, _common.backButton)((0, _i18n2.default)('language')));

    function renderLang(l) {
      return h(
        'li',
        { className: 'list_item' },
        _form2.default.renderRadio(l[1], 'lang', l[0], _settings2.default.general.lang() === l[0], function (e) {
          _settings2.default.general.lang(e.target.value);
          (0, _xhr.setServerLang)(e.target.value);
          (0, _i18n.loadFromSettings)();
        })
      );
    }

    function renderBody() {
      return h(
        'ul',
        { className: 'native_scroller page settings_list radio_list' },
        ctrl.langs().map(function (l) {
          return renderLang(l);
        })
      );
    }
    return _layout2.default.free(header, renderBody);
  }
};

},{"../../i18n":138,"../../settings":148,"../../utils":210,"../../xhr":215,"../layout":160,"../shared/common":186,"../shared/form":187,"mithril":114,"mithril/hyperscript":113}],181:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(vnode) {
    var okeyground = vnode.attrs.okeyground;


    this.wrapperOnCreate = function (_ref) {
      var dom = _ref.dom;
    };

    this.boardOnCreate = function (_ref2) {
      var dom = _ref2.dom;

      okeyground.attach(dom);
    };

    this.boardOnRemove = function () {
      okeyground.detach();
    };
  },
  view: function view(vnode) {
    var bounds = vnode.attrs.bounds;


    var boardClass = ['display_board'].join(' ');

    var wrapperClass = 'game_board_wrapper';

    var wrapperStyle = bounds ? {
      height: bounds.height + 'px',
      width: bounds.width + 'px'
    } : {};

    return h(
      'section',
      { oncreate: this.wrapperOnCreate, className: wrapperClass, style: wrapperStyle },
      h('div', { className: boardClass,
        oncreate: this.boardOnCreate,
        onremove: this.boardOnRemove })
    );
  }
};

// function renderTopMenu() {
//   return (
//     <div class="display_menu">
//       {menuButton()}
//     </div>
//   );
// }

// function renderPlayerInfo(ctrl, player, position) {
//   const wrapperClass = helper.classSet({
//     'playerInfos': true,
//   }) + ` ${position}`;

//   const playerName = player.ai ?
//                      i18n('aiBot', player.ai) :
//                      utils.playerName(player);
//   const playerOnGame = (player.onGame || player.ai ?
//                         <span className="ongame yes" data-icon="3"/> :
//                         <span className="ongame no" data-icon="0"/>
//   );

//   const togglePopup = ctrl.toggleUserPopup.bind(ctrl, position, player.user);
//   const vConf = helper.ontouch(togglePopup);

//   const runningSide = ctrl.isClockRunning() ? ctrl.data.game.player : null;
//   const running = ctrl.data.game.player === player.side;

//   const opens = ctrl.data.game.oscores ? ctrl.data.game.oscores[player.side] : null;
//   const opensHint = opens ? (opens.series ? 'openedSeries' : 'openedPairs') : null;
//   const opensClass = "opens" + ((opens && opens.new) ? " new" : "");

//   return (
//     <div className={wrapperClass} config={vConf}>
//       <div class="wrap_info">
//         {opens ?
//          <div class={opensClass}>
//            {(opens.series ? opens.series : opens.pairs)}
//            {' '}
//            {i18n(opensHint).split(' ')[0]}
//          </div>: null
//         }
//       </div>
//       <div class="wrap_user">
//         <h2 className="playerUser">
//           {playerName}
//           {playerOnGame}
//         </h2>
//         { (ctrl.clock && running) ?
//           renderClock(ctrl.clock, player.side, runningSide, position) : null
//         }
//       </div>
//     </div>
//   );
// }

// export default function(
//   ctrl,
//   okeygroundCtrl,
//   bounds,
//   isPortrait,
//   wrapperClasses) {
//     const data = ctrl.data;

//     const boardClass = [
//       'display_board',
//     ].join(' ');

//     const key = 'board' + (isPortrait ? 'portrait' : 'landscape');
//     let wrapperClass = 'game_board_wrapper';

//     if (wrapperClasses) {
//       wrapperClass += ' ' + wrapperClasses;
//     }

//     const wrapperStyle = bounds ? {
//       height: bounds.height + 'px',
//       width: bounds.width + 'px'
//     } : {};


//     function wrapperConfig(el, isUpdate) {
//       if (!isUpdate) {
//       }
//     }

//     function boardConfig(el, isUpdate) {
//       if (!isUpdate) {
//         if (!bounds) {
//         }
//         okeyground.render(el, okeygroundCtrl);
//       }
//     }

//     okeygroundCtrl.data.topHooks = [
//       // renderTopMenu(),
//       renderPlayerInfo(ctrl, data.opponentUp, 'top'),
//       renderPlayerInfo(ctrl, data.opponentLeft, 'left'),
//       renderPlayerInfo(ctrl, data.player, 'bottom'),
//       renderPlayerInfo(ctrl, data.opponentRight, 'right')
//     ];


//     return (
//       <section className={wrapperClass} config={wrapperConfig}
//                style={wrapperStyle} key={key}>
//         <div className={boardClass} config={boardConfig} />
//       </section>
//     );
// }

},{"../../settings":148,"../../utils/redraw":212,"mithril/hyperscript":113}],182:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(_ref) {
    var attrs = _ref.attrs;


    var title = 'gameApi.title(data)';

    return (0, _hyperscript2.default)('div.main_header_title', {}, [(0, _hyperscript2.default)('h1.header-gameTitle', [(0, _hyperscript2.default)('span', title)])]);
  }
};

},{"mithril/hyperscript":113}],183:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;

    this.onTap = function (e) {
      var el = helper.getButton(e);
      var i = void 0;
      if (el && (i = el.dataset.index)) {
        attrs.onTabChange(Number(i));
      }
    };
  },
  view: function view(vnode) {
    var _vnode$attrs = vnode.attrs,
        buttons = _vnode$attrs.buttons,
        selectedIndex = _vnode$attrs.selectedIndex,
        noIndicator = _vnode$attrs.noIndicator,
        wrapperClass = _vnode$attrs.wrapperClass;


    var iWidth = 100 / buttons.length;
    var shift = selectedIndex * (iWidth * buttons.length);

    var indicatorStyle = {
      width: iWidth + '%',
      transform: 'translateX(' + shift + '%)'
    };

    var buttonStyle = {
      width: iWidth + '%'
    };

    function renderTab(b, i) {
      var className = ['tab-button', selectedIndex === i ? 'selected' : '', b.className].join(' ');
      return h(
        'button',
        { 'data-index': i, className: className, style: buttonStyle },
        b.label,
        b.chip !== undefined ? h(
          'span',
          { className: 'chip' },
          b.chip
        ) : null
      );
    }
    return h(
      'div',
      { className: 'tabs-navigation' + (wrapperClass ? ' ' + wrapperClass : ''),
        oncreate: helper.ontap(this.onTap) },
      buttons.map(renderTab),
      noIndicator ? null : h('div', { className: 'tabIndicator', style: 'indicatorStyle' })
    );
  }
};

},{"../helper":157,"mithril/hyperscript":113}],184:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _helper = require('../helper');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oncreate: function oncreate(_ref) {
    var attrs = _ref.attrs,
        dom = _ref.dom;
  },
  view: function view(_ref2) {
    var attrs = _ref2.attrs;

    var curIndex = attrs.selectedIndex;
    var vw = (0, _helper.viewportDim)().vw;
    var width = attrs.content.length * 100;
    var shift = -(curIndex * vw);

    var style = {
      width: width + 'vw',
      transform: 'translateX(' + shift + 'px)'
    };

    return (0, _hyperscript2.default)('div.tabs-view-wrapper', (0, _hyperscript2.default)('div.tabs-view', {
      style: style,
      className: attrs.className
    }, attrs.content.map(function (_, index) {
      return (0, _hyperscript2.default)('div.tab-content', {
        'data-index': index,
        className: curIndex === index ? 'current' : ''
      }, curIndex === index ? (0, _hyperscript2.default)(Tab, _extends({ index: index }, attrs)) : null);
    })));
  }
};


var Tab = {
  onbeforeupdate: function onbeforeupdate(_ref3, _ref4) {
    var attrs = _ref3.attrs;
    var oldattrs = _ref4.attrs;

    return attrs.content[attrs.index] !== oldattrs.content[oldattrs.index];
  },
  view: function view(_ref5) {
    var attrs = _ref5.attrs;

    return attrs.renderer(attrs.content[attrs.index], attrs.index);
  }
};

},{"../helper":157,"mithril/hyperscript":113}],185:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  view: function view(_, args) {
    var boardClass = ['display_board', args.variant ? args.variant.key : ''].join(' ');

    function boardConf(el, isUpdate, context) {
      var config = makeConfig(args);
      if (context.ground) {
        context.ground.set(config);
      } else {
        // TODO try to avoid that
        if (!config.bounds) {
          // console.log('no board bounds');
          // config.bounds = el.getBoundingClientRect();
        }
        context.ground = (0, _okeygroundMobile2.default)(el, config);
      }
    }
    return h('div', { className: boardClass, config: boardConf });
  }
};


function makeConfig(args) {
  var fen = args.fen,
      orientation = args.orientation,
      bounds = args.bounds;

  var conf = {
    viewOnly: true,
    minimalDom: true,
    fen: fen
  };

  // if (bounds) conf.bounds = bounds;

  return conf;
}

},{"mithril/hyperscript":113,"okeyground-mobile":1}],186:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.menuButton = menuButton;
exports.headerBtns = headerBtns;
exports.dropShadowHeader = dropShadowHeader;
exports.connectingDropShadowHeader = connectingDropShadowHeader;
exports.backButton = backButton;
exports.gamesButton = gamesButton;
exports.header = header;
exports.viewOnlyBoardContent = viewOnlyBoardContent;
exports.empty = empty;
exports.userStatus = userStatus;

var _menu = require('../menu');

var menu = _interopRequireWildcard(_menu);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _gamesMenu = require('../gamesMenu');

var _gamesMenu2 = _interopRequireDefault(_gamesMenu);

var _newGameForm = require('../newGameForm');

var _newGameForm2 = _interopRequireDefault(_newGameForm);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../../router');

var _router2 = _interopRequireDefault(_router);

var _icons = require('./icons');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function menuButton() {
  return h('button.fa.fa-navicon.main_header_button.menu_button', {
    key: 'main-menu',
    oncreate: helper.ontap(menu.mainMenuCtrl.toggle)
  });
}

function headerBtns() {

  if (utils.hasNetwork() && _session2.default.isConnected()) {
    return h('div', { key: 'buttons', className: 'buttons' });
  } else {
    return h('div', { key: 'buttons', className: 'buttons' });
  }
}

function dropShadowHeader(title, leftButton) {

  return [h('nav', [leftButton ? leftButton : menuButton(), title ? h(
    'div',
    { className: 'main_header_title', key: 'title' },
    title
  ) : null, headerBtns()]), h('div.main_header_drop_shadow')];
}

function connectingDropShadowHeader(title) {
  return [h('nav', [menuButton(), h('div.main_header_title.reconnecting', {
    className: title ? 'withTitle' : '',
    key: 'connecting-title'
  }), title ? h('div.main_header_title', { key: 'title' }, title) : null, headerBtns()]), h('div.main_header_drop_shadow')];
}

function backButton(title) {
  return h('div.back_button', { key: 'default-history-backbutton' }, [h('button', { oncreate: helper.ontap(_router2.default.backHistory) }, _icons.backArrow), title !== undefined ? typeof title === 'string' ? h('div.main_header_title', title) : title : null]);
}

// export function menuButton() {
//   return (
//       <button key="main-menu" className="fa fa-navicon main_header_button menu_button" config={helper.ontouch(menu.toggle)}>
//     </button>
//   );
// }

// export function backButton(title) {
//   return (
//       <button key="default-history-backbutton" className="back_button main_header_button" config={helper.ontouch(utils.backHistory)}>
//       <span className="fa fa-arrow-left"/>
//       {title ? <div className="title">{title}</div> : null }
//     </button>
//   );
// }

function gamesButton() {
  var key = void 0,
      action = void 0;

  key = 'games-menu';

  if (_session2.default.nowPlaying().length) {
    key = 'games-menu';
    action = _gamesMenu2.default.open;
  } else {
    key = 'new-game-form';
    action = _newGameForm2.default.open;
  }

  var className = ['main_header_button', 'game_menu_button', !utils.hasNetwork() ? 'invisible' : ''].join(' ');

  var longAction = function longAction() {
    return window.plugins.toast.show(i18n('nbGamesInPlay', _session2.default.nowPlaying().length), 'short', 'top');
  };

  return h('button', { key: key, className: className, config: helper.ontouch(action, longAction) });
}

// export function headerBtns() {
//   return (
//     <div key="buttons" className="buttons">
//       {gamesButton()}
//     </div>
//   );
// }

function header(title, leftButton) {
  return h(
    'nav',
    null,
    leftButton ? leftButton : menuButton(),
    title ? h(
      'h1',
      { key: 'title' },
      title
    ) : null,
    headerBtns()
  );
}

function viewOnlyBoardContent() {
  var isPortrait = false;
  var _vw$vh = { vw: 10, vh: 10 },
      vw = _vw$vh.vw,
      vh = _vw$vh.vh;

  var boardStyle = isPortrait ? { width: vw + 'px', height: vw + 'px' } : {};
  var boardKey = 'viewonlyboard';
  var className = 'board_wrapper';
  var board = h(
    'section',
    { key: boardKey, className: className, style: boardStyle },
    m.component(ViewOnlyBoard)
  );
  return [board];
}

function empty() {
  return [];
}

function userStatus(user) {
  var status = user.online ? 'online' : 'offline';
  return h(
    'div',
    { className: 'user' },
    h('span', { className: 'userStatus ' + status, 'data-icon': 'r' }),
    user.username
  );
}

},{"../../router":145,"../../session":147,"../../utils":210,"../gamesMenu":154,"../helper":157,"../menu":172,"../newGameForm":174,"./icons":188,"mithril/hyperscript":113}],187:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _redraw = require('../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  renderSelect: function renderSelect(label, name, options, settingsProp, isDisabled, onChangeCallback) {
    var prop = settingsProp();
    return [(0, _hyperscript2.default)('label', {
      'for': 'select_' + name
    }, (0, _i18n2.default)(label)), (0, _hyperscript2.default)('select', {
      id: 'select_' + name,
      disabled: isDisabled,
      onchange: function onchange(e) {
        var val = e.target.value;
        settingsProp(val);
        if (onChangeCallback) onChangeCallback(val);
        setTimeout(_redraw2.default, 10);
      }
    }, options.map(function (e) {
      return renderOption(e[0], e[1], prop, e[2], e[3]);
    }))];
  }
};


function renderOption(label, value, prop, labelArg, labelArg2) {
  var l = labelArg && labelArg2 ? (0, _i18n2.default)(label, labelArg, labelArg2) : labelArg ? (0, _i18n2.default)(label, labelArg) : (0, _i18n2.default)(label);
  return (0, _hyperscript2.default)('option', {
    key: value,
    value: value,
    selected: prop === value
  }, l);
}

// import i18n from '../../i18n';
// import m from 'mithril';

// function renderOption(label, value, storedValue, labelArg, labelArg2) {
//   return m('option', {
//     value: value,
//     selected: storedValue === value
//   }, i18n(label, labelArg, labelArg2));
// }

// export default {
//   renderRadio: function(label, name, value, checked, onchange) {
//     var id = name + '_' + value;
//     return [
//       m('input.radio[type=radio]', {
//         name,
//         id,
//         className: value,
//         value,
//         checked,
//         onchange
//       }),
//       m('label', {
//         'for': id
//       }, i18n(label))
//     ];
//   },

//   renderSelect: function(label, name, options, settingsProp, isDisabled, onChangeCallback) {
//     var storedValue = settingsProp();
//     return [
//       m('label', {
//         'for': 'select_' + name
//       }, i18n(label)),
//       m('select', {
//         id: 'select_' + name,
//         disabled: isDisabled,
//         config: function(el, isUpdate, context) {
//           if (!isUpdate) {
//             var onChange = function(e) {
//               settingsProp(e.target.value);
//               if (onChangeCallback) onChangeCallback(e.target.value);
//               setTimeout(function() {
//                 m.redraw();
//               }, 10);
//             };
//             el.addEventListener('change', onChange, false);
//             context.onunload = () => {
//               el.removeEventListener('change', onChange, false);
//             };
//           }
//         }
//       }, options.map(function(e) {
//         return renderOption(e[0], e[1], storedValue, e[2], e[3]);
//       }))
//     ];
//   },
//   renderCheckbox: function(label, name, settingsProp, callback, disabled) {
//     var isOn = settingsProp();
//     return m('div.check_container', {
//       className: disabled ? 'disabled': ''
//     }, [
//       m('label', {
//         'for': name
//       }, label),
//       m('input[type=checkbox]', {
//         name: name,
//         disabled,
//         checked: isOn,
//         onchange: function() {
//           const newVal = !isOn;
//           settingsProp(newVal);
//           if (callback) callback(newVal);
//         }
//       })
//     ]);
//   }
// };

},{"../../i18n":138,"../../utils/redraw":212,"../helper":157,"mithril/hyperscript":113}],188:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require("mithril/hyperscript");

var backArrow = exports.backArrow = h(
  "div",
  { className: "svg_icon" },
  h(
    "div",
    { className: "svg_icon_inner" },
    h(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24" },
      h("path", { d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" })
    )
  )
);

var closeIcon = exports.closeIcon = h(
  "div",
  { className: "svg_icon" },
  h(
    "div",
    { className: "svg_icon_inner" },
    h(
      "svg",
      { width: "24", height: "24", viewBox: "0 0 24 24" },
      h("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" })
    )
  )
);

},{"mithril/hyperscript":113}],189:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit() {},
  view: function view(_ref) {
    var attrs = _ref.attrs,
        children = _ref.children;
    var header = attrs.header;


    return (0, _hyperscript2.default)('main#page', {}, [
    // h('header.main_header.board', header),
    (0, _hyperscript2.default)('div.content_round', children)]);
  }
};

},{"mithril/hyperscript":113}],190:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (key, name, perf, user) {
  var options = { className: 'profilePerf', 'data-icon': (0, _utils.gameIcon)(key) };

  if (variantPerfAvailable(key, perf)) {
    options.className += ' nav';
    options.config = _helper2.default.ontouchY(goToVariantPerf(user, key));
  }

  return (0, _mithril2.default)('div', options, [(0, _mithril2.default)('span.name', name), (0, _mithril2.default)('div.rating', [perf.rating, _helper2.default.progress(perf.prog), (0, _mithril2.default)('span.nb', '/ ' + perf.games)])]);
};

var _utils = require('../../utils');

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function goToVariantPerf(user, key) {
  return function () {
    return _mithril2.default.route('/@/${user.id}/${key}/perf');
  };
}

function variantPerfAvailable(key, perf) {
  return perf.games > 0;
}

},{"../../utils":210,"../helper":157,"mithril":114}],191:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var h = require('mithril/hyperscript');

exports.default = popup;

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function popup(classes, headerF, contentF, isShowing, closef) {

  if (!isShowing) return null;

  var defaultClasses = {
    overlay_popup: true,
    native_scroller: true
  };

  var className = void 0;

  if ((typeof classes === 'undefined' ? 'undefined' : _typeof(classes)) === 'object') {
    className = helper.classSet(Object.assign({}, defaultClasses, classes));
  } else if (typeof classes === 'string') {
    className = helper.classSet(defaultClasses) + ' ' + classes;
  } else {
    throw new Error('First popup argument must be either a string or an object');
  }

  var contentClass = helper.classSet({
    'popup_content': true,
    'noheader': !headerF
  });

  return h(
    'div',
    { key: String(contentF), className: 'overlay_popup_wrapper fade-in',
      onbeforemove: function onbeforemove(vnode) {
        vnode.dom.classList.add('fading_out');
        return new Promise(function (resolve) {
          setTimeout(resolve, 500);
        });
      } },
    h('div', { className: 'popup_overlay_close',
      oncreate: closef ? helper.ontap(closef) : utils.noop }),
    h(
      'div',
      { className: className },
      headerF ? h(
        'header',
        null,
        headerF()
      ) : null,
      h(
        'div',
        { className: contentClass },
        contentF()
      )
    )
  );
}

// function styleConf(el) {
//   const vh = helper.viewportDim().vh;
//   const h = el.getBoundingClientRect().height;
//   const top = (vh - h) / 2;
//   // el.style.top = top + 'px';
// }

// export default function(classes, headerF, contentF, isShowing, closeF) {
//   if (!isShowing) return null;

//   const defaultClasses = {
//     overlay_popup: true,
//     native_scroller: true
//   };

//   let className;

//   if (typeof classes === 'object') {
//     className = helper.classSet(Object.assign({}, defaultClasses, classes));
//   } else if (typeof classes === 'string') {
//     className = helper.classSet(defaultClasses) + ' ' + classes;
//   } else
//     throw new Error('First popup argument must be either string or an object');

//   return (
//     <div className="overlay_popup_wrapper">
//       <div className="popup_overlay_close"
//            config={closeF ? helper.ontouch(helper.fadesOut(closeF, '.overlay_popup_wrapper')) : utils.noop } />
//       <div className={className} config={styleConf}>
//         {headerF ? <header>{headerF()}</header> : null }
//         <div className="popup_content">
//           {contentF()}
//         </div>
//       </div>
//     </div>
//   );
// }

},{"../../utils":210,"../helper":157,"mithril/hyperscript":113}],192:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = OnlineRound;

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _socket = require('../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _ground = require('./ground');

var _ground2 = _interopRequireDefault(_ground);

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _socketHandler = require('./socketHandler');

var _socketHandler2 = _interopRequireDefault(_socketHandler);

var _ClockCtrl = require('./clock/ClockCtrl');

var _ClockCtrl2 = _interopRequireDefault(_ClockCtrl);

var _roundXhr = require('./roundXhr');

var xhr = _interopRequireWildcard(_roundXhr);

var _masaXhr = require('../../masa/masaXhr');

var masaXhr = _interopRequireWildcard(_masaXhr);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var util = _okeygroundMobile2.default.util;
var wrapGroup = util.wrapGroup,
    wrapPiece = util.wrapPiece,
    wrapDrop = util.wrapDrop,
    partial = util.partial;
function OnlineRound(id, cfg) {
  var _this = this;

  var setData = function setData(cfg) {
    _this.data = cfg;
  };

  var onResume = function onResume() {
    xhr.reload(_this).then(function (data) {
      _socket2.default.setVersion(data.player.version);
      _this.onReload(data);
    });
  };

  this.onMove = function (key, piece) {
    if (key === _okeygroundMobile2.default.move.drawMiddle) {
      _this.sendMove(key);
    }
    if (key === _okeygroundMobile2.default.move.discard) {
      _this.vm.hasPlayedDiscard = true;
    }
  };

  this.onUserMove = function (key, move) {
    // TODO: why?
    if (key === _okeygroundMobile2.default.move.leaveTaken) {
      return;
    }
    _this.sendMove(key, move);
  };

  this.sendMove = function (key) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var move = args;
    args.key = key;

    _socket2.default.send('move', move, {
      ackable: true
    });
  };

  this.apiMove = function (o) {
    var d = _this.data,
        playing = _game2.default.isPlayerPlaying(d);

    d.game.turns = o.ply;
    d.game.player = _game2.default.sideByPly(o.ply);
    d.possibleMoves = d.player.side === d.game.player ? o.dests : [];
    if (true) {
      if (o.isMove) {
        if (o.drawmiddle) {
          _this.okeyground.apiMove(o.key, wrapPiece(o.drawmiddle.piece));
        } else if (o.discard) {
          if (!_this.vm.hasPlayedDiscard) {
            _this.okeyground.apiMove(o.key, wrapPiece(o.discard.piece));
          } else {}
          _this.vm.hasPlayedDiscard = false;
        } else if (o.opens) {
          _this.okeyground.apiMove(o.key, wrapGroup(o.opens.group));
        } else if (o.drop) {
          _this.okeyground.apiMove(o.key, wrapDrop(o.drop.piece, o.drop.pos));
        } else if (o.key === _okeygroundMobile2.default.move.collectOpen) {
          _this.restoreFen(o.fen, _okeygroundMobile2.default.move.collectOpen);
        } else if (o.key === _okeygroundMobile2.default.move.leaveTaken) {
          _this.okeyground.apiMove(o.key, wrapPiece(o.leavetaken.piece));
        } else {
          _this.okeyground.apiMove(o.key);
        }
      }

      _this.okeyground.set({
        turnSide: d.game.player,
        movable: {
          dests: playing ? d.possibleMoves : []
        }
      });
    }

    if (o.clock) {
      var c = o.clock;
      if (_this.clock) _this.clock.setClock(d, o.clock.east, o.clock.west, o.clock.south, o.clock.north);
    }

    document.addEventListener('resume', onResume);

    (0, _redraw2.default)();
  };

  this.outoftime = (0, _throttle2.default)(function () {
    _socket2.default.send('outoftime', _this.data.game.player);
  }, 500);

  this.endWithData = function (scores) {
    xhr.reload(_this).then(_this.onReload);
  };

  this.onReload = function (rCfg) {
    setData(rCfg);

    if (!_game2.default.playable(_this.data)) {
      _this.showActions();
    }
    (0, _redraw2.default)();
  };

  this.showActions = function () {
    _router2.default.backbutton.stack.push(_this.hideActions);
    _this.vm.showingActions = true;
  };

  this.hideActions = function (fromBB) {
    if (fromBB !== 'backbutton' && _this.vm.showingActions) _router2.default.backbutton.stack.pop();
    _this.vm.showingActions = false;
  };

  this.id = id;
  setData(cfg);

  this.vm = {
    scoresheetInfo: {}
  };

  this.okeyground = _ground2.default.make(this.data, this.onUserMove, this.onMove);

  this.clock = this.data.clock ? new _ClockCtrl2.default(this.data, {
    onFlag: this.outoftime
  }) : null;

  if (this.clock) {
    var tickNow = function tickNow() {
      _this.clock && _this.clock.tick();
      if (_game2.default.playable(_this.data)) _this.clockTimeoutId = setTimeout(tickNow, 100);
    };
    this.clockTimeoutId = setTimeout(tickNow, 100);
  }

  _socket2.default.createGame(this.data.url.socket, this.data.player.version, (0, _socketHandler2.default)(this), this.data.url.round);

  this.unload = function () {
    clearTimeout(_this.clockTimeoutId);
    document.removeEventListener('resume', onResume);
  };

  this.resign = function () {
    masaXhr.withdraw(_this.data.game.masaId);
  };

  this.leaveTaken = function () {
    _this.sendMove(_okeygroundMobile2.default.move.leaveTaken);
  };

  this.openSeries = function () {
    _this.okeyground.playOpenSeries();
  };

  this.openPairs = function () {
    _this.okeyground.playOpenPairs();
  };

  this.sortPairs = function () {
    _this.okeyground.sortPairs();
  };

  this.sortSeries = function () {
    _this.okeyground.sortSeries();
  };

  this.leaveTaken = function () {
    _this.sendMove(_okeygroundMobile2.default.move.leaveTaken);
  };

  this.collectOpen = function () {
    _this.sendMove(_okeygroundMobile2.default.move.collectOpen);
  };

  this.restoreFen = function (fen, hint) {
    _this.okeyground.set({
      fen: fen,
      animationHint: hint
    });
  };

  if (!_game2.default.playable(this.data)) {
    this.showActions();
  }
  (0, _redraw2.default)();
}

},{"../../../oyunkeyf/game":140,"../../../router":145,"../../../socket":150,"../../../utils/redraw":212,"../../masa/masaXhr":170,"./clock/ClockCtrl":193,"./ground":195,"./roundXhr":196,"./socketHandler":197,"lodash/throttle":109,"okeyground-mobile":1}],193:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ClockCtrl;

var _game = require('../../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ClockCtrl(d, opts) {
  var _this = this;

  this.setClock = function (d, east, west, south, north) {
    var isClockRunning = _game2.default.playable(d) && (d.game.turns >= 4 || d.clock && d.clock.running);

    _this.times = {
      east: east * 1000,
      west: west * 1000,
      north: north * 1000,
      south: south * 1000,
      activeSide: isClockRunning ? d.game.player : undefined,
      lastUpdate: performance.now()
    };
  };

  this.opts = opts;

  var cdata = d.clock;

  this.emergMs = cdata.emerg; // 1000 * Math.min(60, Math.max(10, cdata.emerg * .125));

  this.setClock(d, cdata.sides.east, cdata.sides.west, cdata.sides.south, cdata.sides.north);

  this.elements = {
    east: null,
    west: null,
    south: null,
    north: null
  };

  this.tick = function () {
    var side = _this.times.activeSide;
    if (!side) return;

    var now = performance.now();
    var millis = _this.times[side] - _this.elapsed(now);
    if (millis <= 0) _this.opts.onFlag();else _this.updateElement(side, millis);
  };

  this.updateElement = function (side, millis) {
    var el = _this.elements[side];
    if (el) {
      var width = Math.max(0, Math.min(100, millis / 30000 * 100)) + '%';
      el.style.width = width;
      if (millis < _this.emergMs * 4 * 1000) el.classList.add('emerg');else el.classList.remove('emerg');
    }
  };

  this.elapsed = function () {
    var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
    return Math.max(0, now - _this.times.lastUpdate);
  };

  this.millisOf = function (side) {
    return _this.times.activeSide === side ? Math.max(0, _this.times[side] - _this.elapsed()) : _this.times[side];
  };

  this.isRunning = function () {
    return _this.times.activeSide !== undefined;
  };
}

},{"../../../../oyunkeyf/game":140}],194:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;
    var ctrl = attrs.ctrl,
        side = attrs.side;


    this.clockOnCreate = function (_ref2) {
      var dom = _ref2.dom;

      ctrl.elements[side] = dom;
      ctrl.updateElement(side, ctrl.millisOf(side));
    };
    this.clockOnUpdate = function (_ref3) {
      var dom = _ref3.dom;

      ctrl.elements[side] = dom;
      ctrl.updateElement(side, ctrl.millisOf(side));
    };
  },
  view: function view(_ref4) {
    var attrs = _ref4.attrs;


    return (0, _hyperscript2.default)('div', { className: 'bar' }, [(0, _hyperscript2.default)('span', {
      className: 'bar2',
      oncreate: this.clockOnCreate,
      onupdate: this.clockOnUpdate
    })]);
  }
};

},{"mithril/hyperscript":113}],195:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _okeygroundMobile = require('okeyground-mobile');

var _okeygroundMobile2 = _interopRequireDefault(_okeygroundMobile);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function makeConfig(data) {
  var fen = data.game.fen;

  return {
    fen: fen,
    turnSide: data.game.player,
    povSide: data.player.side,
    spectator: data.player.spectator,
    withTore: !!data.game.variant.key.match(/duzokey/),
    movable: {
      free: false,
      board: _game2.default.isPlayerPlaying(data),
      dests: _game2.default.isPlayerPlaying(data) ? data.possibleMoves : []
    }
  };
}

function make(data, userMove, onMove) {
  var config = makeConfig(data);
  config.movable.events = {
    after: userMove
  };
  config.events = {
    move: onMove
  };

  return new _okeygroundMobile2.default(config);
}

function end(ground) {
  ground.stop();
}

exports.default = {
  make: make,
  end: end
};

},{"../../../oyunkeyf/game":140,"okeyground-mobile":1}],196:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reload = reload;

var _http = require('../../../http');

function reload(ctrl) {
  return (0, _http.fetchJSON)(ctrl.data.url.round);
}

},{"../../../http":137}],197:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ctrl) {
  function reload(o) {}

  var handlers = {
    crowd: function crowd(o) {
      ['east', 'west', 'north', 'south'].forEach(function (side) {
        _game2.default.setOnGame(ctrl.data, side, o[side]);
      });
      (0, _redraw2.default)();
    },
    move: function move(o) {
      o.isMove = true;
      ctrl.apiMove(o);
    },
    end: function end(scores) {
      ctrl.data.game.scores = scores.result;
      _ground2.default.end(ctrl.okeyground);
      ctrl.endWithData(scores);
    }
  };

  return handlers;
};

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _game = require('../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _ground = require('./ground');

var _ground2 = _interopRequireDefault(_ground);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"../../../oyunkeyf/game":140,"../../../utils/redraw":212,"./ground":195}],198:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _router = require('../../../../router');

var _router2 = _interopRequireDefault(_router);

var _helper = require('../../../helper');

var helper = _interopRequireWildcard(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  resign: function resign(ctrl) {
    return h('button', {
      key: 'resign',
      className: 'resign',
      'data-icon': 'b',
      oncreate: helper.ontap(ctrl.resign)
    }, (0, _i18n2.default)('resign'));
  },
  returnToMasa: function returnToMasa(ctrl) {
    function handler() {
      ctrl.hideActions();
      var url = '/masa/' + ctrl.data.game.masaId;
      _router2.default.set(url, true);
    }
    return h(
      'button',
      { key: 'returnToMasa', oncreate: helper.ontap(handler) },
      h('span', { className: 'fa fa-throphy' }),
      (0, _i18n2.default)('backToMasa')
    );
  },
  openSeries: function openSeries(ctrl) {
    var className = "open-series";
    return h(
      'button',
      { className: className, key: 'openSeries',
        oncreate: helper.ontap(ctrl.openSeries) },
      (0, _i18n2.default)('openSeries')
    );
  },
  openPairs: function openPairs(ctrl) {
    var className = "open-pairs";
    return h(
      'button',
      { className: className, key: 'openPairs',
        oncreate: helper.ontap(ctrl.openPairs) },
      (0, _i18n2.default)('openPairs')
    );
  },
  sortPairs: function sortPairs(ctrl) {
    var className = "sort-series";
    return h(
      'button',
      { className: className, key: 'sortSeries',
        oncreate: helper.ontap(ctrl.sortPairs) },
      (0, _i18n2.default)('sortPairs')
    );
  },
  sortSeries: function sortSeries(ctrl) {
    var className = "sort-pairs";
    return h(
      'button',
      { className: className, key: 'sortSeries',
        oncreate: helper.ontap(ctrl.sortSeries) },
      (0, _i18n2.default)('sortSeries')
    );
  },
  collectOpen: function collectOpen(ctrl) {
    var className = "collect-open";
    return h(
      'button',
      { className: className, key: 'collectOpen',
        oncreate: helper.ontap(ctrl.collectOpen) },
      (0, _i18n2.default)('collectOpen')
    );
  },
  leaveTaken: function leaveTaken(ctrl) {
    var className = "leave-taken";
    return h(
      'button',
      { className: className, key: 'leaveTaken',
        oncreate: helper.ontap(ctrl.leaveTaken) },
      (0, _i18n2.default)('leaveTaken')
    );
  }
};

},{"../../../../i18n":138,"../../../../router":145,"../../../helper":157,"mithril/hyperscript":113}],199:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = view;

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _i18n = require('../../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _layout = require('../../../layout');

var _layout2 = _interopRequireDefault(_layout);

var _socket = require('../../../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _helper = require('../../../helper');

var helper = _interopRequireWildcard(_helper);

var _player = require('../../../../oyunkeyf/player');

var playerApi = _interopRequireWildcard(_player);

var _game = require('../../../../oyunkeyf/game');

var _game2 = _interopRequireDefault(_game);

var _status = require('../../../../oyunkeyf/status');

var _status2 = _interopRequireDefault(_status);

var _popup = require('../../../shared/popup');

var _popup2 = _interopRequireDefault(_popup);

var _Board = require('../../../shared/Board');

var _Board2 = _interopRequireDefault(_Board);

var _GameTitle = require('../../../shared/GameTitle');

var _GameTitle2 = _interopRequireDefault(_GameTitle);

var _button = require('./button');

var _button2 = _interopRequireDefault(_button);

var _clockView = require('../clock/clockView');

var _clockView2 = _interopRequireDefault(_clockView);

var _common = require('../../../shared/common');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function view(ctrl) {

  return _layout2.default.board(renderHeader(ctrl), renderContent(ctrl), overlay(ctrl));
}

function overlay(ctrl) {
  return [renderGamePopup(ctrl)];
}

function renderGameRunningActions(ctrl) {
  var gameControls = _button2.default.resign(ctrl);

  return (0, _hyperscript2.default)(
    'div',
    { className: 'game_controls' },
    gameControls
  );
}

function renderGameEndedActions(ctrl) {
  function utilPlayer(p, tag) {
    var fullName = p.user ? p.user.username : p.ai ? (0, _i18n2.default)('aiBot', p.ai) : 'Misafir';

    return (0, _hyperscript2.default)(
      'a',
      { className: 'user_link' },
      fullName
    );
  };
  function playerScoresheetTr(ctrl, _ref) {
    var player = _ref.player,
        scores = _ref.scores;

    var mySide = ctrl.data.player.side;

    return (0, _hyperscript2.default)(
      'tr',
      { key: player.side, className: player.side === mySide ? 'me' : '' },
      (0, _hyperscript2.default)(
        'th',
        { className: 'user' },
        utilPlayer(player)
      ),
      (0, _hyperscript2.default)(
        'th',
        { className: 'score' },
        scores.total
      )
    );
  }

  var result = _game2.default.result(ctrl.data);
  var resultDom = _status2.default.aborted(ctrl.data) ? [] : [(0, _hyperscript2.default)('strong', (0, _i18n2.default)(result)), (0, _hyperscript2.default)('br')];

  var buttons = void 0;
  var masaId = ctrl.data.game.masaId;
  if (masaId) {
    buttons = [_button2.default.returnToMasa(ctrl)];
  }

  var scores = ['east', 'west', 'north', 'south'].map(function (side) {
    return {
      player: _game2.default.getPlayer(ctrl.data, side),
      scores: ctrl.data.game.scores ? ctrl.data.game.scores[side] : { scores: [] }
    };
  });

  var endScores = (0, _hyperscript2.default)(
    'div',
    { className: 'crosstable' },
    (0, _hyperscript2.default)(
      'table',
      null,
      (0, _hyperscript2.default)(
        'thead',
        null,
        (0, _hyperscript2.default)('tr', null)
      ),
      (0, _hyperscript2.default)(
        'tbody',
        null,
        scores.map(playerScoresheetTr.bind(null, ctrl))
      )
    )
  );

  return (0, _hyperscript2.default)(
    'div',
    { className: 'game_controls' },
    (0, _hyperscript2.default)(
      'div',
      { className: 'endScores' },
      endScores
    ),
    (0, _hyperscript2.default)(
      'div',
      { className: 'control buttons' },
      buttons
    )
  );
}

function renderStatus(ctrl) {
  var result = _game2.default.result(ctrl.data);
  var winner = _game2.default.getPlayer(ctrl.data, ctrl.data.game.winner);
  var status = _status2.default.toLabel(ctrl.data.game.status.name, ctrl.data.game.winner) + (winner ? '. ' + 'winner' + '.' : '');

  return (_status2.default.aborted(ctrl.data) ? [] : [(0, _hyperscript2.default)('strong', result), (0, _hyperscript2.default)('br')]).concat([(0, _hyperscript2.default)('em.resultStatus', (0, _i18n2.default)(status))]);
}

function renderGamePopup(ctrl) {
  var header = !_game2.default.playable(ctrl.data) ? function () {
    return renderStatus(ctrl);
  } : undefined;

  return (0, _popup2.default)('player_controls', header, function () {
    return _game2.default.playable(ctrl.data) ? renderGameRunningActions(ctrl) : renderGameEndedActions(ctrl);
  }, ctrl.vm.showingActions, ctrl.hideActions);
}

function renderHeader(ctrl) {
  var children = void 0;

  children = [(0, _common.menuButton)(), renderTitle(ctrl)];

  children.push((0, _common.headerBtns)());

  return (0, _hyperscript2.default)('nav', {
    className: _socket2.default.isConnected() ? '' : 'reconnecting'
  }, children);
}

function renderTitle(ctrl) {
  var data = ctrl.data;
  var masa = ctrl.data.masa;

  return (0, _hyperscript2.default)(_GameTitle2.default, {
    key: 'playing-title',
    data: ctrl.data
  });
}

function renderContent(ctrl) {
  var player = renderPlayTable(ctrl, ctrl.data.player, 'player');
  var opponentLeft = renderPlayTable(ctrl, ctrl.data.opponentLeft, 'opponentLeft');
  var opponentRight = renderPlayTable(ctrl, ctrl.data.opponentRight, 'opponentRight');
  var opponentUp = renderPlayTable(ctrl, ctrl.data.opponentUp, 'opponentUp');

  //  const bounds = helper.getBoardBounds(helper.viewportDim());

  var board = (0, _hyperscript2.default)(_Board2.default, {
    variant: ctrl.data.game.variant.key,
    okeyground: ctrl.okeyground
    //    bounds
  });

  return _hyperscript2.default.fragment({}, [renderMenuActionsBar(ctrl), renderGameActionsBarRight(ctrl), player, opponentLeft, opponentRight, opponentUp, board]);
}

function renderGameActionsBarRight(ctrl) {
  var myTurn = _game2.default.isPlayerTurn(ctrl.data);

  var canOpenSeries = ctrl.okeyground.canOpenSeries();
  var canOpenPairs = ctrl.okeyground.canOpenPairs();
  var canLeaveTaken = ctrl.okeyground.canLeaveTaken();

  var canCollectOpen = ctrl.okeyground.canCollectOpen();

  return (0, _hyperscript2.default)(
    'section',
    { className: 'game_actions_bar right' },
    canLeaveTaken ? _button2.default.leaveTaken(ctrl) : null,
    canOpenPairs ? _button2.default.openPairs(ctrl) : _button2.default.sortPairs(ctrl),
    canOpenSeries ? _button2.default.openSeries(ctrl) : _button2.default.sortSeries(ctrl),
    canCollectOpen ? _button2.default.collectOpen(ctrl) : null
  );
}

function renderMenuActionsBar(ctrl) {
  var gmClass = ['fa', 'fa-ellipsis-v'].join(' ');

  var gmButton = (0, _hyperscript2.default)('button', { className: gmClass, key: 'gameMenu', oncreate: helper.ontap(ctrl.showActions) });

  return (0, _hyperscript2.default)(
    'section',
    { className: 'menu_actions_bar' },
    (0, _common.backButton)(),
    gmButton
  );
}

function renderPlayTable(ctrl, player, position) {

  var classN = 'playTable ' + position;

  return (0, _hyperscript2.default)(
    'section',
    { className: classN },
    renderAntagonistInfo(ctrl, player, position)
  );
}

function renderAntagonistInfo(ctrl, player, position) {
  // const runningSide = ctrl.isClockRunning() ? ctrl.data.game.player : undefined;
  var running = ctrl.data.game.player === player.side;
  var user = player.user;
  var playerName = playerApi.playerName(player);

  return (0, _hyperscript2.default)(
    'div',
    { className: 'antagonistInfos' },
    (0, _hyperscript2.default)(
      'h2',
      { className: 'antagonistUser' },
      (0, _hyperscript2.default)('span', { className: 'fa fa-circle status ' + (player.ai || player.onGame ? 'ongame' : 'offgame') }),
      playerName
    ),
    running ? renderClock(ctrl.clock, player.side) : null
  );
}

function renderClock(ctrl, side, runningSide) {
  return (0, _hyperscript2.default)(_clockView2.default, {
    ctrl: ctrl,
    side: side,
    runningSide: runningSide
  });
}

},{"../../../../i18n":138,"../../../../oyunkeyf/game":140,"../../../../oyunkeyf/player":141,"../../../../oyunkeyf/status":143,"../../../../socket":150,"../../../helper":157,"../../../layout":160,"../../../shared/Board":181,"../../../shared/GameTitle":182,"../../../shared/common":186,"../../../shared/popup":191,"../clock/clockView":194,"./button":198,"mithril/hyperscript":113}],200:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SideMenuCtrl;

var _zanimo = require('zanimo');

var _zanimo2 = _interopRequireDefault(_zanimo);

var _redraw = require('../../../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _router = require('../../../router');

var _router2 = _interopRequireDefault(_router);

var _ = require('.');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SideMenuCtrl(side, menuID, backdropID, onOpen, onClose) {
  var _this = this;

  this.isOpen = false;

  this.side = side;
  this.menuID = menuID;
  this.backdropID = backdropID;
  this.onOpen = onOpen;
  this.onClose = onClose;

  this.open = function () {
    _this.isOpen = true;
    _router2.default.backbutton.stack.push(_this.close);
    var el = document.getElementById(_this.menuID);
    var bd = document.getElementById(_this.backdropID);
    if (_this.onOpen) _this.onOpen();
    return Promise.all([(0, _zanimo2.default)(bd, 'visibility', 'visible', 0), (0, _zanimo2.default)(bd, 'opacity', _.BACKDROP_OPACITY, 250, 'linear'), (0, _zanimo2.default)(el, 'visibility', 'visible', 0), (0, _zanimo2.default)(el, 'transform', 'translate3d(0,0,0)', 250, 'ease-out')]).then(_redraw2.default).catch(console.log.bind(console));
  };

  this.close = function (fromBB) {
    if (fromBB !== 'backbutton' && _this.isOpen) _router2.default.backbutton.stack.pop();
    _this.isOpen = false;
    var el = document.getElementById(_this.menuID);
    var bd = document.getElementById(_this.backdropID);
    if (_this.onClose) _this.onClose();
    return Promise.all([(0, _zanimo2.default)(bd, 'opacity', 0, 250, 'linear'), (0, _zanimo2.default)(el, 'transform', _this.closeTranslate(), 250, 'ease-out')]).then(function () {
      Promise.all([(0, _zanimo2.default)(el, 'visibility', 'hidden', 0), (0, _zanimo2.default)(bd, 'visibility', 'hidden', 0)]);
    }).catch(console.log.bind(console));
  };

  this.toggle = function () {
    if (_this.isOpen) _this.close();else _this.open();
  };

  this.closeTranslate = function () {
    return _this.side === 'left' ? 'translate3d(-100%,0,0)' : 'translate3d(100%,0,0)';
  };
};

},{".":201,"../../../router":145,"../../../utils/redraw":212,"zanimo":131}],201:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var BACKDROP_OPACITY = exports.BACKDROP_OPACITY = 0.7;

},{}],202:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hyperscript = require('mithril/hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _socket = require('../socket');

var _socket2 = _interopRequireDefault(_socket);

var _redraw = require('../utils/redraw');

var _redraw2 = _interopRequireDefault(_redraw);

var _session = require('../session');

var _session2 = _interopRequireDefault(_session);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('./helper');

var helper = _interopRequireWildcard(_helper);

var _router = require('../router');

var _router2 = _interopRequireDefault(_router);

var _loginModal = require('./loginModal');

var _loginModal2 = _interopRequireDefault(_loginModal);

var _backbutton = require('../backbutton');

var _backbutton2 = _interopRequireDefault(_backbutton);

var _icons = require('./shared/icons');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isOpen = false;
var loading = false;

var formError = null;

exports.default = {
  open: open,
  close: close,
  view: function view() {
    if (!isOpen) return null;

    return (0, _hyperscript2.default)('div.modal#signupModal', { oncreate: helper.slidesInUp }, [(0, _hyperscript2.default)('header', [(0, _hyperscript2.default)('button.modal_close', {
      oncreate: helper.ontap(helper.slidesOutDown(close, 'signupModal'))
    }, _icons.closeIcon), (0, _hyperscript2.default)('h2', (0, _i18n2.default)('signUp'))]), (0, _hyperscript2.default)('div#signupModalContent.modal_content', {
      className: loading ? 'loading' : ''
    }, renderForm())]);
  }
};


function renderForm() {
  return [(0, _hyperscript2.default)('form.login', {
    onsubmit: function onsubmit(e) {
      e.preventDefault();
      return submit(e.target);
    }
  }, [(0, _hyperscript2.default)('div.field', [formError && formError.username ? (0, _hyperscript2.default)('div.form-error', formError.username[0]) : null, (0, _hyperscript2.default)('input#pseudo[type=text]', {
    className: formError && formError.username ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('username'),
    autocomplete: 'off',
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: false,
    required: true,
    onfocus: scrollToTop
  })]), (0, _hyperscript2.default)('div.field', [formError && formError.email ? (0, _hyperscript2.default)('div.form-error', formError.email[0]) : null, (0, _hyperscript2.default)('input#email[type=email]', {
    onfocus: scrollToTop,
    className: formError && formError.email ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('email'),
    autocapitalize: 'off',
    autocorrect: 'off',
    spellcheck: false,
    required: true
  })]), (0, _hyperscript2.default)('div.field', [formError && formError.password ? (0, _hyperscript2.default)('div.form-error', formError.password[0]) : null, (0, _hyperscript2.default)('input#password[type=password]', {
    onfocus: scrollToTop,
    className: formError && formError.password ? 'form-error' : '',
    placeholder: (0, _i18n2.default)('password'),
    required: true
  })]), (0, _hyperscript2.default)('div.submit', [(0, _hyperscript2.default)('button.submitButton[data-icon=F]', (0, _i18n2.default)('signUp'))])])];
}

function scrollToTop(e) {
  setTimeout(function () {
    var el = e.target;
    el.scrollIntoView(true);
  }, 300);
}

function submit(form) {
  var login = form[0].value.trim();
  var email = form[1].value.trim();
  var pass = form[2].value.trim();
  if (!login || !email || !pass) return;
  window.Keyboard.hide();
  loading = true;
  formError = null;
  (0, _redraw2.default)();
  _session2.default.signup(login, email, pass).then(function (d) {
    window.plugins.toast.show((0, _i18n2.default)('loginSuccessful'), 'short', 'center');
    _socket2.default.reconnectCurrent();
    (0, _redraw2.default)();
    _loginModal2.default.close();
    close();
  }).catch(function (error) {
    if (isSubmitError(error)) {
      loading = false;
      formError = error.body.error;
      (0, _redraw2.default)();
    } else {
      handleXhrError(error);
    }
  });
}

function isSubmitError(err) {
  return err.body.error !== undefined;
}

function open() {
  _router2.default.backbutton.stack.push(helper.slidesOutDown(close, 'signupModal'));
  formError = null;
  isOpen = true;
}

function close(fromBB) {
  window.Keyboard.hide();
  if (fromBB !== 'backbutton' && isOpen) _router2.default.backbutton.stack.pop();
  isOpen = false;
}

// const signupModal = {};

// var isOpen = false;

// function submit(form) {
//   var login = form[0].value.trim();
//   var email = form[1].value.trim();
//   var pass = form[2].value.trim();
//   if (!login || !email || !pass) return false;
//   window.cordova.plugins.Keyboard.close();
//   return session.signup(login, email, pass).then(function() {
//     signupModal.close();
//     loginModal.close();
//     window.plugins.toast.show(i18n('loginSuccessfull'), 'short', 'center');
//   }, function(error) {
//     var data = error.response;
//     if (data.error.username) {
//       window.plugins.toast.show(data.error.username[0], 'short', 'center');
//     } else if (data.error.password) {
//       window.plugins.toast.show(data.error.password[0], 'short', 'center');
//     }
//   });
// }

// signupModal.open = function() {
//   backbutton.stack.push(helper.slidesOutDown(signupModal.close, 'signupModal'));
//   isOpen = true;
// };

// signupModal.close = function(fromBB) {
//   window.cordova.plugins.Keyboard.close();
//   if (fromBB !== 'backbutton' && isOpen) backbutton.stack.pop();
//   isOpen = false;
// };

// signupModal.view = function() {
//   if (!isOpen) return null;

//   return m('div.modal#signupModal', { config: helper.slidesInUp }, [
//     m('header', [
//       m('button.modal_close[data-icon=L]', {
//         config: helper.ontouch(helper.slidesOutDown(signupModal.close, 'signupModal'))
//       }),
//       m('h2', i18n('signUp'))
//     ]),
//     m('div.modal_content', [
//       m('p.signupWarning.withIcon[data-icon=!]', [
//         i18n('computersAreNotAllowedToPlay')
//       ]),
//       m('p.tosWarning', [
//         i18n('byRegisteringYouAgreeToBeBoundByOur'),
//         m('a', {
//         }, i18n('termsOfService')), '.'
//       ]),
//       m('form.login', {
//         onsubmit: function(e) {
//           e.preventDefault();
//           return submit(e.target);
//         }
//       }, [
//         m('input#pseudo[type=text]', {
//           placeholder: i18n('username'),
//           autocomplete: 'off',
//           autocapitalize: 'off',
//           autocorrect: 'off',
//           spellcheck: 'false',
//           required: true
//         }),
//         m('input#email[type=email]', {
//           placeholder: i18n('email'),
//           autocomplete: 'off',
//           autocapitalize: 'off',
//           autocorrect: 'off',
//           spellcheck: 'false',
//           required: true
//         }),
//         m('input#password[type=password]', {
//           placeholder: i18n('password'),
//           required: true
//         }),
//         m('button.fat', i18n('signUp'))
//       ])
//     ])
//   ]);
// };

// export default signupModal;

},{"../backbutton":135,"../i18n":138,"../router":145,"../session":147,"../socket":150,"../utils/redraw":212,"./helper":157,"./loginModal":162,"./shared/icons":188,"mithril/hyperscript":113}],203:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../helper');

var helper = _interopRequireWildcard(_helper);

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _common = require('../shared/common');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  oncreate: helper.viewFadeIn,
  oninit: function oninit(_ref) {
    var attrs = _ref.attrs;
  },
  view: function view() {
    var body = h(
      'div',
      null,
      (0, _i18n2.default)('underConstruction')
    );

    return _layout2.default.free((0, _common.header)((0, _i18n2.default)('todo')), body, null, null);
  }
};

},{"../../i18n":138,"../helper":157,"../layout":160,"../shared/common":186,"mithril/hyperscript":113}],204:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _userCtrl = require('./userCtrl');

var _userCtrl2 = _interopRequireDefault(_userCtrl);

var _userView = require('./userView');

var _userView2 = _interopRequireDefault(_userView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  controller: _userCtrl2.default,
  view: _userView2.default
};

},{"./userCtrl":205,"./userView":206}],205:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = controller;

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _userXhr = require('./userXhr');

var xhr = _interopRequireWildcard(_userXhr);

var _utils = require('../../utils');

var utils = _interopRequireWildcard(_utils);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _socket = require('../../socket');

var _socket2 = _interopRequireDefault(_socket);

var _mithril = require('mithril');

var _mithril2 = _interopRequireDefault(_mithril);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function controller() {
  _socket2.default.createDefault();

  var user = _mithril2.default.prop();

  xhr.user(_mithril2.default.route.param('id')).then(user, function (error) {
    utils.handleXhrError(error);
    _mithril2.default.route('/');
  }).then(_session2.default.refresh);

  return {
    user: user,
    isMe: function isMe() {
      return _session2.default.getUserId() === user().id;
    }
  };
}

},{"../../session":147,"../../socket":150,"../../utils":210,"../helper":157,"./userXhr":207,"mithril":114}],206:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var h = require('mithril/hyperscript');

exports.default = view;

var _perf = require('../shared/perf');

var _perf2 = _interopRequireDefault(_perf);

var _common = require('../shared/common');

var _layout = require('../layout');

var _layout2 = _interopRequireDefault(_layout);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _helper = require('../helper');

var _helper2 = _interopRequireDefault(_helper);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import userPerfs from '../../oyunkeyf/perfs';
function view(ctrl) {
  var user = ctrl.user();

  if (!user) return null;

  function header() {
    var title = user.username;
    return (0, _common.header)(null, (0, _common.backButton)(title));
  }

  function profile() {
    // TODO
    // stats
    // ratings
    // actions
    return h(
      'div',
      { id: 'userProfile', className: 'native_scroller page' },
      renderStatus(user),
      renderProfile(user),
      renderRatings(user),
      renderActions(ctrl)
    );
  }

  return _layout2.default.free(header, profile);
}

function renderStatus(user) {
  var status = user.online ? 'online' : 'offline';
  return h(
    'section',
    { className: 'onlineStatus' },
    h('span', { className: 'userStatus ' + status, 'data-icon': 'r' }),
    (0, _i18n2.default)(status)
  );
}

function renderProfile(user) {
  if (!user.profile) return null;

  var fullName = '';
  if (user.profile.firstName) fullName += user.profile.firstName;
  if (user.profile.lastName) fullName += (user.profile.firstName ? ' ' : '') + user.profile.lastName;
  // const country = countries[user.profile.country];
  var location = user.profile.location;
  var memberSince = (0, _i18n2.default)('memberSince') + ' ' + window.moment(user.createdAt).format('LL');
  var seenAt = user.seenAt ? (0, _i18n2.default)('lastLogin') + ' ' + window.moment(user.seenAt).calendar() : null;

  return h(
    'section',
    { classname: 'profile' },
    fullName ? h(
      'h3',
      { className: 'fullname' },
      fullName
    ) : null,
    user.profile.bio ? h(
      'p',
      { className: 'profileBio' },
      user.profile.bio
    ) : null,
    h(
      'div',
      { className: 'userInfos' },
      user.language ? h(
        'p',
        { className: 'language withIcon' },
        h(
          'span',
          { className: 'fa fa-comment-o' },
          getLanguageNativeName(user.language)
        )
      ) : null,
      h(
        'p',
        { className: 'location' },
        location
      ),
      h(
        'p',
        { className: 'memberSince' },
        memberSince
      ),
      seenAt ? h(
        'p',
        { className: 'lastSeen' },
        seenAt
      ) : null
    )
  );
}

function renderRatings(user) {
  function isShowing(p) {
    return ['yuzbir', 'duzokey'].indexOf(p.key) !== -1 || p.perf.games > 0;
  }

  return h(
    'section',
    { id: 'userProfileRatings', className: 'perfs' },
    '// ',
    userPerfs(user).filter(isShowing).map(function (p) {
      return (0, _perf2.default)(p.key, p.name, p.perf, user);
    })
  );
}

function renderActions(ctrl) {
  var user = ctrl.user();
  return h(
    'section',
    { id: 'userProfileActions', 'class': 'noPadding' },
    h(
      'div',
      { className: 'list_item_nav',
        config: _helper2.default.ontouchY(ctrl.goToGames),
        key: 'view_all_games' },
      (0, _i18n2.default)('viewAllNbGames', user.count.all)
    )
  );
}

},{"../../i18n":138,"../../session":147,"../helper":157,"../layout":160,"../shared/common":186,"../shared/perf":190,"mithril/hyperscript":113}],207:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.user = user;

var _http = require('../../http');

function user(id) {
  var url = '/api/user/' + id;
  return (0, _http.request)(url, {}, true);
}

},{"../../http":137}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForeground = isForeground;
exports.setForeground = setForeground;
exports.setBackground = setBackground;
var foreground = true;

function isForeground() {
  return foreground;
}

function setForeground() {
  foreground = true;
}

function setBackground() {
  foreground = false;
}

},{}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.batchRequestAnimationFrame = batchRequestAnimationFrame;
var callbacks = new Set();
var batching = false;

function batchRequestAnimationFrame(callback) {
  callbacks.add(callback);
  if (!batching) {
    batching = true;
    requestAnimationFrame(function (ts) {
      var batch = callbacks;
      batching = false;
      callbacks = new Set();
      batch.forEach(function (f) {
        return f(ts);
      });
    });
  }
}

},{}],210:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.oyunkeyfSri = undefined;
exports.autoredraw = autoredraw;
exports.noop = noop;
exports.handleXhrError = handleXhrError;
exports.loadLocalJsonFile = loadLocalJsonFile;
exports.currentSri = currentSri;
exports.newSri = newSri;
exports.tellWorker = tellWorker;
exports.askWorker = askWorker;
exports.hasNetwork = hasNetwork;
exports.partialf = partialf;
exports.f = f;
exports.playerName = playerName;
exports.aiName = aiName;
exports.backHistory = backHistory;
exports.setViewSlideDirection = setViewSlideDirection;
exports.getViewSlideDirection = getViewSlideDirection;
exports.getBoardBounds = getBoardBounds;
exports.gameIcon = gameIcon;
exports.formatMasaDuration = formatMasaDuration;
exports.pad = pad;
exports.capitalize = capitalize;
exports.safeStringToNum = safeStringToNum;

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _redraw = require('./redraw');

var _redraw2 = _interopRequireDefault(_redraw);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function autoredraw(action) {
  var res = action();
  (0, _redraw2.default)();
  return res;
}

function noop() {}

function handleXhrError(error) {
  var status = error.status;
  var data = error.body;
  var message = void 0;

  if (!status || status === 0) {
    message = 'oyunkeyfIsUnreachable';
  } else if (status === 401) {
    message = 'unauthorizedError';
  } else if (status === 404) {
    message = 'resourceNotFoundError';
  } else if (status === 503) {
    message = 'oyunkeyfIsUnavailableError';
  } else {
    message = 'Error.';
  }

  message = (0, _i18n2.default)(message);

  if (typeof data === 'string') {
    message += ' ' + data;
  } else if (typeof data.error === 'string') {
    message += ' ' + (0, _i18n2.default)(data.global[0]);
  }
  window.plugins.toast.show(message, 'short', 'center');
}

function loadLocalJsonFile(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.overrideMimeType('application/json');
    xhr.open('GET', url, true);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if ((xhr.status === 0 || xhr.status === 200) && xhr.responseText !== '') {
          resolve(JSON.parse(xhr.responseText));
        } else {
          reject(xhr);
        }
      }
    };
    xhr.send(null);
  });
}

var sri = void 0;

function currentSri() {
  return sri || newSri();
}

function newSri() {
  sri = Math.random().toString(36).substring(2).slice(0, 10);
  return sri;
}

var oyunkeyfSri = exports.oyunkeyfSri = Math.random().toString(36).substring(2);

function tellWorker(worker, topic, payload) {
  if (payload !== undefined) {
    worker.postMessage({ topic: topic, payload: payload });
  } else {
    worker.postMessage({ topic: topic });
  }
}

function askWorker(worker, msg, callback) {
  return new Promise(function (resolve) {
    function listen(e) {
      if (e.data.topic === msg.topic) {
        worker.removeEventListener('message', listen);
        if (callback) {
          callback(e.data.payload);
        } else {
          resolve(e.data.payload);
        }
      }
    }
    worker.addEventListener('message', listen);
    worker.postMessage(msg);
  });
}

function hasNetwork() {
  return window.navigator.connection.type !== Connection.NONE;
}

// export function handleXhrError(error) {
//   var {response: data, status} = error;
//   if (!hasNetwork()) {
//     window.plugins.toast.show(i18n('noInternetConnection'), 'short', 'center');
//   } else {
//     let message;
//     if (!status || status === 0) {
//       message = 'oyunkeyfIsUnreachable';
//     } else if (status === 401) {
//       message = 'unauthorizedError';
//     } else if (status === 404) {
//       message = 'resourceNotFoundError';
//     } else if (status === 503) {
//       message = 'oyunkeyfIsUnavailableError';
//     } else if (status >= 500) {
//       message = 'serverError';
//     } else {
//       message = 'Error.';
//     }

//     message = i18n(message);

//     if (typeof data === 'string') {
//       message += ` ${data}`;
//     } else if (data.global && data.global.constructor === Array) {
//       message += ` ${data.global[0]}`;
//     } else if (typeof data.error === 'string') {
//       message += ` ${data.error}`;
//     }

//     window.plugins.toast.show(message, 'short', 'center');
//   }
// }

function partialApply(fn, args) {
  return fn.bind.apply(fn, [null].concat(args));
}

function partialf() {
  return partialApply(arguments[0], Array.prototype.slice.call(arguments, 1));
}

function f() {
  var args = arguments,
      fn = arguments[0];
  return function () {
    fn.apply(fn, Array.prototype.slice.call(args, 1));
  };
}

function playerName(player, withRating) {
  if (player.username || player.user) {
    var name = player.username || player.user.username;
    return name;
  }
  if (player.ai) {
    return aiName(player.ai);
  }

  if (player.side) {
    return (0, _i18n2.default)(player.side);
  }

  return (0, _i18n2.default)('anonymous');
}

function aiName(level) {
  return (0, _i18n2.default)('aiBot', level);
}

function backHistory() {
  setViewSlideDirection('bwd');
  if (window.navigator.app && window.navigator.app.backHistory) {
    window.navigator.app.backHistory();
  } else window.history.go(-1);
}

// simple way to determine views animation direction
var viewSlideDirection = 'fwd';
function setViewSlideDirection(d) {
  viewSlideDirection = d;
}
function getViewSlideDirection() {
  return viewSlideDirection;
}

function getBoardBounds(viewportDim, isPortrait, isIpadLike, mode) {
  var vh = viewportDim.vh,
      vw = viewportDim.vw;

  var top = 50;

  if (isPortrait) {
    // const contentHeight = vh - 50;
    // const pTop = 50 + (mode === 'game' ? ((contentHeight - vw - 40) / 2) : 0);
    var contentHeight = vh;
    var pTop = 0;
    return {
      top: pTop,
      right: vw,
      bottom: pTop + vw,
      left: 0,
      width: vw,
      height: vw
    };
  } else {
    // const lSide = vh - top;
    var lSide = vh - 5;
    var lWidth = vw - 5; // lSide * (4/3);
    var spaceCenter = vw - lWidth;
    return {
      top: top,
      right: lSide,
      bottom: top + lSide,
      left: spaceCenter / 2,
      width: lWidth,
      height: lSide
    };
  }
}

// export function autoredraw(action) {
//   m.startComputation();
//   try {
//     return action();
//   } finally {
//     m.endComputation();
//   }
// }

var perfIconsMap = {
  yuzbir: 'T',
  duzokey: '+'
};

function gameIcon(perf) {
  return perfIconsMap[perf] || '8';
}

function formatMasaDuration(rounds, scores) {
  return rounds ? rounds + (0, _i18n2.default)('hands') : scores + (0, _i18n2.default)('scores')[0];
}

function pad(num, size) {
  var s = num + '';
  while (s.length < size) {
    s = '0' + s;
  }return s;
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function safeStringToNum(s) {
  var n = Number(s);
  return isNaN(n) ? undefined : n;
}

},{"../i18n":138,"./redraw":212}],211:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.buildQueryString = buildQueryString;
// from https://github.com/Gozala/querystring

function stringifyPrimitive(v) {
  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
}

function buildQueryString(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}

},{}],212:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.redrawSync = undefined;
exports.default = redraw;

var _signals = require('../signals');

var _signals2 = _interopRequireDefault(_signals);

var _batchRAF = require('./batchRAF');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var redrawSync = exports.redrawSync = _signals2.default.redraw.dispatch;

function redraw() {
  // console.trace();
  (0, _batchRAF.batchRequestAnimationFrame)(redrawSync);
}

},{"../signals":149,"./batchRAF":209}],213:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keepAwake = keepAwake;
exports.allowSleepAgain = allowSleepAgain;
var IDLE_TIMER_DELAY = 15 * 60 * 1000;
var SLEEP_DELAY = 60 * 60 * 1000;

var sleepAgainTimeoutId = void 0;
var cancelTimer = void 0;

function keepAwake() {
  window.plugins.insomnia.keepAwake();
  if (cancelTimer !== undefined) {
    cancelTimer();
  }
  cancelTimer = idleTimer(IDLE_TIMER_DELAY, function () {
    sleepAgainTimeoutId = setTimeout(function () {
      window.plugins.insomnia.allowSleepAgain();
    }, SLEEP_DELAY);
  }, function () {
    clearTimeout(sleepAgainTimeoutId);
  });
}

function allowSleepAgain() {
  if (cancelTimer !== undefined) {
    cancelTimer();
    cancelTimer = undefined;
  }
  window.plugins.insomnia.allowSleepAgain();
}

function idleTimer(delay, onIdle, onWakeUp) {
  var events = ['touchstart'];
  var listening = false;
  var active = true;
  var lastSeenActive = Date.now();
  var intervalID = void 0;
  var onActivity = function onActivity() {
    if (!active) {
      // console.log('Wake up')
      onWakeUp();
    }
    active = true;
    lastSeenActive = Date.now();
    stopListening();
  };
  var startListening = function startListening() {
    if (!listening) {
      events.forEach(function (e) {
        document.addEventListener(e, onActivity);
      });
      listening = true;
    }
  };
  var stopListening = function stopListening() {
    if (listening) {
      events.forEach(function (e) {
        document.removeEventListener(e, onActivity);
      });
      listening = false;
    }
  };
  var cancel = function cancel() {
    clearInterval(intervalID);
    stopListening();
  };
  intervalID = setInterval(function () {
    if (active && Date.now() - lastSeenActive > delay) {
      // console.log('Idle mode')
      onIdle();
      active = false;
    }
    startListening();
  }, 30 * 1000);

  return cancel;
}

},{}],214:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tellWorker = tellWorker;
exports.askWorker = askWorker;
function tellWorker(worker, topic, payload) {
  if (payload !== undefined) {
    worker.postMessage({ topic: topic, payload: payload });
  } else {
    worker.postMessage({ topic: topic });
  }
}

function askWorker(worker, msg) {
  return new Promise(function (resolve, reject) {
    function listen(e) {
      if (e.data.topic === msg.topic && (msg.reqid === undefined || e.data.reqid === msg.reqid)) {
        worker.removeEventListener('message', listen);
        resolve(e.data.payload);
      } else if (e.data.topic === 'error' && e.data.payload.callerTopic === msg.topic && (msg.reqid === undefined || e.data.reqid === msg.reqid)) {
        worker.removeEventListener('message', listen);
        reject(e.data.payload.error);
      }
    }
    worker.addEventListener('message', listen);
    worker.postMessage(msg);
  });
}

},{}],215:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.game = game;
exports.seekGame = seekGame;
exports.setServerLang = setServerLang;

var _http = require('./http');

var _utils = require('./utils');

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// export let cachedPools = [];

// export function newGame() {
//   const config = settings.gameSetup.human;

//   const data = {
//     variant: config.variant(),
//     rounds: config.rounds(),
//     mode: session.isConnected() ? config.mode() : '0',
//     membersOnly: session.isConnected() ? config.membersOnly() : false
//   };

//   return request('/masa/new', {
//     method: 'POST',
//     data
//   }, true);
// }

// export function lobby(feedback) {
//   return request('/', null, feedback);
// }

// export function game(id, background) {
//   var url = '/' + id;
//   return request(url, { background }, true);
// }

function game(id) {
  var url = '/' + id;
  return (0, _http.fetchJSON)(url);
}

function seekGame(setup) {
  var rest = _objectWithoutProperties(setup, []);

  var body = void 0;

  body = JSON.stringify(_extends({}, rest));

  return (0, _http.fetchJSON)('/masa/new', {
    method: 'POST',
    body: body
  }, true);
}

function setServerLang(lang) {
  if (_session2.default.isConnected()) {
    // return request('/translation/select', {
    //   method: 'POST',
    //   data: { lang }
    // });
    return Promise.resolve();
  } else {
    return Promise.resolve();
  }
}

},{"./http":137,"./session":147,"./settings":148,"./utils":210}]},{},[139])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9va2V5Z3JvdW5kL2J1aWxkL25vZGVfbW9kdWxlcy9va2V5Z3JvdW5kLW1vYmlsZS9idWlsZC9va2V5Z3JvdW5kLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2NvbnZlcnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qc29uIiwibm9kZV9tb2R1bGVzL2NvbG9yLXN0cmluZy9jb2xvci1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29sb3IvY29sb3IuanMiLCJub2RlX21vZHVsZXMvaXNjcm9sbC9idWlsZC9pc2Nyb2xsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJhbmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVJhbmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaFNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvbm93LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90aHJvdHRsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvaHlwZXJzY3JpcHQuanMiLCJub2RlX21vZHVsZXMvbWl0aHJpbC9taXRocmlsLmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyLmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL2ZyYWdtZW50LmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL2h5cGVyc2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL21pdGhyaWwvcmVuZGVyL3JlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci90cnVzdC5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3JlbmRlci92bm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9taXRocmlsL3N0cmVhbS9zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcS9xLmpzIiwibm9kZV9tb2R1bGVzL3FhbmltYXRpb25mcmFtZS9zcmMvcWFuaW1hdGlvbmZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL3JsaXRlLXJvdXRlci9ybGl0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxzL2Rpc3Qvc2lnbmFscy5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3ZlbmRvci1wcmVmaXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvemFuaW1vL3NyYy9aYW5pbW8uanMiLCJub2RlX21vZHVsZXMvemFuaW1vL3NyYy9ub3JtYWxpemUtdGltaW5nLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3phbmltby9zcmMvbm9ybWFsaXplLXRyYW5zZm9ybS12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy96YW5pbW8vc3JjL3RyYW5zaXRpb24tc2hvcnRoYW5kLXByb3BlcnR5LmpzIiwic3JjL2JhY2tidXR0b24uanMiLCJzcmMvY29uZmlnLmpzIiwic3JjL2h0dHAuanMiLCJzcmMvaTE4bi5qcyIsInNyYy9tYWluLmpzIiwic3JjL295dW5rZXlmL2dhbWUuanMiLCJzcmMvb3l1bmtleWYvcGxheWVyLmpzIiwic3JjL295dW5rZXlmL3NldHVwLmpzIiwic3JjL295dW5rZXlmL3N0YXR1cy5qcyIsInNyYy9veXVua2V5Zi92YXJpYW50LmpzIiwic3JjL3JvdXRlci5qcyIsInNyYy9yb3V0ZXMuanMiLCJzcmMvc2Vzc2lvbi5qcyIsInNyYy9zZXR0aW5ncy5qcyIsInNyYy9zaWduYWxzLmpzIiwic3JjL3NvY2tldC5qcyIsInNyYy9zcGlubmVyLmpzIiwic3JjL3N0b3JhZ2UuanMiLCJzcmMvdWkvZ2FtZS9pbmRleC5qcyIsInNyYy91aS9nYW1lc01lbnUuanMiLCJzcmMvdWkvaGVscGVyL2FuaW1hdG9yLmpzIiwic3JjL3VpL2hlbHBlci9idXR0b24uanMiLCJzcmMvdWkvaGVscGVyL2luZGV4LmpzIiwic3JjL3VpL2hvbWUvaG9tZVZpZXcuanMiLCJzcmMvdWkvaG9tZS9pbmRleC5qcyIsInNyYy91aS9sYXlvdXQuanMiLCJzcmMvdWkvbG9iYnkuanMiLCJzcmMvdWkvbG9naW5Nb2RhbC5qcyIsInNyYy91aS9tYXNhL01hc2FzTGlzdEN0cmwuanMiLCJzcmMvdWkvbWFzYS9kZXRhaWwvTWFzYUN0cmwuanMiLCJzcmMvdWkvbWFzYS9kZXRhaWwvaW5kZXguanMiLCJzcmMvdWkvbWFzYS9kZXRhaWwvbWFzYVZpZXcuanMiLCJzcmMvdWkvbWFzYS9kZXRhaWwvc29ja2V0SGFuZGxlci5qcyIsInNyYy91aS9tYXNhL2ZhcS5qcyIsInNyYy91aS9tYXNhL2luZGV4LmpzIiwic3JjL3VpL21hc2EvbWFzYVhoci5qcyIsInNyYy91aS9tYXNhL21hc2FzTGlzdFZpZXcuanMiLCJzcmMvdWkvbWVudS9pbmRleC5qcyIsInNyYy91aS9tZW51L21lbnVWaWV3LmpzIiwic3JjL3VpL25ld0dhbWVGb3JtLmpzIiwic3JjL3VpL3BsYXllcnMvaW5kZXguanMiLCJzcmMvdWkvcGxheWVycy9wbGF5ZXJYaHIuanMiLCJzcmMvdWkvcGxheWVycy9wbGF5ZXJzQ3RybC5qcyIsInNyYy91aS9wbGF5ZXJzL3BsYXllcnNWaWV3LmpzIiwic3JjL3VpL3NldHRpbmdzL2luZGV4LmpzIiwic3JjL3VpL3NldHRpbmdzL2xhbmcuanN4Iiwic3JjL3VpL3NoYXJlZC9Cb2FyZC5qcyIsInNyYy91aS9zaGFyZWQvR2FtZVRpdGxlLmpzIiwic3JjL3VpL3NoYXJlZC9UYWJOYXZpZ2F0aW9uLmpzIiwic3JjL3VpL3NoYXJlZC9UYWJWaWV3LmpzIiwic3JjL3VpL3NoYXJlZC9WaWV3T25seUJvYXJkLmpzIiwic3JjL3VpL3NoYXJlZC9jb21tb24uanMiLCJzcmMvdWkvc2hhcmVkL2Zvcm0uanMiLCJzcmMvdWkvc2hhcmVkL2ljb25zLmpzIiwic3JjL3VpL3NoYXJlZC9sYXlvdXQvTWFpbkJvYXJkLmpzIiwic3JjL3VpL3NoYXJlZC9wZXJmLmpzIiwic3JjL3VpL3NoYXJlZC9wb3B1cC5qcyIsInNyYy91aS9zaGFyZWQvcm91bmQvT25saW5lUm91bmQuanMiLCJzcmMvdWkvc2hhcmVkL3JvdW5kL2Nsb2NrL0Nsb2NrQ3RybC5qcyIsInNyYy91aS9zaGFyZWQvcm91bmQvY2xvY2svY2xvY2tWaWV3LmpzIiwic3JjL3VpL3NoYXJlZC9yb3VuZC9ncm91bmQuanMiLCJzcmMvdWkvc2hhcmVkL3JvdW5kL3JvdW5kWGhyLmpzIiwic3JjL3VpL3NoYXJlZC9yb3VuZC9zb2NrZXRIYW5kbGVyLmpzIiwic3JjL3VpL3NoYXJlZC9yb3VuZC92aWV3L2J1dHRvbi5qcyIsInNyYy91aS9zaGFyZWQvcm91bmQvdmlldy9yb3VuZFZpZXcuanMiLCJzcmMvdWkvc2hhcmVkL3NpZGVNZW51L1NpZGVNZW51Q3RybC5qcyIsInNyYy91aS9zaGFyZWQvc2lkZU1lbnUvaW5kZXguanMiLCJzcmMvdWkvc2lnbnVwTW9kYWwuanMiLCJzcmMvdWkvdG9kby9pbmRleC5qcyIsInNyYy91aS91c2VyL2luZGV4LmpzIiwic3JjL3VpL3VzZXIvdXNlckN0cmwuanMiLCJzcmMvdWkvdXNlci91c2VyVmlldy5qcyIsInNyYy91aS91c2VyL3VzZXJYaHIuanMiLCJzcmMvdXRpbHMvYXBwTW9kZS5qcyIsInNyYy91dGlscy9iYXRjaFJBRi5qcyIsInNyYy91dGlscy9pbmRleC5qcyIsInNyYy91dGlscy9xdWVyeXN0cmluZy5qcyIsInNyYy91dGlscy9yZWRyYXcuanMiLCJzcmMvdXRpbHMvc2xlZXAuanMiLCJzcmMvdXRpbHMvd29ya2VyLmpzIiwic3JjL3hoci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2lFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4dUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMS9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDajVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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U0FBUyxJQUFULENBQWMsRUFBZCxFQUFrQjtBQUN2QixNQUFJLE1BQU0sTUFBTSxFQUFoQjtBQUNBLFNBQU8scUJBQVUsR0FBVixDQUFQO0FBQ0Q7O0FBRU0sU0FBUyxRQUFULENBQWtCLEtBQWxCLEVBQXlCO0FBQUEsTUFDbkIsSUFEbUIsNEJBQ1YsS0FEVTs7QUFHOUIsTUFBSSxhQUFKOztBQUVBLFNBQU8sS0FBSyxTQUFMLGNBQW9CLElBQXBCLEVBQVA7O0FBRUEsU0FBTyxxQkFBVSxXQUFWLEVBQXVCO0FBQzVCLFlBQVEsTUFEb0I7QUFFNUI7QUFGNEIsR0FBdkIsRUFHSixJQUhJLENBQVA7QUFJRDs7QUFFTSxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkI7QUFDbEMsTUFBSSxrQkFBUSxXQUFSLEVBQUosRUFBMkI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPLFFBQVEsT0FBUixFQUFQO0FBQ0QsR0FORCxNQU1PO0FBQ0wsV0FBTyxRQUFRLE9BQVIsRUFBUDtBQUNEO0FBQ0YiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciB0O3Q9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLHQuT2tleWdyb3VuZD1lKCl9fShmdW5jdGlvbigpe3ZhciBlO3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIGEobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIXUmJmwpcmV0dXJuIGwobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGQuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixkfXZhciBzPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChzLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gYShufHxlKX0scyxzLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c31mb3IodmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxvPTA7bzxyLmxlbmd0aDtvKyspYShyW29dKTtyZXR1cm4gYX1yZXR1cm4gZX0oKSh7MTpbZnVuY3Rpb24oZSx0LG4peyFmdW5jdGlvbihlKXtmdW5jdGlvbiBuKGUsdCl7aWYoXCJvYmplY3RcIiE9PWEoZSkpcmV0dXJuIHQ7Zm9yKHZhciByIGluIHQpXCJvYmplY3RcIj09PWEoZVtyXSkmJlwib2JqZWN0XCI9PT1hKHRbcl0pP2Vbcl09bihlW3JdLHRbcl0pOmVbcl09dFtyXTtyZXR1cm4gZX1mdW5jdGlvbiByKGUsdCxyKXt2YXIgbz1yWzBdLHU9ci5sZW5ndGg7KGV8fFwib2JqZWN0XCIhPT1hKG8pKSYmKG89e30pO2Zvcih2YXIgbD0wO2w8dTsrK2wpe3ZhciBkPXJbbF0scz1hKGQpO2lmKFwib2JqZWN0XCI9PT1zKWZvcih2YXIgYyBpbiBkKWlmKFwiX19wcm90b19fXCIhPT1jKXt2YXIgZj1lP2kuY2xvbmUoZFtjXSk6ZFtjXTt0P29bY109bihvW2NdLGYpOm9bY109Zn19cmV0dXJuIG99ZnVuY3Rpb24gYShlKXtyZXR1cm57fS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpLnRvTG93ZXJDYXNlKCl9dmFyIGk9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZT09PSEwLCExLGFyZ3VtZW50cyl9LG89XCJtZXJnZVwiO2kucmVjdXJzaXZlPWZ1bmN0aW9uKGUpe3JldHVybiByKGU9PT0hMCwhMCxhcmd1bWVudHMpfSxpLmNsb25lPWZ1bmN0aW9uKGUpe3ZhciB0LG4scj1lLG89YShlKTtpZihcImFycmF5XCI9PT1vKWZvcihyPVtdLG49ZS5sZW5ndGgsdD0wO3Q8bjsrK3Qpclt0XT1pLmNsb25lKGVbdF0pO2Vsc2UgaWYoXCJvYmplY3RcIj09PW8pe3I9e307Zm9yKHQgaW4gZSlyW3RdPWkuY2xvbmUoZVt0XSl9cmV0dXJuIHJ9LGU/dC5leHBvcnRzPWk6d2luZG93W29dPWl9KFwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZcIm9iamVjdFwiPT10eXBlb2YgdC5leHBvcnRzJiZ0LmV4cG9ydHMpfSx7fV0sMjpbZnVuY3Rpb24odCxuLHIpeyFmdW5jdGlvbih0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXIodCk7XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyYmYS5kZXBzKHtkb2N1bWVudDpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQ6e30sbG9jYXRpb246XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGxvY2F0aW9uP2xvY2F0aW9uOnt9LGNsZWFyVGltZW91dDpjbGVhclRpbWVvdXQsc2V0VGltZW91dDpzZXRUaW1lb3V0fSksXCJvYmplY3RcIj09dHlwZW9mIG4mJm51bGwhPW4mJm4uZXhwb3J0cz9uLmV4cG9ydHM9YTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLmFtZD9lKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTp0Lm09YX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dGhpcyxmdW5jdGlvbiBhKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlfWZ1bmN0aW9uIHIoZSl7cmV0dXJuXCJbb2JqZWN0IE9iamVjdF1cIj09PUtlLmNhbGwoZSl9ZnVuY3Rpb24gaShlKXtyZXR1cm5cIltvYmplY3QgU3RyaW5nXVwiPT09S2UuY2FsbChlKX1mdW5jdGlvbiBvKCl7fWZ1bmN0aW9uIHUoZSl7eGU9ZS5kb2N1bWVudCxTZT1lLmxvY2F0aW9uLE1lPWUuY2FuY2VsQW5pbWF0aW9uRnJhbWV8fGUuY2xlYXJUaW1lb3V0LEVlPWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxlLnNldFRpbWVvdXR9ZnVuY3Rpb24gbChlLHQpe2Zvcih2YXIgbixyPVtdLGE9Lyg/OihefCN8XFwuKShbXiNcXC5cXFtcXF1dKykpfChcXFsoLis/KSg/Olxccyo9XFxzKihcInwnfCkoKD86XFxcXFtcIidcXF1dfC4pKj8pXFw1KT9cXF0pL2c7bj1hLmV4ZWModCk7KWlmKFwiXCI9PT1uWzFdJiZuWzJdKWUudGFnPW5bMl07ZWxzZSBpZihcIiNcIj09PW5bMV0pZS5hdHRycy5pZD1uWzJdO2Vsc2UgaWYoXCIuXCI9PT1uWzFdKXIucHVzaChuWzJdKTtlbHNlIGlmKFwiW1wiPT09blszXS5jaGFyQXQoMCkpe3ZhciBpPW5bNl07aSYmKGk9aS5yZXBsYWNlKC9cXFxcKFtcIiddKS9nLFwiJDFcIikpLFwiY2xhc3NcIj09PW5bNF0/ci5wdXNoKGkpOmUuYXR0cnNbbls0XV09aXx8ITB9cmV0dXJuIHJ9ZnVuY3Rpb24gZChlLHQpe3ZhciBuPXQ/ZS5zbGljZSgxKTplO3JldHVybiAxPT09bi5sZW5ndGgmJlRlKG5bMF0pP25bMF06bn1mdW5jdGlvbiBzKGUsdCxuKXt2YXIgcj1cImNsYXNzXCJpbiB0P1wiY2xhc3NcIjpcImNsYXNzTmFtZVwiO2Zvcih2YXIgYSBpbiB0KUNlLmNhbGwodCxhKSYmKGE9PT1yJiZudWxsIT10W2FdJiZcIlwiIT09dFthXT8obi5wdXNoKHRbYV0pLGVbYV09XCJcIik6ZVthXT10W2FdKTtuLmxlbmd0aCYmKGVbcl09bi5qb2luKFwiIFwiKSl9ZnVuY3Rpb24gYyhlLHQpe2Zvcih2YXIgYT1bXSxvPTEsdT1hcmd1bWVudHMubGVuZ3RoO288dTtvKyspYVtvLTFdPWFyZ3VtZW50c1tvXTtpZihlJiZuKGUudmlldykpcmV0dXJuIGFlKGUsYSk7aWYoIWkoZSkpdGhyb3cgbmV3IEVycm9yKFwic2VsZWN0b3IgaW4gbShzZWxlY3RvciwgYXR0cnMsIGNoaWxkcmVuKSBzaG91bGQgYmUgYSBzdHJpbmdcIik7dmFyIGM9bnVsbCE9dCYmcih0KSYmIShcInRhZ1wiaW4gdHx8XCJ2aWV3XCJpbiB0fHxcInN1YnRyZWVcImluIHQpLGY9Yz90Ont9LHA9e3RhZzpcImRpdlwiLGF0dHJzOnt9LGNoaWxkcmVuOmQoYSxjKX07cmV0dXJuIHMocC5hdHRycyxmLGwocCxlKSkscH1mdW5jdGlvbiBmKGUsdCl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aCYmIXQoZVtuXSxuKyspOyk7fWZ1bmN0aW9uIHAoZSx0KXtmKGUsZnVuY3Rpb24oZSxuKXtyZXR1cm4oZT1lJiZlLmF0dHJzKSYmbnVsbCE9ZS5rZXkmJnQoZSxuKX0pfWZ1bmN0aW9uIHYoZSl7dHJ5e2lmKFwiYm9vbGVhblwiIT10eXBlb2YgZSYmbnVsbCE9ZSYmbnVsbCE9ZS50b1N0cmluZygpKXJldHVybiBlfWNhdGNoKHQpe31yZXR1cm5cIlwifWZ1bmN0aW9uIG0oZSx0LG4scil7dHJ5e2goZSx0LG4pLHQubm9kZVZhbHVlPXJ9Y2F0Y2goYSl7fX1mdW5jdGlvbiBnKGUpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKVRlKGVbdF0pJiYoZT1lLmNvbmNhdC5hcHBseShbXSxlKSx0LS0pO3JldHVybiBlfWZ1bmN0aW9uIGgoZSx0LG4pe2UuaW5zZXJ0QmVmb3JlKHQsZS5jaGlsZE5vZGVzW25dfHxudWxsKX1mdW5jdGlvbiB5KGUsdCxuLHIpe3AoZSxmdW5jdGlvbihlLHIpe3RbZT1lLmtleV09dFtlXT97YWN0aW9uOmplLGluZGV4OnIsZnJvbTp0W2VdLmluZGV4LGVsZW1lbnQ6bi5ub2Rlc1t0W2VdLmluZGV4XXx8eGUuY3JlYXRlRWxlbWVudChcImRpdlwiKX06e2FjdGlvbjpCZSxpbmRleDpyfX0pO3ZhciBhPVtdO2Zvcih2YXIgaSBpbiB0KUNlLmNhbGwodCxpKSYmYS5wdXNoKHRbaV0pO3ZhciBvPWEuc29ydChxKSx1PW5ldyBBcnJheShuLmxlbmd0aCk7cmV0dXJuIHUubm9kZXM9bi5ub2Rlcy5zbGljZSgpLGYobyxmdW5jdGlvbih0KXt2YXIgYT10LmluZGV4O2lmKHQuYWN0aW9uPT09RGUmJihWKG5bYV0ubm9kZXMsblthXSksdS5zcGxpY2UoYSwxKSksdC5hY3Rpb249PT1CZSl7dmFyIGk9eGUuY3JlYXRlRWxlbWVudChcImRpdlwiKTtpLmtleT1lW2FdLmF0dHJzLmtleSxoKHIsaSxhKSx1LnNwbGljZShhLDAse2F0dHJzOntrZXk6ZVthXS5hdHRycy5rZXl9LG5vZGVzOltpXX0pLHUubm9kZXNbYV09aX1pZih0LmFjdGlvbj09PWplKXt2YXIgbz10LmVsZW1lbnQsbD1yLmNoaWxkTm9kZXNbYV07bCE9PW8mJm51bGwhPT1vJiZyLmluc2VydEJlZm9yZShvLGx8fG51bGwpLHVbYV09blt0LmZyb21dLHUubm9kZXNbYV09b319KSx1fWZ1bmN0aW9uIHcoZSx0LG4scil7dmFyIGE9ZS5sZW5ndGghPT10Lmxlbmd0aDtyZXR1cm4gYXx8cChlLGZ1bmN0aW9uKGUsbil7dmFyIHI9dFtuXTtyZXR1cm4gYT1yJiZyLmF0dHJzJiZyLmF0dHJzLmtleSE9PWUua2V5fSksYT95KGUsbix0LHIpOnR9ZnVuY3Rpb24gYihlLHQsbil7ZihlLGZ1bmN0aW9uKGUscil7bnVsbCE9dFtyXSYmbi5wdXNoLmFwcGx5KG4sdFtyXS5ub2Rlcyl9KSxmKHQubm9kZXMsZnVuY3Rpb24oZSxyKXtudWxsIT1lLnBhcmVudE5vZGUmJm4uaW5kZXhPZihlKTwwJiZWKFtlXSxbdFtyXV0pfSksZS5sZW5ndGg8dC5sZW5ndGgmJih0Lmxlbmd0aD1lLmxlbmd0aCksdC5ub2Rlcz1ufWZ1bmN0aW9uIFAoZSl7dmFyIHQ9MDtwKGUsZnVuY3Rpb24oKXtyZXR1cm4gZihlLGZ1bmN0aW9uKGUpeyhlPWUmJmUuYXR0cnMpJiZudWxsPT1lLmtleSYmKGUua2V5PVwiX19taXRocmlsX19cIit0KyspfSksMX0pfWZ1bmN0aW9uIGsoZSx0LG4pe3JldHVybiBlLnRhZyE9PXQudGFnfHwobi5zb3J0KCkuam9pbigpIT09T2JqZWN0LmtleXModC5hdHRycykuc29ydCgpLmpvaW4oKXx8KGUuYXR0cnMuaWQhPT10LmF0dHJzLmlkfHwoZS5hdHRycy5rZXkhPT10LmF0dHJzLmtleXx8KFwiYWxsXCI9PT1jLnJlZHJhdy5zdHJhdGVneSgpPyF0LmNvbmZpZ0NvbnRleHR8fHQuY29uZmlnQ29udGV4dC5yZXRhaW4hPT0hMDpcImRpZmZcIj09PWMucmVkcmF3LnN0cmF0ZWd5KCkmJih0LmNvbmZpZ0NvbnRleHQmJnQuY29uZmlnQ29udGV4dC5yZXRhaW49PT0hMSkpKSkpfWZ1bmN0aW9uIE8oZSx0LHIpe2soZSx0LHIpJiYodC5ub2Rlcy5sZW5ndGgmJlYodC5ub2RlcyksdC5jb25maWdDb250ZXh0JiZuKHQuY29uZmlnQ29udGV4dC5vbnVubG9hZCkmJnQuY29uZmlnQ29udGV4dC5vbnVubG9hZCgpLHQuY29udHJvbGxlcnMmJmYodC5jb250cm9sbGVycyxmdW5jdGlvbihlKXtlLm9udW5sb2FkJiZlLm9udW5sb2FkKHtwcmV2ZW50RGVmYXVsdDpvfSl9KSl9ZnVuY3Rpb24geChlLHQpe3JldHVybiBlLmF0dHJzLnhtbG5zP2UuYXR0cnMueG1sbnM6XCJzdmdcIj09PWUudGFnP1wiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjpcIm1hdGhcIj09PWUudGFnP1wiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiOnR9ZnVuY3Rpb24gUyhlLHQsbil7bi5sZW5ndGgmJihlLnZpZXdzPXQsZS5jb250cm9sbGVycz1uLGYobixmdW5jdGlvbihlKXtpZihlLm9udW5sb2FkJiZlLm9udW5sb2FkLiRvbGQmJihlLm9udW5sb2FkPWUub251bmxvYWQuJG9sZCksUmUmJmUub251bmxvYWQpe3ZhciB0PWUub251bmxvYWQ7ZS5vbnVubG9hZD1mdW5jdGlvbigpe30sZS5vbnVubG9hZC4kb2xkPXR9fSkpfWZ1bmN0aW9uIEUoZSx0LHIsYSxpKXtpZihuKHQuYXR0cnMuY29uZmlnKSl7dmFyIG89aS5jb25maWdDb250ZXh0PWkuY29uZmlnQ29udGV4dHx8e307ZS5wdXNoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXR0cnMuY29uZmlnLmNhbGwodCxyLCFhLG8saSl9KX19ZnVuY3Rpb24gTShlLG4scixhLGksbyx1LGwpe3ZhciBkPWUubm9kZXNbMF07cmV0dXJuIGEmJkooZCxuLnRhZyxuLmF0dHJzLGUuYXR0cnMsaSksZS5jaGlsZHJlbj1VKGQsbi50YWcsdCx0LG4uY2hpbGRyZW4sZS5jaGlsZHJlbiwhMSwwLG4uYXR0cnMuY29udGVudGVkaXRhYmxlP2Q6cixpLHUpLGUubm9kZXMuaW50YWN0PSEwLGwubGVuZ3RoJiYoZS52aWV3cz1vLGUuY29udHJvbGxlcnM9bCksZH1mdW5jdGlvbiBDKGUsdCxuKXt2YXIgcjtlLiR0cnVzdGVkP3I9ZWUodCxuLGUpOihyPVt4ZS5jcmVhdGVUZXh0Tm9kZShlKV0sdC5ub2RlTmFtZSBpbiBBZXx8aCh0LHJbMF0sbikpO3ZhciBhO3JldHVybiBhPVwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlP25ldyBlLmNvbnN0cnVjdG9yKGUpOmUsYS5ub2Rlcz1yLGF9ZnVuY3Rpb24gSyhlLHQsbixyLGEsaSl7dmFyIG89dC5ub2RlcztyZXR1cm4gciYmcj09PXhlLmFjdGl2ZUVsZW1lbnQmJmU9PT10fHwoZS4kdHJ1c3RlZD8oVihvLHQpLG89ZWUobixhLGUpKTpcInRleHRhcmVhXCI9PT1pP24udmFsdWU9ZTpyPyhyLmlubmVySFRNTD1lLG89W10uc2xpY2UuY2FsbChyLmNoaWxkTm9kZXMpKTooKDE9PT1vWzBdLm5vZGVUeXBlfHxvLmxlbmd0aD4xfHxvWzBdLm5vZGVWYWx1ZS50cmltJiYhb1swXS5ub2RlVmFsdWUudHJpbSgpKSYmKFYodC5ub2Rlcyx0KSxvPVt4ZS5jcmVhdGVUZXh0Tm9kZShlKV0pLG0obixvWzBdLGEsZSkpKSx0PW5ldyBlLmNvbnN0cnVjdG9yKGUpLHQubm9kZXM9byx0LiR0cnVzdGVkPWUuJHRydXN0ZWQsdH1mdW5jdGlvbiBUKGUsdCxuLHIsYSxpLG8pe3JldHVybiBlLm5vZGVzLmxlbmd0aD9lLnZhbHVlT2YoKSE9PXQudmFsdWVPZigpfHxhP0sodCxlLHIsaSxuLG8pOihlLm5vZGVzLmludGFjdD0hMCxlKTpDKHQscixuKX1mdW5jdGlvbiBBKGUpe3JldHVybiBlLiR0cnVzdGVkP2Uubm9kZXMubGVuZ3RoOlRlKGUpP2UubGVuZ3RoOjF9ZnVuY3Rpb24gRChlLG4scixhLGksbyx1LGwsZCl7ZT1nKGUpO3ZhciBzPVtdLGM9bi5sZW5ndGg9PT1lLmxlbmd0aCxmPTAsdj17fSxtPSExO3AobixmdW5jdGlvbihlLHQpe209ITAsdltuW3RdLmF0dHJzLmtleV09e2FjdGlvbjpEZSxpbmRleDp0fX0pLFAoZSksbSYmKG49dyhlLG4sdixyKSk7Zm9yKHZhciBoPTAseT0wLGs9ZS5sZW5ndGg7eTxrO3krKyl7dmFyIE89VShyLGksbixhLGVbeV0sbltoXSxvLGErZnx8Zix1LGwsZCk7TyE9PXQmJihjPWMmJk8ubm9kZXMuaW50YWN0LGYrPUEoTyksbltoKytdPU8pfXJldHVybiBjfHxiKGUsbixzKSxufWZ1bmN0aW9uIEIoZSx0LG4scixhKXtpZihudWxsIT10KXtpZihLZS5jYWxsKHQpPT09S2UuY2FsbChlKSlyZXR1cm4gdDtpZihhJiZhLm5vZGVzKXt2YXIgaT1uLXIsbz1pKyhUZShlKT9lOnQubm9kZXMpLmxlbmd0aDtWKGEubm9kZXMuc2xpY2UoaSxvKSxhLnNsaWNlKGksbykpfWVsc2UgdC5ub2RlcyYmVih0Lm5vZGVzLHQpfXJldHVybiB0PW5ldyBlLmNvbnN0cnVjdG9yLHQudGFnJiYodD17fSksdC5ub2Rlcz1bXSx0fWZ1bmN0aW9uIGooZSx0KXtyZXR1cm4gZS5hdHRycy5pcz9udWxsPT10P3hlLmNyZWF0ZUVsZW1lbnQoZS50YWcsZS5hdHRycy5pcyk6eGUuY3JlYXRlRWxlbWVudE5TKHQsZS50YWcsZS5hdHRycy5pcyk6bnVsbD09dD94ZS5jcmVhdGVFbGVtZW50KGUudGFnKTp4ZS5jcmVhdGVFbGVtZW50TlModCxlLnRhZyl9ZnVuY3Rpb24gUihlLHQsbixyKXtyZXR1cm4gcj9KKHQsZS50YWcsZS5hdHRycyx7fSxuKTplLmF0dHJzfWZ1bmN0aW9uIEwoZSxuLHIsYSxpLG8pe3JldHVybiBudWxsIT1lLmNoaWxkcmVuJiZlLmNoaWxkcmVuLmxlbmd0aD4wP1UobixlLnRhZyx0LHQsZS5jaGlsZHJlbixyLmNoaWxkcmVuLCEwLDAsZS5hdHRycy5jb250ZW50ZWRpdGFibGU/bjphLGksbyk6ZS5jaGlsZHJlbn1mdW5jdGlvbiBHKGUsdCxuLHIsYSxpLG8pe3ZhciB1PXt0YWc6ZS50YWcsYXR0cnM6dCxjaGlsZHJlbjpuLG5vZGVzOltyXX07cmV0dXJuIFModSxpLG8pLHUuY2hpbGRyZW4mJiF1LmNoaWxkcmVuLm5vZGVzJiYodS5jaGlsZHJlbi5ub2Rlcz1bXSksdX1mdW5jdGlvbiBGKGUsdCxyLGEpe3ZhciBpO3JldHVybiBpPVwiZGlmZlwiPT09Yy5yZWRyYXcuc3RyYXRlZ3koKSYmZT9lLmluZGV4T2YodCk6LTEsaT4tMT9yW2ldOm4oYSk/bmV3IGE6e319ZnVuY3Rpb24gTihlLHQsbixyKXtudWxsIT1yLm9udW5sb2FkJiZHZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGFuZGxlcn0pLmluZGV4T2Yoci5vbnVubG9hZCk8MCYmR2UucHVzaCh7Y29udHJvbGxlcjpyLGhhbmRsZXI6ci5vbnVubG9hZH0pLGUucHVzaChuKSx0LnB1c2gocil9ZnVuY3Rpb24gXyhlLHQsbixyLGEsaSl7dmFyIG89RihuLnZpZXdzLHQscixlLmNvbnRyb2xsZXIpLHU9ZSYmZS5hdHRycyYmZS5hdHRycy5rZXk7cmV0dXJuIGU9MD09PVJlfHxGZXx8ciYmci5pbmRleE9mKG8pPi0xP2UudmlldyhvKTp7dGFnOlwicGxhY2Vob2xkZXJcIn0sXCJyZXRhaW5cIj09PWUuc3VidHJlZT9lOihlLmF0dHJzPWUuYXR0cnN8fHt9LGUuYXR0cnMua2V5PXUsTihpLGEsdCxvKSxlKX1mdW5jdGlvbiBJKGUsdCxuLHIpe2Zvcih2YXIgYT10JiZ0LmNvbnRyb2xsZXJzO251bGwhPWUudmlldzspZT1fKGUsZS52aWV3LiRvcmlnaW5hbHx8ZS52aWV3LHQsYSxyLG4pO3JldHVybiBlfWZ1bmN0aW9uIEgoZSx0LG4scixhLG8sdSxsKXt2YXIgZD1bXSxzPVtdO2lmKGU9SShlLHQsZCxzKSxcInJldGFpblwiPT09ZS5zdWJ0cmVlKXJldHVybiB0O2lmKCFlLnRhZyYmcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHRlbXBsYXRlIG11c3QgcmV0dXJuIGEgdmlydHVhbCBlbGVtZW50LCBub3QgYW4gYXJyYXksIHN0cmluZywgZXRjLlwiKTtlLmF0dHJzPWUuYXR0cnN8fHt9LHQuYXR0cnM9dC5hdHRyc3x8e307dmFyIGM9T2JqZWN0LmtleXMoZS5hdHRycyksZj1jLmxlbmd0aD4oXCJrZXlcImluIGUuYXR0cnM/MTowKTtpZihPKGUsdCxjKSxpKGUudGFnKSl7dmFyIHA9MD09PXQubm9kZXMubGVuZ3RoO3U9eChlLHUpO3ZhciB2O2lmKHApe3Y9aihlLHUpO3ZhciBtPVIoZSx2LHUsZik7aChyLHYsYSk7dmFyIGc9TChlLHYsdCxuLHUsbCk7dD1HKGUsbSxnLHYsdSxkLHMpfWVsc2Ugdj1NKHQsZSxuLGYsdSxkLGwscyk7cmV0dXJuXCJzZWxlY3RcIj09PWUudGFnJiZcInZhbHVlXCJpbiBlLmF0dHJzJiZKKHYsZS50YWcse3ZhbHVlOmUuYXR0cnMudmFsdWV9LHt9LHUpLHB8fG8hPT0hMHx8bnVsbD09dnx8aChyLHYsYSksRShsLGUsdixwLHQpLHR9fWZ1bmN0aW9uIFUoZSx0LGEsaSxvLHUsbCxkLHMsYyxmKXtyZXR1cm4gbz12KG8pLFwicmV0YWluXCI9PT1vLnN1YnRyZWU/dToodT1CKG8sdSxkLGksYSksVGUobyk/RChvLHUsZSxkLHQsbCxzLGMsZik6bnVsbCE9byYmcihvKT9IKG8sdSxzLGUsZCxsLGMsZik6bihvKT91OlQodSxvLGQsZSxsLHMsdCkpfWZ1bmN0aW9uIHEoZSx0KXtyZXR1cm4gZS5hY3Rpb24tdC5hY3Rpb258fGUuaW5kZXgtdC5pbmRleH1mdW5jdGlvbiBYKGUsdCxuKXtuPT09dCYmKGUuc3R5bGU9XCJcIixuPXt9KTtmb3IodmFyIHIgaW4gdClDZS5jYWxsKHQscikmJihudWxsIT1uJiZuW3JdPT09dFtyXXx8KGUuc3R5bGVbcl09dFtyXSkpO2ZvcihyIGluIG4pQ2UuY2FsbChuLHIpJiYoQ2UuY2FsbCh0LHIpfHwoZS5zdHlsZVtyXT1cIlwiKSl9ZnVuY3Rpb24geihlLHQsYSxpLG8sdSl7aWYoXCJjb25maWdcIj09PXR8fFwia2V5XCI9PT10KXJldHVybiEwO2lmKG4oYSkmJlwib25cIj09PXQuc2xpY2UoMCwyKSllW3RdPXRlKGEsZSk7ZWxzZSBpZihcInN0eWxlXCI9PT10JiZudWxsIT1hJiZyKGEpKVgoZSxhLGkpO2Vsc2UgaWYobnVsbCE9dSlcImhyZWZcIj09PXQ/ZS5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcImhyZWZcIixhKTplLnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiPT09dD9cImNsYXNzXCI6dCxhKTtlbHNlIGlmKHQgaW4gZSYmIU5lW3RdKXRyeXsoXCJpbnB1dFwiIT09byYmIWUuaXNDb250ZW50RWRpdGFibGV8fGVbdF0hPWEpJiYoZVt0XT1hKX1jYXRjaChsKXtlLnNldEF0dHJpYnV0ZSh0LGEpfWVsc2UgdHJ5e2Uuc2V0QXR0cmlidXRlKHQsYSl9Y2F0Y2gobCl7fX1mdW5jdGlvbiAkKGUsdCxuLHIsYSxpLG8pe2lmKHQgaW4gYSYmcj09PW4mJlwib2JqZWN0XCIhPXR5cGVvZiBuJiZ4ZS5hY3RpdmVFbGVtZW50IT09ZSlcInZhbHVlXCI9PT10JiZcImlucHV0XCI9PT1pJiZlLnZhbHVlIT1uJiYoZS52YWx1ZT1uKTtlbHNle2FbdF09bjt0cnl7cmV0dXJuIHooZSx0LG4scixpLG8pfWNhdGNoKHUpe2lmKHUubWVzc2FnZS5pbmRleE9mKFwiSW52YWxpZCBhcmd1bWVudFwiKTwwKXRocm93IHV9fX1mdW5jdGlvbiBKKGUsdCxuLHIsYSl7Zm9yKHZhciBpIGluIG4pIUNlLmNhbGwobixpKXx8ISQoZSxpLG5baV0scltpXSxyLHQsYSk7cmV0dXJuIHJ9ZnVuY3Rpb24gVihlLHQpe2Zvcih2YXIgbj1lLmxlbmd0aC0xO24+LTE7bi0tKWlmKGVbbl0mJmVbbl0ucGFyZW50Tm9kZSl7dHJ5e2Vbbl0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlW25dKX1jYXRjaChyKXt9dD1bXS5jb25jYXQodCksdFtuXSYmWSh0W25dKX1lLmxlbmd0aCYmKGUubGVuZ3RoPTApfWZ1bmN0aW9uIFkoZSl7ZS5jb25maWdDb250ZXh0JiZuKGUuY29uZmlnQ29udGV4dC5vbnVubG9hZCkmJihlLmNvbmZpZ0NvbnRleHQub251bmxvYWQoKSxlLmNvbmZpZ0NvbnRleHQub251bmxvYWQ9bnVsbCksZS5jb250cm9sbGVycyYmZihlLmNvbnRyb2xsZXJzLGZ1bmN0aW9uKGUpe24oZS5vbnVubG9hZCkmJmUub251bmxvYWQoe3ByZXZlbnREZWZhdWx0Om99KX0pLGUuY2hpbGRyZW4mJihUZShlLmNoaWxkcmVuKT9mKGUuY2hpbGRyZW4sWSk6ZS5jaGlsZHJlbi50YWcmJlkoZS5jaGlsZHJlbikpfWZ1bmN0aW9uIFEoZSx0KXt0cnl7ZS5hcHBlbmRDaGlsZCh4ZS5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCh0KSl9Y2F0Y2gobil7ZS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIix0KSxXKGUpfX1mdW5jdGlvbiBXKGUpe2lmKFwiU0NSSVBUXCI9PT1lLnRhZ05hbWUpZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChaKGUpLGUpO2Vsc2V7dmFyIHQ9ZS5jaGlsZE5vZGVzO2lmKHQmJnQubGVuZ3RoKWZvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKVcodFtuXSl9cmV0dXJuIGV9ZnVuY3Rpb24gWihlKXtmb3IodmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSxuPWUuYXR0cmlidXRlcyxyPTA7cjxuLmxlbmd0aDtyKyspdC5zZXRBdHRyaWJ1dGUobltyXS5uYW1lLG5bcl0udmFsdWUpO3JldHVybiB0LnRleHQ9ZS5pbm5lckhUTUwsdH1mdW5jdGlvbiBlZShlLHQsbil7dmFyIHI9ZS5jaGlsZE5vZGVzW3RdO2lmKHIpe3ZhciBhPTEhPT1yLm5vZGVUeXBlLGk9eGUuY3JlYXRlRWxlbWVudChcInNwYW5cIik7YT8oZS5pbnNlcnRCZWZvcmUoaSxyfHxudWxsKSxpLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWJlZ2luXCIsbiksZS5yZW1vdmVDaGlsZChpKSk6ci5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLG4pfWVsc2UgUShlLG4pO2Zvcih2YXIgbz1bXTtlLmNoaWxkTm9kZXNbdF0hPT1yOylvLnB1c2goZS5jaGlsZE5vZGVzW3RdKSx0Kys7cmV0dXJuIG99ZnVuY3Rpb24gdGUoZSx0KXtyZXR1cm4gZnVuY3Rpb24obil7bj1ufHxldmVudCxjLnJlZHJhdy5zdHJhdGVneShcImRpZmZcIiksYy5zdGFydENvbXB1dGF0aW9uKCk7dHJ5e3JldHVybiBlLmNhbGwodCxuKX1maW5hbGx5e2xlKCl9fX1mdW5jdGlvbiBuZShlKXt2YXIgdD1JZS5pbmRleE9mKGUpO3JldHVybiB0PDA/SWUucHVzaChlKS0xOnR9ZnVuY3Rpb24gcmUoZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoJiYoZT1hcmd1bWVudHNbMF0pLGV9cmV0dXJuIHQudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIGUmJm4oZS50b0pTT04pP2UudG9KU09OKCk6ZX0sdH1mdW5jdGlvbiBhZShlLHQpe2Z1bmN0aW9uIG4oKXtyZXR1cm4oZS5jb250cm9sbGVyfHxvKS5hcHBseSh0aGlzLHQpfHx0aGlzfWZ1bmN0aW9uIHIobil7Zm9yKHZhciByPVtuXS5jb25jYXQodCksYT0xO2E8YXJndW1lbnRzLmxlbmd0aDthKyspci5wdXNoKGFyZ3VtZW50c1thXSk7cmV0dXJuIGUudmlldy5hcHBseShlLHIpfWUuY29udHJvbGxlciYmKG4ucHJvdG90eXBlPWUuY29udHJvbGxlci5wcm90b3R5cGUpLHIuJG9yaWdpbmFsPWUudmlldzt2YXIgYT17Y29udHJvbGxlcjpuLHZpZXc6cn07cmV0dXJuIHRbMF0mJm51bGwhPXRbMF0ua2V5JiYoYS5hdHRycz17a2V5OnRbMF0ua2V5fSksYX1mdW5jdGlvbiBpZShlLHQsbixyKXtpZighcil7Yy5yZWRyYXcuc3RyYXRlZ3koXCJhbGxcIiksYy5zdGFydENvbXB1dGF0aW9uKCkscWVbbl09dDt2YXIgYTthPVVlPWU/ZTplPXtjb250cm9sbGVyOm99O3ZhciBpPW5ldyhlLmNvbnRyb2xsZXJ8fG8pO3JldHVybiBhPT09VWUmJih6ZVtuXT1pLFhlW25dPWUpLGxlKCksbnVsbD09PWUmJm9lKHQsbiksemVbbl19bnVsbD09ZSYmb2UodCxuKSxaZSYmKFdlPVplKX1mdW5jdGlvbiBvZShlLHQpe3FlLnNwbGljZSh0LDEpLHplLnNwbGljZSh0LDEpLFhlLnNwbGljZSh0LDEpLG1lKGUpLEllLnNwbGljZShuZShlKSwxKSxHZT1bXX1mdW5jdGlvbiB1ZSgpe1ZlJiYoVmUoKSxWZT1udWxsKSxmKHFlLGZ1bmN0aW9uKGUsdCl7dmFyIG49WGVbdF07aWYoemVbdF0pe3ZhciByPVt6ZVt0XV07Yy5yZW5kZXIoZSxuLnZpZXc/bi52aWV3KHplW3RdLHIpOlwiXCIpfX0pLFllJiYoWWUoKSxZZT1udWxsKSwkZT1udWxsLEplPW5ldyBEYXRlLGMucmVkcmF3LnN0cmF0ZWd5KFwiZGlmZlwiKX1mdW5jdGlvbiBsZSgpe1wibm9uZVwiPT09Yy5yZWRyYXcuc3RyYXRlZ3koKT8oUmUtLSxjLnJlZHJhdy5zdHJhdGVneShcImRpZmZcIikpOmMuZW5kQ29tcHV0YXRpb24oKX1mdW5jdGlvbiBkZShlKXtyZXR1cm4gZS5zbGljZShudFtjLnJvdXRlLm1vZGVdLmxlbmd0aCl9ZnVuY3Rpb24gc2UoZSx0LG4pe3R0PXt9O3ZhciByPW4uaW5kZXhPZihcIj9cIik7ciE9PS0xJiYodHQ9dmUobi5zdWJzdHIocisxLG4ubGVuZ3RoKSksbj1uLnN1YnN0cigwLHIpKTt2YXIgYT1PYmplY3Qua2V5cyh0KSxpPWEuaW5kZXhPZihuKTtpZihpIT09LTEpcmV0dXJuIGMubW91bnQoZSx0W2FbaV1dKSwhMDtmb3IodmFyIG8gaW4gdClpZihDZS5jYWxsKHQsbykpe2lmKG89PT1uKXJldHVybiBjLm1vdW50KGUsdFtvXSksITA7dmFyIHU9bmV3IFJlZ0V4cChcIl5cIitvLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLFwiKC4qPylcIikucmVwbGFjZSgvOlteXFwvXSsvZyxcIihbXlxcXFwvXSspXCIpK1wiLz8kXCIpO2lmKHUudGVzdChuKSlyZXR1cm4gbi5yZXBsYWNlKHUsZnVuY3Rpb24oKXt2YXIgbj1vLm1hdGNoKC86W15cXC9dKy9nKXx8W10scj1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxLC0yKTtmKG4sZnVuY3Rpb24oZSx0KXt0dFtlLnJlcGxhY2UoLzp8XFwuL2csXCJcIildPWRlY29kZVVSSUNvbXBvbmVudChyW3RdKX0pLGMubW91bnQoZSx0W29dKX0pLCEwfX1mdW5jdGlvbiBjZShlKXtpZihlPWV8fGV2ZW50LCEoZS5jdHJsS2V5fHxlLm1ldGFLZXl8fGUuc2hpZnRLZXl8fDI9PT1lLndoaWNoKSl7ZS5wcmV2ZW50RGVmYXVsdD9lLnByZXZlbnREZWZhdWx0KCk6ZS5yZXR1cm5WYWx1ZT0hMTt2YXIgdCxuPWUuY3VycmVudFRhcmdldHx8ZS5zcmNFbGVtZW50O2Zvcih0PVwicGF0aG5hbWVcIj09PWMucm91dGUubW9kZSYmbi5zZWFyY2g/dmUobi5zZWFyY2guc2xpY2UoMSkpOnt9O24mJiEvYS9pLnRlc3Qobi5ub2RlTmFtZSk7KW49bi5wYXJlbnROb2RlO1JlPTAsYy5yb3V0ZShuW2Mucm91dGUubW9kZV0uc2xpY2UobnRbYy5yb3V0ZS5tb2RlXS5sZW5ndGgpLHQpfX1mdW5jdGlvbiBmZSgpe1wiaGFzaFwiIT09Yy5yb3V0ZS5tb2RlJiZTZS5oYXNoP1NlLmhhc2g9U2UuaGFzaDplLnNjcm9sbFRvKDAsMCl9ZnVuY3Rpb24gcGUoZSxuKXt2YXIgYT17fSxpPVtdO2Zvcih2YXIgbyBpbiBlKWlmKENlLmNhbGwoZSxvKSl7dmFyIHU9bj9uK1wiW1wiK28rXCJdXCI6byxsPWVbb107aWYobnVsbD09PWwpaS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh1KSk7ZWxzZSBpZihyKGwpKWkucHVzaChwZShsLHUpKTtlbHNlIGlmKFRlKGwpKXt2YXIgZD1bXTthW3VdPWFbdV18fHt9LGYobCxmdW5jdGlvbihlKXthW3VdW2VdfHwoYVt1XVtlXT0hMCxkLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHUpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChlKSkpfSksaS5wdXNoKGQuam9pbihcIiZcIikpfWVsc2UgbCE9PXQmJmkucHVzaChlbmNvZGVVUklDb21wb25lbnQodSkrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGwpKX1yZXR1cm4gaS5qb2luKFwiJlwiKX1mdW5jdGlvbiB2ZShlKXtpZihcIlwiPT09ZXx8bnVsbD09ZSlyZXR1cm57fTtcIj9cIj09PWUuY2hhckF0KDApJiYoZT1lLnNsaWNlKDEpKTt2YXIgdD1lLnNwbGl0KFwiJlwiKSxuPXt9O3JldHVybiBmKHQsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIj1cIikscj1kZWNvZGVVUklDb21wb25lbnQodFswXSksYT0yPT09dC5sZW5ndGg/ZGVjb2RlVVJJQ29tcG9uZW50KHRbMV0pOm51bGw7bnVsbCE9bltyXT8oVGUobltyXSl8fChuW3JdPVtuW3JdXSksbltyXS5wdXNoKGEpKTpuW3JdPWF9KSxufWZ1bmN0aW9uIG1lKGUpe3ZhciBuPW5lKGUpO1YoZS5jaGlsZE5vZGVzLEhlW25dKSxIZVtuXT10fWZ1bmN0aW9uIGdlKGUsdCl7dmFyIG49Yy5wcm9wKHQpO3JldHVybiBlLnRoZW4obiksbi50aGVuPWZ1bmN0aW9uKG4scil7cmV0dXJuIGdlKGUudGhlbihuLHIpLHQpfSxuW1wiY2F0Y2hcIl09bi50aGVuLmJpbmQobnVsbCxudWxsKSxufWZ1bmN0aW9uIGhlKGUsdCl7ZnVuY3Rpb24gYShlKXtsPWV8fGx0LHMubWFwKGZ1bmN0aW9uKGUpe2w9PT11dD9lLnJlc29sdmUoZCk6ZS5yZWplY3QoZCl9KX1mdW5jdGlvbiBpKGUsdCxhLGkpe2lmKChudWxsIT1kJiZyKGQpfHxuKGQpKSYmbihlKSl0cnl7dmFyIG89MDtlLmNhbGwoZCxmdW5jdGlvbihlKXtvKyt8fChkPWUsdCgpKX0sZnVuY3Rpb24oZSl7bysrfHwoZD1lLGEoKSl9KX1jYXRjaCh1KXtjLmRlZmVycmVkLm9uZXJyb3IodSksZD11LGEoKX1lbHNlIGkoKX1mdW5jdGlvbiBvKCl7dmFyIHI7dHJ5e3I9ZCYmZC50aGVufWNhdGNoKHMpe3JldHVybiBjLmRlZmVycmVkLm9uZXJyb3IocyksZD1zLGw9b3QsbygpfWw9PT1vdCYmYy5kZWZlcnJlZC5vbmVycm9yKGQpLGkocixmdW5jdGlvbigpe2w9aXQsbygpfSxmdW5jdGlvbigpe2w9b3QsbygpfSxmdW5jdGlvbigpe3RyeXtsPT09aXQmJm4oZSk/ZD1lKGQpOmw9PT1vdCYmbih0KSYmKGQ9dChkKSxsPWl0KX1jYXRjaChvKXtyZXR1cm4gYy5kZWZlcnJlZC5vbmVycm9yKG8pLGQ9byxhKCl9ZD09PXU/KGQ9VHlwZUVycm9yKCksYSgpKTppKHIsZnVuY3Rpb24oKXthKHV0KX0sYSxmdW5jdGlvbigpe2EobD09PWl0JiZ1dCl9KX0pfXZhciB1PXRoaXMsbD0wLGQ9MCxzPVtdO3UucHJvbWlzZT17fSx1LnJlc29sdmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGx8fChkPWUsbD1pdCxvKCkpLHV9LHUucmVqZWN0PWZ1bmN0aW9uKGUpe3JldHVybiBsfHwoZD1lLGw9b3QsbygpKSx1fSx1LnByb21pc2UudGhlbj1mdW5jdGlvbihlLHQpe3ZhciBuPW5ldyBoZShlLHQpO3JldHVybiBsPT09dXQ/bi5yZXNvbHZlKGQpOmw9PT1sdD9uLnJlamVjdChkKTpzLnB1c2gobiksbi5wcm9taXNlfX1mdW5jdGlvbiB5ZShlKXtyZXR1cm4gZX1mdW5jdGlvbiB3ZShuKXt2YXIgcj1uLmNhbGxiYWNrTmFtZXx8XCJtaXRocmlsX2NhbGxiYWNrX1wiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpK1wiX1wiK01hdGgucm91bmQoMWUxNipNYXRoLnJhbmRvbSgpKS50b1N0cmluZygzNiksYT14ZS5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2Vbcl09ZnVuY3Rpb24oaSl7YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLG4ub25sb2FkKHt0eXBlOlwibG9hZFwiLHRhcmdldDp7cmVzcG9uc2VUZXh0Oml9fSksZVtyXT10fSxhLm9uZXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4gYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLG4ub25lcnJvcih7dHlwZTpcImVycm9yXCIsdGFyZ2V0OntzdGF0dXM6NTAwLHJlc3BvbnNlVGV4dDpKU09OLnN0cmluZ2lmeSh7ZXJyb3I6XCJFcnJvciBtYWtpbmcganNvbnAgcmVxdWVzdFwifSl9fSksZVtyXT10LCExfSxhLm9ubG9hZD1mdW5jdGlvbigpe3JldHVybiExfSxhLnNyYz1uLnVybCsobi51cmwuaW5kZXhPZihcIj9cIik+MD9cIiZcIjpcIj9cIikrKG4uY2FsbGJhY2tLZXk/bi5jYWxsYmFja0tleTpcImNhbGxiYWNrXCIpK1wiPVwiK3IrXCImXCIrcGUobi5kYXRhfHx7fSkseGUuYm9keS5hcHBlbmRDaGlsZChhKX1mdW5jdGlvbiBiZSh0KXt2YXIgYT1uZXcgZS5YTUxIdHRwUmVxdWVzdDtpZihhLm9wZW4odC5tZXRob2QsdC51cmwsITAsdC51c2VyLHQucGFzc3dvcmQpLGEub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ND09PWEucmVhZHlTdGF0ZSYmKGEuc3RhdHVzPj0yMDAmJmEuc3RhdHVzPDMwMD90Lm9ubG9hZCh7dHlwZTpcImxvYWRcIix0YXJnZXQ6YX0pOnQub25lcnJvcih7dHlwZTpcImVycm9yXCIsdGFyZ2V0OmF9KSl9LHQuc2VyaWFsaXplPT09SlNPTi5zdHJpbmdpZnkmJnQuZGF0YSYmXCJHRVRcIiE9PXQubWV0aG9kJiZhLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIiksdC5kZXNlcmlhbGl6ZT09PUpTT04ucGFyc2UmJmEuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC8qXCIpLHIodC5oZWFkZXJzKSlmb3IodmFyIG8gaW4gdC5oZWFkZXJzKUNlLmNhbGwodC5oZWFkZXJzLG8pJiZhLnNldFJlcXVlc3RIZWFkZXIobyx0LmhlYWRlcnNbb10pO2lmKG4odC5jb25maWcpKXt2YXIgdT10LmNvbmZpZyhhLHQpO251bGwhPXUmJihhPXUpfXZhciBsPVwiR0VUXCIhPT10Lm1ldGhvZCYmdC5kYXRhP3QuZGF0YTpcIlwiO2lmKGwmJiFpKGwpJiZsLmNvbnN0cnVjdG9yIT09ZS5Gb3JtRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGRhdGEgc2hvdWxkIGJlIGVpdGhlciBiZSBhIHN0cmluZyBvciBGb3JtRGF0YS4gQ2hlY2sgdGhlIGBzZXJpYWxpemVgIG9wdGlvbiBpbiBgbS5yZXF1ZXN0YFwiKTtyZXR1cm4gYS5zZW5kKGwpLGF9ZnVuY3Rpb24gUGUoZSl7cmV0dXJuIGUuZGF0YVR5cGUmJlwianNvbnBcIj09PWUuZGF0YVR5cGUudG9Mb3dlckNhc2UoKT93ZShlKTpiZShlKX1mdW5jdGlvbiBrZShlLHQsbil7aWYoXCJHRVRcIj09PWUubWV0aG9kJiZcImpzb25wXCIhPT1lLmRhdGFUeXBlKXt2YXIgcj1lLnVybC5pbmRleE9mKFwiP1wiKTwwP1wiP1wiOlwiJlwiLGE9cGUodCk7ZS51cmwrPWE/cithOlwiXCJ9ZWxzZSBlLmRhdGE9bih0KX1mdW5jdGlvbiBPZShlLHQpe3JldHVybiB0JiYoZT1lLnJlcGxhY2UoLzpbYS16XVxcdysvZ2ksZnVuY3Rpb24oZSl7dmFyIG49ZS5zbGljZSgxKSxyPXRbbl18fGU7cmV0dXJuIGRlbGV0ZSB0W25dLHJ9KSksZX1jLnZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm5cInYwLjIuOFwifTt2YXIgeGUsU2UsRWUsTWUsQ2U9e30uaGFzT3duUHJvcGVydHksS2U9e30udG9TdHJpbmcsVGU9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09S2UuY2FsbChlKX0sQWU9e0FSRUE6MSxCQVNFOjEsQlI6MSxDT0w6MSxDT01NQU5EOjEsRU1CRUQ6MSxIUjoxLElNRzoxLElOUFVUOjEsS0VZR0VOOjEsTElOSzoxLE1FVEE6MSxQQVJBTToxLFNPVVJDRToxLFRSQUNLOjEsV0JSOjF9O2MuZGVwcz1mdW5jdGlvbih0KXtyZXR1cm4gdShlPXR8fHdpbmRvdyksZX0sYy5kZXBzLmZhY3Rvcnk9Yy5mYWN0b3J5PWEsYy5kZXBzKGUpO3ZhciBEZT0xLEJlPTIsamU9MyxSZT0wO2Muc3RhcnRDb21wdXRhdGlvbj1mdW5jdGlvbigpe1JlKyt9LGMuZW5kQ29tcHV0YXRpb249ZnVuY3Rpb24oKXtSZT4xP1JlLS06KFJlPTAsYy5yZWRyYXcoKSl9O3ZhciBMZSxHZT1bXSxGZT0hMSxOZT17bGlzdDoxLHN0eWxlOjEsZm9ybToxLHR5cGU6MSx3aWR0aDoxLGhlaWdodDoxfSxfZT17YXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oZSl7TGU9PT10JiYoTGU9eGUuY3JlYXRlRWxlbWVudChcImh0bWxcIikpLHhlLmRvY3VtZW50RWxlbWVudCYmeGUuZG9jdW1lbnRFbGVtZW50IT09ZT94ZS5yZXBsYWNlQ2hpbGQoZSx4ZS5kb2N1bWVudEVsZW1lbnQpOnhlLmFwcGVuZENoaWxkKGUpLHRoaXMuY2hpbGROb2Rlcz14ZS5jaGlsZE5vZGVzfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24oZSl7dGhpcy5hcHBlbmRDaGlsZChlKX0sY2hpbGROb2RlczpbXX0sSWU9W10sSGU9e307Yy5yZW5kZXI9ZnVuY3Rpb24oZSxuLHIpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKTt2YXIgYSxpPVtdLG89bmUoZSksdT1lPT09eGU7YT11fHxlPT09eGUuZG9jdW1lbnRFbGVtZW50P19lOmUsdSYmXCJodG1sXCIhPT1uLnRhZyYmKG49e3RhZzpcImh0bWxcIixhdHRyczp7fSxjaGlsZHJlbjpufSksSGVbb109PT10JiZWKGEuY2hpbGROb2Rlcykscj09PSEwJiZtZShlKSxIZVtvXT1VKGEsbnVsbCx0LHQsbixIZVtvXSwhMSwwLG51bGwsdCxpKSxmKGksZnVuY3Rpb24oZSl7ZSgpfSl9LGMudHJ1c3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9bmV3IFN0cmluZyhlKSxlLiR0cnVzdGVkPSEwLGV9LGMucHJvcD1mdW5jdGlvbihlKXtyZXR1cm4obnVsbCE9ZSYmKHIoZSl8fG4oZSkpfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgUHJvbWlzZSYmZSBpbnN0YW5jZW9mIFByb21pc2UpJiZuKGUudGhlbik/Z2UoZSk6cmUoZSl9O3ZhciBVZSxxZT1bXSxYZT1bXSx6ZT1bXSwkZT1udWxsLEplPTAsVmU9bnVsbCxZZT1udWxsLFFlPTE2O2MuY29tcG9uZW50PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO3JldHVybiBhZShlLHQpfTt2YXIgV2UsWmU7Yy5tb3VudD1jLm1vZHVsZT1mdW5jdGlvbihlLHQpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKTt2YXIgcj1xZS5pbmRleE9mKGUpO3I8MCYmKHI9cWUubGVuZ3RoKTt2YXIgYT0hMSxpPXtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe2E9ITAsVmU9WWU9bnVsbH19O3JldHVybiBmKEdlLGZ1bmN0aW9uKGUpe2UuaGFuZGxlci5jYWxsKGUuY29udHJvbGxlcixpKSxlLmNvbnRyb2xsZXIub251bmxvYWQ9bnVsbH0pLGE/ZihHZSxmdW5jdGlvbihlKXtlLmNvbnRyb2xsZXIub251bmxvYWQ9ZS5oYW5kbGVyfSk6R2U9W10semVbcl0mJm4oemVbcl0ub251bmxvYWQpJiZ6ZVtyXS5vbnVubG9hZChpKSxpZSh0LGUscixhKX07dmFyIGV0PSExO2MucmVkcmF3PWZ1bmN0aW9uKHQpe2lmKCFldCl7ZXQ9ITAsdCYmKEZlPSEwKTt0cnl7JGUmJiF0PyhFZT09PWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxuZXcgRGF0ZS1KZT5RZSkmJigkZT4wJiZNZSgkZSksJGU9RWUodWUsUWUpKToodWUoKSwkZT1FZShmdW5jdGlvbigpeyRlPW51bGx9LFFlKSl9ZmluYWxseXtldD1GZT0hMX19fSxjLnJlZHJhdy5zdHJhdGVneT1jLnByb3AoKSxjLndpdGhBdHRyPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocil7cj1yfHx3aW5kb3cuZXZlbnQ7dmFyIGE9ci5jdXJyZW50VGFyZ2V0fHx0aGlzLGk9bnx8dGhpcyxvPWUgaW4gYT9hW2VdOmEuZ2V0QXR0cmlidXRlKGUpO3QuY2FsbChpLG8pfX07dmFyIHR0LG50PXtwYXRobmFtZTpcIlwiLGhhc2g6XCIjXCIsc2VhcmNoOlwiP1wifSxydD1vLGF0PSExO2Mucm91dGU9ZnVuY3Rpb24odCxuLHIsYSl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIFdlO2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoJiZpKG4pKXtydD1mdW5jdGlvbihlKXt2YXIgYT1XZT1kZShlKTtpZighc2UodCxyLGEpKXtpZihhdCl0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIGRlZmF1bHQgcm91dGUgbWF0Y2hlcyBvbmUgb2YgdGhlIHJvdXRlcyBkZWZpbmVkIGluIG0ucm91dGVcIik7YXQ9ITAsYy5yb3V0ZShuLCEwKSxhdD0hMX19O3ZhciBvPVwiaGFzaFwiPT09Yy5yb3V0ZS5tb2RlP1wib25oYXNoY2hhbmdlXCI6XCJvbnBvcHN0YXRlXCI7cmV0dXJuIGVbb109ZnVuY3Rpb24oKXt2YXIgZT1TZVtjLnJvdXRlLm1vZGVdO1wicGF0aG5hbWVcIj09PWMucm91dGUubW9kZSYmKGUrPVNlLnNlYXJjaCksV2UhPT1kZShlKSYmcnQoZSl9LFZlPWZlLHZvaWQgZVtvXSgpfWlmKHQuYWRkRXZlbnRMaXN0ZW5lcnx8dC5hdHRhY2hFdmVudCl7dmFyIHU9XCJwYXRobmFtZVwiIT09Yy5yb3V0ZS5tb2RlP1NlLnBhdGhuYW1lOlwiXCI7cmV0dXJuIHQuaHJlZj11K250W2Mucm91dGUubW9kZV0rYS5hdHRycy5ocmVmLHZvaWQodC5hZGRFdmVudExpc3RlbmVyPyh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGNlKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGNlKSk6KHQuZGV0YWNoRXZlbnQoXCJvbmNsaWNrXCIsY2UpLHQuYXR0YWNoRXZlbnQoXCJvbmNsaWNrXCIsY2UpKSl9aWYoaSh0KSl7WmU9V2UsV2U9dDt2YXIgbCxkPW58fHt9LHM9V2UuaW5kZXhPZihcIj9cIik7bD1zPi0xP3ZlKFdlLnNsaWNlKHMrMSkpOnt9O2Zvcih2YXIgZiBpbiBkKUNlLmNhbGwoZCxmKSYmKGxbZl09ZFtmXSk7dmFyIHAsdj1wZShsKTtwPXM+LTE/V2Uuc2xpY2UoMCxzKTpXZSx2JiYoV2U9cCsocC5pbmRleE9mKFwiP1wiKT09PS0xP1wiP1wiOlwiJlwiKSt2KTt2YXIgbT0oMz09PWFyZ3VtZW50cy5sZW5ndGg/cjpuKT09PSEwfHxaZT09PVdlO2lmKGUuaGlzdG9yeS5wdXNoU3RhdGUpe3ZhciBnPW0/XCJyZXBsYWNlU3RhdGVcIjpcInB1c2hTdGF0ZVwiO1ZlPWZlLFllPWZ1bmN0aW9uKCl7dHJ5e2UuaGlzdG9yeVtnXShudWxsLHhlLnRpdGxlLG50W2Mucm91dGUubW9kZV0rV2UpfWNhdGNoKHQpe1NlW2Mucm91dGUubW9kZV09V2V9fSxydChudFtjLnJvdXRlLm1vZGVdK1dlKX1lbHNlIFNlW2Mucm91dGUubW9kZV09V2UscnQobnRbYy5yb3V0ZS5tb2RlXStXZSk7WmU9bnVsbH19LGMucm91dGUucGFyYW09ZnVuY3Rpb24oZSl7aWYoIXR0KXRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IGNhbGwgbS5yb3V0ZShlbGVtZW50LCBkZWZhdWx0Um91dGUsIHJvdXRlcykgYmVmb3JlIGNhbGxpbmcgbS5yb3V0ZS5wYXJhbSgpXCIpO3JldHVybiBlP3R0W2VdOnR0fSxjLnJvdXRlLm1vZGU9XCJzZWFyY2hcIixjLnJvdXRlLmJ1aWxkUXVlcnlTdHJpbmc9cGUsYy5yb3V0ZS5wYXJzZVF1ZXJ5U3RyaW5nPXZlLGMuZGVmZXJyZWQ9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgaGU7cmV0dXJuIGUucHJvbWlzZT1nZShlLnByb21pc2UpLGV9O3ZhciBpdD0xLG90PTIsdXQ9MyxsdD00O3JldHVybiBjLmRlZmVycmVkLm9uZXJyb3I9ZnVuY3Rpb24oZSl7aWYoXCJbb2JqZWN0IEVycm9yXVwiPT09S2UuY2FsbChlKSYmIS8gRXJyb3IvLnRlc3QoZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpKSl0aHJvdyBSZT0wLGV9LGMuc3luYz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG8pe3JldHVybiBhW2VdPW8sdHx8KGk9XCJyZWplY3RcIiksMD09PS0tciYmKG4ucHJvbWlzZShhKSxuW2ldKGEpKSxvfX12YXIgbj1jLmRlZmVycmVkKCkscj1lLmxlbmd0aCxhPVtdLGk9XCJyZXNvbHZlXCI7cmV0dXJuIGUubGVuZ3RoPjA/ZihlLGZ1bmN0aW9uKGUsbil7ZS50aGVuKHQobiwhMCksdChuLCExKSl9KTpuLnJlc29sdmUoW10pLG4ucHJvbWlzZX0sYy5yZXF1ZXN0PWZ1bmN0aW9uKGUpe2UuYmFja2dyb3VuZCE9PSEwJiZjLnN0YXJ0Q29tcHV0YXRpb24oKTt2YXIgdCxuLHIsYT1uZXcgaGUsaT1lLmRhdGFUeXBlJiZcImpzb25wXCI9PT1lLmRhdGFUeXBlLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGk/KHQ9ZS5zZXJpYWxpemU9bj1lLmRlc2VyaWFsaXplPXllLHI9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVzcG9uc2VUZXh0fSk6KHQ9ZS5zZXJpYWxpemU9ZS5zZXJpYWxpemV8fEpTT04uc3RyaW5naWZ5LG49ZS5kZXNlcmlhbGl6ZT1lLmRlc2VyaWFsaXplfHxKU09OLnBhcnNlLHI9ZS5leHRyYWN0fHxmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXNwb25zZVRleHQubGVuZ3RofHxuIT09SlNPTi5wYXJzZT9lLnJlc3BvbnNlVGV4dDpudWxsfSksZS5tZXRob2Q9KGUubWV0aG9kfHxcIkdFVFwiKS50b1VwcGVyQ2FzZSgpLGUudXJsPU9lKGUudXJsLGUuZGF0YSksa2UoZSxlLmRhdGEsdCksZS5vbmxvYWQ9ZS5vbmVycm9yPWZ1bmN0aW9uKHQpe3RyeXt0PXR8fGV2ZW50O3ZhciBpPW4ocih0LnRhcmdldCxlKSk7XCJsb2FkXCI9PT10LnR5cGU/KGUudW53cmFwU3VjY2VzcyYmKGk9ZS51bndyYXBTdWNjZXNzKGksdC50YXJnZXQpKSxUZShpKSYmZS50eXBlP2YoaSxmdW5jdGlvbih0LG4pe2lbbl09bmV3IGUudHlwZSh0KX0pOmUudHlwZSYmKGk9bmV3IGUudHlwZShpKSksYS5yZXNvbHZlKGkpKTooZS51bndyYXBFcnJvciYmKGk9ZS51bndyYXBFcnJvcihpLHQudGFyZ2V0KSksYS5yZWplY3QoaSkpfWNhdGNoKG8pe2EucmVqZWN0KG8pLGMuZGVmZXJyZWQub25lcnJvcihvKX1maW5hbGx5e2UuYmFja2dyb3VuZCE9PSEwJiZjLmVuZENvbXB1dGF0aW9uKCl9fSxQZShlKSxhLnByb21pc2U9Z2UoYS5wcm9taXNlLGUuaW5pdGlhbFZhbHVlKSxhLnByb21pc2V9LGN9KX0se31dLDM6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlLHQpe3ZhciBuPS43KmUud2lkdGgscj0uNyplLmhlaWdodCxhPXBbXCJkZWZhdWx0XCJdLm1pbmlLZXkycG9zKHQpLGk9W2FbMF0qKG4vcFtcImRlZmF1bHRcIl0ubWluaUNvbHVtbnMpLGFbMV0qKHIvcFtcImRlZmF1bHRcIl0ubWluaVJvd3MpXTtyZXR1cm4gaX1mdW5jdGlvbiBpKGUsdCxuKXt2YXIgcj1wW1wiZGVmYXVsdFwiXS5rZXkycG9zKG4pLGE9W3JbMF0qKGUud2lkdGgvcFtcImRlZmF1bHRcIl0uY29sdW1ucyksclsxXSplLmhlaWdodCouNV0saT1bZS5sZWZ0LXQubGVmdCxlLnRvcC10LnRvcF07cmV0dXJuW2lbMF0rYVswXSxpWzFdK2FbMV1dfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm5bZVswXS10WzBdLGVbMV0tdFsxXV19ZnVuY3Rpb24gdShlLHQpe3JldHVybiB0WzBdfWZ1bmN0aW9uIGwoZSx0LG4pe3JldHVybntrZXk6ZSxkaXN0YW5jZTpuLGNvbG9yOnQuY29sb3IsbnVtYmVyOnQubnVtYmVyfX1mdW5jdGlvbiBkKGUsdCl7dmFyIG4scixkLHMsYz10LmFuaW1hdGlvbi5jdXJyZW50LGY9cFtcImRlZmF1bHRcIl0uZmluZFBvdih0LnBvdlNpZGUsdC50dXJuU2lkZSksbT1wW1wiZGVmYXVsdFwiXS52ZWN0b3JCeVBvdihmKSxnPSh0LmJvdW5kcygpLHQudG9wQm91bmRzKCkpLGg9dC5ib2FyZEJvdW5kcygpLHk9aC53aWR0aCx3PShoLmhlaWdodCxnLndpZHRoKSxiPWcuaGVpZ2h0LFA9LjA2MjUqdyxrPS4xNCpiLE89LjA2MjUqeSx4PXt9LFM9W10sRT17fSxNPXt9LEM9cFtcImRlZmF1bHRcIl0uZGlzY2FyZEJ5UG92KGYpLEs9cFtcImRlZmF1bHRcIl0uZHJhd0J5UG92KGYpLFQ9cFtcImRlZmF1bHRcIl0udG9wS2V5MnBvcyhLKSxBPXBbXCJkZWZhdWx0XCJdLnRvcEtleTJwb3MoQyksRD1bdyptWzBdLGIqbVsxXSsoXCJ1cFwiPT09Zj8tazpcImxlZnRcIj09PWY/LWsvMjowKV0sQj1bMTIqUCxiLWtdLGo9W1AqQVswXSxrKkFbMV1dLFI9W1AqVFswXSxrKlRbMV1dLEw9WzEqUCwxKmtdLEc9W10sRj1bXSxOPVtdLF89W107Zm9yKG49MDtuPHBbXCJkZWZhdWx0XCJdLmFsbEFsbG93ZWRCb2FyZEtleXMubGVuZ3RoO24rKyl7cj1wW1wiZGVmYXVsdFwiXS5hbGxBbGxvd2VkQm9hcmRLZXlzW25dLGQ9dC5waWVjZXNbcl0scz1lLnBpZWNlc1tyXTt2YXIgST1pKGgsZyxyKTshZCYmcz9HLnB1c2gobChyLHMsSSkpOmQmJiFzJiZGLnB1c2gobChyLGQsSSkpfWZvcihuPTA7bjxwW1wiZGVmYXVsdFwiXS5taW5pQWxsS2V5cy5sZW5ndGg7bisrKXtyPXBbXCJkZWZhdWx0XCJdLm1pbmlBbGxLZXlzW25dLGQ9dC5vcGVucy5sYXlvdXQ/dC5vcGVucy5sYXlvdXQubGF5b3V0W3JdOm51bGwscz1lLm9wZW5zLmxheW91dD9lLm9wZW5zLmxheW91dC5sYXlvdXRbcl06bnVsbDt2YXIgSD1hKGcscik7ZCYmIXM/Xy5wdXNoKGwocixkLEgpKTohZCYmcyYmTi5wdXNoKGwocixzLEgpKX12YXIgVSxxLFg7cmV0dXJuXCJkb3duXCIhPT1mfHx0LnNwZWN0YXRvcj9jLmhpbnQ9PT12W1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlPyhVPVsxMipQLGJdLHE9RCxYPVtxWzBdLVVbMF0scVsxXS1VWzFdXSx4W3BbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50XT1bWCxYLCEwXSk6Yy5oaW50PT09dltcImRlZmF1bHRcIl0uZGlzY2FyZD8oVT1bUCpBWzBdLGsqQVsxXV0scT1ELFg9W3FbMF0tVVswXSxxWzFdLVVbMV1dLHhbQ109W1gsWF0pOmMuaGludD09PXZbXCJkZWZhdWx0XCJdLmRyYXdMZWZ0PyhVPVtQKlRbMF0saypUWzFdXSxxPUQsWD1bcVswXS1VWzBdLHFbMV0tVVsxXV0seFt2W1wiZGVmYXVsdFwiXS5kcmF3TGVmdCtLXT1bWCxYLCEwXSxNLnBpZWNlPWUuZGlzY2FyZHNbS10pOmMuaGludD09PXZbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW4/KFU9W1AqVFswXSxrKlRbMV1dLHE9RCxYPVtxWzBdLVVbMF0scVsxXS1VWzFdXSx4W0tdPVtYLFhdKTpjLmhpbnQ9PT12W1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzP18uZm9yRWFjaChmdW5jdGlvbihlLHQpe3E9RCxxPW8ocSxMKSxxPW8ocSxlLmRpc3RhbmNlKSxVPVswLDBdLFg9W3FbMF0tVVswXSxxWzFdLVVbMV1dLHhbZS5rZXldPVtYLFhdLEVbZS5rZXldPVsxLjc1LDEuNzVdfSk6Yy5oaW50PT09dltcImRlZmF1bHRcIl0uY29sbGVjdE9wZW4mJk4uZm9yRWFjaChmdW5jdGlvbihlLHQpe3E9RCxxPW8ocSxMKSxxPW8ocSxlLmRpc3RhbmNlKSxVPVswLDBdLFg9W3FbMF0tVVswXSxxWzFdLVVbMV1dLHhbZS5rZXldPVtYLFgsITBdLE1bZS5rZXldPWV9KTpjLmhpbnQ9PT12W1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlJiZGWzBdPyhyPUZbMF0ua2V5LFU9RlswXS5kaXN0YW5jZSxVPW8oVSxCKSxxPVswLDBdLFg9W3FbMF0tVVswXSxxWzFdLVVbMV1dLHhbcl09W1gsWF0pOmMuaGludD09PXZbXCJkZWZhdWx0XCJdLmRpc2NhcmQmJkdbMF0/KHE9R1swXS5kaXN0YW5jZSxxPW8ocSxqKSxVPVswLDBdLFg9W3FbMF0tVVswXSxxWzFdLVVbMV1dLHhbQ109W1gsWF0pOmMuaGludD09PXZbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW4/R1swXT8ocT1HWzBdLmRpc3RhbmNlLHE9byhxLFIpLFU9WzAsMF0sWD1bcVswXS1VWzBdLHFbMV0tVVsxXV0seFtLXT1bWCxYXSk6KFU9W1AqVFswXSxrKlRbMV1dLHE9RCxYPVtxWzBdLVVbMF0scVsxXS1VWzFdXSx4W0tdPVtYLFhdKTpjLmhpbnQ9PT12W1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzJiZfLmZvckVhY2goZnVuY3Rpb24oZSx0KXt2YXIgbj11KGUsRy5maWx0ZXIocFtcImRlZmF1bHRcIl0ucGFydGlhbChwW1wiZGVmYXVsdFwiXS5waWVjZUVxdWFsLGUpKSk7Ry5zcGxpY2UoRy5pbmRleE9mKG4pLDEpLG4mJihxPW4uZGlzdGFuY2UscT1vKG4uZGlzdGFuY2UsW08sMF0pLHE9byhxLEwpLHE9byhxLGUuZGlzdGFuY2UpLFU9WzAsMF0sWD1bcVswXS1VWzBdLHFbMV0tVVsxXV0seFtlLmtleV09W1gsWF0sRVtlLmtleV09WzEuNzUsMS43NV0pfSkse2FuaW1zOngsZmFkaW5nczpTLHNjYWxlczpFLGV4dHJhOk19fWZ1bmN0aW9uIHMoZSx0KXtyZXR1cm4gTWF0aC5yb3VuZChlKnQpL3R9ZnVuY3Rpb24gYyhlKXtpZihlLmFuaW1hdGlvbi5jdXJyZW50LnN0YXJ0KXt2YXIgdD0xLSgobmV3IERhdGUpLmdldFRpbWUoKS1lLmFuaW1hdGlvbi5jdXJyZW50LnN0YXJ0KS9lLmFuaW1hdGlvbi5jdXJyZW50LmR1cmF0aW9uO2lmKHQ8PTApZS5hbmltYXRpb24uY3VycmVudD17fSxlLnJlbmRlcigpO2Vsc2V7dmFyIG4scj1tLmVhc2VJbk91dEN1YmljKHQpO2Zvcih2YXIgYSBpbiBlLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zKW49ZS5hbmltYXRpb24uY3VycmVudC5hbmltc1thXSxuWzFdPVtzKG5bMF1bMF0qciwxMCkscyhuWzBdWzFdKnIsMTApXSxuWzJdJiYoblsxXT1bblswXVswXS1uWzFdWzBdLG5bMF1bMV0tblsxXVsxXV0pO3ZhciBpO2ZvcihpIGluIGUuYW5pbWF0aW9uLmN1cnJlbnQuZmFkaW5ncyllLmFuaW1hdGlvbnMuY3VycmVudC5mYWRpbmdzW2ldLm9wYWNpdHk9cyhyLDEwMCk7Zm9yKGkgaW4gZS5hbmltYXRpb24uY3VycmVudC5zY2FsZXMpbj1lLmFuaW1hdGlvbi5jdXJyZW50LnNjYWxlc1tpXSxuWzBdPTErcyguNypyLDEwKSxuWzFdPTErcyguNypyLDEwKTtlLnJlbmRlcigpLHBbXCJkZWZhdWx0XCJdLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2MoZSl9KX19fWZ1bmN0aW9uIGYoZSx0KXt2YXIgbixyPXtwaWVjZXM6e30sb3BlbnM6e30sbWlkZGxlczp7fSxkaXNjYXJkczp7fX07Zm9yKG4gaW4gdC5waWVjZXMpdC5waWVjZXNbbl0mJihyLnBpZWNlc1tuXT17Y29sb3I6dC5waWVjZXNbbl0uY29sb3IsbnVtYmVyOnQucGllY2VzW25dLm51bWJlcn0pO2ZvcihuIGluIHQuZGlzY2FyZHMpdC5kaXNjYXJkc1tuXSYmdC5kaXNjYXJkc1tuXVswXSYmKHIuZGlzY2FyZHNbbl09e2NvbG9yOnQuZGlzY2FyZHNbbl1bMF0uY29sb3IsbnVtYmVyOnQuZGlzY2FyZHNbbl1bMF0ubnVtYmVyfSk7aWYodC5vcGVucy5sYXlvdXQpe3ZhciBhO3Iub3BlbnMubGF5b3V0PXtsYXlvdXQ6e319O2ZvcihuIGluIHQub3BlbnMubGF5b3V0LmxheW91dClhPXQub3BlbnMubGF5b3V0LmxheW91dFtuXSxyLm9wZW5zLmxheW91dC5sYXlvdXRbbl09e2NvbG9yOmEuY29sb3IsbnVtYmVyOmEubnVtYmVyfX12YXIgaT1lKCksbz1kKHIsdCk7aWYoT2JqZWN0LmtleXMoby5hbmltcykubGVuZ3RoPjB8fG8uZmFkaW5ncy5sZW5ndGg+MCl7dmFyIHU9dC5hbmltYXRpb24uY3VycmVudC5zdGFydDt0LmFuaW1hdGlvbi5jdXJyZW50PXtzdGFydDoobmV3IERhdGUpLmdldFRpbWUoKSxkdXJhdGlvbjp0LmFuaW1hdGlvbi5kdXJhdGlvbixhbmltczpvLmFuaW1zLGZhZGluZ3M6by5mYWRpbmdzLHNjYWxlczpvLnNjYWxlcyxleHRyYTpvLmV4dHJhfSx1fHxjKHQpfWVsc2UgdC5yZW5kZXJSQUYoKTtyZXR1cm4gaX12YXIgcD1yKGUoXCIuL3V0aWxcIikpLHY9cihlKFwiLi9tb3ZlXCIpKSxtPXtlYXNlSW5PdXRDdWJpYzpmdW5jdGlvbihlKXtyZXR1cm4gZTwuNT80KmUqZSplOihlLTEpKigyKmUtMikqKDIqZS0yKSsxfX07dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49W3RdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCkpO2lmKHQuYW5pbWF0aW9uLmVuYWJsZWQpcmV0dXJuIGYocFtcImRlZmF1bHRcIl0ucGFydGlhbEFwcGx5KGUsbiksdCk7dmFyIHI9ZS5hcHBseShudWxsLG4pO3JldHVybiB0LnJlbmRlclJBRigpLHJ9fX0se1wiLi9tb3ZlXCI6MTIsXCIuL3V0aWxcIjoxN31dLDQ6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19dmFyIGE9cihlKFwibWl0aHJpbFwiKSksaT1yKGUoXCIuL3ZpZXdcIikpLG89cihlKFwiLi9ib2FyZFwiKSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybntzZXQ6ZS5zZXQsZ2V0UGllY2VHcm91cHM6ZnVuY3Rpb24oKXtyZXR1cm4gb1tcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cHMoZS5kYXRhKX0sYXR0YWNoOmZ1bmN0aW9uKHQpe2FbXCJkZWZhdWx0XCJdLnJlbmRlcih0LCgwLGlbXCJkZWZhdWx0XCJdKShlKSwhMCl9LGRldGFjaDpmdW5jdGlvbigpe30sc29ydFBhaXJzOmUuc29ydFBhaXJzLHNvcnRTZXJpZXM6ZS5zb3J0U2VyaWVzLGFwaU1vdmU6ZS5hcGlNb3ZlLGFwaURyYXdNaWRkbGVFbmQ6ZS5hcGlEcmF3TWlkZGxlRW5kLHBsYXlPcGVuU2VyaWVzOmUucGxheU9wZW5TZXJpZXMscGxheU9wZW5QYWlyczplLnBsYXlPcGVuUGFpcnMscGxheUxlYXZlVGFrZW46ZS5wbGF5TGVhdmVUYWtlbixjYW5PcGVuU2VyaWVzOmUuY2FuT3BlblNlcmllcyxjYW5PcGVuUGFpcnM6ZS5jYW5PcGVuUGFpcnMsY2FuQ29sbGVjdE9wZW46ZS5jYW5Db2xsZWN0T3BlbixjYW5MZWF2ZVRha2VuOmUuY2FuTGVhdmVUYWtlbixzdG9wOmUuc3RvcCxnZXRQaWVjZUdyb3VwU2VyaWVzOmUuZ2V0UGllY2VHcm91cFNlcmllcyxnZXRQaWVjZUdyb3VwUGFpcnM6ZS5nZXRQaWVjZUdyb3VwUGFpcnMsZ2V0RmVuOmUuZ2V0RmVufX19LHtcIi4vYm9hcmRcIjo1LFwiLi92aWV3XCI6MTgsbWl0aHJpbDoyfV0sNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBpKGUsdCl7cmV0dXJuIGwoZSl8fHUoZSx0KXx8bygpfWZ1bmN0aW9uIG8oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX1mdW5jdGlvbiB1KGUsdCl7dmFyIG49W10scj0hMCxhPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIG8sdT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KG89dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKG8udmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaChsKXthPSEwLGk9bH1maW5hbGx5e3RyeXtyfHxudWxsPT11W1wicmV0dXJuXCJdfHx1W1wicmV0dXJuXCJdKCl9ZmluYWxseXtpZihhKXRocm93IGl9fXJldHVybiBufWZ1bmN0aW9uIGwoZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX1mdW5jdGlvbiBkKGUpe2lmKEYoZSkpe3ZhciB0PWUubWlkZGxlc1tuZVtcImRlZmF1bHRcIl0uZ29zdGVyZ2VdLG49ZWUoZSk7aWYobj1uLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4gaWVbXCJkZWZhdWx0XCJdLnNlcmllcyhuLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KSx0KX0pLG4ubGVuZ3RoPjApe3ZhciByPVkobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnBpZWNlc1t0XX0pfSkpO3JldHVybiBtKGUsbiksdWUobmVbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixyZVtcImRlZmF1bHRcIl0ub3BlblNlcmllcyxvZShyKSkpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1yZVtcImRlZmF1bHRcIl0ub3BlblNlcmllcywhMH19cmV0dXJuITF9ZnVuY3Rpb24gcyhlKXtpZihOKGUpKXt2YXIgdD1lLm1pZGRsZXNbbmVbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxuPWVlKGUpO2lmKG49bi5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIGllW1wiZGVmYXVsdFwiXS5wYWlycyhuLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KSx0KX0pLG4ubGVuZ3RoPjApe3ZhciByPVkobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnBpZWNlc1t0XX0pfSkpO3JldHVybiB2KGUsbiksdWUobmVbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixyZVtcImRlZmF1bHRcIl0ub3BlblBhaXJzLG9lKHIpKSksZS5hbmltYXRpb24uY3VycmVudC5oaW50PXJlW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzLCEwfX1yZXR1cm4hMX1mdW5jdGlvbiBjKGUsdCl7cmV0dXJuIHQ9YWVbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZSh0KS5waWVjZSwhKCFfKGUpfHwhTyhlLHQpKSYmKHVlKG5lW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIscmVbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW4pKSxlLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9cmVbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW4sITApfWZ1bmN0aW9uIGYoZSx0KXt2YXIgbj1uZVtcImRlZmF1bHRcIl0ubWlkZGxlQ291bnQ7dyhlLG4pLHAoZSx0KX1mdW5jdGlvbiBwKGUsdCl7XCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PWFlW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UodCkucGllY2UpLGUubWlkZGxlSG9sZGVyLnBpZWNlPXQsZyhlKX1mdW5jdGlvbiB2KGUsdCl7dmFyIG49dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLnBpZWNlc1t0XX0pfSkscj1ZKG4pO3VlKG5lW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUscmVbXCJkZWZhdWx0XCJdLm9wZW5QYWlycyxvZShyKSkpLHQuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSBlLnBpZWNlc1t0XX0pfSk7dmFyIGE9ZS5vcGVucy5wYWlycy5jb25jYXQobik7ZS5vcGVucy5wYWlycz1hLGUub3BlbnMucmVsYXlvdXQoZSl9ZnVuY3Rpb24gbShlLHQpe3ZhciBuPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pLHI9WShuKTt1ZShuZVtcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLHJlW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzLG9lKHIpKSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIGUucGllY2VzW3RdfSl9KTt2YXIgYT1lLm9wZW5zLnNlcmllcy5jb25jYXQobik7ZS5vcGVucy5zZXJpZXM9YSxlLm9wZW5zLnJlbGF5b3V0KGUpfWZ1bmN0aW9uIGcoZSl7dmFyIHQ9ZS5taWRkbGVIb2xkZXIua2V5LG49ZS5taWRkbGVIb2xkZXIucGllY2U7dCYmbiYmKGUucGllY2VzW3RdPW4sZS5sYXN0TW92ZT1bbmVbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50XSxlLm1pZGRsZUhvbGRlci5jdXJyZW50PSExLGUubWlkZGxlSG9sZGVyLmtleT1udWxsLGUubWlkZGxlSG9sZGVyLnBpZWNlPW51bGwpfWZ1bmN0aW9uIGgoZSx0LG4pe3ZhciByPVgoZSx0KTtpZihyLmxlbmd0aD4wKXt2YXIgYT1yWzBdLm1hcChmdW5jdGlvbih0LGEpe3ZhciBpPXJbMF0ubGVuZ3RoLWEtMSxvPW5lW1wiZGVmYXVsdFwiXS5kZWNCb2FyZEtleShuLDIqaSk7cmV0dXJuW3QsbyxlLnBpZWNlc1t0XV19KSxvPWEuZXZlcnkoZnVuY3Rpb24odCl7dmFyIG49aSh0LDMpLHI9KG5bMF0sblsxXSk7blsyXTtyZXR1cm4gbmVbXCJkZWZhdWx0XCJdLmlzQWxsQWxsb3dlZEJvYXJkS2V5KHIpJiZbcixuZVtcImRlZmF1bHRcIl0uZGVjQm9hcmRLZXkociwtMSldLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiFlLnBpZWNlc1t0XXx8YS5maWx0ZXIoZnVuY3Rpb24oZSl7dmFyIG49aShlLDMpLHI9blswXTtuWzFdLG5bMl07cmV0dXJuIHI9PT10fSkubGVuZ3RoPjB9KX0pO3JldHVybiEhbyYmKGEubWFwKGZ1bmN0aW9uKHQpe3ZhciBuPWkodCwzKSxyPW5bMF0sYT1uWzFdLG89blsyXTtyZXR1cm4gZGVsZXRlIGUucGllY2VzW3JdLFtyLGEsb119KS5tYXAoZnVuY3Rpb24odCl7dmFyIG49aSh0LDMpLHI9KG5bMF0sblsxXSksYT1uWzJdO2UucGllY2VzW3JdPWF9KSwhMCl9cmV0dXJuITF9ZnVuY3Rpb24geShlLHQsbil7aWYodD09PW58fCFlLnBpZWNlc1t0XSlyZXR1cm4hMTt2YXIgcj1lLnBpZWNlc1tuXTtyZXR1cm4gZS5waWVjZXNbbl09ZS5waWVjZXNbdF0sZS5waWVjZXNbdF09ciwhMH1mdW5jdGlvbiB3KGUsdCl7ZS5taWRkbGVzW25lW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF0tLSxlLm1pZGRsZUhvbGRlci5jdXJyZW50PSEwO3ZhciBuPXooZSk7cmV0dXJuIGUubWlkZGxlSG9sZGVyLmtleT1uLCEwfWZ1bmN0aW9uIGIoZSx0LG4pe2lmKCFufHxlLnBpZWNlc1tuXSl7dmFyIHI9eihlKTtuPXJ9cmV0dXJuIHVlKG5lW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUscmVbXCJkZWZhdWx0XCJdLmRyYXdNaWRkbGVFbmQpKSxlLm1pZGRsZUhvbGRlci5rZXk9bixnKGUpLCEwfWZ1bmN0aW9uIFAoZSx0KXtyZXR1cm4gdWUobmVbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxyZVtcImRlZmF1bHRcIl0uZHJhd01pZGRsZSkpLGUubWlkZGxlc1tuZVtcImRlZmF1bHRcIl0ubWlkZGxlQ291bnRdLS0sZS5taWRkbGVIb2xkZXIuY3VycmVudD0hMCwhMH1mdW5jdGlvbiBrKGUsdCxuKXtyZXR1cm4hZS5waWVjZXNbbl0mJih1ZShuZVtcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLHJlW1wiZGVmYXVsdFwiXS5kcmF3TGVmdCkpLGUucGllY2VzW25dPWUuZGlzY2FyZHNbbmVbXCJkZWZhdWx0XCJdLmRpc2NhcmRzWzFdXVswXSxlLmRpc2NhcmRzW25lW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1sxXV0uc2hpZnQoKSxcbiEwKX1mdW5jdGlvbiBPKGUsdCl7dmFyIG49JChlLHQpO2lmKCFuKXJldHVybiExO3VlKG5lW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUuZXZlbnRzLm1vdmUscmVbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW4pKTt2YXIgcj1uZVtcImRlZmF1bHRcIl0uZmluZFBvdihlLnBvdlNpZGUsZS50dXJuU2lkZSk7cmV0dXJuIGRlbGV0ZSBlLnBpZWNlc1tuXSxlLmRpc2NhcmRzW25lW1wiZGVmYXVsdFwiXS5kcmF3QnlQb3YocildLnVuc2hpZnQodCksITB9ZnVuY3Rpb24geChlLHQsbil7aWYobiYmbmVbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodCkmJm5lW1wiZGVmYXVsdFwiXS5pc0JvYXJkS2V5KG4pJiZCKGUsdCxuKSl7aWYoaChlLHQsbikpcmV0dXJuITA7aWYoeShlLHQsbikpcmV0dXJuITB9fWZ1bmN0aW9uIFMoZSx0KXtpZihuZVtcImRlZmF1bHRcIl0uaXNNaWRkbGVLZXkodCkmJlIoZSx0KSlyZXR1cm4gUChlLHQpLCEwfWZ1bmN0aW9uIEUoZSx0LG4pe2lmKG5lW1wiZGVmYXVsdFwiXS5pc01pZGRsZUtleSh0KSYmTChlLHQpKXJldHVybiBiKGUsdCxuKSwhMH1mdW5jdGlvbiBNKGUsdCxuKXtpZihuJiZuZVtcImRlZmF1bHRcIl0uaXNCb2FyZEtleShuKSYmbmVbXCJkZWZhdWx0XCJdLmlzRHJhd0xlZnRLZXkodCkmJkcoZSx0LG4pJiZrKGUsdCxuKSlyZXR1cm4gdWUobmVbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5tb3ZhYmxlLmV2ZW50cy5hZnRlcixyZVtcImRlZmF1bHRcIl0uZHJhd0xlZnQpKSwhMH1mdW5jdGlvbiBDKGUsdCxuKXtufHwobmVbXCJkZWZhdWx0XCJdLmlzTWlkZGxlS2V5KHQpP1MoZSx0KSYmVChlLHQpOm5lW1wiZGVmYXVsdFwiXS5pc0RyYXdMZWZ0S2V5KHQpJiZHKGUpJiZUKGUsdCkpfWZ1bmN0aW9uIEsoZSx0KXtlLnNlbGVjdGVkPyh0P2Uuc2VsZWN0ZWQhPT10JiYoeChlLGUuc2VsZWN0ZWQsdCl8fE0oZSxlLnNlbGVjdGVkLHQpfHxFKGUsZS5zZWxlY3RlZCx0KSk6RShlLGUuc2VsZWN0ZWQsdCksVChlLG51bGwpKTpEKGUsdCkmJlQoZSx0KX1mdW5jdGlvbiBUKGUsdCl7aWYoZS5zZWxlY3RlZD10LHQmJm5lW1wiZGVmYXVsdFwiXS5pc0JvYXJkS2V5KHQpKWlmKHEoZSx0KSl7dmFyIG49ZS5taWRkbGVzW25lW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV07ZS5vcGVuYWJsZS5kZXN0cz1pZVtcImRlZmF1bHRcIl0uY29tcHV0ZShlLm9wZW5zLGUucGllY2VzW3RdLG4pfWVsc2UgZS5vcGVuYWJsZS5kZXN0cz1bXTtlbHNlIGUub3BlbmFibGUuZGVzdHM9W119ZnVuY3Rpb24gQShlKXtyZXR1cm4gZS5wb3ZTaWRlPT09ZS50dXJuU2lkZX1mdW5jdGlvbiBEKGUsdCl7dmFyIG49ZS5waWVjZXNbdF07cmV0dXJuIG4mJmUubW92YWJsZS5ib2FyZH1mdW5jdGlvbiBCKGUsdCxuKXtyZXR1cm4gdCE9biYmRChlLHQpfWZ1bmN0aW9uIGooZSl7cmV0dXJuIEEoZSl9ZnVuY3Rpb24gUihlLHQpe3JldHVybiBqKGUpJiYhZS5taWRkbGVIb2xkZXIuY3VycmVudCYmbmVbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMscmVbXCJkZWZhdWx0XCJdLmRyYXdNaWRkbGUpfWZ1bmN0aW9uIEwoZSl7cmV0dXJuIGUubWlkZGxlSG9sZGVyLmN1cnJlbnR9ZnVuY3Rpb24gRyhlLHQsbil7cmV0dXJuIGooZSkmJiFMKGUpJiZuZVtcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxyZVtcImRlZmF1bHRcIl0uZHJhd0xlZnQpfWZ1bmN0aW9uIEYoZSl7cmV0dXJuIEEoZSkmJm5lW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLHJlW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzKX1mdW5jdGlvbiBOKGUpe3JldHVybiBBKGUpJiZuZVtcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxyZVtcImRlZmF1bHRcIl0ub3BlblBhaXJzKX1mdW5jdGlvbiBfKGUpe3JldHVybiBBKGUpJiZuZVtcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxyZVtcImRlZmF1bHRcIl0ubGVhdmVUYWtlbil9ZnVuY3Rpb24gSShlKXtyZXR1cm4gQShlKSYmbmVbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMscmVbXCJkZWZhdWx0XCJdLmNvbGxlY3RPcGVuKX1mdW5jdGlvbiBIKGUpe0soZSxudWxsKX1mdW5jdGlvbiBVKGUpe2UubW92YWJsZS5zaWRlPW51bGwsZS5tb3ZhYmxlLmRlc3RzPVtdLGUub3BlbmFibGUuZGVzdHM9W10sZS5tb3ZhYmxlLmJvYXJkPSExLEgoZSl9ZnVuY3Rpb24gcShlLHQpe3ZhciBuPWUucGllY2VzW3RdO3JldHVybiEoIW58fGUucG92U2lkZSE9PWUudHVyblNpZGUpfWZ1bmN0aW9uIFgoZSx0KXt2YXIgbj1lLm1pZGRsZXNbbmVbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxyPWVlKGUpO3JldHVybiByPXIuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlW2UubGVuZ3RoLTFdPT09dH0pLHI9ci5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIGllW1wiZGVmYXVsdFwiXS5zZXJpZXModC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUucGllY2VzW3RdfSksbil8fGllW1wiZGVmYXVsdFwiXS5wYWlycyh0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KSxuKX0pfWZ1bmN0aW9uIHooZSl7dmFyIHQ9bmVbXCJkZWZhdWx0XCJdLmFsbEFsbG93ZWRCb2FyZEtleXMuc2xpY2UoMSksbj1uZVtcImRlZmF1bHRcIl0uYWxsQWxsb3dlZEJvYXJkS2V5cy5zbGljZSgyKSxyPW5lW1wiZGVmYXVsdFwiXS5hbGxBbGxvd2VkQm9hcmRLZXlzLm1hcChmdW5jdGlvbihlLHIpe3JldHVybltlLHRbcl0sbltyXV19KS5maWx0ZXIoZnVuY3Rpb24odCl7dmFyIG49aSh0LDMpLHI9blswXSxhPW5bMV0sbz1uWzJdO3JldHVybiByJiZhJiZvJiYhZS5waWVjZXNbcl0mJiFlLnBpZWNlc1thXSYmIWUucGllY2VzW29dfSk7cmV0dXJuIHJbci5sZW5ndGgtMV1bMV19ZnVuY3Rpb24gJChlLHQpe3JldHVybiBuZVtcImRlZmF1bHRcIl0uYWxsQWxsb3dlZEJvYXJkS2V5cy5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIGUucGllY2VzW25dJiZuZVtcImRlZmF1bHRcIl0ucGllY2VFcXVhbChlLnBpZWNlc1tuXSx0KX0pWzBdfWZ1bmN0aW9uIEooZSx0LG4scil7dmFyIGE9VihlLHQsbik7aWYoIWEpcmV0dXJuIGE7dmFyIGk9bmVbXCJkZWZhdWx0XCJdLmRlY0JvYXJkS2V5KGEpO3JldHVybiBpIT09ciYmZS5waWVjZXNbaV0mJihhPWkpLG5lW1wiZGVmYXVsdFwiXS5ub3RBbGxvd2VkQm9hcmRLZXlzLmluZGV4T2YoYSkhPT0tMT9udWxsOmF9ZnVuY3Rpb24gVihlLHQsbil7aWYobnx8ZS5ib3VuZHMpe249bnx8ZS5ib3VuZHMoKTt2YXIgcj1NYXRoLmZsb29yKG5lW1wiZGVmYXVsdFwiXS5jb2x1bW5zKigodFswXS1uLmxlZnQpL24ud2lkdGgpKSxhPU1hdGguZmxvb3IobmVbXCJkZWZhdWx0XCJdLnJvd3MqKCh0WzFdLW4udG9wKS9uLmhlaWdodCkpO3JldHVybiBhPj0wJiZhPG5lW1wiZGVmYXVsdFwiXS5yb3dzJiZyPj0wJiZyPG5lW1wiZGVmYXVsdFwiXS5jb2x1bW5zP25lW1wiZGVmYXVsdFwiXS5wb3Mya2V5KFtyLGFdKTp2b2lkIDB9fWZ1bmN0aW9uIFkoZSl7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5rZXl9KS5qb2luKFwiXCIpfSkuam9pbihcIiBcIil9ZnVuY3Rpb24gUShlKXt2YXIgdD1lLm1pZGRsZXNbbmVbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSxuPWUud2l0aFRvcmUscj1aKGUpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gaWVbXCJkZWZhdWx0XCJdLnNlcmllcyhlLHQsbil9KTtyZXR1cm4gWShyKX1mdW5jdGlvbiBXKGUpe3ZhciB0PWUubWlkZGxlc1tuZVtcImRlZmF1bHRcIl0uZ29zdGVyZ2VdLG49WihlKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGllW1wiZGVmYXVsdFwiXS5wYWlycyhlLHQpfSk7cmV0dXJuIFkobil9ZnVuY3Rpb24gWihlKXtyZXR1cm4gZWUoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5waWVjZXNbdF19KX0pfWZ1bmN0aW9uIGVlKGUpe3ZhciB0PW5lW1wiZGVmYXVsdFwiXS5wb3Mya2V5KFtuZVtcImRlZmF1bHRcIl0uY29sdW1ucy0xLDBdKSxuPW5lW1wiZGVmYXVsdFwiXS5hbGxLZXlzLnNsaWNlKDEpLHI9bmVbXCJkZWZhdWx0XCJdLmFsbEtleXMubWFwKGZ1bmN0aW9uKGUsdCl7cmV0dXJuW2Usblt0XV19KS5yZWR1Y2UoZnVuY3Rpb24obixyKXt2YXIgYT1pKG4sMiksbz1hWzBdLHU9YVsxXSxsPWkociwyKSxkPWxbMF0scz1sWzFdO3JldHVybiBlLnBpZWNlc1tkXSYmby5wdXNoKGQpLChkJiYhZS5waWVjZXNbZF0mJnMmJiFlLnBpZWNlc1tzXXx8ZD09PXQpJiYwIT09by5sZW5ndGgmJih1LnB1c2gobyksbz1bXSksW28sdV19LFtbXSxbXV0pLGE9aShyLDIpLG89YVswXSx1PWFbMV07cmV0dXJuIDAhPT1vLmxlbmd0aCYmdS5wdXNoKG8pLHV9dmFyIHRlLG5lPXIoZShcIi4vdXRpbFwiKSkscmU9cihlKFwiLi9tb3ZlXCIpKSxhZT1yKGUoXCIuL3BpZWNlc1wiKSksaWU9cihlKFwiLi9vcGVuXCIpKSxvZT1uZVtcImRlZmF1bHRcIl0ud3JhcEdyb3VwLHVlPW5lW1wiZGVmYXVsdFwiXS5jYWxsVXNlckZ1bmN0aW9uO3QuZXhwb3J0cz0odGU9e3BsYXlPcGVuU2VyaWVzOmQscGxheU9wZW5QYWlyczpzLHBsYXlMZWF2ZVRha2VuOmMsYXBpRHJhd01pZGRsZUVuZDpwfSxhKHRlLFwiYXBpRHJhd01pZGRsZUVuZFwiLHApLGEodGUsXCJhcGlGb3JjZURyYXdNaWRkbGVFbmRcIixmKSxhKHRlLFwiYXBpRm9yY2VEcmF3TWlkZGxlRW5kXCIsZiksYSh0ZSxcInVzZXJNb3ZlXCIseCksYSh0ZSxcInVzZXJEcmF3TGVmdFwiLE0pLGEodGUsXCJ1c2VyQmVnaW5EcmF3TWlkZGxlXCIsUyksYSh0ZSxcInVzZXJFbmREcmF3TWlkZGxlXCIsRSksYSh0ZSxcInNlbGVjdFNxdWFyZVwiLEspLGEodGUsXCJzZWxlY3RUb3BcIixDKSxhKHRlLFwic2V0U2VsZWN0ZWRcIixUKSxhKHRlLFwiY2FuT3BlblNlcmllc1wiLEYpLGEodGUsXCJjYW5PcGVuUGFpcnNcIixOKSxhKHRlLFwiY2FuTGVhdmVUYWtlblwiLF8pLGEodGUsXCJjYW5Db2xsZWN0T3BlblwiLEkpLGEodGUsXCJzdG9wXCIsVSksYSh0ZSxcImNhbmNlbE1vdmVcIixIKSxhKHRlLFwiaXNEcm9wcGFibGVPcGVuc1wiLHEpLGEodGUsXCJmaW5kQm9hcmREcmFnR3JvdXBcIixYKSxhKHRlLFwiZ2V0S2V5QXREb21Qb3NcIixWKSxhKHRlLFwiZ2V0S2V5QXREb21Qb3NPblBpZWNlXCIsSiksYSh0ZSxcImdldFBpZWNlR3JvdXBzXCIsWiksYSh0ZSxcImdldFBpZWNlR3JvdXBTZXJpZXNcIixRKSxhKHRlLFwiZ2V0UGllY2VHcm91cFBhaXJzXCIsVyksdGUpfSx7XCIuL21vdmVcIjoxMixcIi4vb3BlblwiOjEzLFwiLi9waWVjZXNcIjoxNCxcIi4vdXRpbFwiOjE3fV0sNjpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX12YXIgYT1yKGUoXCJtZXJnZVwiKSksaT1yKGUoXCIuL3BpZWNlc1wiKSk7dC5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7aWYodClpZihhW1wiZGVmYXVsdFwiXS5yZWN1cnNpdmUoZSx0KSxlLmZlbil7ZS5zcGVjdGF0b3ImJihlLmZlbj1lLnBvdlNpZGVbMF0rZS5mZW4uc2xpY2UoMSkpLGUuYW5pbWF0aW9uSGludD8oZS5hbmltYXRpb24uY3VycmVudC5oaW50PWUuYW5pbWF0aW9uSGludCxkZWxldGUgZS5hbmltYXRpb25IaW50KTplLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9XCJcIjt2YXIgbj1pW1wiZGVmYXVsdFwiXS5yZWFkKGUuZmVuKTtlLnBpZWNlcz1uLnBpZWNlcyxlLmRpc2NhcmRzPW4uZGlzY2FyZHMsZS5vcGVucz1uLm9wZW5zLGUubWlkZGxlcz1uLm1pZGRsZXMsZGVsZXRlIGUuZmVufWVsc2UgZS5hbmltYXRpb24uY3VycmVudC5oaW50PVwiXCJ9fSx7XCIuL3BpZWNlc1wiOjE0LG1lcmdlOjF9XSw3OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fXZhciBhPXIoZShcIi4vdGFibGVcIikpLGk9cihlKFwiLi9ib2FyZFwiKSksbz1yKGUoXCIuL3NvcnRlclwiKSksdT1yKGUoXCIuL2RhdGFcIikpLGw9cihlKFwiLi9jb25maWd1cmVcIikpLGQ9cihlKFwiLi91dGlsXCIpKSxzPXIoZShcIi4vYW5pbVwiKSksYz1yKGUoXCIuL2RyYWdcIikpLGY9cihlKFwiLi9waWVjZXNcIikpO3QuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3RoaXMuZGF0YT0oMCx1W1wiZGVmYXVsdFwiXSkoZSksdGhpcy5kYXRhLmZsaXBQaWVjZT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7dCYmIXRoaXMuZmxpcHBhYmxlLmN1cnJlbnQub3JpZyYmKHRoaXMuZmxpcHBhYmxlLmN1cnJlbnQ9e29yaWc6ZX0sdGhpcy5yZW5kZXJSQUYoKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bi5mbGlwcGFibGUuY3VycmVudC5mbGlwPSEwLG4ucmVuZGVyUkFGKCksc2V0VGltZW91dChmdW5jdGlvbigpe3QuZmxpcD0hdC5mbGlwLG4uZmxpcHBhYmxlLmN1cnJlbnQ9e30sbi5yZW5kZXJSQUYoKX0sNjAwKX0sMTApKX0uYmluZCh0aGlzLmRhdGEpLHRoaXMuZ2V0RmVuPWZ1bmN0aW9uKCl7cmV0dXJuIGZbXCJkZWZhdWx0XCJdLndyaXRlKHQuZGF0YS5waWVjZXMpfSx0aGlzLmdldFBpZWNlR3JvdXBTZXJpZXM9ZnVuY3Rpb24oKXtyZXR1cm4gaVtcImRlZmF1bHRcIl0uZ2V0UGllY2VHcm91cFNlcmllcyh0LmRhdGEpfSx0aGlzLmdldFBpZWNlR3JvdXBQYWlycz1mdW5jdGlvbigpe3JldHVybiBpW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwUGFpcnModC5kYXRhKX0sdGhpcy5zZXQ9KDAsc1tcImRlZmF1bHRcIl0pKGxbXCJkZWZhdWx0XCJdLHRoaXMuZGF0YSksdGhpcy5hcGlNb3ZlPSgwLHNbXCJkZWZhdWx0XCJdKShhW1wiZGVmYXVsdFwiXS5hcGlNb3ZlLHRoaXMuZGF0YSksdGhpcy5hcGlEcmF3TWlkZGxlRW5kPSgwLHNbXCJkZWZhdWx0XCJdKShpW1wiZGVmYXVsdFwiXS5hcGlEcmF3TWlkZGxlRW5kLHRoaXMuZGF0YSksdGhpcy5wbGF5T3BlblNlcmllcz0oMCxzW1wiZGVmYXVsdFwiXSkoaVtcImRlZmF1bHRcIl0ucGxheU9wZW5TZXJpZXMsdGhpcy5kYXRhKSx0aGlzLnBsYXlPcGVuUGFpcnM9KDAsc1tcImRlZmF1bHRcIl0pKGlbXCJkZWZhdWx0XCJdLnBsYXlPcGVuUGFpcnMsdGhpcy5kYXRhKSx0aGlzLnBsYXlMZWF2ZVRha2VuPSgwLHNbXCJkZWZhdWx0XCJdKShpW1wiZGVmYXVsdFwiXS5wbGF5TGVhdmVUYWtlbix0aGlzLmRhdGEpLHRoaXMuc29ydFBhaXJzPSgwLHNbXCJkZWZhdWx0XCJdKShvW1wiZGVmYXVsdFwiXS5zb3J0UGFpcnMsdGhpcy5kYXRhKSx0aGlzLnNvcnRTZXJpZXM9KDAsc1tcImRlZmF1bHRcIl0pKG9bXCJkZWZhdWx0XCJdLnNvcnRTZXJpZXMsdGhpcy5kYXRhKSx0aGlzLmNhbkxlYXZlVGFrZW49ZFtcImRlZmF1bHRcIl0ucGFydGlhbChpW1wiZGVmYXVsdFwiXS5jYW5MZWF2ZVRha2VuLHRoaXMuZGF0YSksdGhpcy5jYW5Db2xsZWN0T3Blbj1kW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGlbXCJkZWZhdWx0XCJdLmNhbkNvbGxlY3RPcGVuLHRoaXMuZGF0YSksdGhpcy5jYW5PcGVuU2VyaWVzPWRbXCJkZWZhdWx0XCJdLnBhcnRpYWwoaVtcImRlZmF1bHRcIl0uY2FuT3BlblNlcmllcyx0aGlzLmRhdGEpLHRoaXMuY2FuT3BlblBhaXJzPWRbXCJkZWZhdWx0XCJdLnBhcnRpYWwoaVtcImRlZmF1bHRcIl0uY2FuT3BlblBhaXJzLHRoaXMuZGF0YSksdGhpcy5zdG9wPSgwLHNbXCJkZWZhdWx0XCJdKShmdW5jdGlvbihlKXtpW1wiZGVmYXVsdFwiXS5zdG9wKGUpLGNbXCJkZWZhdWx0XCJdLmNhbmNlbChlKX0sdGhpcy5kYXRhKSx0aGlzLm9udW5sb2FkPWZ1bmN0aW9uKCl7fX19LHtcIi4vYW5pbVwiOjMsXCIuL2JvYXJkXCI6NSxcIi4vY29uZmlndXJlXCI6NixcIi4vZGF0YVwiOjgsXCIuL2RyYWdcIjo5LFwiLi9waWVjZXNcIjoxNCxcIi4vc29ydGVyXCI6MTUsXCIuL3RhYmxlXCI6MTYsXCIuL3V0aWxcIjoxN31dLDg6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19dmFyIGE9KHIoZShcIm1lcmdlXCIpKSxyKGUoXCIuL3BpZWNlc1wiKSkpLGk9cihlKFwiLi9jb25maWd1cmVcIikpO3QuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD17cG92U2lkZTpcImVhc3RcIix0dXJuU2lkZTpcImVhc3RcIixsYXN0TW92ZTpudWxsLHdpdGhUb3JlOiExLHBpZWNlczphW1wiZGVmYXVsdFwiXS5yZWFkQm9hcmQoYVtcImRlZmF1bHRcIl0ubWl4ZWQpLGRpc2NhcmRzOmFbXCJkZWZhdWx0XCJdLnJlYWREaXNjYXJkcyhhW1wiZGVmYXVsdFwiXS5pbml0aWFsRGlzY2FyZHMsXCJlYXN0XCIpLG9wZW5zOmFbXCJkZWZhdWx0XCJdLnJlYWRPcGVuR3JvdXBzKGFbXCJkZWZhdWx0XCJdLmluaXRpYWxPcGVuR3JvdXBzKSxtaWRkbGVzOmFbXCJkZWZhdWx0XCJdLnJlYWRNaWRkbGVzKGFbXCJkZWZhdWx0XCJdLmluaXRpYWxNaWRkbGVzKSxzZWxlY3RlZDpudWxsLG1pZGRsZUhvbGRlcjp7Y3VycmVudDohMSxrZXk6bnVsbCxwaWVjZTpudWxsfSx2aWV3T25seTohMSxhbmltYXRpb246e2VuYWJsZWQ6ITAsZHVyYXRpb246NTAwLGN1cnJlbnQ6e319LGRyYWdnYWJsZTp7ZW5hYmxlZDohMCxkaXN0YW5jZTozLGN1cnJlbnQ6e319LG1vdmFibGU6e2JvYXJkOiEwLGZyZWU6ITAsZXZlbnRzOnthZnRlcjpmdW5jdGlvbihlLHQpe319fSxmbGlwcGFibGU6e2VuYWJsZWQ6ITAsY3VycmVudDp7fX0sb3BlbmFibGU6e2Rlc3RzOltdfSxldmVudHM6e21vdmU6ZnVuY3Rpb24oZSx0KXt9fX07cmV0dXJuKDAsaVtcImRlZmF1bHRcIl0pKHQsZXx8e30pLHR9fSx7XCIuL2NvbmZpZ3VyZVwiOjYsXCIuL3BpZWNlc1wiOjE0LG1lcmdlOjF9XSw5OltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0LG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpwW1wiZGVmYXVsdFwiXS5yb3dzLGE9YXJndW1lbnRzLmxlbmd0aD40JiZ2b2lkIDAhPT1hcmd1bWVudHNbNF0/YXJndW1lbnRzWzRdOnBbXCJkZWZhdWx0XCJdLmNvbHVtbnM7cmV0dXJue2xlZnQ6dC5sZWZ0K3Qud2lkdGgqblswXS9hLHRvcDp0LnRvcCt0LmhlaWdodCpuWzFdL3Isd2lkdGg6dC53aWR0aC9hLGhlaWdodDp0LmhlaWdodC9yfX1mdW5jdGlvbiBpKGUsdCl7aWYoKHZvaWQgMD09PXQuYnV0dG9ufHwwPT09dC5idXR0b24pJiYodC5zdG9wUHJvcGFnYXRpb24oKSx0LnByZXZlbnREZWZhdWx0KCksIWUudmlld09ubHkpKXtzPXQudGFyZ2V0O3ZhciBuPWUuc2VsZWN0ZWQscj1wW1wiZGVmYXVsdFwiXS5ldmVudFBvc2l0aW9uKHQpLGk9ZS5ib2FyZEJvdW5kcygpLHU9ZS5vcGVuc0JvdW5kcygpLGw9ZS50b3BCb3VuZHMoKSxkPWNbXCJkZWZhdWx0XCJdLmdldEtleUF0RG9tUG9zT25QaWVjZShlLHIsaSk7Y1tcImRlZmF1bHRcIl0uc2VsZWN0U3F1YXJlKGUsZCksZHx8KGQ9ZltcImRlZmF1bHRcIl0uZ2V0RHJhd0tleUF0RG9tUG9zKGUscixsKSkmJmNbXCJkZWZhdWx0XCJdLnNlbGVjdFRvcChlLGQsbiksIWQmJm4mJigoZD1mW1wiZGVmYXVsdFwiXS5nZXRPcGVuc0tleUF0RG9tUG9zKGUscix1KSk/ZltcImRlZmF1bHRcIl0uZHJvcE9wZW5zKGUsbixkKTooZD1mW1wiZGVmYXVsdFwiXS5nZXREaXNjYXJkS2V5QXREb21Qb3MoZSxyLGwpKSYmZltcImRlZmF1bHRcIl0uZHJvcFRvcChlLG4sZCkpO3ZhciB2PWUuc2VsZWN0ZWQ9PT1kO2lmKHYmJmZbXCJkZWZhdWx0XCJdLmlzRHJhZ2dhYmxlKGUsZCkpe3ZhciBtPXBbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkoZCk/YShlLGkscFtcImRlZmF1bHRcIl0ua2V5MnBvcyhkKSk6YShlLGwscFtcImRlZmF1bHRcIl0udG9wS2V5MnBvcyhkKSxwW1wiZGVmYXVsdFwiXS50b3BSb3dzLHBbXCJkZWZhdWx0XCJdLnRvcENvbHVtbnMpLGc9Y1tcImRlZmF1bHRcIl0uZmluZEJvYXJkRHJhZ0dyb3VwKGUsZClbMF07ZS5kcmFnZ2FibGUuY3VycmVudD17ZHJhZ0dyb3VwOmcsb3JpZzpkLHJlbDpyLGVwb3M6cixwb3M6WzAsMF0sZGVjOltyWzBdLShtLmxlZnQrbS53aWR0aC8yKSxyWzFdLShtLnRvcCttLmhlaWdodC8yKV0sYm9hcmRCb3VuZHM6aSxvcGVuc0JvdW5kczp1LHRvcEJvdW5kczpsLHN0YXJ0ZWQ6ITF9fW8oZSl9fWZ1bmN0aW9uIG8oZSl7cFtcImRlZmF1bHRcIl0ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5kcmFnZ2FibGUuY3VycmVudDt0Lm9yaWcmJighdC5zdGFydGVkJiZwW1wiZGVmYXVsdFwiXS5kaXN0YW5jZSh0LmVwb3MsdC5yZWwpPj1lLmRyYWdnYWJsZS5kaXN0YW5jZSYmKHQuc3RhcnRlZD0hMCksdC5zdGFydGVkJiYodC5wb3M9W3QuZXBvc1swXS10LnJlbFswXSx0LmVwb3NbMV0tdC5yZWxbMV1dLHQub3Zlcj1jW1wiZGVmYXVsdFwiXS5nZXRLZXlBdERvbVBvc09uUGllY2UoZSx0LmVwb3MsdC5ib2FyZEJvdW5kcyx0Lm9yaWcpLCF0Lm92ZXImJnBbXCJkZWZhdWx0XCJdLmlzQm9hcmRLZXkodC5vcmlnKSYmKHQub3Zlcj1mW1wiZGVmYXVsdFwiXS5nZXRPcGVuc0tleUF0RG9tUG9zKGUsdC5lcG9zLHQub3BlbnNCb3VuZHMpfHxmW1wiZGVmYXVsdFwiXS5nZXREaXNjYXJkS2V5QXREb21Qb3MoZSx0LmVwb3MsdC50b3BCb3VuZHMpKSkpLGUucmVuZGVyKCksdC5vcmlnJiZvKGUpfSl9ZnVuY3Rpb24gdShlLHQpe2UuZHJhZ2dhYmxlLmN1cnJlbnQub3JpZyYmKGUuZHJhZ2dhYmxlLmN1cnJlbnQuZXBvcz1wW1wiZGVmYXVsdFwiXS5ldmVudFBvc2l0aW9uKHQpKX1mdW5jdGlvbiBsKGUsdCl7dmFyIG49ZS5kcmFnZ2FibGUscj1uLmN1cnJlbnQ/bi5jdXJyZW50Lm9yaWc6bnVsbDtpZihyKXt2YXIgYT1uLmN1cnJlbnQub3ZlcjtuLmN1cnJlbnQuc3RhcnRlZCYmKGNbXCJkZWZhdWx0XCJdLnNldFNlbGVjdGVkKGUsbnVsbCksY1tcImRlZmF1bHRcIl0udXNlck1vdmUoZSxyLGEpfHxmW1wiZGVmYXVsdFwiXS5kcm9wT3BlbnMoZSxyLGEpfHxmW1wiZGVmYXVsdFwiXS5kcm9wVG9wKGUscixhKXx8Y1tcImRlZmF1bHRcIl0udXNlckRyYXdMZWZ0KGUscixhKXx8Y1tcImRlZmF1bHRcIl0udXNlckVuZERyYXdNaWRkbGUoZSxyLGEpKSxuLmN1cnJlbnQ9e319fWZ1bmN0aW9uIGQoZSl7ZS5kcmFnZ2FibGUuY3VycmVudC5vcmlnJiYoZS5kcmFnZ2FibGUuY3VycmVudD17fSxjW1wiZGVmYXVsdFwiXS5zZWxlY3RTcXVhcmUoZSxudWxsKSl9dmFyIHMsYz1yKGUoXCIuL2JvYXJkXCIpKSxmPXIoZShcIi4vdGFibGVcIikpLHA9cihlKFwiLi91dGlsXCIpKTt0LmV4cG9ydHM9e3N0YXJ0OmksbW92ZTp1LGVuZDpsLGNhbmNlbDpkfX0se1wiLi9ib2FyZFwiOjUsXCIuL3RhYmxlXCI6MTYsXCIuL3V0aWxcIjoxN31dLDEwOltmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e1wiZGVmYXVsdFwiOmV9fWZ1bmN0aW9uIGEoZSx0KXt0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSx1W1wiZGVmYXVsdFwiXS5jYW5jZWxNb3ZlKGUpO3ZhciBuPWxbXCJkZWZhdWx0XCJdLmV2ZW50UG9zaXRpb24odCkscj1lLmJvYXJkQm91bmRzKCksYT11W1wiZGVmYXVsdFwiXS5nZXRLZXlBdERvbVBvc09uUGllY2UoZSxuLHIpLGk9ZS5waWVjZXNbYV07ZS5mbGlwUGllY2UoYSxpKX1mdW5jdGlvbiBpKGUsdCl7fWZ1bmN0aW9uIG8oZSx0KXt9dmFyIHU9cihlKFwiLi9ib2FyZFwiKSksbD1yKGUoXCIuL3V0aWxcIikpO3QuZXhwb3J0cz17c3RhcnQ6YSxtb3ZlOmksZW5kOm99fSx7XCIuL2JvYXJkXCI6NSxcIi4vdXRpbFwiOjE3fV0sMTE6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlKXt2YXIgdD1uZXcgaVtcImRlZmF1bHRcIl0oZSk7cmV0dXJuKDAsbFtcImRlZmF1bHRcIl0pKHQpfXZhciBpPXIoZShcIi4vY3RybFwiKSksbz1yKGUoXCIuL3V0aWxcIikpLHU9cihlKFwiLi9tb3ZlXCIpKSxsPXIoZShcIi4vYXBpXCIpKSxkPXIoZShcIi4vYW5pbVwiKSkscz1yKGUoXCIuL2RyYWdcIikpO3QuZXhwb3J0cz1hLHQuZXhwb3J0cy5jb250cm9sbGVyPWlbXCJkZWZhdWx0XCJdLHQuZXhwb3J0cy51dGlsPW9bXCJkZWZhdWx0XCJdLHQuZXhwb3J0cy5tb3ZlPXVbXCJkZWZhdWx0XCJdLHQuZXhwb3J0cy5hbmltPWRbXCJkZWZhdWx0XCJdLHQuZXhwb3J0cy5kcmFnPXNbXCJkZWZhdWx0XCJdfSx7XCIuL2FuaW1cIjozLFwiLi9hcGlcIjo0LFwiLi9jdHJsXCI6NyxcIi4vZHJhZ1wiOjksXCIuL21vdmVcIjoxMixcIi4vdXRpbFwiOjE3fV0sMTI6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1cImRtXCIsYT1cImRsXCIsaT1cImRkXCIsbz1cImx0XCIsdT1cInNzXCIsbD1cIm9zXCIsZD1cIm9wXCIscz1cImNvXCIsYz1cImRvc1wiLGY9XCJkb3BcIixwPVwiZGRzXCIsdj1cImRkcFwiLG09XCJsXCIsZz1cInJcIixoPVwicFwiO3QuZXhwb3J0cz17ZHJhd01pZGRsZTpyLGRyYXdMZWZ0OmEsZGlzY2FyZDppLGxlYXZlVGFrZW46byxzaWduOnUsb3BlblNlcmllczpsLG9wZW5QYWlyczpkLGNvbGxlY3RPcGVuOnMsZHJvcE9wZW5TZXJpZXM6Yyxkcm9wT3BlblBhaXJzOmYsZHJvcExlZnQ6bSxkcm9wUmlnaHQ6Zyxkcm9wUmVwbGFjZTpoLGRpc2NhcmRFbmRTZXJpZXM6cCxkaXNjYXJkRW5kUGFpcnM6dn19LHt9XSwxMzpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUsdCl7cmV0dXJuIHUoZSl8fG8oZSx0KXx8aSgpfWZ1bmN0aW9uIGkoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX1mdW5jdGlvbiBvKGUsdCl7dmFyIG49W10scj0hMCxhPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIG8sdT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KG89dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKG8udmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaChsKXthPSEwLGk9bH1maW5hbGx5e3RyeXtyfHxudWxsPT11W1wicmV0dXJuXCJdfHx1W1wicmV0dXJuXCJdKCl9ZmluYWxseXtpZihhKXRocm93IGl9fXJldHVybiBufWZ1bmN0aW9uIHUoZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX1mdW5jdGlvbiBsKGUsdCl7cmV0dXJuIGUubGVuZ3RoPT09dC5sZW5ndGgmJmUuZXZlcnkoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZT09PXRbbl19KX1mdW5jdGlvbiBkKGUsdCl7cmV0dXJuIHQuZXZlcnkoZnVuY3Rpb24odCxuKXtyZXR1cm4gdC5jb2xvcj09PWVbbl19KX1mdW5jdGlvbiBzKGUsdCl7aWYoZS5sZW5ndGg8MylyZXR1cm4hMTt2YXIgbj1lLmxlbmd0aCxyPWVbMF0uY29sb3IsYT1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5rZXl9KSxpPWEuc2xpY2UoMCkucmV2ZXJzZSgpLG89d1tcImRlZmF1bHRcIl0uc2VyaWVzQnlDb2xvcihyKTt0JiYobz1vLnNsaWNlKDApLG8ucHVzaChvWzBdKSk7Zm9yKHZhciB1PTA7dTw9by5sZW5ndGgtbjt1Kyspe3ZhciBkPW8uc2xpY2UodSx1K24pO2lmKGwoZCxhKXxsKGQsaSkpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gYyhlKXt2YXIgdD1lLmxlbmd0aCxuPWVbMF0ubnVtYmVyO3JldHVybiEhKDM9PT10fDQ9PT10KSYmKCEhZS5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gZS5udW1iZXI9PT1ufSkmJmIuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gZCh0LnNsaWNlKDAsZS5sZW5ndGgpLGUpfSkpfWZ1bmN0aW9uIGYoZSx0KXt2YXIgbj13W1wiZGVmYXVsdFwiXS5tYWtlUGllY2UodC5jLHQubik7cmV0dXJuIG4uaXNGYWtlPSEwLHdbXCJkZWZhdWx0XCJdLnBpZWNlRmFrZShlKT9uOmV9ZnVuY3Rpb24gcChlLHQpe3JldHVybiFlLmlzRmFrZSYmZS5rZXk9PT10LmtleX1mdW5jdGlvbiB2KGUsdCl7ZnVuY3Rpb24gbihlLHQpe3JldHVybiBlLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gdC5pbmRleE9mKGUpPDB9KX1mdW5jdGlvbiByKGUsdCl7cmV0dXJuIGUua2V5PT09dC5rZXl9ZnVuY3Rpb24gaShlLHQpe3ZhciByPVtcInJcIixcImdcIixcImJcIixcImxcIl0sYT1lLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hcChlLHQpfSksaT1uKHIsYS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY30pKTtpZihpLmxlbmd0aDwxKXJldHVybiBlO2lmKGEubGVuZ3RoPDEpcmV0dXJuIGU7aWYoIShhLmxlbmd0aDxlLmxlbmd0aCkpcmV0dXJuIGU7dmFyIG89aVswXSx1PWFbMF0ubixsPXdbXCJkZWZhdWx0XCJdLm1ha2VQaWVjZShvLHUpO3JldHVybiBhLnB1c2gobCksYX1mdW5jdGlvbiBvKGUsdCl7dmFyIG47aWYoMD09PWUubGVuZ3RoKXJldHVybiBlO2lmKGUubGVuZ3RoPDMpcmV0dXJuIGU7dmFyIGk9YShlLDMpLHU9aVswXSxsPWlbMV0sZD1pWzJdLHM9W3UsbCxkXTtpZihuPWUuc2xpY2UoMyxlLmxlbmd0aCkscCh1LHQpKXIod1tcImRlZmF1bHRcIl0ucGllY2VVcChsKSxkKT9zPVt3W1wiZGVmYXVsdFwiXS5waWVjZURvd24obCksbCxkXTpyKHdbXCJkZWZhdWx0XCJdLnBpZWNlRG93bihsKSxkKSYmKHM9W3dbXCJkZWZhdWx0XCJdLnBpZWNlVXAobCksbCxkXSk7ZWxzZSBpZihwKGwsdCkpcih3W1wiZGVmYXVsdFwiXS5waWVjZVVwKHdbXCJkZWZhdWx0XCJdLnBpZWNlVXAodSkpLGQpP3M9W3Usd1tcImRlZmF1bHRcIl0ucGllY2VVcCh1KSxkXTpyKHdbXCJkZWZhdWx0XCJdLnBpZWNlRG93bih3W1wiZGVmYXVsdFwiXS5waWVjZURvd24odSkpLGQpJiYocz1bdSx3W1wiZGVmYXVsdFwiXS5waWVjZURvd24odSksZF0pO2Vsc2V7aWYoIXAoZCx0KSlyZXR1cm4gbj1vKGUuc2xpY2UoMSxlLmxlbmd0aCksdCksbi51bnNoaWZ0KGVbMF0pLG47cih3W1wiZGVmYXVsdFwiXS5waWVjZVVwKHUpLGwpP3M9W3UsbCx3W1wiZGVmYXVsdFwiXS5waWVjZVVwKGwpXTpyKHdbXCJkZWZhdWx0XCJdLnBpZWNlRG93bih1KSxsKSYmKHM9W3UsbCx3W1wiZGVmYXVsdFwiXS5waWVjZURvd24obCldKX1yZXR1cm4gcy5jb25jYXQobil9ZnVuY3Rpb24gdShlLHQpe2lmKDIhPWUubGVuZ3RoKXJldHVybiBlO3ZhciBuPWEoZSwyKSxyPW5bMF0saT1uWzFdO3JldHVybiBwKHIsdCk/W2ksaV06cChpLHQpP1tyLHJdOmV9aWYoZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHAoZSx0KX0pLmxlbmd0aD4xKXJldHVybiBlO2lmKGUubGVuZ3RoPDMpcmV0dXJuIHUoZSx0KTt2YXIgbD1lLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hcChlLHQpfSk7cmV0dXJuIGwuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIGUubj09PWxbMF0ubn0pP2koZSx0KTpsLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBlLmM9PT1sWzBdLmN9KT9vKGUsdCk6ZX1mdW5jdGlvbiBtKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxyPXdbXCJkZWZhdWx0XCJdLnBpZWNlVXAodCksYT1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZihlLHIpfSksaT12KGEscik7cmV0dXJuIHMoaSxuKXxjKGkpfWZ1bmN0aW9uIGcoZSx0KXtpZigyIT09ZS5sZW5ndGgpcmV0dXJuITE7dmFyIG49d1tcImRlZmF1bHRcIl0ucGllY2VVcCh0KSxyPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBmKGUsbil9KSxpPXYocixuKSxvPWEoaSwyKSx1PW9bMF0sbD1vWzFdO3JldHVybiB1LmtleT09PWwua2V5fWZ1bmN0aW9uIGgoZSx0LG4pe3ZhciByPVtdLGE9d1tcImRlZmF1bHRcIl0ucGllY2VVcChuKTtyZXR1cm4gdD1mKHQsYSksZS5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihpLG8pe3ZhciB1PWkuc2xpY2UoMCksbD1pLnNsaWNlKDApO3Uuc3BsaWNlKDAsMCx0KSxsLnNwbGljZShpLmxlbmd0aCwwLHQpLG0odSxuKSYmci5wdXNoKHdbXCJkZWZhdWx0XCJdLmdldE9wZW5TZXJpZUtleUZyb21Hcm91cEluZGV4KGUsbywwKSksbShsLG4pJiZyLnB1c2god1tcImRlZmF1bHRcIl0uZ2V0T3BlblNlcmllS2V5RnJvbUdyb3VwSW5kZXgoZSxvLGkubGVuZ3RoKzEpKTt2YXIgZD1pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcChlLGEpP3Q6ZX0pO2lmKG0oZCxuKSl7dmFyIHM7aS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7cChlLGEpJiYocz10KX0pLHIucHVzaCh3W1wiZGVmYXVsdFwiXS5nZXRPcGVuU2VyaWVLZXlGcm9tR3JvdXBJbmRleChlLG8scysxKSl9fSksZS5wYWlycy5mb3JFYWNoKGZ1bmN0aW9uKGksbyl7dmFyIHU9aS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHAoZSxhKT90OmV9KTtpZihnKHUsbikpe3ZhciBsPXkoaSxhKTtyLnB1c2god1tcImRlZmF1bHRcIl0uZ2V0T3BlblBhaXJLZXlGcm9tR3JvdXBJbmRleChlLG8sbCkpfX0pLHJ9ZnVuY3Rpb24geShlLHQpe3ZhciBuO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSxyKXtwKGUsdCkmJihuPXIpfSksbn1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuW1wiZGVmYXVsdFwiXT12b2lkIDA7dmFyIHc9cihlKFwiLi9waWVjZXNcIikpLGI9ZnVuY3Rpb24oKXt2YXIgZT13W1wiZGVmYXVsdFwiXS5jb2xvcnMsdD1bXTtmb3IodmFyIG4gaW4gZSlmb3IodmFyIHIgaW4gZSlmb3IodmFyIGEgaW4gZSlmb3IodmFyIGkgaW4gZSluIT09ciYmbiE9PWEmJm4hPT1pJiZyIT09YSYmciE9PWkmJmEhPT1pJiZ0LnB1c2goW2Vbbl0sZVtyXSxlW2FdLGVbaV1dKTtyZXR1cm4gdH0oKSxQPXtjb21wdXRlOmgsc2VyaWVzOm0scGFpcnM6ZyxmaW5kT2tleUluZGV4Onl9O25bXCJkZWZhdWx0XCJdPVB9LHtcIi4vcGllY2VzXCI6MTR9XSwxNDpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUsdCl7cmV0dXJuIHUoZSl8fG8oZSx0KXx8aSgpfWZ1bmN0aW9uIGkoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX1mdW5jdGlvbiBvKGUsdCl7dmFyIG49W10scj0hMCxhPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIG8sdT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KG89dS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKG8udmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaChsKXthPSEwLGk9bH1maW5hbGx5e3RyeXtyfHxudWxsPT11W1wicmV0dXJuXCJdfHx1W1wicmV0dXJuXCJdKCl9ZmluYWxseXtpZihhKXRocm93IGl9fXJldHVybiBufWZ1bmN0aW9uIHUoZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX1mdW5jdGlvbiBsKGUpe3ZhciB0PVtdO2Zvcih2YXIgbiBpbiBCKXQucHVzaChFKGUsbikua2V5KTtyZXR1cm4gdH1mdW5jdGlvbiBkKGUpe3ZhciB0PXswOjAsMToxLDI6MiwzOjMsNDo0LDU6NSw2OjYsNzo3LDg6OCw5Ojl9LG49dFtlWzBdXSxyPXRbZVsxXV07cmV0dXJuIHZvaWQgMD09PXI/dm9pZCAwPT09bj97bGVmdDplLnNsaWNlKDEpfTp7bnVtYmVyOm4sbGVmdDplLnNsaWNlKDEpfTp7bnVtYmVyOjEwKm4rcixsZWZ0OmUuc2xpY2UoMil9fWZ1bmN0aW9uIHMoZSl7dmFyIHQ9LyhbbHxyfHBdKShcXGRcXGQ/KS8sbj1lLm1hdGNoKHQpLHI9blsxXSxhPXBhcnNlSW50KG5bMl0pO3JldHVybnt0eXBlOnIsZ3JvdXBJbmRleDphfX1mdW5jdGlvbiBjKGUpe3ZhciB0PWVbMF0sbj1lWzFdLHI9ZVsyXSxhPTI7cmV0dXJuIERbdF0/KEJbbityXSYmKG4rPXIsYT0zKSx7cGllY2U6RSh0LG4pLGxlZnQ6ZS5zbGljZShhKX0pOntsZWZ0OmUuc2xpY2UoMSl9fWZ1bmN0aW9uIGYoZSl7dmFyIHQ9W10sbj1bXTtmb3IoZSs9XCJcXG5cIjtlLmxlbmd0aD4wOyl7dmFyIHI9YyhlKTtyLnBpZWNlP24ucHVzaChyLnBpZWNlKToobi5sZW5ndGg+MCYmdC5wdXNoKG4pLG49W10pLGU9ci5sZWZ0fXJldHVybiB0fWZ1bmN0aW9uIHAoZSl7Zm9yKHZhciB0PVtdLG49MDtlLmxlbmd0aD4wOyl7dmFyIHI9YyhlKTtyLnBpZWNlJiYodFtuXT1yLnBpZWNlKSxuKyssZT1yLmxlZnR9cmV0dXJuIHR9ZnVuY3Rpb24gdihlKXt2YXIgdD17fTtlPXAoZSk7Zm9yKHZhciBuPTAscj0wO3I8ZS5sZW5ndGg7cisrKXtpZihlW3JdKXtmb3IoO248MTAwJiYhQVtcImRlZmF1bHRcIl0uaXNBbGxvd2VkQm9hcmRLZXkoQVtcImRlZmF1bHRcIl0uZW5jb2RlS2V5KG4sXCJiXCIpKTspbisrO3RbQVtcImRlZmF1bHRcIl0uZW5jb2RlS2V5KG4sXCJiXCIpXT1lW3JdLG4rK31uKyt9cmV0dXJuIHR9ZnVuY3Rpb24gbShlLHQpe2U9ZS5zcGxpdChcIiBcIik7dmFyIG49e307cmV0dXJuIEFbXCJkZWZhdWx0XCJdLmFsbFNpZGVzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gQVtcImRlZmF1bHRcIl0uZmluZFBvdih0LGUpfSkuZm9yRWFjaChmdW5jdGlvbih0LHIpe3ZhciBhPXAoZVtyXXx8XCJcIik7bltBW1wiZGVmYXVsdFwiXS5kaXNjYXJkQnlQb3YodCldPWF9KSxufWZ1bmN0aW9uIGcoZSl7dmFyIHQ9ZS5zcGxpdChcIi9cIiksbj1hKHQsMikscj1uWzBdLGk9blsxXTtyPWYociksaT1mKGkpO3ZhciBvPWgocixpKTtyZXR1cm57c2VyaWVzOnIscGFpcnM6aSxsYXlvdXQ6byxyZWxheW91dDpmdW5jdGlvbihlKXtlLm9wZW5zLmxheW91dD1oKGUub3BlbnMuc2VyaWVzLGUub3BlbnMucGFpcnMpfX19ZnVuY3Rpb24gaChlLHQpe3ZhciBuLHIsYSxpLG8sdT17fSxsPXtzZXJpZXM6e30scGFpcnM6e319LGQ9W10scz0wO2ZvcihuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBjPWVbbl07aT0oZFtzXXx8MSktMSxvPXMsbC5zZXJpZXNbQVtcImRlZmF1bHRcIl0ubWluaVBvczJrZXkoW2ksb10pXT1uO2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKWE9ZFtzXXx8MSxyPUFbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFthLHNdKSx1W3JdPWNbZl0sZFtzXT1hKzE7ZFtzXSs9MixzKysscz49QVtcImRlZmF1bHRcIl0ubWluaVJvd3MmJihzPTApfWZvcihkPVtdLG49MCxmPTAscj0wLGE9MCxzPTAsbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcD10W25dO2ZvcihpPShkW3NdfHxBW1wiZGVmYXVsdFwiXS5taW5pQ29sdW1ucy0xKS0xLG89cyxsLnBhaXJzW0FbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KFtpLG9dKV09bixmPXAubGVuZ3RoLTE7Zj49MDtmLS0pYT1kW3NdfHxBW1wiZGVmYXVsdFwiXS5taW5pQ29sdW1ucy0xLHI9QVtcImRlZmF1bHRcIl0ubWluaVBvczJrZXkoW2Esc10pLHVbcl09cFtmXSxkW3NdPWEtMTtkW3NdLT0xLHMrKyxzPj1BW1wiZGVmYXVsdFwiXS5taW5pUm93cyYmKHM9MCl9cmV0dXJue2xheW91dDp1LGdyb3VwTWFwOmx9fWZ1bmN0aW9uIHkoZSx0LG4pe2Zvcih2YXIgciBpbiBlKWlmKGVbcl09PT10KXt2YXIgaT1BW1wiZGVmYXVsdFwiXS5taW5pS2V5MnBvcyhyKSxvPWEoaSwyKSx1PW9bMF0sbD1vWzFdLGQ9W3UrbixsXTtyZXR1cm4gQVtcImRlZmF1bHRcIl0ubWluaVBvczJrZXkoZCl9fWZ1bmN0aW9uIHcoZSx0LG4pe3ZhciByPWUubGF5b3V0Lmdyb3VwTWFwLnBhaXJzO3JldHVybiB5KHIsdCxuKX1mdW5jdGlvbiBiKGUsdCxuKXt2YXIgcj1lLmxheW91dC5ncm91cE1hcC5zZXJpZXM7cmV0dXJuIHkocix0LG4pfWZ1bmN0aW9uIFAoZSx0KXt2YXIgbj1lLm9wZW5zLHI9bi5zZXJpZXMsaT1uLmxheW91dC5ncm91cE1hcCxvPWEodCwyKSx1PW9bMF0sbD1vWzFdO2Zvcih2YXIgZCBpbiBpLnNlcmllcyl7dmFyIHM9aS5zZXJpZXNbZF0sYz1yW3NdLGY9QVtcImRlZmF1bHRcIl0ubWluaUtleTJwb3MoZCkscD1hKGYsMiksdj1wWzBdLG09cFsxXSxnPXUtdjtpZighKGc8MHx8Zz5jLmxlbmd0aCsxfHxsIT1tKSlyZXR1cm5bcyxnXX19ZnVuY3Rpb24gayhlLHQpe3ZhciBuPWUub3BlbnMscj1uLnBhaXJzLGk9bi5sYXlvdXQuZ3JvdXBNYXAsbz1hKHQsMiksdT1vWzBdLGw9b1sxXTtmb3IodmFyIGQgaW4gaS5wYWlycyl7dmFyIHM9aS5wYWlyc1tkXSxjPShyW3NdLEFbXCJkZWZhdWx0XCJdLm1pbmlLZXkycG9zKGQpKSxmPWEoYywyKSxwPWZbMF0sdj1mWzFdLG09dS1wO2lmKCEobTwwfHxtPjF8fGwhPXYpKXJldHVybltzLG1dfX1mdW5jdGlvbiBPKGUpe3ZhciB0PXt9LG49ZChlKTtyZXR1cm4gdFtBW1wiZGVmYXVsdFwiXS5taWRkbGVDb3VudF09bi5udW1iZXIsbj1jKG4ubGVmdCksdFtBW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV09bi5waWVjZSx0fWZ1bmN0aW9uIHgoZSl7ZT1lLnNwbGl0KFwiL1wiKTt2YXIgdD0yLG49MyxyPTQsYT0xLGk9MCxvPXtlOlwiZWFzdFwiLHc6XCJ3ZXN0XCIsbjpcIm5vcnRoXCIsczpcInNvdXRoXCJ9W2VbaV1dO3JldHVybntwaWVjZXM6dihlW3RdKSxkaXNjYXJkczptKGVbbl0sbyksb3BlbnM6ZyhbZVtyXSxlW3IrMV1dLmpvaW4oXCIvXCIpKSxtaWRkbGVzOk8oZVthXSl9fWZ1bmN0aW9uIFMoZSl7dmFyIHQ9QVtcImRlZmF1bHRcIl0uYWxsS2V5cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUua2V5fHxcIiBcIn0pLmpvaW4oXCJcIik7cmV0dXJuIHQucmVwbGFjZSgvKFteXFxzXSlcXHMvZyxcIiQxXCIpfWZ1bmN0aW9uIEUoZSx0KXtyZXR1cm57Y29sb3I6RFtlXSxudW1iZXI6Qlt0XSxjOmUsbjpwYXJzZUludCh0KSxrZXk6ZSt0fX1mdW5jdGlvbiBNKGUpe3ZhciB0PWUuYyxuPWUubiUxMysxO3JldHVybiBFKHQsbil9ZnVuY3Rpb24gQyhlKXt2YXIgdD1lLmMsbj0oZS5uKzExKSUxMysxO3JldHVybiBFKHQsbil9ZnVuY3Rpb24gSyhlKXtyZXR1cm5cImZha2VcIj09PWUuY29sb3J9ZnVuY3Rpb24gVChlKXtyZXR1cm4gZS5sZW5ndGg+MCYmMTQ9PT1lLm1hdGNoKGopLmxlbmd0aH12YXIgQT1yKGUoXCIuL3V0aWxcIikpLEQ9e2I6XCJibHVlXCIscjpcInJlZFwiLGc6XCJncmVlblwiLGw6XCJibGFja1wiLGY6XCJmYWtlXCJ9LEI9ezE6XCJvbmVcIiwyOlwidHdvXCIsMzpcInRocmVlXCIsNDpcImZvdXJcIiw1OlwiZml2ZVwiLDY6XCJzaXhcIiw3Olwic2V2ZW5cIiw4OlwiZWlnaHRcIiw5OlwibmluZVwiLDEwOlwidGVuXCIsMTE6XCJlbGV2ZW5cIiwxMjpcInR3ZWx2ZVwiLDEzOlwidGhpcnRlZW5cIn0saj0vW2Z8cnxsfGJ8Z11cXGRcXGQ/L2csUj1mdW5jdGlvbigpe3ZhciBlPXt9O2Zvcih2YXIgdCBpbiBEKWVbRFt0XV09bCh0KTtyZXR1cm4gZX0oKSxMPWZ1bmN0aW9uKGUpe3JldHVybiBSW2VdfSxHPVwiZzdyN2I3bDcgZzhyOGI4bDggZzEzcjEzYjEzbDEzIGwxMiByNnI1cjRyMTJyMTMgZzlnOGcxMyBnNiBsOGw3bDEyXCIsRj1cInIxZzFsMWIxIHIyZzJsMmIyIHIzZzNsM2IzIHI0ZzRsNGI0IHIxM2cxM2wxM2IxMyByMWcxbDFiMVwiLE49XCJyMXIyIHIzcjRyNXI2cjdyOHI5cjEwcjExcjEycjEzbDFsMmwzbDRsNWw2bDcgICBnMWcyICBsM1wiLF89XCIyMGwzXCIsST1cImIxICByMXIyIGcxXCIsSD1cInI4bDhiOFxcbmIxYjJiM1xcbmI5YjEwYjExYjEyXFxubDEzcjEzYjEzXFxucjEyYjEyZzEyXFxucjdyOHI5cjEwXFxuZzEwZzExZzEyXFxubDZiNnI2XFxubDlsMTBsMTFcXG5iN2w3cjdnN1xcbnIxM2wxM2IxM2cxM1xcbmwxMHIxMGIxMGcxMFxcbmw2cjZnNlxcbmwxYjFnMVxcbi9yMXIxXFxuZzFnMVxcbmcyZzJcXG5nM2czXFxuZzRnNFxcbmc1ZzVcXG5nNmc2XFxuZzdnN1xcbmc4ZzhcXG5nOWc5XFxuZzEwZzEwXFxuZzExZzExXFxuZzEyZzEyXFxuXFxuXCI7dC5leHBvcnRzPXt2YWxpZER1ek9rZXlHcm91cEZlbjpULGluaXRpYWw6TixyYWluYm93OkYsbWl4ZWQ6Ryx3cml0ZTpTLHJlYWQ6eCxyZWFkRHJvcFBvczpzLHJlYWRQaWVjZTpjLHJlYWRCb2FyZDp2LGluaXRpYWxNaWRkbGVzOl8saW5pdGlhbERpc2NhcmRzOkksaW5pdGlhbE9wZW5Hcm91cHM6SCxyZWFkTWlkZGxlczpPLHJlYWREaXNjYXJkczptLHJlYWRQaWVjZUdyb3VwOmYscmVhZE9wZW5Hcm91cHM6ZyxsYXlvdXRPcGVuczpoLHNlcmllc0J5Q29sb3I6TCxtYWtlUGllY2U6RSxwaWVjZVVwOk0scGllY2VEb3duOkMscGllY2VGYWtlOkssY29sb3JzOkQsZ2V0T3BlblNlcmllS2V5RnJvbUdyb3VwSW5kZXg6YixnZXRPcGVuUGFpcktleUZyb21Hcm91cEluZGV4OncsZ2V0T3BlblNlcmllRnJvbVBvczpQLGdldE9wZW5QYWlyRnJvbVBvczprfX0se1wiLi91dGlsXCI6MTd9XSwxNTpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUpe3JldHVybiB1KGUpfHxvKGUpfHxpKCl9ZnVuY3Rpb24gaSgpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX1mdW5jdGlvbiBvKGUpe2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpcmV0dXJuIEFycmF5LmZyb20oZSl9ZnVuY3Rpb24gdShlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxuPW5ldyBBcnJheShlLmxlbmd0aCk7dDxlLmxlbmd0aDt0Kyspblt0XT1lW3RdO3JldHVybiBufX1mdW5jdGlvbiBsKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBkKGUpe2Z1bmN0aW9uIHQoZSxuLHIpe2Zvcih2YXIgaSBpbiByKXt2YXIgbz1yW2ldO2lmKGkhPT1uJiZvLmM9PT1lLmMpe2lmKDE9PT1vLm4mJjI9PT1lLm4pcmV0dXJuW2woe30saSxvKV07aWYoMTM9PT1vLm4mJjE9PT1lLm58fG8ubj09PWUubi0xKXJldHVybltsKHt9LGksbyldLmNvbmNhdChhKHQobyxpLHIpKSl9fXJldHVybltdfWZ1bmN0aW9uIG4oZSx0LHIpe2Zvcih2YXIgaSBpbiByKXt2YXIgbz1yW2ldO2lmKGkhPT10JiZvLmM9PT1lLmMpe2lmKDE9PT1vLm4mJjEzPT09ZS5uKXJldHVybltsKHt9LGksbyldO2lmKG8ubj09PWUubisxKXJldHVybltsKHt9LGksbyldLmNvbmNhdChhKG4obyxpLHIpKSl9fXJldHVybltdfWZ1bmN0aW9uIHIoZSx0LG4pe3ZhciByPXt9O2Zvcih2YXIgYSBpbiBuKXt2YXIgaT1uW2FdO2EhPT10JiZpLm49PT1lLm4mJmkuYyE9PWUuYyYmKHJbaS5jXT1sKHt9LGEsaSkpfXJldHVybiBPYmplY3QudmFsdWVzKHIpfWZ1bmN0aW9uIGkoZSl7dmFyIGE9e307Zm9yKHZhciBpIGluIGUpe3ZhciBvPWVbaV07byYmKGFbaV09e2Rvd25zOnQobyxpLGUpLHVwczpuKG8saSxlKSxzYW1lOnIobyxpLGUpfSl9dmFyIHU9e3R5cGU6bnVsbCxrZXk6bnVsbCx2YWx1ZTowfTtmb3IodmFyIGQgaW4gYSl7dmFyIHM9YVtkXTtbXCJkb3duc1wiLFwidXBzXCIsXCJzYW1lXCJdLm1hcChmdW5jdGlvbihlKXtzW2VdLmxlbmd0aD49dS52YWx1ZSYmKHUudHlwZT1lLHUua2V5PWQsdS52YWx1ZT1zW2VdLmxlbmd0aCl9KX12YXIgYz1hW3Uua2V5XVt1LnR5cGVdO3JldHVyblwiZG93bnNcIj09PXUudHlwZT9jLnVuc2hpZnQobCh7fSx1LmtleSxlW3Uua2V5XSkpOmMudW5zaGlmdChsKHt9LHUua2V5LGVbdS5rZXldKSksY31mb3IodmFyIG8gaW4gZS5waWVjZXMpZS5waWVjZXNbb118fGRlbGV0ZSBlLnBpZWNlc1tvXTt2YXIgdT1PYmplY3QuYXNzaWduKHt9LGUucGllY2VzKTtmb3IobyBpbiBlLnBpZWNlcyllLnBpZWNlc1tvXT12b2lkIDAsZGVsZXRlIGUucGllY2VzW29dO2Zvcih2YXIgZD0xO09iamVjdC5rZXlzKHUpLmxlbmd0aD4wOyl7dmFyIHM9aSh1KSxjPXMubGVuZ3RoO2Q9ZltcImRlZmF1bHRcIl0ubmV4dEl0ZXJhdG9yRm9yR3JvdXAoZCxjKSxzLmZvckVhY2goZnVuY3Rpb24odCxuKXtmb3IodmFyIHIgaW4gdCl7dmFyIGE9dFtyXTtlLnBpZWNlc1tmW1wiZGVmYXVsdFwiXS5pdGVyYXRvcjJLZXkoZCsyKm4pXT1hLHVbcl09dm9pZCAwLGRlbGV0ZSB1W3JdfX0pLGQrPTIqYysxfWNvbnNvbGUubG9nKGUucGllY2VzKX1mdW5jdGlvbiBzKGUpe3ZhciB0PXt9O2Zvcih2YXIgbiBpbiBlLnBpZWNlcyl7dmFyIHI9ZS5waWVjZXNbbl07ciYmKHRbci5rZXldP3Rbci5rZXldKys6dFtyLmtleV09MSxkZWxldGUgZS5waWVjZXNbbl0pfXZhciBhPTE7Zm9yKHZhciBpIGluIHQpe3ZhciBvPXRbaV07YT1mW1wiZGVmYXVsdFwiXS5uZXh0SXRlcmF0b3JGb3JHcm91cChhLG8pO2Zvcih2YXIgdT0wO3U8bzt1KyspZS5waWVjZXNbZltcImRlZmF1bHRcIl0uaXRlcmF0b3IyS2V5KGErMip1KV09Y1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKGkpLnBpZWNlO2ErPTIqbysxfX12YXIgYz1yKGUoXCIuL3BpZWNlc1wiKSksZj1yKGUoXCIuL3V0aWxcIikpO3QuZXhwb3J0cz17c29ydFBhaXJzOnMsc29ydFNlcmllczpkfX0se1wiLi9waWVjZXNcIjoxNCxcIi4vdXRpbFwiOjE3fV0sMTY6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7XCJkZWZhdWx0XCI6ZX19ZnVuY3Rpb24gYShlLHQpe3JldHVybiB1KGUpfHxvKGUsdCl8fGkoKX1mdW5jdGlvbiBpKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9ZnVuY3Rpb24gbyhlLHQpe3ZhciBuPVtdLHI9ITAsYT0hMSxpPXZvaWQgMDt0cnl7Zm9yKHZhciBvLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShyPShvPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChvLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtyPSEwKTt9Y2F0Y2gobCl7YT0hMCxpPWx9ZmluYWxseXt0cnl7cnx8bnVsbD09dVtcInJldHVyblwiXXx8dVtcInJldHVyblwiXSgpfWZpbmFsbHl7aWYoYSl0aHJvdyBpfX1yZXR1cm4gbn1mdW5jdGlvbiB1KGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9ZnVuY3Rpb24gbChlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fSxyPW4ucGllY2UsYT1uLmdyb3VwLGk9bi5wb3Msbz1SW1wiZGVmYXVsdFwiXS5maW5kUG92KGUucG92U2lkZSxlLnR1cm5TaWRlKTtpZihlLnR1cm5TaWRlIT09ZS5wb3ZTaWRlfHxlLnNwZWN0YXRvcilzd2l0Y2godCl7Y2FzZSBMW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlOnYoZSksZS5hbmltYXRpb24uY3VycmVudC5oaW50PUxbXCJkZWZhdWx0XCJdLmRyYXdNaWRkbGU7YnJlYWs7Y2FzZSBMW1wiZGVmYXVsdFwiXS5kcmF3TGVmdDptKGUsUltcImRlZmF1bHRcIl0uZHJhd0J5UG92KG8pKSxlLmFuaW1hdGlvbi5jdXJyZW50LmhpbnQ9TFtcImRlZmF1bHRcIl0uZHJhd0xlZnQ7YnJlYWs7Y2FzZSBMW1wiZGVmYXVsdFwiXS5kaXNjYXJkOnI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLHAoZSxSW1wiZGVmYXVsdFwiXS5kaXNjYXJkQnlQb3YobyksciksZS5hbmltYXRpb24uY3VycmVudC5oaW50PUxbXCJkZWZhdWx0XCJdLmRpc2NhcmQ7YnJlYWs7Y2FzZSBMW1wiZGVmYXVsdFwiXS5sZWF2ZVRha2VuOnI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLGcoZSxSW1wiZGVmYXVsdFwiXS5kcmF3QnlQb3YobyksciksZS5hbmltYXRpb24uY3VycmVudC5oaW50PUxbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW47YnJlYWs7Y2FzZSBMW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzOmE9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlR3JvdXAoYSksYyhlLGEpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1MW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzO2JyZWFrO2Nhc2UgTFtcImRlZmF1bHRcIl0ub3BlblBhaXJzOmE9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlR3JvdXAoYSksZihlLGEpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1MW1wiZGVmYXVsdFwiXS5vcGVuU2VyaWVzO2JyZWFrO2Nhc2UgTFtcImRlZmF1bHRcIl0uZHJvcE9wZW5TZXJpZXM6cj1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UocikucGllY2UsaT1HW1wiZGVmYXVsdFwiXS5yZWFkRHJvcFBvcyhpKSxkKGUscixpKTticmVhaztjYXNlIExbXCJkZWZhdWx0XCJdLmRyb3BPcGVuUGFpcnM6cj1HW1wiZGVmYXVsdFwiXS5yZWFkUGllY2UocikucGllY2UsaT1HW1wiZGVmYXVsdFwiXS5yZWFkRHJvcFBvcyhpKSxzKGUscixpKTticmVhaztkZWZhdWx0OmNvbnNvbGUuZXJyb3IoXCJ1bmtub3duIG1vdmVcIil9ZWxzZSBpZihlLnNwZWN0YXRvcil0PT09TFtcImRlZmF1bHRcIl0ubGVhdmVUYWtlbiYmKHI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLGcoZSxSW1wiZGVmYXVsdFwiXS5kcmF3QnlQb3YobyksciksZS5hbmltYXRpb24uY3VycmVudC5oaW50PUxbXCJkZWZhdWx0XCJdLmxlYXZlVGFrZW4pO2Vsc2Ugc3dpdGNoKHQpe2Nhc2UgTFtcImRlZmF1bHRcIl0uZGlzY2FyZDpyPUdbXCJkZWZhdWx0XCJdLnJlYWRQaWVjZShyKS5waWVjZSx3KGUscixSW1wiZGVmYXVsdFwiXS5kaXNjYXJkc1syXSksZS5hbmltYXRpb24uY3VycmVudC5oaW50PUxbXCJkZWZhdWx0XCJdLmRpc2NhcmQ7YnJlYWs7Y2FzZSBMW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlOnI9R1tcImRlZmF1bHRcIl0ucmVhZFBpZWNlKHIpLnBpZWNlLGUubWlkZGxlSG9sZGVyLmN1cnJlbnQ/TltcImRlZmF1bHRcIl0uYXBpRHJhd01pZGRsZUVuZChlLHIpOk5bXCJkZWZhdWx0XCJdLmFwaUZvcmNlRHJhd01pZGRsZUVuZChlLHIpLGUuYW5pbWF0aW9uLmN1cnJlbnQuaGludD1MW1wiZGVmYXVsdFwiXS5kcmF3TWlkZGxlO2JyZWFrO2Nhc2UgTFtcImRlZmF1bHRcIl0ubGVhdmVUYWtlbjpOW1wiZGVmYXVsdFwiXS5wbGF5TGVhdmVUYWtlbihlLHIpfX1mdW5jdGlvbiBkKGUsdCxuKXt2YXIgcj1uLnR5cGUsYT1uLmdyb3VwSW5kZXgsaT1lLm9wZW5zLnNlcmllc1thXSxvPXIhPT1MW1wiZGVmYXVsdFwiXS5kcm9wUmVwbGFjZT8wOjEsdT0wO2lmKHI9PT1MW1wiZGVmYXVsdFwiXS5kcm9wTGVmdCl1PTA7ZWxzZSBpZihyPT09TFtcImRlZmF1bHRcIl0uZHJvcFJpZ2h0KXU9aS5sZW5ndGgrMTtlbHNle3ZhciBsPUdbXCJkZWZhdWx0XCJdLnBpZWNlVXAoZS5taWRkbGVzW1JbXCJkZWZhdWx0XCJdLmdvc3RlcmdlXSk7dT1GW1wiZGVmYXVsdFwiXS5maW5kT2tleUluZGV4KGksbCkrMX1pLnNwbGljZSh1LW8sbyx0KSxlLm9wZW5zLnJlbGF5b3V0KGUpfWZ1bmN0aW9uIHMoZSx0LG4pe3ZhciByPW4uZ3JvdXBJbmRleCxhPWUub3BlbnMucGFpcnNbcl0saT1HW1wiZGVmYXVsdFwiXS5waWVjZVVwKGUubWlkZGxlc1tSW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0pLG89RltcImRlZmF1bHRcIl0uZmluZE9rZXlJbmRleChhLGkpO2Euc3BsaWNlKG8sMSx0KSxlLm9wZW5zLnJlbGF5b3V0KGUpfWZ1bmN0aW9uIGMoZSx0KXt2YXIgbj10LHI9ZS5vcGVucy5zZXJpZXMuY29uY2F0KG4pO2Uub3BlbnMuc2VyaWVzPXIsZS5vcGVucy5yZWxheW91dChlKX1mdW5jdGlvbiBmKGUsdCl7dmFyIG49dCxyPWUub3BlbnMucGFpcnMuY29uY2F0KG4pO2Uub3BlbnMucGFpcnM9cixlLm9wZW5zLnJlbGF5b3V0KGUpfWZ1bmN0aW9uIHAoZSx0LG4pe3JldHVybiBlLmRpc2NhcmRzW3RdLnVuc2hpZnQobiksZS5sYXN0TW92ZT1bdF0sITB9ZnVuY3Rpb24gdihlKXtyZXR1cm4gZS5taWRkbGVzW1JbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50XS0tLGUubGFzdE1vdmU9W1JbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50XSwhMH1mdW5jdGlvbiBtKGUsdCl7cmV0dXJuIGUuZGlzY2FyZHNbdF0uc2hpZnQoKSwhMH1mdW5jdGlvbiBnKGUsdCxuKXtyZXR1cm4gZS5kaXNjYXJkc1t0XS51bnNoaWZ0KG4pLCEwfWZ1bmN0aW9uIGgoZSx0LG4scil7aWYoIWUucGllY2VzW3RdfHwhcilyZXR1cm4hMTt2YXIgaT1lLnBpZWNlc1t0XTtVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxMW1wiZGVmYXVsdFwiXS5kcm9wT3BlblNlcmllcyxJKGkua2V5KSkpO3ZhciBvPWEociwyKSx1PW9bMF0sbD1vWzFdLGQ9ZS5vcGVucy5zZXJpZXNbdV0scz1PKGQsbCksYz1zIT09TFtcImRlZmF1bHRcIl0uZHJvcFJlcGxhY2U/MDoxO2lmKGQuc3BsaWNlKGwtYyxjLGkpLGUub3BlbnMucmVsYXlvdXQoZSksZGVsZXRlIGUucGllY2VzW3RdLHM9PT1MW1wiZGVmYXVsdFwiXS5kcm9wUmVwbGFjZSl7dmFyIGY9R1tcImRlZmF1bHRcIl0ucGllY2VVcChlLm1pZGRsZXNbUltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdKTtlLnBpZWNlc1t0XT1mfXJldHVybiEwfWZ1bmN0aW9uIHkoZSx0LG4scil7aWYoIWUucGllY2VzW3RdfHwhcilyZXR1cm4hMTt2YXIgaT1lLnBpZWNlc1t0XTtVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxMW1wiZGVmYXVsdFwiXS5kcm9wT3BlblBhaXJzLEkoaS5rZXkpKSk7dmFyIG89YShyLDIpLHU9b1swXSxsPW9bMV0sZD1lLm9wZW5zLnBhaXJzW3VdO2Quc3BsaWNlKGwsMSxpKSxlLm9wZW5zLnJlbGF5b3V0KGUpLGRlbGV0ZSBlLnBpZWNlc1t0XTt2YXIgcz1HW1wiZGVmYXVsdFwiXS5waWVjZVVwKGUubWlkZGxlc1tSW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0pO3JldHVybiBlLnBpZWNlc1t0XT1zLCEwfWZ1bmN0aW9uIHcoZSx0LG4pe2Zvcih2YXIgciBpbiBlLnBpZWNlcyl7dmFyIGE9ZS5waWVjZXNbcl07aWYoYSYmUltcImRlZmF1bHRcIl0ucGllY2VFcXVhbCh0LGEpKXJldHVybiBiKGUscixuKSwhMH1yZXR1cm4hMX1mdW5jdGlvbiBiKGUsdCxuKXt2YXIgcj1lLnBpZWNlc1t0XTtyZXR1cm4hIXImJihVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxMW1wiZGVmYXVsdFwiXS5kaXNjYXJkLEkoci5rZXkpKSksZS5kaXNjYXJkc1tuXS51bnNoaWZ0KGUucGllY2VzW3RdKSxkZWxldGUgZS5waWVjZXNbdF0sZS5sYXN0TW92ZT1bbl0sITApfWZ1bmN0aW9uIFAoZSx0KXt2YXIgbj1lLnBpZWNlc1t0XTtyZXR1cm4hIW4mJighIVJbXCJkZWZhdWx0XCJdLnBpZWNlRXF1YWwobixlLm1pZGRsZXNbUltcImRlZmF1bHRcIl0uZ29zdGVyZ2VdKSYmKFUoUltcImRlZmF1bHRcIl0ucGFydGlhbChlLmV2ZW50cy5tb3ZlLExbXCJkZWZhdWx0XCJdLnNpZ24sSShuLmtleSkpKSwhMCkpfWZ1bmN0aW9uIGsoZSx0KXt2YXIgbj1lLnBpZWNlc1t0XTtpZighbilyZXR1cm4hMTtkZWxldGUgZS5waWVjZXNbdF07dmFyIHI9KEdbXCJkZWZhdWx0XCJdLndyaXRlKGUucGllY2VzKSxOW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwU2VyaWVzKGUpKSxhPU5bXCJkZWZhdWx0XCJdLmdldFBpZWNlR3JvdXBQYWlycyhlKTtpZihHW1wiZGVmYXVsdFwiXS52YWxpZER1ek9rZXlHcm91cEZlbihyKSlVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxMW1wiZGVmYXVsdFwiXS5kaXNjYXJkRW5kU2VyaWVzLEgocikpKTtlbHNle2lmKCFHW1wiZGVmYXVsdFwiXS52YWxpZER1ek9rZXlHcm91cEZlbihhKSlyZXR1cm4gZS5waWVjZXNbdF09biwhMTtVKFJbXCJkZWZhdWx0XCJdLnBhcnRpYWwoZS5ldmVudHMubW92ZSxMW1wiZGVmYXVsdFwiXS5kaXNjYXJkRW5kUGFpcnMsSChhKSkpfXJldHVybiEwfWZ1bmN0aW9uIE8oZSx0KXtyZXR1cm4gMD09PXQ/TFtcImRlZmF1bHRcIl0uZHJvcExlZnQ6dD09PWUubGVuZ3RoKzE/TFtcImRlZmF1bHRcIl0uZHJvcFJpZ2h0OkxbXCJkZWZhdWx0XCJdLmRyb3BSZXBsYWNlfWZ1bmN0aW9uIHgoZSx0LG4pe2lmKG4mJlJbXCJkZWZhdWx0XCJdLmlzT3BlbnNLZXkobikmJlQoZSx0LG4pKXt2YXIgcixpLG8sdSxsLGQ9ZS5waWVjZXNbdF0scz1HW1wiZGVmYXVsdFwiXS5nZXRPcGVuU2VyaWVGcm9tUG9zKGUsUltcImRlZmF1bHRcIl0ubWluaUtleTJwb3MobikpO2lmKHMpe3ZhciBjPWEocywyKTtyPWNbMF0saT1jWzFdLG89ZS5vcGVucy5zZXJpZXNbcl0sdT1PKG8saSksbD11K3J9aWYoaChlLHQsbixzKSlyZXR1cm4gVShSW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIsTFtcImRlZmF1bHRcIl0uZHJvcE9wZW5TZXJpZXMsXyhkLmtleSxsKSkpLCEwO3ZhciBmPUdbXCJkZWZhdWx0XCJdLmdldE9wZW5QYWlyRnJvbVBvcyhlLFJbXCJkZWZhdWx0XCJdLm1pbmlLZXkycG9zKG4pKTtpZihmKXt2YXIgcD1hKGYsMik7cj1wWzBdLGk9cFsxXSxvPWUub3BlbnMucGFpcnNbcl0sdT1PKG8saSksbD11K3J9aWYoeShlLHQsbixmKSlyZXR1cm4gVShSW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIsTFtcImRlZmF1bHRcIl0uZHJvcE9wZW5QYWlycyxfKGQua2V5LGwpKSksITB9cmV0dXJuITF9ZnVuY3Rpb24gUyhlLHQsbil7dmFyIHI9ZS5waWVjZXNbdF07aWYobiYmbj09PVJbXCJkZWZhdWx0XCJdLmRpc2NhcmRzWzJdKXtpZihBKGUsdCxuKSYmYihlLHQsbikpcmV0dXJuIFUoUltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLExbXCJkZWZhdWx0XCJdLmRpc2NhcmQsSShyLmtleSkpKSwhMH1lbHNlIGlmKG49PT1SW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZSl7aWYoQihlLHQpJiZQKGUsdCkpcmV0dXJuIFUoUltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLExbXCJkZWZhdWx0XCJdLnNpZ24sSShyLmtleSkpKSwhMDtpZihEKGUsdCkmJmsoZSx0KSl7dmFyIGE9KEdbXCJkZWZhdWx0XCJdLndyaXRlKGUucGllY2VzKSxOW1wiZGVmYXVsdFwiXS5nZXRQaWVjZUdyb3VwU2VyaWVzKGUpKSxpPU5bXCJkZWZhdWx0XCJdLmdldFBpZWNlR3JvdXBQYWlycyhlKTtyZXR1cm4gR1tcImRlZmF1bHRcIl0udmFsaWREdXpPa2V5R3JvdXBGZW4oYSk/VShSW1wiZGVmYXVsdFwiXS5wYXJ0aWFsKGUubW92YWJsZS5ldmVudHMuYWZ0ZXIsTFtcImRlZmF1bHRcIl0uZGlzY2FyZEVuZFNlcmllcyxIKGEpKSk6R1tcImRlZmF1bHRcIl0udmFsaWREdXpPa2V5R3JvdXBGZW4oaSkmJlUoUltcImRlZmF1bHRcIl0ucGFydGlhbChlLm1vdmFibGUuZXZlbnRzLmFmdGVyLExbXCJkZWZhdWx0XCJdLmRpc2NhcmRFbmRQYWlycyxIKGkpKSksITB9fXJldHVybiExfWZ1bmN0aW9uIEUoZSx0KXtNKGUsdCl9ZnVuY3Rpb24gTShlLHQpe2Uuc2VsZWN0ZWQ9dH1mdW5jdGlvbiBDKGUsdCl7cmV0dXJuIFJbXCJkZWZhdWx0XCJdLmlzTWlkZGxlS2V5KHQpfHxSW1wiZGVmYXVsdFwiXS5pc0RyYXdMZWZ0S2V5KHQpP2UucG92U2lkZT09PWUudHVyblNpZGU6UltcImRlZmF1bHRcIl0uaXNCb2FyZEtleSh0KX1mdW5jdGlvbiBLKGUpe3JldHVybiBlLnBvdlNpZGU9PT1lLnR1cm5TaWRlfWZ1bmN0aW9uIFQoZSx0LG4pe3ZhciByPWUubWlkZGxlc1tSW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV07cmV0dXJuIE5bXCJkZWZhdWx0XCJdLmlzRHJvcHBhYmxlT3BlbnMoZSx0KSYmUltcImRlZmF1bHRcIl0uaXNCb2FyZEtleSh0KSYmUltcImRlZmF1bHRcIl0uaXNPcGVuc0tleShuKSYmUltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxMW1wiZGVmYXVsdFwiXS5kcm9wT3BlblNlcmllcykmJlJbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMsTFtcImRlZmF1bHRcIl0uZHJvcE9wZW5QYWlycykmJlJbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChGW1wiZGVmYXVsdFwiXS5jb21wdXRlKGUub3BlbnMsZS5waWVjZXNbdF0sciksbil9ZnVuY3Rpb24gQShlLHQsbil7cmV0dXJuIEsoZSkmJlJbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWChlLm1vdmFibGUuZGVzdHMsTFtcImRlZmF1bHRcIl0uZGlzY2FyZCl9ZnVuY3Rpb24gRChlLHQpe3JldHVybiBLKGUpJiZSW1wiZGVmYXVsdFwiXS5jb250YWluc1goZS5tb3ZhYmxlLmRlc3RzLExbXCJkZWZhdWx0XCJdLmRpc2NhcmRFbmRTZXJpZXMpfWZ1bmN0aW9uIEIoZSx0KXtyZXR1cm4gSyhlKSYmUltcImRlZmF1bHRcIl0uY29udGFpbnNYKGUubW92YWJsZS5kZXN0cyxMW1wiZGVmYXVsdFwiXS5zaG93U2lnbil9ZnVuY3Rpb24gaihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06UltcImRlZmF1bHRcIl0udG9wQ29sdW1ucyxuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpSW1wiZGVmYXVsdFwiXS50b3BSb3dzO3JldHVybiBmdW5jdGlvbihyLGEsaSl7aWYoaXx8ci5ib3VuZHMpe2k9aXx8ci5ib3VuZHMoKTt2YXIgbz1NYXRoLmZsb29yKHQqKChhWzBdLWkubGVmdCkvaS53aWR0aCkpLHU9TWF0aC5mbG9vcihuKigoYVsxXS1pLnRvcCkvaS5oZWlnaHQpKTtyZXR1cm4gdT49MCYmdTxuJiZvPj0wJiZvPHQ/ZSh1LG8pOnZvaWQgMH19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG5bXCJkZWZhdWx0XCJdPXZvaWQgMDt2YXIgUj1yKGUoXCIuL3V0aWxcIikpLEw9cihlKFwiLi9tb3ZlXCIpKSxHPXIoZShcIi4vcGllY2VzXCIpKSxGPXIoZShcIi4vb3BlblwiKSksTj1yKGUoXCIuL2JvYXJkXCIpKSxfPVJbXCJkZWZhdWx0XCJdLndyYXBEcm9wLEk9UltcImRlZmF1bHRcIl0ud3JhcFBpZWNlLEg9UltcImRlZmF1bHRcIl0ud3JhcEdyb3VwLFU9UltcImRlZmF1bHRcIl0uY2FsbFVzZXJGdW5jdGlvbixxPWooZnVuY3Rpb24oZSx0KXtyZXR1cm4gUltcImRlZmF1bHRcIl0ubWluaVBvczJrZXkoW3QsZV0pfSxSW1wiZGVmYXVsdFwiXS5taW5pQ29sdW1ucyxSW1wiZGVmYXVsdFwiXS5taW5pUm93cyksWD1qKGZ1bmN0aW9uKGUsdCl7aWYoZT09PVJbXCJkZWZhdWx0XCJdLnRvcFJvd3MtMSl7aWYoMD09PXQpcmV0dXJuIFJbXCJkZWZhdWx0XCJdLmRpc2NhcmRzWzFdO2lmKHQ9PT1SW1wiZGVmYXVsdFwiXS50b3BDb2x1bW5zLTQpcmV0dXJuIFJbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50fX0pLHo9aihmdW5jdGlvbihlLHQpe2lmKGU9PT1SW1wiZGVmYXVsdFwiXS50b3BSb3dzLTEpe2lmKHQ9PT1SW1wiZGVmYXVsdFwiXS50b3BDb2x1bW5zLTEpcmV0dXJuIFJbXCJkZWZhdWx0XCJdLmRpc2NhcmRzWzJdO2lmKHQ9PT1SW1wiZGVmYXVsdFwiXS50b3BDb2x1bW5zLTMpcmV0dXJuIFJbXCJkZWZhdWx0XCJdLmdvc3RlcmdlfX0pLCQ9e2FwaU1vdmU6bCxzZWxlY3RUb3A6RSxkcm9wVG9wOlMsZHJvcE9wZW5zOngsaXNEcmFnZ2FibGU6QyxnZXREcmF3S2V5QXREb21Qb3M6WCxcbmdldERpc2NhcmRLZXlBdERvbVBvczp6LGdldE9wZW5zS2V5QXREb21Qb3M6cX07bltcImRlZmF1bHRcIl09JH0se1wiLi9ib2FyZFwiOjUsXCIuL21vdmVcIjoxMixcIi4vb3BlblwiOjEzLFwiLi9waWVjZXNcIjoxNCxcIi4vdXRpbFwiOjE3fV0sMTc6W2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7cmV0dXJuIF9bZV1bdF19ZnVuY3Rpb24gYShlLHQpe3JldHVybiBlLmNvbG9yPT09dC5jb2xvciYmZS5udW1iZXI9PT10Lm51bWJlcn1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBuPVtdLHI9MDtyPGU7cisrKWZvcih2YXIgYT0wO2E8dDthKyspbi5wdXNoKFthLHJdKTtyZXR1cm4gbn1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIHQrZX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuIHBhcnNlSW50KGUuc2xpY2UoMSkpfWZ1bmN0aW9uIGwoZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjE7cmV0dXJuIG8odShlKS10LFcpfWZ1bmN0aW9uIGQoZSl7cmV0dXJuIGVbMF09PT1XfWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGVbMF09PT1afWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGU9PT1KfWZ1bmN0aW9uIGYoZSl7cmV0dXJuIGU9PT0kWzFdfWZ1bmN0aW9uIHAoZSl7dmFyIHQ9ZVsxXSpCK2VbMF07cmV0dXJuIG8odCxXKX1mdW5jdGlvbiB2KGUpe3JldHVybiBlPXUoZSksW2UlQixNYXRoLmZsb29yKGUvQildfWZ1bmN0aW9uIG0oZSl7cmV0dXJuIG8oZSxXKX1mdW5jdGlvbiBnKGUsdCl7ZnVuY3Rpb24gbihlKXt2YXIgdD1NYXRoLmZsb29yKGUvQiksbj1lJUI7cmV0dXJuW24sdF19ZnVuY3Rpb24gcihlKXtyZXR1cm4gZVsxXSpCK2VbMF19dmFyIGE9bihlKSxpPW4oZSsyKnQpO3JldHVybiBhWzFdIT09aVsxXT9yKFsxLDFdKTooMT09PWFbMV0mJjA9PT1hWzBdJiYoYVswXT0xKSxyKGEpKX1mdW5jdGlvbiBoKGUpe3JldHVybiBZW2VdfWZ1bmN0aW9uIHkoZSl7dmFyIHQ9ZVsxXSpHK2VbMF07cmV0dXJuIG8odCxaKX1mdW5jdGlvbiB3KGUpe3JldHVybiBlPXUoZSksW2UlRyxNYXRoLmZsb29yKGUvRyldfWZ1bmN0aW9uIGIoZSl7dmFyIHQ9W107Zm9yKHZhciBuIGluIGUpZVtuXSYmdC5wdXNoKG4pO3JldHVybiB0LmpvaW4oXCIgXCIpfWZ1bmN0aW9uIFAoZSx0KXtyZXR1cm4gZSYmZS5pbmRleE9mKHQpIT09LTF9ZnVuY3Rpb24gayhlKXtyZXR1cm4gZS50b3VjaGVzP1tlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCxlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WV06W2UuY2xpZW50WCxlLmNsaWVudFldfWZ1bmN0aW9uIE8oZSx0KXtyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGVbMF0tdFswXSwyKStNYXRoLnBvdyhlWzFdLXRbMV0sMikpfWZ1bmN0aW9uIHgoKXtyZXR1cm5cInRyYW5zZm9ybVwiaW4gZG9jdW1lbnQuYm9keS5zdHlsZT9cInRyYW5zZm9ybVwiOlwid2Via2l0VHJhbnNmb3JtXCJpbiBkb2N1bWVudC5ib2R5LnN0eWxlP1wid2Via2l0VHJhbnNmb3JtXCI6XCJtb3pUcmFuc2Zvcm1cImluIGRvY3VtZW50LmJvZHkuc3R5bGU/XCJtb3pUcmFuc2Zvcm1cIjpcIm9UcmFuc2Zvcm1cImluIGRvY3VtZW50LmJvZHkuc3R5bGU/XCJvVHJhbnNmb3JtXCI6XCJtc1RyYW5zZm9ybVwifWZ1bmN0aW9uIFMoKXtyZXR1cm4gRHx8KEQ9eCgpKSxEfWZ1bmN0aW9uIEUoZSl7cmV0dXJuXCJ0cmFuc2xhdGUoXCIrZVswXStcInB4LFwiK2VbMV0rXCJweClcIn1mdW5jdGlvbiBNKGUsdCl7cmV0dXJuIGUuYmluZC5hcHBseShlLFtudWxsXS5jb25jYXQodCkpfWZ1bmN0aW9uIEMoKXtyZXR1cm4gTShhcmd1bWVudHNbMF0sQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX1mdW5jdGlvbiBLKGUpe3JldHVybiAyPT09ZS5idXR0b25zfHwyPT09ZS5idXR0b259ZnVuY3Rpb24gVChlKXt2YXIgdCxuPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PWUoKSksdH07cmV0dXJuIG4uY2xlYXI9ZnVuY3Rpb24oKXt0PXZvaWQgMH0sbn1mdW5jdGlvbiBBKGUpe3NldFRpbWVvdXQoZSwxKX12YXIgRCxCPTMyLGo9MixSPTE2LEw9NyxHPTIwLEY9OCxOPVtcImVhc3RcIixcIndlc3RcIixcIm5vcnRoXCIsXCJzb3V0aFwiXSxfPXtlYXN0OntlYXN0OlwiZG93blwiLHdlc3Q6XCJ1cFwiLG5vcnRoOlwicmlnaHRcIixzb3V0aDpcImxlZnRcIn0sd2VzdDp7ZWFzdDpcInVwXCIsd2VzdDpcImRvd25cIixub3J0aDpcImxlZnRcIixzb3V0aDpcInJpZ2h0XCJ9LG5vcnRoOntlYXN0OlwibGVmdFwiLHdlc3Q6XCJyaWdodFwiLG5vcnRoOlwiZG93blwiLHNvdXRoOlwidXBcIn0sc291dGg6e2Vhc3Q6XCJyaWdodFwiLHdlc3Q6XCJsZWZ0XCIsbm9ydGg6XCJ1cFwiLHNvdXRoOlwiZG93blwifX0sST17dXA6MCxsZWZ0OjEsZG93bjoyLHJpZ2h0OjN9LEg9e3VwOjMsbGVmdDowLGRvd246MSxyaWdodDoyfSxVPXt1cDpbLjUsMF0sbGVmdDpbMCwuNV0scmlnaHQ6WzEsLjVdLGRvd246Wy41LDFdfSxxPWZ1bmN0aW9uKGUpe3JldHVybiBVW2VdfSxYPWZ1bmN0aW9uKGUpe3JldHVybiAkW0lbZV1dfSx6PWZ1bmN0aW9uKGUpe3JldHVybiAkW0hbZV1dfSwkPVtcImR1cFwiLFwiZGxlZnRcIixcImRkb3duXCIsXCJkcmlnaHRcIl0sSj1cIm1taWRkbGVDb3VudFwiLFY9XCJtZ29zdGVyZ2VcIixZPXtkdXA6WzAsMF0sZGxlZnQ6WzAsTC0xXSxkZG93bjpbUi0xLEwtMV0sZHJpZ2h0OltSLTEsMF0sbW1pZGRsZUNvdW50OltSLTQsTC0xXSxtZ29zdGVyZ2U6W1ItMyxMLTFdfSxRPXtjb2xvcjpcImVtcHR5XCIsbnVtYmVyOjF9LFc9XCJiXCIsWj1cIm9cIixlZT1pKGosQiksdGU9aShGLEcpLG5lPVtbMCwwXSxbMzAsMF0sWzMxLDBdLFszMiwwXSxbNjIsMF0sWzYzLDBdXS5tYXAocCkscmU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5lLmluZGV4T2YoZSk9PT0tMX0sYWU9ZWUubWFwKHApLGllPWFlLmZpbHRlcihyZSksb2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGllLmluZGV4T2YoZSkhPT0tMX0sdWU9dGUubWFwKHkpLGxlPWZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm4gdC5waWVjZT1lLHR9LGRlPWZ1bmN0aW9uKGUpe3JldHVybntncm91cDplfX0sc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57cGllY2U6ZSxwb3M6dH19O3QuZXhwb3J0cz17dG9wQ29sdW1uczpSLHRvcFJvd3M6TCxjb2x1bW5zOkIscm93czpqLGVtcHR5UGllY2U6USxwaWVjZUVxdWFsOmEsYWxsU2lkZXM6TixhbGxQb3M6ZWUsYWxsS2V5czphZSx0b3BLZXkycG9zOmgscG9zMmtleTpwLGtleTJwb3M6dixpdGVyYXRvcjJLZXk6bSxuZXh0SXRlcmF0b3JGb3JHcm91cDpnLG1pbmlDb2x1bW5zOkcsbWluaVJvd3M6RixtaW5pQWxsUG9zOnRlLG1pbmlBbGxLZXlzOnVlLG1pbmlQb3Mya2V5OnksbWluaUtleTJwb3M6dyxlbmNvZGVLZXk6byxkZWNCb2FyZEtleTpsLG5vdEFsbG93ZWRCb2FyZEtleXM6bmUsaXNBbGxvd2VkQm9hcmRLZXk6cmUsaXNBbGxBbGxvd2VkQm9hcmRLZXk6b2UsYWxsQWxsb3dlZEJvYXJkS2V5czppZSxpc0JvYXJkS2V5OmQsaXNPcGVuc0tleTpzLGlzTWlkZGxlS2V5OmMsaXNEcmF3TGVmdEtleTpmLGZpbmRQb3Y6cix2ZWN0b3JCeVBvdjpxLGRyYXdCeVBvdjp6LGRpc2NhcmRCeVBvdjpYLGRpc2NhcmRzOiQsbWlkZGxlQ291bnQ6Sixnb3N0ZXJnZTpWLGNsYXNzU2V0OmIsY29udGFpbnNYOlAsZXZlbnRQb3NpdGlvbjprLGRpc3RhbmNlOk8sdHJhbnNmb3JtUHJvcDpTLHRyYW5zbGF0ZTpFLHJlcXVlc3RBbmltYXRpb25GcmFtZTood2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LnNldFRpbWVvdXQpLmJpbmQod2luZG93KSxwYXJ0aWFsQXBwbHk6TSxwYXJ0aWFsOkMsaXNSaWdodEJ1dHRvbjpLLG1lbW86VCx3cmFwUGllY2U6bGUsd3JhcEdyb3VwOmRlLHdyYXBEcm9wOnNlLGNhbGxVc2VyRnVuY3Rpb246QX19LHt9XSwxODpbZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntcImRlZmF1bHRcIjplfX1mdW5jdGlvbiBhKGUpe3JldHVybiBlLmNvbG9yK1wiIFwiK2UubnVtYmVyfWZ1bmN0aW9uIGkoZSl7cmV0dXJue2xlZnQ6ZVswXSooMTAwL1RbXCJkZWZhdWx0XCJdLmNvbHVtbnMpK1wiJVwiLHRvcDplWzFdKigxMDAvVFtcImRlZmF1bHRcIl0ucm93cykrXCIlXCJ9fWZ1bmN0aW9uIG8oZSl7cmV0dXJue2xlZnQ6ZVswXSooMTAwL1RbXCJkZWZhdWx0XCJdLm1pbmlDb2x1bW5zKStcIiVcIix0b3A6ZVsxXSooMTAwL1RbXCJkZWZhdWx0XCJdLm1pbmlSb3dzKStcIiVcIn19ZnVuY3Rpb24gdShlLHQsbixyKXt2YXIgaT0oZS5kYXRhLHtrZXk6bixzdHlsZTpvKHQpLFwiY2xhc3NcIjphKHIpK1wiIG1pbmlcIn0pO2lmKGUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltcyl7dmFyIHU9ZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW25dLGw9ZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LnNjYWxlc1tuXTt1JiYoaVtcImNsYXNzXCJdKz1cIiBhbmltYXRpbmdcIixpLnN0eWxlW1RbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV09VFtcImRlZmF1bHRcIl0udHJhbnNsYXRlKHVbMV0pLGwmJihpLnN0eWxlW1RbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV0rPVwiIHNjYWxlKFwiLmNvbmNhdChsWzBdLFwiLCBcIikuY29uY2F0KGxbMV0sXCIpXCIpLGkuc3R5bGUudHJhbnNmb3JtT3JpZ2luPVwiY2VudGVyXCIpKX1yZXR1cm57dGFnOlwicGllY2VcIixhdHRyczppfX1mdW5jdGlvbiBsKGUsdCxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdLGk9ZS5kYXRhLG89VFtcImRlZmF1bHRcIl0uY2xhc3NTZXQoe3NlbGVjdGVkOmkuc2VsZWN0ZWQ9PT10LFwibGFzdC1tb3ZlXCI6aS5sYXN0TW92ZSYmVFtcImRlZmF1bHRcIl0uY29udGFpbnNYKGkubGFzdE1vdmUsdCl9KSx1PXtzdHlsZTp7fSxcImNsYXNzXCI6W2EobiksdCxvXS5qb2luKFwiIFwiKSxcImRhdGEtbWlkZGxlLWNvdW50XCI6ZS5kYXRhLm1pZGRsZXNbdF19LGw9ZS5kYXRhLmRyYWdnYWJsZS5jdXJyZW50O2lmKHImJmwub3JpZz09PXQpdS5zdHlsZVtUW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldPVRbXCJkZWZhdWx0XCJdLnRyYW5zbGF0ZShbbC5wb3NbMF0rbC5kZWNbMF0sbC5wb3NbMV0rbC5kZWNbMV1dKSx1W1wiY2xhc3NcIl0rPVwiIGRyYWdnaW5nXCI7ZWxzZSBpZighciYmZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zKXt2YXIgZD1lLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXNbdF07ZCYmKHVbXCJjbGFzc1wiXSs9XCIgYW5pbWF0aW5nXCIsdS5zdHlsZVtUW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldPVRbXCJkZWZhdWx0XCJdLnRyYW5zbGF0ZShkWzFdKSl9cmV0dXJue3RhZzpcInBpZWNlXCIsYXR0cnM6dX19ZnVuY3Rpb24gZChlLHQsbixyKXt2YXIgaT0hKGFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdKXx8YXJndW1lbnRzWzRdLG89YXJndW1lbnRzLmxlbmd0aD41JiZ2b2lkIDAhPT1hcmd1bWVudHNbNV0/YXJndW1lbnRzWzVdOnQsdT1lLmRhdGEsbD1UW1wiZGVmYXVsdFwiXS5jbGFzc1NldCh7c2VsZWN0ZWQ6dS5zZWxlY3RlZD09PXR9KSxkPXtzdHlsZTp7fSxcImNsYXNzXCI6W2EobiksdCxsXS5qb2luKFwiIFwiKX07ciYmKGRbXCJjbGFzc1wiXSs9XCIgXCIrcik7dmFyIHM9ZS5kYXRhLmRyYWdnYWJsZS5jdXJyZW50O2lmKGkmJnMub3JpZz09PXQpZC5zdHlsZVtUW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldPVRbXCJkZWZhdWx0XCJdLnRyYW5zbGF0ZShbcy5wb3NbMF0rcy5kZWNbMF0scy5wb3NbMV0rcy5kZWNbMV1dKSxkW1wiY2xhc3NcIl0rPVwiIGRyYWdnaW5nXCI7ZWxzZSBpZihpJiZlLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXMpe3ZhciBjPWUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltc1tvXTtjJiYoZFtcImNsYXNzXCJdKz1cIiBhbmltYXRpbmdcIixkLnN0eWxlW1RbXCJkZWZhdWx0XCJdLnRyYW5zZm9ybVByb3AoKV09VFtcImRlZmF1bHRcIl0udHJhbnNsYXRlKGNbMV0pKX1yZXR1cm57dGFnOlwicGllY2VcIixhdHRyczpkfX1mdW5jdGlvbiBzKGUsdCxuKXt2YXIgcj0oZS5kYXRhLFRbXCJkZWZhdWx0XCJdLmNsYXNzU2V0KHtcInBpZWNlLWhvbGRlclwiOiEwfSkpLGE9e3N0eWxlOnt9LFwiY2xhc3NcIjpbdCxyLG5dLmpvaW4oXCIgXCIpfTtyZXR1cm57dGFnOlwiZGl2XCIsYXR0cnM6YX19ZnVuY3Rpb24gYyhlLHQsbixyKXt2YXIgYT1cImZsaXBwZXJcIisobj9cIiBob3ZlclwiOlwiXCIpK1wiIFwiK3IsaT17dG9wOjAsbGVmdDowfSxvPWUuYXR0cnMuc3R5bGU7ZS5hdHRycy5zdHlsZT1pLHQuYXR0cnMuc3R5bGU9aTt2YXIgdT17XCJjbGFzc1wiOmEsc3R5bGU6b307cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOnUsY2hpbGRyZW46W3t0YWc6XCJkaXZcIixhdHRyczp7XCJjbGFzc1wiOlwiZnJvbnRcIn0sY2hpbGRyZW46W2VdfSx7dGFnOlwiZGl2XCIsYXR0cnM6e1wiY2xhc3NcIjpcImJhY2tcIn0sY2hpbGRyZW46W3RdfV19fWZ1bmN0aW9uIGYoZSx0LG4scixvKXt2YXIgdT1lLmRhdGEsbD1UW1wiZGVmYXVsdFwiXS5jbGFzc1NldCh7c2VsZWN0ZWQ6dS5zZWxlY3RlZD09PW59KSxkPXtrZXk6bixzdHlsZTppKHQpLFwiY2xhc3NcIjpbYShyKSxsXS5qb2luKFwiIFwiKX07byYmKGRbXCJjbGFzc1wiXSs9XCIgXCIrbyk7dmFyIHM9ZS5kYXRhLmRyYWdnYWJsZS5jdXJyZW50O2lmKHMuZHJhZ0dyb3VwJiZzLmRyYWdHcm91cC5pbmRleE9mKG4pIT09LTE/KGQuc3R5bGVbVFtcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1UW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoW3MucG9zWzBdK3MuZGVjWzBdLHMucG9zWzFdK3MuZGVjWzFdXSksZFtcImNsYXNzXCJdKz1cIiBncm91cCBkcmFnZ2luZ1wiKTpzLm9yaWc9PT1uJiYocy5vdmVyJiZUW1wiZGVmYXVsdFwiXS5pc09wZW5zS2V5KHMub3ZlcikmJihkLnN0eWxlLndpZHRoPXMub3BlbnNCb3VuZHMud2lkdGgvVFtcImRlZmF1bHRcIl0ubWluaUNvbHVtbnMrXCJweFwiLGQuc3R5bGUuaGVpZ2h0PXMub3BlbnNCb3VuZHMuaGVpZ2h0L1RbXCJkZWZhdWx0XCJdLm1pbmlSb3dzK1wicHhcIiksZC5zdHlsZVtUW1wiZGVmYXVsdFwiXS50cmFuc2Zvcm1Qcm9wKCldPVRbXCJkZWZhdWx0XCJdLnRyYW5zbGF0ZShbcy5wb3NbMF0rcy5kZWNbMF0scy5wb3NbMV0rcy5kZWNbMV1dKSxkW1wiY2xhc3NcIl0rPVwiIGRyYWdnaW5nXCIpLGUuZGF0YS5hbmltYXRpb24uY3VycmVudC5hbmltcyl7dmFyIGM9ZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW25dO2MmJihkW1wiY2xhc3NcIl0rPVwiIGFuaW1hdGluZ1wiLGQuc3R5bGVbVFtcImRlZmF1bHRcIl0udHJhbnNmb3JtUHJvcCgpXT1UW1wiZGVmYXVsdFwiXS50cmFuc2xhdGUoY1sxXSkpfXJldHVybnt0YWc6XCJwaWVjZVwiLGF0dHJzOmR9fWZ1bmN0aW9uIHAoZSx0LG4pe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7XCJjbGFzc1wiOmUrXCIgb2MgXCIrbn19fWZ1bmN0aW9uIHYoZSx0LG4pe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7c3R5bGU6byhuKSxcImNsYXNzXCI6ZStcIiBvY1wifX19ZnVuY3Rpb24gbShlLHQsbil7cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntzdHlsZTppKG4pLFwiY2xhc3NcIjplfX19ZnVuY3Rpb24gZyhlKXtmdW5jdGlvbiB0KGUpe3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7XCJjbGFzc1wiOlwid29vZCBcIitlfX19dmFyIG4scj1lLmRhdGEsYT1UW1wiZGVmYXVsdFwiXS5hbGxQb3MsaT1bXTtpLnB1c2godChcImxlZnRcIiksdChcInJpZ2h0XCIpKTtmb3IodmFyIG89MDtvPGEubGVuZ3RoO28rKyl7dmFyIHU9VFtcImRlZmF1bHRcIl0ucG9zMmtleShhW29dKSxsPXIucGllY2VzW3VdO2lmKGwpe3ZhciBkPWYoZSxhW29dLHUsbCk7aWYoci5mbGlwcGFibGUuY3VycmVudC5vcmlnPT09dSl7dmFyIHMscCx2PXIuZmxpcHBhYmxlLmN1cnJlbnQuZmxpcCxnPWYoZSxhW29dLHUsVFtcImRlZmF1bHRcIl0uZW1wdHlQaWVjZSk7bC5mbGlwPyhzPWcscD1kKToocz1kLHA9ZyksaS5wdXNoKGMocyxwLHYpKX1lbHNlIGwuZmxpcCYmKGQ9ZihlLGFbb10sdSxUW1wiZGVmYXVsdFwiXS5lbXB0eVBpZWNlKSksaS5wdXNoKGQpfXIuZHJhZ2dhYmxlLmN1cnJlbnQub3Zlcj09PXUmJihuPW0oXCJkcmFnLW92ZXJcIixlLGFbb10pKX1yZXR1cm4gci5taWRkbGVIb2xkZXIua2V5JiZpLnB1c2goZihlLFRbXCJkZWZhdWx0XCJdLmtleTJwb3Moci5taWRkbGVIb2xkZXIua2V5KSxyLm1pZGRsZUhvbGRlci5rZXksVFtcImRlZmF1bHRcIl0uZW1wdHlQaWVjZSxcImxvYWRpbmdcIikpLG4mJmkucHVzaChuKSx7dGFnOlwiZGl2XCIsYXR0cnM6e2NvbmZpZzpmdW5jdGlvbih0LG4scil7bnx8KGUuZGF0YS5ib2FyZEJvdW5kcz1UW1wiZGVmYXVsdFwiXS5tZW1vKHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQodCkpKX0sXCJjbGFzc1wiOlwib2ctYm9hcmRcIn0sY2hpbGRyZW46aX19ZnVuY3Rpb24gaChlLHQpe2Zvcih2YXIgbj1lLmRhdGEscj1UW1wiZGVmYXVsdFwiXS5taW5pQWxsUG9zLGE9W10saT1bXSxvPTA7bzxyLmxlbmd0aDtvKyspe3ZhciBsPVRbXCJkZWZhdWx0XCJdLm1pbmlQb3Mya2V5KHJbb10pLGQ9dFtsXTtpZihkJiZhLnB1c2godShlLHJbb10sbCxkKSksZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zKXt2YXIgcz1lLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXNbbF07ZD1lLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuZXh0cmFbbF0scyYmZCYmYS5wdXNoKHUoZSxyW29dLGwsZCkpfXZhciBjPVRbXCJkZWZhdWx0XCJdLmNsYXNzU2V0KHtcImRyYWctb3ZlclwiOm4uZHJhZ2dhYmxlLmN1cnJlbnQub3Zlcj09PWwsXCJtb3ZlLWRlc3RcIjpUW1wiZGVmYXVsdFwiXS5jb250YWluc1gobi5vcGVuYWJsZS5kZXN0cyxsKX0pO1wiXCIhPT1jJiZpLnB1c2godihjLGUscltvXSkpfXJldHVybiBhLnB1c2goaSksYX1mdW5jdGlvbiB5KGUpe3ZhciB0PWUuZGF0YSxuPWgoZSx0Lm9wZW5zLmxheW91dC5sYXlvdXQpO3JldHVybnt0YWc6XCJkaXZcIixhdHRyczp7Y29uZmlnOmZ1bmN0aW9uKHQsbixyKXtufHwoZS5kYXRhLm9wZW5zQm91bmRzPVRbXCJkZWZhdWx0XCJdLm1lbW8odC5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZCh0KSkpfSxcImNsYXNzXCI6XCJvZy1vcGVuc1wifSxjaGlsZHJlbjpufX1mdW5jdGlvbiB3KGUpe3ZhciB0PWUuZGF0YSxuPVtdLHI9W107Zm9yKHZhciBhIGluIHQuZGlzY2FyZHMpe3ZhciBpPXQuZGlzY2FyZHNbYV1bMF0sbz1UW1wiZGVmYXVsdFwiXS5jbGFzc1NldCh7XCJkcmFnLW92ZXJcIjp0LmRyYWdnYWJsZS5jdXJyZW50Lm92ZXI9PT1hLFwibW92ZS1kZXN0XCI6XCJkZG93blwiPT09YSYmdC5zZWxlY3RlZCYmVFtcImRlZmF1bHRcIl0uaXNCb2FyZEtleSh0LnNlbGVjdGVkKSYmVFtcImRlZmF1bHRcIl0uY29udGFpbnNYKHQubW92YWJsZS5kZXN0cyxBW1wiZGVmYXVsdFwiXS5kaXNjYXJkKSxcImxhc3QtbW92ZVwiOnQubGFzdE1vdmUmJlRbXCJkZWZhdWx0XCJdLmNvbnRhaW5zWCh0Lmxhc3RNb3ZlLGEpfSk7aWYoaSl7dC5kaXNjYXJkc1thXVsxXSYmci5wdXNoKGQoZSxhLHQuZGlzY2FyZHNbYV1bMV0sXCJmYWtlXCIsITEpKSxyLnB1c2goZChlLGEsaSxvKSk7dmFyIHU9QVtcImRlZmF1bHRcIl0uZHJhd0xlZnQrYSxsPSEhZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zJiZlLmRhdGEuYW5pbWF0aW9uLmN1cnJlbnQuYW5pbXNbdV07aWYobCl7dmFyIGM9ZS5kYXRhLmFuaW1hdGlvbi5jdXJyZW50LmV4dHJhLnBpZWNlO3IucHVzaChkKGUsYSxjLG8sITAsdSkpfX1lbHNlIG4ucHVzaChzKGUsYSxvKSl9cmV0dXJuIG4ucHVzaChyKSxufWZ1bmN0aW9uIGIoZSl7dmFyIHQ9ZS5kYXRhLG49W10scj10Lm1pZGRsZUhvbGRlci5waWVjZXx8VFtcImRlZmF1bHRcIl0uZW1wdHlQaWVjZTtpZihuLnB1c2goZChlLFRbXCJkZWZhdWx0XCJdLmdvc3RlcmdlLHQubWlkZGxlc1tUW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZV0pKSxuLnB1c2gobChlLFRbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50LFRbXCJkZWZhdWx0XCJdLmVtcHR5UGllY2UpKSxUW1wiZGVmYXVsdFwiXS5pc01pZGRsZUtleSh0LmRyYWdnYWJsZS5jdXJyZW50Lm9yaWcpfHx0LmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zJiZ0LmFuaW1hdGlvbi5jdXJyZW50LmFuaW1zW1RbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50XSl7dmFyIGE9bChlLFRbXCJkZWZhdWx0XCJdLm1pZGRsZUNvdW50LHIsITApO24ucHVzaChhKX1yZXR1cm4gdC5kcmFnZ2FibGUuY3VycmVudC5vdmVyPT09VFtcImRlZmF1bHRcIl0uZ29zdGVyZ2UmJm4ucHVzaChwKFwiZHJhZy1vdmVyXCIsZSxUW1wiZGVmYXVsdFwiXS5nb3N0ZXJnZSkpLG59ZnVuY3Rpb24gUChlKXt2YXIgdD1bXSxuPWUuZGF0YS50b3BIb29rcztyZXR1cm4gbiYmdC5wdXNoKG4pLHR9ZnVuY3Rpb24gayhlKXt2YXIgdD1bYihlKSx3KGUpLHkoZSksUChlKV07cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntjb25maWc6ZnVuY3Rpb24odCxuLHIpe258fChlLmRhdGEudG9wQm91bmRzPVRbXCJkZWZhdWx0XCJdLm1lbW8odC5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZCh0KSkpfSxcImNsYXNzXCI6XCJvZy10b3BcIn0sY2hpbGRyZW46dH19ZnVuY3Rpb24gTyhlKXtyZXR1cm5bayhlKSxnKGUpXX1mdW5jdGlvbiB4KGUsdCxuKXtyZXR1cm4gZnVuY3Rpb24ocil7VFtcImRlZmF1bHRcIl0uaXNSaWdodEJ1dHRvbihyKT9uKGUscik6ZS52aWV3T25seXx8dChlLHIpfX1mdW5jdGlvbiBTKGUsdCxuKXt2YXIgcj1lLmRhdGEsYT14KHIsQ1tcImRlZmF1bHRcIl0uc3RhcnQsS1tcImRlZmF1bHRcIl0uc3RhcnQpLGk9eChyLENbXCJkZWZhdWx0XCJdLm1vdmUsS1tcImRlZmF1bHRcIl0ubW92ZSksbz14KHIsQ1tcImRlZmF1bHRcIl0uZW5kLEtbXCJkZWZhdWx0XCJdLmVuZCksdT1bXCJ0b3VjaHN0YXJ0XCIsXCJtb3VzZWRvd25cIl0sbD1bXCJ0b3VjaG1vdmVcIixcIm1vdXNlbW92ZVwiXSxkPVtcInRvdWNoZW5kXCIsXCJtb3VzZXVwXCJdO3UuZm9yRWFjaChmdW5jdGlvbihlKXt0LmFkZEV2ZW50TGlzdGVuZXIoZSxhKX0pLGwuZm9yRWFjaChmdW5jdGlvbihlKXtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGUsaSl9KSxkLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlLG8pfSksbi5vbnVubG9hZD1mdW5jdGlvbigpe3UuZm9yRWFjaChmdW5jdGlvbihlKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSxhKX0pLGwuZm9yRWFjaChmdW5jdGlvbihlKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGUsaSl9KSxkLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLG8pfSl9fWZ1bmN0aW9uIEUoZSl7cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntcImNsYXNzXCI6XCJvZy10YWJsZVwiLGNvbmZpZzpmdW5jdGlvbih0LG4scil7bnx8KGUuZGF0YS52aWV3T25seXx8UyhlLHQsciksZS5kYXRhLnJlbmRlcj1mdW5jdGlvbigpe01bXCJkZWZhdWx0XCJdLnJlbmRlcih0LE8oZSkpfSxlLmRhdGEucmVuZGVyUkFGPWZ1bmN0aW9uKCl7VFtcImRlZmF1bHRcIl0ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUuZGF0YS5yZW5kZXIpfSxlLmRhdGEuYm91bmRzPVRbXCJkZWZhdWx0XCJdLm1lbW8odC5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZCh0KSksZS5kYXRhLmVsZW1lbnQ9dCxlLmRhdGEucmVuZGVyKCkpfX0sY2hpbGRyZW46W119fXZhciBNPXIoZShcIm1pdGhyaWxcIikpLEM9cihlKFwiLi9kcmFnXCIpKSxLPXIoZShcIi4vZHJhd1wiKSksVD1yKGUoXCIuL3V0aWxcIikpLEE9cihlKFwiLi9tb3ZlXCIpKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJue3RhZzpcImRpdlwiLGF0dHJzOntjb25maWc6ZnVuY3Rpb24odCxuKXtufHwodC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIixmdW5jdGlvbihlKXtyZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpLCExfSksW1wib25zY3JvbGxcIixcIm9ucmVzaXplXCJdLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49d2luZG93W3RdO3dpbmRvd1t0XT1mdW5jdGlvbigpe24mJm4oKSxlLmRhdGEuYm91bmRzLmNsZWFyKCksZS5kYXRhLmJvYXJkQm91bmRzLmNsZWFyKCksZS5kYXRhLm9wZW5zQm91bmRzLmNsZWFyKCksZS5kYXRhLnRvcEJvdW5kcy5jbGVhcigpfX0pKX0sXCJjbGFzc1wiOltcIm9nLXRhYmxlLXdyYXBcIl0uam9pbihcIiBcIil9LGNoaWxkcmVuOltFKGUpXX19fSx7XCIuL2RyYWdcIjo5LFwiLi9kcmF3XCI6MTAsXCIuL21vdmVcIjoxMixcIi4vdXRpbFwiOjE3LG1pdGhyaWw6Mn1dfSx7fSxbMTFdKSgxMSl9KTsiLCIvKiBNSVQgbGljZW5zZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmdiMmhzbDogcmdiMmhzbCxcbiAgcmdiMmhzdjogcmdiMmhzdixcbiAgcmdiMmh3YjogcmdiMmh3YixcbiAgcmdiMmNteWs6IHJnYjJjbXlrLFxuICByZ2Iya2V5d29yZDogcmdiMmtleXdvcmQsXG4gIHJnYjJ4eXo6IHJnYjJ4eXosXG4gIHJnYjJsYWI6IHJnYjJsYWIsXG4gIHJnYjJsY2g6IHJnYjJsY2gsXG5cbiAgaHNsMnJnYjogaHNsMnJnYixcbiAgaHNsMmhzdjogaHNsMmhzdixcbiAgaHNsMmh3YjogaHNsMmh3YixcbiAgaHNsMmNteWs6IGhzbDJjbXlrLFxuICBoc2wya2V5d29yZDogaHNsMmtleXdvcmQsXG5cbiAgaHN2MnJnYjogaHN2MnJnYixcbiAgaHN2MmhzbDogaHN2MmhzbCxcbiAgaHN2Mmh3YjogaHN2Mmh3YixcbiAgaHN2MmNteWs6IGhzdjJjbXlrLFxuICBoc3Yya2V5d29yZDogaHN2MmtleXdvcmQsXG5cbiAgaHdiMnJnYjogaHdiMnJnYixcbiAgaHdiMmhzbDogaHdiMmhzbCxcbiAgaHdiMmhzdjogaHdiMmhzdixcbiAgaHdiMmNteWs6IGh3YjJjbXlrLFxuICBod2Iya2V5d29yZDogaHdiMmtleXdvcmQsXG5cbiAgY215azJyZ2I6IGNteWsycmdiLFxuICBjbXlrMmhzbDogY215azJoc2wsXG4gIGNteWsyaHN2OiBjbXlrMmhzdixcbiAgY215azJod2I6IGNteWsyaHdiLFxuICBjbXlrMmtleXdvcmQ6IGNteWsya2V5d29yZCxcblxuICBrZXl3b3JkMnJnYjoga2V5d29yZDJyZ2IsXG4gIGtleXdvcmQyaHNsOiBrZXl3b3JkMmhzbCxcbiAga2V5d29yZDJoc3Y6IGtleXdvcmQyaHN2LFxuICBrZXl3b3JkMmh3Yjoga2V5d29yZDJod2IsXG4gIGtleXdvcmQyY215azoga2V5d29yZDJjbXlrLFxuICBrZXl3b3JkMmxhYjoga2V5d29yZDJsYWIsXG4gIGtleXdvcmQyeHl6OiBrZXl3b3JkMnh5eixcblxuICB4eXoycmdiOiB4eXoycmdiLFxuICB4eXoybGFiOiB4eXoybGFiLFxuICB4eXoybGNoOiB4eXoybGNoLFxuXG4gIGxhYjJ4eXo6IGxhYjJ4eXosXG4gIGxhYjJyZ2I6IGxhYjJyZ2IsXG4gIGxhYjJsY2g6IGxhYjJsY2gsXG5cbiAgbGNoMmxhYjogbGNoMmxhYixcbiAgbGNoMnh5ejogbGNoMnh5eixcbiAgbGNoMnJnYjogbGNoMnJnYlxufVxuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG4iLCJ2YXIgY29udmVyc2lvbnMgPSByZXF1aXJlKFwiLi9jb252ZXJzaW9uc1wiKTtcblxudmFyIGNvbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgQ29udmVydGVyKCk7XG59XG5cbmZvciAodmFyIGZ1bmMgaW4gY29udmVyc2lvbnMpIHtcbiAgLy8gZXhwb3J0IFJhdyB2ZXJzaW9uc1xuICBjb252ZXJ0W2Z1bmMgKyBcIlJhd1wiXSA9ICAoZnVuY3Rpb24oZnVuYykge1xuICAgIC8vIGFjY2VwdCBhcnJheSBvciBwbGFpbiBhcmdzXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgIH1cbiAgfSkoZnVuYyk7XG5cbiAgdmFyIHBhaXIgPSAvKFxcdyspMihcXHcrKS8uZXhlYyhmdW5jKSxcbiAgICAgIGZyb20gPSBwYWlyWzFdLFxuICAgICAgdG8gPSBwYWlyWzJdO1xuXG4gIC8vIGV4cG9ydCByZ2IyaHNsIGFuZCBbXCJyZ2JcIl1bXCJoc2xcIl1cbiAgY29udmVydFtmcm9tXSA9IGNvbnZlcnRbZnJvbV0gfHwge307XG5cbiAgY29udmVydFtmcm9tXVt0b10gPSBjb252ZXJ0W2Z1bmNdID0gKGZ1bmN0aW9uKGZ1bmMpIHsgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIFxuICAgICAgdmFyIHZhbCA9IGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiIHx8IHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdmFsOyAvLyBrZXl3b3JkXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKVxuICAgICAgICB2YWxbaV0gPSBNYXRoLnJvdW5kKHZhbFtpXSk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSkoZnVuYyk7XG59XG5cblxuLyogQ29udmVydGVyIGRvZXMgbGF6eSBjb252ZXJzaW9uIGFuZCBjYWNoaW5nICovXG52YXIgQ29udmVydGVyID0gZnVuY3Rpb24oKSB7XG4gICB0aGlzLmNvbnZzID0ge307XG59O1xuXG4vKiBFaXRoZXIgZ2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2Ugb3JcbiAgc2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGRlcGVuZGluZyBvbiBhcmdzICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnJvdXRlU3BhY2UgPSBmdW5jdGlvbihzcGFjZSwgYXJncykge1xuICAgdmFyIHZhbHVlcyA9IGFyZ3NbMF07XG4gICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJnYigpXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuICAgfVxuICAgLy8gY29sb3IucmdiKDEwLCAxMCwgMTApXG4gICBpZiAodHlwZW9mIHZhbHVlcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTsgICAgICAgIFxuICAgfVxuXG4gICByZXR1cm4gdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHVlcyk7XG59O1xuICBcbi8qIFNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBpbnZhbGlkYXRpbmcgY2FjaGUgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UsIHZhbHVlcykge1xuICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgdGhpcy5jb252cyA9IHt9O1xuICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWx1ZXM7XG4gICByZXR1cm4gdGhpcztcbn07XG5cbi8qIEdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLiBJZiB0aGVyZSdzIGFscmVhZHlcbiAgYSBjb252ZXJzaW9uIGZvciB0aGUgc3BhY2UsIGZldGNoIGl0LCBvdGhlcndpc2VcbiAgY29tcHV0ZSBpdCAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSkge1xuICAgdmFyIHZhbHMgPSB0aGlzLmNvbnZzW3NwYWNlXTtcbiAgIGlmICghdmFscykge1xuICAgICAgdmFyIGZzcGFjZSA9IHRoaXMuc3BhY2UsXG4gICAgICAgICAgZnJvbSA9IHRoaXMuY29udnNbZnNwYWNlXTtcbiAgICAgIHZhbHMgPSBjb252ZXJ0W2ZzcGFjZV1bc3BhY2VdKGZyb20pO1xuXG4gICAgICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHM7XG4gICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuW1wicmdiXCIsIFwiaHNsXCIsIFwiaHN2XCIsIFwiY215a1wiLCBcImtleXdvcmRcIl0uZm9yRWFjaChmdW5jdGlvbihzcGFjZSkge1xuICAgQ29udmVydGVyLnByb3RvdHlwZVtzcGFjZV0gPSBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3V0ZVNwYWNlKHNwYWNlLCBhcmd1bWVudHMpO1xuICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDsiLCJtb2R1bGUuZXhwb3J0cz17XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59IiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb2xvck5hbWVzID0gcmVxdWlyZSgnY29sb3ItbmFtZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgIGdldFJnYmE6IGdldFJnYmEsXG4gICBnZXRIc2xhOiBnZXRIc2xhLFxuICAgZ2V0UmdiOiBnZXRSZ2IsXG4gICBnZXRIc2w6IGdldEhzbCxcbiAgIGdldEh3YjogZ2V0SHdiLFxuICAgZ2V0QWxwaGE6IGdldEFscGhhLFxuXG4gICBoZXhTdHJpbmc6IGhleFN0cmluZyxcbiAgIHJnYlN0cmluZzogcmdiU3RyaW5nLFxuICAgcmdiYVN0cmluZzogcmdiYVN0cmluZyxcbiAgIHBlcmNlbnRTdHJpbmc6IHBlcmNlbnRTdHJpbmcsXG4gICBwZXJjZW50YVN0cmluZzogcGVyY2VudGFTdHJpbmcsXG4gICBoc2xTdHJpbmc6IGhzbFN0cmluZyxcbiAgIGhzbGFTdHJpbmc6IGhzbGFTdHJpbmcsXG4gICBod2JTdHJpbmc6IGh3YlN0cmluZyxcbiAgIGtleXdvcmQ6IGtleXdvcmRcbn1cblxuZnVuY3Rpb24gZ2V0UmdiYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgYWJiciA9ICAvXiMoW2EtZkEtRjAtOV17M30pJC8sXG4gICAgICAgaGV4ID0gIC9eIyhbYS1mQS1GMC05XXs2fSkkLyxcbiAgICAgICByZ2JhID0gL15yZ2JhP1xcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooW1xcZFxcLl0rKVxccyopP1xcKSQvLFxuICAgICAgIHBlciA9IC9ecmdiYT9cXChcXHMqKFtcXGRcXC5dKylcXCVcXHMqLFxccyooW1xcZFxcLl0rKVxcJVxccyosXFxzKihbXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFtcXGRcXC5dKylcXHMqKT9cXCkkLyxcbiAgICAgICBrZXl3b3JkID0gLyhcXEQrKS87XG5cbiAgIHZhciByZ2IgPSBbMCwgMCwgMF0sXG4gICAgICAgYSA9IDEsXG4gICAgICAgbWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJicik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgICAgaWYgKG1hdGNoWzFdID09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJnYiA9IGNvbG9yTmFtZXNbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooXFxkKykoPzpkZWcpP1xccyosXFxzKihbXFxkXFwuXSspJVxccyosXFxzKihbXFxkXFwuXSspJVxccyooPzosXFxzKihbXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChoc2wpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICBzID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgbCA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzRdKSB8fCAxLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFxcZCspKD86ZGVnKT9cXHMqLFxccyooW1xcZFxcLl0rKSVcXHMqLFxccyooW1xcZFxcLl0rKSVcXHMqKD86LFxccyooW1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgdyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGIgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFs0XSkgfHwgMSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZ2Ioc3RyaW5nKSB7XG4gICB2YXIgcmdiYSA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIHJldHVybiByZ2JhICYmIHJnYmEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEhzbChzdHJpbmcpIHtcbiAgdmFyIGhzbGEgPSBnZXRIc2xhKHN0cmluZyk7XG4gIHJldHVybiBoc2xhICYmIGhzbGEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEFscGhhKHN0cmluZykge1xuICAgdmFyIHZhbHMgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICBpZiAodmFscykge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHNsYShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRId2Ioc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG59XG5cbi8vIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIGhleFN0cmluZyhyZ2IpIHtcbiAgIHJldHVybiBcIiNcIiArIGhleERvdWJsZShyZ2JbMF0pICsgaGV4RG91YmxlKHJnYlsxXSlcbiAgICAgICAgICAgICAgKyBoZXhEb3VibGUocmdiWzJdKTtcbn1cblxuZnVuY3Rpb24gcmdiU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChyZ2JhWzNdICE9PSB1bmRlZmluZWQgPyByZ2JhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdXG4gICAgICAgICAgICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudFN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG5cbiAgIHJldHVybiBcInJnYihcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlLCBcIiArIChhbHBoYSB8fCByZ2JhWzNdIHx8IDEpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbFN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAoaHNsYVszXSAmJiBoc2xhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbChcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChoc2xhWzNdICE9PSB1bmRlZmluZWQgPyBoc2xhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2xhKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSwgXCJcbiAgICAgICAgICAgKyBhbHBoYSArIFwiKVwiO1xufVxuXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxuLy8gKGh3YiBoYXZlIGFscGhhIG9wdGlvbmFsICYgMSBpcyBkZWZhdWx0IHZhbHVlKVxuZnVuY3Rpb24gaHdiU3RyaW5nKGh3YiwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChod2JbM10gIT09IHVuZGVmaW5lZCA/IGh3YlszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHdiKFwiICsgaHdiWzBdICsgXCIsIFwiICsgaHdiWzFdICsgXCIlLCBcIiArIGh3YlsyXSArIFwiJVwiXG4gICAgICAgICAgICsgKGFscGhhICE9PSB1bmRlZmluZWQgJiYgYWxwaGEgIT09IDEgPyBcIiwgXCIgKyBhbHBoYSA6IFwiXCIpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn1cblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gc2NhbGUobnVtLCBtaW4sIG1heCkge1xuICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxuXG5cbi8vY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG52YXIgcmV2ZXJzZU5hbWVzID0ge307XG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZXMpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWVzW25hbWVdXSA9IG5hbWU7XG59IiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjb252ZXJ0ID0gcmVxdWlyZShcImNvbG9yLWNvbnZlcnRcIiksXG4gICAgc3RyaW5nID0gcmVxdWlyZShcImNvbG9yLXN0cmluZ1wiKTtcblxudmFyIENvbG9yID0gZnVuY3Rpb24oY3NzU3RyaW5nKSB7XG4gIGlmIChjc3NTdHJpbmcgaW5zdGFuY2VvZiBDb2xvcikgcmV0dXJuIGNzc1N0cmluZztcbiAgaWYgKCEgKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHJldHVybiBuZXcgQ29sb3IoY3NzU3RyaW5nKTtcblxuICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICByZ2I6IFswLCAwLCAwXSxcbiAgICAgIGhzbDogWzAsIDAsIDBdLFxuICAgICAgaHN2OiBbMCwgMCwgMF0sXG4gICAgICBod2I6IFswLCAwLCAwXSxcbiAgICAgIGNteWs6IFswLCAwLCAwLCAwXSxcbiAgICAgIGFscGhhOiAxXG4gICB9XG5cbiAgIC8vIHBhcnNlIENvbG9yKCkgYXJndW1lbnRcbiAgIGlmICh0eXBlb2YgY3NzU3RyaW5nID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciB2YWxzID0gc3RyaW5nLmdldFJnYmEoY3NzU3RyaW5nKTtcbiAgICAgIGlmICh2YWxzKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCB2YWxzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFscyA9IHN0cmluZy5nZXRIc2xhKGNzc1N0cmluZykpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHNsXCIsIHZhbHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih2YWxzID0gc3RyaW5nLmdldEh3Yihjc3NTdHJpbmcpKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcImh3YlwiLCB2YWxzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBzdHJpbmcgXFxcIlwiICsgY3NzU3RyaW5nICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAodHlwZW9mIGNzc1N0cmluZyA9PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YXIgdmFscyA9IGNzc1N0cmluZztcbiAgICAgIGlmKHZhbHNbXCJyXCJdICE9PSB1bmRlZmluZWQgfHwgdmFsc1tcInJlZFwiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCB2YWxzKVxuICAgICAgfVxuICAgICAgZWxzZSBpZih2YWxzW1wibFwiXSAhPT0gdW5kZWZpbmVkIHx8IHZhbHNbXCJsaWdodG5lc3NcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdmFscylcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFsc1tcInZcIl0gIT09IHVuZGVmaW5lZCB8fCB2YWxzW1widmFsdWVcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc3ZcIiwgdmFscylcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYodmFsc1tcIndcIl0gIT09IHVuZGVmaW5lZCB8fCB2YWxzW1wid2hpdGVuZXNzXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHdiXCIsIHZhbHMpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKHZhbHNbXCJjXCJdICE9PSB1bmRlZmluZWQgfHwgdmFsc1tcImN5YW5cIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJjbXlrXCIsIHZhbHMpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gb2JqZWN0IFwiICsgSlNPTi5zdHJpbmdpZnkoY3NzU3RyaW5nKSk7XG4gICAgICB9XG4gICB9XG59XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcbiAgIHJnYjogZnVuY3Rpb24gKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNwYWNlKFwicmdiXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuICAgaHNsOiBmdW5jdGlvbih2YWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTcGFjZShcImhzbFwiLCBhcmd1bWVudHMpO1xuICAgfSxcbiAgIGhzdjogZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3BhY2UoXCJoc3ZcIiwgYXJndW1lbnRzKTtcbiAgIH0sXG4gICBod2I6IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFNwYWNlKFwiaHdiXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuICAgY215azogZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3BhY2UoXCJjbXlrXCIsIGFyZ3VtZW50cyk7XG4gICB9LFxuXG4gICByZ2JBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMucmdiO1xuICAgfSxcbiAgIGhzbEFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5oc2w7XG4gICB9LFxuICAgaHN2QXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmhzdjtcbiAgIH0sXG4gICBod2JBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZXMuYWxwaGEgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmh3Yi5jb25jYXQoW3RoaXMudmFsdWVzLmFscGhhXSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5od2I7XG4gICB9LFxuICAgY215a0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5jbXlrO1xuICAgfSxcbiAgIHJnYmFBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuICAgICAgcmV0dXJuIHJnYi5jb25jYXQoW3RoaXMudmFsdWVzLmFscGhhXSk7XG4gICB9LFxuICAgaHNsYUFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG4gICAgICByZXR1cm4gaHNsLmNvbmNhdChbdGhpcy52YWx1ZXMuYWxwaGFdKTtcbiAgIH0sXG4gICBhbHBoYTogZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5hbHBoYTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiYWxwaGFcIiwgdmFsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgcmVkOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJyZ2JcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBncmVlbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwicmdiXCIsIDEsIHZhbCk7XG4gICB9LFxuICAgYmx1ZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwicmdiXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgaHVlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc2xcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBzYXR1cmF0aW9uOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc2xcIiwgMSwgdmFsKTtcbiAgIH0sXG4gICBsaWdodG5lc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImhzbFwiLCAyLCB2YWwpO1xuICAgfSxcbiAgIHNhdHVyYXRpb252OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJoc3ZcIiwgMSwgdmFsKTtcbiAgIH0sXG4gICB3aGl0ZW5lc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImh3YlwiLCAxLCB2YWwpO1xuICAgfSxcbiAgIGJsYWNrbmVzczogZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGFubmVsKFwiaHdiXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgdmFsdWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImhzdlwiLCAyLCB2YWwpO1xuICAgfSxcbiAgIGN5YW46IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImNteWtcIiwgMCwgdmFsKTtcbiAgIH0sXG4gICBtYWdlbnRhOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJjbXlrXCIsIDEsIHZhbCk7XG4gICB9LFxuICAgeWVsbG93OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldENoYW5uZWwoXCJjbXlrXCIsIDIsIHZhbCk7XG4gICB9LFxuICAgYmxhY2s6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hhbm5lbChcImNteWtcIiwgMywgdmFsKTtcbiAgIH0sXG5cbiAgIGhleFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmhleFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IpO1xuICAgfSxcbiAgIHJnYlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJnYlN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICByZ2JhU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICBwZXJjZW50U3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucGVyY2VudFN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcbiAgIH0sXG4gICBoc2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5oc2xTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgaHNsYVN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG4gICB9LFxuICAgaHdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmcuaHdiU3RyaW5nKHRoaXMudmFsdWVzLmh3YiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuICAgfSxcbiAgIGtleXdvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0cmluZy5rZXl3b3JkKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuICAgfSxcblxuICAgcmdiTnVtYmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZXMucmdiWzBdIDw8IDE2KSB8ICh0aGlzLnZhbHVlcy5yZ2JbMV0gPDwgOCkgfCB0aGlzLnZhbHVlcy5yZ2JbMl07XG4gICB9LFxuXG4gICBsdW1pbm9zaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcbiAgICAgIHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG4gICAgICB2YXIgbHVtID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG4gICAgICAgICBsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MlxuICAgICAgICAgICAgICAgICAgOiBNYXRoLnBvdygoKGNoYW4gKyAwLjA1NSkgLyAxLjA1NSksIDIuNClcbiAgICAgIH1cbiAgICAgIHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG4gICB9LFxuXG4gICBjb250cmFzdDogZnVuY3Rpb24oY29sb3IyKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG4gICAgICB2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuICAgICAgdmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuICAgICAgaWYgKGx1bTEgPiBsdW0yKSB7XG4gICAgICAgICByZXR1cm4gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG4gICB9LFxuXG4gICBsZXZlbDogZnVuY3Rpb24oY29sb3IyKSB7XG4gICAgIHZhciBjb250cmFzdFJhdGlvID0gdGhpcy5jb250cmFzdChjb2xvcjIpO1xuICAgICByZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNy4xKVxuICAgICAgID8gJ0FBQSdcbiAgICAgICA6IChjb250cmFzdFJhdGlvID49IDQuNSlcbiAgICAgICAgPyAnQUEnXG4gICAgICAgIDogJyc7XG4gICB9LFxuXG4gICBkYXJrOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3RcbiAgICAgIHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2IsXG4gICAgICAgICAgeWlxID0gKHJnYlswXSAqIDI5OSArIHJnYlsxXSAqIDU4NyArIHJnYlsyXSAqIDExNCkgLyAxMDAwO1xuICAgXHRyZXR1cm4geWlxIDwgMTI4O1xuICAgfSxcblxuICAgbGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmRhcmsoKTtcbiAgIH0sXG5cbiAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gW11cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG4gICAgICB9XG4gICAgICB0aGlzLnNldFZhbHVlcyhcInJnYlwiLCByZ2IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICBsaWdodGVuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzJdICs9IHRoaXMudmFsdWVzLmhzbFsyXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgZGFya2VuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzJdIC09IHRoaXMudmFsdWVzLmhzbFsyXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgc2F0dXJhdGU6IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICB0aGlzLnZhbHVlcy5oc2xbMV0gKz0gdGhpcy52YWx1ZXMuaHNsWzFdICogcmF0aW87XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImhzbFwiLCB0aGlzLnZhbHVlcy5oc2wpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICBkZXNhdHVyYXRlOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzFdIC09IHRoaXMudmFsdWVzLmhzbFsxXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgd2hpdGVuOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgdGhpcy52YWx1ZXMuaHdiWzFdICs9IHRoaXMudmFsdWVzLmh3YlsxXSAqIHJhdGlvO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJod2JcIiwgdGhpcy52YWx1ZXMuaHdiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgYmxhY2tlbjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMudmFsdWVzLmh3YlsyXSArPSB0aGlzLnZhbHVlcy5od2JbMl0gKiByYXRpbztcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiaHdiXCIsIHRoaXMudmFsdWVzLmh3Yik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIGdyZXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmF5c2NhbGUjQ29udmVydGluZ19jb2xvcl90b19ncmF5c2NhbGVcbiAgICAgIHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwicmdiXCIsIFt2YWwsIHZhbCwgdmFsXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIGNsZWFyZXI6IGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICB0aGlzLnNldFZhbHVlcyhcImFscGhhXCIsIHRoaXMudmFsdWVzLmFscGhhIC0gKHRoaXMudmFsdWVzLmFscGhhICogcmF0aW8pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgb3BhcXVlcjogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwiYWxwaGFcIiwgdGhpcy52YWx1ZXMuYWxwaGEgKyAodGhpcy52YWx1ZXMuYWxwaGEgKiByYXRpbykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICByb3RhdGU6IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICAgIHZhciBodWUgPSB0aGlzLnZhbHVlcy5oc2xbMF07XG4gICAgICBodWUgPSAoaHVlICsgZGVncmVlcykgJSAzNjA7XG4gICAgICBodWUgPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuICAgICAgdGhpcy52YWx1ZXMuaHNsWzBdID0gaHVlO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJoc2xcIiwgdGhpcy52YWx1ZXMuaHNsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgbWl4OiBmdW5jdGlvbihjb2xvcjIsIHdlaWdodCkge1xuICAgICAgd2VpZ2h0ID0gMSAtICh3ZWlnaHQgPT0gbnVsbCA/IDAuNSA6IHdlaWdodCk7XG5cbiAgICAgIC8vIGFsZ29yaXRobSBmcm9tIFNhc3MncyBtaXgoKS4gUmF0aW8gb2YgZmlyc3QgY29sb3IgaW4gbWl4IGlzXG4gICAgICAvLyBkZXRlcm1pbmVkIGJ5IHRoZSBhbHBoYXMgb2YgYm90aCBjb2xvcnMgYW5kIHRoZSB3ZWlnaHRcbiAgICAgIHZhciB0MSA9IHdlaWdodCAqIDIgLSAxLFxuICAgICAgICAgIGQgPSB0aGlzLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuICAgICAgdmFyIHdlaWdodDEgPSAoKCh0MSAqIGQgPT0gLTEpID8gdDEgOiAodDEgKyBkKSAvICgxICsgdDEgKiBkKSkgKyAxKSAvIDI7XG4gICAgICB2YXIgd2VpZ2h0MiA9IDEgLSB3ZWlnaHQxO1xuXG4gICAgICB2YXIgcmdiID0gdGhpcy5yZ2JBcnJheSgpO1xuICAgICAgdmFyIHJnYjIgPSBjb2xvcjIucmdiQXJyYXkoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHJnYltpXSAqIHdlaWdodDEgKyByZ2IyW2ldICogd2VpZ2h0MjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0VmFsdWVzKFwicmdiXCIsIHJnYik7XG5cbiAgICAgIHZhciBhbHBoYSA9IHRoaXMuYWxwaGEoKSAqIHdlaWdodCArIGNvbG9yMi5hbHBoYSgpICogKDEgLSB3ZWlnaHQpO1xuICAgICAgdGhpcy5zZXRWYWx1ZXMoXCJhbHBoYVwiLCBhbHBoYSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgcmV0dXJuIHRoaXMucmdiKCk7XG4gICB9LFxuXG4gICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IoKSk7XG4gICB9XG59XG5cblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHt9O1xuICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsc1tzcGFjZVtpXV0gPSB0aGlzLnZhbHVlc1tzcGFjZV1baV07XG4gICB9XG4gICBpZiAodGhpcy52YWx1ZXMuYWxwaGEgIT0gMSkge1xuICAgICAgdmFsc1tcImFcIl0gPSB0aGlzLnZhbHVlcy5hbHBoYTtcbiAgIH1cbiAgIC8vIHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAwLjR9XG4gICByZXR1cm4gdmFscztcbn1cblxuQ29sb3IucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlLCB2YWxzKSB7XG4gICB2YXIgc3BhY2VzID0ge1xuICAgICAgXCJyZ2JcIjogW1wicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCJdLFxuICAgICAgXCJoc2xcIjogW1wiaHVlXCIsIFwic2F0dXJhdGlvblwiLCBcImxpZ2h0bmVzc1wiXSxcbiAgICAgIFwiaHN2XCI6IFtcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJ2YWx1ZVwiXSxcbiAgICAgIFwiaHdiXCI6IFtcImh1ZVwiLCBcIndoaXRlbmVzc1wiLCBcImJsYWNrbmVzc1wiXSxcbiAgICAgIFwiY215a1wiOiBbXCJjeWFuXCIsIFwibWFnZW50YVwiLCBcInllbGxvd1wiLCBcImJsYWNrXCJdXG4gICB9O1xuXG4gICB2YXIgbWF4ZXMgPSB7XG4gICAgICBcInJnYlwiOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICBcImhzbFwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImhzdlwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImh3YlwiOiBbMzYwLCAxMDAsIDEwMF0sXG4gICAgICBcImNteWtcIjogWzEwMCwgMTAwLCAxMDAsIDEwMF1cbiAgIH07XG5cbiAgIHZhciBhbHBoYSA9IDE7XG4gICBpZiAoc3BhY2UgPT0gXCJhbHBoYVwiKSB7XG4gICAgICBhbHBoYSA9IHZhbHM7XG4gICB9XG4gICBlbHNlIGlmICh2YWxzLmxlbmd0aCkge1xuICAgICAgLy8gWzEwLCAxMCwgMTBdXG4gICAgICB0aGlzLnZhbHVlc1tzcGFjZV0gPSB2YWxzLnNsaWNlKDAsIHNwYWNlLmxlbmd0aCk7XG4gICAgICBhbHBoYSA9IHZhbHNbc3BhY2UubGVuZ3RoXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHNbc3BhY2VbMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHtyOiAxMCwgZzogMTAsIGI6IDEwfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW3NwYWNlW2ldXTtcbiAgICAgIH1cbiAgICAgIGFscGhhID0gdmFscy5hO1xuICAgfVxuICAgZWxzZSBpZiAodmFsc1tzcGFjZXNbc3BhY2VdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB7cmVkOiAxMCwgZ3JlZW46IDEwLCBibHVlOiAxMH1cbiAgICAgIHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbY2hhbnNbaV1dO1xuICAgICAgfVxuICAgICAgYWxwaGEgPSB2YWxzLmFscGhhO1xuICAgfVxuICAgdGhpcy52YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogdGhpcy52YWx1ZXMuYWxwaGEpICkpO1xuICAgaWYgKHNwYWNlID09IFwiYWxwaGFcIikge1xuICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICAvLyBjYXAgdmFsdWVzIG9mIHRoZSBzcGFjZSBwcmlvciBjb252ZXJ0aW5nIGFsbCB2YWx1ZXNcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYXBwZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhlc1tzcGFjZV1baV0sIHRoaXMudmFsdWVzW3NwYWNlXVtpXSkpO1xuICAgICAgdGhpcy52YWx1ZXNbc3BhY2VdW2ldID0gTWF0aC5yb3VuZChjYXBwZWQpO1xuICAgfVxuXG4gICAvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG4gICBmb3IgKHZhciBzbmFtZSBpbiBzcGFjZXMpIHtcbiAgICAgIGlmIChzbmFtZSAhPSBzcGFjZSkge1xuICAgICAgICAgdGhpcy52YWx1ZXNbc25hbWVdID0gY29udmVydFtzcGFjZV1bc25hbWVdKHRoaXMudmFsdWVzW3NwYWNlXSlcbiAgICAgIH1cblxuICAgICAgLy8gY2FwIHZhbHVlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NuYW1lXVtpXSwgdGhpcy52YWx1ZXNbc25hbWVdW2ldKSk7XG4gICAgICAgICB0aGlzLnZhbHVlc1tzbmFtZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG4gICAgICB9XG4gICB9XG4gICByZXR1cm4gdHJ1ZTtcbn1cblxuQ29sb3IucHJvdG90eXBlLnNldFNwYWNlID0gZnVuY3Rpb24oc3BhY2UsIGFyZ3MpIHtcbiAgIHZhciB2YWxzID0gYXJnc1swXTtcbiAgIGlmICh2YWxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNvbG9yLnJnYigpXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuICAgfVxuICAgLy8gY29sb3IucmdiKDEwLCAxMCwgMTApXG4gICBpZiAodHlwZW9mIHZhbHMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuICAgfVxuICAgdGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuICAgcmV0dXJuIHRoaXM7XG59XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24oc3BhY2UsIGluZGV4LCB2YWwpIHtcbiAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmVkKClcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tzcGFjZV1baW5kZXhdO1xuICAgfVxuICAgLy8gY29sb3IucmVkKDEwMClcbiAgIHRoaXMudmFsdWVzW3NwYWNlXVtpbmRleF0gPSB2YWw7XG4gICB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdGhpcy52YWx1ZXNbc3BhY2VdKTtcbiAgIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiLyohIGlTY3JvbGwgdjUuMi4wIH4gKGMpIDIwMDgtMjAxNiBNYXR0ZW8gU3BpbmVsbGkgfiBodHRwOi8vY3ViaXEub3JnL2xpY2Vuc2UgKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgTWF0aCkge1xudmFyIHJBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdHx8XG5cdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcdFx0fHxcblx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXHRcdHx8XG5cdGZ1bmN0aW9uIChjYWxsYmFjaykgeyB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTsgfTtcblxudmFyIHV0aWxzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG1lID0ge307XG5cblx0dmFyIF9lbGVtZW50U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblx0dmFyIF92ZW5kb3IgPSAoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ZW5kb3JzID0gWyd0JywgJ3dlYmtpdFQnLCAnTW96VCcsICdtc1QnLCAnT1QnXSxcblx0XHRcdHRyYW5zZm9ybSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHZlbmRvcnMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dHJhbnNmb3JtID0gdmVuZG9yc1tpXSArICdyYW5zZm9ybSc7XG5cdFx0XHRpZiAoIHRyYW5zZm9ybSBpbiBfZWxlbWVudFN0eWxlICkgcmV0dXJuIHZlbmRvcnNbaV0uc3Vic3RyKDAsIHZlbmRvcnNbaV0ubGVuZ3RoLTEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBfcHJlZml4U3R5bGUgKHN0eWxlKSB7XG5cdFx0aWYgKCBfdmVuZG9yID09PSBmYWxzZSApIHJldHVybiBmYWxzZTtcblx0XHRpZiAoIF92ZW5kb3IgPT09ICcnICkgcmV0dXJuIHN0eWxlO1xuXHRcdHJldHVybiBfdmVuZG9yICsgc3R5bGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHlsZS5zdWJzdHIoMSk7XG5cdH1cblxuXHRtZS5nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gZ2V0VGltZSAoKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcblxuXHRtZS5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBvYmopIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBvYmogKSB7XG5cdFx0XHR0YXJnZXRbaV0gPSBvYmpbaV07XG5cdFx0fVxuXHR9O1xuXG5cdG1lLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuXHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sICEhY2FwdHVyZSk7XG5cdH07XG5cblx0bWUucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKSB7XG5cdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgISFjYXB0dXJlKTtcblx0fTtcblxuXHRtZS5wcmVmaXhQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAocG9pbnRlckV2ZW50KSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5NU1BvaW50ZXJFdmVudCA/XG5cdFx0XHQnTVNQb2ludGVyJyArIHBvaW50ZXJFdmVudC5jaGFyQXQoNykudG9VcHBlckNhc2UoKSArIHBvaW50ZXJFdmVudC5zdWJzdHIoOCk6XG5cdFx0XHRwb2ludGVyRXZlbnQ7XG5cdH07XG5cblx0bWUubW9tZW50dW0gPSBmdW5jdGlvbiAoY3VycmVudCwgc3RhcnQsIHRpbWUsIGxvd2VyTWFyZ2luLCB3cmFwcGVyU2l6ZSwgZGVjZWxlcmF0aW9uKSB7XG5cdFx0dmFyIGRpc3RhbmNlID0gY3VycmVudCAtIHN0YXJ0LFxuXHRcdFx0c3BlZWQgPSBNYXRoLmFicyhkaXN0YW5jZSkgLyB0aW1lLFxuXHRcdFx0ZGVzdGluYXRpb24sXG5cdFx0XHRkdXJhdGlvbjtcblxuXHRcdGRlY2VsZXJhdGlvbiA9IGRlY2VsZXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gMC4wMDA2IDogZGVjZWxlcmF0aW9uO1xuXG5cdFx0ZGVzdGluYXRpb24gPSBjdXJyZW50ICsgKCBzcGVlZCAqIHNwZWVkICkgLyAoIDIgKiBkZWNlbGVyYXRpb24gKSAqICggZGlzdGFuY2UgPCAwID8gLTEgOiAxICk7XG5cdFx0ZHVyYXRpb24gPSBzcGVlZCAvIGRlY2VsZXJhdGlvbjtcblxuXHRcdGlmICggZGVzdGluYXRpb24gPCBsb3dlck1hcmdpbiApIHtcblx0XHRcdGRlc3RpbmF0aW9uID0gd3JhcHBlclNpemUgPyBsb3dlck1hcmdpbiAtICggd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApICkgOiBsb3dlck1hcmdpbjtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoZGVzdGluYXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9IGVsc2UgaWYgKCBkZXN0aW5hdGlvbiA+IDAgKSB7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IHdyYXBwZXJTaXplID8gd3JhcHBlclNpemUgLyAyLjUgKiAoIHNwZWVkIC8gOCApIDogMDtcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoY3VycmVudCkgKyBkZXN0aW5hdGlvbjtcblx0XHRcdGR1cmF0aW9uID0gZGlzdGFuY2UgLyBzcGVlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVzdGluYXRpb246IE1hdGgucm91bmQoZGVzdGluYXRpb24pLFxuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0fTtcblx0fTtcblxuXHR2YXIgX3RyYW5zZm9ybSA9IF9wcmVmaXhTdHlsZSgndHJhbnNmb3JtJyk7XG5cblx0bWUuZXh0ZW5kKG1lLCB7XG5cdFx0aGFzVHJhbnNmb3JtOiBfdHJhbnNmb3JtICE9PSBmYWxzZSxcblx0XHRoYXNQZXJzcGVjdGl2ZTogX3ByZWZpeFN0eWxlKCdwZXJzcGVjdGl2ZScpIGluIF9lbGVtZW50U3R5bGUsXG5cdFx0aGFzVG91Y2g6ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyxcblx0XHRoYXNQb2ludGVyOiAhISh3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudCksIC8vIElFMTAgaXMgcHJlZml4ZWRcblx0XHRoYXNUcmFuc2l0aW9uOiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb24nKSBpbiBfZWxlbWVudFN0eWxlXG5cdH0pO1xuXG5cdC8qXG5cdFRoaXMgc2hvdWxkIGZpbmQgYWxsIEFuZHJvaWQgYnJvd3NlcnMgbG93ZXIgdGhhbiBidWlsZCA1MzUuMTkgKGJvdGggc3RvY2sgYnJvd3NlciBhbmQgd2Vidmlldylcblx0LSBnYWxheHkgUzIgaXMgb2tcbiAgICAtIDIuMy42IDogYEFwcGxlV2ViS2l0LzUzMy4xIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzMuMWBcbiAgICAtIDQuMC40IDogYEFwcGxlV2ViS2l0LzUzNC4zMCAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIE1vYmlsZSBTYWZhcmkvNTM0LjMwYFxuICAgLSBnYWxheHkgUzMgaXMgYmFkQW5kcm9pZCAoc3RvY2sgYnJvd2VyLCB3ZWJ2aWV3KVxuICAgICBgQXBwbGVXZWJLaXQvNTM0LjMwIChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzQuMzBgXG4gICAtIGdhbGF4eSBTNCBpcyBiYWRBbmRyb2lkIChzdG9jayBicm93ZXIsIHdlYnZpZXcpXG4gICAgIGBBcHBsZVdlYktpdC81MzQuMzAgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBNb2JpbGUgU2FmYXJpLzUzNC4zMGBcbiAgIC0gZ2FsYXh5IFM1IGlzIE9LXG4gICAgIGBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiAoQ2hyb21lLylgXG4gICAtIGdhbGF4eSBTNiBpcyBPS1xuICAgICBgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgTW9iaWxlIFNhZmFyaS81MzcuMzYgKENocm9tZS8pYFxuICAqL1xuXHRtZS5pc0JhZEFuZHJvaWQgPSAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFwcFZlcnNpb24gPSB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb247XG5cdFx0Ly8gQW5kcm9pZCBicm93c2VyIGlzIG5vdCBhIGNocm9tZSBicm93c2VyLlxuXHRcdGlmICgvQW5kcm9pZC8udGVzdChhcHBWZXJzaW9uKSAmJiAhKC9DaHJvbWVcXC9cXGQvLnRlc3QoYXBwVmVyc2lvbikpKSB7XG5cdFx0XHR2YXIgc2FmYXJpVmVyc2lvbiA9IGFwcFZlcnNpb24ubWF0Y2goL1NhZmFyaVxcLyhcXGQrLlxcZCkvKTtcblx0XHRcdGlmKHNhZmFyaVZlcnNpb24gJiYgdHlwZW9mIHNhZmFyaVZlcnNpb24gPT09IFwib2JqZWN0XCIgJiYgc2FmYXJpVmVyc2lvbi5sZW5ndGggPj0gMikge1xuXHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdChzYWZhcmlWZXJzaW9uWzFdKSA8IDUzNS4xOTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KSgpO1xuXG5cdG1lLmV4dGVuZChtZS5zdHlsZSA9IHt9LCB7XG5cdFx0dHJhbnNmb3JtOiBfdHJhbnNmb3JtLFxuXHRcdHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogX3ByZWZpeFN0eWxlKCd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nKSxcblx0XHR0cmFuc2l0aW9uRHVyYXRpb246IF9wcmVmaXhTdHlsZSgndHJhbnNpdGlvbkR1cmF0aW9uJyksXG5cdFx0dHJhbnNpdGlvbkRlbGF5OiBfcHJlZml4U3R5bGUoJ3RyYW5zaXRpb25EZWxheScpLFxuXHRcdHRyYW5zZm9ybU9yaWdpbjogX3ByZWZpeFN0eWxlKCd0cmFuc2Zvcm1PcmlnaW4nKVxuXHR9KTtcblxuXHRtZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChlLCBjKSB7XG5cdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgYyArIFwiKFxcXFxzfCQpXCIpO1xuXHRcdHJldHVybiByZS50ZXN0KGUuY2xhc3NOYW1lKTtcblx0fTtcblxuXHRtZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlLCBjKSB7XG5cdFx0aWYgKCBtZS5oYXNDbGFzcyhlLCBjKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbmV3Y2xhc3MgPSBlLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXHRcdG5ld2NsYXNzLnB1c2goYyk7XG5cdFx0ZS5jbGFzc05hbWUgPSBuZXdjbGFzcy5qb2luKCcgJyk7XG5cdH07XG5cblx0bWUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZSwgYykge1xuXHRcdGlmICggIW1lLmhhc0NsYXNzKGUsIGMpICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGMgKyBcIihcXFxcc3wkKVwiLCAnZycpO1xuXHRcdGUuY2xhc3NOYW1lID0gZS5jbGFzc05hbWUucmVwbGFjZShyZSwgJyAnKTtcblx0fTtcblxuXHRtZS5vZmZzZXQgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHR2YXIgbGVmdCA9IC1lbC5vZmZzZXRMZWZ0LFxuXHRcdFx0dG9wID0gLWVsLm9mZnNldFRvcDtcblxuXHRcdC8vIGpzaGludCAtVzA4NFxuXHRcdHdoaWxlIChlbCA9IGVsLm9mZnNldFBhcmVudCkge1xuXHRcdFx0bGVmdCAtPSBlbC5vZmZzZXRMZWZ0O1xuXHRcdFx0dG9wIC09IGVsLm9mZnNldFRvcDtcblx0XHR9XG5cdFx0Ly8ganNoaW50ICtXMDg0XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogbGVmdCxcblx0XHRcdHRvcDogdG9wXG5cdFx0fTtcblx0fTtcblxuXHRtZS5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChlbCwgZXhjZXB0aW9ucykge1xuXHRcdGZvciAoIHZhciBpIGluIGV4Y2VwdGlvbnMgKSB7XG5cdFx0XHRpZiAoIGV4Y2VwdGlvbnNbaV0udGVzdChlbFtpXSkgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRtZS5leHRlbmQobWUuZXZlbnRUeXBlID0ge30sIHtcblx0XHR0b3VjaHN0YXJ0OiAxLFxuXHRcdHRvdWNobW92ZTogMSxcblx0XHR0b3VjaGVuZDogMSxcblxuXHRcdG1vdXNlZG93bjogMixcblx0XHRtb3VzZW1vdmU6IDIsXG5cdFx0bW91c2V1cDogMixcblxuXHRcdHBvaW50ZXJkb3duOiAzLFxuXHRcdHBvaW50ZXJtb3ZlOiAzLFxuXHRcdHBvaW50ZXJ1cDogMyxcblxuXHRcdE1TUG9pbnRlckRvd246IDMsXG5cdFx0TVNQb2ludGVyTW92ZTogMyxcblx0XHRNU1BvaW50ZXJVcDogM1xuXHR9KTtcblxuXHRtZS5leHRlbmQobWUuZWFzZSA9IHt9LCB7XG5cdFx0cXVhZHJhdGljOiB7XG5cdFx0XHRzdHlsZTogJ2N1YmljLWJlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KScsXG5cdFx0XHRmbjogZnVuY3Rpb24gKGspIHtcblx0XHRcdFx0cmV0dXJuIGsgKiAoIDIgLSBrICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjaXJjdWxhcjoge1xuXHRcdFx0c3R5bGU6ICdjdWJpYy1iZXppZXIoMC4xLCAwLjU3LCAwLjEsIDEpJyxcdC8vIE5vdCBwcm9wZXJseSBcImNpcmN1bGFyXCIgYnV0IHRoaXMgbG9va3MgYmV0dGVyLCBpdCBzaG91bGQgYmUgKDAuMDc1LCAwLjgyLCAwLjE2NSwgMSlcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCAxIC0gKCAtLWsgKiBrICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGJhY2s6IHtcblx0XHRcdHN0eWxlOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMiwgMS4yNzUpJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHR2YXIgYiA9IDQ7XG5cdFx0XHRcdHJldHVybiAoIGsgPSBrIC0gMSApICogayAqICggKCBiICsgMSApICogayArIGIgKSArIDE7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRib3VuY2U6IHtcblx0XHRcdHN0eWxlOiAnJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRpZiAoICggayAvPSAxICkgPCAoIDEgLyAyLjc1ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyIC8gMi43NSApICkge1xuXHRcdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAxLjUgLyAyLjc1ICkgKSAqIGsgKyAwLjc1O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBrIDwgKCAyLjUgLyAyLjc1ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuMjUgLyAyLjc1ICkgKSAqIGsgKyAwLjkzNzU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqICggayAtPSAoIDIuNjI1IC8gMi43NSApICkgKiBrICsgMC45ODQzNzU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGVsYXN0aWM6IHtcblx0XHRcdHN0eWxlOiAnJyxcblx0XHRcdGZuOiBmdW5jdGlvbiAoaykge1xuXHRcdFx0XHR2YXIgZiA9IDAuMjIsXG5cdFx0XHRcdFx0ZSA9IDAuNDtcblxuXHRcdFx0XHRpZiAoIGsgPT09IDAgKSB7IHJldHVybiAwOyB9XG5cdFx0XHRcdGlmICggayA9PSAxICkgeyByZXR1cm4gMTsgfVxuXG5cdFx0XHRcdHJldHVybiAoIGUgKiBNYXRoLnBvdyggMiwgLSAxMCAqIGsgKSAqIE1hdGguc2luKCAoIGsgLSBmIC8gNCApICogKCAyICogTWF0aC5QSSApIC8gZiApICsgMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0bWUudGFwID0gZnVuY3Rpb24gKGUsIGV2ZW50TmFtZSkge1xuXHRcdHZhciBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuXHRcdGV2LmluaXRFdmVudChldmVudE5hbWUsIHRydWUsIHRydWUpO1xuXHRcdGV2LnBhZ2VYID0gZS5wYWdlWDtcblx0XHRldi5wYWdlWSA9IGUucGFnZVk7XG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG5cdH07XG5cblx0bWUuY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldCxcblx0XHRcdGV2O1xuXG5cdFx0aWYgKCAhKC8oU0VMRUNUfElOUFVUfFRFWFRBUkVBKS9pKS50ZXN0KHRhcmdldC50YWdOYW1lKSApIHtcblx0XHRcdGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyk7XG5cdFx0XHRldi5pbml0TW91c2VFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlLCBlLnZpZXcsIDEsXG5cdFx0XHRcdHRhcmdldC5zY3JlZW5YLCB0YXJnZXQuc2NyZWVuWSwgdGFyZ2V0LmNsaWVudFgsIHRhcmdldC5jbGllbnRZLFxuXHRcdFx0XHRlLmN0cmxLZXksIGUuYWx0S2V5LCBlLnNoaWZ0S2V5LCBlLm1ldGFLZXksXG5cdFx0XHRcdDAsIG51bGwpO1xuXG5cdFx0XHRldi5fY29uc3RydWN0ZWQgPSB0cnVlO1xuXHRcdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXYpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gbWU7XG59KSgpO1xuZnVuY3Rpb24gSVNjcm9sbCAoZWwsIG9wdGlvbnMpIHtcblx0dGhpcy53cmFwcGVyID0gdHlwZW9mIGVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcblx0dGhpcy5zY3JvbGxlciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5zY3JvbGxlclN0eWxlID0gdGhpcy5zY3JvbGxlci5zdHlsZTtcdFx0Ly8gY2FjaGUgc3R5bGUgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXG5cdHRoaXMub3B0aW9ucyA9IHtcblxuXHRcdHJlc2l6ZVNjcm9sbGJhcnM6IHRydWUsXG5cblx0XHRtb3VzZVdoZWVsU3BlZWQ6IDIwLFxuXG5cdFx0c25hcFRocmVzaG9sZDogMC4zMzQsXG5cbi8vIElOU0VSVCBQT0lOVDogT1BUSU9OU1xuXHRcdGRpc2FibGVQb2ludGVyIDogIXV0aWxzLmhhc1BvaW50ZXIsXG5cdFx0ZGlzYWJsZVRvdWNoIDogdXRpbHMuaGFzUG9pbnRlciB8fCAhdXRpbHMuaGFzVG91Y2gsXG5cdFx0ZGlzYWJsZU1vdXNlIDogdXRpbHMuaGFzUG9pbnRlciB8fCB1dGlscy5oYXNUb3VjaCxcblx0XHRzdGFydFg6IDAsXG5cdFx0c3RhcnRZOiAwLFxuXHRcdHNjcm9sbFk6IHRydWUsXG5cdFx0ZGlyZWN0aW9uTG9ja1RocmVzaG9sZDogNSxcblx0XHRtb21lbnR1bTogdHJ1ZSxcblxuXHRcdGJvdW5jZTogdHJ1ZSxcblx0XHRib3VuY2VUaW1lOiA2MDAsXG5cdFx0Ym91bmNlRWFzaW5nOiAnJyxcblxuXHRcdHByZXZlbnREZWZhdWx0OiB0cnVlLFxuXHRcdHByZXZlbnREZWZhdWx0RXhjZXB0aW9uOiB7IHRhZ05hbWU6IC9eKElOUFVUfFRFWFRBUkVBfEJVVFRPTnxTRUxFQ1QpJC8gfSxcblxuXHRcdEhXQ29tcG9zaXRpbmc6IHRydWUsXG5cdFx0dXNlVHJhbnNpdGlvbjogdHJ1ZSxcblx0XHR1c2VUcmFuc2Zvcm06IHRydWUsXG5cdFx0YmluZFRvV3JhcHBlcjogdHlwZW9mIHdpbmRvdy5vbm1vdXNlZG93biA9PT0gXCJ1bmRlZmluZWRcIlxuXHR9O1xuXG5cdGZvciAoIHZhciBpIGluIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHRpb25zXG5cdHRoaXMudHJhbnNsYXRlWiA9IHRoaXMub3B0aW9ucy5IV0NvbXBvc2l0aW5nICYmIHV0aWxzLmhhc1BlcnNwZWN0aXZlID8gJyB0cmFuc2xhdGVaKDApJyA6ICcnO1xuXG5cdHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uID0gdXRpbHMuaGFzVHJhbnNpdGlvbiAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNpdGlvbjtcblx0dGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSA9IHV0aWxzLmhhc1RyYW5zZm9ybSAmJiB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtO1xuXG5cdHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT09IHRydWUgPyAndmVydGljYWwnIDogdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCA9ICF0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCAmJiB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQ7XG5cblx0Ly8gSWYgeW91IHdhbnQgZXZlbnRQYXNzdGhyb3VnaCBJIGhhdmUgdG8gbG9jayBvbmUgb2YgdGhlIGF4ZXNcblx0dGhpcy5vcHRpb25zLnNjcm9sbFkgPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2Nyb2xsWTtcblx0dGhpcy5vcHRpb25zLnNjcm9sbFggPSB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAnaG9yaXpvbnRhbCcgPyBmYWxzZSA6IHRoaXMub3B0aW9ucy5zY3JvbGxYO1xuXG5cdC8vIFdpdGggZXZlbnRQYXNzdGhyb3VnaCB3ZSBhbHNvIG5lZWQgbG9ja0RpcmVjdGlvbiBtZWNoYW5pc21cblx0dGhpcy5vcHRpb25zLmZyZWVTY3JvbGwgPSB0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCAmJiAhdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2g7XG5cdHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPyAwIDogdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQ7XG5cblx0dGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nID09ICdzdHJpbmcnID8gdXRpbHMuZWFzZVt0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nXSB8fCB1dGlscy5lYXNlLmNpcmN1bGFyIDogdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblxuXHR0aGlzLm9wdGlvbnMucmVzaXplUG9sbGluZyA9IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nID09PSB1bmRlZmluZWQgPyA2MCA6IHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nO1xuXG5cdGlmICggdGhpcy5vcHRpb25zLnRhcCA9PT0gdHJ1ZSApIHtcblx0XHR0aGlzLm9wdGlvbnMudGFwID0gJ3RhcCc7XG5cdH1cblxuXHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzID09ICdzY2FsZScgKSB7XG5cdFx0dGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gPSBmYWxzZTtcblx0fVxuXG5cdHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbiA/IC0xIDogMTtcblxuLy8gSU5TRVJUIFBPSU5UOiBOT1JNQUxJWkFUSU9OXG5cblx0Ly8gU29tZSBkZWZhdWx0c1xuXHR0aGlzLnggPSAwO1xuXHR0aGlzLnkgPSAwO1xuXHR0aGlzLmRpcmVjdGlvblggPSAwO1xuXHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXHR0aGlzLl9ldmVudHMgPSB7fTtcblxuLy8gSU5TRVJUIFBPSU5UOiBERUZBVUxUU1xuXG5cdHRoaXMuX2luaXQoKTtcblx0dGhpcy5yZWZyZXNoKCk7XG5cblx0dGhpcy5zY3JvbGxUbyh0aGlzLm9wdGlvbnMuc3RhcnRYLCB0aGlzLm9wdGlvbnMuc3RhcnRZKTtcblx0dGhpcy5lbmFibGUoKTtcbn1cblxuSVNjcm9sbC5wcm90b3R5cGUgPSB7XG5cdHZlcnNpb246ICc1LjIuMCcsXG5cblx0X2luaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzIHx8IHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzICkge1xuXHRcdFx0dGhpcy5faW5pdEluZGljYXRvcnMoKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsICkge1xuXHRcdFx0dGhpcy5faW5pdFdoZWVsKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHRoaXMuX2luaXRTbmFwKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgKSB7XG5cdFx0XHR0aGlzLl9pbml0S2V5cygpO1xuXHRcdH1cblxuLy8gSU5TRVJUIFBPSU5UOiBfaW5pdFxuXG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2luaXRFdmVudHModHJ1ZSk7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gXHRcdHRoaXMucmVzaXplVGltZW91dCA9IG51bGw7XG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdkZXN0cm95Jyk7XG5cdH0sXG5cblx0X3RyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCBlLnRhcmdldCAhPSB0aGlzLnNjcm9sbGVyIHx8ICF0aGlzLmlzSW5UcmFuc2l0aW9uICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKCk7XG5cdFx0aWYgKCAhdGhpcy5yZXNldFBvc2l0aW9uKHRoaXMub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHQvLyBSZWFjdCB0byBsZWZ0IG1vdXNlIGJ1dHRvbiBvbmx5XG5cdFx0aWYgKCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPSAxICkge1xuXHRcdCAgLy8gZm9yIGJ1dHRvbiBwcm9wZXJ0eVxuXHRcdCAgLy8gaHR0cDovL3VuaXhwYXBhLmNvbS9qcy9tb3VzZS5odG1sXG5cdFx0ICB2YXIgYnV0dG9uO1xuXHQgICAgaWYgKCFlLndoaWNoKSB7XG5cdCAgICAgIC8qIElFIGNhc2UgKi9cblx0ICAgICAgYnV0dG9uID0gKGUuYnV0dG9uIDwgMikgPyAwIDpcblx0ICAgICAgICAgICAgICAgKChlLmJ1dHRvbiA9PSA0KSA/IDEgOiAyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8qIEFsbCBvdGhlcnMgKi9cblx0ICAgICAgYnV0dG9uID0gZS5idXR0b247XG5cdCAgICB9XG5cdFx0XHRpZiAoIGJ1dHRvbiAhPT0gMCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCAodGhpcy5pbml0aWF0ZWQgJiYgdXRpbHMuZXZlbnRUeXBlW2UudHlwZV0gIT09IHRoaXMuaW5pdGlhdGVkKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAmJiAhdXRpbHMuaXNCYWRBbmRyb2lkICYmICF1dGlscy5wcmV2ZW50RGVmYXVsdEV4Y2VwdGlvbihlLnRhcmdldCwgdGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLFxuXHRcdFx0cG9zO1xuXG5cdFx0dGhpcy5pbml0aWF0ZWRcdD0gdXRpbHMuZXZlbnRUeXBlW2UudHlwZV07XG5cdFx0dGhpcy5tb3ZlZFx0XHQ9IGZhbHNlO1xuXHRcdHRoaXMuZGlzdFhcdFx0PSAwO1xuXHRcdHRoaXMuZGlzdFlcdFx0PSAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25ZID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9IDA7XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKCk7XG5cdFx0XHR0aGlzLmlzSW5UcmFuc2l0aW9uID0gZmFsc2U7XG5cdFx0XHRwb3MgPSB0aGlzLmdldENvbXB1dGVkUG9zaXRpb24oKTtcblx0XHRcdHRoaXMuX3RyYW5zbGF0ZShNYXRoLnJvdW5kKHBvcy54KSwgTWF0aC5yb3VuZChwb3MueSkpO1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHR9IGVsc2UgaWYgKCAhdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0FuaW1hdGluZyApIHtcblx0XHRcdHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdGFydFggICAgPSB0aGlzLng7XG5cdFx0dGhpcy5zdGFydFkgICAgPSB0aGlzLnk7XG5cdFx0dGhpcy5hYnNTdGFydFggPSB0aGlzLng7XG5cdFx0dGhpcy5hYnNTdGFydFkgPSB0aGlzLnk7XG5cdFx0dGhpcy5wb2ludFggICAgPSBwb2ludC5wYWdlWDtcblx0XHR0aGlzLnBvaW50WSAgICA9IHBvaW50LnBhZ2VZO1xuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdiZWZvcmVTY3JvbGxTdGFydCcpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPT0gdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgKSB7XHQvLyBpbmNyZWFzZXMgcGVyZm9ybWFuY2Ugb24gQW5kcm9pZD8gVE9ETzogY2hlY2shXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0dmFyIHBvaW50XHRcdD0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcblx0XHRcdGRlbHRhWFx0XHQ9IHBvaW50LnBhZ2VYIC0gdGhpcy5wb2ludFgsXG5cdFx0XHRkZWx0YVlcdFx0PSBwb2ludC5wYWdlWSAtIHRoaXMucG9pbnRZLFxuXHRcdFx0dGltZXN0YW1wXHQ9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHRhYnNEaXN0WCwgYWJzRGlzdFk7XG5cblx0XHR0aGlzLnBvaW50WFx0XHQ9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMucG9pbnRZXHRcdD0gcG9pbnQucGFnZVk7XG5cblx0XHR0aGlzLmRpc3RYXHRcdCs9IGRlbHRhWDtcblx0XHR0aGlzLmRpc3RZXHRcdCs9IGRlbHRhWTtcblx0XHRhYnNEaXN0WFx0XHQ9IE1hdGguYWJzKHRoaXMuZGlzdFgpO1xuXHRcdGFic0Rpc3RZXHRcdD0gTWF0aC5hYnModGhpcy5kaXN0WSk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIG1vdmUgYXQgbGVhc3QgMTAgcGl4ZWxzIGZvciB0aGUgc2Nyb2xsaW5nIHRvIGluaXRpYXRlXG5cdFx0aWYgKCB0aW1lc3RhbXAgLSB0aGlzLmVuZFRpbWUgPiAzMDAgJiYgKGFic0Rpc3RYIDwgMTAgJiYgYWJzRGlzdFkgPCAxMCkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgeW91IGFyZSBzY3JvbGxpbmcgaW4gb25lIGRpcmVjdGlvbiBsb2NrIHRoZSBvdGhlclxuXHRcdGlmICggIXRoaXMuZGlyZWN0aW9uTG9ja2VkICYmICF0aGlzLm9wdGlvbnMuZnJlZVNjcm9sbCApIHtcblx0XHRcdGlmICggYWJzRGlzdFggPiBhYnNEaXN0WSArIHRoaXMub3B0aW9ucy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkICkge1xuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkxvY2tlZCA9ICdoJztcdFx0Ly8gbG9jayBob3Jpem9udGFsbHlcblx0XHRcdH0gZWxzZSBpZiAoIGFic0Rpc3RZID49IGFic0Rpc3RYICsgdGhpcy5vcHRpb25zLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQgKSB7XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uTG9ja2VkID0gJ3YnO1x0XHQvLyBsb2NrIHZlcnRpY2FsbHlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uTG9ja2VkID0gJ24nO1x0XHQvLyBubyBsb2NrXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmRpcmVjdGlvbkxvY2tlZCA9PSAnaCcgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICd2ZXJ0aWNhbCcgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5ldmVudFBhc3N0aHJvdWdoID09ICdob3Jpem9udGFsJyApIHtcblx0XHRcdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YVkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMuZGlyZWN0aW9uTG9ja2VkID09ICd2JyApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmV2ZW50UGFzc3Rocm91Z2ggPT0gJ2hvcml6b250YWwnICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuZXZlbnRQYXNzdGhyb3VnaCA9PSAndmVydGljYWwnICkge1xuXHRcdFx0XHR0aGlzLmluaXRpYXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhWCA9IDA7XG5cdFx0fVxuXG5cdFx0ZGVsdGFYID0gdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsID8gZGVsdGFYIDogMDtcblx0XHRkZWx0YVkgPSB0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsID8gZGVsdGFZIDogMDtcblxuXHRcdG5ld1ggPSB0aGlzLnggKyBkZWx0YVg7XG5cdFx0bmV3WSA9IHRoaXMueSArIGRlbHRhWTtcblxuXHRcdC8vIFNsb3cgZG93biBpZiBvdXRzaWRlIG9mIHRoZSBib3VuZGFyaWVzXG5cdFx0aWYgKCBuZXdYID4gMCB8fCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYICkge1xuXHRcdFx0bmV3WCA9IHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLnggKyBkZWx0YVggLyAzIDogbmV3WCA+IDAgPyAwIDogdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblx0XHRpZiAoIG5ld1kgPiAwIHx8IG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRuZXdZID0gdGhpcy5vcHRpb25zLmJvdW5jZSA/IHRoaXMueSArIGRlbHRhWSAvIDMgOiBuZXdZID4gMCA/IDAgOiB0aGlzLm1heFNjcm9sbFk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gZGVsdGFYID4gMCA/IC0xIDogZGVsdGFYIDwgMCA/IDEgOiAwO1xuXHRcdHRoaXMuZGlyZWN0aW9uWSA9IGRlbHRhWSA+IDAgPyAtMSA6IGRlbHRhWSA8IDAgPyAxIDogMDtcblxuXHRcdGlmICggIXRoaXMubW92ZWQgKSB7XG5cdFx0XHR0aGlzLl9leGVjRXZlbnQoJ3Njcm9sbFN0YXJ0Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb3ZlZCA9IHRydWU7XG5cblx0XHR0aGlzLl90cmFuc2xhdGUobmV3WCwgbmV3WSk7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IF9tb3ZlICovXG5cblx0XHRpZiAoIHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lID4gMzAwICkge1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSB0aW1lc3RhbXA7XG5cdFx0XHR0aGlzLnN0YXJ0WCA9IHRoaXMueDtcblx0XHRcdHRoaXMuc3RhcnRZID0gdGhpcy55O1xuXHRcdH1cblxuLyogUkVQTEFDRSBFTkQ6IF9tb3ZlICovXG5cblx0fSxcblxuXHRfZW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdGlmICggIXRoaXMuZW5hYmxlZCB8fCB1dGlscy5ldmVudFR5cGVbZS50eXBlXSAhPT0gdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQgJiYgIXV0aWxzLnByZXZlbnREZWZhdWx0RXhjZXB0aW9uKGUudGFyZ2V0LCB0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHRFeGNlcHRpb24pICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHZhciBwb2ludCA9IGUuY2hhbmdlZFRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZSxcblx0XHRcdG1vbWVudHVtWCxcblx0XHRcdG1vbWVudHVtWSxcblx0XHRcdGR1cmF0aW9uID0gdXRpbHMuZ2V0VGltZSgpIC0gdGhpcy5zdGFydFRpbWUsXG5cdFx0XHRuZXdYID0gTWF0aC5yb3VuZCh0aGlzLngpLFxuXHRcdFx0bmV3WSA9IE1hdGgucm91bmQodGhpcy55KSxcblx0XHRcdGRpc3RhbmNlWCA9IE1hdGguYWJzKG5ld1ggLSB0aGlzLnN0YXJ0WCksXG5cdFx0XHRkaXN0YW5jZVkgPSBNYXRoLmFicyhuZXdZIC0gdGhpcy5zdGFydFkpLFxuXHRcdFx0dGltZSA9IDAsXG5cdFx0XHRlYXNpbmcgPSAnJztcblxuXHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSAwO1xuXHRcdHRoaXMuaW5pdGlhdGVkID0gMDtcblx0XHR0aGlzLmVuZFRpbWUgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHQvLyByZXNldCBpZiB3ZSBhcmUgb3V0c2lkZSBvZiB0aGUgYm91bmRhcmllc1xuXHRcdGlmICggdGhpcy5yZXNldFBvc2l0aW9uKHRoaXMub3B0aW9ucy5ib3VuY2VUaW1lKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1kpO1x0Ly8gZW5zdXJlcyB0aGF0IHRoZSBsYXN0IHBvc2l0aW9uIGlzIHJvdW5kZWRcblxuXHRcdC8vIHdlIHNjcm9sbGVkIGxlc3MgdGhhbiAxMCBwaXhlbHNcblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMudGFwICkge1xuXHRcdFx0XHR1dGlscy50YXAoZSwgdGhpcy5vcHRpb25zLnRhcCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNrICkge1xuXHRcdFx0XHR1dGlscy5jbGljayhlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxDYW5jZWwnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX2V2ZW50cy5mbGljayAmJiBkdXJhdGlvbiA8IDIwMCAmJiBkaXN0YW5jZVggPCAxMDAgJiYgZGlzdGFuY2VZIDwgMTAwICkge1xuXHRcdFx0dGhpcy5fZXhlY0V2ZW50KCdmbGljaycpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHN0YXJ0IG1vbWVudHVtIGFuaW1hdGlvbiBpZiBuZWVkZWRcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5tb21lbnR1bSAmJiBkdXJhdGlvbiA8IDMwMCApIHtcblx0XHRcdG1vbWVudHVtWCA9IHRoaXMuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IHV0aWxzLm1vbWVudHVtKHRoaXMueCwgdGhpcy5zdGFydFgsIGR1cmF0aW9uLCB0aGlzLm1heFNjcm9sbFgsIHRoaXMub3B0aW9ucy5ib3VuY2UgPyB0aGlzLndyYXBwZXJXaWR0aCA6IDAsIHRoaXMub3B0aW9ucy5kZWNlbGVyYXRpb24pIDogeyBkZXN0aW5hdGlvbjogbmV3WCwgZHVyYXRpb246IDAgfTtcblx0XHRcdG1vbWVudHVtWSA9IHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB1dGlscy5tb21lbnR1bSh0aGlzLnksIHRoaXMuc3RhcnRZLCBkdXJhdGlvbiwgdGhpcy5tYXhTY3JvbGxZLCB0aGlzLm9wdGlvbnMuYm91bmNlID8gdGhpcy53cmFwcGVySGVpZ2h0IDogMCwgdGhpcy5vcHRpb25zLmRlY2VsZXJhdGlvbikgOiB7IGRlc3RpbmF0aW9uOiBuZXdZLCBkdXJhdGlvbjogMCB9O1xuXHRcdFx0bmV3WCA9IG1vbWVudHVtWC5kZXN0aW5hdGlvbjtcblx0XHRcdG5ld1kgPSBtb21lbnR1bVkuZGVzdGluYXRpb247XG5cdFx0XHR0aW1lID0gTWF0aC5tYXgobW9tZW50dW1YLmR1cmF0aW9uLCBtb21lbnR1bVkuZHVyYXRpb24pO1xuXHRcdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IDE7XG5cdFx0fVxuXG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0dmFyIHNuYXAgPSB0aGlzLl9uZWFyZXN0U25hcChuZXdYLCBuZXdZKTtcblx0XHRcdHRoaXMuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0dGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdYIC0gc25hcC54KSwgMTAwMCksXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhuZXdZIC0gc25hcC55KSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXHRcdFx0bmV3WCA9IHNuYXAueDtcblx0XHRcdG5ld1kgPSBzbmFwLnk7XG5cblx0XHRcdHRoaXMuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXHRcdFx0ZWFzaW5nID0gdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZztcblx0XHR9XG5cbi8vIElOU0VSVCBQT0lOVDogX2VuZFxuXG5cdFx0aWYgKCBuZXdYICE9IHRoaXMueCB8fCBuZXdZICE9IHRoaXMueSApIHtcblx0XHRcdC8vIGNoYW5nZSBlYXNpbmcgZnVuY3Rpb24gd2hlbiBzY3JvbGxlciBnb2VzIG91dCBvZiB0aGUgYm91bmRhcmllc1xuXHRcdFx0aWYgKCBuZXdYID4gMCB8fCBuZXdYIDwgdGhpcy5tYXhTY3JvbGxYIHx8IG5ld1kgPiAwIHx8IG5ld1kgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHRcdGVhc2luZyA9IHV0aWxzLmVhc2UucXVhZHJhdGljO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIHRpbWUsIGVhc2luZyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG5cblx0XHR0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQucmVmcmVzaCgpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy5yZXNpemVQb2xsaW5nKTtcblx0fSxcblxuXHRyZXNldFBvc2l0aW9uOiBmdW5jdGlvbiAodGltZSkge1xuXHRcdHZhciB4ID0gdGhpcy54LFxuXHRcdFx0eSA9IHRoaXMueTtcblxuXHRcdHRpbWUgPSB0aW1lIHx8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgfHwgdGhpcy54ID4gMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCB8fCB0aGlzLnkgPiAwICkge1xuXHRcdFx0eSA9IDA7XG5cdFx0fSBlbHNlIGlmICggdGhpcy55IDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHRpZiAoIHggPT0gdGhpcy54ICYmIHkgPT0gdGhpcy55ICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgdGhpcy5vcHRpb25zLmJvdW5jZUVhc2luZyk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJmID0gdGhpcy53cmFwcGVyLm9mZnNldEhlaWdodDtcdFx0Ly8gRm9yY2UgcmVmbG93XG5cblx0XHR0aGlzLndyYXBwZXJXaWR0aFx0PSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cdFx0dGhpcy53cmFwcGVySGVpZ2h0XHQ9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbi8qIFJFUExBQ0UgU1RBUlQ6IHJlZnJlc2ggKi9cblxuXHRcdHRoaXMuc2Nyb2xsZXJXaWR0aFx0PSB0aGlzLnNjcm9sbGVyLm9mZnNldFdpZHRoO1xuXHRcdHRoaXMuc2Nyb2xsZXJIZWlnaHRcdD0gdGhpcy5zY3JvbGxlci5vZmZzZXRIZWlnaHQ7XG5cblx0XHR0aGlzLm1heFNjcm9sbFhcdFx0PSB0aGlzLndyYXBwZXJXaWR0aCAtIHRoaXMuc2Nyb2xsZXJXaWR0aDtcblx0XHR0aGlzLm1heFNjcm9sbFlcdFx0PSB0aGlzLndyYXBwZXJIZWlnaHQgLSB0aGlzLnNjcm9sbGVySGVpZ2h0O1xuXG4vKiBSRVBMQUNFIEVORDogcmVmcmVzaCAqL1xuXG5cdFx0dGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsXHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxYICYmIHRoaXMubWF4U2Nyb2xsWCA8IDA7XG5cdFx0dGhpcy5oYXNWZXJ0aWNhbFNjcm9sbFx0XHQ9IHRoaXMub3B0aW9ucy5zY3JvbGxZICYmIHRoaXMubWF4U2Nyb2xsWSA8IDA7XG5cblx0XHRpZiAoICF0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgKSB7XG5cdFx0XHR0aGlzLm1heFNjcm9sbFggPSAwO1xuXHRcdFx0dGhpcy5zY3JvbGxlcldpZHRoID0gdGhpcy53cmFwcGVyV2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHRoaXMubWF4U2Nyb2xsWSA9IDA7XG5cdFx0XHR0aGlzLnNjcm9sbGVySGVpZ2h0ID0gdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdH1cblxuXHRcdHRoaXMuZW5kVGltZSA9IDA7XG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSAwO1xuXG5cdFx0dGhpcy53cmFwcGVyT2Zmc2V0ID0gdXRpbHMub2Zmc2V0KHRoaXMud3JhcHBlcik7XG5cblx0XHR0aGlzLl9leGVjRXZlbnQoJ3JlZnJlc2gnKTtcblxuXHRcdHRoaXMucmVzZXRQb3NpdGlvbigpO1xuXG4vLyBJTlNFUlQgUE9JTlQ6IF9yZWZyZXNoXG5cblx0fSxcblxuXHRvbjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2goZm4pO1xuXHR9LFxuXG5cdG9mZjogZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCAhdGhpcy5fZXZlbnRzW3R5cGVdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5pbmRleE9mKGZuKTtcblxuXHRcdGlmICggaW5kZXggPiAtMSApIHtcblx0XHRcdHRoaXMuX2V2ZW50c1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSxcblxuXHRfZXhlY0V2ZW50OiBmdW5jdGlvbiAodHlwZSkge1xuXHRcdGlmICggIXRoaXMuX2V2ZW50c1t0eXBlXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsID0gdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcblxuXHRcdGlmICggIWwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0dGhpcy5fZXZlbnRzW3R5cGVdW2ldLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbiAoeCwgeSwgdGltZSwgZWFzaW5nKSB7XG5cdFx0eCA9IHRoaXMueCArIHg7XG5cdFx0eSA9IHRoaXMueSArIHk7XG5cdFx0dGltZSA9IHRpbWUgfHwgMDtcblxuXHRcdHRoaXMuc2Nyb2xsVG8oeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRzY3JvbGxUbzogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB1dGlscy5lYXNlLmNpcmN1bGFyO1xuXG5cdFx0dGhpcy5pc0luVHJhbnNpdGlvbiA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIHRpbWUgPiAwO1xuXHRcdHZhciB0cmFuc2l0aW9uVHlwZSA9IHRoaXMub3B0aW9ucy51c2VUcmFuc2l0aW9uICYmIGVhc2luZy5zdHlsZTtcblx0XHRpZiAoICF0aW1lIHx8IHRyYW5zaXRpb25UeXBlICkge1xuXHRcdFx0XHRpZih0cmFuc2l0aW9uVHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbihlYXNpbmcuc3R5bGUpO1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zaXRpb25UaW1lKHRpbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2FuaW1hdGUoeCwgeSwgdGltZSwgZWFzaW5nLmZuKTtcblx0XHR9XG5cdH0sXG5cblx0c2Nyb2xsVG9FbGVtZW50OiBmdW5jdGlvbiAoZWwsIHRpbWUsIG9mZnNldFgsIG9mZnNldFksIGVhc2luZykge1xuXHRcdGVsID0gZWwubm9kZVR5cGUgPyBlbCA6IHRoaXMuc2Nyb2xsZXIucXVlcnlTZWxlY3RvcihlbCk7XG5cblx0XHRpZiAoICFlbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcG9zID0gdXRpbHMub2Zmc2V0KGVsKTtcblxuXHRcdHBvcy5sZWZ0IC09IHRoaXMud3JhcHBlck9mZnNldC5sZWZ0O1xuXHRcdHBvcy50b3AgIC09IHRoaXMud3JhcHBlck9mZnNldC50b3A7XG5cblx0XHQvLyBpZiBvZmZzZXRYL1kgYXJlIHRydWUgd2UgY2VudGVyIHRoZSBlbGVtZW50IHRvIHRoZSBzY3JlZW5cblx0XHRpZiAoIG9mZnNldFggPT09IHRydWUgKSB7XG5cdFx0XHRvZmZzZXRYID0gTWF0aC5yb3VuZChlbC5vZmZzZXRXaWR0aCAvIDIgLSB0aGlzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyKTtcblx0XHR9XG5cdFx0aWYgKCBvZmZzZXRZID09PSB0cnVlICkge1xuXHRcdFx0b2Zmc2V0WSA9IE1hdGgucm91bmQoZWwub2Zmc2V0SGVpZ2h0IC8gMiAtIHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRwb3MubGVmdCAtPSBvZmZzZXRYIHx8IDA7XG5cdFx0cG9zLnRvcCAgLT0gb2Zmc2V0WSB8fCAwO1xuXG5cdFx0cG9zLmxlZnQgPSBwb3MubGVmdCA+IDAgPyAwIDogcG9zLmxlZnQgPCB0aGlzLm1heFNjcm9sbFggPyB0aGlzLm1heFNjcm9sbFggOiBwb3MubGVmdDtcblx0XHRwb3MudG9wICA9IHBvcy50b3AgID4gMCA/IDAgOiBwb3MudG9wICA8IHRoaXMubWF4U2Nyb2xsWSA/IHRoaXMubWF4U2Nyb2xsWSA6IHBvcy50b3A7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkIHx8IHRpbWUgPT09IG51bGwgfHwgdGltZSA9PT0gJ2F1dG8nID8gTWF0aC5tYXgoTWF0aC5hYnModGhpcy54LXBvcy5sZWZ0KSwgTWF0aC5hYnModGhpcy55LXBvcy50b3ApKSA6IHRpbWU7XG5cblx0XHR0aGlzLnNjcm9sbFRvKHBvcy5sZWZ0LCBwb3MudG9wLCB0aW1lLCBlYXNpbmcpO1xuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXG5cdFx0dmFyIGR1cmF0aW9uUHJvcCA9IHV0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbjtcblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9IHRpbWUgKyAnbXMnO1xuXG5cdFx0aWYgKCAhdGltZSAmJiB1dGlscy5pc0JhZEFuZHJvaWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwLjAwMDFtcyc7XG5cdFx0XHQvLyByZW1vdmUgMC4wMDAxbXNcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHJBRihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5zY3JvbGxlclN0eWxlW2R1cmF0aW9uUHJvcF0gPT09ICcwLjAwMDFtcycpIHtcblx0XHRcdFx0XHRzZWxmLnNjcm9sbGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwcyc7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltZSh0aW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWVcblxuXHR9LFxuXG5cdF90cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGZ1bmN0aW9uIChlYXNpbmcpIHtcblx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZztcblxuXG5cdFx0aWYgKCB0aGlzLmluZGljYXRvcnMgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yc1tpXS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24oZWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblxuLy8gSU5TRVJUIFBPSU5UOiBfdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXG5cblx0fSxcblxuXHRfdHJhbnNsYXRlOiBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybSApIHtcblxuLyogUkVQTEFDRSBTVEFSVDogX3RyYW5zbGF0ZSAqL1xuXG5cdFx0XHR0aGlzLnNjcm9sbGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUoJyArIHggKyAncHgsJyArIHkgKyAncHgpJyArIHRoaXMudHJhbnNsYXRlWjtcblxuLyogUkVQTEFDRSBFTkQ6IF90cmFuc2xhdGUgKi9cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gTWF0aC5yb3VuZCh4KTtcblx0XHRcdHkgPSBNYXRoLnJvdW5kKHkpO1xuXHRcdFx0dGhpcy5zY3JvbGxlclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuc2Nyb2xsZXJTdHlsZS50b3AgPSB5ICsgJ3B4Jztcblx0XHR9XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblxuXHRpZiAoIHRoaXMuaW5kaWNhdG9ycyApIHtcblx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuaW5kaWNhdG9ycy5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvcnNbaV0udXBkYXRlUG9zaXRpb24oKTtcblx0XHR9XG5cdH1cblxuXG4vLyBJTlNFUlQgUE9JTlQ6IF90cmFuc2xhdGVcblxuXHR9LFxuXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0dmFyIGV2ZW50VHlwZSA9IHJlbW92ZSA/IHV0aWxzLnJlbW92ZUV2ZW50IDogdXRpbHMuYWRkRXZlbnQsXG5cdFx0XHR0YXJnZXQgPSB0aGlzLm9wdGlvbnMuYmluZFRvV3JhcHBlciA/IHRoaXMud3JhcHBlciA6IHdpbmRvdztcblxuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh3aW5kb3csICdyZXNpemUnLCB0aGlzKTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmNsaWNrICkge1xuXHRcdFx0ZXZlbnRUeXBlKHRoaXMud3JhcHBlciwgJ2NsaWNrJywgdGhpcywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVNb3VzZSApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICdtb3VzZWRvd24nLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZW1vdmUnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICdtb3VzZWNhbmNlbCcsIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgJ21vdXNldXAnLCB0aGlzKTtcblx0XHR9XG5cblx0XHRpZiAoIHV0aWxzLmhhc1BvaW50ZXIgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlUG9pbnRlciApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcmRvd24nKSwgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyY2FuY2VsJyksIHRoaXMpO1xuXHRcdFx0ZXZlbnRUeXBlKHRhcmdldCwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKCB1dGlscy5oYXNUb3VjaCAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVUb3VjaCApIHtcblx0XHRcdGV2ZW50VHlwZSh0aGlzLndyYXBwZXIsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0XHRldmVudFR5cGUodGFyZ2V0LCAndG91Y2hjYW5jZWwnLCB0aGlzKTtcblx0XHRcdGV2ZW50VHlwZSh0YXJnZXQsICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHRcdGV2ZW50VHlwZSh0aGlzLnNjcm9sbGVyLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzKTtcblx0XHRldmVudFR5cGUodGhpcy5zY3JvbGxlciwgJ01TVHJhbnNpdGlvbkVuZCcsIHRoaXMpO1xuXHR9LFxuXG5cdGdldENvbXB1dGVkUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWF0cml4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zY3JvbGxlciwgbnVsbCksXG5cdFx0XHR4LCB5O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4W3V0aWxzLnN0eWxlLnRyYW5zZm9ybV0uc3BsaXQoJyknKVswXS5zcGxpdCgnLCAnKTtcblx0XHRcdHggPSArKG1hdHJpeFsxMl0gfHwgbWF0cml4WzRdKTtcblx0XHRcdHkgPSArKG1hdHJpeFsxM10gfHwgbWF0cml4WzVdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9ICttYXRyaXgubGVmdC5yZXBsYWNlKC9bXi1cXGQuXS9nLCAnJyk7XG5cdFx0XHR5ID0gK21hdHJpeC50b3AucmVwbGFjZSgvW14tXFxkLl0vZywgJycpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7IHg6IHgsIHk6IHkgfTtcblx0fSxcblx0X2luaXRJbmRpY2F0b3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGludGVyYWN0aXZlID0gdGhpcy5vcHRpb25zLmludGVyYWN0aXZlU2Nyb2xsYmFycyxcblx0XHRcdGN1c3RvbVN0eWxlID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICE9ICdzdHJpbmcnLFxuXHRcdFx0aW5kaWNhdG9ycyA9IFtdLFxuXHRcdFx0aW5kaWNhdG9yO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5pbmRpY2F0b3JzID0gW107XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxiYXJzICkge1xuXHRcdFx0Ly8gVmVydGljYWwgc2Nyb2xsYmFyXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zY3JvbGxZICkge1xuXHRcdFx0XHRpbmRpY2F0b3IgPSB7XG5cdFx0XHRcdFx0ZWw6IGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIoJ3YnLCBpbnRlcmFjdGl2ZSwgdGhpcy5vcHRpb25zLnNjcm9sbGJhcnMpLFxuXHRcdFx0XHRcdGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZSxcblx0XHRcdFx0XHRkZWZhdWx0U2Nyb2xsYmFyczogdHJ1ZSxcblx0XHRcdFx0XHRjdXN0b21TdHlsZTogY3VzdG9tU3R5bGUsXG5cdFx0XHRcdFx0cmVzaXplOiB0aGlzLm9wdGlvbnMucmVzaXplU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRzaHJpbms6IHRoaXMub3B0aW9ucy5zaHJpbmtTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGZhZGU6IHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyxcblx0XHRcdFx0XHRsaXN0ZW5YOiBmYWxzZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IuZWwpO1xuXHRcdFx0XHRpbmRpY2F0b3JzLnB1c2goaW5kaWNhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9yaXpvbnRhbCBzY3JvbGxiYXJcblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNjcm9sbFggKSB7XG5cdFx0XHRcdGluZGljYXRvciA9IHtcblx0XHRcdFx0XHRlbDogY3JlYXRlRGVmYXVsdFNjcm9sbGJhcignaCcsIGludGVyYWN0aXZlLCB0aGlzLm9wdGlvbnMuc2Nyb2xsYmFycyksXG5cdFx0XHRcdFx0aW50ZXJhY3RpdmU6IGludGVyYWN0aXZlLFxuXHRcdFx0XHRcdGRlZmF1bHRTY3JvbGxiYXJzOiB0cnVlLFxuXHRcdFx0XHRcdGN1c3RvbVN0eWxlOiBjdXN0b21TdHlsZSxcblx0XHRcdFx0XHRyZXNpemU6IHRoaXMub3B0aW9ucy5yZXNpemVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdHNocmluazogdGhpcy5vcHRpb25zLnNocmlua1Njcm9sbGJhcnMsXG5cdFx0XHRcdFx0ZmFkZTogdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzLFxuXHRcdFx0XHRcdGxpc3Rlblk6IGZhbHNlXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKGluZGljYXRvci5lbCk7XG5cdFx0XHRcdGluZGljYXRvcnMucHVzaChpbmRpY2F0b3IpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmluZGljYXRvcnMgKSB7XG5cdFx0XHQvLyBUT0RPOiBjaGVjayBjb25jYXQgY29tcGF0aWJpbGl0eVxuXHRcdFx0aW5kaWNhdG9ycyA9IGluZGljYXRvcnMuY29uY2F0KHRoaXMub3B0aW9ucy5pbmRpY2F0b3JzKTtcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IGluZGljYXRvcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JzLnB1c2goIG5ldyBJbmRpY2F0b3IodGhpcywgaW5kaWNhdG9yc1tpXSkgKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBjaGVjayBpZiB3ZSBjYW4gdXNlIGFycmF5Lm1hcCAod2lkZSBjb21wYXRpYmlsaXR5IGFuZCBwZXJmb3JtYW5jZSBpc3N1ZXMpXG5cdFx0ZnVuY3Rpb24gX2luZGljYXRvcnNNYXAgKGZuKSB7XG5cdFx0XHRpZiAodGhhdC5pbmRpY2F0b3JzKSB7XG5cdFx0XHRcdGZvciAoIHZhciBpID0gdGhhdC5pbmRpY2F0b3JzLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoYXQuaW5kaWNhdG9yc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5mYWRlU2Nyb2xsYmFycyApIHtcblx0XHRcdHRoaXMub24oJ3Njcm9sbEVuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2luZGljYXRvcnNNYXAoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMuZmFkZSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLm9uKCdzY3JvbGxDYW5jZWwnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbignc2Nyb2xsU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLmZhZGUoMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMub24oJ2JlZm9yZVNjcm9sbFN0YXJ0JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5mYWRlKDEsIHRydWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdF9pbmRpY2F0b3JzTWFwKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfaW5kaWNhdG9yc01hcChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGRlbGV0ZSB0aGlzLmluZGljYXRvcnM7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2luaXRXaGVlbDogZnVuY3Rpb24gKCkge1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ3doZWVsJywgdGhpcyk7XG5cdFx0dXRpbHMuYWRkRXZlbnQodGhpcy53cmFwcGVyLCAnbW91c2V3aGVlbCcsIHRoaXMpO1xuXHRcdHV0aWxzLmFkZEV2ZW50KHRoaXMud3JhcHBlciwgJ0RPTU1vdXNlU2Nyb2xsJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2hlZWxUaW1lb3V0KTtcblx0XHRcdHRoaXMud2hlZWxUaW1lb3V0ID0gbnVsbDtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMud3JhcHBlciwgJ3doZWVsJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICdtb3VzZXdoZWVsJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLndyYXBwZXIsICdET01Nb3VzZVNjcm9sbCcsIHRoaXMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF93aGVlbDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoICF0aGlzLmVuYWJsZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dmFyIHdoZWVsRGVsdGFYLCB3aGVlbERlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGlmICggdGhpcy53aGVlbFRpbWVvdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsU3RhcnQnKTtcblx0XHR9XG5cblx0XHQvLyBFeGVjdXRlIHRoZSBzY3JvbGxFbmQgZXZlbnQgYWZ0ZXIgNDAwbXMgdGhlIHdoZWVsIHN0b3BwZWQgc2Nyb2xsaW5nXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMud2hlZWxUaW1lb3V0KTtcblx0XHR0aGlzLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYoIXRoYXQub3B0aW9ucy5zbmFwKSB7XG5cdFx0XHRcdHRoYXQuX2V4ZWNFdmVudCgnc2Nyb2xsRW5kJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGF0LndoZWVsVGltZW91dCA9IHVuZGVmaW5lZDtcblx0XHR9LCA0MDApO1xuXG5cdFx0aWYgKCAnZGVsdGFYJyBpbiBlICkge1xuXHRcdFx0aWYgKGUuZGVsdGFNb2RlID09PSAxKSB7XG5cdFx0XHRcdHdoZWVsRGVsdGFYID0gLWUuZGVsdGFYICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHRcdFx0d2hlZWxEZWx0YVkgPSAtZS5kZWx0YVkgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hlZWxEZWx0YVggPSAtZS5kZWx0YVg7XG5cdFx0XHRcdHdoZWVsRGVsdGFZID0gLWUuZGVsdGFZO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhWCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gZS53aGVlbERlbHRhWCAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0XHR3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YVkgLyAxMjAgKiB0aGlzLm9wdGlvbnMubW91c2VXaGVlbFNwZWVkO1xuXHRcdH0gZWxzZSBpZiAoICd3aGVlbERlbHRhJyBpbiBlICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWSA9IGUud2hlZWxEZWx0YSAvIDEyMCAqIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsU3BlZWQ7XG5cdFx0fSBlbHNlIGlmICggJ2RldGFpbCcgaW4gZSApIHtcblx0XHRcdHdoZWVsRGVsdGFYID0gd2hlZWxEZWx0YVkgPSAtZS5kZXRhaWwgLyAzICogdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxTcGVlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHdoZWVsRGVsdGFYICo9IHRoaXMub3B0aW9ucy5pbnZlcnRXaGVlbERpcmVjdGlvbjtcblx0XHR3aGVlbERlbHRhWSAqPSB0aGlzLm9wdGlvbnMuaW52ZXJ0V2hlZWxEaXJlY3Rpb247XG5cblx0XHRpZiAoICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0d2hlZWxEZWx0YVggPSB3aGVlbERlbHRhWTtcblx0XHRcdHdoZWVsRGVsdGFZID0gMDtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwICkge1xuXHRcdFx0bmV3WCA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVg7XG5cdFx0XHRuZXdZID0gdGhpcy5jdXJyZW50UGFnZS5wYWdlWTtcblxuXHRcdFx0aWYgKCB3aGVlbERlbHRhWCA+IDAgKSB7XG5cdFx0XHRcdG5ld1gtLTtcblx0XHRcdH0gZWxzZSBpZiAoIHdoZWVsRGVsdGFYIDwgMCApIHtcblx0XHRcdFx0bmV3WCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdoZWVsRGVsdGFZID4gMCApIHtcblx0XHRcdFx0bmV3WS0tO1xuXHRcdFx0fSBlbHNlIGlmICggd2hlZWxEZWx0YVkgPCAwICkge1xuXHRcdFx0XHRuZXdZKys7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRuZXdYID0gdGhpcy54ICsgTWF0aC5yb3VuZCh0aGlzLmhhc0hvcml6b250YWxTY3JvbGwgPyB3aGVlbERlbHRhWCA6IDApO1xuXHRcdG5ld1kgPSB0aGlzLnkgKyBNYXRoLnJvdW5kKHRoaXMuaGFzVmVydGljYWxTY3JvbGwgPyB3aGVlbERlbHRhWSA6IDApO1xuXG5cdFx0dGhpcy5kaXJlY3Rpb25YID0gd2hlZWxEZWx0YVggPiAwID8gLTEgOiB3aGVlbERlbHRhWCA8IDAgPyAxIDogMDtcblx0XHR0aGlzLmRpcmVjdGlvblkgPSB3aGVlbERlbHRhWSA+IDAgPyAtMSA6IHdoZWVsRGVsdGFZIDwgMCA/IDEgOiAwO1xuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG4vLyBJTlNFUlQgUE9JTlQ6IF93aGVlbFxuXHR9LFxuXG5cdF9pbml0U25hcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY3VycmVudFBhZ2UgPSB7fTtcblxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5zbmFwID09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnNuYXAgPSB0aGlzLnNjcm9sbGVyLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnNuYXApO1xuXHRcdH1cblxuXHRcdHRoaXMub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSA9IDAsIGwsXG5cdFx0XHRcdG0gPSAwLCBuLFxuXHRcdFx0XHRjeCwgY3ksXG5cdFx0XHRcdHggPSAwLCB5LFxuXHRcdFx0XHRzdGVwWCA9IHRoaXMub3B0aW9ucy5zbmFwU3RlcFggfHwgdGhpcy53cmFwcGVyV2lkdGgsXG5cdFx0XHRcdHN0ZXBZID0gdGhpcy5vcHRpb25zLnNuYXBTdGVwWSB8fCB0aGlzLndyYXBwZXJIZWlnaHQsXG5cdFx0XHRcdGVsO1xuXG5cdFx0XHR0aGlzLnBhZ2VzID0gW107XG5cblx0XHRcdGlmICggIXRoaXMud3JhcHBlcldpZHRoIHx8ICF0aGlzLndyYXBwZXJIZWlnaHQgfHwgIXRoaXMuc2Nyb2xsZXJXaWR0aCB8fCAhdGhpcy5zY3JvbGxlckhlaWdodCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwID09PSB0cnVlICkge1xuXHRcdFx0XHRjeCA9IE1hdGgucm91bmQoIHN0ZXBYIC8gMiApO1xuXHRcdFx0XHRjeSA9IE1hdGgucm91bmQoIHN0ZXBZIC8gMiApO1xuXG5cdFx0XHRcdHdoaWxlICggeCA+IC10aGlzLnNjcm9sbGVyV2lkdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5wYWdlc1tpXSA9IFtdO1xuXHRcdFx0XHRcdGwgPSAwO1xuXHRcdFx0XHRcdHkgPSAwO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCB5ID4gLXRoaXMuc2Nyb2xsZXJIZWlnaHQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBhZ2VzW2ldW2xdID0ge1xuXHRcdFx0XHRcdFx0XHR4OiBNYXRoLm1heCh4LCB0aGlzLm1heFNjcm9sbFgpLFxuXHRcdFx0XHRcdFx0XHR5OiBNYXRoLm1heCh5LCB0aGlzLm1heFNjcm9sbFkpLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogc3RlcFgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogc3RlcFksXG5cdFx0XHRcdFx0XHRcdGN4OiB4IC0gY3gsXG5cdFx0XHRcdFx0XHRcdGN5OiB5IC0gY3lcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHkgLT0gc3RlcFk7XG5cdFx0XHRcdFx0XHRsKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eCAtPSBzdGVwWDtcblx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsID0gdGhpcy5vcHRpb25zLnNuYXA7XG5cdFx0XHRcdGwgPSBlbC5sZW5ndGg7XG5cdFx0XHRcdG4gPSAtMTtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBpID09PSAwIHx8IGVsW2ldLm9mZnNldExlZnQgPD0gZWxbaS0xXS5vZmZzZXRMZWZ0ICkge1xuXHRcdFx0XHRcdFx0bSA9IDA7XG5cdFx0XHRcdFx0XHRuKys7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5wYWdlc1ttXSApIHtcblx0XHRcdFx0XHRcdHRoaXMucGFnZXNbbV0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR4ID0gTWF0aC5tYXgoLWVsW2ldLm9mZnNldExlZnQsIHRoaXMubWF4U2Nyb2xsWCk7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWF4KC1lbFtpXS5vZmZzZXRUb3AsIHRoaXMubWF4U2Nyb2xsWSk7XG5cdFx0XHRcdFx0Y3ggPSB4IC0gTWF0aC5yb3VuZChlbFtpXS5vZmZzZXRXaWR0aCAvIDIpO1xuXHRcdFx0XHRcdGN5ID0geSAtIE1hdGgucm91bmQoZWxbaV0ub2Zmc2V0SGVpZ2h0IC8gMik7XG5cblx0XHRcdFx0XHR0aGlzLnBhZ2VzW21dW25dID0ge1xuXHRcdFx0XHRcdFx0eDogeCxcblx0XHRcdFx0XHRcdHk6IHksXG5cdFx0XHRcdFx0XHR3aWR0aDogZWxbaV0ub2Zmc2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGVsW2ldLm9mZnNldEhlaWdodCxcblx0XHRcdFx0XHRcdGN4OiBjeCxcblx0XHRcdFx0XHRcdGN5OiBjeVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIHggPiB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRcdFx0XHRtKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZ29Ub1BhZ2UodGhpcy5jdXJyZW50UGFnZS5wYWdlWCB8fCAwLCB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZIHx8IDAsIDApO1xuXG5cdFx0XHQvLyBVcGRhdGUgc25hcCB0aHJlc2hvbGQgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkICUgMSA9PT0gMCApIHtcblx0XHRcdFx0dGhpcy5zbmFwVGhyZXNob2xkWCA9IHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRYID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLndpZHRoICogdGhpcy5vcHRpb25zLnNuYXBUaHJlc2hvbGQpO1xuXHRcdFx0XHR0aGlzLnNuYXBUaHJlc2hvbGRZID0gTWF0aC5yb3VuZCh0aGlzLnBhZ2VzW3RoaXMuY3VycmVudFBhZ2UucGFnZVhdW3RoaXMuY3VycmVudFBhZ2UucGFnZVldLmhlaWdodCAqIHRoaXMub3B0aW9ucy5zbmFwVGhyZXNob2xkKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMub24oJ2ZsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRpbWUgPSB0aGlzLm9wdGlvbnMuc25hcFNwZWVkIHx8IE1hdGgubWF4KFxuXHRcdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0TWF0aC5taW4oTWF0aC5hYnModGhpcy54IC0gdGhpcy5zdGFydFgpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMueSAtIHRoaXMuc3RhcnRZKSwgMTAwMClcblx0XHRcdFx0XHQpLCAzMDApO1xuXG5cdFx0XHR0aGlzLmdvVG9QYWdlKFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYICsgdGhpcy5kaXJlY3Rpb25YLFxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICsgdGhpcy5kaXJlY3Rpb25ZLFxuXHRcdFx0XHR0aW1lXG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9uZWFyZXN0U25hcDogZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRpZiAoICF0aGlzLnBhZ2VzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHg6IDAsIHk6IDAsIHBhZ2VYOiAwLCBwYWdlWTogMCB9O1xuXHRcdH1cblxuXHRcdHZhciBpID0gMCxcblx0XHRcdGwgPSB0aGlzLnBhZ2VzLmxlbmd0aCxcblx0XHRcdG0gPSAwO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZXhjZWVkZWQgdGhlIHNuYXAgdGhyZXNob2xkXG5cdFx0aWYgKCBNYXRoLmFicyh4IC0gdGhpcy5hYnNTdGFydFgpIDwgdGhpcy5zbmFwVGhyZXNob2xkWCAmJlxuXHRcdFx0TWF0aC5hYnMoeSAtIHRoaXMuYWJzU3RhcnRZKSA8IHRoaXMuc25hcFRocmVzaG9sZFkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50UGFnZTtcblx0XHR9XG5cblx0XHRpZiAoIHggPiAwICkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fSBlbHNlIGlmICggeCA8IHRoaXMubWF4U2Nyb2xsWCApIHtcblx0XHRcdHggPSB0aGlzLm1heFNjcm9sbFg7XG5cdFx0fVxuXG5cdFx0aWYgKCB5ID4gMCApIHtcblx0XHRcdHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHkgPCB0aGlzLm1heFNjcm9sbFkgKSB7XG5cdFx0XHR5ID0gdGhpcy5tYXhTY3JvbGxZO1xuXHRcdH1cblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggeCA+PSB0aGlzLnBhZ2VzW2ldWzBdLmN4ICkge1xuXHRcdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsID0gdGhpcy5wYWdlc1tpXS5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IG0gPCBsOyBtKysgKSB7XG5cdFx0XHRpZiAoIHkgPj0gdGhpcy5wYWdlc1swXVttXS5jeSApIHtcblx0XHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpID09IHRoaXMuY3VycmVudFBhZ2UucGFnZVggKSB7XG5cdFx0XHRpICs9IHRoaXMuZGlyZWN0aW9uWDtcblxuXHRcdFx0aWYgKCBpIDwgMCApIHtcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKCBpID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0XHRpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXG5cdFx0XHR4ID0gdGhpcy5wYWdlc1tpXVswXS54O1xuXHRcdH1cblxuXHRcdGlmICggbSA9PSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VZICkge1xuXHRcdFx0bSArPSB0aGlzLmRpcmVjdGlvblk7XG5cblx0XHRcdGlmICggbSA8IDAgKSB7XG5cdFx0XHRcdG0gPSAwO1xuXHRcdFx0fSBlbHNlIGlmICggbSA+PSB0aGlzLnBhZ2VzWzBdLmxlbmd0aCApIHtcblx0XHRcdFx0bSA9IHRoaXMucGFnZXNbMF0ubGVuZ3RoIC0gMTtcblx0XHRcdH1cblxuXHRcdFx0eSA9IHRoaXMucGFnZXNbMF1bbV0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHksXG5cdFx0XHRwYWdlWDogaSxcblx0XHRcdHBhZ2VZOiBtXG5cdFx0fTtcblx0fSxcblxuXHRnb1RvUGFnZTogZnVuY3Rpb24gKHgsIHksIHRpbWUsIGVhc2luZykge1xuXHRcdGVhc2luZyA9IGVhc2luZyB8fCB0aGlzLm9wdGlvbnMuYm91bmNlRWFzaW5nO1xuXG5cdFx0aWYgKCB4ID49IHRoaXMucGFnZXMubGVuZ3RoICkge1xuXHRcdFx0eCA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2UgaWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblxuXHRcdGlmICggeSA+PSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCApIHtcblx0XHRcdHkgPSB0aGlzLnBhZ2VzW3hdLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9XG5cblx0XHR2YXIgcG9zWCA9IHRoaXMucGFnZXNbeF1beV0ueCxcblx0XHRcdHBvc1kgPSB0aGlzLnBhZ2VzW3hdW3ldLnk7XG5cblx0XHR0aW1lID0gdGltZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLnNuYXBTcGVlZCB8fCBNYXRoLm1heChcblx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyhwb3NYIC0gdGhpcy54KSwgMTAwMCksXG5cdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHBvc1kgLSB0aGlzLnkpLCAxMDAwKVxuXHRcdFx0KSwgMzAwKSA6IHRpbWU7XG5cblx0XHR0aGlzLmN1cnJlbnRQYWdlID0ge1xuXHRcdFx0eDogcG9zWCxcblx0XHRcdHk6IHBvc1ksXG5cdFx0XHRwYWdlWDogeCxcblx0XHRcdHBhZ2VZOiB5XG5cdFx0fTtcblxuXHRcdHRoaXMuc2Nyb2xsVG8ocG9zWCwgcG9zWSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRuZXh0OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4Kys7XG5cblx0XHRpZiAoIHggPj0gdGhpcy5wYWdlcy5sZW5ndGggJiYgdGhpcy5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHggPSAwO1xuXHRcdFx0eSsrO1xuXHRcdH1cblxuXHRcdHRoaXMuZ29Ub1BhZ2UoeCwgeSwgdGltZSwgZWFzaW5nKTtcblx0fSxcblxuXHRwcmV2OiBmdW5jdGlvbiAodGltZSwgZWFzaW5nKSB7XG5cdFx0dmFyIHggPSB0aGlzLmN1cnJlbnRQYWdlLnBhZ2VYLFxuXHRcdFx0eSA9IHRoaXMuY3VycmVudFBhZ2UucGFnZVk7XG5cblx0XHR4LS07XG5cblx0XHRpZiAoIHggPCAwICYmIHRoaXMuaGFzVmVydGljYWxTY3JvbGwgKSB7XG5cdFx0XHR4ID0gMDtcblx0XHRcdHktLTtcblx0XHR9XG5cblx0XHR0aGlzLmdvVG9QYWdlKHgsIHksIHRpbWUsIGVhc2luZyk7XG5cdH0sXG5cblx0X2luaXRLZXlzOiBmdW5jdGlvbiAoZSkge1xuXHRcdC8vIGRlZmF1bHQga2V5IGJpbmRpbmdzXG5cdFx0dmFyIGtleXMgPSB7XG5cdFx0XHRwYWdlVXA6IDMzLFxuXHRcdFx0cGFnZURvd246IDM0LFxuXHRcdFx0ZW5kOiAzNSxcblx0XHRcdGhvbWU6IDM2LFxuXHRcdFx0bGVmdDogMzcsXG5cdFx0XHR1cDogMzgsXG5cdFx0XHRyaWdodDogMzksXG5cdFx0XHRkb3duOiA0MFxuXHRcdH07XG5cdFx0dmFyIGk7XG5cblx0XHQvLyBpZiB5b3UgZ2l2ZSBtZSBjaGFyYWN0ZXJzIEkgZ2l2ZSB5b3Uga2V5Y29kZVxuXHRcdGlmICggdHlwZW9mIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncyA9PSAnb2JqZWN0JyApIHtcblx0XHRcdGZvciAoIGkgaW4gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldID0gdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzW2ldLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MgPSB7fTtcblx0XHR9XG5cblx0XHRmb3IgKCBpIGluIGtleXMgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gPSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3NbaV0gfHwga2V5c1tpXTtcblx0XHR9XG5cblx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICdrZXlkb3duJywgdGhpcyk7XG5cblx0XHR0aGlzLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAna2V5ZG93bicsIHRoaXMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9rZXk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5lbmFibGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzbmFwID0gdGhpcy5vcHRpb25zLnNuYXAsXHQvLyB3ZSBhcmUgdXNpbmcgdGhpcyBhbG90LCBiZXR0ZXIgdG8gY2FjaGUgaXRcblx0XHRcdG5ld1ggPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWCA6IHRoaXMueCxcblx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5jdXJyZW50UGFnZS5wYWdlWSA6IHRoaXMueSxcblx0XHRcdG5vdyA9IHV0aWxzLmdldFRpbWUoKSxcblx0XHRcdHByZXZUaW1lID0gdGhpcy5rZXlUaW1lIHx8IDAsXG5cdFx0XHRhY2NlbGVyYXRpb24gPSAwLjI1MCxcblx0XHRcdHBvcztcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnVzZVRyYW5zaXRpb24gJiYgdGhpcy5pc0luVHJhbnNpdGlvbiApIHtcblx0XHRcdHBvcyA9IHRoaXMuZ2V0Q29tcHV0ZWRQb3NpdGlvbigpO1xuXG5cdFx0XHR0aGlzLl90cmFuc2xhdGUoTWF0aC5yb3VuZChwb3MueCksIE1hdGgucm91bmQocG9zLnkpKTtcblx0XHRcdHRoaXMuaXNJblRyYW5zaXRpb24gPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmtleUFjY2VsZXJhdGlvbiA9IG5vdyAtIHByZXZUaW1lIDwgMjAwID8gTWF0aC5taW4odGhpcy5rZXlBY2NlbGVyYXRpb24gKyBhY2NlbGVyYXRpb24sIDUwKSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBlLmtleUNvZGUgKSB7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5wYWdlVXA6XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggKz0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZICs9IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucGFnZURvd246XG5cdFx0XHRcdGlmICggdGhpcy5oYXNIb3Jpem9udGFsU2Nyb2xsICYmICF0aGlzLmhhc1ZlcnRpY2FsU2Nyb2xsICkge1xuXHRcdFx0XHRcdG5ld1ggLT0gc25hcCA/IDEgOiB0aGlzLndyYXBwZXJXaWR0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXdZIC09IHNuYXAgPyAxIDogdGhpcy53cmFwcGVySGVpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MuZW5kOlxuXHRcdFx0XHRuZXdYID0gc25hcCA/IHRoaXMucGFnZXMubGVuZ3RoLTEgOiB0aGlzLm1heFNjcm9sbFg7XG5cdFx0XHRcdG5ld1kgPSBzbmFwID8gdGhpcy5wYWdlc1swXS5sZW5ndGgtMSA6IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIHRoaXMub3B0aW9ucy5rZXlCaW5kaW5ncy5ob21lOlxuXHRcdFx0XHRuZXdYID0gMDtcblx0XHRcdFx0bmV3WSA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MubGVmdDpcblx0XHRcdFx0bmV3WCArPSBzbmFwID8gLTEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MudXA6XG5cdFx0XHRcdG5ld1kgKz0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSB0aGlzLm9wdGlvbnMua2V5QmluZGluZ3MucmlnaHQ6XG5cdFx0XHRcdG5ld1ggLT0gc25hcCA/IC0xIDogNSArIHRoaXMua2V5QWNjZWxlcmF0aW9uPj4wO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgdGhpcy5vcHRpb25zLmtleUJpbmRpbmdzLmRvd246XG5cdFx0XHRcdG5ld1kgLT0gc25hcCA/IDEgOiA1ICsgdGhpcy5rZXlBY2NlbGVyYXRpb24+PjA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggc25hcCApIHtcblx0XHRcdHRoaXMuZ29Ub1BhZ2UobmV3WCwgbmV3WSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuZXdYID4gMCApIHtcblx0XHRcdG5ld1ggPSAwO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH0gZWxzZSBpZiAoIG5ld1ggPCB0aGlzLm1heFNjcm9sbFggKSB7XG5cdFx0XHRuZXdYID0gdGhpcy5tYXhTY3JvbGxYO1xuXHRcdFx0dGhpcy5rZXlBY2NlbGVyYXRpb24gPSAwO1xuXHRcdH1cblxuXHRcdGlmICggbmV3WSA+IDAgKSB7XG5cdFx0XHRuZXdZID0gMDtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9IGVsc2UgaWYgKCBuZXdZIDwgdGhpcy5tYXhTY3JvbGxZICkge1xuXHRcdFx0bmV3WSA9IHRoaXMubWF4U2Nyb2xsWTtcblx0XHRcdHRoaXMua2V5QWNjZWxlcmF0aW9uID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbFRvKG5ld1gsIG5ld1ksIDApO1xuXG5cdFx0dGhpcy5rZXlUaW1lID0gbm93O1xuXHR9LFxuXG5cdF9hbmltYXRlOiBmdW5jdGlvbiAoZGVzdFgsIGRlc3RZLCBkdXJhdGlvbiwgZWFzaW5nRm4pIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdGFydFggPSB0aGlzLngsXG5cdFx0XHRzdGFydFkgPSB0aGlzLnksXG5cdFx0XHRzdGFydFRpbWUgPSB1dGlscy5nZXRUaW1lKCksXG5cdFx0XHRkZXN0VGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuXG5cdFx0ZnVuY3Rpb24gc3RlcCAoKSB7XG5cdFx0XHR2YXIgbm93ID0gdXRpbHMuZ2V0VGltZSgpLFxuXHRcdFx0XHRuZXdYLCBuZXdZLFxuXHRcdFx0XHRlYXNpbmc7XG5cblx0XHRcdGlmICggbm93ID49IGRlc3RUaW1lICkge1xuXHRcdFx0XHR0aGF0LmlzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQuX3RyYW5zbGF0ZShkZXN0WCwgZGVzdFkpO1xuXG5cdFx0XHRcdGlmICggIXRoYXQucmVzZXRQb3NpdGlvbih0aGF0Lm9wdGlvbnMuYm91bmNlVGltZSkgKSB7XG5cdFx0XHRcdFx0dGhhdC5fZXhlY0V2ZW50KCdzY3JvbGxFbmQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bm93ID0gKCBub3cgLSBzdGFydFRpbWUgKSAvIGR1cmF0aW9uO1xuXHRcdFx0ZWFzaW5nID0gZWFzaW5nRm4obm93KTtcblx0XHRcdG5ld1ggPSAoIGRlc3RYIC0gc3RhcnRYICkgKiBlYXNpbmcgKyBzdGFydFg7XG5cdFx0XHRuZXdZID0gKCBkZXN0WSAtIHN0YXJ0WSApICogZWFzaW5nICsgc3RhcnRZO1xuXHRcdFx0dGhhdC5fdHJhbnNsYXRlKG5ld1gsIG5ld1kpO1xuXG5cdFx0XHRpZiAoIHRoYXQuaXNBbmltYXRpbmcgKSB7XG5cdFx0XHRcdHJBRihzdGVwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmlzQW5pbWF0aW5nID0gdHJ1ZTtcblx0XHRzdGVwKCk7XG5cdH0sXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHN3aXRjaCAoIGUudHlwZSApIHtcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmRvd24nOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyRG93bic6XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHR0aGlzLl9zdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcm1vdmUnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyTW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJ1cCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJVcCc6XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGNhc2UgJ3RvdWNoY2FuY2VsJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyQ2FuY2VsJzpcblx0XHRcdGNhc2UgJ21vdXNlY2FuY2VsJzpcblx0XHRcdFx0dGhpcy5fZW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ29yaWVudGF0aW9uY2hhbmdlJzpcblx0XHRcdGNhc2UgJ3Jlc2l6ZSc6XG5cdFx0XHRcdHRoaXMuX3Jlc2l6ZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RyYW5zaXRpb25lbmQnOlxuXHRcdFx0Y2FzZSAnd2Via2l0VHJhbnNpdGlvbkVuZCc6XG5cdFx0XHRjYXNlICdvVHJhbnNpdGlvbkVuZCc6XG5cdFx0XHRjYXNlICdNU1RyYW5zaXRpb25FbmQnOlxuXHRcdFx0XHR0aGlzLl90cmFuc2l0aW9uRW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3doZWVsJzpcblx0XHRcdGNhc2UgJ0RPTU1vdXNlU2Nyb2xsJzpcblx0XHRcdGNhc2UgJ21vdXNld2hlZWwnOlxuXHRcdFx0XHR0aGlzLl93aGVlbChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdrZXlkb3duJzpcblx0XHRcdFx0dGhpcy5fa2V5KGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2NsaWNrJzpcblx0XHRcdFx0aWYgKCB0aGlzLmVuYWJsZWQgJiYgIWUuX2NvbnN0cnVjdGVkICkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxufTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTY3JvbGxiYXIgKGRpcmVjdGlvbiwgaW50ZXJhY3RpdmUsIHR5cGUpIHtcblx0dmFyIHNjcm9sbGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuXHRcdGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5cdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTknO1xuXHRcdGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gJy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMC41KTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC45KTtib3JkZXItcmFkaXVzOjNweCc7XG5cdH1cblxuXHRpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2lTY3JvbGxJbmRpY2F0b3InO1xuXG5cdGlmICggZGlyZWN0aW9uID09ICdoJyApIHtcblx0XHRpZiAoIHR5cGUgPT09IHRydWUgKSB7XG5cdFx0XHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO2hlaWdodDo3cHg7bGVmdDoycHg7cmlnaHQ6MnB4O2JvdHRvbTowJztcblx0XHRcdGluZGljYXRvci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdFx0fVxuXHRcdHNjcm9sbGJhci5jbGFzc05hbWUgPSAnaVNjcm9sbEhvcml6b250YWxTY3JvbGxiYXInO1xuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZSA9PT0gdHJ1ZSApIHtcblx0XHRcdHNjcm9sbGJhci5zdHlsZS5jc3NUZXh0ICs9ICc7d2lkdGg6N3B4O2JvdHRvbToycHg7dG9wOjJweDtyaWdodDoxcHgnO1xuXHRcdFx0aW5kaWNhdG9yLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHRcdH1cblx0XHRzY3JvbGxiYXIuY2xhc3NOYW1lID0gJ2lTY3JvbGxWZXJ0aWNhbFNjcm9sbGJhcic7XG5cdH1cblxuXHRzY3JvbGxiYXIuc3R5bGUuY3NzVGV4dCArPSAnO292ZXJmbG93OmhpZGRlbic7XG5cblx0aWYgKCAhaW50ZXJhY3RpdmUgKSB7XG5cdFx0c2Nyb2xsYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cdH1cblxuXHRzY3JvbGxiYXIuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcblxuXHRyZXR1cm4gc2Nyb2xsYmFyO1xufVxuXG5mdW5jdGlvbiBJbmRpY2F0b3IgKHNjcm9sbGVyLCBvcHRpb25zKSB7XG5cdHRoaXMud3JhcHBlciA9IHR5cGVvZiBvcHRpb25zLmVsID09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmVsKSA6IG9wdGlvbnMuZWw7XG5cdHRoaXMud3JhcHBlclN0eWxlID0gdGhpcy53cmFwcGVyLnN0eWxlO1xuXHR0aGlzLmluZGljYXRvciA9IHRoaXMud3JhcHBlci5jaGlsZHJlblswXTtcblx0dGhpcy5pbmRpY2F0b3JTdHlsZSA9IHRoaXMuaW5kaWNhdG9yLnN0eWxlO1xuXHR0aGlzLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG5cblx0dGhpcy5vcHRpb25zID0ge1xuXHRcdGxpc3Rlblg6IHRydWUsXG5cdFx0bGlzdGVuWTogdHJ1ZSxcblx0XHRpbnRlcmFjdGl2ZTogZmFsc2UsXG5cdFx0cmVzaXplOiB0cnVlLFxuXHRcdGRlZmF1bHRTY3JvbGxiYXJzOiBmYWxzZSxcblx0XHRzaHJpbms6IGZhbHNlLFxuXHRcdGZhZGU6IGZhbHNlLFxuXHRcdHNwZWVkUmF0aW9YOiAwLFxuXHRcdHNwZWVkUmF0aW9ZOiAwXG5cdH07XG5cblx0Zm9yICggdmFyIGkgaW4gb3B0aW9ucyApIHtcblx0XHR0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xuXHR9XG5cblx0dGhpcy5zaXplUmF0aW9YID0gMTtcblx0dGhpcy5zaXplUmF0aW9ZID0gMTtcblx0dGhpcy5tYXhQb3NYID0gMDtcblx0dGhpcy5tYXhQb3NZID0gMDtcblxuXHRpZiAoIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSApIHtcblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVRvdWNoICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaGVuZCcsIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZVBvaW50ZXIgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLmFkZEV2ZW50KHdpbmRvdywgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVydXAnKSwgdGhpcyk7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlTW91c2UgKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh0aGlzLmluZGljYXRvciwgJ21vdXNlZG93bicsIHRoaXMpO1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblx0fVxuXG5cdGlmICggdGhpcy5vcHRpb25zLmZhZGUgKSB7XG5cdFx0dGhpcy53cmFwcGVyU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNmb3JtXSA9IHRoaXMuc2Nyb2xsZXIudHJhbnNsYXRlWjtcblx0XHR2YXIgZHVyYXRpb25Qcm9wID0gdXRpbHMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uO1xuXHRcdHRoaXMud3JhcHBlclN0eWxlW2R1cmF0aW9uUHJvcF0gPSB1dGlscy5pc0JhZEFuZHJvaWQgPyAnMC4wMDAxbXMnIDogJzBtcyc7XG5cdFx0Ly8gcmVtb3ZlIDAuMDAwMW1zXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKHV0aWxzLmlzQmFkQW5kcm9pZCkge1xuXHRcdFx0ckFGKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihzZWxmLndyYXBwZXJTdHlsZVtkdXJhdGlvblByb3BdID09PSAnMC4wMDAxbXMnKSB7XG5cdFx0XHRcdFx0c2VsZi53cmFwcGVyU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwcyc7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gJzAnO1xuXHR9XG59XG5cbkluZGljYXRvci5wcm90b3R5cGUgPSB7XG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbiAoZSkge1xuXHRcdHN3aXRjaCAoIGUudHlwZSApIHtcblx0XHRcdGNhc2UgJ3RvdWNoc3RhcnQnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcmRvd24nOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyRG93bic6XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHR0aGlzLl9zdGFydChlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0b3VjaG1vdmUnOlxuXHRcdFx0Y2FzZSAncG9pbnRlcm1vdmUnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyTW92ZSc6XG5cdFx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0XHR0aGlzLl9tb3ZlKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RvdWNoZW5kJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJ1cCc6XG5cdFx0XHRjYXNlICdNU1BvaW50ZXJVcCc6XG5cdFx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGNhc2UgJ3RvdWNoY2FuY2VsJzpcblx0XHRcdGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuXHRcdFx0Y2FzZSAnTVNQb2ludGVyQ2FuY2VsJzpcblx0XHRcdGNhc2UgJ21vdXNlY2FuY2VsJzpcblx0XHRcdFx0dGhpcy5fZW5kKGUpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICggdGhpcy5vcHRpb25zLmZhZGVTY3JvbGxiYXJzICkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZmFkZVRpbWVvdXQpO1xuXHRcdFx0dGhpcy5mYWRlVGltZW91dCA9IG51bGw7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5vcHRpb25zLmludGVyYWN0aXZlICkge1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQodGhpcy5pbmRpY2F0b3IsICd0b3VjaHN0YXJ0JywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh0aGlzLmluZGljYXRvciwgdXRpbHMucHJlZml4UG9pbnRlckV2ZW50KCdwb2ludGVyZG93bicpLCB0aGlzKTtcblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHRoaXMuaW5kaWNhdG9yLCAnbW91c2Vkb3duJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNobW92ZScsIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cblx0XHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ3RvdWNoZW5kJywgdGhpcyk7XG5cdFx0XHR1dGlscy5yZW1vdmVFdmVudCh3aW5kb3csIHV0aWxzLnByZWZpeFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJyksIHRoaXMpO1xuXHRcdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAnbW91c2V1cCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICkge1xuXHRcdFx0dGhpcy53cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcblx0XHR9XG5cdH0sXG5cblx0X3N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHRoaXMudHJhbnNpdGlvblRpbWUoKTtcblxuXHRcdHRoaXMuaW5pdGlhdGVkID0gdHJ1ZTtcblx0XHR0aGlzLm1vdmVkID0gZmFsc2U7XG5cdFx0dGhpcy5sYXN0UG9pbnRYXHQ9IHBvaW50LnBhZ2VYO1xuXHRcdHRoaXMubGFzdFBvaW50WVx0PSBwb2ludC5wYWdlWTtcblxuXHRcdHRoaXMuc3RhcnRUaW1lXHQ9IHV0aWxzLmdldFRpbWUoKTtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5kaXNhYmxlVG91Y2ggKSB7XG5cdFx0XHR1dGlscy5hZGRFdmVudCh3aW5kb3csICd0b3VjaG1vdmUnLCB0aGlzKTtcblx0XHR9XG5cdFx0aWYgKCAhdGhpcy5vcHRpb25zLmRpc2FibGVQb2ludGVyICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLm9wdGlvbnMuZGlzYWJsZU1vdXNlICkge1xuXHRcdFx0dXRpbHMuYWRkRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdiZWZvcmVTY3JvbGxTdGFydCcpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBwb2ludCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsXG5cdFx0XHRkZWx0YVgsIGRlbHRhWSxcblx0XHRcdG5ld1gsIG5ld1ksXG5cdFx0XHR0aW1lc3RhbXAgPSB1dGlscy5nZXRUaW1lKCk7XG5cblx0XHRpZiAoICF0aGlzLm1vdmVkICkge1xuXHRcdFx0dGhpcy5zY3JvbGxlci5fZXhlY0V2ZW50KCdzY3JvbGxTdGFydCcpO1xuXHRcdH1cblxuXHRcdHRoaXMubW92ZWQgPSB0cnVlO1xuXG5cdFx0ZGVsdGFYID0gcG9pbnQucGFnZVggLSB0aGlzLmxhc3RQb2ludFg7XG5cdFx0dGhpcy5sYXN0UG9pbnRYID0gcG9pbnQucGFnZVg7XG5cblx0XHRkZWx0YVkgPSBwb2ludC5wYWdlWSAtIHRoaXMubGFzdFBvaW50WTtcblx0XHR0aGlzLmxhc3RQb2ludFkgPSBwb2ludC5wYWdlWTtcblxuXHRcdG5ld1ggPSB0aGlzLnggKyBkZWx0YVg7XG5cdFx0bmV3WSA9IHRoaXMueSArIGRlbHRhWTtcblxuXHRcdHRoaXMuX3BvcyhuZXdYLCBuZXdZKTtcblxuLy8gSU5TRVJUIFBPSU5UOiBpbmRpY2F0b3IuX21vdmVcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdF9lbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKCAhdGhpcy5pbml0aWF0ZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0aWF0ZWQgPSBmYWxzZTtcblxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCAndG91Y2htb3ZlJywgdGhpcyk7XG5cdFx0dXRpbHMucmVtb3ZlRXZlbnQod2luZG93LCB1dGlscy5wcmVmaXhQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksIHRoaXMpO1xuXHRcdHV0aWxzLnJlbW92ZUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScsIHRoaXMpO1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuc25hcCApIHtcblx0XHRcdHZhciBzbmFwID0gdGhpcy5zY3JvbGxlci5fbmVhcmVzdFNuYXAodGhpcy5zY3JvbGxlci54LCB0aGlzLnNjcm9sbGVyLnkpO1xuXG5cdFx0XHR2YXIgdGltZSA9IHRoaXMub3B0aW9ucy5zbmFwU3BlZWQgfHwgTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRNYXRoLm1pbihNYXRoLmFicyh0aGlzLnNjcm9sbGVyLnggLSBzbmFwLngpLCAxMDAwKSxcblx0XHRcdFx0XHRcdE1hdGgubWluKE1hdGguYWJzKHRoaXMuc2Nyb2xsZXIueSAtIHNuYXAueSksIDEwMDApXG5cdFx0XHRcdFx0KSwgMzAwKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNjcm9sbGVyLnggIT0gc25hcC54IHx8IHRoaXMuc2Nyb2xsZXIueSAhPSBzbmFwLnkgKSB7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWCA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuZGlyZWN0aW9uWSA9IDA7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsZXIuY3VycmVudFBhZ2UgPSBzbmFwO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHNuYXAueCwgc25hcC55LCB0aW1lLCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMuYm91bmNlRWFzaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubW92ZWQgKSB7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLl9leGVjRXZlbnQoJ3Njcm9sbEVuZCcpO1xuXHRcdH1cblx0fSxcblxuXHR0cmFuc2l0aW9uVGltZTogZnVuY3Rpb24gKHRpbWUpIHtcblx0XHR0aW1lID0gdGltZSB8fCAwO1xuXHRcdHZhciBkdXJhdGlvblByb3AgPSB1dGlscy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb247XG5cdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID0gdGltZSArICdtcyc7XG5cblx0XHRpZiAoICF0aW1lICYmIHV0aWxzLmlzQmFkQW5kcm9pZCApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbZHVyYXRpb25Qcm9wXSA9ICcwLjAwMDFtcyc7XG5cdFx0XHQvLyByZW1vdmUgMC4wMDAxbXNcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHJBRihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID09PSAnMC4wMDAxbXMnKSB7XG5cdFx0XHRcdFx0c2VsZi5pbmRpY2F0b3JTdHlsZVtkdXJhdGlvblByb3BdID0gJzBzJztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogZnVuY3Rpb24gKGVhc2luZykge1xuXHRcdHRoaXMuaW5kaWNhdG9yU3R5bGVbdXRpbHMuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXSA9IGVhc2luZztcblx0fSxcblxuXHRyZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy50cmFuc2l0aW9uVGltZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCAmJiAhdGhpcy5vcHRpb25zLmxpc3RlblkgKSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5ZICYmICF0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUuZGlzcGxheSA9IHRoaXMuc2Nyb2xsZXIuaGFzVmVydGljYWxTY3JvbGwgPyAnYmxvY2snIDogJ25vbmUnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmRpc3BsYXkgPSB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgfHwgdGhpcy5zY3JvbGxlci5oYXNWZXJ0aWNhbFNjcm9sbCA/ICdibG9jaycgOiAnbm9uZSc7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLmhhc0hvcml6b250YWxTY3JvbGwgJiYgdGhpcy5zY3JvbGxlci5oYXNWZXJ0aWNhbFNjcm9sbCApIHtcblx0XHRcdHV0aWxzLmFkZENsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxCb3RoU2Nyb2xsYmFycycpO1xuXHRcdFx0dXRpbHMucmVtb3ZlQ2xhc3ModGhpcy53cmFwcGVyLCAnaVNjcm9sbExvbmVTY3JvbGxiYXInKTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjcm9sbGJhcnMgJiYgdGhpcy5vcHRpb25zLmN1c3RvbVN0eWxlICkge1xuXHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5yaWdodCA9ICc4cHgnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlci5zdHlsZS5ib3R0b20gPSAnOHB4Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1dGlscy5yZW1vdmVDbGFzcyh0aGlzLndyYXBwZXIsICdpU2Nyb2xsQm90aFNjcm9sbGJhcnMnKTtcblx0XHRcdHV0aWxzLmFkZENsYXNzKHRoaXMud3JhcHBlciwgJ2lTY3JvbGxMb25lU2Nyb2xsYmFyJyk7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmRlZmF1bHRTY3JvbGxiYXJzICYmIHRoaXMub3B0aW9ucy5jdXN0b21TdHlsZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWCApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUucmlnaHQgPSAnMnB4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZXIuc3R5bGUuYm90dG9tID0gJzJweCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgciA9IHRoaXMud3JhcHBlci5vZmZzZXRIZWlnaHQ7XHQvLyBmb3JjZSByZWZyZXNoXG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5saXN0ZW5YICkge1xuXHRcdFx0dGhpcy53cmFwcGVyV2lkdGggPSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yV2lkdGggPSBNYXRoLm1heChNYXRoLnJvdW5kKHRoaXMud3JhcHBlcldpZHRoICogdGhpcy53cmFwcGVyV2lkdGggLyAodGhpcy5zY3JvbGxlci5zY3JvbGxlcldpZHRoIHx8IHRoaXMud3JhcHBlcldpZHRoIHx8IDEpKSwgOCk7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLmluZGljYXRvcldpZHRoICsgJ3B4Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9yV2lkdGggPSB0aGlzLmluZGljYXRvci5jbGllbnRXaWR0aDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NYID0gdGhpcy53cmFwcGVyV2lkdGggLSB0aGlzLmluZGljYXRvcldpZHRoO1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ2NsaXAnICkge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WCA9IC10aGlzLmluZGljYXRvcldpZHRoICsgODtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVggPSB0aGlzLndyYXBwZXJXaWR0aCAtIDg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1pbkJvdW5kYXJ5WCA9IDA7XG5cdFx0XHRcdHRoaXMubWF4Qm91bmRhcnlYID0gdGhpcy5tYXhQb3NYO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNpemVSYXRpb1ggPSB0aGlzLm9wdGlvbnMuc3BlZWRSYXRpb1ggfHwgKHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWCAmJiAodGhpcy5tYXhQb3NYIC8gdGhpcy5zY3JvbGxlci5tYXhTY3JvbGxYKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMubGlzdGVuWSApIHtcblx0XHRcdHRoaXMud3JhcHBlckhlaWdodCA9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5yZXNpemUgKSB7XG5cdFx0XHRcdHRoaXMuaW5kaWNhdG9ySGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5yb3VuZCh0aGlzLndyYXBwZXJIZWlnaHQgKiB0aGlzLndyYXBwZXJIZWlnaHQgLyAodGhpcy5zY3JvbGxlci5zY3JvbGxlckhlaWdodCB8fCB0aGlzLndyYXBwZXJIZWlnaHQgfHwgMSkpLCA4KTtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodCArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmluZGljYXRvckhlaWdodCA9IHRoaXMuaW5kaWNhdG9yLmNsaWVudEhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnY2xpcCcgKSB7XG5cdFx0XHRcdHRoaXMubWluQm91bmRhcnlZID0gLXRoaXMuaW5kaWNhdG9ySGVpZ2h0ICsgODtcblx0XHRcdFx0dGhpcy5tYXhCb3VuZGFyeVkgPSB0aGlzLndyYXBwZXJIZWlnaHQgLSA4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5taW5Cb3VuZGFyeVkgPSAwO1xuXHRcdFx0XHR0aGlzLm1heEJvdW5kYXJ5WSA9IHRoaXMubWF4UG9zWTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXhQb3NZID0gdGhpcy53cmFwcGVySGVpZ2h0IC0gdGhpcy5pbmRpY2F0b3JIZWlnaHQ7XG5cdFx0XHR0aGlzLnNpemVSYXRpb1kgPSB0aGlzLm9wdGlvbnMuc3BlZWRSYXRpb1kgfHwgKHRoaXMuc2Nyb2xsZXIubWF4U2Nyb2xsWSAmJiAodGhpcy5tYXhQb3NZIC8gdGhpcy5zY3JvbGxlci5tYXhTY3JvbGxZKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHR9LFxuXG5cdHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHggPSB0aGlzLm9wdGlvbnMubGlzdGVuWCAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWCAqIHRoaXMuc2Nyb2xsZXIueCkgfHwgMCxcblx0XHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSAmJiBNYXRoLnJvdW5kKHRoaXMuc2l6ZVJhdGlvWSAqIHRoaXMuc2Nyb2xsZXIueSkgfHwgMDtcblxuXHRcdGlmICggIXRoaXMub3B0aW9ucy5pZ25vcmVCb3VuZGFyaWVzICkge1xuXHRcdFx0aWYgKCB4IDwgdGhpcy5taW5Cb3VuZGFyeVggKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLmluZGljYXRvcldpZHRoICsgeCwgOCk7XG5cdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHggPSB0aGlzLm1pbkJvdW5kYXJ5WDtcblx0XHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heEJvdW5kYXJ5WCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy53aWR0aCA9IE1hdGgubWF4KHRoaXMuaW5kaWNhdG9yV2lkdGggLSAoeCAtIHRoaXMubWF4UG9zWCksIDgpO1xuXHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHR4ID0gdGhpcy5tYXhQb3NYICsgdGhpcy5pbmRpY2F0b3JXaWR0aCAtIHRoaXMud2lkdGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHRoaXMubWF4Qm91bmRhcnlYO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgJiYgdGhpcy53aWR0aCAhPSB0aGlzLmluZGljYXRvcldpZHRoICkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5pbmRpY2F0b3JXaWR0aDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHkgPCB0aGlzLm1pbkJvdW5kYXJ5WSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuc2hyaW5rID09ICdzY2FsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmluZGljYXRvckhlaWdodCArIHkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR5ID0gdGhpcy5taW5Cb3VuZGFyeVk7XG5cdFx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhCb3VuZGFyeVkgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5vcHRpb25zLnNocmluayA9PSAnc2NhbGUnICkge1xuXHRcdFx0XHRcdHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5pbmRpY2F0b3JIZWlnaHQgLSAoeSAtIHRoaXMubWF4UG9zWSkgKiAzLCA4KTtcblx0XHRcdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhQb3NZICsgdGhpcy5pbmRpY2F0b3JIZWlnaHQgLSB0aGlzLmhlaWdodDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gdGhpcy5tYXhCb3VuZGFyeVk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMub3B0aW9ucy5zaHJpbmsgPT0gJ3NjYWxlJyAmJiB0aGlzLmhlaWdodCAhPSB0aGlzLmluZGljYXRvckhlaWdodCApIHtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLmluZGljYXRvckhlaWdodDtcblx0XHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0aWYgKCB0aGlzLnNjcm9sbGVyLm9wdGlvbnMudXNlVHJhbnNmb3JtICkge1xuXHRcdFx0dGhpcy5pbmRpY2F0b3JTdHlsZVt1dGlscy5zdHlsZS50cmFuc2Zvcm1dID0gJ3RyYW5zbGF0ZSgnICsgeCArICdweCwnICsgeSArICdweCknICsgdGhpcy5zY3JvbGxlci50cmFuc2xhdGVaO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmluZGljYXRvclN0eWxlLmxlZnQgPSB4ICsgJ3B4Jztcblx0XHRcdHRoaXMuaW5kaWNhdG9yU3R5bGUudG9wID0geSArICdweCc7XG5cdFx0fVxuXHR9LFxuXG5cdF9wb3M6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0aWYgKCB4IDwgMCApIHtcblx0XHRcdHggPSAwO1xuXHRcdH0gZWxzZSBpZiAoIHggPiB0aGlzLm1heFBvc1ggKSB7XG5cdFx0XHR4ID0gdGhpcy5tYXhQb3NYO1xuXHRcdH1cblxuXHRcdGlmICggeSA8IDAgKSB7XG5cdFx0XHR5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCB5ID4gdGhpcy5tYXhQb3NZICkge1xuXHRcdFx0eSA9IHRoaXMubWF4UG9zWTtcblx0XHR9XG5cblx0XHR4ID0gdGhpcy5vcHRpb25zLmxpc3RlblggPyBNYXRoLnJvdW5kKHggLyB0aGlzLnNpemVSYXRpb1gpIDogdGhpcy5zY3JvbGxlci54O1xuXHRcdHkgPSB0aGlzLm9wdGlvbnMubGlzdGVuWSA/IE1hdGgucm91bmQoeSAvIHRoaXMuc2l6ZVJhdGlvWSkgOiB0aGlzLnNjcm9sbGVyLnk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHgsIHkpO1xuXHR9LFxuXG5cdGZhZGU6IGZ1bmN0aW9uICh2YWwsIGhvbGQpIHtcblx0XHRpZiAoIGhvbGQgJiYgIXRoaXMudmlzaWJsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5mYWRlVGltZW91dCk7XG5cdFx0dGhpcy5mYWRlVGltZW91dCA9IG51bGw7XG5cblx0XHR2YXIgdGltZSA9IHZhbCA/IDI1MCA6IDUwMCxcblx0XHRcdGRlbGF5ID0gdmFsID8gMCA6IDMwMDtcblxuXHRcdHZhbCA9IHZhbCA/ICcxJyA6ICcwJztcblxuXHRcdHRoaXMud3JhcHBlclN0eWxlW3V0aWxzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbl0gPSB0aW1lICsgJ21zJztcblxuXHRcdHRoaXMuZmFkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHR0aGlzLndyYXBwZXJTdHlsZS5vcGFjaXR5ID0gdmFsO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gK3ZhbDtcblx0XHR9KS5iaW5kKHRoaXMsIHZhbCksIGRlbGF5KTtcblx0fVxufTtcblxuSVNjcm9sbC51dGlscyA9IHV0aWxzO1xuXG5pZiAoIHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gSVNjcm9sbDtcbn0gZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgICAgICBkZWZpbmUoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIElTY3JvbGw7IH0gKTtcbn0gZWxzZSB7XG5cdHdpbmRvdy5JU2Nyb2xsID0gSVNjcm9sbDtcbn1cblxufSkod2luZG93LCBkb2N1bWVudCwgTWF0aCk7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAqIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc3RlcDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSYW5nZTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYmFzZVJhbmdlID0gcmVxdWlyZSgnLi9fYmFzZVJhbmdlJyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpLFxuICAgIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmFuZ2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJvdW5jZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBub3c7XG4iLCJ2YXIgY3JlYXRlUmFuZ2UgPSByZXF1aXJlKCcuL19jcmVhdGVSYW5nZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gKlxuICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yYW5nZSg0KTtcbiAqIC8vID0+IFswLCAxLCAyLCAzXVxuICpcbiAqIF8ucmFuZ2UoLTQpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA1KTtcbiAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICpcbiAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAqXG4gKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAqXG4gKiBfLnJhbmdlKDEsIDQsIDApO1xuICogLy8gPT4gWzEsIDEsIDFdXG4gKlxuICogXy5yYW5nZSgwKTtcbiAqIC8vID0+IFtdXG4gKi9cbnZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZ2U7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi9kZWJvdW5jZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgaHlwZXJzY3JpcHQgPSByZXF1aXJlKFwiLi9yZW5kZXIvaHlwZXJzY3JpcHRcIilcblxuaHlwZXJzY3JpcHQudHJ1c3QgPSByZXF1aXJlKFwiLi9yZW5kZXIvdHJ1c3RcIilcbmh5cGVyc2NyaXB0LmZyYWdtZW50ID0gcmVxdWlyZShcIi4vcmVuZGVyL2ZyYWdtZW50XCIpXG5cbm1vZHVsZS5leHBvcnRzID0gaHlwZXJzY3JpcHRcbiIsIjsoZnVuY3Rpb24oKSB7XG5cInVzZSBzdHJpY3RcIlxuZnVuY3Rpb24gVm5vZGUodGFnLCBrZXksIGF0dHJzMCwgY2hpbGRyZW4sIHRleHQsIGRvbSkge1xuXHRyZXR1cm4ge3RhZzogdGFnLCBrZXk6IGtleSwgYXR0cnM6IGF0dHJzMCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0OiB0ZXh0LCBkb206IGRvbSwgZG9tU2l6ZTogdW5kZWZpbmVkLCBzdGF0ZTogdW5kZWZpbmVkLCBfc3RhdGU6IHVuZGVmaW5lZCwgZXZlbnRzOiB1bmRlZmluZWQsIGluc3RhbmNlOiB1bmRlZmluZWQsIHNraXA6IGZhbHNlfVxufVxuVm5vZGUubm9ybWFsaXplID0gZnVuY3Rpb24obm9kZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShub2RlKSkgcmV0dXJuIFZub2RlKFwiW1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4obm9kZSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRpZiAobm9kZSAhPSBudWxsICYmIHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBub2RlID09PSBmYWxzZSA/IFwiXCIgOiBub2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0cmV0dXJuIG5vZGVcbn1cblZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNoaWxkcmVuW2ldID0gVm5vZGUubm9ybWFsaXplKGNoaWxkcmVuW2ldKVxuXHR9XG5cdHJldHVybiBjaGlsZHJlblxufVxudmFyIHNlbGVjdG9yUGFyc2VyID0gLyg/OihefCN8XFwuKShbXiNcXC5cXFtcXF1dKykpfChcXFsoLis/KSg/Olxccyo9XFxzKihcInwnfCkoKD86XFxcXFtcIidcXF1dfC4pKj8pXFw1KT9cXF0pL2dcbnZhciBzZWxlY3RvckNhY2hlID0ge31cbnZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuZnVuY3Rpb24gaXNFbXB0eShvYmplY3QpIHtcblx0Zm9yICh2YXIga2V5IGluIG9iamVjdCkgaWYgKGhhc093bi5jYWxsKG9iamVjdCwga2V5KSkgcmV0dXJuIGZhbHNlXG5cdHJldHVybiB0cnVlXG59XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGlmICghaXNFbXB0eShzdGF0ZS5hdHRycykgJiYgIWlzRW1wdHkoYXR0cnMpKSB7XG5cdFx0dmFyIG5ld0F0dHJzID0ge31cblx0XHRmb3IodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpKSB7XG5cdFx0XHRcdG5ld0F0dHJzW2tleV0gPSBhdHRyc1trZXldXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGF0dHJzID0gbmV3QXR0cnNcblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gc3RhdGUuYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoc3RhdGUuYXR0cnMsIGtleSkpIHtcblx0XHRcdGF0dHJzW2tleV0gPSBzdGF0ZS5hdHRyc1trZXldXG5cdFx0fVxuXHR9XG5cdGlmIChjbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChhdHRycy5jbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhdHRycy5jbGFzcyA9IHVuZGVmaW5lZFxuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG5cdFx0fVxuXHRcdGlmIChzdGF0ZS5hdHRycy5jbGFzc05hbWUgIT0gbnVsbCkge1xuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gc3RhdGUuYXR0cnMuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWVcblx0XHR9XG5cdH1cblx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpICYmIGtleSAhPT0gXCJrZXlcIikge1xuXHRcdFx0aGFzQXR0cnMgPSB0cnVlXG5cdFx0XHRicmVha1xuXHRcdH1cblx0fVxuXHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdICE9IG51bGwgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIiNcIikge1xuXHRcdHRleHQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkTGlzdCA9IGNoaWxkcmVuXG5cdH1cblx0cmV0dXJuIFZub2RlKHN0YXRlLnRhZywgYXR0cnMua2V5LCBoYXNBdHRycyA/IGF0dHJzIDogdW5kZWZpbmVkLCBjaGlsZExpc3QsIHRleHQpXG59XG5mdW5jdGlvbiBoeXBlcnNjcmlwdChzZWxlY3Rvcikge1xuXHQvLyBCZWNhdXNlIHNsb3BweSBtb2RlIHN1Y2tzXG5cdHZhciBhdHRycyA9IGFyZ3VtZW50c1sxXSwgc3RhcnQgPSAyLCBjaGlsZHJlblxuXHRpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNlbGVjdG9yLnZpZXcgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHRocm93IEVycm9yKFwiVGhlIHNlbGVjdG9yIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgY29tcG9uZW50LlwiKTtcblx0fVxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dmFyIGNhY2hlZCA9IHNlbGVjdG9yQ2FjaGVbc2VsZWN0b3JdIHx8IGNvbXBpbGVTZWxlY3RvcihzZWxlY3Rvcilcblx0fVxuXHRpZiAoYXR0cnMgPT0gbnVsbCkge1xuXHRcdGF0dHJzID0ge31cblx0fSBlbHNlIGlmICh0eXBlb2YgYXR0cnMgIT09IFwib2JqZWN0XCIgfHwgYXR0cnMudGFnICE9IG51bGwgfHwgQXJyYXkuaXNBcnJheShhdHRycykpIHtcblx0XHRhdHRycyA9IHt9XG5cdFx0c3RhcnQgPSAxXG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IHN0YXJ0ICsgMSkge1xuXHRcdGNoaWxkcmVuID0gYXJndW1lbnRzW3N0YXJ0XVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIGNoaWxkcmVuID0gW2NoaWxkcmVuXVxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkcmVuID0gW11cblx0XHR3aGlsZSAoc3RhcnQgPCBhcmd1bWVudHMubGVuZ3RoKSBjaGlsZHJlbi5wdXNoKGFyZ3VtZW50c1tzdGFydCsrXSlcblx0fVxuXHR2YXIgbm9ybWFsaXplZCA9IFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKVxuXHRpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIGV4ZWNTZWxlY3RvcihjYWNoZWQsIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBWbm9kZShzZWxlY3RvciwgYXR0cnMua2V5LCBhdHRycywgbm9ybWFsaXplZClcblx0fVxufVxuaHlwZXJzY3JpcHQudHJ1c3QgPSBmdW5jdGlvbihodG1sKSB7XG5cdGlmIChodG1sID09IG51bGwpIGh0bWwgPSBcIlwiXG5cdHJldHVybiBWbm9kZShcIjxcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGh0bWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxuaHlwZXJzY3JpcHQuZnJhZ21lbnQgPSBmdW5jdGlvbihhdHRyczEsIGNoaWxkcmVuKSB7XG5cdHJldHVybiBWbm9kZShcIltcIiwgYXR0cnMxLmtleSwgYXR0cnMxLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxudmFyIG0gPSBoeXBlcnNjcmlwdFxuLyoqIEBjb25zdHJ1Y3RvciAqL1xudmFyIFByb21pc2VQb2x5ZmlsbCA9IGZ1bmN0aW9uKGV4ZWN1dG9yKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlUG9seWZpbGwpKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIG11c3QgYmUgY2FsbGVkIHdpdGggYG5ld2BcIilcblx0aWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpXG5cdHZhciBzZWxmID0gdGhpcywgcmVzb2x2ZXJzID0gW10sIHJlamVjdG9ycyA9IFtdLCByZXNvbHZlQ3VycmVudCA9IGhhbmRsZXIocmVzb2x2ZXJzLCB0cnVlKSwgcmVqZWN0Q3VycmVudCA9IGhhbmRsZXIocmVqZWN0b3JzLCBmYWxzZSlcblx0dmFyIGluc3RhbmNlID0gc2VsZi5faW5zdGFuY2UgPSB7cmVzb2x2ZXJzOiByZXNvbHZlcnMsIHJlamVjdG9yczogcmVqZWN0b3JzfVxuXHR2YXIgY2FsbEFzeW5jID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBoYW5kbGVyKGxpc3QsIHNob3VsZEFic29yYikge1xuXHRcdHJldHVybiBmdW5jdGlvbiBleGVjdXRlKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGhlblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHNob3VsZEFic29yYiAmJiB2YWx1ZSAhPSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiAodGhlbiA9IHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIHcvIGl0c2VsZlwiKVxuXHRcdFx0XHRcdGV4ZWN1dGVPbmNlKHRoZW4uYmluZCh2YWx1ZSkpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2FsbEFzeW5jKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCFzaG91bGRBYnNvcmIgJiYgbGlzdC5sZW5ndGggPT09IDApIGNvbnNvbGUuZXJyb3IoXCJQb3NzaWJsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb246XCIsIHZhbHVlKVxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSBsaXN0W2ldKHZhbHVlKVxuXHRcdFx0XHRcdFx0cmVzb2x2ZXJzLmxlbmd0aCA9IDAsIHJlamVjdG9ycy5sZW5ndGggPSAwXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5zdGF0ZSA9IHNob3VsZEFic29yYlxuXHRcdFx0XHRcdFx0aW5zdGFuY2UucmV0cnkgPSBmdW5jdGlvbigpIHtleGVjdXRlKHZhbHVlKX1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWplY3RDdXJyZW50KGUpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGV4ZWN1dGVPbmNlKHRoZW4pIHtcblx0XHR2YXIgcnVucyA9IDBcblx0XHRmdW5jdGlvbiBydW4oZm4pIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAocnVucysrID4gMCkgcmV0dXJuXG5cdFx0XHRcdGZuKHZhbHVlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgb25lcnJvciA9IHJ1bihyZWplY3RDdXJyZW50KVxuXHRcdHRyeSB7dGhlbihydW4ocmVzb2x2ZUN1cnJlbnQpLCBvbmVycm9yKX0gY2F0Y2ggKGUpIHtvbmVycm9yKGUpfVxuXHR9XG5cdGV4ZWN1dGVPbmNlKGV4ZWN1dG9yKVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0aW9uKSB7XG5cdHZhciBzZWxmID0gdGhpcywgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZVxuXHRmdW5jdGlvbiBoYW5kbGUoY2FsbGJhY2ssIGxpc3QsIG5leHQsIHN0YXRlKSB7XG5cdFx0bGlzdC5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIG5leHQodmFsdWUpXG5cdFx0XHRlbHNlIHRyeSB7cmVzb2x2ZU5leHQoY2FsbGJhY2sodmFsdWUpKX0gY2F0Y2ggKGUpIHtpZiAocmVqZWN0TmV4dCkgcmVqZWN0TmV4dChlKX1cblx0XHR9KVxuXHRcdGlmICh0eXBlb2YgaW5zdGFuY2UucmV0cnkgPT09IFwiZnVuY3Rpb25cIiAmJiBzdGF0ZSA9PT0gaW5zdGFuY2Uuc3RhdGUpIGluc3RhbmNlLnJldHJ5KClcblx0fVxuXHR2YXIgcmVzb2x2ZU5leHQsIHJlamVjdE5leHRcblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge3Jlc29sdmVOZXh0ID0gcmVzb2x2ZSwgcmVqZWN0TmV4dCA9IHJlamVjdH0pXG5cdGhhbmRsZShvbkZ1bGZpbGxlZCwgaW5zdGFuY2UucmVzb2x2ZXJzLCByZXNvbHZlTmV4dCwgdHJ1ZSksIGhhbmRsZShvblJlamVjdGlvbiwgaW5zdGFuY2UucmVqZWN0b3JzLCByZWplY3ROZXh0LCBmYWxzZSlcblx0cmV0dXJuIHByb21pc2Vcbn1cblByb21pc2VQb2x5ZmlsbC5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihvblJlamVjdGlvbikge1xuXHRyZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKVxufVxuUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlUG9seWZpbGwpIHJldHVybiB2YWx1ZVxuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlKSB7cmVzb2x2ZSh2YWx1ZSl9KVxufVxuUHJvbWlzZVBvbHlmaWxsLnJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge3JlamVjdCh2YWx1ZSl9KVxufVxuUHJvbWlzZVBvbHlmaWxsLmFsbCA9IGZ1bmN0aW9uKGxpc3QpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0dmFyIHRvdGFsID0gbGlzdC5sZW5ndGgsIGNvdW50ID0gMCwgdmFsdWVzID0gW11cblx0XHRpZiAobGlzdC5sZW5ndGggPT09IDApIHJlc29sdmUoW10pXG5cdFx0ZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdChmdW5jdGlvbihpKSB7XG5cdFx0XHRcdGZ1bmN0aW9uIGNvbnN1bWUodmFsdWUpIHtcblx0XHRcdFx0XHRjb3VudCsrXG5cdFx0XHRcdFx0dmFsdWVzW2ldID0gdmFsdWVcblx0XHRcdFx0XHRpZiAoY291bnQgPT09IHRvdGFsKSByZXNvbHZlKHZhbHVlcylcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGlzdFtpXSAhPSBudWxsICYmICh0eXBlb2YgbGlzdFtpXSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbGlzdFtpXSA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgbGlzdFtpXS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRsaXN0W2ldLnRoZW4oY29uc3VtZSwgcmVqZWN0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgY29uc3VtZShsaXN0W2ldKVxuXHRcdFx0fSkoaSlcblx0XHR9XG5cdH0pXG59XG5Qcm9taXNlUG9seWZpbGwucmFjZSA9IGZ1bmN0aW9uKGxpc3QpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsaXN0W2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KVxuXHRcdH1cblx0fSlcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdGlmICh0eXBlb2Ygd2luZG93LlByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHdpbmRvdy5Qcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG5cdHZhciBQcm9taXNlUG9seWZpbGwgPSB3aW5kb3cuUHJvbWlzZVxufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsLlByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIGdsb2JhbC5Qcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG5cdHZhciBQcm9taXNlUG9seWZpbGwgPSBnbG9iYWwuUHJvbWlzZVxufSBlbHNlIHtcbn1cbnZhciBidWlsZFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikgcmV0dXJuIFwiXCJcblx0dmFyIGFyZ3MgPSBbXVxuXHRmb3IgKHZhciBrZXkwIGluIG9iamVjdCkge1xuXHRcdGRlc3RydWN0dXJlKGtleTAsIG9iamVjdFtrZXkwXSlcblx0fVxuXHRyZXR1cm4gYXJncy5qb2luKFwiJlwiKVxuXHRmdW5jdGlvbiBkZXN0cnVjdHVyZShrZXkwLCB2YWx1ZSkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkZXN0cnVjdHVyZShrZXkwICsgXCJbXCIgKyBpICsgXCJdXCIsIHZhbHVlW2ldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHZhbHVlKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgYXJncy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkwKSArICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBcIlwiID8gXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpIDogXCJcIikpXG5cdH1cbn1cbnZhciBGSUxFX1BST1RPQ09MX1JFR0VYID0gbmV3IFJlZ0V4cChcIl5maWxlOi8vXCIsIFwiaVwiKVxudmFyIF84ID0gZnVuY3Rpb24oJHdpbmRvdywgUHJvbWlzZSkge1xuXHR2YXIgY2FsbGJhY2tDb3VudCA9IDBcblx0dmFyIG9uY29tcGxldGlvblxuXHRmdW5jdGlvbiBzZXRDb21wbGV0aW9uQ2FsbGJhY2soY2FsbGJhY2spIHtvbmNvbXBsZXRpb24gPSBjYWxsYmFja31cblx0ZnVuY3Rpb24gZmluYWxpemVyKCkge1xuXHRcdHZhciBjb3VudCA9IDBcblx0XHRmdW5jdGlvbiBjb21wbGV0ZSgpIHtpZiAoLS1jb3VudCA9PT0gMCAmJiB0eXBlb2Ygb25jb21wbGV0aW9uID09PSBcImZ1bmN0aW9uXCIpIG9uY29tcGxldGlvbigpfVxuXHRcdHJldHVybiBmdW5jdGlvbiBmaW5hbGl6ZShwcm9taXNlMCkge1xuXHRcdFx0dmFyIHRoZW4wID0gcHJvbWlzZTAudGhlblxuXHRcdFx0cHJvbWlzZTAudGhlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb3VudCsrXG5cdFx0XHRcdHZhciBuZXh0ID0gdGhlbjAuYXBwbHkocHJvbWlzZTAsIGFyZ3VtZW50cylcblx0XHRcdFx0bmV4dC50aGVuKGNvbXBsZXRlLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0Y29tcGxldGUoKVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gMCkgdGhyb3cgZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRyZXR1cm4gZmluYWxpemUobmV4dClcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlMFxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBub3JtYWxpemUoYXJncywgZXh0cmEpIHtcblx0XHRpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciB1cmwgPSBhcmdzXG5cdFx0XHRhcmdzID0gZXh0cmEgfHwge31cblx0XHRcdGlmIChhcmdzLnVybCA9PSBudWxsKSBhcmdzLnVybCA9IHVybFxuXHRcdH1cblx0XHRyZXR1cm4gYXJnc1xuXHR9XG5cdGZ1bmN0aW9uIHJlcXVlc3QoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRpZiAoYXJncy5tZXRob2QgPT0gbnVsbCkgYXJncy5tZXRob2QgPSBcIkdFVFwiXG5cdFx0XHRhcmdzLm1ldGhvZCA9IGFyZ3MubWV0aG9kLnRvVXBwZXJDYXNlKClcblx0XHRcdHZhciB1c2VCb2R5ID0gKGFyZ3MubWV0aG9kID09PSBcIkdFVFwiIHx8IGFyZ3MubWV0aG9kID09PSBcIlRSQUNFXCIpID8gZmFsc2UgOiAodHlwZW9mIGFyZ3MudXNlQm9keSA9PT0gXCJib29sZWFuXCIgPyBhcmdzLnVzZUJvZHkgOiB0cnVlKVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLnNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLnNlcmlhbGl6ZSA9IHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcmdzLmRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSA/IGZ1bmN0aW9uKHZhbHVlKSB7cmV0dXJuIHZhbHVlfSA6IEpTT04uc3RyaW5naWZ5XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuZGVzZXJpYWxpemUgIT09IFwiZnVuY3Rpb25cIikgYXJncy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuZXh0cmFjdCAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmV4dHJhY3QgPSBleHRyYWN0XG5cdFx0XHRhcmdzLnVybCA9IGludGVycG9sYXRlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHRpZiAodXNlQm9keSkgYXJncy5kYXRhID0gYXJncy5zZXJpYWxpemUoYXJncy5kYXRhKVxuXHRcdFx0ZWxzZSBhcmdzLnVybCA9IGFzc2VtYmxlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHR2YXIgeGhyID0gbmV3ICR3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSxcblx0XHRcdFx0YWJvcnRlZCA9IGZhbHNlLFxuXHRcdFx0XHRfYWJvcnQgPSB4aHIuYWJvcnRcblx0XHRcdHhoci5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuXHRcdFx0XHRhYm9ydGVkID0gdHJ1ZVxuXHRcdFx0XHRfYWJvcnQuY2FsbCh4aHIpXG5cdFx0XHR9XG5cdFx0XHR4aHIub3BlbihhcmdzLm1ldGhvZCwgYXJncy51cmwsIHR5cGVvZiBhcmdzLmFzeW5jID09PSBcImJvb2xlYW5cIiA/IGFyZ3MuYXN5bmMgOiB0cnVlLCB0eXBlb2YgYXJncy51c2VyID09PSBcInN0cmluZ1wiID8gYXJncy51c2VyIDogdW5kZWZpbmVkLCB0eXBlb2YgYXJncy5wYXNzd29yZCA9PT0gXCJzdHJpbmdcIiA/IGFyZ3MucGFzc3dvcmQgOiB1bmRlZmluZWQpXG5cdFx0XHRpZiAoYXJncy5zZXJpYWxpemUgPT09IEpTT04uc3RyaW5naWZ5ICYmIHVzZUJvZHkgJiYgIShhcmdzLmhlYWRlcnMgJiYgYXJncy5oZWFkZXJzLmhhc093blByb3BlcnR5KFwiQ29udGVudC1UeXBlXCIpKSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSAmJiAhKGFyZ3MuaGVhZGVycyAmJiBhcmdzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoXCJBY2NlcHRcIikpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC8qXCIpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy53aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSBhcmdzLndpdGhDcmVkZW50aWFsc1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZ3MuaGVhZGVycykgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXJncy5oZWFkZXJzLCBrZXkpKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgYXJncy5oZWFkZXJzW2tleV0pXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3MuY29uZmlnID09PSBcImZ1bmN0aW9uXCIpIHhociA9IGFyZ3MuY29uZmlnKHhociwgYXJncykgfHwgeGhyXG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIERvbid0IHRocm93IGVycm9ycyBvbiB4aHIuYWJvcnQoKS5cblx0XHRcdFx0aWYoYWJvcnRlZCkgcmV0dXJuXG5cdFx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzcG9uc2UgPSAoYXJncy5leHRyYWN0ICE9PSBleHRyYWN0KSA/IGFyZ3MuZXh0cmFjdCh4aHIsIGFyZ3MpIDogYXJncy5kZXNlcmlhbGl6ZShhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSlcblx0XHRcdFx0XHRcdGlmICgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0IHx8IEZJTEVfUFJPVE9DT0xfUkVHRVgudGVzdChhcmdzLnVybCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShjYXN0KGFyZ3MudHlwZSwgcmVzcG9uc2UpKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcih4aHIucmVzcG9uc2VUZXh0KVxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UpIGVycm9yW2tleV0gPSByZXNwb25zZVtrZXldXG5cdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJlamVjdChlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZUJvZHkgJiYgKGFyZ3MuZGF0YSAhPSBudWxsKSkgeGhyLnNlbmQoYXJncy5kYXRhKVxuXHRcdFx0ZWxzZSB4aHIuc2VuZCgpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlID8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBqc29ucChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdHZhciBjYWxsYmFja05hbWUgPSBhcmdzLmNhbGxiYWNrTmFtZSB8fCBcIl9taXRocmlsX1wiICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxNikgKyBcIl9cIiArIGNhbGxiYWNrQ291bnQrK1xuXHRcdFx0dmFyIHNjcmlwdCA9ICR3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKVxuXHRcdFx0JHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIGRhdGEpKVxuXHRcdFx0XHRkZWxldGUgJHdpbmRvd1tjYWxsYmFja05hbWVdXG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpXG5cdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJKU09OUCByZXF1ZXN0IGZhaWxlZFwiKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MuZGF0YSA9PSBudWxsKSBhcmdzLmRhdGEgPSB7fVxuXHRcdFx0YXJncy51cmwgPSBpbnRlcnBvbGF0ZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0YXJncy5kYXRhW2FyZ3MuY2FsbGJhY2tLZXkgfHwgXCJjYWxsYmFja1wiXSA9IGNhbGxiYWNrTmFtZVxuXHRcdFx0c2NyaXB0LnNyYyA9IGFzc2VtYmxlKGFyZ3MudXJsLCBhcmdzLmRhdGEpXG5cdFx0XHQkd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpXG5cdFx0fSlcblx0XHRyZXR1cm4gYXJncy5iYWNrZ3JvdW5kID09PSB0cnVlPyBwcm9taXNlMCA6IGZpbmFsaXplKHByb21pc2UwKVxuXHR9XG5cdGZ1bmN0aW9uIGludGVycG9sYXRlKHVybCwgZGF0YSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHJldHVybiB1cmxcblx0XHR2YXIgdG9rZW5zID0gdXJsLm1hdGNoKC86W15cXC9dKy9naSkgfHwgW11cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IHRva2Vuc1tpXS5zbGljZSgxKVxuXHRcdFx0aWYgKGRhdGFba2V5XSAhPSBudWxsKSB7XG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHRva2Vuc1tpXSwgZGF0YVtrZXldKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdXJsXG5cdH1cblx0ZnVuY3Rpb24gYXNzZW1ibGUodXJsLCBkYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5c3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZyhkYXRhKVxuXHRcdGlmIChxdWVyeXN0cmluZyAhPT0gXCJcIikge1xuXHRcdFx0dmFyIHByZWZpeCA9IHVybC5pbmRleE9mKFwiP1wiKSA8IDAgPyBcIj9cIiA6IFwiJlwiXG5cdFx0XHR1cmwgKz0gcHJlZml4ICsgcXVlcnlzdHJpbmdcblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGRlc2VyaWFsaXplKGRhdGEpIHtcblx0XHR0cnkge3JldHVybiBkYXRhICE9PSBcIlwiID8gSlNPTi5wYXJzZShkYXRhKSA6IG51bGx9XG5cdFx0Y2F0Y2ggKGUpIHt0aHJvdyBuZXcgRXJyb3IoZGF0YSl9XG5cdH1cblx0ZnVuY3Rpb24gZXh0cmFjdCh4aHIpIHtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH1cblx0ZnVuY3Rpb24gY2FzdCh0eXBlMCwgZGF0YSkge1xuXHRcdGlmICh0eXBlb2YgdHlwZTAgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YVtpXSA9IG5ldyB0eXBlMChkYXRhW2ldKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHJldHVybiBuZXcgdHlwZTAoZGF0YSlcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHRyZXR1cm4ge3JlcXVlc3Q6IHJlcXVlc3QsIGpzb25wOiBqc29ucCwgc2V0Q29tcGxldGlvbkNhbGxiYWNrOiBzZXRDb21wbGV0aW9uQ2FsbGJhY2t9XG59XG52YXIgcmVxdWVzdFNlcnZpY2UgPSBfOCh3aW5kb3csIFByb21pc2VQb2x5ZmlsbClcbnZhciBjb3JlUmVuZGVyZXIgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciAkZG9jID0gJHdpbmRvdy5kb2N1bWVudFxuXHR2YXIgJGVtcHR5RnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHR2YXIgbmFtZVNwYWNlID0ge1xuXHRcdHN2ZzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuXHRcdG1hdGg6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiXG5cdH1cblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cdGZ1bmN0aW9uIGdldE5hbWVTcGFjZSh2bm9kZSkge1xuXHRcdHJldHVybiB2bm9kZS5hdHRycyAmJiB2bm9kZS5hdHRycy54bWxucyB8fCBuYW1lU3BhY2Vbdm5vZGUudGFnXVxuXHR9XG5cdC8vY3JlYXRlXG5cdGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCBzdGFydCwgZW5kLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0Y3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRjYXNlIFwiI1wiOiByZXR1cm4gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHRcdFx0Y2FzZSBcIjxcIjogcmV0dXJuIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCJbXCI6IHJldHVybiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRkZWZhdWx0OiByZXR1cm4gY3JlYXRlRWxlbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHJldHVybiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0KHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0dm5vZGUuZG9tID0gJGRvYy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS5jaGlsZHJlbilcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgdm5vZGUuZG9tLCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZhciBtYXRjaDEgPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaDFbMV1dIHx8IFwiZGl2XCJcblx0XHR2YXIgdGVtcCA9ICRkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQxKVxuXHRcdHRlbXAuaW5uZXJIVE1MID0gdm5vZGUuY2hpbGRyZW5cblx0XHR2bm9kZS5kb20gPSB0ZW1wLmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gdGVtcC5jaGlsZE5vZGVzLmxlbmd0aFxuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0dmFyIGNoaWxkXG5cdFx0d2hpbGUgKGNoaWxkID0gdGVtcC5maXJzdENoaWxkKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZClcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVGcmFnbWVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGNyZWF0ZU5vZGVzKGZyYWdtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcblx0XHR2bm9kZS5kb21TaXplID0gZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHRpbnNlcnROb2RlKHBhcmVudCwgZnJhZ21lbnQsIG5leHRTaWJsaW5nKVxuXHRcdHJldHVybiBmcmFnbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciB0YWcgPSB2bm9kZS50YWdcblx0XHR2YXIgYXR0cnMyID0gdm5vZGUuYXR0cnNcblx0XHR2YXIgaXMgPSBhdHRyczIgJiYgYXR0cnMyLmlzXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cdFx0dmFyIGVsZW1lbnQgPSBucyA/XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpIDpcblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50KHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50KHRhZylcblx0XHR2bm9kZS5kb20gPSBlbGVtZW50XG5cdFx0aWYgKGF0dHJzMiAhPSBudWxsKSB7XG5cdFx0XHRzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucylcblx0XHR9XG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUudGV4dCAhPT0gXCJcIikgZWxlbWVudC50ZXh0Q29udGVudCA9IHZub2RlLnRleHRcblx0XHRcdFx0ZWxzZSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdH1cblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRcdGNyZWF0ZU5vZGVzKGVsZW1lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHRcdFx0c2V0TGF0ZUF0dHJzKHZub2RlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKSB7XG5cdFx0dmFyIHNlbnRpbmVsXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcudmlldyA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IE9iamVjdC5jcmVhdGUodm5vZGUudGFnKVxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS5zdGF0ZS52aWV3XG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB2b2lkIDBcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUudGFnXG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHRcdHZub2RlLnN0YXRlID0gKHZub2RlLnRhZy5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUudGFnLnByb3RvdHlwZS52aWV3ID09PSBcImZ1bmN0aW9uXCIpID8gbmV3IHZub2RlLnRhZyh2bm9kZSkgOiB2bm9kZS50YWcodm5vZGUpXG5cdFx0fVxuXHRcdHZub2RlLl9zdGF0ZSA9IHZub2RlLnN0YXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuZG9tICE9IG51bGwgPyB2bm9kZS5pbnN0YW5jZS5kb21TaXplIDogMFxuXHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXHRcdFx0cmV0dXJuIGVsZW1lbnRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdFx0cmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0fVxuXHR9XG5cdC8vdXBkYXRlXG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLCB2bm9kZXMsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGlmIChvbGQgPT09IHZub2RlcyB8fCBvbGQgPT0gbnVsbCAmJiB2bm9kZXMgPT0gbnVsbCkgcmV0dXJuXG5cdFx0ZWxzZSBpZiAob2xkID09IG51bGwpIGNyZWF0ZU5vZGVzKHBhcmVudCwgdm5vZGVzLCAwLCB2bm9kZXMubGVuZ3RoLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdGVsc2UgaWYgKHZub2RlcyA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIDAsIG9sZC5sZW5ndGgsIHZub2Rlcylcblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQubGVuZ3RoID09PSB2bm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpc1Vua2V5ZWQgPSBmYWxzZVxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICh2bm9kZXNbaV0gIT0gbnVsbCAmJiBvbGRbaV0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aXNVbmtleWVkID0gdm5vZGVzW2ldLmtleSA9PSBudWxsICYmIG9sZFtpXS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzVW5rZXllZCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkW2ldID09PSB2bm9kZXNbaV0pIGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRlbHNlIGlmIChvbGRbaV0gPT0gbnVsbCAmJiB2bm9kZXNbaV0gIT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2Rlc1tpXSwgaG9va3MsIG5zLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRlbHNlIGlmICh2bm9kZXNbaV0gPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCBpLCBpICsgMSwgdm5vZGVzKVxuXHRcdFx0XHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkW2ldLCB2bm9kZXNbaV0sIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIGkgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWN5Y2xpbmcgPSByZWN5Y2xpbmcgfHwgaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKVxuXHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHR2YXIgcG9vbCA9IG9sZC5wb29sXG5cdFx0XHRcdG9sZCA9IG9sZC5jb25jYXQob2xkLnBvb2wpXG5cdFx0XHR9XG5cdFx0XHR2YXIgb2xkU3RhcnQgPSAwLCBzdGFydCA9IDAsIG9sZEVuZCA9IG9sZC5sZW5ndGggLSAxLCBlbmQgPSB2bm9kZXMubGVuZ3RoIC0gMSwgbWFwXG5cdFx0XHR3aGlsZSAob2xkRW5kID49IG9sZFN0YXJ0ICYmIGVuZCA+PSBzdGFydCkge1xuXHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRTdGFydF0sIHYgPSB2bm9kZXNbc3RhcnRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRTdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmIChvLmtleSA9PT0gdi5rZXkpIHtcblx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkU3RhcnQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdG9sZFN0YXJ0KyssIHN0YXJ0Kytcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgbyA9IG9sZFtvbGRFbmRdXG5cdFx0XHRcdFx0aWYgKG8gPT09IHYgJiYgIXJlY3ljbGluZykgb2xkRW5kLS0sIHN0YXJ0Kytcblx0XHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdFx0ZWxzZSBpZiAodiA9PSBudWxsKSBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkRW5kID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdFx0aWYgKHJlY3ljbGluZyB8fCBzdGFydCA8IGVuZCkgaW5zZXJ0Tm9kZShwYXJlbnQsIHRvRnJhZ21lbnQobyksIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkU3RhcnQsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgYnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXSwgdiA9IHZub2Rlc1tlbmRdXG5cdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHRlbHNlIGlmIChvID09IG51bGwpIG9sZEVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZEVuZCArIDEsIG5leHRTaWJsaW5nKSwgc2hvdWxkUmVjeWNsZSwgbnMpXG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZyAmJiBvLnRhZyA9PT0gdi50YWcpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRpZiAoby5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBvLmRvbVxuXHRcdFx0XHRcdG9sZEVuZC0tLCBlbmQtLVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGlmICghbWFwKSBtYXAgPSBnZXRLZXlNYXAob2xkLCBvbGRFbmQpXG5cdFx0XHRcdFx0aWYgKHYgIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dmFyIG9sZEluZGV4ID0gbWFwW3Yua2V5XVxuXHRcdFx0XHRcdFx0aWYgKG9sZEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG1vdmFibGUgPSBvbGRbb2xkSW5kZXhdXG5cdFx0XHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRJbmRleCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBtb3ZhYmxlLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHJlY3ljbGluZywgbnMpXG5cdFx0XHRcdFx0XHRcdGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG1vdmFibGUpLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0b2xkW29sZEluZGV4XS5za2lwID0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRpZiAobW92YWJsZS5kb20gIT0gbnVsbCkgbmV4dFNpYmxpbmcgPSBtb3ZhYmxlLmRvbVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBkb20gPSBjcmVhdGVOb2RlKHBhcmVudCwgdiwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0XHRcdFx0bmV4dFNpYmxpbmcgPSBkb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZW5kIDwgc3RhcnQpIGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCArIDEsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0XHRyZW1vdmVOb2RlcyhvbGQsIG9sZFN0YXJ0LCBvbGRFbmQgKyAxLCB2bm9kZXMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHR2YXIgb2xkVGFnID0gb2xkLnRhZywgdGFnID0gdm5vZGUudGFnXG5cdFx0aWYgKG9sZFRhZyA9PT0gdGFnKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IG9sZC5zdGF0ZVxuXHRcdFx0dm5vZGUuX3N0YXRlID0gb2xkLl9zdGF0ZVxuXHRcdFx0dm5vZGUuZXZlbnRzID0gb2xkLmV2ZW50c1xuXHRcdFx0aWYgKCFyZWN5Y2xpbmcgJiYgc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpKSByZXR1cm5cblx0XHRcdGlmICh0eXBlb2Ygb2xkVGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0XHRcdFx0dm5vZGUuc3RhdGUgPSB7fVxuXHRcdFx0XHRcdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAob2xkVGFnKSB7XG5cdFx0XHRcdFx0Y2FzZSBcIiNcIjogdXBkYXRlVGV4dChvbGQsIHZub2RlKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiPFwiOiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpOyBicmVha1xuXHRcdFx0XHRcdGNhc2UgXCJbXCI6IHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKTsgYnJlYWtcblx0XHRcdFx0XHRkZWZhdWx0OiB1cGRhdGVFbGVtZW50KG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5zKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZCwgbnVsbClcblx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlVGV4dChvbGQsIHZub2RlKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbi50b1N0cmluZygpICE9PSB2bm9kZS5jaGlsZHJlbi50b1N0cmluZygpKSB7XG5cdFx0XHRvbGQuZG9tLm5vZGVWYWx1ZSA9IHZub2RlLmNoaWxkcmVuXG5cdFx0fVxuXHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVIVE1MKHBhcmVudCwgb2xkLCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAob2xkLmNoaWxkcmVuICE9PSB2bm9kZS5jaGlsZHJlbikge1xuXHRcdFx0dG9GcmFnbWVudChvbGQpXG5cdFx0XHRjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdH1cblx0XHRlbHNlIHZub2RlLmRvbSA9IG9sZC5kb20sIHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0dXBkYXRlTm9kZXMocGFyZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0dmFyIGRvbVNpemUgPSAwLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gbnVsbFxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLmRvbSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHZub2RlLmRvbSA9PSBudWxsKSB2bm9kZS5kb20gPSBjaGlsZC5kb21cblx0XHRcdFx0XHRkb21TaXplICs9IGNoaWxkLmRvbVNpemUgfHwgMVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9tU2l6ZSAhPT0gMSkgdm5vZGUuZG9tU2l6ZSA9IGRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlMCBtdWx0aXBsZSBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZS50ZXh0ID0gdW5kZWZpbmVkXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQuYXR0cnMsIHZub2RlLmF0dHJzLCBucylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9PSBcIlwiKSB7XG5cdFx0XHRpZiAob2xkLnRleHQudG9TdHJpbmcoKSAhPT0gdm5vZGUudGV4dC50b1N0cmluZygpKSBvbGQuZG9tLmZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdm5vZGUudGV4dFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmIChvbGQudGV4dCAhPSBudWxsKSBvbGQuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGQudGV4dCwgdW5kZWZpbmVkLCBvbGQuZG9tLmZpcnN0Q2hpbGQpXVxuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkgdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR1cGRhdGVOb2RlcyhlbGVtZW50LCBvbGQuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCByZWN5Y2xpbmcsIGhvb2tzLCBudWxsLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50KHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0aWYgKHJlY3ljbGluZykge1xuXHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSA9PT0gdm5vZGUpIHRocm93IEVycm9yKFwiQSB2aWV3IGNhbm5vdCByZXR1cm4gdGhlIHZub2RlIGl0IHJlY2VpdmVkIGFzIGFyZ3VtZW50XCIpXG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgdXBkYXRlTGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0XHR1cGRhdGVMaWZlY3ljbGUodm5vZGUuX3N0YXRlLCB2bm9kZSwgaG9va3MpXG5cdFx0fVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAob2xkLmluc3RhbmNlID09IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZC5pbnN0YW5jZSwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmluc3RhbmNlLmRvbVNpemVcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUob2xkLmluc3RhbmNlLCBudWxsKVxuXHRcdFx0dm5vZGUuZG9tID0gdW5kZWZpbmVkXG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpIHtcblx0XHRpZiAob2xkLnBvb2wgIT0gbnVsbCAmJiBNYXRoLmFicyhvbGQucG9vbC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSA8PSBNYXRoLmFicyhvbGQubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkpIHtcblx0XHRcdHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZFswXSAmJiBvbGRbMF0uY2hpbGRyZW4gJiYgb2xkWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgcG9vbENoaWxkcmVuTGVuZ3RoID0gb2xkLnBvb2xbMF0gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4gJiYgb2xkLnBvb2xbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciB2bm9kZXNDaGlsZHJlbkxlbmd0aCA9IHZub2Rlc1swXSAmJiB2bm9kZXNbMF0uY2hpbGRyZW4gJiYgdm5vZGVzWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHRpZiAoTWF0aC5hYnMocG9vbENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpIDw9IE1hdGguYWJzKG9sZENoaWxkcmVuTGVuZ3RoIC0gdm5vZGVzQ2hpbGRyZW5MZW5ndGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIGdldEtleU1hcCh2bm9kZXMsIGVuZCkge1xuXHRcdHZhciBtYXAgPSB7fSwgaSA9IDBcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBrZXkyID0gdm5vZGUua2V5XG5cdFx0XHRcdGlmIChrZXkyICE9IG51bGwpIG1hcFtrZXkyXSA9IGlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cdGZ1bmN0aW9uIHRvRnJhZ21lbnQodm5vZGUpIHtcblx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZVxuXHRcdGlmIChjb3VudDAgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudDAgPiAwKSB7XG5cdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdGZyYWdtZW50Lmluc2VydEJlZm9yZShkb20sIGZyYWdtZW50LmZpcnN0Q2hpbGQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJhZ21lbnRcblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gdm5vZGUuZG9tXG5cdH1cblx0ZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcodm5vZGVzLCBpLCBuZXh0U2libGluZykge1xuXHRcdGZvciAoOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgdm5vZGVzW2ldLmRvbSAhPSBudWxsKSByZXR1cm4gdm5vZGVzW2ldLmRvbVxuXHRcdH1cblx0XHRyZXR1cm4gbmV4dFNpYmxpbmdcblx0fVxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cdGZ1bmN0aW9uIHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0aWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnRhZyA9PT0gXCI8XCIpIHtcblx0XHRcdHZhciBjb250ZW50ID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5cblx0XHRcdGlmICh2bm9kZS5kb20uaW5uZXJIVE1MICE9PSBjb250ZW50KSB2bm9kZS5kb20uaW5uZXJIVE1MID0gY29udGVudFxuXHRcdH1cblx0XHRlbHNlIGlmICh2bm9kZS50ZXh0ICE9IG51bGwgfHwgY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggIT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG5vZGUgb2YgYSBjb250ZW50ZWRpdGFibGUgbXVzdCBiZSB0cnVzdGVkXCIpXG5cdH1cblx0Ly9yZW1vdmVcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZXModm5vZGVzLCBzdGFydCwgZW5kLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnNraXApIHZub2RlLnNraXAgPSBmYWxzZVxuXHRcdFx0XHRlbHNlIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUodm5vZGUsIGNvbnRleHQpIHtcblx0XHR2YXIgZXhwZWN0ZWQgPSAxLCBjYWxsZWQgPSAwXG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0XHRpZiAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0ZXhwZWN0ZWQrK1xuXHRcdFx0XHRyZXN1bHQudGhlbihjb250aW51YXRpb24sIGNvbnRpbnVhdGlvbilcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnRpbnVhdGlvbigpXG5cdFx0ZnVuY3Rpb24gY29udGludWF0aW9uKCkge1xuXHRcdFx0aWYgKCsrY2FsbGVkID09PSBleHBlY3RlZCkge1xuXHRcdFx0XHRvbnJlbW92ZSh2bm9kZSlcblx0XHRcdFx0aWYgKHZub2RlLmRvbSkge1xuXHRcdFx0XHRcdHZhciBjb3VudDAgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQwID4gMSkge1xuXHRcdFx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHRcdFx0d2hpbGUgKC0tY291bnQwKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKGRvbS5uZXh0U2libGluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlTm9kZUZyb21ET00odm5vZGUuZG9tKVxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICE9IG51bGwgJiYgdm5vZGUuZG9tU2l6ZSA9PSBudWxsICYmICFoYXNJbnRlZ3JhdGlvbk1ldGhvZHModm5vZGUuYXR0cnMpICYmIHR5cGVvZiB2bm9kZS50YWcgPT09IFwic3RyaW5nXCIpIHsgLy9UT0RPIHRlc3QgY3VzdG9tIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnRleHQucG9vbCkgY29udGV4dC5wb29sID0gW3Zub2RlXVxuXHRcdFx0XHRcdFx0ZWxzZSBjb250ZXh0LnBvb2wucHVzaCh2bm9kZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21ET00obm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcblx0XHRpZiAocGFyZW50ICE9IG51bGwpIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuXHR9XG5cdGZ1bmN0aW9uIG9ucmVtb3ZlKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmF0dHJzICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5hdHRycy5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS5fc3RhdGUub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuX3N0YXRlLm9ucmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRcdGlmIChjaGlsZCAhPSBudWxsKSBvbnJlbW92ZShjaGlsZClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2F0dHJzMlxuXHRmdW5jdGlvbiBzZXRBdHRycyh2bm9kZSwgYXR0cnMyLCBucykge1xuXHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRzZXRBdHRyKHZub2RlLCBrZXkyLCBudWxsLCBhdHRyczJba2V5Ml0sIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBzZXRBdHRyKHZub2RlLCBrZXkyLCBvbGQsIHZhbHVlLCBucykge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0aWYgKGtleTIgPT09IFwia2V5XCIgfHwga2V5MiA9PT0gXCJpc1wiIHx8IChvbGQgPT09IHZhbHVlICYmICFpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGtleTIpKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IGlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkyLmluZGV4T2YoXCI6XCIpXG5cdFx0aWYgKG5zTGFzdEluZGV4ID4gLTEgJiYga2V5Mi5zdWJzdHIoMCwgbnNMYXN0SW5kZXgpID09PSBcInhsaW5rXCIpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIGtleTIuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleTJbMF0gPT09IFwib1wiICYmIGtleTJbMV0gPT09IFwiblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5MiA9PT0gXCJzdHlsZVwiKSB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgaW4gZWxlbWVudCAmJiAhaXNBdHRyaWJ1dGUoa2V5MikgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0aWYgKGtleTIgPT09IFwidmFsdWVcIikge1xuXHRcdFx0XHR2YXIgbm9ybWFsaXplZDAgPSBcIlwiICsgdmFsdWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbXBsaWNpdC1jb2VyY2lvblxuXHRcdFx0XHQvL3NldHRpbmcgaW5wdXRbdmFsdWVdIHRvIHNhbWUgdmFsdWUgYnkgdHlwaW5nIG9uIGZvY3VzZWQgZWxlbWVudCBtb3ZlcyBjdXJzb3IgdG8gZW5kIGluIENocm9tZVxuXHRcdFx0XHRpZiAoKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiIHx8IHZub2RlLnRhZyA9PT0gXCJ0ZXh0YXJlYVwiKSAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQwICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0Ly9zZXR0aW5nIHNlbGVjdFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlLmRvbS5zZWxlY3RlZEluZGV4ID09PSAtMSAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvbGQgIT09IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vc2V0dGluZyBvcHRpb25bdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwib3B0aW9uXCIgJiYgb2xkICE9IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCkgcmV0dXJuXG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB5b3UgYXNzaWduIGFuIGlucHV0IHR5cGUxIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3IwIHdpbGwgb2NjdXIuXG5cdFx0XHRpZiAodm5vZGUudGFnID09PSBcImlucHV0XCIgJiYga2V5MiA9PT0gXCJ0eXBlXCIpIHtcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXkyXSA9IHZhbHVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0aWYgKHZhbHVlKSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyLCBcIlwiKVxuXHRcdFx0XHRlbHNlIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleTIpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIgPT09IFwiY2xhc3NOYW1lXCIgPyBcImNsYXNzXCIgOiBrZXkyLCB2YWx1ZSlcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0TGF0ZUF0dHJzKHZub2RlKSB7XG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0aWYgKFwidmFsdWVcIiBpbiBhdHRyczIpIHNldEF0dHIodm5vZGUsIFwidmFsdWVcIiwgbnVsbCwgYXR0cnMyLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCwgYXR0cnMyLnNlbGVjdGVkSW5kZXgsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cnModm5vZGUsIG9sZCwgYXR0cnMyLCBucykge1xuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBhdHRyczIpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5Miwgb2xkICYmIG9sZFtrZXkyXSwgYXR0cnMyW2tleTJdLCBucylcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9sZCAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRpZiAoYXR0cnMyID09IG51bGwgfHwgIShrZXkyIGluIGF0dHJzMikpIHtcblx0XHRcdFx0XHRpZiAoa2V5MiA9PT0gXCJjbGFzc05hbWVcIikga2V5MiA9IFwiY2xhc3NcIlxuXHRcdFx0XHRcdGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5MikpIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZWxzZSBpZiAoa2V5MiAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwgYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcInZhbHVlXCIgfHwgYXR0ciA9PT0gXCJjaGVja2VkXCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZEluZGV4XCIgfHwgYXR0ciA9PT0gXCJzZWxlY3RlZFwiICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50XG5cdH1cblx0ZnVuY3Rpb24gaXNMaWZlY3ljbGVNZXRob2QoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcIm9uaW5pdFwiIHx8IGF0dHIgPT09IFwib25jcmVhdGVcIiB8fCBhdHRyID09PSBcIm9udXBkYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmVyZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JldXBkYXRlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0F0dHJpYnV0ZShhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwiaHJlZlwiIHx8IGF0dHIgPT09IFwibGlzdFwiIHx8IGF0dHIgPT09IFwiZm9ybVwiIHx8IGF0dHIgPT09IFwid2lkdGhcIiB8fCBhdHRyID09PSBcImhlaWdodFwiLy8gfHwgYXR0ciA9PT0gXCJ0eXBlXCJcblx0fVxuXHRmdW5jdGlvbiBpc0N1c3RvbUVsZW1lbnQodm5vZGUpe1xuXHRcdHJldHVybiB2bm9kZS5hdHRycy5pcyB8fCB2bm9kZS50YWcuaW5kZXhPZihcIi1cIikgPiAtMVxuXHR9XG5cdGZ1bmN0aW9uIGhhc0ludGVncmF0aW9uTWV0aG9kcyhzb3VyY2UpIHtcblx0XHRyZXR1cm4gc291cmNlICE9IG51bGwgJiYgKHNvdXJjZS5vbmNyZWF0ZSB8fCBzb3VyY2Uub251cGRhdGUgfHwgc291cmNlLm9uYmVmb3JlcmVtb3ZlIHx8IHNvdXJjZS5vbnJlbW92ZSlcblx0fVxuXHQvL3N0eWxlXG5cdGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgc3R5bGUpIHtcblx0XHRpZiAob2xkID09PSBzdHlsZSkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIiwgb2xkID0gbnVsbFxuXHRcdGlmIChzdHlsZSA9PSBudWxsKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0ZWxzZSBpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGQgPT09IFwic3RyaW5nXCIpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCJcblx0XHRcdGZvciAodmFyIGtleTIgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXkyXSA9IHN0eWxlW2tleTJdXG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkICE9IG51bGwgJiYgdHlwZW9mIG9sZCAhPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkyIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleTIgaW4gc3R5bGUpKSBlbGVtZW50LnN0eWxlW2tleTJdID0gXCJcIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB2bm9kZS5kb21cblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb25ldmVudCAhPT0gXCJmdW5jdGlvblwiID8gdmFsdWUgOiBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdmFsdWUuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0b25ldmVudC5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHRcdGlmIChrZXkyIGluIGVsZW1lbnQpIGVsZW1lbnRba2V5Ml0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleTIuc2xpY2UoMilcblx0XHRcdGlmICh2bm9kZS5ldmVudHMgPT09IHVuZGVmaW5lZCkgdm5vZGUuZXZlbnRzID0ge31cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gPT09IGNhbGxiYWNrKSByZXR1cm5cblx0XHRcdGlmICh2bm9kZS5ldmVudHNba2V5Ml0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2bm9kZS5ldmVudHNba2V5Ml0gPSBjYWxsYmFja1xuXHRcdFx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB2bm9kZS5ldmVudHNba2V5Ml0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2xpZmVjeWNsZVxuXHRmdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25pbml0ID09PSBcImZ1bmN0aW9uXCIpIHNvdXJjZS5vbmluaXQuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub25jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub25jcmVhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUxpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9udXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9udXBkYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiBzaG91bGROb3RVcGRhdGUodm5vZGUsIG9sZCkge1xuXHRcdHZhciBmb3JjZVZub2RlVXBkYXRlLCBmb3JjZUNvbXBvbmVudFVwZGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHR5cGVvZiB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZVZub2RlVXBkYXRlID0gdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAodHlwZW9mIHZub2RlLnRhZyAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlQ29tcG9uZW50VXBkYXRlID0gdm5vZGUuX3N0YXRlLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKCEoZm9yY2VWbm9kZVVwZGF0ZSA9PT0gdW5kZWZpbmVkICYmIGZvcmNlQ29tcG9uZW50VXBkYXRlID09PSB1bmRlZmluZWQpICYmICFmb3JjZVZub2RlVXBkYXRlICYmICFmb3JjZUNvbXBvbmVudFVwZGF0ZSkge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IG9sZC5pbnN0YW5jZVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gcmVuZGVyKGRvbSwgdm5vZGVzKSB7XG5cdFx0aWYgKCFkb20pIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgcGFzc2VkIHRvIG0ucm91dGUvbS5tb3VudC9tLnJlbmRlciBpcyBub3QgdW5kZWZpbmVkLlwiKVxuXHRcdHZhciBob29rcyA9IFtdXG5cdFx0dmFyIGFjdGl2ZSA9ICRkb2MuYWN0aXZlRWxlbWVudFxuXHRcdHZhciBuYW1lc3BhY2UgPSBkb20ubmFtZXNwYWNlVVJJXG5cdFx0Ly8gRmlyc3QgdGltZTAgcmVuZGVyaW5nIGludG8gYSBub2RlIGNsZWFycyBpdCBvdXRcblx0XHRpZiAoZG9tLnZub2RlcyA9PSBudWxsKSBkb20udGV4dENvbnRlbnQgPSBcIlwiXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHZub2RlcykpIHZub2RlcyA9IFt2bm9kZXNdXG5cdFx0dXBkYXRlTm9kZXMoZG9tLCBkb20udm5vZGVzLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbih2bm9kZXMpLCBmYWxzZSwgaG9va3MsIG51bGwsIG5hbWVzcGFjZSA9PT0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIgPyB1bmRlZmluZWQgOiBuYW1lc3BhY2UpXG5cdFx0ZG9tLnZub2RlcyA9IHZub2Rlc1xuXHRcdC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHJldHVybiBudWxsIGluIElFIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9hY3RpdmVFbGVtZW50XG5cdFx0aWYgKGFjdGl2ZSAhPSBudWxsICYmICRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIGhvb2tzW2ldKClcblx0fVxuXHRyZXR1cm4ge3JlbmRlcjogcmVuZGVyLCBzZXRFdmVudENhbGxiYWNrOiBzZXRFdmVudENhbGxiYWNrfVxufVxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2spIHtcblx0Ly82MGZwcyB0cmFuc2xhdGVzIHRvIDE2LjZtcywgcm91bmQgaXQgZG93biBzaW5jZSBzZXRUaW1lb3V0IHJlcXVpcmVzIGludFxuXHR2YXIgdGltZSA9IDE2XG5cdHZhciBsYXN0ID0gMCwgcGVuZGluZyA9IG51bGxcblx0dmFyIHRpbWVvdXQgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKVxuXHRcdGlmIChsYXN0ID09PSAwIHx8IG5vdyAtIGxhc3QgPj0gdGltZSkge1xuXHRcdFx0bGFzdCA9IG5vd1xuXHRcdFx0Y2FsbGJhY2soKVxuXHRcdH1cblx0XHRlbHNlIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG5cdFx0XHRwZW5kaW5nID0gdGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0cGVuZGluZyA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2soKVxuXHRcdFx0XHRsYXN0ID0gRGF0ZS5ub3coKVxuXHRcdFx0fSwgdGltZSAtIChub3cgLSBsYXN0KSlcblx0XHR9XG5cdH1cbn1cbnZhciBfMTEgPSBmdW5jdGlvbigkd2luZG93KSB7XG5cdHZhciByZW5kZXJTZXJ2aWNlID0gY29yZVJlbmRlcmVyKCR3aW5kb3cpXG5cdHJlbmRlclNlcnZpY2Uuc2V0RXZlbnRDYWxsYmFjayhmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUucmVkcmF3ID09PSBmYWxzZSkgZS5yZWRyYXcgPSB1bmRlZmluZWRcblx0XHRlbHNlIHJlZHJhdygpXG5cdH0pXG5cdHZhciBjYWxsYmFja3MgPSBbXVxuXHRmdW5jdGlvbiBzdWJzY3JpYmUoa2V5MSwgY2FsbGJhY2spIHtcblx0XHR1bnN1YnNjcmliZShrZXkxKVxuXHRcdGNhbGxiYWNrcy5wdXNoKGtleTEsIHRocm90dGxlKGNhbGxiYWNrKSlcblx0fVxuXHRmdW5jdGlvbiB1bnN1YnNjcmliZShrZXkxKSB7XG5cdFx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2Yoa2V5MSlcblx0XHRpZiAoaW5kZXggPiAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMilcblx0fVxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdGNhbGxiYWNrc1tpXSgpXG5cdFx0fVxuXHR9XG5cdHJldHVybiB7c3Vic2NyaWJlOiBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSwgcmVkcmF3OiByZWRyYXcsIHJlbmRlcjogcmVuZGVyU2VydmljZS5yZW5kZXJ9XG59XG52YXIgcmVkcmF3U2VydmljZSA9IF8xMSh3aW5kb3cpXG5yZXF1ZXN0U2VydmljZS5zZXRDb21wbGV0aW9uQ2FsbGJhY2socmVkcmF3U2VydmljZS5yZWRyYXcpXG52YXIgXzE2ID0gZnVuY3Rpb24ocmVkcmF3U2VydmljZTApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCBbXSlcblx0XHRcdHJlZHJhd1NlcnZpY2UwLnVuc3Vic2NyaWJlKHJvb3QpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNvbXBvbmVudC52aWV3ID09IG51bGwgJiYgdHlwZW9mIGNvbXBvbmVudCAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJtLm1vdW50KGVsZW1lbnQsIGNvbXBvbmVudCkgZXhwZWN0cyBhIGNvbXBvbmVudCwgbm90IGEgdm5vZGVcIilcblx0XHRcblx0XHR2YXIgcnVuMCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFZub2RlKGNvbXBvbmVudCkpXG5cdFx0fVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4wKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnJlZHJhdygpXG5cdH1cbn1cbm0ubW91bnQgPSBfMTYocmVkcmF3U2VydmljZSlcbnZhciBQcm9taXNlID0gUHJvbWlzZVBvbHlmaWxsXG52YXIgcGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRpZiAoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PSBudWxsKSByZXR1cm4ge31cblx0aWYgKHN0cmluZy5jaGFyQXQoMCkgPT09IFwiP1wiKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSlcblx0dmFyIGVudHJpZXMgPSBzdHJpbmcuc3BsaXQoXCImXCIpLCBkYXRhMCA9IHt9LCBjb3VudGVycyA9IHt9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBlbnRyeSA9IGVudHJpZXNbaV0uc3BsaXQoXCI9XCIpXG5cdFx0dmFyIGtleTUgPSBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMF0pXG5cdFx0dmFyIHZhbHVlID0gZW50cnkubGVuZ3RoID09PSAyID8gZGVjb2RlVVJJQ29tcG9uZW50KGVudHJ5WzFdKSA6IFwiXCJcblx0XHRpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWVcblx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlXG5cdFx0dmFyIGxldmVscyA9IGtleTUuc3BsaXQoL1xcXVxcWz98XFxbLylcblx0XHR2YXIgY3Vyc29yID0gZGF0YTBcblx0XHRpZiAoa2V5NS5pbmRleE9mKFwiW1wiKSA+IC0xKSBsZXZlbHMucG9wKClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzW2pdLCBuZXh0TGV2ZWwgPSBsZXZlbHNbaiArIDFdXG5cdFx0XHR2YXIgaXNOdW1iZXIgPSBuZXh0TGV2ZWwgPT0gXCJcIiB8fCAhaXNOYU4ocGFyc2VJbnQobmV4dExldmVsLCAxMCkpXG5cdFx0XHR2YXIgaXNWYWx1ZSA9IGogPT09IGxldmVscy5sZW5ndGggLSAxXG5cdFx0XHRpZiAobGV2ZWwgPT09IFwiXCIpIHtcblx0XHRcdFx0dmFyIGtleTUgPSBsZXZlbHMuc2xpY2UoMCwgaikuam9pbigpXG5cdFx0XHRcdGlmIChjb3VudGVyc1trZXk1XSA9PSBudWxsKSBjb3VudGVyc1trZXk1XSA9IDBcblx0XHRcdFx0bGV2ZWwgPSBjb3VudGVyc1trZXk1XSsrXG5cdFx0XHR9XG5cdFx0XHRpZiAoY3Vyc29yW2xldmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnNvcltsZXZlbF0gPSBpc1ZhbHVlID8gdmFsdWUgOiBpc051bWJlciA/IFtdIDoge31cblx0XHRcdH1cblx0XHRcdGN1cnNvciA9IGN1cnNvcltsZXZlbF1cblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGEwXG59XG52YXIgY29yZVJvdXRlciA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gdHlwZW9mICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPT09IFwiZnVuY3Rpb25cIlxuXHR2YXIgY2FsbEFzeW5jMCA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXRcblx0ZnVuY3Rpb24gbm9ybWFsaXplMShmcmFnbWVudDApIHtcblx0XHR2YXIgZGF0YSA9ICR3aW5kb3cubG9jYXRpb25bZnJhZ21lbnQwXS5yZXBsYWNlKC8oPzolW2EtZjg5XVthLWYwLTldKSsvZ2ltLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0aWYgKGZyYWdtZW50MCA9PT0gXCJwYXRobmFtZVwiICYmIGRhdGFbMF0gIT09IFwiL1wiKSBkYXRhID0gXCIvXCIgKyBkYXRhXG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXHR2YXIgYXN5bmNJZFxuXHRmdW5jdGlvbiBkZWJvdW5jZUFzeW5jKGNhbGxiYWNrMCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChhc3luY0lkICE9IG51bGwpIHJldHVyblxuXHRcdFx0YXN5bmNJZCA9IGNhbGxBc3luYzAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFzeW5jSWQgPSBudWxsXG5cdFx0XHRcdGNhbGxiYWNrMCgpXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSkge1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKVxuXHRcdHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpXG5cdFx0dmFyIHBhdGhFbmQgPSBxdWVyeUluZGV4ID4gLTEgPyBxdWVyeUluZGV4IDogaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBxdWVyeUVuZCA9IGhhc2hJbmRleCA+IC0xID8gaGFzaEluZGV4IDogcGF0aC5sZW5ndGhcblx0XHRcdHZhciBxdWVyeVBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSwgcXVlcnlFbmQpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBxdWVyeVBhcmFtcykgcXVlcnlEYXRhW2tleTRdID0gcXVlcnlQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0aWYgKGhhc2hJbmRleCA+IC0xKSB7XG5cdFx0XHR2YXIgaGFzaFBhcmFtcyA9IHBhcnNlUXVlcnlTdHJpbmcocGF0aC5zbGljZShoYXNoSW5kZXggKyAxKSlcblx0XHRcdGZvciAodmFyIGtleTQgaW4gaGFzaFBhcmFtcykgaGFzaERhdGFba2V5NF0gPSBoYXNoUGFyYW1zW2tleTRdXG5cdFx0fVxuXHRcdHJldHVybiBwYXRoLnNsaWNlKDAsIHBhdGhFbmQpXG5cdH1cblx0dmFyIHJvdXRlciA9IHtwcmVmaXg6IFwiIyFcIn1cblx0cm91dGVyLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZTIgPSByb3V0ZXIucHJlZml4LmNoYXJBdCgwKVxuXHRcdHN3aXRjaCAodHlwZTIpIHtcblx0XHRcdGNhc2UgXCIjXCI6IHJldHVybiBub3JtYWxpemUxKFwiaGFzaFwiKS5zbGljZShyb3V0ZXIucHJlZml4Lmxlbmd0aClcblx0XHRcdGNhc2UgXCI/XCI6IHJldHVybiBub3JtYWxpemUxKFwic2VhcmNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gbm9ybWFsaXplMShcInBhdGhuYW1lXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKSArIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikgKyBub3JtYWxpemUxKFwiaGFzaFwiKVxuXHRcdH1cblx0fVxuXHRyb3V0ZXIuc2V0UGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHR2YXIgcXVlcnlEYXRhID0ge30sIGhhc2hEYXRhID0ge31cblx0XHRwYXRoID0gcGFyc2VQYXRoKHBhdGgsIHF1ZXJ5RGF0YSwgaGFzaERhdGEpXG5cdFx0aWYgKGRhdGEgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBkYXRhKSBxdWVyeURhdGFba2V5NF0gPSBkYXRhW2tleTRdXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKC86KFteXFwvXSspL2csIGZ1bmN0aW9uKG1hdGNoMiwgdG9rZW4pIHtcblx0XHRcdFx0ZGVsZXRlIHF1ZXJ5RGF0YVt0b2tlbl1cblx0XHRcdFx0cmV0dXJuIGRhdGFbdG9rZW5dXG5cdFx0XHR9KVxuXHRcdH1cblx0XHR2YXIgcXVlcnkgPSBidWlsZFF1ZXJ5U3RyaW5nKHF1ZXJ5RGF0YSlcblx0XHRpZiAocXVlcnkpIHBhdGggKz0gXCI/XCIgKyBxdWVyeVxuXHRcdHZhciBoYXNoID0gYnVpbGRRdWVyeVN0cmluZyhoYXNoRGF0YSlcblx0XHRpZiAoaGFzaCkgcGF0aCArPSBcIiNcIiArIGhhc2hcblx0XHRpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnN0YXRlIDogbnVsbFxuXHRcdFx0dmFyIHRpdGxlID0gb3B0aW9ucyA/IG9wdGlvbnMudGl0bGUgOiBudWxsXG5cdFx0XHQkd2luZG93Lm9ucG9wc3RhdGUoKVxuXHRcdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZXBsYWNlKSAkd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgcm91dGVyLnByZWZpeCArIHBhdGgpXG5cdFx0XHRlbHNlICR3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHR9XG5cdFx0ZWxzZSAkd2luZG93LmxvY2F0aW9uLmhyZWYgPSByb3V0ZXIucHJlZml4ICsgcGF0aFxuXHR9XG5cdHJvdXRlci5kZWZpbmVSb3V0ZXMgPSBmdW5jdGlvbihyb3V0ZXMsIHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGZ1bmN0aW9uIHJlc29sdmVSb3V0ZSgpIHtcblx0XHRcdHZhciBwYXRoID0gcm91dGVyLmdldFBhdGgoKVxuXHRcdFx0dmFyIHBhcmFtcyA9IHt9XG5cdFx0XHR2YXIgcGF0aG5hbWUgPSBwYXJzZVBhdGgocGF0aCwgcGFyYW1zLCBwYXJhbXMpXG5cdFx0XHR2YXIgc3RhdGUgPSAkd2luZG93Lmhpc3Rvcnkuc3RhdGVcblx0XHRcdGlmIChzdGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAodmFyIGsgaW4gc3RhdGUpIHBhcmFtc1trXSA9IHN0YXRlW2tdXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciByb3V0ZTAgaW4gcm91dGVzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIl5cIiArIHJvdXRlMC5yZXBsYWNlKC86W15cXC9dKz9cXC57M30vZywgXCIoLio/KVwiKS5yZXBsYWNlKC86W15cXC9dKy9nLCBcIihbXlxcXFwvXSspXCIpICsgXCJcXC8/JFwiKVxuXHRcdFx0XHRpZiAobWF0Y2hlci50ZXN0KHBhdGhuYW1lKSkge1xuXHRcdFx0XHRcdHBhdGhuYW1lLnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5cyA9IHJvdXRlMC5tYXRjaCgvOlteXFwvXSsvZykgfHwgW11cblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgLTIpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0cGFyYW1zW2tleXNbaV0ucmVwbGFjZSgvOnxcXC4vZywgXCJcIildID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlc1tpXSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUocm91dGVzW3JvdXRlMF0sIHBhcmFtcywgcGF0aCwgcm91dGUwKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlamVjdChwYXRoLCBwYXJhbXMpXG5cdFx0fVxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkgJHdpbmRvdy5vbnBvcHN0YXRlID0gZGVib3VuY2VBc3luYyhyZXNvbHZlUm91dGUpXG5cdFx0ZWxzZSBpZiAocm91dGVyLnByZWZpeC5jaGFyQXQoMCkgPT09IFwiI1wiKSAkd2luZG93Lm9uaGFzaGNoYW5nZSA9IHJlc29sdmVSb3V0ZVxuXHRcdHJlc29sdmVSb3V0ZSgpXG5cdH1cblx0cmV0dXJuIHJvdXRlclxufVxudmFyIF8yMCA9IGZ1bmN0aW9uKCR3aW5kb3csIHJlZHJhd1NlcnZpY2UwKSB7XG5cdHZhciByb3V0ZVNlcnZpY2UgPSBjb3JlUm91dGVyKCR3aW5kb3cpXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHYpIHtyZXR1cm4gdn1cblx0dmFyIHJlbmRlcjEsIGNvbXBvbmVudCwgYXR0cnMzLCBjdXJyZW50UGF0aCwgbGFzdFVwZGF0ZVxuXHR2YXIgcm91dGUgPSBmdW5jdGlvbihyb290LCBkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuXHRcdGlmIChyb290ID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGUgRE9NIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIGBtLnJvdXRlYCBpcyBub3QgdW5kZWZpbmVkXCIpXG5cdFx0dmFyIHJ1bjEgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZW5kZXIxICE9IG51bGwpIHJlZHJhd1NlcnZpY2UwLnJlbmRlcihyb290LCByZW5kZXIxKFZub2RlKGNvbXBvbmVudCwgYXR0cnMzLmtleSwgYXR0cnMzKSkpXG5cdFx0fVxuXHRcdHZhciBiYWlsID0gZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0aWYgKHBhdGggIT09IGRlZmF1bHRSb3V0ZSkgcm91dGVTZXJ2aWNlLnNldFBhdGgoZGVmYXVsdFJvdXRlLCBudWxsLCB7cmVwbGFjZTogdHJ1ZX0pXG5cdFx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGRlZmF1bHQgcm91dGUgXCIgKyBkZWZhdWx0Um91dGUpXG5cdFx0fVxuXHRcdHJvdXRlU2VydmljZS5kZWZpbmVSb3V0ZXMocm91dGVzLCBmdW5jdGlvbihwYXlsb2FkLCBwYXJhbXMsIHBhdGgpIHtcblx0XHRcdHZhciB1cGRhdGUgPSBsYXN0VXBkYXRlID0gZnVuY3Rpb24ocm91dGVSZXNvbHZlciwgY29tcCkge1xuXHRcdFx0XHRpZiAodXBkYXRlICE9PSBsYXN0VXBkYXRlKSByZXR1cm5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcCAhPSBudWxsICYmICh0eXBlb2YgY29tcC52aWV3ID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGNvbXAgPT09IFwiZnVuY3Rpb25cIik/IGNvbXAgOiBcImRpdlwiXG5cdFx0XHRcdGF0dHJzMyA9IHBhcmFtcywgY3VycmVudFBhdGggPSBwYXRoLCBsYXN0VXBkYXRlID0gbnVsbFxuXHRcdFx0XHRyZW5kZXIxID0gKHJvdXRlUmVzb2x2ZXIucmVuZGVyIHx8IGlkZW50aXR5KS5iaW5kKHJvdXRlUmVzb2x2ZXIpXG5cdFx0XHRcdHJ1bjEoKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBheWxvYWQudmlldyB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJmdW5jdGlvblwiKSB1cGRhdGUoe30sIHBheWxvYWQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0aWYgKHBheWxvYWQub25tYXRjaCkge1xuXHRcdFx0XHRcdFByb21pc2UucmVzb2x2ZShwYXlsb2FkLm9ubWF0Y2gocGFyYW1zLCBwYXRoKSkudGhlbihmdW5jdGlvbihyZXNvbHZlZCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKHBheWxvYWQsIHJlc29sdmVkKVxuXHRcdFx0XHRcdH0sIGJhaWwpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB1cGRhdGUocGF5bG9hZCwgXCJkaXZcIilcblx0XHRcdH1cblx0XHR9LCBiYWlsKVxuXHRcdHJlZHJhd1NlcnZpY2UwLnN1YnNjcmliZShyb290LCBydW4xKVxuXHR9XG5cdHJvdXRlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcblx0XHRpZiAobGFzdFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXHRcdFx0b3B0aW9ucy5yZXBsYWNlID0gdHJ1ZVxuXHRcdH1cblx0XHRsYXN0VXBkYXRlID0gbnVsbFxuXHRcdHJvdXRlU2VydmljZS5zZXRQYXRoKHBhdGgsIGRhdGEsIG9wdGlvbnMpXG5cdH1cblx0cm91dGUuZ2V0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIGN1cnJlbnRQYXRofVxuXHRyb3V0ZS5wcmVmaXggPSBmdW5jdGlvbihwcmVmaXgwKSB7cm91dGVTZXJ2aWNlLnByZWZpeCA9IHByZWZpeDB9XG5cdHJvdXRlLmxpbmsgPSBmdW5jdGlvbih2bm9kZTEpIHtcblx0XHR2bm9kZTEuZG9tLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgcm91dGVTZXJ2aWNlLnByZWZpeCArIHZub2RlMS5hdHRycy5ocmVmKVxuXHRcdHZub2RlMS5kb20ub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS53aGljaCA9PT0gMikgcmV0dXJuXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KClcblx0XHRcdGUucmVkcmF3ID0gZmFsc2Vcblx0XHRcdHZhciBocmVmID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpXG5cdFx0XHRpZiAoaHJlZi5pbmRleE9mKHJvdXRlU2VydmljZS5wcmVmaXgpID09PSAwKSBocmVmID0gaHJlZi5zbGljZShyb3V0ZVNlcnZpY2UucHJlZml4Lmxlbmd0aClcblx0XHRcdHJvdXRlLnNldChocmVmLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0XHR9XG5cdH1cblx0cm91dGUucGFyYW0gPSBmdW5jdGlvbihrZXkzKSB7XG5cdFx0aWYodHlwZW9mIGF0dHJzMyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Yga2V5MyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGF0dHJzM1trZXkzXVxuXHRcdHJldHVybiBhdHRyczNcblx0fVxuXHRyZXR1cm4gcm91dGVcbn1cbm0ucm91dGUgPSBfMjAod2luZG93LCByZWRyYXdTZXJ2aWNlKVxubS53aXRoQXR0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lLCBjYWxsYmFjazEsIGNvbnRleHQpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0XHRjYWxsYmFjazEuY2FsbChjb250ZXh0IHx8IHRoaXMsIGF0dHJOYW1lIGluIGUuY3VycmVudFRhcmdldCA/IGUuY3VycmVudFRhcmdldFthdHRyTmFtZV0gOiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSlcblx0fVxufVxudmFyIF8yOCA9IGNvcmVSZW5kZXJlcih3aW5kb3cpXG5tLnJlbmRlciA9IF8yOC5yZW5kZXJcbm0ucmVkcmF3ID0gcmVkcmF3U2VydmljZS5yZWRyYXdcbm0ucmVxdWVzdCA9IHJlcXVlc3RTZXJ2aWNlLnJlcXVlc3Rcbm0uanNvbnAgPSByZXF1ZXN0U2VydmljZS5qc29ucFxubS5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZ1xubS5idWlsZFF1ZXJ5U3RyaW5nID0gYnVpbGRRdWVyeVN0cmluZ1xubS52ZXJzaW9uID0gXCIxLjEuNlwiXG5tLnZub2RlID0gVm5vZGVcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGVbXCJleHBvcnRzXCJdID0gbVxuZWxzZSB3aW5kb3cubSA9IG1cbn0oKSk7IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZW5kZXIvcmVuZGVyXCIpKHdpbmRvdylcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBWbm9kZSA9IHJlcXVpcmUoXCIuLi9yZW5kZXIvdm5vZGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdHRycywgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRycy5rZXksIGF0dHJzLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxuXG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqZWN0KSB7XG5cdGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChoYXNPd24uY2FsbChvYmplY3QsIGtleSkpIHJldHVybiBmYWxzZVxuXHRyZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuXG5mdW5jdGlvbiBleGVjU2VsZWN0b3Ioc3RhdGUsIGF0dHJzLCBjaGlsZHJlbikge1xuXHR2YXIgaGFzQXR0cnMgPSBmYWxzZSwgY2hpbGRMaXN0LCB0ZXh0XG5cdHZhciBjbGFzc05hbWUgPSBhdHRycy5jbGFzc05hbWUgfHwgYXR0cnMuY2xhc3NcblxuXHRpZiAoIWlzRW1wdHkoc3RhdGUuYXR0cnMpICYmICFpc0VtcHR5KGF0dHJzKSkge1xuXHRcdHZhciBuZXdBdHRycyA9IHt9XG5cblx0XHRmb3IodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0aWYgKGhhc093bi5jYWxsKGF0dHJzLCBrZXkpKSB7XG5cdFx0XHRcdG5ld0F0dHJzW2tleV0gPSBhdHRyc1trZXldXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXR0cnMgPSBuZXdBdHRyc1xuXHR9XG5cblx0Zm9yICh2YXIga2V5IGluIHN0YXRlLmF0dHJzKSB7XG5cdFx0aWYgKGhhc093bi5jYWxsKHN0YXRlLmF0dHJzLCBrZXkpKSB7XG5cdFx0XHRhdHRyc1trZXldID0gc3RhdGUuYXR0cnNba2V5XVxuXHRcdH1cblx0fVxuXG5cdGlmIChjbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChhdHRycy5jbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhdHRycy5jbGFzcyA9IHVuZGVmaW5lZFxuXHRcdFx0YXR0cnMuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG5cdFx0fVxuXG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXG5cdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChhdHRycywga2V5KSAmJiBrZXkgIT09IFwia2V5XCIpIHtcblx0XHRcdGhhc0F0dHJzID0gdHJ1ZVxuXHRcdFx0YnJlYWtcblx0XHR9XG5cdH1cblxuXHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdICE9IG51bGwgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIiNcIikge1xuXHRcdHRleHQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkTGlzdCA9IGNoaWxkcmVuXG5cdH1cblxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cblxuZnVuY3Rpb24gaHlwZXJzY3JpcHQoc2VsZWN0b3IpIHtcblx0Ly8gQmVjYXVzZSBzbG9wcHkgbW9kZSBzdWNrc1xuXHR2YXIgYXR0cnMgPSBhcmd1bWVudHNbMV0sIHN0YXJ0ID0gMiwgY2hpbGRyZW5cblxuXHRpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNlbGVjdG9yLnZpZXcgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHRocm93IEVycm9yKFwiVGhlIHNlbGVjdG9yIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgY29tcG9uZW50LlwiKTtcblx0fVxuXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cblx0aWYgKGF0dHJzID09IG51bGwpIHtcblx0XHRhdHRycyA9IHt9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzICE9PSBcIm9iamVjdFwiIHx8IGF0dHJzLnRhZyAhPSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHRcdHN0YXJ0ID0gMVxuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IHN0YXJ0ICsgMSkge1xuXHRcdGNoaWxkcmVuID0gYXJndW1lbnRzW3N0YXJ0XVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIGNoaWxkcmVuID0gW2NoaWxkcmVuXVxuXHR9IGVsc2Uge1xuXHRcdGNoaWxkcmVuID0gW11cblx0XHR3aGlsZSAoc3RhcnQgPCBhcmd1bWVudHMubGVuZ3RoKSBjaGlsZHJlbi5wdXNoKGFyZ3VtZW50c1tzdGFydCsrXSlcblx0fVxuXG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cblx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHJldHVybiBleGVjU2VsZWN0b3IoY2FjaGVkLCBhdHRycywgbm9ybWFsaXplZClcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gVm5vZGUoc2VsZWN0b3IsIGF0dHJzLmtleSwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBlcnNjcmlwdFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyICRkb2MgPSAkd2luZG93LmRvY3VtZW50XG5cdHZhciAkZW1wdHlGcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cblx0dmFyIG9uZXZlbnRcblx0ZnVuY3Rpb24gc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaykge3JldHVybiBvbmV2ZW50ID0gY2FsbGJhY2t9XG5cblx0ZnVuY3Rpb24gZ2V0TmFtZVNwYWNlKHZub2RlKSB7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzICYmIHZub2RlLmF0dHJzLnhtbG5zIHx8IG5hbWVTcGFjZVt2bm9kZS50YWddXG5cdH1cblxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2ggPSB2bm9kZS5jaGlsZHJlbi5tYXRjaCgvXlxccyo/PChcXHcrKS9pbSkgfHwgW11cblx0XHR2YXIgcGFyZW50MSA9IHtjYXB0aW9uOiBcInRhYmxlXCIsIHRoZWFkOiBcInRhYmxlXCIsIHRib2R5OiBcInRhYmxlXCIsIHRmb290OiBcInRhYmxlXCIsIHRyOiBcInRib2R5XCIsIHRoOiBcInRyXCIsIHRkOiBcInRyXCIsIGNvbGdyb3VwOiBcInRhYmxlXCIsIGNvbDogXCJjb2xncm91cFwifVttYXRjaFsxXV0gfHwgXCJkaXZcIlxuXHRcdHZhciB0ZW1wID0gJGRvYy5jcmVhdGVFbGVtZW50KHBhcmVudDEpXG5cblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzID0gdm5vZGUuYXR0cnNcblx0XHR2YXIgaXMgPSBhdHRycyAmJiBhdHRycy5pc1xuXG5cdFx0bnMgPSBnZXROYW1lU3BhY2Uodm5vZGUpIHx8IG5zXG5cblx0XHR2YXIgZWxlbWVudCA9IG5zID9cblx0XHRcdGlzID8gJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywge2lzOiBpc30pIDogJGRvYy5jcmVhdGVFbGVtZW50TlMobnMsIHRhZykgOlxuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnQodGFnKVxuXHRcdHZub2RlLmRvbSA9IGVsZW1lbnRcblxuXHRcdGlmIChhdHRycyAhPSBudWxsKSB7XG5cdFx0XHRzZXRBdHRycyh2bm9kZSwgYXR0cnMsIG5zKVxuXHRcdH1cblxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKHZub2RlLnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodm5vZGUudGV4dCAhPT0gXCJcIikgZWxlbWVudC50ZXh0Q29udGVudCA9IHZub2RlLnRleHRcblx0XHRcdFx0ZWxzZSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdH1cblx0XHRcdGlmICh2bm9kZS5jaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRcdGNyZWF0ZU5vZGVzKGVsZW1lbnQsIGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGgsIGhvb2tzLCBudWxsLCBucylcblx0XHRcdFx0c2V0TGF0ZUF0dHJzKHZub2RlKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKSB7XG5cdFx0dmFyIHNlbnRpbmVsXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcudmlldyA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IE9iamVjdC5jcmVhdGUodm5vZGUudGFnKVxuXHRcdFx0c2VudGluZWwgPSB2bm9kZS5zdGF0ZS52aWV3XG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSB2b2lkIDBcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUudGFnXG5cdFx0XHRpZiAoc2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgIT0gbnVsbCkgcmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IHRydWVcblx0XHRcdHZub2RlLnN0YXRlID0gKHZub2RlLnRhZy5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUudGFnLnByb3RvdHlwZS52aWV3ID09PSBcImZ1bmN0aW9uXCIpID8gbmV3IHZub2RlLnRhZyh2bm9kZSkgOiB2bm9kZS50YWcodm5vZGUpXG5cdFx0fVxuXHRcdHZub2RlLl9zdGF0ZSA9IHZub2RlLnN0YXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRpbml0TGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdHZub2RlLmluc3RhbmNlID0gVm5vZGUubm9ybWFsaXplKHZub2RlLl9zdGF0ZS52aWV3LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkID0gbnVsbFxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaG9va3MpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuZG9tICE9IG51bGwgPyB2bm9kZS5pbnN0YW5jZS5kb21TaXplIDogMFxuXHRcdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGVsZW1lbnQsIG5leHRTaWJsaW5nKVxuXHRcdFx0cmV0dXJuIGVsZW1lbnRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb21TaXplID0gMFxuXHRcdFx0cmV0dXJuICRlbXB0eUZyYWdtZW50XG5cdFx0fVxuXHR9XG5cblx0Ly91cGRhdGVcblx0ZnVuY3Rpb24gdXBkYXRlTm9kZXMocGFyZW50LCBvbGQsIHZub2RlcywgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKSB7XG5cdFx0aWYgKG9sZCA9PT0gdm5vZGVzIHx8IG9sZCA9PSBudWxsICYmIHZub2RlcyA9PSBudWxsKSByZXR1cm5cblx0XHRlbHNlIGlmIChvbGQgPT0gbnVsbCkgY3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIDAsIHZub2Rlcy5sZW5ndGgsIGhvb2tzLCBuZXh0U2libGluZywgbnMpXG5cdFx0ZWxzZSBpZiAodm5vZGVzID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgMCwgb2xkLmxlbmd0aCwgdm5vZGVzKVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC5sZW5ndGggPT09IHZub2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlzVW5rZXllZCA9IGZhbHNlXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIG9sZFtpXSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpc1Vua2V5ZWQgPSB2bm9kZXNbaV0ua2V5ID09IG51bGwgJiYgb2xkW2ldLmtleSA9PSBudWxsXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNVbmtleWVkKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChvbGRbaV0gPT09IHZub2Rlc1tpXSkgY29udGludWVcblx0XHRcdFx0XHRcdGVsc2UgaWYgKG9sZFtpXSA9PSBudWxsICYmIHZub2Rlc1tpXSAhPSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGVzW2ldLCBob29rcywgbnMsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSlcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHZub2Rlc1tpXSA9PSBudWxsKSByZW1vdmVOb2RlcyhvbGQsIGksIGkgKyAxLCB2bm9kZXMpXG5cdFx0XHRcdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGRbaV0sIHZub2Rlc1tpXSwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgaSArIDEsIG5leHRTaWJsaW5nKSwgcmVjeWNsaW5nLCBucylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlY3ljbGluZyA9IHJlY3ljbGluZyB8fCBpc1JlY3ljbGFibGUob2xkLCB2bm9kZXMpXG5cdFx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRcdHZhciBwb29sID0gb2xkLnBvb2xcblx0XHRcdFx0b2xkID0gb2xkLmNvbmNhdChvbGQucG9vbClcblx0XHRcdH1cblxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblxuXHRcdGlmICh2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikge1xuXHRcdFx0aWYgKHZub2RlLmF0dHJzID09IG51bGwpIHZub2RlLmF0dHJzID0ge31cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuYXR0cnMudmFsdWUgPSB2bm9kZS50ZXh0IC8vRklYTUUgaGFuZGxlIG11bHRpcGxlIGNoaWxkcmVuXG5cdFx0XHRcdHZub2RlLnRleHQgPSB1bmRlZmluZWRcblx0XHRcdH1cblx0XHR9XG5cdFx0dXBkYXRlQXR0cnModm5vZGUsIG9sZC5hdHRycywgdm5vZGUuYXR0cnMsIG5zKVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsICYmIHZub2RlLmF0dHJzLmNvbnRlbnRlZGl0YWJsZSAhPSBudWxsKSB7XG5cdFx0XHRzZXRDb250ZW50RWRpdGFibGUodm5vZGUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPSBudWxsICYmIHZub2RlLnRleHQgIT09IFwiXCIpIHtcblx0XHRcdGlmIChvbGQudGV4dC50b1N0cmluZygpICE9PSB2bm9kZS50ZXh0LnRvU3RyaW5nKCkpIG9sZC5kb20uZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2bm9kZS50ZXh0XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKG9sZC50ZXh0ICE9IG51bGwpIG9sZC5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZC50ZXh0LCB1bmRlZmluZWQsIG9sZC5kb20uZmlyc3RDaGlsZCldXG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB2bm9kZS5jaGlsZHJlbiA9IFtWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZub2RlLnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKV1cblx0XHRcdHVwZGF0ZU5vZGVzKGVsZW1lbnQsIG9sZC5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHJlY3ljbGluZywgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpIHtcblx0XHRpZiAocmVjeWNsaW5nKSB7XG5cdFx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBob29rcylcblx0XHR9IGVsc2Uge1xuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBWbm9kZS5ub3JtYWxpemUodm5vZGUuX3N0YXRlLnZpZXcuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHRcdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR9XG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdGlmIChvbGQuaW5zdGFuY2UgPT0gbnVsbCkgY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLmluc3RhbmNlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKVxuXHRcdFx0ZWxzZSB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLmluc3RhbmNlLCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0dm5vZGUuZG9tID0gdm5vZGUuaW5zdGFuY2UuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZVxuXHRcdH1cblx0XHRlbHNlIGlmIChvbGQuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQuaW5zdGFuY2UsIG51bGwpXG5cdFx0XHR2bm9kZS5kb20gPSB1bmRlZmluZWRcblx0XHRcdHZub2RlLmRvbVNpemUgPSAwXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tID0gb2xkLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IG9sZC5kb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcykge1xuXHRcdGlmIChvbGQucG9vbCAhPSBudWxsICYmIE1hdGguYWJzKG9sZC5wb29sLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpIDw9IE1hdGguYWJzKG9sZC5sZW5ndGggLSB2bm9kZXMubGVuZ3RoKSkge1xuXHRcdFx0dmFyIG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkWzBdICYmIG9sZFswXS5jaGlsZHJlbiAmJiBvbGRbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdHZhciBwb29sQ2hpbGRyZW5MZW5ndGggPSBvbGQucG9vbFswXSAmJiBvbGQucG9vbFswXS5jaGlsZHJlbiAmJiBvbGQucG9vbFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHZub2Rlc0NoaWxkcmVuTGVuZ3RoID0gdm5vZGVzWzBdICYmIHZub2Rlc1swXS5jaGlsZHJlbiAmJiB2bm9kZXNbMF0uY2hpbGRyZW4ubGVuZ3RoIHx8IDBcblx0XHRcdGlmIChNYXRoLmFicyhwb29sQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkgPD0gTWF0aC5hYnMob2xkQ2hpbGRyZW5MZW5ndGggLSB2bm9kZXNDaGlsZHJlbkxlbmd0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblx0ZnVuY3Rpb24gZ2V0S2V5TWFwKHZub2RlcywgZW5kKSB7XG5cdFx0dmFyIG1hcCA9IHt9LCBpID0gMFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHZhciB2bm9kZSA9IHZub2Rlc1tpXVxuXHRcdFx0aWYgKHZub2RlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGtleSA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5ICE9IG51bGwpIG1hcFtrZXldID0gaVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cblx0ZnVuY3Rpb24gdG9GcmFnbWVudCh2bm9kZSkge1xuXHRcdHZhciBjb3VudCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQgIT0gbnVsbCB8fCB2bm9kZS5kb20gPT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0XHRcdGlmIChjb3VudCA+IDApIHtcblx0XHRcdFx0dmFyIGRvbSA9IHZub2RlLmRvbVxuXHRcdFx0XHR3aGlsZSAoLS1jb3VudCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnROb2RlKHBhcmVudCwgZG9tLCBuZXh0U2libGluZykge1xuXHRcdGlmIChuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5wYXJlbnROb2RlKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9tKVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0Q29udGVudEVkaXRhYmxlKHZub2RlKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0udGFnID09PSBcIjxcIikge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjaGlsZHJlblswXS5jaGlsZHJlblxuXHRcdFx0aWYgKHZub2RlLmRvbS5pbm5lckhUTUwgIT09IGNvbnRlbnQpIHZub2RlLmRvbS5pbm5lckhUTUwgPSBjb250ZW50XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZub2RlLnRleHQgIT0gbnVsbCB8fCBjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgbm9kZSBvZiBhIGNvbnRlbnRlZGl0YWJsZSBtdXN0IGJlIHRydXN0ZWRcIilcblx0fVxuXG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQgPSB2bm9kZS5kb21TaXplIHx8IDFcblx0XHRcdFx0XHRpZiAoY291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1jb3VudCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUuX3N0YXRlLm9ucmVtb3ZlID09PSBcImZ1bmN0aW9uXCIpIHZub2RlLl9zdGF0ZS5vbnJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSBvbnJlbW92ZSh2bm9kZS5pbnN0YW5jZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvL2F0dHJzXG5cdGZ1bmN0aW9uIHNldEF0dHJzKHZub2RlLCBhdHRycywgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdHNldEF0dHIodm5vZGUsIGtleSwgbnVsbCwgYXR0cnNba2V5XSwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldEF0dHIodm5vZGUsIGtleSwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkgPT09IFwia2V5XCIgfHwga2V5ID09PSBcImlzXCIgfHwgKG9sZCA9PT0gdmFsdWUgJiYgIWlzRm9ybUF0dHJpYnV0ZSh2bm9kZSwga2V5KSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkpKSByZXR1cm5cblx0XHR2YXIgbnNMYXN0SW5kZXggPSBrZXkuaW5kZXhPZihcIjpcIilcblx0XHRpZiAobnNMYXN0SW5kZXggPiAtMSAmJiBrZXkuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkuc2xpY2UobnNMYXN0SW5kZXggKyAxKSwgdmFsdWUpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGtleVswXSA9PT0gXCJvXCIgJiYga2V5WzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHVwZGF0ZVN0eWxlKGVsZW1lbnQsIG9sZCwgdmFsdWUpXG5cdFx0ZWxzZSBpZiAoa2V5IGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleSkgJiYgbnMgPT09IHVuZGVmaW5lZCAmJiAhaXNDdXN0b21FbGVtZW50KHZub2RlKSkge1xuXHRcdFx0aWYgKGtleSA9PT0gXCJ2YWx1ZVwiKSB7XG5cdFx0XHRcdHZhciBub3JtYWxpemVkID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0Ly9zZXR0aW5nIHNlbGVjdFt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlLmRvbS5zZWxlY3RlZEluZGV4ID09PSAtMSAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvbGQgIT09IG51bGwgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkICYmIHZub2RlLmRvbSA9PT0gJGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9zZXR0aW5nIG9wdGlvblt2YWx1ZV0gdG8gc2FtZSB2YWx1ZSB3aGlsZSBoYXZpbmcgc2VsZWN0IG9wZW4gYmxpbmtzIHNlbGVjdCBkcm9wZG93biBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJvcHRpb25cIiAmJiBvbGQgIT0gbnVsbCAmJiB2bm9kZS5kb20udmFsdWUgPT09IG5vcm1hbGl6ZWQpIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRSAxMSB3aXRoIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiwgYW4gZXJyb3Igd2lsbCBvY2N1ci5cblx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiAmJiBrZXkgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudFtrZXldID0gdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0XHRpZiAodmFsdWUpIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSA9PT0gXCJjbGFzc05hbWVcIiA/IFwiY2xhc3NcIiA6IGtleSwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRycyA9IHZub2RlLmF0dHJzXG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJzZWxlY3RcIiAmJiBhdHRycyAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJ2YWx1ZVwiIGluIGF0dHJzKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzLnZhbHVlLCB1bmRlZmluZWQpXG5cdFx0XHRpZiAoXCJzZWxlY3RlZEluZGV4XCIgaW4gYXR0cnMpIHNldEF0dHIodm5vZGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsLCBhdHRycy5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzLCBucykge1xuXHRcdGlmIChhdHRycyAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdFx0c2V0QXR0cih2bm9kZSwga2V5LCBvbGQgJiYgb2xkW2tleV0sIGF0dHJzW2tleV0sIG5zKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2xkICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzID09IG51bGwgfHwgIShrZXkgaW4gYXR0cnMpKSB7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gXCJjbGFzc05hbWVcIikga2V5ID0gXCJjbGFzc1wiXG5cdFx0XHRcdFx0aWYgKGtleVswXSA9PT0gXCJvXCIgJiYga2V5WzFdID09PSBcIm5cIiAmJiAhaXNMaWZlY3ljbGVNZXRob2Qoa2V5KSkgdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleSAhPT0gXCJrZXlcIikgdm5vZGUuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNGb3JtQXR0cmlidXRlKHZub2RlLCBhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwidmFsdWVcIiB8fCBhdHRyID09PSBcImNoZWNrZWRcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkSW5kZXhcIiB8fCBhdHRyID09PSBcInNlbGVjdGVkXCIgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpc0xpZmVjeWNsZU1ldGhvZChhdHRyKSB7XG5cdFx0cmV0dXJuIGF0dHIgPT09IFwib25pbml0XCIgfHwgYXR0ciA9PT0gXCJvbmNyZWF0ZVwiIHx8IGF0dHIgPT09IFwib251cGRhdGVcIiB8fCBhdHRyID09PSBcIm9ucmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXJlbW92ZVwiIHx8IGF0dHIgPT09IFwib25iZWZvcmV1cGRhdGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQXR0cmlidXRlKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJocmVmXCIgfHwgYXR0ciA9PT0gXCJsaXN0XCIgfHwgYXR0ciA9PT0gXCJmb3JtXCIgfHwgYXR0ciA9PT0gXCJ3aWR0aFwiIHx8IGF0dHIgPT09IFwiaGVpZ2h0XCIvLyB8fCBhdHRyID09PSBcInR5cGVcIlxuXHR9XG5cdGZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh2bm9kZSl7XG5cdFx0cmV0dXJuIHZub2RlLmF0dHJzLmlzIHx8IHZub2RlLnRhZy5pbmRleE9mKFwiLVwiKSA+IC0xXG5cdH1cblx0ZnVuY3Rpb24gaGFzSW50ZWdyYXRpb25NZXRob2RzKHNvdXJjZSkge1xuXHRcdHJldHVybiBzb3VyY2UgIT0gbnVsbCAmJiAoc291cmNlLm9uY3JlYXRlIHx8IHNvdXJjZS5vbnVwZGF0ZSB8fCBzb3VyY2Uub25iZWZvcmVyZW1vdmUgfHwgc291cmNlLm9ucmVtb3ZlKVxuXHR9XG5cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc3R5bGUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGtleSBpbiBzdHlsZSkpIGVsZW1lbnQuc3R5bGVba2V5XSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vZXZlbnRcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQodm5vZGUsIGtleSwgdmFsdWUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdHZhciBjYWxsYmFjayA9IHR5cGVvZiBvbmV2ZW50ICE9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSA6IGZ1bmN0aW9uKGUpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWx1ZS5jYWxsKGVsZW1lbnQsIGUpXG5cdFx0XHRvbmV2ZW50LmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9XG5cdFx0aWYgKGtleSBpbiBlbGVtZW50KSBlbGVtZW50W2tleV0gPSB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhbGxiYWNrIDogbnVsbFxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGtleS5zbGljZSgyKVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50cyA9PT0gdW5kZWZpbmVkKSB2bm9kZS5ldmVudHMgPSB7fVxuXHRcdFx0aWYgKHZub2RlLmV2ZW50c1trZXldID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleV0gIT0gbnVsbCkgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleV0sIGZhbHNlKVxuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHZub2RlLmV2ZW50c1trZXldID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleV0sIGZhbHNlKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vbGlmZWN5Y2xlXG5cdGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmluaXQgPT09IFwiZnVuY3Rpb25cIikgc291cmNlLm9uaW5pdC5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbmNyZWF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlTGlmZWN5Y2xlKHNvdXJjZSwgdm5vZGUsIGhvb2tzKSB7XG5cdFx0aWYgKHR5cGVvZiBzb3VyY2Uub251cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgaG9va3MucHVzaChzb3VyY2Uub251cGRhdGUuYmluZCh2bm9kZS5zdGF0ZSwgdm5vZGUpKVxuXHR9XG5cdGZ1bmN0aW9uIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSB7XG5cdFx0dmFyIGZvcmNlVm5vZGVVcGRhdGUsIGZvcmNlQ29tcG9uZW50VXBkYXRlXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIGZvcmNlVm5vZGVVcGRhdGUgPSB2bm9kZS5hdHRycy5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VDb21wb25lbnRVcGRhdGUgPSB2bm9kZS5fc3RhdGUub25iZWZvcmV1cGRhdGUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUsIG9sZClcblx0XHRpZiAoIShmb3JjZVZub2RlVXBkYXRlID09PSB1bmRlZmluZWQgJiYgZm9yY2VDb21wb25lbnRVcGRhdGUgPT09IHVuZGVmaW5lZCkgJiYgIWZvcmNlVm5vZGVVcGRhdGUgJiYgIWZvcmNlQ29tcG9uZW50VXBkYXRlKSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHRcdHZub2RlLmluc3RhbmNlID0gb2xkLmluc3RhbmNlXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXG5cdFx0Ly8gRmlyc3QgdGltZSByZW5kZXJpbmcgaW50byBhIG5vZGUgY2xlYXJzIGl0IG91dFxuXHRcdGlmIChkb20udm5vZGVzID09IG51bGwpIGRvbS50ZXh0Q29udGVudCA9IFwiXCJcblxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHQvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiByZXR1cm4gbnVsbCBpbiBJRSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvYWN0aXZlRWxlbWVudFxuXHRcdGlmIChhY3RpdmUgIT0gbnVsbCAmJiAkZG9jLmFjdGl2ZUVsZW1lbnQgIT09IGFjdGl2ZSkgYWN0aXZlLmZvY3VzKClcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdH1cblxuXHRyZXR1cm4ge3JlbmRlcjogcmVuZGVyLCBzZXRFdmVudENhbGxiYWNrOiBzZXRFdmVudENhbGxiYWNrfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIFZub2RlID0gcmVxdWlyZShcIi4uL3JlbmRlci92bm9kZVwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMsIGNoaWxkcmVuLCB0ZXh0LCBkb20pIHtcblx0cmV0dXJuIHt0YWc6IHRhZywga2V5OiBrZXksIGF0dHJzOiBhdHRycywgY2hpbGRyZW46IGNoaWxkcmVuLCB0ZXh0OiB0ZXh0LCBkb206IGRvbSwgZG9tU2l6ZTogdW5kZWZpbmVkLCBzdGF0ZTogdW5kZWZpbmVkLCBfc3RhdGU6IHVuZGVmaW5lZCwgZXZlbnRzOiB1bmRlZmluZWQsIGluc3RhbmNlOiB1bmRlZmluZWQsIHNraXA6IGZhbHNlfVxufVxuVm5vZGUubm9ybWFsaXplID0gZnVuY3Rpb24obm9kZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShub2RlKSkgcmV0dXJuIFZub2RlKFwiW1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4obm9kZSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRpZiAobm9kZSAhPSBudWxsICYmIHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBub2RlID09PSBmYWxzZSA/IFwiXCIgOiBub2RlLCB1bmRlZmluZWQsIHVuZGVmaW5lZClcblx0cmV0dXJuIG5vZGVcbn1cblZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNoaWxkcmVuW2ldID0gVm5vZGUubm9ybWFsaXplKGNoaWxkcmVuW2ldKVxuXHR9XG5cdHJldHVybiBjaGlsZHJlblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZub2RlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3N0cmVhbS9zdHJlYW1cIilcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG47KGZ1bmN0aW9uKCkge1xuXCJ1c2Ugc3RyaWN0XCJcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGd1aWQgPSAwLCBIQUxUID0ge31cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSgpIHtcblx0ZnVuY3Rpb24gc3RyZWFtKCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IEhBTFQpIHVwZGF0ZVN0cmVhbShzdHJlYW0sIGFyZ3VtZW50c1swXSlcblx0XHRyZXR1cm4gc3RyZWFtLl9zdGF0ZS52YWx1ZVxuXHR9XG5cdGluaXRTdHJlYW0oc3RyZWFtKVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IEhBTFQpIHVwZGF0ZVN0cmVhbShzdHJlYW0sIGFyZ3VtZW50c1swXSlcblxuXHRyZXR1cm4gc3RyZWFtXG59XG5mdW5jdGlvbiBpbml0U3RyZWFtKHN0cmVhbSkge1xuXHRzdHJlYW0uY29uc3RydWN0b3IgPSBjcmVhdGVTdHJlYW1cblx0c3RyZWFtLl9zdGF0ZSA9IHtpZDogZ3VpZCsrLCB2YWx1ZTogdW5kZWZpbmVkLCBzdGF0ZTogMCwgZGVyaXZlOiB1bmRlZmluZWQsIHJlY292ZXI6IHVuZGVmaW5lZCwgZGVwczoge30sIHBhcmVudHM6IFtdLCBlbmRTdHJlYW06IHVuZGVmaW5lZCwgdW5yZWdpc3RlcjogdW5kZWZpbmVkfVxuXHRzdHJlYW0ubWFwID0gc3RyZWFtW1wiZmFudGFzeS1sYW5kL21hcFwiXSA9IG1hcCwgc3RyZWFtW1wiZmFudGFzeS1sYW5kL2FwXCJdID0gYXAsIHN0cmVhbVtcImZhbnRhc3ktbGFuZC9vZlwiXSA9IGNyZWF0ZVN0cmVhbVxuXHRzdHJlYW0udmFsdWVPZiA9IHZhbHVlT2YsIHN0cmVhbS50b0pTT04gPSB0b0pTT04sIHN0cmVhbS50b1N0cmluZyA9IHZhbHVlT2ZcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJlYW0sIHtcblx0XHRlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCFzdHJlYW0uX3N0YXRlLmVuZFN0cmVhbSkge1xuXHRcdFx0XHR2YXIgZW5kU3RyZWFtID0gY3JlYXRlU3RyZWFtKClcblx0XHRcdFx0ZW5kU3RyZWFtLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0dW5yZWdpc3RlclN0cmVhbShzdHJlYW0pXG5cdFx0XHRcdFx0XHRlbmRTdHJlYW0uX3N0YXRlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbigpe3VucmVnaXN0ZXJTdHJlYW0oZW5kU3RyZWFtKX1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHN0cmVhbS5fc3RhdGUuZW5kU3RyZWFtID0gZW5kU3RyZWFtXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyZWFtLl9zdGF0ZS5lbmRTdHJlYW1cblx0XHR9fVxuXHR9KVxufVxuZnVuY3Rpb24gdXBkYXRlU3RyZWFtKHN0cmVhbSwgdmFsdWUpIHtcblx0dXBkYXRlU3RhdGUoc3RyZWFtLCB2YWx1ZSlcblx0Zm9yICh2YXIgaWQgaW4gc3RyZWFtLl9zdGF0ZS5kZXBzKSB1cGRhdGVEZXBlbmRlbmN5KHN0cmVhbS5fc3RhdGUuZGVwc1tpZF0sIGZhbHNlKVxuXHRpZiAoc3RyZWFtLl9zdGF0ZS51bnJlZ2lzdGVyICE9IG51bGwpIHN0cmVhbS5fc3RhdGUudW5yZWdpc3RlcigpXG5cdGZpbmFsaXplKHN0cmVhbSlcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHN0cmVhbSwgdmFsdWUpIHtcblx0c3RyZWFtLl9zdGF0ZS52YWx1ZSA9IHZhbHVlXG5cdHN0cmVhbS5fc3RhdGUuY2hhbmdlZCA9IHRydWVcblx0aWYgKHN0cmVhbS5fc3RhdGUuc3RhdGUgIT09IDIpIHN0cmVhbS5fc3RhdGUuc3RhdGUgPSAxXG59XG5mdW5jdGlvbiB1cGRhdGVEZXBlbmRlbmN5KHN0cmVhbSwgbXVzdFN5bmMpIHtcblx0dmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZSwgcGFyZW50cyA9IHN0YXRlLnBhcmVudHNcblx0aWYgKHBhcmVudHMubGVuZ3RoID4gMCAmJiBwYXJlbnRzLmV2ZXJ5KGFjdGl2ZSkgJiYgKG11c3RTeW5jIHx8IHBhcmVudHMuc29tZShjaGFuZ2VkKSkpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJlYW0uX3N0YXRlLmRlcml2ZSgpXG5cdFx0aWYgKHZhbHVlID09PSBIQUxUKSByZXR1cm4gZmFsc2Vcblx0XHR1cGRhdGVTdGF0ZShzdHJlYW0sIHZhbHVlKVxuXHR9XG59XG5mdW5jdGlvbiBmaW5hbGl6ZShzdHJlYW0pIHtcblx0c3RyZWFtLl9zdGF0ZS5jaGFuZ2VkID0gZmFsc2Vcblx0Zm9yICh2YXIgaWQgaW4gc3RyZWFtLl9zdGF0ZS5kZXBzKSBzdHJlYW0uX3N0YXRlLmRlcHNbaWRdLl9zdGF0ZS5jaGFuZ2VkID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tYmluZShmbiwgc3RyZWFtcykge1xuXHRpZiAoIXN0cmVhbXMuZXZlcnkodmFsaWQpKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCBlYWNoIGl0ZW0gcGFzc2VkIHRvIHN0cmVhbS5jb21iaW5lL3N0cmVhbS5tZXJnZSBpcyBhIHN0cmVhbVwiKVxuXHRyZXR1cm4gaW5pdERlcGVuZGVuY3koY3JlYXRlU3RyZWFtKCksIHN0cmVhbXMsIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSh0aGlzLCBzdHJlYW1zLmNvbmNhdChbc3RyZWFtcy5maWx0ZXIoY2hhbmdlZCldKSlcblx0fSlcbn1cblxuZnVuY3Rpb24gaW5pdERlcGVuZGVuY3koZGVwLCBzdHJlYW1zLCBkZXJpdmUpIHtcblx0dmFyIHN0YXRlID0gZGVwLl9zdGF0ZVxuXHRzdGF0ZS5kZXJpdmUgPSBkZXJpdmVcblx0c3RhdGUucGFyZW50cyA9IHN0cmVhbXMuZmlsdGVyKG5vdEVuZGVkKVxuXG5cdHJlZ2lzdGVyRGVwZW5kZW5jeShkZXAsIHN0YXRlLnBhcmVudHMpXG5cdHVwZGF0ZURlcGVuZGVuY3koZGVwLCB0cnVlKVxuXG5cdHJldHVybiBkZXBcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVwZW5kZW5jeShzdHJlYW0sIHBhcmVudHMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0cGFyZW50c1tpXS5fc3RhdGUuZGVwc1tzdHJlYW0uX3N0YXRlLmlkXSA9IHN0cmVhbVxuXHRcdHJlZ2lzdGVyRGVwZW5kZW5jeShzdHJlYW0sIHBhcmVudHNbaV0uX3N0YXRlLnBhcmVudHMpXG5cdH1cbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJTdHJlYW0oc3RyZWFtKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3RyZWFtLl9zdGF0ZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHBhcmVudCA9IHN0cmVhbS5fc3RhdGUucGFyZW50c1tpXVxuXHRcdGRlbGV0ZSBwYXJlbnQuX3N0YXRlLmRlcHNbc3RyZWFtLl9zdGF0ZS5pZF1cblx0fVxuXHRmb3IgKHZhciBpZCBpbiBzdHJlYW0uX3N0YXRlLmRlcHMpIHtcblx0XHR2YXIgZGVwZW5kZW50ID0gc3RyZWFtLl9zdGF0ZS5kZXBzW2lkXVxuXHRcdHZhciBpbmRleCA9IGRlcGVuZGVudC5fc3RhdGUucGFyZW50cy5pbmRleE9mKHN0cmVhbSlcblx0XHRpZiAoaW5kZXggPiAtMSkgZGVwZW5kZW50Ll9zdGF0ZS5wYXJlbnRzLnNwbGljZShpbmRleCwgMSlcblx0fVxuXHRzdHJlYW0uX3N0YXRlLnN0YXRlID0gMiAvL2VuZGVkXG5cdHN0cmVhbS5fc3RhdGUuZGVwcyA9IHt9XG59XG5cbmZ1bmN0aW9uIG1hcChmbikge3JldHVybiBjb21iaW5lKGZ1bmN0aW9uKHN0cmVhbSkge3JldHVybiBmbihzdHJlYW0oKSl9LCBbdGhpc10pfVxuZnVuY3Rpb24gYXAoc3RyZWFtKSB7cmV0dXJuIGNvbWJpbmUoZnVuY3Rpb24oczEsIHMyKSB7cmV0dXJuIHMxKCkoczIoKSl9LCBbc3RyZWFtLCB0aGlzXSl9XG5mdW5jdGlvbiB2YWx1ZU9mKCkge3JldHVybiB0aGlzLl9zdGF0ZS52YWx1ZX1cbmZ1bmN0aW9uIHRvSlNPTigpIHtyZXR1cm4gdGhpcy5fc3RhdGUudmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdGhpcy5fc3RhdGUudmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9zdGF0ZS52YWx1ZS50b0pTT04oKSA6IHRoaXMuX3N0YXRlLnZhbHVlfVxuXG5mdW5jdGlvbiB2YWxpZChzdHJlYW0pIHtyZXR1cm4gc3RyZWFtLl9zdGF0ZSB9XG5mdW5jdGlvbiBhY3RpdmUoc3RyZWFtKSB7cmV0dXJuIHN0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDF9XG5mdW5jdGlvbiBjaGFuZ2VkKHN0cmVhbSkge3JldHVybiBzdHJlYW0uX3N0YXRlLmNoYW5nZWR9XG5mdW5jdGlvbiBub3RFbmRlZChzdHJlYW0pIHtyZXR1cm4gc3RyZWFtLl9zdGF0ZS5zdGF0ZSAhPT0gMn1cblxuZnVuY3Rpb24gbWVyZ2Uoc3RyZWFtcykge1xuXHRyZXR1cm4gY29tYmluZShmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc3RyZWFtcy5tYXAoZnVuY3Rpb24ocykge3JldHVybiBzKCl9KVxuXHR9LCBzdHJlYW1zKVxufVxuXG5mdW5jdGlvbiBzY2FuKHJlZHVjZXIsIHNlZWQsIHN0cmVhbSkge1xuXHR2YXIgbmV3U3RyZWFtID0gY29tYmluZShmdW5jdGlvbiAocykge1xuXHRcdHJldHVybiBzZWVkID0gcmVkdWNlcihzZWVkLCBzLl9zdGF0ZS52YWx1ZSlcblx0fSwgW3N0cmVhbV0pXG5cblx0aWYgKG5ld1N0cmVhbS5fc3RhdGUuc3RhdGUgPT09IDApIG5ld1N0cmVhbShzZWVkKVxuXG5cdHJldHVybiBuZXdTdHJlYW1cbn1cblxuZnVuY3Rpb24gc2Nhbk1lcmdlKHR1cGxlcywgc2VlZCkge1xuXHR2YXIgc3RyZWFtcyA9IHR1cGxlcy5tYXAoZnVuY3Rpb24odHVwbGUpIHtcblx0XHR2YXIgc3RyZWFtID0gdHVwbGVbMF1cblx0XHRpZiAoc3RyZWFtLl9zdGF0ZS5zdGF0ZSA9PT0gMCkgc3RyZWFtKHVuZGVmaW5lZClcblx0XHRyZXR1cm4gc3RyZWFtXG5cdH0pXG5cblx0dmFyIG5ld1N0cmVhbSA9IGNvbWJpbmUoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoYW5nZWQgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdXG5cblx0XHRzdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtLCBpZHgpIHtcblx0XHRcdGlmIChjaGFuZ2VkLmluZGV4T2Yoc3RyZWFtKSA+IC0xKSB7XG5cdFx0XHRcdHNlZWQgPSB0dXBsZXNbaWR4XVsxXShzZWVkLCBzdHJlYW0uX3N0YXRlLnZhbHVlKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRyZXR1cm4gc2VlZFxuXHR9LCBzdHJlYW1zKVxuXG5cdHJldHVybiBuZXdTdHJlYW1cbn1cblxuY3JlYXRlU3RyZWFtW1wiZmFudGFzeS1sYW5kL29mXCJdID0gY3JlYXRlU3RyZWFtXG5jcmVhdGVTdHJlYW0ubWVyZ2UgPSBtZXJnZVxuY3JlYXRlU3RyZWFtLmNvbWJpbmUgPSBjb21iaW5lXG5jcmVhdGVTdHJlYW0uc2NhbiA9IHNjYW5cbmNyZWF0ZVN0cmVhbS5zY2FuTWVyZ2UgPSBzY2FuTWVyZ2VcbmNyZWF0ZVN0cmVhbS5IQUxUID0gSEFMVFxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IGNyZWF0ZVN0cmVhbVxuZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5tID09PSBcImZ1bmN0aW9uXCIgJiYgIShcInN0cmVhbVwiIGluIHdpbmRvdy5tKSkgd2luZG93Lm0uc3RyZWFtID0gY3JlYXRlU3RyZWFtXG5lbHNlIHdpbmRvdy5tID0ge3N0cmVhbSA6IGNyZWF0ZVN0cmVhbX1cblxufSgpKTtcbiIsIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyAod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbKG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddO1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHdlZWtkYXlzW20uZGF5KCldIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICB2YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgVVQ6IDAsXG4gICAgICAgIEdNVDogMCxcbiAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICBQU1Q6IC04ICogNjBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XG4gICAgICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgICAgIHZhciB6b25lID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQ7XG4gICAgdmFyIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFO1xuICAgIHZhciBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMyArIDMsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX0hPVVIgLSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBwcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIHByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG4gICAgcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIHByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIHByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4gICAgcHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6ICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzogcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6ICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1F1YXJ0ZXJzICAgICA9IG1ha2VBcygnUScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbiAgICBwcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzICAgICA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjQuMCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG4gICAgaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIGhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICBob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIHZpbTp0cz00OnN0cz00OnN3PTQ6XG4vKiFcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEyIEtyaXMgS293YWwgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVRcbiAqIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvcmF3L21hc3Rlci9MSUNFTlNFXG4gKlxuICogV2l0aCBwYXJ0cyBieSBUeWxlciBDbG9zZVxuICogQ29weXJpZ2h0IDIwMDctMjAwOSBUeWxlciBDbG9zZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBYIGxpY2Vuc2UgZm91bmRcbiAqIGF0IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UuaHRtbFxuICogRm9ya2VkIGF0IHJlZl9zZW5kLmpzIHZlcnNpb246IDIwMDktMDUtMTFcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IE1hcmsgTWlsbGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBUaGlzIGZpbGUgd2lsbCBmdW5jdGlvbiBwcm9wZXJseSBhcyBhIDxzY3JpcHQ+IHRhZywgb3IgYSBtb2R1bGVcbiAgICAvLyB1c2luZyBDb21tb25KUyBhbmQgTm9kZUpTIG9yIFJlcXVpcmVKUyBtb2R1bGUgZm9ybWF0cy4gIEluXG4gICAgLy8gQ29tbW9uL05vZGUvUmVxdWlyZUpTLCB0aGUgbW9kdWxlIGV4cG9ydHMgdGhlIFEgQVBJIGFuZCB3aGVuXG4gICAgLy8gZXhlY3V0ZWQgYXMgYSBzaW1wbGUgPHNjcmlwdD4sIGl0IGNyZWF0ZXMgYSBRIGdsb2JhbCBpbnN0ZWFkLlxuXG4gICAgLy8gTW9udGFnZSBSZXF1aXJlXG4gICAgaWYgKHR5cGVvZiBib290c3RyYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBib290c3RyYXAoXCJwcm9taXNlXCIsIGRlZmluaXRpb24pO1xuXG4gICAgLy8gQ29tbW9uSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAvLyBSZXF1aXJlSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcblxuICAgIC8vIFNFUyAoU2VjdXJlIEVjbWFTY3JpcHQpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICghc2VzLm9rKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcy5tYWtlUSA9IGRlZmluaXRpb247XG4gICAgICAgIH1cblxuICAgIC8vIDxzY3JpcHQ+XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZWxmLlEgPSBkZWZpbml0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGVudmlyb25tZW50IHdhcyBub3QgYW50aWNpYXB0ZWQgYnkgUS4gUGxlYXNlIGZpbGUgYSBidWcuXCIpO1xuICAgIH1cblxufSkoZnVuY3Rpb24gKCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoYXNTdGFja3MgPSBmYWxzZTtcbnRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzU3RhY2tzID0gISFlLnN0YWNrO1xufVxuXG4vLyBBbGwgY29kZSBhZnRlciB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMgcmVwb3J0ZWRcbi8vIGJ5IFEuXG52YXIgcVN0YXJ0aW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG52YXIgcUZpbGVOYW1lO1xuXG4vLyBzaGltc1xuXG4vLyB1c2VkIGZvciBmYWxsYmFjayBpbiBcImFsbFJlc29sdmVkXCJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cbnZhciBuZXh0VGljayA9KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBsaW5rZWQgbGlzdCBvZiB0YXNrcyAoc2luZ2xlLCB3aXRoIGhlYWQgbm9kZSlcbiAgICB2YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xuICAgIHZhciB0YWlsID0gaGVhZDtcbiAgICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB2YXIgcmVxdWVzdFRpY2sgPSB2b2lkIDA7XG4gICAgdmFyIGlzTm9kZUpTID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG5cbiAgICAgICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgICAgIHZhciB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgaGVhZC5kb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb250aW51YXRpb24gaWYgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyBzdXBwcmVzc2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBicm93c2VycywgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLlxuICAgICAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5leHRUaWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAgICAgLy8gTm9kZS5qcyBiZWZvcmUgMC45LiBOb3RlIHRoYXQgc29tZSBmYWtlLU5vZGUgZW52aXJvbm1lbnRzLCBsaWtlIHRoZVxuICAgICAgICAvLyBNb2NoYSB0ZXN0IHJ1bm5lciwgaW50cm9kdWNlIGEgYHByb2Nlc3NgIGdsb2JhbCB3aXRob3V0IGEgYG5leHRUaWNrYC5cbiAgICAgICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgU2FmYXJpIFZlcnNpb24gNi4wLjUgKDg1MzYuMzAuMSkgaW50ZXJtaXR0ZW50bHkgY2Fubm90IGNyZWF0ZVxuICAgICAgICAvLyB3b3JraW5nIG1lc3NhZ2UgcG9ydHMgdGhlIGZpcnN0IHRpbWUgYSBwYWdlIGxvYWRzLlxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gcmVxdWVzdFBvcnRUaWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0UG9ydFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIHVzZSBpdC5cbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICByZXF1ZXN0UG9ydFRpY2soKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBicm93c2Vyc1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0VGljaztcbn0pKCk7XG5cbi8vIEF0dGVtcHQgdG8gbWFrZSBnZW5lcmljcyBzYWZlIGluIHRoZSBmYWNlIG9mIGRvd25zdHJlYW1cbi8vIG1vZGlmaWNhdGlvbnMuXG4vLyBUaGVyZSBpcyBubyBzaXR1YXRpb24gd2hlcmUgdGhpcyBpcyBuZWNlc3NhcnkuXG4vLyBJZiB5b3UgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSwgdGhlc2UgcHJpbW9yZGlhbHMgbmVlZCB0byBiZVxuLy8gZGVlcGx5IGZyb3plbiBhbnl3YXksIGFuZCBpZiB5b3UgZG9u4oCZdCBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLFxuLy8gdGhpcyBpcyBqdXN0IHBsYWluIHBhcmFub2lkLlxuLy8gSG93ZXZlciwgdGhpcyAqKm1pZ2h0KiogaGF2ZSB0aGUgbmljZSBzaWRlLWVmZmVjdCBvZiByZWR1Y2luZyB0aGUgc2l6ZSBvZlxuLy8gdGhlIG1pbmlmaWVkIGNvZGUgYnkgcmVkdWNpbmcgeC5jYWxsKCkgdG8gbWVyZWx5IHgoKVxuLy8gU2VlIE1hcmsgTWlsbGVy4oCZcyBleHBsYW5hdGlvbiBvZiB3aGF0IHRoaXMgZG9lcy5cbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWNvbnZlbnRpb25zOnNhZmVfbWV0YV9wcm9ncmFtbWluZ1xudmFyIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjYWxsLmFwcGx5KGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCwgYnV0IHNsb3dlcjpcbi8vIHVuY3VycnlUaGlzID0gRnVuY3Rpb25fYmluZC5iaW5kKEZ1bmN0aW9uX2JpbmQuY2FsbCk7XG4vLyBodHRwOi8vanNwZXJmLmNvbS91bmN1cnJ5dGhpc1xuXG52YXIgYXJyYXlfc2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheS5wcm90b3R5cGUuc2xpY2UpO1xuXG52YXIgYXJyYXlfcmVkdWNlID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIGJhc2lzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgLy8gY29uY2VybmluZyB0aGUgaW5pdGlhbCB2YWx1ZSwgaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gc2VlayB0byB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFycmF5LCBhY2NvdW50aW5nXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgaXMgaXMgYSBzcGFyc2UgYXJyYXlcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBiYXNpcyA9IHRoaXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZHVjZVxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSBhcnJheSBpcyBzcGFyc2VcbiAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgYmFzaXMgPSBjYWxsYmFjayhiYXNpcywgdGhpc1tpbmRleF0sIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzaXM7XG4gICAgfVxuKTtcblxudmFyIGFycmF5X2luZGV4T2YgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbm90IGEgdmVyeSBnb29kIHNoaW0sIGJ1dCBnb29kIGVub3VnaCBmb3Igb3VyIG9uZSB1c2Ugb2YgaXRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuKTtcblxudmFyIGFycmF5X21hcCA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xsZWN0ID0gW107XG4gICAgICAgIGFycmF5X3JlZHVjZShzZWxmLCBmdW5jdGlvbiAodW5kZWZpbmVkLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjYWxsYmFjay5jYWxsKHRoaXNwLCB2YWx1ZSwgaW5kZXgsIHNlbGYpKTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Q7XG4gICAgfVxuKTtcblxudmFyIG9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUpIHtcbiAgICBmdW5jdGlvbiBUeXBlKCkgeyB9XG4gICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgcmV0dXJuIG5ldyBUeXBlKCk7XG59O1xuXG52YXIgb2JqZWN0X2hhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbnZhciBvYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdF9oYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcblxudmFyIG9iamVjdF90b1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gT2JqZWN0KHZhbHVlKTtcbn1cblxuLy8gZ2VuZXJhdG9yIHJlbGF0ZWQgc2hpbXNcblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGZ1bmN0aW9uIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbmZ1bmN0aW9uIGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBvYmplY3RfdG9TdHJpbmcoZXhjZXB0aW9uKSA9PT0gXCJbb2JqZWN0IFN0b3BJdGVyYXRpb25dXCIgfHxcbiAgICAgICAgZXhjZXB0aW9uIGluc3RhbmNlb2YgUVJldHVyblZhbHVlXG4gICAgKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGhlbHBlciBhbmQgUS5yZXR1cm4gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW5cbi8vIFNwaWRlck1vbmtleS5cbnZhciBRUmV0dXJuVmFsdWU7XG5pZiAodHlwZW9mIFJldHVyblZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUVJldHVyblZhbHVlID0gUmV0dXJuVmFsdWU7XG59IGVsc2Uge1xuICAgIFFSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbn1cblxuLy8gbG9uZyBzdGFjayB0cmFjZXNcblxudmFyIFNUQUNLX0pVTVBfU0VQQVJBVE9SID0gXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiO1xuXG5mdW5jdGlvbiBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpIHtcbiAgICAvLyBJZiBwb3NzaWJsZSwgdHJhbnNmb3JtIHRoZSBlcnJvciBzdGFjayB0cmFjZSBieSByZW1vdmluZyBOb2RlIGFuZCBRXG4gICAgLy8gY3J1ZnQsIHRoZW4gY29uY2F0ZW5hdGluZyB3aXRoIHRoZSBzdGFjayB0cmFjZSBvZiBgcHJvbWlzZWAuIFNlZSAjNTcuXG4gICAgaWYgKGhhc1N0YWNrcyAmJlxuICAgICAgICBwcm9taXNlLnN0YWNrICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnJvci5zdGFjayAmJlxuICAgICAgICBlcnJvci5zdGFjay5pbmRleE9mKFNUQUNLX0pVTVBfU0VQQVJBVE9SKSA9PT0gLTFcbiAgICApIHtcbiAgICAgICAgdmFyIHN0YWNrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwID0gcHJvbWlzZTsgISFwOyBwID0gcC5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChwLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tzLnVuc2hpZnQocC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnVuc2hpZnQoZXJyb3Iuc3RhY2spO1xuXG4gICAgICAgIHZhciBjb25jYXRlZFN0YWNrcyA9IHN0YWNrcy5qb2luKFwiXFxuXCIgKyBTVEFDS19KVU1QX1NFUEFSQVRPUiArIFwiXFxuXCIpO1xuICAgICAgICBlcnJvci5zdGFjayA9IGZpbHRlclN0YWNrU3RyaW5nKGNvbmNhdGVkU3RhY2tzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlclN0YWNrU3RyaW5nKHN0YWNrU3RyaW5nKSB7XG4gICAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGRlc2lyZWRMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICBpZiAoIWlzSW50ZXJuYWxGcmFtZShsaW5lKSAmJiAhaXNOb2RlRnJhbWUobGluZSkgJiYgbGluZSkge1xuICAgICAgICAgICAgZGVzaXJlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc2lyZWRMaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVGcmFtZShzdGFja0xpbmUpIHtcbiAgICByZXR1cm4gc3RhY2tMaW5lLmluZGV4T2YoXCIobW9kdWxlLmpzOlwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgc3RhY2tMaW5lLmluZGV4T2YoXCIobm9kZS5qczpcIikgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKSB7XG4gICAgLy8gTmFtZWQgZnVuY3Rpb25zOiBcImF0IGZ1bmN0aW9uTmFtZSAoZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXIpXCJcbiAgICAvLyBJbiBJRTEwIGZ1bmN0aW9uIG5hbWUgY2FuIGhhdmUgc3BhY2VzIChcIkFub255bW91cyBmdW5jdGlvblwiKSBPX29cbiAgICB2YXIgYXR0ZW1wdDEgPSAvYXQgLisgXFwoKC4rKTooXFxkKyk6KD86XFxkKylcXCkkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQxKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDFbMV0sIE51bWJlcihhdHRlbXB0MVsyXSldO1xuICAgIH1cblxuICAgIC8vIEFub255bW91cyBmdW5jdGlvbnM6IFwiYXQgZmlsZW5hbWU6bGluZU51bWJlcjpjb2x1bW5OdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MiA9IC9hdCAoW14gXSspOihcXGQrKTooPzpcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDIpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MlsxXSwgTnVtYmVyKGF0dGVtcHQyWzJdKV07XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCBzdHlsZTogXCJmdW5jdGlvbkBmaWxlbmFtZTpsaW5lTnVtYmVyIG9yIEBmaWxlbmFtZTpsaW5lTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDMgPSAvLipAKC4rKTooXFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQzKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDNbMV0sIE51bWJlcihhdHRlbXB0M1syXSldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnRlcm5hbEZyYW1lKHN0YWNrTGluZSkge1xuICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoc3RhY2tMaW5lKTtcblxuICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG5cbiAgICByZXR1cm4gZmlsZU5hbWUgPT09IHFGaWxlTmFtZSAmJlxuICAgICAgICBsaW5lTnVtYmVyID49IHFTdGFydGluZ0xpbmUgJiZcbiAgICAgICAgbGluZU51bWJlciA8PSBxRW5kaW5nTGluZTtcbn1cblxuLy8gZGlzY292ZXIgb3duIGZpbGUgbmFtZSBhbmQgbGluZSBudW1iZXIgcmFuZ2UgZm9yIGZpbHRlcmluZyBzdGFja1xuLy8gdHJhY2VzXG5mdW5jdGlvbiBjYXB0dXJlTGluZSgpIHtcbiAgICBpZiAoIWhhc1N0YWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gbGluZXNbMF0uaW5kZXhPZihcIkBcIikgPiAwID8gbGluZXNbMV0gOiBsaW5lc1syXTtcbiAgICAgICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihmaXJzdExpbmUpO1xuICAgICAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcUZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgICAgICByZXR1cm4gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKGNhbGxiYWNrLCBuYW1lLCBhbHRlcm5hdGl2ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiIGlzIGRlcHJlY2F0ZWQsIHVzZSBcIiArIGFsdGVybmF0aXZlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpbnN0ZWFkLlwiLCBuZXcgRXJyb3IoXCJcIikuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShjYWxsYmFjaywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vLyBlbmQgb2Ygc2hpbXNcbi8vIGJlZ2lubmluZyBvZiByZWFsIHdvcmtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZSwgcGFzc2VzIHByb21pc2VzIHRocm91Z2gsIG9yXG4gKiBjb2VyY2VzIHByb21pc2VzIGZyb20gZGlmZmVyZW50IHN5c3RlbXMuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZSBvciBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIFEodmFsdWUpIHtcbiAgICAvLyBJZiB0aGUgb2JqZWN0IGlzIGFscmVhZHkgYSBQcm9taXNlLCByZXR1cm4gaXQgZGlyZWN0bHkuICBUaGlzIGVuYWJsZXNcbiAgICAvLyB0aGUgcmVzb2x2ZSBmdW5jdGlvbiB0byBib3RoIGJlIHVzZWQgdG8gY3JlYXRlZCByZWZlcmVuY2VzIGZyb20gb2JqZWN0cyxcbiAgICAvLyBidXQgdG8gdG9sZXJhYmx5IGNvZXJjZSBub24tcHJvbWlzZXMgdG8gcHJvbWlzZXMuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gYXNzaW1pbGF0ZSB0aGVuYWJsZXNcbiAgICBpZiAoaXNQcm9taXNlQWxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsKHZhbHVlKTtcbiAgICB9XG59XG5RLnJlc29sdmUgPSBRO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuIG9mIHRoZSBldmVudCBsb29wLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdGFza1xuICovXG5RLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbi8qKlxuICogQ29udHJvbHMgd2hldGhlciBvciBub3QgbG9uZyBzdGFjayB0cmFjZXMgd2lsbCBiZSBvblxuICovXG5RLmxvbmdTdGFja1N1cHBvcnQgPSBmYWxzZTtcblxuLy8gZW5hYmxlIGxvbmcgc3RhY2tzIGlmIFFfREVCVUcgaXMgc2V0XG5pZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5RX0RFQlVHKSB7XG4gICAgUS5sb25nU3RhY2tTdXBwb3J0ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEge3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH0gb2JqZWN0LlxuICpcbiAqIGByZXNvbHZlYCBpcyBhIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGEgbW9yZSByZXNvbHZlZCB2YWx1ZSBmb3IgdGhlXG4gKiBwcm9taXNlLiBUbyBmdWxmaWxsIHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYW55IHZhbHVlIHRoYXQgaXNcbiAqIG5vdCBhIHRoZW5hYmxlLiBUbyByZWplY3QgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhIHJlamVjdGVkXG4gKiB0aGVuYWJsZSwgb3IgaW52b2tlIGByZWplY3RgIHdpdGggdGhlIHJlYXNvbiBkaXJlY3RseS4gVG8gcmVzb2x2ZSB0aGVcbiAqIHByb21pc2UgdG8gYW5vdGhlciB0aGVuYWJsZSwgdGh1cyBwdXR0aW5nIGl0IGluIHRoZSBzYW1lIHN0YXRlLCBpbnZva2VcbiAqIGByZXNvbHZlYCB3aXRoIHRoYXQgb3RoZXIgdGhlbmFibGUuXG4gKi9cblEuZGVmZXIgPSBkZWZlcjtcbmZ1bmN0aW9uIGRlZmVyKCkge1xuICAgIC8vIGlmIFwibWVzc2FnZXNcIiBpcyBhbiBcIkFycmF5XCIsIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHByb21pc2UgaGFzIG5vdCB5ZXRcbiAgICAvLyBiZWVuIHJlc29sdmVkLiAgSWYgaXQgaXMgXCJ1bmRlZmluZWRcIiwgaXQgaGFzIGJlZW4gcmVzb2x2ZWQuICBFYWNoXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgbWVzc2FnZXMgYXJyYXkgaXMgaXRzZWxmIGFuIGFycmF5IG9mIGNvbXBsZXRlIGFyZ3VtZW50cyB0b1xuICAgIC8vIGZvcndhcmQgdG8gdGhlIHJlc29sdmVkIHByb21pc2UuICBXZSBjb2VyY2UgdGhlIHJlc29sdXRpb24gdmFsdWUgdG8gYVxuICAgIC8vIHByb21pc2UgdXNpbmcgdGhlIGByZXNvbHZlYCBmdW5jdGlvbiBiZWNhdXNlIGl0IGhhbmRsZXMgYm90aCBmdWxseVxuICAgIC8vIG5vbi10aGVuYWJsZSB2YWx1ZXMgYW5kIG90aGVyIHRoZW5hYmxlcyBncmFjZWZ1bGx5LlxuICAgIHZhciBtZXNzYWdlcyA9IFtdLCBwcm9ncmVzc0xpc3RlbmVycyA9IFtdLCByZXNvbHZlZFByb21pc2U7XG5cbiAgICB2YXIgZGVmZXJyZWQgPSBvYmplY3RfY3JlYXRlKGRlZmVyLnByb3RvdHlwZSk7XG4gICAgdmFyIHByb21pc2UgPSBvYmplY3RfY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcblxuICAgIHByb21pc2UucHJvbWlzZURpc3BhdGNoID0gZnVuY3Rpb24gKHJlc29sdmUsIG9wLCBvcGVyYW5kcykge1xuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChhcmdzKTtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJ3aGVuXCIgJiYgb3BlcmFuZHNbMV0pIHsgLy8gcHJvZ3Jlc3Mgb3BlcmFuZFxuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXJzLnB1c2gob3BlcmFuZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShyZXNvbHZlZFByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gWFhYIGRlcHJlY2F0ZWRcbiAgICBwcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lYXJlclZhbHVlID0gbmVhcmVyKHJlc29sdmVkUHJvbWlzZSk7XG4gICAgICAgIGlmIChpc1Byb21pc2UobmVhcmVyVmFsdWUpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZWFyZXJWYWx1ZTsgLy8gc2hvcnRlbiBjaGFpblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXJWYWx1ZTtcbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicGVuZGluZ1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgfTtcblxuICAgIGlmIChRLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTk9URTogZG9uJ3QgdHJ5IHRvIHVzZSBgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VgIG9yIHRyYW5zZmVyIHRoZVxuICAgICAgICAgICAgLy8gYWNjZXNzb3IgYXJvdW5kOyB0aGF0IGNhdXNlcyBtZW1vcnkgbGVha3MgYXMgcGVyIEdILTExMS4gSnVzdFxuICAgICAgICAgICAgLy8gcmVpZnkgdGhlIHN0YWNrIHRyYWNlIGFzIGEgc3RyaW5nIEFTQVAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSwgY3V0IG9mZiB0aGUgZmlyc3QgbGluZTsgaXQncyBhbHdheXMganVzdFxuICAgICAgICAgICAgLy8gXCJbb2JqZWN0IFByb21pc2VdXFxuXCIsIGFzIHBlciB0aGUgYHRvU3RyaW5nYC5cbiAgICAgICAgICAgIHByb21pc2Uuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cmluZyhlLnN0YWNrLmluZGV4T2YoXCJcXG5cIikgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IHdlIGRvIHRoZSBjaGVja3MgZm9yIGByZXNvbHZlZFByb21pc2VgIGluIGVhY2ggbWV0aG9kLCBpbnN0ZWFkIG9mXG4gICAgLy8gY29uc29saWRhdGluZyB0aGVtIGludG8gYGJlY29tZWAsIHNpbmNlIG90aGVyd2lzZSB3ZSdkIGNyZWF0ZSBuZXdcbiAgICAvLyBwcm9taXNlcyB3aXRoIHRoZSBsaW5lcyBgYmVjb21lKHdoYXRldmVyKHZhbHVlKSlgLiBTZWUgZS5nLiBHSC0yNTIuXG5cbiAgICBmdW5jdGlvbiBiZWNvbWUobmV3UHJvbWlzZSkge1xuICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZXdQcm9taXNlO1xuICAgICAgICBwcm9taXNlLnNvdXJjZSA9IG5ld1Byb21pc2U7XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKG1lc3NhZ2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShuZXdQcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuXG4gICAgICAgIG1lc3NhZ2VzID0gdm9pZCAwO1xuICAgICAgICBwcm9ncmVzc0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICBkZWZlcnJlZC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShRKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGRlZmVycmVkLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKGZ1bGZpbGwodmFsdWUpKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKHJlamVjdChyZWFzb24pKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UocHJvZ3Jlc3NMaXN0ZW5lcnMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb2dyZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIGRlZmVycmVkXG4gKiBwcm9taXNlLlxuICogQHJldHVybnMgYSBub2RlYmFja1xuICovXG5kZWZlci5wcm90b3R5cGUubWFrZU5vZGVSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZShhcnJheV9zbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gcmVzb2x2ZXIge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub3RoaW5nIGFuZCBhY2NlcHRzXG4gKiB0aGUgcmVzb2x2ZSwgcmVqZWN0LCBhbmQgbm90aWZ5IGZ1bmN0aW9ucyBmb3IgYSBkZWZlcnJlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IG1heSBiZSByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiByZXNvbHZlIGFuZCByZWplY3RcbiAqIGZ1bmN0aW9ucywgb3IgcmVqZWN0ZWQgYnkgYSB0aHJvd24gZXhjZXB0aW9uIGluIHJlc29sdmVyXG4gKi9cblEuUHJvbWlzZSA9IHByb21pc2U7IC8vIEVTNlxuUS5wcm9taXNlID0gcHJvbWlzZTtcbmZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbnByb21pc2UucmFjZSA9IHJhY2U7IC8vIEVTNlxucHJvbWlzZS5hbGwgPSBhbGw7IC8vIEVTNlxucHJvbWlzZS5yZWplY3QgPSByZWplY3Q7IC8vIEVTNlxucHJvbWlzZS5yZXNvbHZlID0gUTsgLy8gRVM2XG5cbi8vIFhYWCBleHBlcmltZW50YWwuICBUaGlzIG1ldGhvZCBpcyBhIHdheSB0byBkZW5vdGUgdGhhdCBhIGxvY2FsIHZhbHVlIGlzXG4vLyBzZXJpYWxpemFibGUgYW5kIHNob3VsZCBiZSBpbW1lZGlhdGVseSBkaXNwYXRjaGVkIHRvIGEgcmVtb3RlIHVwb24gcmVxdWVzdCxcbi8vIGluc3RlYWQgb2YgcGFzc2luZyBhIHJlZmVyZW5jZS5cblEucGFzc0J5Q29weSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIElmIHR3byBwcm9taXNlcyBldmVudHVhbGx5IGZ1bGZpbGwgdG8gdGhlIHNhbWUgdmFsdWUsIHByb21pc2VzIHRoYXQgdmFsdWUsXG4gKiBidXQgb3RoZXJ3aXNlIHJlamVjdHMuXG4gKiBAcGFyYW0geCB7QW55Kn1cbiAqIEBwYXJhbSB5IHtBbnkqfVxuICogQHJldHVybnMge0FueSp9IGEgcHJvbWlzZSBmb3IgeCBhbmQgeSBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYnV0IGEgcmVqZWN0aW9uXG4gKiBvdGhlcndpc2UuXG4gKlxuICovXG5RLmpvaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBRKHgpLmpvaW4oeSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICByZXR1cm4gUShbdGhpcywgdGhhdF0pLnNwcmVhZChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gVE9ETzogXCI9PT1cIiBzaG91bGQgYmUgT2JqZWN0LmlzIG9yIGVxdWl2XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGpvaW46IG5vdCB0aGUgc2FtZTogXCIgKyB4ICsgXCIgXCIgKyB5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGZpcnN0IG9mIGFuIGFycmF5IG9mIHByb21pc2VzIHRvIGJlY29tZSBzZXR0bGVkLlxuICogQHBhcmFtIGFuc3dlcnMge0FycmF5W0FueSpdfSBwcm9taXNlcyB0byByYWNlXG4gKiBAcmV0dXJucyB7QW55Kn0gdGhlIGZpcnN0IHByb21pc2UgdG8gYmUgc2V0dGxlZFxuICovXG5RLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShhbnN3ZXJQcykge1xuICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24oYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG5cbiAgICBmdW5jdGlvbiBfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiID8gZnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWplY3RlZChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXhjZXB0aW9uLCBzZWxmKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ld0V4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wcm9ncmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvZ3Jlc3NlZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvZ3Jlc3NlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9mdWxmaWxsZWQodmFsdWUpKTtcbiAgICAgICAgfSwgXCJ3aGVuXCIsIFtmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9yZWplY3RlZChleGNlcHRpb24pKTtcbiAgICAgICAgfV0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvZ3Jlc3MgcHJvcGFnYXRvciBuZWVkIHRvIGJlIGF0dGFjaGVkIGluIHRoZSBjdXJyZW50IHRpY2suXG4gICAgc2VsZi5wcm9taXNlRGlzcGF0Y2godm9pZCAwLCBcIndoZW5cIiwgW3ZvaWQgMCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9wcm9ncmVzc2VkKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblEudGFwID0gZnVuY3Rpb24gKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGFwKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogV29ya3MgYWxtb3N0IGxpa2UgXCJmaW5hbGx5XCIsIGJ1dCBub3QgY2FsbGVkIGZvciByZWplY3Rpb25zLlxuICogT3JpZ2luYWwgcmVzb2x1dGlvbiB2YWx1ZSBpcyBwYXNzZWQgdGhyb3VnaCBjYWxsYmFjayB1bmFmZmVjdGVkLlxuICogQ2FsbGJhY2sgbWF5IHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGF3YWl0ZWQgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtRLlByb21pc2V9XG4gKiBAZXhhbXBsZVxuICogZG9Tb21ldGhpbmcoKVxuICogICAudGhlbiguLi4pXG4gKiAgIC50YXAoY29uc29sZS5sb2cpXG4gKiAgIC50aGVuKC4uLik7XG4gKi9cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwodmFsdWUpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIG9ic2VydmVyIG9uIGEgcHJvbWlzZS5cbiAqXG4gKiBHdWFyYW50ZWVzOlxuICpcbiAqIDEuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gKiAyLiB0aGF0IGVpdGhlciB0aGUgZnVsZmlsbGVkIGNhbGxiYWNrIG9yIHRoZSByZWplY3RlZCBjYWxsYmFjayB3aWxsIGJlXG4gKiAgICBjYWxsZWQsIGJ1dCBub3QgYm90aC5cbiAqIDMuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIG5vdCBiZSBjYWxsZWQgaW4gdGhpcyB0dXJuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSB0byBvYnNlcnZlXG4gKiBAcGFyYW0gZnVsZmlsbGVkICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiBAcGFyYW0gcmVqZWN0ZWQgICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcmVqZWN0aW9uIGV4Y2VwdGlvblxuICogQHBhcmFtIHByb2dyZXNzZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgaW52b2tlZCBjYWxsYmFja1xuICovXG5RLndoZW4gPSB3aGVuO1xuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufTtcblxuUS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IHJlYXNvbjsgfSk7XG59O1xuXG5RLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlamVjdChyZWFzb24pO1xufTtcblxuLyoqXG4gKiBJZiBhbiBvYmplY3QgaXMgbm90IGEgcHJvbWlzZSwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUuXG4gKiBJZiBhIHByb21pc2UgaXMgcmVqZWN0ZWQsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlIHRvby5cbiAqIElmIGl04oCZcyBhIGZ1bGZpbGxlZCBwcm9taXNlLCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmVhcmVyLlxuICogSWYgaXTigJlzIGEgZGVmZXJyZWQgcHJvbWlzZSBhbmQgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLCB0aGVcbiAqIHJlc29sdXRpb24gaXMgXCJuZWFyZXJcIi5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIG1vc3QgcmVzb2x2ZWQgKG5lYXJlc3QpIGZvcm0gb2YgdGhlIG9iamVjdFxuICovXG5cbi8vIFhYWCBzaG91bGQgd2UgcmUtZG8gdGhpcz9cblEubmVhcmVyID0gbmVhcmVyO1xuZnVuY3Rpb24gbmVhcmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHZhbHVlLmluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZS5cbiAqIE90aGVyd2lzZSBpdCBpcyBhIGZ1bGZpbGxlZCB2YWx1ZS5cbiAqL1xuUS5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFByb21pc2U7XG59XG5cblEuaXNQcm9taXNlQWxpa2UgPSBpc1Byb21pc2VBbGlrZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUFsaWtlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgbWVhbmluZyBub3RcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAqL1xuUS5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG5mdW5jdGlvbiBpc1BlbmRpbmcob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsdWUgb3IgZnVsZmlsbGVkXG4gKiBwcm9taXNlLlxuICovXG5RLmlzRnVsZmlsbGVkID0gaXNGdWxmaWxsZWQ7XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZChvYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUHJvbWlzZShvYmplY3QpIHx8IG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuUS5pc1JlamVjdGVkID0gaXNSZWplY3RlZDtcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn07XG5cbi8vLy8gQkVHSU4gVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vLyBUaGlzIHByb21pc2UgbGlicmFyeSBjb25zdW1lcyBleGNlcHRpb25zIHRocm93biBpbiBoYW5kbGVycyBzbyB0aGV5IGNhbiBiZVxuLy8gaGFuZGxlZCBieSBhIHN1YnNlcXVlbnQgcHJvbWlzZS4gIFRoZSBleGNlcHRpb25zIGdldCBhZGRlZCB0byB0aGlzIGFycmF5IHdoZW5cbi8vIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSBhcmUgaGFuZGxlZC4gIE5vdGUgdGhhdCBpbiBFUzYgb3Jcbi8vIHNoaW1tZWQgZW52aXJvbm1lbnRzLCB0aGlzIHdvdWxkIG5hdHVyYWxseSBiZSBhIGBTZXRgLlxudmFyIHVuaGFuZGxlZFJlYXNvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24uc3RhY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKHJlYXNvbi5zdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKFwiKG5vIHN0YWNrKSBcIiArIHJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5zcGxpY2UoYXQsIDEpO1xuICAgIH1cbn1cblxuUS5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMgPSByZXNldFVuaGFuZGxlZFJlamVjdGlvbnM7XG5cblEuZ2V0VW5oYW5kbGVkUmVhc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyB0aGF0IGNvbnN1bWVycyBjYW4ndCBpbnRlcmZlcmUgd2l0aCBvdXIgaW50ZXJuYWwgc3RhdGUuXG4gICAgcmV0dXJuIHVuaGFuZGxlZFJlYXNvbnMuc2xpY2UoKTtcbn07XG5cblEuc3RvcFVuaGFuZGxlZFJlamVjdGlvblRyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZhbHNlO1xufTtcblxucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG5cbi8vLy8gRU5EIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqIEBwYXJhbSByZWFzb24gdmFsdWUgZGVzY3JpYmluZyB0aGUgZmFpbHVyZVxuICovXG5RLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICB2YXIgcmVqZWN0aW9uID0gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGUgZXJyb3IgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdW50cmFja1JlamVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkKHJlYXNvbikgOiB0aGlzO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcInJlamVjdGVkXCIsIHJlYXNvbjogcmVhc29uIH07XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIHJlYXNvbiBoYXMgbm90IGJlZW4gaGFuZGxlZC5cbiAgICB0cmFja1JlamVjdGlvbihyZWplY3Rpb24sIHJlYXNvbik7XG5cbiAgICByZXR1cm4gcmVqZWN0aW9uO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBmdWxmaWxsZWQgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlXG4gKi9cblEuZnVsZmlsbCA9IGZ1bGZpbGw7XG5mdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBcImdldFwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInNldFwiOiBmdW5jdGlvbiAobmFtZSwgcmhzKSB7XG4gICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IHJocztcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3N0XCI6IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAvLyBNYXJrIE1pbGxlciBwcm9wb3NlcyB0aGF0IHBvc3Qgd2l0aCBubyBuYW1lIHNob3VsZCBhcHBseSBhXG4gICAgICAgICAgICAvLyBwcm9taXNlZCBmdW5jdGlvbi5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBudWxsIHx8IG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV0uYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImFwcGx5XCI6IGZ1bmN0aW9uICh0aGlzcCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXNwLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJrZXlzXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGVuYWJsZXMgdG8gUSBwcm9taXNlcy5cbiAqIEBwYXJhbSBwcm9taXNlIHRoZW5hYmxlIHByb21pc2VcbiAqIEByZXR1cm5zIGEgUSBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZShwcm9taXNlKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuLyoqXG4gKiBBbm5vdGF0ZXMgYW4gb2JqZWN0IHN1Y2ggdGhhdCBpdCB3aWxsIG5ldmVyIGJlXG4gKiB0cmFuc2ZlcnJlZCBhd2F5IGZyb20gdGhpcyBwcm9jZXNzIG92ZXIgYW55IHByb21pc2VcbiAqIGNvbW11bmljYXRpb24gY2hhbm5lbC5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIHByb21pc2UgYSB3cmFwcGluZyBvZiB0aGF0IG9iamVjdCB0aGF0XG4gKiBhZGRpdGlvbmFsbHkgcmVzcG9uZHMgdG8gdGhlIFwiaXNEZWZcIiBtZXNzYWdlXG4gKiB3aXRob3V0IGEgcmVqZWN0aW9uLlxuICovXG5RLm1hc3RlciA9IG1hc3RlcjtcbmZ1bmN0aW9uIG1hc3RlcihvYmplY3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwiaXNEZWZcIjogZnVuY3Rpb24gKCkge31cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjayhvcCwgYXJncykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncyk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUShvYmplY3QpLmluc3BlY3QoKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTcHJlYWRzIHRoZSB2YWx1ZXMgb2YgYSBwcm9taXNlZCBhcnJheSBvZiBhcmd1bWVudHMgaW50byB0aGVcbiAqIGZ1bGZpbGxtZW50IGNhbGxiYWNrLlxuICogQHBhcmFtIGZ1bGZpbGxlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHZhcmlhZGljIGFyZ3VtZW50cyBmcm9tIHRoZVxuICogcHJvbWlzZWQgYXJyYXlcbiAqIEBwYXJhbSByZWplY3RlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBleGNlcHRpb24gaWYgdGhlIHByb21pc2VcbiAqIGlzIHJlamVjdGVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9yIHRocm93biBleGNlcHRpb24gb2ZcbiAqIGVpdGhlciBjYWxsYmFjay5cbiAqL1xuUS5zcHJlYWQgPSBzcHJlYWQ7XG5mdW5jdGlvbiBzcHJlYWQodmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkuc3ByZWFkKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFsbCgpLnRoZW4oZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWQuYXBwbHkodm9pZCAwLCBhcnJheSk7XG4gICAgfSwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBUaGUgYXN5bmMgZnVuY3Rpb24gaXMgYSBkZWNvcmF0b3IgZm9yIGdlbmVyYXRvciBmdW5jdGlvbnMsIHR1cm5pbmdcbiAqIHRoZW0gaW50byBhc3luY2hyb25vdXMgZ2VuZXJhdG9ycy4gIEFsdGhvdWdoIGdlbmVyYXRvcnMgYXJlIG9ubHkgcGFydFxuICogb2YgdGhlIG5ld2VzdCBFQ01BU2NyaXB0IDYgZHJhZnRzLCB0aGlzIGNvZGUgZG9lcyBub3QgY2F1c2Ugc3ludGF4XG4gKiBlcnJvcnMgaW4gb2xkZXIgZW5naW5lcy4gIFRoaXMgY29kZSBzaG91bGQgY29udGludWUgdG8gd29yayBhbmQgd2lsbFxuICogaW4gZmFjdCBpbXByb3ZlIG92ZXIgdGltZSBhcyB0aGUgbGFuZ3VhZ2UgaW1wcm92ZXMuXG4gKlxuICogRVM2IGdlbmVyYXRvcnMgYXJlIGN1cnJlbnRseSBwYXJ0IG9mIFY4IHZlcnNpb24gMy4xOSB3aXRoIHRoZVxuICogLS1oYXJtb255LWdlbmVyYXRvcnMgcnVudGltZSBmbGFnIGVuYWJsZWQuICBTcGlkZXJNb25rZXkgaGFzIGhhZCB0aGVtXG4gKiBmb3IgbG9uZ2VyLCBidXQgdW5kZXIgYW4gb2xkZXIgUHl0aG9uLWluc3BpcmVkIGZvcm0uICBUaGlzIGZ1bmN0aW9uXG4gKiB3b3JrcyBvbiBib3RoIGtpbmRzIG9mIGdlbmVyYXRvcnMuXG4gKlxuICogRGVjb3JhdGVzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHN1Y2ggdGhhdDpcbiAqICAtIGl0IG1heSB5aWVsZCBwcm9taXNlc1xuICogIC0gZXhlY3V0aW9uIHdpbGwgY29udGludWUgd2hlbiB0aGF0IHByb21pc2UgaXMgZnVsZmlsbGVkXG4gKiAgLSB0aGUgdmFsdWUgb2YgdGhlIHlpZWxkIGV4cHJlc3Npb24gd2lsbCBiZSB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiAgLSBpdCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSAod2hlbiB0aGUgZ2VuZXJhdG9yXG4gKiAgICBzdG9wcyBpdGVyYXRpbmcpXG4gKiAgLSB0aGUgZGVjb3JhdGVkIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKiAgICBvZiB0aGUgZ2VuZXJhdG9yIG9yIHRoZSBmaXJzdCByZWplY3RlZCBwcm9taXNlIGFtb25nIHRob3NlXG4gKiAgICB5aWVsZGVkLlxuICogIC0gaWYgYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBnZW5lcmF0b3IsIGl0IHByb3BhZ2F0ZXMgdGhyb3VnaFxuICogICAgZXZlcnkgZm9sbG93aW5nIHlpZWxkIHVudGlsIGl0IGlzIGNhdWdodCwgb3IgdW50aWwgaXQgZXNjYXBlc1xuICogICAgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBhbHRvZ2V0aGVyLCBhbmQgaXMgdHJhbnNsYXRlZCBpbnRvIGFcbiAqICAgIHJlamVjdGlvbiBmb3IgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGRlY29yYXRlZCBnZW5lcmF0b3IuXG4gKi9cblEuYXN5bmMgPSBhc3luYztcbmZ1bmN0aW9uIGFzeW5jKG1ha2VHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJzZW5kXCIsIGFyZyBpcyBhIHZhbHVlXG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInRocm93XCIsIGFyZyBpcyBhbiBleGNlcHRpb25cbiAgICAgICAgZnVuY3Rpb24gY29udGludWVyKHZlcmIsIGFyZykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgLy8gVW50aWwgVjggMy4xOSAvIENocm9taXVtIDI5IGlzIHJlbGVhc2VkLCBTcGlkZXJNb25rZXkgaXMgdGhlIG9ubHlcbiAgICAgICAgICAgIC8vIGVuZ2luZSB0aGF0IGhhcyBhIGRlcGxveWVkIGJhc2Ugb2YgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBTTSdzIGdlbmVyYXRvcnMgdXNlIHRoZSBQeXRob24taW5zcGlyZWQgc2VtYW50aWNzIG9mXG4gICAgICAgICAgICAvLyBvdXRkYXRlZCBFUzYgZHJhZnRzLiAgV2Ugd291bGQgbGlrZSB0byBzdXBwb3J0IEVTNiwgYnV0IHdlJ2QgYWxzb1xuICAgICAgICAgICAgLy8gbGlrZSB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHVzZSBnZW5lcmF0b3JzIGluIGRlcGxveWVkIGJyb3dzZXJzLCBzb1xuICAgICAgICAgICAgLy8gd2UgYWxzbyBzdXBwb3J0IFB5dGhvbi1zdHlsZSBnZW5lcmF0b3JzLiAgQXQgc29tZSBwb2ludCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgICAgICAvLyB0aGlzIGJsb2NrLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIFN0b3BJdGVyYXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBFUzYgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdC52YWx1ZSwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3BpZGVyTW9ua2V5IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogUmVtb3ZlIHRoaXMgY2FzZSB3aGVuIFNNIGRvZXMgRVM2IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEoZXhjZXB0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gbWFrZUdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwibmV4dFwiKTtcbiAgICAgICAgdmFyIGVycmJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwidGhyb3dcIik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIHNwYXduIGZ1bmN0aW9uIGlzIGEgc21hbGwgd3JhcHBlciBhcm91bmQgYXN5bmMgdGhhdCBpbW1lZGlhdGVseVxuICogY2FsbHMgdGhlIGdlbmVyYXRvciBhbmQgYWxzbyBlbmRzIHRoZSBwcm9taXNlIGNoYWluLCBzbyB0aGF0IGFueVxuICogdW5oYW5kbGVkIGVycm9ycyBhcmUgdGhyb3duIGluc3RlYWQgb2YgZm9yd2FyZGVkIHRvIHRoZSBlcnJvclxuICogaGFuZGxlci4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBpdCdzIGV4dHJlbWVseSBjb21tb24gdG8gcnVuXG4gKiBnZW5lcmF0b3JzIGF0IHRoZSB0b3AtbGV2ZWwgdG8gd29yayB3aXRoIGxpYnJhcmllcy5cbiAqL1xuUS5zcGF3biA9IHNwYXduO1xuZnVuY3Rpb24gc3Bhd24obWFrZUdlbmVyYXRvcikge1xuICAgIFEuZG9uZShRLmFzeW5jKG1ha2VHZW5lcmF0b3IpKCkpO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaW50ZXJmYWNlIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbi8qKlxuICogVGhyb3dzIGEgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHRvIHN0b3AgYW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvci5cbiAqXG4gKiBUaGlzIGludGVyZmFjZSBpcyBhIHN0b3AtZ2FwIG1lYXN1cmUgdG8gc3VwcG9ydCBnZW5lcmF0b3IgcmV0dXJuXG4gKiB2YWx1ZXMgaW4gb2xkZXIgRmlyZWZveC9TcGlkZXJNb25rZXkuICBJbiBicm93c2VycyB0aGF0IHN1cHBvcnQgRVM2XG4gKiBnZW5lcmF0b3JzIGxpa2UgQ2hyb21pdW0gMjksIGp1c3QgdXNlIFwicmV0dXJuXCIgaW4geW91ciBnZW5lcmF0b3JcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHJldHVybiB2YWx1ZSBmb3IgdGhlIHN1cnJvdW5kaW5nIGdlbmVyYXRvclxuICogQHRocm93cyBSZXR1cm5WYWx1ZSBleGNlcHRpb24gd2l0aCB0aGUgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uKiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIHJldHVybiBmb28gKyBiYXI7XG4gKiB9KVxuICogLy8gT2xkZXIgU3BpZGVyTW9ua2V5IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgUS5yZXR1cm4oZm9vICsgYmFyKTtcbiAqIH0pXG4gKi9cblFbXCJyZXR1cm5cIl0gPSBfcmV0dXJuO1xuZnVuY3Rpb24gX3JldHVybih2YWx1ZSkge1xuICAgIHRocm93IG5ldyBRUmV0dXJuVmFsdWUodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBwcm9taXNlZCBmdW5jdGlvbiBkZWNvcmF0b3IgZW5zdXJlcyB0aGF0IGFueSBwcm9taXNlIGFyZ3VtZW50c1xuICogYXJlIHNldHRsZWQgYW5kIHBhc3NlZCBhcyB2YWx1ZXMgKGB0aGlzYCBpcyBhbHNvIHNldHRsZWQgYW5kIHBhc3NlZFxuICogYXMgYSB2YWx1ZSkuICBJdCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdCBvZiBhIGZ1bmN0aW9uIGlzXG4gKiBhbHdheXMgYSBwcm9taXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgYWRkID0gUS5wcm9taXNlZChmdW5jdGlvbiAoYSwgYikge1xuICogICAgIHJldHVybiBhICsgYjtcbiAqIH0pO1xuICogYWRkKFEoYSksIFEoQikpO1xuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBkZWNvcmF0ZVxuICogQHJldHVybnMge2Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW4gZGVjb3JhdGVkLlxuICovXG5RLnByb21pc2VkID0gcHJvbWlzZWQ7XG5mdW5jdGlvbiBwcm9taXNlZChjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzcHJlYWQoW3RoaXMsIGFsbChhcmd1bWVudHMpXSwgZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBzZW5kcyBhIG1lc3NhZ2UgdG8gYSB2YWx1ZSBpbiBhIGZ1dHVyZSB0dXJuXG4gKiBAcGFyYW0gb2JqZWN0KiB0aGUgcmVjaXBpZW50XG4gKiBAcGFyYW0gb3AgdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2Ugb3BlcmF0aW9uLCBlLmcuLCBcIndoZW5cIixcbiAqIEBwYXJhbSBhcmdzIGZ1cnRoZXIgYXJndW1lbnRzIHRvIGJlIGZvcndhcmRlZCB0byB0aGUgb3BlcmF0aW9uXG4gKiBAcmV0dXJucyByZXN1bHQge1Byb21pc2V9IGEgcHJvbWlzZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKi9cblEuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbmZ1bmN0aW9uIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKG9wLCBhcmdzKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAob3AsIGFyZ3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZGVmZXJyZWQucmVzb2x2ZSwgb3AsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGdldFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcHJvcGVydHkgdmFsdWVcbiAqL1xuUS5nZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciBvYmplY3Qgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0gdmFsdWUgICAgIG5ldyB2YWx1ZSBvZiBwcm9wZXJ0eVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGRlbGV0ZVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSB2YWx1ZSAgICAgYSB2YWx1ZSB0byBwb3N0LCB0eXBpY2FsbHkgYW4gYXJyYXkgb2ZcbiAqICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBhcmd1bWVudHMgZm9yIHByb21pc2VzIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgYXJlIHVsdGltYXRlbHkgYmFja2VkIHdpdGggYHJlc29sdmVgIHZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgYXMgb3Bwb3NlZCB0byB0aG9zZSBiYWNrZWQgd2l0aCBVUkxzXG4gKiAgICAgICAgICAgICAgICAgIHdoZXJlaW4gdGhlIHBvc3RlZCB2YWx1ZSBjYW4gYmUgYW55XG4gKiAgICAgICAgICAgICAgICAgIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG4vLyBib3VuZCBsb2NhbGx5IGJlY2F1c2UgaXQgaXMgdXNlZCBieSBvdGhlciBtZXRob2RzXG5RLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGludm9jYXRpb24gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblEubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMildKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUHJvbWlzZS5wcm90b3R5cGUubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSBhcmdzICAgICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmFwcGx5ID0gZnVuY3Rpb24gKG9iamVjdCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBDYWxscyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblFbXCJ0cnlcIl0gPVxuUS5mY2FsbCA9IGZ1bmN0aW9uIChvYmplY3QgLyogLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMpXSk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiwgdHJhbnNmb3JtaW5nIHJldHVybiB2YWx1ZXMgaW50byBhIGZ1bGZpbGxlZFxuICogcHJvbWlzZSBhbmQgdGhyb3duIGVycm9ycyBpbnRvIGEgcmVqZWN0ZWQgb25lLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYmluZCA9IGZ1bmN0aW9uIChvYmplY3QgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IFEob2JqZWN0KTtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5mYmluZCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIG5hbWVzIG9mIHRoZSBvd25lZCBwcm9wZXJ0aWVzIG9mIGEgcHJvbWlzZWRcbiAqIG9iamVjdCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIGtleXMgb2YgdGhlIGV2ZW50dWFsbHkgc2V0dGxlZCBvYmplY3RcbiAqL1xuUS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5LiAgSWYgYW55IG9mXG4gKiB0aGUgcHJvbWlzZXMgZ2V0cyByZWplY3RlZCwgdGhlIHdob2xlIGFycmF5IGlzIHJlamVjdGVkIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzXG4gKi9cbi8vIEJ5IE1hcmsgTWlsbGVyXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1zdHJhd21hbjpjb25jdXJyZW5jeSZyZXY9MTMwODc3NjUyMSNhbGxmdWxmaWxsZWRcblEuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICB2YXIgY291bnREb3duID0gMDtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb21pc2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9taXNlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzUHJvbWlzZShwcm9taXNlKSAmJlxuICAgICAgICAgICAgICAgIChzbmFwc2hvdCA9IHByb21pc2UuaW5zcGVjdCgpKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gc25hcHNob3QudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsrY291bnREb3duO1xuICAgICAgICAgICAgICAgIHdoZW4oXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1jb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7IGluZGV4OiBpbmRleCwgdmFsdWU6IHByb2dyZXNzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgaWYgKGNvdW50RG93biA9PT0gMCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIHRvIGJlIHNldHRsZWQsIGVpdGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiAgVGhpcyBpcyBkaXN0aW5jdCBmcm9tIGBhbGxgIHNpbmNlIHRoYXQgd291bGQgc3RvcFxuICogd2FpdGluZyBhdCB0aGUgZmlyc3QgcmVqZWN0aW9uLiAgVGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAqIGBhbGxSZXNvbHZlZGAgd2lsbCBuZXZlciBiZSByZWplY3RlZC5cbiAqIEBwYXJhbSBwcm9taXNlcyBhIHByb21pc2UgZm9yIGFuIGFycmF5IChvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcbiAqIChvciB2YWx1ZXMpXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXNcbiAqL1xuUS5hbGxSZXNvbHZlZCA9IGRlcHJlY2F0ZShhbGxSZXNvbHZlZCwgXCJhbGxSZXNvbHZlZFwiLCBcImFsbFNldHRsZWRcIik7XG5mdW5jdGlvbiBhbGxSZXNvbHZlZChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcHJvbWlzZXMgPSBhcnJheV9tYXAocHJvbWlzZXMsIFEpO1xuICAgICAgICByZXR1cm4gd2hlbihhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbFJlc29sdmVkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAc2VlIFByb21pc2UjYWxsU2V0dGxlZFxuICovXG5RLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xuICAgIHJldHVybiBRKHByb21pc2VzKS5hbGxTZXR0bGVkKCk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUShwcm9taXNlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2FyZGxlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZWdhcmRsZXNzLCByZWdhcmRsZXNzKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgZmFpbHVyZSBvZiBhIHByb21pc2UsIGdpdmluZyBhbiBvcG9ydHVuaXR5IHRvIHJlY292ZXJcbiAqIHdpdGggYSBjYWxsYmFjay4gIElmIHRoZSBnaXZlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gKiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlmIHRoZVxuICogZ2l2ZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFja1xuICovXG5RLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBsaXN0ZW5lciB0aGF0IGNhbiByZXNwb25kIHRvIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZnJvbSBhXG4gKiBwcm9taXNlJ3Mgb3JpZ2luYXRpbmcgZGVmZXJyZWQuIFRoaXMgbGlzdGVuZXIgcmVjZWl2ZXMgdGhlIGV4YWN0IGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGBgZGVmZXJyZWQubm90aWZ5YGAuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybnMgdGhlIGdpdmVuIHByb21pc2UsIHVuY2hhbmdlZFxuICovXG5RLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5mdW5jdGlvbiBwcm9ncmVzcyhvYmplY3QsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIG9ic2VydmUgdGhlIHNldHRsaW5nIG9mIGEgcHJvbWlzZSxcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBGb3J3YXJkc1xuICogdGhlIHJlc29sdXRpb24gdG8gdGhlIHJldHVybmVkIHByb21pc2Ugd2hlbiB0aGUgY2FsbGJhY2sgaXMgZG9uZS5cbiAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBjb21wbGV0aW9uLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBvYnNlcnZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlblxuICogcHJvbWlzZSwgdGFrZXMgbm8gYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSB3aGVuXG4gKiBgYGZpbmBgIGlzIGRvbmUuXG4gKi9cblEuZmluID0gLy8gWFhYIGxlZ2FjeVxuUVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdClbXCJmaW5hbGx5XCJdKGNhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZpbiA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVE9ETyBhdHRlbXB0IHRvIHJlY3ljbGUgdGhlIHJlamVjdGlvbiB3aXRoIFwidGhpc1wiLlxuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgYSBjaGFpbiBvZiBwcm9taXNlcywgZm9yY2luZyByZWplY3Rpb25zIHRvIGJlXG4gKiB0aHJvd24gYXMgZXhjZXB0aW9ucy5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBhdCB0aGUgZW5kIG9mIGEgY2hhaW4gb2YgcHJvbWlzZXNcbiAqIEByZXR1cm5zIG5vdGhpbmdcbiAqL1xuUS5kb25lID0gZnVuY3Rpb24gKG9iamVjdCwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRvbmUoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHZhciBvblVuaGFuZGxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGZvcndhcmQgdG8gYSBmdXR1cmUgdHVybiBzbyB0aGF0IGBgd2hlbmBgXG4gICAgICAgIC8vIGRvZXMgbm90IGNhdGNoIGl0IGFuZCB0dXJuIGl0IGludG8gYSByZWplY3Rpb24uXG4gICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IGBuZXh0VGlja2BpbmcgdmlhIGFuIHVubmVjZXNzYXJ5IGB3aGVuYC5cbiAgICB2YXIgcHJvbWlzZSA9IGZ1bGZpbGxlZCB8fCByZWplY3RlZCB8fCBwcm9ncmVzcyA/XG4gICAgICAgIHRoaXMudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykgOlxuICAgICAgICB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgICAgb25VbmhhbmRsZWRFcnJvciA9IHByb2Nlc3MuZG9tYWluLmJpbmQob25VbmhhbmRsZWRFcnJvcik7XG4gICAgfVxuXG4gICAgcHJvbWlzZS50aGVuKHZvaWQgMCwgb25VbmhhbmRsZWRFcnJvcik7XG59O1xuXG4vKipcbiAqIENhdXNlcyBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgaWYgaXQgZG9lcyBub3QgZ2V0IGZ1bGZpbGxlZCBiZWZvcmVcbiAqIHNvbWUgbWlsbGlzZWNvbmRzIHRpbWUgb3V0LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzIHRpbWVvdXRcbiAqIEBwYXJhbSB7QW55Kn0gY3VzdG9tIGVycm9yIG1lc3NhZ2Ugb3IgRXJyb3Igb2JqZWN0IChvcHRpb25hbClcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgaWYgaXQgaXNcbiAqIGZ1bGZpbGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAqL1xuUS50aW1lb3V0ID0gZnVuY3Rpb24gKG9iamVjdCwgbXMsIGVycm9yKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aW1lb3V0KG1zLCBlcnJvcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBlcnJvcikge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVycm9yIHx8IFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IgfHwgXCJUaW1lZCBvdXQgYWZ0ZXIgXCIgKyBtcyArIFwiIG1zXCIpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IFwiRVRJTUVET1VUXCI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICB9LCBtcyk7XG5cbiAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9LCBkZWZlcnJlZC5ub3RpZnkpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgKG9yIHByb21pc2VkIHZhbHVlKSwgc29tZVxuICogbWlsbGlzZWNvbmRzIGFmdGVyIGl0IHJlc29sdmVkLiBQYXNzZXMgcmVqZWN0aW9ucyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBhZnRlciBtaWxsaXNlY29uZHNcbiAqIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UuXG4gKiBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSByZWplY3RzLCB0aGF0IGlzIHBhc3NlZCBpbW1lZGlhdGVseS5cbiAqL1xuUS5kZWxheSA9IGZ1bmN0aW9uIChvYmplY3QsIHRpbWVvdXQpIHtcbiAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kZWxheSh0aW1lb3V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGFzIGFuIGFycmF5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogICAgICBRLm5mYXBwbHkoRlMucmVhZEZpbGUsIFtfX2ZpbGVuYW1lXSlcbiAqICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqICAgICAgfSlcbiAqXG4gKi9cblEubmZhcHBseSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgaW5kaXZpZHVhbGx5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmNhbGwoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpXG4gKiAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogfSlcbiAqXG4gKi9cblEubmZjYWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIE5vZGVKUyBjb250aW51YXRpb24gcGFzc2luZyBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbiBlcXVpdmFsZW50XG4gKiB2ZXJzaW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmJpbmQoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpKFwidXRmLThcIilcbiAqIC50aGVuKGNvbnNvbGUubG9nKVxuICogLmRvbmUoKVxuICovXG5RLm5mYmluZCA9XG5RLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIFEoY2FsbGJhY2spLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZiaW5kID1cblByb21pc2UucHJvdG90eXBlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEuZGVub2RlaWZ5LmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG5RLm5iaW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFEoYm91bmQpLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmJpbmQgPSBmdW5jdGlvbiAoLyp0aGlzcCwgLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDApO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5uYmluZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIHdpdGggYSBnaXZlbiBhcnJheSBvZiBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZCBjYWxsYmFjay5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLm5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkubnBvc3QobmFtZSwgYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLm5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzIHx8IFtdKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2ssIGZvcndhcmRpbmcgdGhlIGdpdmVuIHZhcmlhZGljIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkXG4gKiBjYWxsYmFjayBhcmd1bWVudC5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSAuLi5hcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFjayB3aWxsXG4gKiBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblEubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUS5uaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5Qcm9taXNlLnByb3RvdHlwZS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5Qcm9taXNlLnByb3RvdHlwZS5uaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogSWYgYSBmdW5jdGlvbiB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgYm90aCBOb2RlIGNvbnRpbnVhdGlvbi1wYXNzaW5nLXN0eWxlIGFuZFxuICogcHJvbWlzZS1yZXR1cm5pbmctc3R5bGUsIGl0IGNhbiBlbmQgaXRzIGludGVybmFsIHByb21pc2UgY2hhaW4gd2l0aFxuICogYG5vZGVpZnkobm9kZWJhY2spYCwgZm9yd2FyZGluZyB0aGUgb3B0aW9uYWwgbm9kZWJhY2sgYXJndW1lbnQuICBJZiB0aGUgdXNlclxuICogZWxlY3RzIHRvIHVzZSBhIG5vZGViYWNrLCB0aGUgcmVzdWx0IHdpbGwgYmUgc2VudCB0aGVyZS4gIElmIHRoZXkgZG8gbm90XG4gKiBwYXNzIGEgbm9kZWJhY2ssIHRoZXkgd2lsbCByZWNlaXZlIHRoZSByZXN1bHQgcHJvbWlzZS5cbiAqIEBwYXJhbSBvYmplY3QgYSByZXN1bHQgKG9yIGEgcHJvbWlzZSBmb3IgYSByZXN1bHQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBub2RlYmFjayBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2tcbiAqIEByZXR1cm5zIGVpdGhlciB0aGUgcHJvbWlzZSBvciBub3RoaW5nXG4gKi9cblEubm9kZWlmeSA9IG5vZGVpZnk7XG5mdW5jdGlvbiBub2RlaWZ5KG9iamVjdCwgbm9kZWJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5vZGVpZnkobm9kZWJhY2spO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrKSB7XG4gICAgaWYgKG5vZGViYWNrKSB7XG4gICAgICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG4vLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxudmFyIHFFbmRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcblxucmV0dXJuIFE7XG5cbn0pO1xuIiwiLypcbiAqIFFhbmltYXRpb25mcmFtZS5qcyAtIFByb21pc2lmaWVkIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aXRoIFFcbiAqL1xuLypqc2xpbnQgbmV3Y2FwOiB0cnVlICovXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LlFhbmltYXRpb25GcmFtZSA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KShmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIEltcG9ydCBRXG4gIHZhciBRID0gd2luZG93LlEgfHwgcmVxdWlyZShcInFcIik7XG5cbiAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsXG4gIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XG4gICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICB9O1xuICB9KSgpO1xuXG4gIC8vIFFhbmltYXRpb25GcmFtZShmOiBmdW5jdGlvbikgPT4gcHJvbWlzZSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgZlxuICAvLyAtLS1cbiAgLy9cbiAgdmFyIFFhbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGQgPSBRLmRlZmVyKCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQucmVzb2x2ZShmKCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkLnJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZC5wcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBRYW5pbWF0aW9uRnJhbWU7XG59KTtcbiIsIi8vIFRoaXMgbGlicmFyeSBzdGFydGVkIGFzIGFuIGV4cGVyaW1lbnQgdG8gc2VlIGhvdyBzbWFsbCBJIGNvdWxkIG1ha2Vcbi8vIGEgZnVuY3Rpb25hbCByb3V0ZXIuIEl0IGhhcyBzaW5jZSBiZWVuIG9wdGltaXplZCAoYW5kIHRodXMgZ3Jvd24pLlxuLy8gVGhlIHJlZHVuZGFuY3kgYW5kIGluZWxlZ2FuY2UgaGVyZSBpcyBmb3IgdGhlIHNha2Ugb2YgZWl0aGVyIHNpemVcbi8vIG9yIHNwZWVkLlxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIHZhciBkZWZpbmUgPSByb290LmRlZmluZTtcblxuICBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3JsaXRlJywgW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5SbGl0ZSA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcm91dGVzID0ge30sXG4gICAgICAgIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZ1bmN0aW9uIG5vb3AocykgeyByZXR1cm4gczsgfVxuXG4gICAgZnVuY3Rpb24gc2FuaXRpemUodXJsKSB7XG4gICAgICB+dXJsLmluZGV4T2YoJy8/JykgJiYgKHVybCA9IHVybC5yZXBsYWNlKCcvPycsICc/JykpO1xuICAgICAgdXJsWzBdID09ICcvJyAmJiAodXJsID0gdXJsLnNsaWNlKDEpKTtcbiAgICAgIHVybFt1cmwubGVuZ3RoIC0gMV0gPT0gJy8nICYmICh1cmwgPSB1cmwuc2xpY2UoMCwgLTEpKTtcblxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzVXJsKHVybCwgZXNjKSB7XG4gICAgICB2YXIgcGllY2VzID0gdXJsLnNwbGl0KCcvJyksXG4gICAgICAgICAgcnVsZXMgPSByb3V0ZXMsXG4gICAgICAgICAgcGFyYW1zID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aCAmJiBydWxlczsgKytpKSB7XG4gICAgICAgIHZhciBwaWVjZSA9IGVzYyhwaWVjZXNbaV0pO1xuICAgICAgICBydWxlcyA9IHJ1bGVzW3BpZWNlLnRvTG93ZXJDYXNlKCldIHx8IHJ1bGVzWyc6J107XG4gICAgICAgIHJ1bGVzICYmIHJ1bGVzWyd+J10gJiYgKHBhcmFtc1tydWxlc1snfiddXSA9IHBpZWNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1bGVzICYmIHtcbiAgICAgICAgY2I6IHJ1bGVzWydAJ10sXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NRdWVyeSh1cmwsIGN0eCwgZXNjKSB7XG4gICAgICBpZiAodXJsICYmIGN0eC5jYikge1xuICAgICAgICB2YXIgaGFzaCA9IHVybC5pbmRleE9mKCcjJyksXG4gICAgICAgICAgICBxdWVyeSA9IChoYXNoIDwgMCA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoKSkuc3BsaXQoJyYnKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIG5hbWVWYWx1ZSA9IHF1ZXJ5W2ldLnNwbGl0KCc9Jyk7XG5cbiAgICAgICAgICBjdHgucGFyYW1zW25hbWVWYWx1ZVswXV0gPSBlc2MobmFtZVZhbHVlWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb2t1cCh1cmwpIHtcbiAgICAgIHZhciBxdWVyeVNwbGl0ID0gc2FuaXRpemUodXJsKS5zcGxpdCgnPycpLFxuICAgICAgICAgIGVzYyA9IH51cmwuaW5kZXhPZignJScpID8gZGVjb2RlIDogbm9vcDtcblxuICAgICAgcmV0dXJuIHByb2Nlc3NRdWVyeShxdWVyeVNwbGl0WzFdLCBwcm9jZXNzVXJsKHF1ZXJ5U3BsaXRbMF0sIGVzYykgfHwge30sIGVzYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZDogZnVuY3Rpb24ocm91dGUsIGhhbmRsZXIpIHtcblxuICAgICAgICB2YXIgcGllY2VzID0gcm91dGUuc3BsaXQoJy8nKSxcbiAgICAgICAgICAgIHJ1bGVzID0gcm91dGVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHBpZWNlID0gcGllY2VzW2ldLFxuICAgICAgICAgICAgICBuYW1lID0gcGllY2VbMF0gPT0gJzonID8gJzonIDogcGllY2UudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIHJ1bGVzID0gcnVsZXNbbmFtZV0gfHwgKHJ1bGVzW25hbWVdID0ge30pO1xuXG4gICAgICAgICAgbmFtZSA9PSAnOicgJiYgKHJ1bGVzWyd+J10gPSBwaWVjZS5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBydWxlc1snQCddID0gaGFuZGxlcjtcbiAgICAgIH0sXG5cbiAgICAgIGV4aXN0czogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gISFsb29rdXAodXJsKS5jYjtcbiAgICAgIH0sXG5cbiAgICAgIGxvb2t1cDogbG9va3VwLFxuXG4gICAgICBydW46IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbG9va3VwKHVybCk7XG5cbiAgICAgICAgcmVzdWx0LmNiICYmIHJlc3VsdC5jYih7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgcGFyYW1zOiByZXN1bHQucGFyYW1zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAhIXJlc3VsdC5jYjtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufSkpO1xuIiwiLypqc2xpbnQgb25ldmFyOnRydWUsIHVuZGVmOnRydWUsIG5ld2NhcDp0cnVlLCByZWdleHA6dHJ1ZSwgYml0d2lzZTp0cnVlLCBtYXhlcnI6NTAsIGluZGVudDo0LCB3aGl0ZTpmYWxzZSwgbm9tZW46ZmFsc2UsIHBsdXNwbHVzOmZhbHNlICovXG4vKmdsb2JhbCBkZWZpbmU6ZmFsc2UsIHJlcXVpcmU6ZmFsc2UsIGV4cG9ydHM6ZmFsc2UsIG1vZHVsZTpmYWxzZSwgc2lnbmFsczpmYWxzZSAqL1xuXG4vKiogQGxpY2Vuc2VcbiAqIEpTIFNpZ25hbHMgPGh0dHA6Ly9taWxsZXJtZWRlaXJvcy5naXRodWIuY29tL2pzLXNpZ25hbHMvPlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBBdXRob3I6IE1pbGxlciBNZWRlaXJvc1xuICogVmVyc2lvbjogMS4wLjAgLSBCdWlsZDogMjY4ICgyMDEyLzExLzI5IDA1OjQ4IFBNKVxuICovXG5cbihmdW5jdGlvbihnbG9iYWwpe1xuXG4gICAgLy8gU2lnbmFsQmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgdGhhdCByZXByZXNlbnRzIGEgYmluZGluZyBiZXR3ZWVuIGEgU2lnbmFsIGFuZCBhIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgICAqIDxiciAvPi0gPHN0cm9uZz5UaGlzIGlzIGFuIGludGVybmFsIGNvbnN0cnVjdG9yIGFuZCBzaG91bGRuJ3QgYmUgY2FsbGVkIGJ5IHJlZ3VsYXIgdXNlcnMuPC9zdHJvbmc+XG4gICAgICogPGJyIC8+LSBpbnNwaXJlZCBieSBKb2EgRWJlcnQgQVMzIFNpZ25hbEJpbmRpbmcgYW5kIFJvYmVydCBQZW5uZXIncyBTbG90IGNsYXNzZXMuXG4gICAgICogQGF1dGhvciBNaWxsZXIgTWVkZWlyb3NcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAbmFtZSBTaWduYWxCaW5kaW5nXG4gICAgICogQHBhcmFtIHtTaWduYWx9IHNpZ25hbCBSZWZlcmVuY2UgdG8gU2lnbmFsIG9iamVjdCB0aGF0IGxpc3RlbmVyIGlzIGN1cnJlbnRseSBib3VuZCB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc09uY2UgSWYgYmluZGluZyBzaG91bGQgYmUgZXhlY3V0ZWQganVzdCBvbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XSBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldIFRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuIChkZWZhdWx0ID0gMCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2lnbmFsQmluZGluZyhzaWduYWwsIGxpc3RlbmVyLCBpc09uY2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlciBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2lnbmFsLlxuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYmluZGluZyBzaG91bGQgYmUgZXhlY3V0ZWQganVzdCBvbmNlLlxuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc09uY2UgPSBpc09uY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRleHQgb24gd2hpY2ggbGlzdGVuZXIgd2lsbCBiZSBleGVjdXRlZCAob2JqZWN0IHRoYXQgc2hvdWxkIHJlcHJlc2VudCB0aGUgYHRoaXNgIHZhcmlhYmxlIGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbikuXG4gICAgICAgICAqIEBtZW1iZXJPZiBTaWduYWxCaW5kaW5nLnByb3RvdHlwZVxuICAgICAgICAgKiBAbmFtZSBjb250ZXh0XG4gICAgICAgICAqIEB0eXBlIE9iamVjdHx1bmRlZmluZWR8bnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbGlzdGVuZXJDb250ZXh0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gU2lnbmFsIG9iamVjdCB0aGF0IGxpc3RlbmVyIGlzIGN1cnJlbnRseSBib3VuZCB0by5cbiAgICAgICAgICogQHR5cGUgU2lnbmFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaWduYWwgPSBzaWduYWw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbmVyIHByaW9yaXR5XG4gICAgICAgICAqIEB0eXBlIE51bWJlclxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuICAgIH1cblxuICAgIFNpZ25hbEJpbmRpbmcucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBiaW5kaW5nIGlzIGFjdGl2ZSBhbmQgc2hvdWxkIGJlIGV4ZWN1dGVkLlxuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmUgOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHBhcmFtZXRlcnMgcGFzc2VkIHRvIGxpc3RlbmVyIGR1cmluZyBgU2lnbmFsLmRpc3BhdGNoYCBhbmQgYFNpZ25hbEJpbmRpbmcuZXhlY3V0ZWAuIChjdXJyaWVkIHBhcmFtZXRlcnMpXG4gICAgICAgICAqIEB0eXBlIEFycmF5fG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHBhcmFtcyA6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGwgbGlzdGVuZXIgcGFzc2luZyBhcmJpdHJhcnkgcGFyYW1ldGVycy5cbiAgICAgICAgICogPHA+SWYgYmluZGluZyB3YXMgYWRkZWQgdXNpbmcgYFNpZ25hbC5hZGRPbmNlKClgIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gc2lnbmFsIGRpc3BhdGNoIHF1ZXVlLCB0aGlzIG1ldGhvZCBpcyB1c2VkIGludGVybmFsbHkgZm9yIHRoZSBzaWduYWwgZGlzcGF0Y2guPC9wPlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFyYW1zQXJyXSBBcnJheSBvZiBwYXJhbWV0ZXJzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgbGlzdGVuZXJcbiAgICAgICAgICogQHJldHVybiB7Kn0gVmFsdWUgcmV0dXJuZWQgYnkgdGhlIGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXhlY3V0ZSA6IGZ1bmN0aW9uIChwYXJhbXNBcnIpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyUmV0dXJuLCBwYXJhbXM7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUgJiYgISF0aGlzLl9saXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMucGFyYW1zPyB0aGlzLnBhcmFtcy5jb25jYXQocGFyYW1zQXJyKSA6IHBhcmFtc0FycjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyUmV0dXJuID0gdGhpcy5fbGlzdGVuZXIuYXBwbHkodGhpcy5jb250ZXh0LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc09uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlclJldHVybjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0YWNoIGJpbmRpbmcgZnJvbSBzaWduYWwuXG4gICAgICAgICAqIC0gYWxpYXMgdG86IG15U2lnbmFsLnJlbW92ZShteUJpbmRpbmcuZ2V0TGlzdGVuZXIoKSk7XG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9IEhhbmRsZXIgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNpZ25hbCBvciBgbnVsbGAgaWYgYmluZGluZyB3YXMgcHJldmlvdXNseSBkZXRhY2hlZC5cbiAgICAgICAgICovXG4gICAgICAgIGRldGFjaCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQm91bmQoKT8gdGhpcy5fc2lnbmFsLnJlbW92ZSh0aGlzLl9saXN0ZW5lciwgdGhpcy5jb250ZXh0KSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBiaW5kaW5nIGlzIHN0aWxsIGJvdW5kIHRvIHRoZSBzaWduYWwgYW5kIGhhdmUgYSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGlzQm91bmQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCEhdGhpcy5fc2lnbmFsICYmICEhdGhpcy5fbGlzdGVuZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiBTaWduYWxCaW5kaW5nIHdpbGwgb25seSBiZSBleGVjdXRlZCBvbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNPbmNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzT25jZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IEhhbmRsZXIgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICovXG4gICAgICAgIGdldExpc3RlbmVyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWx9IFNpZ25hbCB0aGF0IGxpc3RlbmVyIGlzIGN1cnJlbnRseSBib3VuZCB0by5cbiAgICAgICAgICovXG4gICAgICAgIGdldFNpZ25hbCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZGVzdHJveSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaWduYWw7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jb250ZXh0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tTaWduYWxCaW5kaW5nIGlzT25jZTonICsgdGhpcy5faXNPbmNlICsnLCBpc0JvdW5kOicrIHRoaXMuaXNCb3VuZCgpICsnLCBhY3RpdmU6JyArIHRoaXMuYWN0aXZlICsgJ10nO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbi8qZ2xvYmFsIFNpZ25hbEJpbmRpbmc6ZmFsc2UqL1xuXG4gICAgLy8gU2lnbmFsIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCBmbk5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnbGlzdGVuZXIgaXMgYSByZXF1aXJlZCBwYXJhbSBvZiB7Zm59KCkgYW5kIHNob3VsZCBiZSBhIEZ1bmN0aW9uLicucmVwbGFjZSgne2ZufScsIGZuTmFtZSkgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBldmVudCBicm9hZGNhc3RlclxuICAgICAqIDxiciAvPi0gaW5zcGlyZWQgYnkgUm9iZXJ0IFBlbm5lcidzIEFTMyBTaWduYWxzLlxuICAgICAqIEBuYW1lIFNpZ25hbFxuICAgICAqIEBhdXRob3IgTWlsbGVyIE1lZGVpcm9zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2lnbmFsKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgQXJyYXkuPFNpZ25hbEJpbmRpbmc+XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wcmV2UGFyYW1zID0gbnVsbDtcblxuICAgICAgICAvLyBlbmZvcmNlIGRpc3BhdGNoIHRvIGF3YXlzIHdvcmsgb24gc2FtZSBjb250ZXh0ICgjNDcpXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBTaWduYWwucHJvdG90eXBlLmRpc3BhdGNoLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgU2lnbmFsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2lnbmFscyBWZXJzaW9uIE51bWJlclxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICogQGNvbnN0XG4gICAgICAgICAqL1xuICAgICAgICBWRVJTSU9OIDogJzEuMC4wJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgU2lnbmFsIHNob3VsZCBrZWVwIHJlY29yZCBvZiBwcmV2aW91c2x5IGRpc3BhdGNoZWQgcGFyYW1ldGVycyBhbmRcbiAgICAgICAgICogYXV0b21hdGljYWxseSBleGVjdXRlIGxpc3RlbmVyIGR1cmluZyBgYWRkKClgL2BhZGRPbmNlKClgIGlmIFNpZ25hbCB3YXNcbiAgICAgICAgICogYWxyZWFkeSBkaXNwYXRjaGVkIGJlZm9yZS5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgbWVtb3JpemUgOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Nob3VsZFByb3BhZ2F0ZSA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIFNpZ25hbCBpcyBhY3RpdmUgYW5kIHNob3VsZCBicm9hZGNhc3QgZXZlbnRzLlxuICAgICAgICAgKiA8cD48c3Ryb25nPklNUE9SVEFOVDo8L3N0cm9uZz4gU2V0dGluZyB0aGlzIHByb3BlcnR5IGR1cmluZyBhIGRpc3BhdGNoIHdpbGwgb25seSBhZmZlY3QgdGhlIG5leHQgZGlzcGF0Y2gsIGlmIHlvdSB3YW50IHRvIHN0b3AgdGhlIHByb3BhZ2F0aW9uIG9mIGEgc2lnbmFsIHVzZSBgaGFsdCgpYCBpbnN0ZWFkLjwvcD5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlIDogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc09uY2VcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0ZW5lckNvbnRleHRdXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldXG4gICAgICAgICAqIEByZXR1cm4ge1NpZ25hbEJpbmRpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfcmVnaXN0ZXJMaXN0ZW5lciA6IGZ1bmN0aW9uIChsaXN0ZW5lciwgaXNPbmNlLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG5cbiAgICAgICAgICAgIHZhciBwcmV2SW5kZXggPSB0aGlzLl9pbmRleE9mTGlzdGVuZXIobGlzdGVuZXIsIGxpc3RlbmVyQ29udGV4dCksXG4gICAgICAgICAgICAgICAgYmluZGluZztcblxuICAgICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbcHJldkluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5pc09uY2UoKSAhPT0gaXNPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBhZGQnKyAoaXNPbmNlPyAnJyA6ICdPbmNlJykgKycoKSB0aGVuIGFkZCcrICghaXNPbmNlPyAnJyA6ICdPbmNlJykgKycoKSB0aGUgc2FtZSBsaXN0ZW5lciB3aXRob3V0IHJlbW92aW5nIHRoZSByZWxhdGlvbnNoaXAgZmlyc3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gbmV3IFNpZ25hbEJpbmRpbmcodGhpcywgbGlzdGVuZXIsIGlzT25jZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQmluZGluZyhiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5tZW1vcml6ZSAmJiB0aGlzLl9wcmV2UGFyYW1zKXtcbiAgICAgICAgICAgICAgICBiaW5kaW5nLmV4ZWN1dGUodGhpcy5fcHJldlBhcmFtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1NpZ25hbEJpbmRpbmd9IGJpbmRpbmdcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9hZGRCaW5kaW5nIDogZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIC8vc2ltcGxpZmllZCBpbnNlcnRpb24gc29ydFxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICBkbyB7IC0tbjsgfSB3aGlsZSAodGhpcy5fYmluZGluZ3Nbbl0gJiYgYmluZGluZy5fcHJpb3JpdHkgPD0gdGhpcy5fYmluZGluZ3Nbbl0uX3ByaW9yaXR5KTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLnNwbGljZShuICsgMSwgMCwgYmluZGluZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9pbmRleE9mTGlzdGVuZXIgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fYmluZGluZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGN1cjtcbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICBjdXIgPSB0aGlzLl9iaW5kaW5nc1tuXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLl9saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiYgY3VyLmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBpZiBsaXN0ZW5lciB3YXMgYXR0YWNoZWQgdG8gU2lnbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIFNpZ25hbCBoYXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGhhcyA6IGZ1bmN0aW9uIChsaXN0ZW5lciwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lciwgY29udGV4dCkgIT09IC0xO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgc2lnbmFsLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBTaWduYWwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0ZW5lckNvbnRleHRdIENvbnRleHQgb24gd2hpY2ggbGlzdGVuZXIgd2lsbCBiZSBleGVjdXRlZCAob2JqZWN0IHRoYXQgc2hvdWxkIHJlcHJlc2VudCB0aGUgYHRoaXNgIHZhcmlhYmxlIGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbikuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldIFRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuIExpc3RlbmVycyB3aXRoIGhpZ2hlciBwcmlvcml0eSB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBsaXN0ZW5lcnMgd2l0aCBsb3dlciBwcmlvcml0eS4gTGlzdGVuZXJzIHdpdGggc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgd2VyZSBhZGRlZC4gKGRlZmF1bHQgPSAwKVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfSBBbiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIGJldHdlZW4gdGhlIFNpZ25hbCBhbmQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBhZGQgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIsICdhZGQnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmVyLCBmYWxzZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBsaXN0ZW5lciB0byB0aGUgc2lnbmFsIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgYWZ0ZXIgZmlyc3QgZXhlY3V0aW9uICh3aWxsIGJlIGV4ZWN1dGVkIG9ubHkgb25jZSkuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFNpZ25hbCBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpc3RlbmVyQ29udGV4dF0gQ29udGV4dCBvbiB3aGljaCBsaXN0ZW5lciB3aWxsIGJlIGV4ZWN1dGVkIChvYmplY3QgdGhhdCBzaG91bGQgcmVwcmVzZW50IHRoZSBgdGhpc2AgdmFyaWFibGUgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9uKS5cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcmlvcml0eV0gVGhlIHByaW9yaXR5IGxldmVsIG9mIHRoZSBldmVudCBsaXN0ZW5lci4gTGlzdGVuZXJzIHdpdGggaGlnaGVyIHByaW9yaXR5IHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIGxpc3RlbmVycyB3aXRoIGxvd2VyIHByaW9yaXR5LiBMaXN0ZW5lcnMgd2l0aCBzYW1lIHByaW9yaXR5IGxldmVsIHdpbGwgYmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgb3JkZXIgYXMgdGhleSB3ZXJlIGFkZGVkLiAoZGVmYXVsdCA9IDApXG4gICAgICAgICAqIEByZXR1cm4ge1NpZ25hbEJpbmRpbmd9IEFuIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJpbmRpbmcgYmV0d2VlbiB0aGUgU2lnbmFsIGFuZCBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGFkZE9uY2UgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIsICdhZGRPbmNlJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lciwgdHJ1ZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIHNpbmdsZSBsaXN0ZW5lciBmcm9tIHRoZSBkaXNwYXRjaCBxdWV1ZS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgSGFuZGxlciBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIEV4ZWN1dGlvbiBjb250ZXh0IChzaW5jZSB5b3UgY2FuIGFkZCB0aGUgc2FtZSBoYW5kbGVyIG11bHRpcGxlIHRpbWVzIGlmIGV4ZWN1dGluZyBpbiBhIGRpZmZlcmVudCBjb250ZXh0KS5cbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IExpc3RlbmVyIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmUgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIsICdyZW1vdmUnKTtcblxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9pbmRleE9mTGlzdGVuZXIobGlzdGVuZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ3NbaV0uX2Rlc3Ryb3koKTsgLy9ubyByZWFzb24gdG8gYSBTaWduYWxCaW5kaW5nIGV4aXN0IGlmIGl0IGlzbid0IGF0dGFjaGVkIHRvIGEgc2lnbmFsXG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmcm9tIHRoZSBTaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVBbGwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nc1tuXS5fZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmluZGluZ3MubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoZSBTaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXROdW1MaXN0ZW5lcnMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCwgYmxvY2tpbmcgdGhlIGRpc3BhdGNoIHRvIG5leHQgbGlzdGVuZXJzIG9uIHRoZSBxdWV1ZS5cbiAgICAgICAgICogPHA+PHN0cm9uZz5JTVBPUlRBTlQ6PC9zdHJvbmc+IHNob3VsZCBiZSBjYWxsZWQgb25seSBkdXJpbmcgc2lnbmFsIGRpc3BhdGNoLCBjYWxsaW5nIGl0IGJlZm9yZS9hZnRlciBkaXNwYXRjaCB3b24ndCBhZmZlY3Qgc2lnbmFsIGJyb2FkY2FzdC48L3A+XG4gICAgICAgICAqIEBzZWUgU2lnbmFsLnByb3RvdHlwZS5kaXNhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBoYWx0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc2hvdWxkUHJvcGFnYXRlID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BhdGNoL0Jyb2FkY2FzdCBTaWduYWwgdG8gYWxsIGxpc3RlbmVycyBhZGRlZCB0byB0aGUgcXVldWUuXG4gICAgICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcmFtc10gUGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gZWFjaCBoYW5kbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGF0Y2ggOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoISB0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmFtc0FyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgbiA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBiaW5kaW5ncztcblxuICAgICAgICAgICAgaWYgKHRoaXMubWVtb3JpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2UGFyYW1zID0gcGFyYW1zQXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISBuKSB7XG4gICAgICAgICAgICAgICAgLy9zaG91bGQgY29tZSBhZnRlciBtZW1vcml6ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncy5zbGljZSgpOyAvL2Nsb25lIGFycmF5IGluIGNhc2UgYWRkL3JlbW92ZSBpdGVtcyBkdXJpbmcgZGlzcGF0Y2hcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IHRydWU7IC8vaW4gY2FzZSBgaGFsdGAgd2FzIGNhbGxlZCBiZWZvcmUgZGlzcGF0Y2ggb3IgZHVyaW5nIHRoZSBwcmV2aW91cyBkaXNwYXRjaC5cblxuICAgICAgICAgICAgLy9leGVjdXRlIGFsbCBjYWxsYmFja3MgdW50aWwgZW5kIG9mIHRoZSBsaXN0IG9yIHVudGlsIGEgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgIG9yIHN0b3BzIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAvL3JldmVyc2UgbG9vcCBzaW5jZSBsaXN0ZW5lcnMgd2l0aCBoaWdoZXIgcHJpb3JpdHkgd2lsbCBiZSBhZGRlZCBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBkbyB7IG4tLTsgfSB3aGlsZSAoYmluZGluZ3Nbbl0gJiYgdGhpcy5fc2hvdWxkUHJvcGFnYXRlICYmIGJpbmRpbmdzW25dLmV4ZWN1dGUocGFyYW1zQXJyKSAhPT0gZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3JnZXQgbWVtb3JpemVkIGFyZ3VtZW50cy5cbiAgICAgICAgICogQHNlZSBTaWduYWwubWVtb3JpemVcbiAgICAgICAgICovXG4gICAgICAgIGZvcmdldCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLl9wcmV2UGFyYW1zID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFsbCBiaW5kaW5ncyBmcm9tIHNpZ25hbCBhbmQgZGVzdHJveSBhbnkgcmVmZXJlbmNlIHRvIGV4dGVybmFsIG9iamVjdHMgKGRlc3Ryb3kgU2lnbmFsIG9iamVjdCkuXG4gICAgICAgICAqIDxwPjxzdHJvbmc+SU1QT1JUQU5UOjwvc3Ryb25nPiBjYWxsaW5nIGFueSBtZXRob2Qgb24gdGhlIHNpZ25hbCBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRpc3Bvc2Ugd2lsbCB0aHJvdyBlcnJvcnMuPC9wPlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYmluZGluZ3M7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJldlBhcmFtcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbU2lnbmFsIGFjdGl2ZTonKyB0aGlzLmFjdGl2ZSArJyBudW1MaXN0ZW5lcnM6JysgdGhpcy5nZXROdW1MaXN0ZW5lcnMoKSArJ10nO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbiAgICAvLyBOYW1lc3BhY2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgbmFtZXNwYWNlXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBuYW1lIHNpZ25hbHNcbiAgICAgKi9cbiAgICB2YXIgc2lnbmFscyA9IFNpZ25hbDtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBldmVudCBicm9hZGNhc3RlclxuICAgICAqIEBzZWUgU2lnbmFsXG4gICAgICovXG4gICAgLy8gYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChzZWUgI2doLTQ0KVxuICAgIHNpZ25hbHMuU2lnbmFsID0gU2lnbmFsO1xuXG5cblxuICAgIC8vZXhwb3J0cyB0byBtdWx0aXBsZSBlbnZpcm9ubWVudHNcbiAgICBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpeyAvL0FNRFxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmFsczsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyl7IC8vbm9kZVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHNpZ25hbHM7XG4gICAgfSBlbHNlIHsgLy9icm93c2VyXG4gICAgICAgIC8vdXNlIHN0cmluZyBiZWNhdXNlIG9mIEdvb2dsZSBjbG9zdXJlIGNvbXBpbGVyIEFEVkFOQ0VEX01PREVcbiAgICAgICAgLypqc2xpbnQgc3ViOnRydWUgKi9cbiAgICAgICAgZ2xvYmFsWydzaWduYWxzJ10gPSBzaWduYWxzO1xuICAgIH1cblxufSh0aGlzKSk7XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKS5zdHlsZSxcbiAgICBwcmVmaXhlcyA9ICdPIG1zIE1veiB3ZWJraXQnLnNwbGl0KCcgJyksXG4gICAgaGFzUHJlZml4ID0gL14ob3xtc3xtb3p8d2Via2l0KS8sXG4gICAgdXBwZXIgPSAvKFtBLVpdKS9nLFxuICAgIG1lbW8gPSB7fTtcblxuZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgcmV0dXJuIChrZXkgaW4gbWVtbykgPyBtZW1vW2tleV0gOiBtZW1vW2tleV0gPSBwcmVmaXgoa2V5KTtcbn1cblxuZnVuY3Rpb24gcHJlZml4KGtleSl7XG4gICAgdmFyIGNhcGl0YWxpemVkS2V5ID0ga2V5LnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uKHMsIG1hdGNoKXtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgaSA9IHByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgbmFtZTtcblxuICAgIGlmIChzdHlsZVtjYXBpdGFsaXplZEtleV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGNhcGl0YWxpemVkS2V5O1xuXG4gICAgY2FwaXRhbGl6ZWRLZXkgPSBjYXBpdGFsaXplKGtleSk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIG5hbWUgPSBwcmVmaXhlc1tpXSArIGNhcGl0YWxpemVkS2V5O1xuICAgICAgICBpZiAoc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gcHJlZml4ICcgKyBrZXkpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cil7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuZnVuY3Rpb24gZGFzaGVkUHJlZml4KGtleSl7XG4gICAgdmFyIHByZWZpeGVkS2V5ID0gZ2V0KGtleSksXG4gICAgICAgIHVwcGVyID0gLyhbQS1aXSkvZztcblxuICAgIGlmICh1cHBlci50ZXN0KHByZWZpeGVkS2V5KSkge1xuICAgICAgICBwcmVmaXhlZEtleSA9IChoYXNQcmVmaXgudGVzdChwcmVmaXhlZEtleSkgPyAnLScgOiAnJykgKyBwcmVmaXhlZEtleS5yZXBsYWNlKHVwcGVyLCAnLSQxJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeGVkS2V5LnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xubW9kdWxlLmV4cG9ydHMuZGFzaCA9IGRhc2hlZFByZWZpeDtcbiIsIi8vIFphbmltby5qcyAtIFByb21pc2UgYmFzZWQgQ1NTMyB0cmFuc2l0aW9uc1xuLy8gKGMpIDIwMTEtMjAxNCBQYXVsIFBhbnNlcnJpZXVcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUSA9IHJlcXVpcmUoJ3EnKSxcbiAgICBRYW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKCdxYW5pbWF0aW9uZnJhbWUnKSxcbiAgICBwcmVmaXggPSByZXF1aXJlKCd2ZW5kb3ItcHJlZml4JyksXG4gICAgbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUgPSByZXF1aXJlKCcuLi9zcmMvbm9ybWFsaXplLXRyYW5zZm9ybS12YWx1ZScpLFxuICAgIHNob3J0aGFuZCA9IHJlcXVpcmUoJy4uL3NyYy90cmFuc2l0aW9uLXNob3J0aGFuZC1wcm9wZXJ0eScpLFxuICAgIHRyYW5zaXRpb24gPSBwcmVmaXgoJ3RyYW5zaXRpb24nKSxcbiAgICB0cmFuc2l0aW9uZW5kID0gJ1dlYmtpdFRyYW5zaXRpb24nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCcsXG5cbiAgICBpc0RPTSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGVsICYmIGVsLm5vZGVUeXBlO1xuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhZGRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGVsdCwgYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGVsdC5zdHlsZVt0cmFuc2l0aW9uXTtcbiAgICAgICAgYXR0ciA9IHByZWZpeC5kYXNoKGF0dHIpO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGVbdHJhbnNpdGlvbl0gPSBjdXJyZW50VmFsdWUgKyBcIiwgXCIgKyBzaG9ydGhhbmQoYXR0ciwgZHVyYXRpb24sIGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbHQuc3R5bGVbdHJhbnNpdGlvbl0gPSBzaG9ydGhhbmQoYXR0ciwgZHVyYXRpb24sIGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWx0LnN0eWxlW3ByZWZpeChhdHRyKV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChlbCwgYXR0cikge1xuICAgICAgICBlbC5zdHlsZVt0cmFuc2l0aW9uXSA9IGVsLnN0eWxlW3RyYW5zaXRpb25dXG4gICAgICAgICAgICAuc3BsaXQoJywnKS5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdC5tYXRjaChhdHRyKTtcbiAgICAgICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICB9LFxuXG4gICAgYXBwbHljc3MgPSBmdW5jdGlvbiAoZWwsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBRYW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGVsLnN0eWxlW3ByZWZpeC5kYXNoKGF0dHIpXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY3NzID0gZnVuY3Rpb24gKGVsLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICBpZihlbC5femFuaW1vICYmIGVsLl96YW5pbW8uaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgIGVsLl96YW5pbW9bYXR0cl0uZGVmZXIucmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlphbmltbyB0cmFuc2l0aW9uIHdpdGggdHJhbnNmb3JtPVwiICtcbiAgICAgICAgICAgICAgICBlbC5femFuaW1vW2F0dHJdLnZhbHVlICtcbiAgICAgICAgICAgICAgICBcIiBzdG9wcGVkIGJ5IHRyYW5zZm9ybT1cIiArIHZhbHVlXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGVsLl96YW5pbW9bYXR0cl0uY2IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHljc3MoZWwsIGF0dHIsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgYW5pbWF0ZSA9IGZ1bmN0aW9uIChlbCwgYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIHByZWZpeGVkID0gcHJlZml4LmRhc2goYXR0ciksXG4gICAgICAgICAgICBkID0gUS5kZWZlcigpLFxuICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgIGNiID0gZnVuY3Rpb24gKGNsZWFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHsgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyB0aW1lb3V0ID0gbnVsbDsgfVxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb24oZWwsIGF0dHIpO1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbmVuZCwgY2JUcmFuc2l0aW9uZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYXIpIHsgZGVsZXRlIGVsLl96YW5pbW9bYXR0cl07IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYlRyYW5zaXRpb25lbmQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYocHJlZml4KGV2dC5wcm9wZXJ0eU5hbWUpID09PSBwcmVmaXgocHJlZml4ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uZW5kLCBjYlRyYW5zaXRpb25lbmQpO1xuXG4gICAgICAgIFFhbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uKGVsLCBhdHRyLCBub3JtYWxpemVUcmFuc2Zvcm1WYWx1ZSh2YWx1ZSksIGR1cmF0aW9uLCBlYXNpbmcpO1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByYXdWYWwgPSBlbC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByZWZpeGVkKSxcbiAgICAgICAgICAgICAgICAgICAgZG9tVmFsID0gbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUocmF3VmFsKSxcbiAgICAgICAgICAgICAgICAgICAgZ2l2ZW5WYWwgPSBub3JtYWxpemVUcmFuc2Zvcm1WYWx1ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYih0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tVmFsID09PSBnaXZlblZhbCkgeyBkLnJlc29sdmUoZWwpOyB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KCBuZXcgRXJyb3IoXCJaYW5pbW8gdHJhbnNpdGlvbjogd2l0aCBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhdHRyICsgXCIgPSBcIiArIGdpdmVuVmFsICsgXCIsIERPTSB2YWx1ZT1cIiArIGRvbVZhbFxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBkdXJhdGlvbiArIDIwICk7XG5cbiAgICAgICAgICAgIGVsLl96YW5pbW8gPSBlbC5femFuaW1vIHx8IHsgfTtcbiAgICAgICAgICAgIGlmKGVsLl96YW5pbW9bYXR0cl0pIHtcbiAgICAgICAgICAgICAgICBlbC5femFuaW1vW2F0dHJdLmRlZmVyLnJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiWmFuaW1vIHRyYW5zaXRpb24gd2l0aCBcIiArXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgKyBcIj1cIiArIGVsLl96YW5pbW9bYXR0cl0udmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICBcIiBzdG9wcGVkIGJ5IHRyYW5zaXRpb24gd2l0aCBcIiArIGF0dHIgKyBcIj1cIiArIHZhbHVlXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgZWwuX3phbmltb1thdHRyXS5jYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuX3phbmltb1thdHRyXSA9IHtjYjogY2IsIHZhbHVlOiB2YWx1ZSwgZGVmZXI6IGR9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZC5wcm9taXNlO1xuICAgIH07XG5cbi8qKlxuICogWmFuaW1vKGVsIHwgcHJvbWlzZVtlbF0pXG4gKiA+IFJldHVybnMgYSBQcm9taXNlIG9mIGVsLlxuICpcbiAqIFphbmltbyhlbCB8IHByb21pc2VbZWxdLCBhdHRyLCB2YWx1ZSlcbiAqID4gU2V0cyBlbC5zdHlsZVthdHRyXT12YWx1ZSBhbmQgcmV0dXJucyB0aGUgcHJvbWlzZSBvZiBlbC5cbiAqXG4gKiBaYW5pbW8oZWwgfCBwcm9taXNlW2VsXSwgYXR0ciwgdmFsdWUsIGR1cmF0aW9uLCBbZWFzaW5nXSlcbiAqID4gUGVyZm9ybXMgYSB0cmFuc2l0aW9uLlxuICovXG52YXIgWmFuaW1vID0gZnVuY3Rpb24gKGVsLCBhdHRyLCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZykge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBhcml0eSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGFyaXR5ID09PSAwIHx8IGFyaXR5ID09PSAyIHx8IGFyaXR5ID4gNSkge1xuICAgICAgICByZXR1cm4gUS5yZWplY3QobmV3IEVycm9yKFwiWmFuaW1vIGludmFsaWQgYXJndW1lbnRzXCIpKTtcbiAgICB9XG4gICAgaWYgKFEuaXNQcm9taXNlKGVsKSkge1xuICAgICAgICByZXR1cm4gZWwudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gWmFuaW1vLmFwcGx5KHRoaXMsIFt2YWxdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0RPTShlbCkpIHtcbiAgICAgICAgcmV0dXJuIFEucmVqZWN0KG5ldyBFcnJvcihcIlphbmltbyByZXF1aXJlIGFuIEhUTUxFbGVtZW50LCBvciBhIHByb21pc2Ugb2YgYW4gSFRNTEVsZW1lbnRcIikpO1xuICAgIH1cbiAgICBpZiAoYXJpdHkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFEoZWwpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBwcmVmaXguZGFzaChhdHRyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICByZXR1cm4gUS5yZWplY3QobmV3IEVycm9yKFwiWmFuaW1vIHRyYW5zaXRpb246IFwiICsgYXR0ciArICcgaXMgbm90IHN1cHBvcnRlZCEnKSk7XG4gICAgfTtcbiAgICBpZiAoYXJpdHkgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGNzcyhlbCwgYXR0ciwgdmFsdWUpO1xuICAgIH1cbiAgICBpZih3aW5kb3cuaXNOYU4ocGFyc2VJbnQoZHVyYXRpb24sIDEwKSkpIHtcbiAgICAgICAgcmV0dXJuIFEucmVqZWN0KG5ldyBFcnJvcihcIlphbmltbyB0cmFuc2l0aW9uOiBkdXJhdGlvbiBtdXN0IGJlIGFuIGludGVnZXIhXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGUoZWwsIGF0dHIsIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nKTtcbn07XG5cbi8qKlxuICogQSBmdW5jdGlvbiB3cmFwcGluZyBgWmFuaW1vKGVsLCAuLi4pYCBhcyBhIGBmKC4uLikoZWwpYCBmb3IgZWFzeSBjaGFpbmluZyBwdXJwb3NlLlxuICovXG5aYW5pbW8uZiA9IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBaYW5pbW8uYXBwbHkodGhpcywgW2VsXS5jb25jYXQoYXJncykpO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFphbmltbztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGNoUGFyZW50aGVzaXMgPSAvKFxcKC4rP1xcKSkvZyxcbiAgICBzcGFjZSA9IC8gKy9nLFxuICAgIGVtcHR5U3RyaW5nID0gXCJcIixcbiAgICB3aGl0ZXNwYWNlID0gXCIgXCIsXG5cbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5zdWJzdHIoMSwgbWF0Y2gubGVuZ3RoLTIpLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICAgIHJzdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhcmcucmVwbGFjZShzcGFjZSwgZW1wdHlTdHJpbmcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gXCIoXCIgKyByc3Quam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuICB0eXBlb2YgdCA9PT0gJ3N0cmluZycgPyB0LnJlcGxhY2Uoc3BhY2UsIHdoaXRlc3BhY2UpLnJlcGxhY2UobWF0Y2hQYXJlbnRoZXNpcywgbm9ybWFsaXplKSA6IHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sb3IgPSByZXF1aXJlKCdjb2xvcicpLFxuICAgIG1hdGNoUGFyZW50aGVzaXMgPSAvKFxcKC4rP1xcKSkvZyxcbiAgICBtYXRjaENvbG9ycyA9IC8oXFxicmdiYVxcYnxcXGJoc2xcXGJ8XFxiaHNsYVxcYikoXFwoLis/XFwpKS9nLFxuICAgIHNwYWNlID0gLyArL2csXG4gICAgZW1wdHlTdHJpbmcgPSBcIlwiLFxuICAgIHdoaXRlc3BhY2UgPSBcIiBcIixcbiAgICB6ZXJvcGl4ZWwgPSAvXjBweCQvZyxcbiAgICB6ZXJvID0gXCIwXCIsXG5cbiAgICBub3JtQXJncyA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICB2YXIgYXJncyA9IG1hdGNoLnN1YnN0cigxLCBtYXRjaC5sZW5ndGgtMikuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgcnN0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmcucmVwbGFjZShzcGFjZSwgZW1wdHlTdHJpbmcpLnJlcGxhY2UoemVyb3BpeGVsLCB6ZXJvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gXCIoXCIgKyByc3Quam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9LFxuXG4gICAgbm9ybUNvbG9ycyA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICB2YXIgYyA9IENvbG9yKG1hdGNoKTtcbiAgICAgICAgaWYgKGMuYWxwaGEoKSApIHsgYy5hbHBoYShNYXRoLnJvdW5kKGMuYWxwaGEoKSAqIDEwKSAvIDEwKTsgfVxuICAgICAgICByZXR1cm4gYy5yZ2JTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2Uoc3BhY2UsIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICAucmVwbGFjZShtYXRjaENvbG9ycywgbm9ybUNvbG9ycylcbiAgICAgICAgICAgIC5yZXBsYWNlKG1hdGNoUGFyZW50aGVzaXMsIG5vcm1BcmdzKTtcbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZW1wdHlTdHJpbmc7XG4gICAgcmV0dXJuIHdpbmRvdy5pc05hTih2YWwpID8gbm9ybWFsaXplKHZhbCkgOiB2YWwudG9TdHJpbmcoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwcmVmaXggPSByZXF1aXJlKCd2ZW5kb3ItcHJlZml4JyksXG4gICAgbm9ybWFsaXplVHJhbnNmb3JtVmFsdWUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZS10cmFuc2Zvcm0tdmFsdWUnKSxcbiAgICBub3JtYWxpemVUaW1pbmdGdW5jdGlvbiA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXRpbWluZy1mdW5jdGlvbicpLFxuICAgIHRyYW5zaXRpb24gPSBwcmVmaXguZGFzaCgndHJhbnNpdGlvbicpLFxuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgdGVzdCA9ICdvcGFjaXR5IDEwMG1zIGxpbmVhciAwcycsXG4gICAgbm9ybWFsaXplZFRlc3QgPSBub3JtYWxpemVUcmFuc2Zvcm1WYWx1ZSh0ZXN0KSxcbiAgICBzaG9ydGhhbmQgPSBmdW5jdGlvbiBzaG9ydGhhbmQodiwgZCwgdCkge1xuICAgICAgICByZXR1cm4gdiArIFwiIFwiICsgZCArIFwibXMgXCIgKyAodCB8fCBcImxpbmVhclwiKTtcbiAgICB9O1xuXG5lbC5zdHlsZVt0cmFuc2l0aW9uXSA9IG5vcm1hbGl6ZWRUZXN0O1xuXG5pZihub3JtYWxpemVUcmFuc2Zvcm1WYWx1ZShlbC5zdHlsZVt0cmFuc2l0aW9uXSkgPT09IG5vcm1hbGl6ZWRUZXN0KSB7XG4gICAgc2hvcnRoYW5kID0gZnVuY3Rpb24gKHYsIGQsIHQpIHtcbiAgICAgICAgcmV0dXJuIHYgKyBcIiBcIiArIGQgKyBcIm1zIFwiICsgKG5vcm1hbGl6ZVRpbWluZ0Z1bmN0aW9uKHQpIHx8IFwibGluZWFyXCIpICsgXCIgMHNcIjtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0aGFuZDtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJ2xvZGFzaC9pc0Z1bmN0aW9uJztcbmltcG9ydCBpMThuIGZyb20gJy4vaTE4bic7XG5pbXBvcnQgeyBiYWNrSGlzdG9yeSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmNvbnN0IHN0YWNrID0gW107XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhY2tidXR0b24oKSB7XG4gIHZhciBiID0gc3RhY2sucG9wKCk7XG4gIGlmIChpc0Z1bmN0aW9uKGIpKSB7XG4gICAgYignYmFja2J1dHRvbicpO1xuICAgIG0ucmVkcmF3KCk7XG4gIH0gZWxzZSBpZiAoIS9eXFwvJC8udGVzdChtLnJvdXRlKCkpKSB7XG4gICAgLy8gaWYgcGxheWluZyBhIGdhbWUgYXMgYW5vbiBhc2sgZm9yIGNvbmZpcm1hdGlvblxuICAgIGlmICgvXlxcL2dhbWVcXC9bYS16QS1aMC05XXsxMn0vLnRlc3QobS5yb3V0ZSgpKSkge1xuICAgICAgbmF2aWdhdG9yLm5vdGlmaWNhdGlvbi5jb25maXJtKFxuICAgICAgICBpMThuKCd0aGVyZUlzQUdhbWVJblByb2dyZXNzJyksXG4gICAgICAgIGkgPT4geyBpZiAoaT09PTEpIGJhY2tIaXN0b3J5KCk7IH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2tIaXN0b3J5KCk7XG4gICAgfVxuICB9ZWxzZSB7XG4gICAgd2luZG93Lm5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICB9XG59O1xuXG5iYWNrYnV0dG9uLnN0YWNrID0gc3RhY2s7XG4iLCJjb25zdCBkZWZhdWx0cyA9IHtcbiAgYXBpVmVyc2lvbjogMSxcbiAgZmV0Y2hUaW1lb3V0TXM6IDEwMDAwXG59O1xuXG5jb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgd2luZG93Lm95dW5rZXlmKTtcblxuZXhwb3J0IGRlZmF1bHQgY29uZmlnO1xuIiwiaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5pbXBvcnQgc3Bpbm5lciBmcm9tICcuL3NwaW5uZXInO1xuaW1wb3J0IGdsb2JhbENvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBidWlsZFF1ZXJ5U3RyaW5nIH0gZnJvbSAnLi91dGlscy9xdWVyeXN0cmluZyc7XG5pbXBvcnQgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UnO1xuXG5leHBvcnQgY29uc3QgU0VTU0lPTl9JRF9LRVkgPSAnc2Vzc2lvbklkJztcblxuY29uc3QgYmFzZVVybCA9IGdsb2JhbENvbmZpZy5hcGlFbmRQb2ludDtcblxuZnVuY3Rpb24gYWRkUXVlcnlTdHJpbmcodXJsLCBxdWVyeVN0cmluZykge1xuICBjb25zdCBwcmVmaXggPSB1cmwuaW5kZXhPZignPycpIDwgMCA/ICc/JyA6ICcmJztcbiAgbGV0IHJlcyA9IHVybCArIHByZWZpeCArIHF1ZXJ5U3RyaW5nO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0KHVybCwgdHlwZSwgb3B0cywgZmVlZGJhY2spIHtcblxuICBsZXQgdGltZW91dElkO1xuXG4gIGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgaWYgKGZlZWRiYWNrKSBzcGlubmVyLnN0b3AoKTtcbiAgfVxuXG4gIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcbiAgICBjb25zdCBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcob3B0cy5xdWVyeSk7XG4gICAgaWYgKHF1ZXJ5ICE9PSAnJykge1xuICAgICAgdXJsID0gYWRkUXVlcnlTdHJpbmcodXJsLCBxdWVyeSk7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRzLnF1ZXJ5O1xuICB9XG4gIFxuICBjb25zdCBjZmcgPSB7XG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL3ZuZC5veXVua2V5Zi52JyArIGdsb2JhbENvbmZpZy5hcGlWZXJzaW9uICsgJytqc29uJ1xuICAgIH1cbiAgfTtcblxuICBtZXJnZShjZmcsIG9wdHMpO1xuXG4gIGNvbnN0IGluaXQgPSB7XG4gICAgLi4uY2ZnLFxuICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoY2ZnLmhlYWRlcnMpXG4gIH07XG5cbiAgaWYgKChpbml0Lm1ldGhvZCA9PT0gJ1BPU1QnIHx8IGluaXQubWV0aG9kID09PSAnUFVUJykgJiZcbiAgICAgICFpbml0LmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkge1xuICAgIChpbml0LmhlYWRlcnMpLmFwcGVuZCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnKTtcbiAgICBpZiAoIWluaXQuYm9keSl7XG4gICAgICBpbml0LmJvZHkgPSAne30nO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNpZCA9IHN0b3JhZ2UuZ2V0KFNFU1NJT05fSURfS0VZKTtcbiAgaWYgKHNpZCAhPT0gbnVsbCkge1xuICAgIGluaXQuaGVhZGVycy5hcHBlbmQoU0VTU0lPTl9JRF9LRVksIHNpZCk7XG4gIH1cblxuICBjb25zdCBmdWxsVXJsID0gdXJsLmluZGV4T2YoJ2h0dHAnKSA+IC0xID8gdXJsIDogYmFzZVVybCArIHVybDtcblxuICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0JykpLFxuICAgICAgZ2xvYmFsQ29uZmlnLmZldGNoVGltZW91dE1zXG4gICAgKTtcbiAgfSk7XG5cbiAgY29uc3QgcmVzcE9yVGltZW91dCA9IFByb21pc2UucmFjZShbXG4gICAgZmV0Y2goZnVsbFVybCwgaW5pdCksXG4gICAgdGltZW91dFByb21pc2VcbiAgXSk7XG5cbiAgaWYgKGZlZWRiYWNrKSB7XG4gICAgc3Bpbm5lci5zcGluKCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc3BPclRpbWVvdXRcbiAgICAgIC50aGVuKChyKSA9PiB7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgaWYgKHIub2spIHtcbiAgICAgICAgICByZXNvbHZlKHJbdHlwZV0oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgci50ZXh0KClcbiAgICAgICAgICAgIC50aGVuKChib2R5VGV4dCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXM6IHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5wYXJzZShib2R5VGV4dClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXM6IHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgYm9keTogci5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IgJyArIGVycik7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgYm9keTogZXJyLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaEpTT04odXJsLCBvcHRzLCBmZWVkYmFjayA9IGZhbHNlKSB7XG4gIHJldHVybiByZXF1ZXN0KHVybCwgJ2pzb24nLCBvcHRzLCBmZWVkYmFjayk7XG59XG5cbmV4cG9ydCBjb25zdCBhcGlWZXJzaW9uID0gMTtcblxuLy8gY29uc3QgYmFzZVVybCA9IHdpbmRvdy5veXVua2V5Zi5hcGlFbmRQb2ludDtcblxuZnVuY3Rpb24gb25TdWNjZXNzKGRhdGEpIHtcbiAgc3Bpbm5lci5zdG9wKCk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBvbkVycm9yKGRhdGEpIHtcbiAgc3Bpbm5lci5zdG9wKCk7XG4gIHRocm93IGRhdGE7XG59XG5cbmZ1bmN0aW9uIHhockNvbmZpZyh4aHIpIHtcbiAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcbiAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi92bmQub3l1bmtleWYudicgKyBhcGlWZXJzaW9uICsgJytqc29uJyk7XG4gIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICB4aHIudGltZW91dCA9IDgwMDA7XG59XG5cbi8vIGNvbnZlbmllbnQgd3JhcHBlciBhcm91bmQgbS5yZXF1ZXN0XG4vLyBleHBvcnQgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdHMsIGZlZWRiYWNrLCB4aHJDb25mKSB7XG4vLyAgIHZhciBjZmcgPSB7XG4vLyAgICAgdXJsOiBiYXNlVXJsICsgdXJsLFxuLy8gICAgIG1ldGhvZDogJ0dFVCcsXG4vLyAgICAgZGF0YTogeyB9LFxuLy8gICAgIGNvbmZpZzogeGhyQ29uZiB8fCB4aHJDb25maWcsXG4vLyAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uKHRleHQpIHtcbi8vICAgICAgIHRyeSB7XG4vLyAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuLy8gICAgICAgfSBjYXRjaCAoZSkge1xuLy8gICAgICAgICB0aHJvdyB7IHJlc3BvbnNlOiB7IGVycm9yOiAnQ2Fubm90IHJlYWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXInIH19O1xuLy8gICAgICAgfVxuLy8gICAgIH0sXG4vLyAgICAgdW53cmFwRXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlLCB4aHIpIHtcbi8vICAgICAgIHJldHVybiB7IHJlc3BvbnNlLCBzdGF0dXM6IHhoci5zdGF0dXMgfTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyAgIG1lcmdlKGNmZywgb3B0cyk7XG5cbi8vICAgaWYgKGNmZy5tZXRob2QgPT09ICdHRVQnKSB7XG4vLyAgICAgY2ZnLmRhdGEuXyA9IERhdGUubm93KCk7XG4vLyAgIH1cblxuLy8gICB2YXIgcHJvbWlzZSA9IG0ucmVxdWVzdChjZmcpO1xuXG4vLyAgIGlmIChmZWVkYmFjaykge1xuLy8gICAgIHNwaW5uZXIuc3Bpbihkb2N1bWVudC5ib2R5KTtcbi8vICAgICByZXR1cm4gcHJvbWlzZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgcmV0dXJuIHByb21pc2U7XG4vLyAgIH1cbi8vIH0gXG4iLCJpbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBsb2FkTG9jYWxKc29uRmlsZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5cbmNvbnN0IGRlZmF1bHRDb2RlID0gJ3RyLVRSJztcblxubGV0IGxhbmcgPSBkZWZhdWx0Q29kZTtcbmxldCBtZXNzYWdlcyA9IHt9O1xuXG5jb25zdCB1bnRyYW5zbGF0ZWQgPSB7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZygpIHtcbiAgcmV0dXJuIGxhbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGkxOG4oa2V5LCAuLi5hcmdzKSB7XG4gIHZhciBzdHIgPSBtZXNzYWdlc1trZXldIHx8IHVudHJhbnNsYXRlZFtrZXldfHwga2V5O1xuICBhcmdzLmZvckVhY2goYSA9PiB7IHN0ciA9IHN0ci5yZXBsYWNlKCclcycsIFN0cmluZyhhKSk7IH0pO1xuICBcbiAgcmV0dXJuIHN0cjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRQcmVmZXJyZWRMYW5ndWFnZSgpIHtcbiAgY29uc3QgZnJvbVNldHRpbmdzID0gc2V0dGluZ3MuZ2VuZXJhbC5sYW5nKCk7XG4gIGlmIChmcm9tU2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbG9hZExhbmd1YWdlKGZyb21TZXR0aW5ncyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgd2luZG93Lm5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldFByZWZlcnJlZExhbmd1YWdlKFxuICAgICAgbCA9PiByZXNvbHZlKGwudmFsdWUuc3BsaXQoJy0nKVswXSksXG4gICAgICAoKSA9PiByZXNvbHZlKGRlZmF1bHRDb2RlKVxuICAgICk7XG4gIH0pLnRoZW4oKGNvZGUpID0+IHtcbiAgICBzZXR0aW5ncy5nZW5lcmFsLmxhbmcoY29kZSk7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH0pLnRoZW4obG9hZEZpbGUpXG4gICAgLnRoZW4obG9hZE1vbWVudExvY2FsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2UobGFuZykge1xuICByZXR1cm4gbG9hZEZpbGUobGFuZylcbiAgICAudGhlbihsb2FkTW9tZW50TG9jYWxlKTtcbn1cblxuZnVuY3Rpb24gbG9hZEZpbGUoY29kZSkge1xuICByZXR1cm4gbG9hZExvY2FsSnNvbkZpbGUoJ2kxOG4vJyArIGNvZGUgKyAnLmpzb24nKVxuICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgbGFuZyA9IGNvZGU7XG4gICAgICBtZXNzYWdlcyA9IGRhdGE7XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBpZiAoY29kZSA9PT0gZGVmYXVsdENvZGUpIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gbG9hZEZpbGUoZGVmYXVsdENvZGUpO1xuICAgIH0pO1xufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlTGFuZ3VhZ2VzKCkge1xuLy8gICByZXR1cm4gbS5yZXF1ZXN0KHtcbi8vICAgICB1cmw6ICdpMThuL3JlZnMuanNvbicsXG4vLyAgICAgbWV0aG9kOiAnR0VUJ1xuLy8gICB9KS50aGVuKGRhdGEgPT4geyByZXR1cm4gZGF0YTsgfSwgZXJyb3IgPT4ge1xuLy8gICAgIC8vIHNhbWUgd29ya2Fyb3VuZCBmb3IgaU9TIGFzIGFib3ZlXG4vLyAgICAgaWYgKGVycm9yICYmIGVycm9yWzBdWzBdID09PSAndHInKVxuLy8gICAgICAgcmV0dXJuIGVycm9yO1xuLy8gICAgIGVsc2Vcbi8vICAgICAgIHRocm93IHsgZXJyb3I6ICdDYW5ub3QgbG9hZCBsYW5ndWFnZXMnIH07XG4vLyAgIH0pO1xuLy8gfVxuXG5cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGxvYWRGcm9tU2V0dGluZ3MoKSB7XG4vLyAgIHJldHVybiBsb2FkRmlsZShzZXR0aW5ncy5nZW5lcmFsLmxhbmcoKSkudGhlbihsb2FkTW9tZW50TG9jYWxlKTtcbi8vIH1cblxuLy8gZnVuY3Rpb24gbG9hZEZpbGUoY29kZSkge1xuLy8gICByZXR1cm4gbS5yZXF1ZXN0KHtcbi8vICAgICB1cmw6ICdpMThuLycgKyBjb2RlICsgJy5qc29uJyxcbi8vICAgICBtZXRob2Q6ICdHRVQnLFxuLy8gICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbih0ZXh0KSB7XG4vLyAgICAgICB0cnkge1xuLy8gICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbi8vICAgICAgIH0gY2F0Y2ggKGUpIHtcbi8vICAgICAgICAgdGhyb3cgeyBlcnJvcjogJ0xhbmcgbm90IGF2YWlsYWJsZScgfTtcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuLy8gICAgIG1lc3NhZ2VzID0gZGF0YTtcbi8vICAgICByZXR1cm4gY29kZTtcbi8vICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbi8vICAgICAvLyB3b3JrYXJvdW5kIGZvciBpT1M6IGJlY2F1c2UgeGhyIGZvciBsb2NhbCBmaWxlIGhhcyBhIDAgc3RhdHVzIGl0IHdpbGxcbi8vICAgICAvLyByZWplY3QgdGhlIHByb21pc2UgYW5kIHN0aWxsIGhhdmUgdGhlIHJlc3BvbnNlIG9iamVjdFxuLy8gICAgIGlmIChlcnJvciAmJiBlcnJvci5wbGF5V2l0aEFGcmllbmQpIHtcbi8vICAgICAgIG1lc3NhZ2VzID0gZXJyb3I7XG4vLyAgICAgICByZXR1cm4gY29kZTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgaWYgKGNvZGUgPT09IGRlZmF1bHRDb2RlKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuLy8gICAgICAgcmV0dXJuIGxvYWRGaWxlKGRlZmF1bHRDb2RlKTtcbi8vICAgICB9XG4vLyAgIH0pO1xuLy8gfVxuXG5mdW5jdGlvbiBsb2FkTW9tZW50TG9jYWxlKGNvZGUpIHtcbiAgaWYgKGNvZGUgIT09ICdlbicpIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnNyYyA9ICdtb21lbnQvbG9jYWxlLycgKyBjb2RlICsgJy5qcyc7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9XG4gIHdpbmRvdy5tb21lbnQubG9jYWxlKGNvZGUpO1xuICByZXR1cm4gY29kZTtcbn1cblxuIiwiLyogYXBwbGljYXRpb24gZW50cnkgcG9pbnQgKi9cblxuLy8gaW1wb3J0ICcuL3BvbHlmaWxscyc7XG5cblxuLy8gZm9yIG1vbWVudCBhIGdsb2JhbCBvYmplY3QgbWFrZXMgbG9hZGluZyBsb2NhbGVzIGVhc2llclxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xud2luZG93Lm1vbWVudCA9IG1vbWVudDtcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuL3Nlc3Npb24nO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBsb2FkUHJlZmVycmVkTGFuZ3VhZ2UsIGVuc3VyZUxhbmdJc0F2YWlsYWJsZSwgbG9hZExhbmd1YWdlIH0gZnJvbSAnLi9pMThuJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuL3hocic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi91aS9oZWxwZXInO1xuaW1wb3J0IGJhY2tidXR0b24gZnJvbSAnLi9iYWNrYnV0dG9uJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi9zb2NrZXQnO1xuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcyc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4vcm91dGVyJztcbmltcG9ydCB7IGlzRm9yZWdyb3VuZCwgc2V0Rm9yZWdyb3VuZCwgc2V0QmFja2dyb3VuZCB9IGZyb20gJy4vdXRpbHMvYXBwTW9kZSc7XG5cbmxldCBmaXJzdENvbm5lY3Rpb24gPSB0cnVlO1xuXG5mdW5jdGlvbiBtYWluKCkge1xuICByb3V0ZXMuaW5pdCgpO1xuICAvLyBjYWNoZSB2aWV3cG9ydCBkaW1zXG4gIGhlbHBlci52aWV3cG9ydERpbSgpO1xuXG4gIC8vIHB1bGwgc2Vzc2lvbiBkYXRhIG9uY2UgKHRvIGxvZyBpbiB1c2VyIGF1dG9tYXRpY2FsbHkgdGhhbmtzIHRvIGNvb2tpZSlcbiAgLy8gYW5kIGFsc28gbGlzdGVuIHRvIG9ubGluZSBldmVudCBpbiBjYXNlIG5ldHdvcmsgd2FzIGRpc2Nvbm5lY3RlZCBhdCBhcHBcbiAgLy8gc3RhcnR1cFxuICBpZiAodXRpbHMuaGFzTmV0d29yaygpKSB7XG4gICAgb25PbmxpbmUoKTtcbiAgfVxuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIG9uT25saW5lLCBmYWxzZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBvbk9mZmxpbmUsIGZhbHNlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgb25SZXN1bWUsIGZhbHNlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBvblBhdXNlLCBmYWxzZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCByb3V0ZXIuYmFja2J1dHRvbiwgZmFsc2UpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICBzb2NrZXQudGVybWluYXRlKCk7XG4gIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKTtcblxuICBpZiAoY29yZG92YS5wbGF0Zm9ybUlkID09PSAnYW5kcm9pZCcpIHtcbiAgICB3aW5kb3cuU3RhdHVzQmFyLmJhY2tncm91bmRDb2xvckJ5SGV4U3RyaW5nKCcjMTUxQTFFJyk7XG4gIH1cblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3Iuc3BsYXNoc2NyZWVuLmhpZGUoKTtcbiAgICB3aW5kb3cuU3RhdHVzQmFyLmhpZGUoKTtcbiAgICAvLyB4aHJTdGF0dXMoKTtcbiAgfSwgNTAwKTtcbn1cblxuZnVuY3Rpb24gb25PbmxpbmUoKSB7XG4gIGlmIChpc0ZvcmVncm91bmQoKSkge1xuICAgIGlmIChmaXJzdENvbm5lY3Rpb24pIHtcbiAgICAgIGZpcnN0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgLy8geGhyLnN0YXR1cygpO1xuICAgICAgXG4gICAgICBzZXNzaW9uLnJlbWVtYmVyTG9naW4oKVxuICAgICAgICAudGhlbigodXNlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHNlcnZlckxhbmcgPSB1c2VyLmxhbmd1YWdlICYmIHVzZXIubGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgICBpZiAoc2VydmVyTGFuZykge1xuICAgICAgICAgICAgZW5zdXJlTGFuZ0lzQXZhaWxhYmxlKHNlcnZlckxhbmcpXG4gICAgICAgICAgICAgIC50aGVuKGxhbmcgPT4ge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmdlbmVyYWwubGFuZyhsYW5nKTtcbiAgICAgICAgICAgICAgICBsb2FkTGFuZ3VhZ2UobGFuZyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0ZWQgYXMgYW5vbnltb3VzJyk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQuY29ubmVjdCgpO1xuICAgICAgc2Vzc2lvbi5yZWZyZXNoKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uT2ZmbGluZSgpIHtcbiAgaWYgKGlzRm9yZWdyb3VuZCgpICYmICFoYXNOZXR3b3JrKCkpIHtcbiAgICBzb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgIHJlZHJhdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICBoZWxwZXIuY2xlYXJDYWNoZWRWaWV3cG9ydERpbSgpO1xuICByZWRyYXcoKTtcbn1cblxuZnVuY3Rpb24gb25SZXN1bWUoKSB7XG4gIHNldEZvcmVncm91bmQoKTtcbiAgc2Vzc2lvbi5yZWZyZXNoKCk7XG4gIHNvY2tldC5jb25uZWN0KCk7XG4gIHJlZHJhdygpO1xufVxuXG5mdW5jdGlvbiBvblBhdXNlKCkge1xuICBzZXRCYWNrZ3JvdW5kKCk7XG4gIHNvY2tldC5kaXNjb25uZWN0KCk7XG59XG5cbi8vIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGV2ZW50LCBzb3VyY2UsIGZpbGVubywgY29sdW1OdW1iZXIpIHtcbi8vICAgdmFyIGRlc2NyaXB0aW9uID0gZXZlbnQgKyAnIGF0ICcgKyBzb3VyY2UgKyAnIFsnICsgZmlsZW5vICsgJywgJyArIGNvbHVtTnVtYmVyICsgJ10nO1xuLy8gfVxuXG4vLyB3aW5kb3cub25lcnJvciA9IGhhbmRsZUVycm9yO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IGxvYWRQcmVmZXJyZWRMYW5ndWFnZSgpLnRoZW4obWFpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiIsImltcG9ydCBpMThuIGZyb20gJy4uL2kxOG4nO1xuaW1wb3J0IHN0YXR1cyBmcm9tICcuL3N0YXR1cyc7XG5cbmZ1bmN0aW9uIHBsYXlhYmxlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuZ2FtZS5zdGF0dXMuaWQgPCBzdGF0dXMuaWRzLmFib3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzUGxheWVyUGxheWluZyhkYXRhKSB7XG4gIHJldHVybiBwbGF5YWJsZShkYXRhKSAmJiAhZGF0YS5wbGF5ZXIuc3BlY3RhdG9yO1xufVxuXG5mdW5jdGlvbiBpc1BsYXllclR1cm4oZGF0YSkge1xuICByZXR1cm4gaXNQbGF5ZXJQbGF5aW5nKGRhdGEpICYmIGRhdGEuZ2FtZS5wbGF5ZXIgPT09IGRhdGEucGxheWVyLnNpZGU7XG59XG5cbmZ1bmN0aW9uIGdldFBsYXllcihkYXRhLCBzaWRlKSB7XG4gIHJldHVybiBbJ3BsYXllcicsICdvcHBvbmVudExlZnQnLCAnb3Bwb25lbnRSaWdodCcsICdvcHBvbmVudFVwJ11cbiAgICAubWFwKGsgPT4gZGF0YVtrXSlcbiAgICAuZmlsdGVyKHBsYXllciA9PiBwbGF5ZXIuc2lkZSA9PT0gc2lkZSlbMF07XG59XG5cbmZ1bmN0aW9uIHJlc3VsdChkYXRhKSB7XG4gIGlmIChzdGF0dXMuYWJvcnRlZChkYXRhKSkge1xuICAgIHJldHVybiBpMThuKCdnYW1lQWJvcnRlZCcpO1xuICB9IGVsc2UgaWYgKHN0YXR1cy5maW5pc2hlZChkYXRhKSkge1xuICAgIHJldHVybiBpMThuKCdnYW1lRmluaXNoZWQnKTtcbiAgfVxufTtcblxuY29uc3Qgc2lkZXMgPSBbXCJlYXN0XCIsIFwibm9ydGhcIiwgXCJ3ZXN0XCIsIFwic291dGhcIl07XG5cbmZ1bmN0aW9uIHNpZGVCeVBseShwbHkpIHtcbiAgcmV0dXJuIHNpZGVzW3BseSAlIDRdO1xufVxuXG5mdW5jdGlvbiBzZXRPbkdhbWUoZGF0YSwgc2lkZSwgb25HYW1lKSB7XG4gIHZhciBwbGF5ZXIgPSBnZXRQbGF5ZXIoZGF0YSwgc2lkZSk7XG4gIHBsYXllci5vbkdhbWUgPSBvbkdhbWU7XG59XG5cbi8vIGZ1bmN0aW9uIHJvdW5kc09yU2NvcmVzKGdhbWUpIHtcbi8vICAgaWYgKGdhbWUucm91bmRzKSB7XG4vLyAgICAgcmV0dXJuIGRhdGEuXG4vLyAgIH0gZWxzZSBpZiAoZGF0YS5zY29yZXMpIHtcbiAgICBcbi8vICAgfSBlbHNlIHtcbi8vICAgICByZXR1cm4gJyc7XG4vLyAgIH1cbi8vIH1cblxuZnVuY3Rpb24gdGl0bGUoZGF0YSkge1xuICB2YXIgdGV4dDtcbiAgaWYgKGlzUGxheWVyVHVybihkYXRhKSkge1xuICAgIHRleHQgPSBpMThuKCd5b3VyVHVybicpO1xuICB9IGVsc2Uge1xuICAgIHRleHQgPSBpMThuKCd3YWl0aW5nRm9yT3Bwb25lbnQnKTtcbiAgfVxuICAvLyBjb25zdCB2YXJpYW50ID0gZ2V0VmFyaWFudChkYXRhLmdhbWUudmFyaWFudC5rZXkpO1xuICAvLyBjb25zdCBuYW1lID0gdmFyaWFudCA/ICh2YXJpYW50LnNob3J0TmFtZSB8fCB2YXJpYW50Lm5hbWUpIDogJyc7XG4gIHJldHVybiB0ZXh0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzUGxheWVyUGxheWluZyxcbiAgaXNQbGF5ZXJUdXJuLFxuICBnZXRQbGF5ZXIsXG4gIHNpZGVCeVBseSxcbiAgcGxheWFibGUsXG4gIHNldE9uR2FtZSxcbiAgdGl0bGUsXG4gIHJlc3VsdFxufTtcbiIsImltcG9ydCBpMThuIGZyb20gJy4uL2kxOG4nO1xuXG5leHBvcnQgZnVuY3Rpb24gcGxheWVyTmFtZShwbGF5ZXIpIHtcbiAgaWYgKHBsYXllci5uYW1lIHx8IHBsYXllci51c2VybmFtZSB8fCBwbGF5ZXIudXNlcikge1xuICAgIGxldCBuYW1lID0gcGxheWVyLm5hbWUgfHwgcGxheWVyLnVzZXJuYW1lIHx8IHBsYXllci51c2VyLnVzZXJuYW1lO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGlmIChwbGF5ZXIuYWkpIHtcbiAgICByZXR1cm4gYWlOYW1lKHBsYXllcik7XG4gIH1cbiAgcmV0dXJuICdBbm9ueW1vdXMnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWlOYW1lKHBsYXllcikge1xuICByZXR1cm4gaTE4bignYWlCb3QnLCAxKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBodW1hblNldHVwRnJvbVNldHRpbmdzKHNldHRpbmdzT2JqKSB7XG4gIHJldHVybiB7XG4gICAgbW9kZTogc2V0dGluZ3NPYmoubW9kZSgpLFxuICAgIHZhcmlhbnQ6IHNldHRpbmdzT2JqLnZhcmlhbnQoKSxcbiAgICByb3VuZHM6IHNldHRpbmdzT2JqLnJvdW5kcygpXG4gIH07XG59XG4iLCIvLyBzY2FsYW9rZXkvc3JjL21haW4vc2NhbGEvU3RhdHVzLnNjYWxhXG5cbmltcG9ydCBpMThuIGZyb20gJy4uL2kxOG4nO1xuXG5jb25zdCBpZHMgPSB7XG4gIGNyZWF0ZWQ6IDEwLFxuICBzdGFydGVkOiAyMCxcbiAgYWJvcnRlZDogMjUsXG4gIG1pZGRsZUVuZDogMzAsXG4gIG5vcm1hbEVuZDogNDAsXG4gIHZhcmlhbnRFbmQ6IDcwXG59O1xuXG5mdW5jdGlvbiBzdGFydGVkKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuZ2FtZS5zdGF0dXMuaWQgPj0gaWRzLnN0YXJ0ZWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaGVkKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuZ2FtZS5zdGF0dXMuaWQgPj0gaWRzLm1pZGRsZUVuZDtcbn1cblxuZnVuY3Rpb24gYWJvcnRlZChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmdhbWUuc3RhdHVzLmlkID09PSBpZHMuYWJvcnRlZDtcbn1cblxuZnVuY3Rpb24gbWlkZGxlRW5kKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuZ2FtZS5zdGF0dXMuaWQgPT09IGlkcy5taWRkbGVFbmQ7XG59XG5cblxuZnVuY3Rpb24gcGxheWluZyhkYXRhKSB7XG4gIHJldHVybiBzdGFydGVkKGRhdGEpICYmICFmaW5pc2hlZChkYXRhKSAmJiAhYWJvcnRlZChkYXRhKTtcbn1cblxuZnVuY3Rpb24gdG9MYWJlbChzdGF0dXMsIHdpbm5lciwgdmFyaWFudCkge1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICBjYXNlICdzdGFydGVkJzpcbiAgICByZXR1cm4gaTE4bigncGxheWluZ1JpZ2h0Tm93Jyk7XG4gIGNhc2UgJ2Fib3J0ZWQnOlxuICAgIHJldHVybiBpMThuKCdnYW1lQWJvcnRlZCcpO1xuICBjYXNlICdtaWRkbGVFbmQnOlxuICAgIHJldHVybiBpMThuKCdnYW1lTWlkZGxlRmluaXNoZWQnKTtcbiAgY2FzZSAnbm9ybWFsRW5kJzpcbiAgICByZXR1cm4gaTE4bignZ2FtZUZpbmlzaGVkJyk7XG4gIGNhc2UgJ3ZhcmlhbnRFbmQnOlxuICAgIHJldHVybiBpMThuKCdnYW1lRmluaXNoZWQnKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZHMsXG4gIHN0YXJ0ZWQsXG4gIGZpbmlzaGVkLFxuICBhYm9ydGVkLFxuICBwbGF5aW5nLFxuICBtaWRkbGVFbmQsXG4gIHRvTGFiZWxcbn07XG4iLCJjb25zdCB2YXJpYW50TWFwID0ge1xuICB5dXpiaXI6IHtcbiAgICBuYW1lOiAnWcO8emJpcicsXG4gICAgaWQ6IDFcbiAgfSxcbiAgeXV6YmlydGVzdDoge1xuICAgIG5hbWU6ICdZdXpiaXIgVGVzdCcsXG4gICAgaWQ6IDJcbiAgfSxcbiAgZHV6b2tleToge1xuICAgIG5hbWU6ICdEw7x6IE9rZXknLFxuICAgIGlkOiAzXG4gIH0sXG4gIGR1em9rZXl0ZXN0OiB7XG4gICAgbmFtZTogJ0TDvHogT2tleSBUZXN0JyxcbiAgICBpZDogNFxuICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhcmlhbnQoa2V5KSB7XG4gIHJldHVybiB2YXJpYW50TWFwW2tleV07XG59XG4iLCJpbXBvcnQgUmxpdGUgZnJvbSAncmxpdGUtcm91dGVyJztcbmltcG9ydCAqIGFzIFJlbmRlclNlcnZpY2UgZnJvbSAnbWl0aHJpbC9yZW5kZXInO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnbG9kYXNoL2lzRnVuY3Rpb24nO1xuaW1wb3J0IFZub2RlIGZyb20gJ21pdGhyaWwvcmVuZGVyL3Zub2RlJztcbmltcG9ydCBzaWduYWxzIGZyb20gJy4vc2lnbmFscyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4vdXRpbHMvcmVkcmF3JztcblxuY29uc3Qgcm91dGVyID0gbmV3IFJsaXRlKCk7XG5cbmxldCBjdXJyZW50U3RhdGVJZCA9IDA7XG5sZXQgdmlld1NsaWRlRGlyZWN0aW9uID0gJ2Z3ZCc7XG5cbmxldCBwcmV2aW91c1BhdGggPSAnLyc7XG5cbmNvbnN0IHVpZCA9IChmdW5jdGlvbigpIHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IGlkKys7XG59KSgpO1xuXG5jb25zdCBiYWNrYnV0dG9uID0gKCgpID0+IHtcbiAgY29uc3QgeCA9ICgpID0+IHtcblxuICAgIGNvbnN0IGIgPSAoeC5zdGFjay5sZW5ndGggPT09IDApID9udWxsOnguc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihiKSkge1xuICAgICAgYignYmFja2J1dHRvbicpO1xuICAgICAgcmVkcmF3KCk7XG4gICAgfSBlbHNlIGlmICghL15cXC8kLy50ZXN0KGdldCgpKSkge1xuICAgICAgYmFja0hpc3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93Lm5hdmlnYXRvci5hcHAuZXhpdEFwcCgpO1xuICAgIH1cbiAgICBcbiAgfTtcblxuICB4LnN0YWNrID0gW107XG4gIFxuICByZXR1cm4geDtcbn0pKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVSb3V0ZXMobW91bnRQb2ludCwgcm91dGVzKSB7XG5cbiAgZm9yIChsZXQgcm91dGUgaW4gcm91dGVzKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gcm91dGVzW3JvdXRlXTtcbiAgICByb3V0ZXIuYWRkKHJvdXRlLCBmdW5jdGlvbiBvblJvdXRlTWF0Y2goeyBwYXJhbXMgfSkge1xuICAgICAgY29uc3QgUm91dGVDb21wb25lbnQgPSB7IHZpZXcoKSB7XG4gICAgICAgIHZhciBub2RlID0gVm5vZGUoY29tcG9uZW50LCB1bmRlZmluZWQsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfX07XG5cbiAgICAgIGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgICAgUmVuZGVyU2VydmljZS5yZW5kZXIobW91bnRQb2ludCwgVm5vZGUoUm91dGVDb21wb25lbnQpKTtcbiAgICAgIH1cblxuICAgICAgc2lnbmFscy5yZWRyYXcucmVtb3ZlQWxsKCk7XG4gICAgICBzaWduYWxzLnJlZHJhdy5hZGQocmVkcmF3KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlZHJhdygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzaWduYWxzLnJlZHJhdy5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBwcm9jZXNzUXVlcnlzdHJpbmcpO1xuICBwcm9jZXNzUXVlcnlzdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1F1ZXJ5c3RyaW5nKGUpIHtcbiAgaWYgKGUgJiYgZS5zdGF0ZSkge1xuICAgIGlmIChlLnN0YXRlLmlkIDwgY3VycmVudFN0YXRlSWQpIHtcbiAgICAgIHZpZXdTbGlkZURpcmVjdGlvbiA9ICdid2QnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3U2xpZGVEaXJlY3Rpb24gPSAnZndkJztcbiAgICB9XG4gICAgY3VycmVudFN0YXRlSWQgPSBlLnN0YXRlLmlkO1xuICB9XG4gIHByZXZpb3VzUGF0aCA9IGdldCgpO1xuICBjb25zdCBxcyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgJz89JztcbiAgY29uc3QgbWF0Y2hlZCA9IHJvdXRlci5ydW4ocXMuc2xpY2UoMikpO1xuICBpZiAoIW1hdGNoZWQpIHJvdXRlci5ydW4oJy8nKTtcbn1cblxuZnVuY3Rpb24gYXNzaWduU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlID9cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHdpbmRvdy5oaXN0b3J5LnN0YXRlLCBzdGF0ZSkgOlxuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnN0YXRlO1xuXG4gICAgaWYgKHBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG5ld1N0YXRlLCAnJywgJz89JyArIHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUobmV3U3RhdGUsICcnKTtcbiAgICB9XG4gIH0gY2F0Y2goZSkgeyBjb25zb2xlLmVycm9yKGUpOyB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VQYXRoKHBhdGgpIHtcbiAgYXNzaWduU3RhdGUodW5kZWZpbmVkLCBwYXRoKTtcbn1cblxuZnVuY3Rpb24gZG9TZXQocGF0aCwgcmVwbGFjZSA9IGZhbHNlKSB7XG4gIGJhY2tidXR0b24uc3RhY2sgPSBbXTtcbiAgcHJldmlvdXNQYXRoID0gZ2V0KCk7XG4gIGlmIChyZXBsYWNlKSB7XG4gICAgcmVwbGFjZVBhdGgocGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RhdGVJZCA9IHVpZCgpO1xuICAgIGN1cnJlbnRTdGF0ZUlkID0gc3RhdGVJZDtcbiAgICB2aWV3U2xpZGVEaXJlY3Rpb24gPSAnZndkJztcbiAgICB0cnkge1xuICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHsgaWQ6IHN0YXRlSWQgfSwgJycsICc/PScgKyBwYXRoKTtcbiAgICB9IGNhdGNoIChlKSB7IGNvbnNvbGUuZXJyb3IoZSk7IH1cbiAgfVxuICBjb25zdCBtYXRjaGVkID0gcm91dGVyLnJ1bihwYXRoKTtcbiAgaWYgKCFtYXRjaGVkKSByb3V0ZXIucnVuKCcvJyk7XG59XG5cbmZ1bmN0aW9uIHNldChwYXRoLCByZXBsYWNlID0gZmFsc2UpIHtcbiAgc2V0VGltZW91dCgoKSA9PiBkb1NldChwYXRoLCByZXBsYWNlKSwgMCk7XG59XG5cbmZ1bmN0aW9uIGdldCgpIHtcbiAgY29uc3QgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggfHwgJz89Lyc7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGF0aC5zdWJzdHJpbmcoMikpO1xufVxuXG5mdW5jdGlvbiBiYWNrSGlzdG9yeSgpIHtcbiAgd2luZG93Lmhpc3RvcnkuZ28oLTEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldCxcbiAgc2V0LFxuICBiYWNrYnV0dG9uLFxuICBiYWNrSGlzdG9yeVxufTtcbiIsImltcG9ydCBob21lIGZyb20gJy4vdWkvaG9tZSc7XG5pbXBvcnQgZ2FtZSBmcm9tICcuL3VpL2dhbWUnO1xuaW1wb3J0IHVzZXIgZnJvbSAnLi91aS91c2VyJztcbmltcG9ydCBwbGF5ZXJzIGZyb20gJy4vdWkvcGxheWVycyc7XG5pbXBvcnQgbWFzYURldGFpbCBmcm9tICcuL3VpL21hc2EvZGV0YWlsJztcbmltcG9ydCBtYXNhIGZyb20gJy4vdWkvbWFzYSc7XG5pbXBvcnQgdG9kbyBmcm9tICcuL3VpL3RvZG8nO1xuaW1wb3J0IHNldHRpbmdzVWkgZnJvbSAnLi91aS9zZXR0aW5ncyc7XG5pbXBvcnQgc2V0dGluZ3NMYW5nIGZyb20gJy4vdWkvc2V0dGluZ3MvbGFuZyc7XG5pbXBvcnQgeyBkZWZpbmVSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdCgpIHtcbiAgICBkZWZpbmVSb3V0ZXMoZG9jdW1lbnQuYm9keSwge1xuICAgICAgJyc6IGhvbWUsXG4gICAgICAnQC86aWQnOiB1c2VyLFxuICAgICAgJ3BsYXllcnMnOiBwbGF5ZXJzLFxuICAgICAgJ2dhbWUvOmlkJzogZ2FtZSxcbiAgICAgICdtYXNhLzptYXNhSWQvZ2FtZS86aWQnOiBnYW1lLFxuICAgICAgJ21hc2FzJzogbWFzYSxcbiAgICAgICdtYXNhLzppZCc6IG1hc2FEZXRhaWwsXG4gICAgICAnc2V0dGluZ3MnOiBzZXR0aW5nc1VpLFxuICAgICAgJ3NldHRpbmdzL2xhbmcnOiBzZXR0aW5nc0xhbmcsXG4gICAgICAndG9kbyc6IHRvZG8sXG4gICAgfSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgeyBTRVNTSU9OX0lEX0tFWSwgZmV0Y2hKU09OIH0gZnJvbSAnLi9odHRwJztcbmltcG9ydCB7IGhhc05ldHdvcmssIGhhbmRsZVhockVycm9yIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCBpMThuIGZyb20gJy4vaTE4bic7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZSc7XG5cbmxldCBzZXNzaW9uO1xuXG5mdW5jdGlvbiBpc0Nvbm5lY3RlZCgpIHtcbiAgcmV0dXJuIHNlc3Npb24gIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Vzc2lvbigpIHtcbiAgcmV0dXJuIHNlc3Npb247XG59XG5cbmZ1bmN0aW9uIGlzU2Vzc2lvbihkYXRhKSB7XG4gIHJldHVybiBkYXRhLmlkICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHN0b3JlU2Vzc2lvbihkKSB7XG4gIFxufVxuXG5mdW5jdGlvbiBsb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL2xvZ2luJywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmRcbiAgICB9KVxuICB9LCB0cnVlKVxuICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoaXNTZXNzaW9uKGRhdGEpKSB7XG4gICAgICAgIHNlc3Npb24gPSBkYXRhO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zZXNzaW9uSWQpIHtcbiAgICAgICAgICBzdG9yYWdlLnNldChTRVNTSU9OX0lEX0tFWSwgc2Vzc2lvbi5zZXNzaW9uSWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlU2Vzc2lvbihkYXRhKTtcbiAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNpZ251cCh1c2VybmFtZSwgZW1haWwsIHBhc3N3b3JkKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9zaWdudXAnLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkXG4gICAgfSlcbiAgfSwgdHJ1ZSlcbiAgICAudGhlbihkID0+IHtcbiAgICAgIGlmIChpc1Nlc3Npb24oZCkpIHtcbiAgICAgICAgc2Vzc2lvbiA9IGQ7XG4gICAgICAgIGlmIChzZXNzaW9uLnNlc3Npb25JZCkge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0KFNFU1NJT05fSURfS0VZLCBzZXNzaW9uLnNlc3Npb25JZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW1lbWJlckxvZ2luKCkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvYWNjb3VudC9pbmZvJylcbiAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgc2Vzc2lvbiA9IGRhdGE7XG4gICAgICBzdG9yZVNlc3Npb24oZGF0YSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL2FjY291bnQvaW5mbycsIHsgY2FjaGU6ICdyZWxvYWQnIH0pXG4gICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHNlc3Npb24gPSBkYXRhO1xuICAgICAgc3RvcmVTZXNzaW9uKGRhdGEpO1xuICAgICAgcmVkcmF3KCk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKHNlc3Npb24gIT09IHVuZGVmaW5lZCAmJiBlcnIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgc2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgb25Mb2dvdXQoKTtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bignc2lnbmVkT3V0JyksICdzaG9ydCcsICdjZW50ZXInKTtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25Mb2dvdXQoKSB7XG4gIHN0b3JhZ2UucmVtb3ZlKFNFU1NJT05fSURfS0VZKTtcbiAgc2lnbmFscy5hZnRlckxvZ291dC5kaXNwYXRjaCgpO1xufVxuXG5mdW5jdGlvbiBsb2dvdXQoKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9sb2dvdXQnLCB7IG1ldGhvZDogJ0dFVCcgfSwgdHJ1ZSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBzZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgcmVkcmF3KCk7XG4gICAgfSkuY2F0Y2goaGFuZGxlWGhyRXJyb3IpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0Nvbm5lY3RlZCxcbiAgc2lnbnVwLFxuICBsb2dvdXQsXG4gIGxvZ2luOiB0aHJvdHRsZShsb2dpbiwgMTAwMCksXG4gIHJlbWVtYmVyTG9naW46IHRocm90dGxlKHJlbWVtYmVyTG9naW4sIDEwMDApLFxuICBnZXQ6IGdldFNlc3Npb24sXG4gIHJlZnJlc2g6IHRocm90dGxlKHJlZnJlc2gsIDEwMDApXG59O1xuXG5cbiIsImltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JhZ2UnO1xuaW1wb3J0IHJhbmdlIGZyb20gJ2xvZGFzaC9yYW5nZSc7XG5cbmZ1bmN0aW9uIHR1cGxlT2YoeCkge1xuICByZXR1cm4gW3gudG9TdHJpbmcoKSwgeC50b1N0cmluZygpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZW5lcmFsOiB7XG4gICAgbGFuZzogc3RvcmUucHJvcCgnc2V0dGluZ3MubGFuZycsIG51bGwpLFxuICAgIHRoZW1lOiB7XG4gICAgICBiYWNrZ3JvdW5kOiBzdG9yZS5wcm9wKCdzZXR0aW5ncy5iZ1RoZW1lJywgJ2RhcmsnKVxuICAgIH1cbiAgfSxcbiAgZ2FtZToge1xuICAgIHN1cHBvcnRlZFZhcmlhbnRzOiBbJ3N0YW5kYXJkJywgJ3l1emJpcicsICdkdXpva2V5J11cbiAgfSxcbiAgZ2FtZVNldHVwOiB7XG4gICAgYXZhaWxhYmxlUm91bmRzOiBbMSwgNSwgMTAsIDE1LCAyMCwgMjUsIDMwXS5tYXAodHVwbGVPZiksXG4gICAgaXNSb3VuZFZhbGlkOiBmdW5jdGlvbihnYW1lU2V0dGluZ3MpIHtcbiAgICAgIHJldHVybiBnYW1lU2V0dGluZ3Mucm91bmRzKCkgIT09ICcwJztcbiAgICB9LFxuICAgIGh1bWFuOiB7XG4gICAgICBhdmFpbGFibGVWYXJpYW50czogW1xuICAgICAgICBbJzEwMSBPa2V5JywgJzEnXSxcbiAgICAgICAgWydEw7x6IE9rZXknLCAnMyddXG4gICAgICBdLFxuICAgICAgdmFyaWFudDogc3RvcmUucHJvcCgnc2V0dGluZ3MuZ2FtZS5odW1hbi52YXJpYW50JywgJzEnKSxcbiAgICAgIHJvdW5kczogc3RvcmUucHJvcCgnc2V0dGluZ3MuZ2FtZS5odW1hbi5yb3VuZHMnLCAnMScpLFxuICAgICAgbW9kZTogc3RvcmUucHJvcCgnc2V0dGluZ3MuZ2FtZS5odW1hbi5tb2RlJywgJzAnKSxcbiAgICAgIG1lbWJlcnNPbmx5OiBzdG9yZS5wcm9wKCdzZXR0aW5ncy5nYW1lLmh1bWFuLm1lbWJlcnNPbmx5JywgZmFsc2UpXG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnc2lnbmFscyc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIHJlZHJhdzogbmV3IFNpZ25hbCgpLFxuXG4gIGFmdGVyTG9naW46IG5ldyBTaWduYWwoKSxcblxuICBhZnRlckxvZ291dDogbmV3IFNpZ25hbCgpLFxuXG4gIHNlc3Npb25SZXN0b3JlZDogbmV3IFNpZ25hbCgpXG5cbn07XG4iLCJpbXBvcnQgZ2xvYmFsQ29uZmlnIGZyb20gJy4vY29uZmlnJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlJztcbmltcG9ydCB7IFNFU1NJT05fSURfS0VZIH0gZnJvbSAnLi9odHRwJztcbmltcG9ydCB7IG5ld1NyaSwgYXV0b3JlZHJhdywgaGFzTmV0d29yayB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgYXNrV29ya2VyLCB0ZWxsV29ya2VyIH0gZnJvbSAnLi91dGlscy93b3JrZXInO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi9zZXNzaW9uJztcblxuXG5mdW5jdGlvbiBzZXR1cENvbm5lY3Rpb24oc2V0dXAsIHNvY2tldEhhbmRsZXJzKSB7XG4gIGNvbnN0IHNpZCA9IHN0b3JhZ2UuZ2V0KFNFU1NJT05fSURfS0VZKTtcbiAgaWYgKHNpZCAhPT0gbnVsbCkge1xuICAgIGlmIChzZXR1cC5vcHRzLnBhcmFtcykge1xuICAgICAgc2V0dXAub3B0cy5wYXJhbXNbU0VTU0lPTl9JRF9LRVldID0gc2lkO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXR1cC5vcHRzLnBhcmFtcyA9IHtcbiAgICAgICAgW1NFU1NJT05fSURfS0VZXTogc2lkXG4gICAgICB9OyAgICAgICBcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2V0dXAub3B0cy5wYXJhbXMpIHtcbiAgICBkZWxldGUgc2V0dXAub3B0cy5wYXJhbXMuc2Vzc2lvbklkO1xuICB9XG4gIHNldHVwLm9wdHMub3B0aW9ucy5pc0F1dGggPSAhIXNpZDtcbiAgd29ya2VyLm9ubWVzc2FnZSA9IChtc2cpID0+IHtcbiAgICBzd2l0Y2ggKG1zZy5kYXRhLnRvcGljKSB7XG4gICAgY2FzZSAnb25PcGVuJzpcbiAgICAgIGlmIChzb2NrZXRIYW5kbGVycy5vbk9wZW4pIHNvY2tldEhhbmRsZXJzLm9uT3BlbigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgIG9uRGlzY29ubmVjdGVkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgb25Db25uZWN0ZWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29uRXJyb3InOlxuICAgICAgaWYgKHNvY2tldEhhbmRsZXJzLm9uRXJyb3IpIHNvY2tldEhhbmRsZXJzLm9uRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2hhbmRsZSc6XG4gICAgICBsZXQgaCA9IHNvY2tldEhhbmRsZXJzLmV2ZW50c1ttc2cuZGF0YS5wYXlsb2FkLnRdO1xuICAgICAgaWYgKGgpIGgobXNnLmRhdGEucGF5bG9hZC5kLCBtc2cuZGF0YS5wYXlsb2FkKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHNldHVwKTtcbn1cblxuZnVuY3Rpb24gb25Db25uZWN0ZWQoKSB7XG4gIGlmICghY29ubmVjdGVkV1MpIHtcbiAgICBjb25uZWN0ZWRXUyA9IHRydWU7XG4gICAgcmVkcmF3KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25EaXNjb25uZWN0ZWQoKSB7XG4gIGlmIChjb25uZWN0ZWRXUykge1xuICAgIGNvbm5lY3RlZFdTID0gZmFsc2U7XG4gICAgcmVkcmF3KCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWNvbm5lY3RDdXJyZW50KCkge1xuICBcbn1cblxubGV0IGNvbm5lY3RlZFdTID0gZmFsc2U7XG5cbmNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoJ2xpYi9zb2NrZXRXb3JrZXIuanMnKTtcbmNvbnN0IGRlZmF1bHRIYW5kbGVycyA9IHtcbiAgXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMb2JieShuYW1lLCBvbk9wZW4sIGhhbmRsZXJzKSB7XG4gIGNvbnN0IHNvY2tldEhhbmRsZXJzID0ge1xuICAgIG9uT3BlbjogKCkgPT4ge1xuICAgICAgc2Vzc2lvbi5yZWZyZXNoKCk7XG4gICAgICBvbk9wZW4oKTtcbiAgICB9LFxuICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycylcbiAgfTtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBuYW1lLFxuICAgICAgZGVidWc6IGdsb2JhbENvbmZpZy5tb2RlID09PSAnZGV2JyxcbiAgICAgIHBpbmdEZWxheTogMjAwMCxcbiAgICAgIHNlbmRPbk9wZW46IFtdLFxuICAgICAgcmVnaXN0ZXJlZEV2ZW50czogT2JqZWN0LmtleXMoc29ja2V0SGFuZGxlcnMuZXZlbnRzKVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXAgPSB7XG4gICAgY2xpZW50SWQ6IG5ld1NyaSgpLFxuICAgIHNvY2tldEVuZFBvaW50OiBnbG9iYWxDb25maWcuc29ja2V0RW5kUG9pbnQsXG4gICAgdXJsOiBgL2xvYmJ5L3NvY2tldC92JHtnbG9iYWxDb25maWcuYXBpVmVyc2lvbn1gLFxuICAgIG9wdHNcbiAgfTtcbiAgc2V0dXBDb25uZWN0aW9uKHNldHVwLCBzb2NrZXRIYW5kbGVycyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hc2EobWFzYUlkLCB2ZXJzaW9uLCBoYW5kbGVycykge1xuICBsZXQgdXJsID0gJy9tYXNhLycgKyBtYXNhSWQgKyBgL3NvY2tldC92JHtnbG9iYWxDb25maWcuYXBpVmVyc2lvbn1gO1xuICBjb25zdCBzb2NrZXRIYW5kbGVycyA9IHtcbiAgICBldmVudHM6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIYW5kbGVycywgaGFuZGxlcnMpLFxuICAgIG9uT3Blbjogc2Vzc2lvbi5iYWNrZ3JvdW5kUmVmcmVzaFxuICB9O1xuICBjb25zdCBvcHRzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIG5hbWU6ICdtYXNhJyxcbiAgICAgIGRlYnVnOiBnbG9iYWxDb25maWcubW9kZSA9PT0gJ2RldicsXG4gICAgICBwaW5nRGVsYXk6IDIwMDAsXG4gICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4gICAgfVxuICB9O1xuICBjb25zdCBzZXR1cCA9IHtcbiAgICBjbGllbnRJZDogbmV3U3JpKCksXG4gICAgc29ja2V0RW5kUG9pbnQ6IGdsb2JhbENvbmZpZy5zb2NrZXRFbmRQb2ludCxcbiAgICB1cmwsXG4gICAgdmVyc2lvbixcbiAgICBvcHRzXG4gIH07XG4gIHNldHVwQ29ubmVjdGlvbihzZXR1cCwgc29ja2V0SGFuZGxlcnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVHYW1lKFxuICB1cmwsXG4gIHZlcnNpb24sXG4gIGhhbmRsZXJzLFxuICBnYW1lVXJsKSB7XG4gIGNvbnN0IHNvY2tldEhhbmRsZXJzID0ge1xuICAgIG9uT3Blbjogc2Vzc2lvbi5iYWNrZ3JvdW5kUmVmcmVzaCxcbiAgICBldmVudHM6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIYW5kbGVycywgaGFuZGxlcnMpXG4gIH07XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgbmFtZTogJ2dhbWUnLFxuICAgICAgZGVidWc6IGdsb2JhbENvbmZpZy5tb2RlID09PSAnZGV2JyxcbiAgICAgIHNlbmRPbk9wZW46IFtdLFxuICAgICAgcmVnaXN0ZXJlZEV2ZW50czogT2JqZWN0LmtleXMoc29ja2V0SGFuZGxlcnMuZXZlbnRzKVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0dXAgPSB7XG4gICAgY2xpZW50SWQ6IG5ld1NyaSgpLFxuICAgIHNvY2tldEVuZFBvaW50OiBnbG9iYWxDb25maWcuc29ja2V0RW5kUG9pbnQsXG4gICAgdXJsLFxuICAgIHZlcnNpb24sXG4gICAgb3B0c1xuICB9O1xuICBcbiAgc2V0dXBDb25uZWN0aW9uKHNldHVwLCBzb2NrZXRIYW5kbGVycyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgY3JlYXRlR2FtZSxcbiAgY3JlYXRlTG9iYnksXG4gIGNyZWF0ZU1hc2EsXG4gIHJlY29ubmVjdEN1cnJlbnQsXG4gIHNldFZlcnNpb24odmVyc2lvbikge1xuICAgIHRlbGxXb3JrZXIod29ya2VyLCAnc2V0VmVyc2lvbicsIHZlcnNpb24pO1xuICB9LFxuICBzZW5kOiAodCwgZGF0YSwgb3B0cykgPT4ge1xuICAgIHRlbGxXb3JrZXIod29ya2VyLCAnc2VuZCcsIFt0LCBkYXRhLCBvcHRzXSk7XG4gIH0sXG4gIGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiBjb25uZWN0ZWRXUztcbiAgfSxcbiAgY29ubmVjdCgpIHtcbiAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ2Nvbm5lY3QnKTtcbiAgfSxcbiAgZGVzdHJveSgpIHtcbiAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ2Rlc3Ryb3knKTtcbiAgfVxufTtcblxuXG4vLy8gT0xEXG5cblxuLy8gY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcignbGliL3NvY2tldFdvcmtlci5qcycpO1xuXG4vLyBsZXQgc29ja2V0SGFuZGxlcnM7XG4vLyBsZXQgZXJyb3JEZXRlY3RlZCA9IGZhbHNlO1xuLy8gbGV0IGNvbm5lY3RlZFdTID0gdHJ1ZTtcblxuLy8gbGV0IGFscmVhZHlXYXJuZWQgPSBmYWxzZTtcbi8vIGxldCByZWRyYXdPbkRpc2Nvbm5lY3RlZFRpbWVvdXRJRDtcbi8vIGxldCBwcm94eUZhaWxUaW1lb3V0SUQ7XG4vLyBjb25zdCBwcm94eUZhaWxNc2cgPSBcIk95dW5rZXlmIHN1bnVjdWxhcsSxbmEgYmHEn2xhbnTEsSBrb3B0dS4gUHJvYmxlbSBzw7xyZWtsaSB5YcWfYW7EsXlvcnNhIHByb3h5IHlhZGEgbmV0d29yaydsYSBpbGdpbGkgb2xhYmlsaXIuXCI7XG5cbi8vIGNvbnN0IGRlZmF1bHRIYW5kbGVycyA9IHtcbi8vIH07XG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZUdhbWUodXJsLCB2ZXJzaW9uLCBoYW5kbGVycywgZ2FtZVVybCkge1xuLy8gICBlcnJvckRldGVjdGVkID0gZmFsc2U7XG4vLyAgIHNvY2tldEhhbmRsZXJzID0ge1xuLy8gICAgIG9uRXJyb3I6IGZ1bmN0aW9uKCkge1xuLy8gICAgICAgLy8gd2UgY2FuJ3QgZ2V0IHNvY2tldCBlcnJvciwgc28gd2Ugc2VuZCBhbiB4aHIgdG8gdGVzdCB3aGV0aGVyIHRoZVxuLy8gICAgICAgLy8gcmVqZWN0aW9uIGlzIGFuIGF1dGhvcml6YXRpb24gaXNzdWVcbi8vICAgICAgIGlmICghZXJyb3JEZXRlY3RlZCkge1xuLy8gICAgICAgICAvLyBqdXN0IHRvIGJlIHN1cmUgdGhhdCB3ZSBkb24ndCBzZW5kIGFuIHhociBldmVyeSBzZWNvbmQgd2hlbiB0aGVcbi8vICAgICAgICAgLy8gd2Vic29ja2V0IGlzIHRyeWluZyB0byByZWNvbm5lY3Rcbi8vICAgICAgICAgZXJyb3JEZXRlY3RlZCA9IHRydWU7XG4vLyAgICAgICAgIHhoci5nYW1lKGdhbWVVcmwuc3Vic3RyaW5nKDEpKS50aGVuKGZ1bmN0aW9uKCkge30sIGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcbi8vICAgICAgICAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bigndW5hdXRob3JpemVkRXJyb3InKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICAgICAgICAgICAgbS5yb3V0ZSgnLycpO1xuLy8gICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICB9XG4vLyAgICAgfSxcbi8vICAgICBldmVudHM6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRIYW5kbGVycywgaGFuZGxlcnMpXG4vLyAgIH07XG5cbi8vICAgY29uc3Qgb3B0cyA9IHtcbi8vICAgICBvcHRpb25zOiB7XG4vLyAgICAgICBuYW1lOiAnZ2FtZScsXG4vLyAgICAgICBkZWJ1ZzogZmFsc2UsXG4vLyAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbi8vICAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4vLyAgICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbi8vICAgICB1cmwsXG4vLyAgICAgdmVyc2lvbixcbi8vICAgICBvcHRzXG4vLyAgIH0pO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiBjcmVhdGVNYXNhKG1hc2FJZCwgdmVyc2lvbiwgaGFuZGxlcnMpIHtcbi8vICAgbGV0IHVybCA9ICcvbWFzYS8nICsgbWFzYUlkICsgJy9zb2NrZXQvdjEnO1xuXG4vLyAgIHNvY2tldEhhbmRsZXJzID0ge1xuLy8gICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycylcbi8vICAgfTtcbi8vICAgY29uc3Qgb3B0cyA9IHtcbi8vICAgICBvcHRpb25zOiB7XG4vLyAgICAgICBuYW1lOiAnbWFzYScsXG4vLyAgICAgICBkZWJ1ZzogZmFsc2UsXG4vLyAgICAgICBwaW5nRGVsYXk6IDIwMDAsXG4vLyAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbi8vICAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4vLyAgICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbi8vICAgICB1cmwsXG4vLyAgICAgdmVyc2lvbixcbi8vICAgICBvcHRzXG4vLyAgIH0pO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiBjcmVhdGVNYXNhSG9tZShoYW5kbGVycykge1xuLy8gICBsZXQgdXJsID0gJy9zb2NrZXQnO1xuXG4vLyAgIHNvY2tldEhhbmRsZXJzID0ge1xuLy8gICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEhhbmRsZXJzLCBoYW5kbGVycylcbi8vICAgfTtcbi8vICAgY29uc3Qgb3B0cyA9IHtcbi8vICAgICBwYXJhbXM6IHsgZmxhZzogJ21hc2EnIH0sXG4vLyAgICAgb3B0aW9uczoge1xuLy8gICAgICAgbmFtZTogJ21hc2FIb21lJyxcbi8vICAgICAgIGRlYnVnOiBmYWxzZSxcbi8vICAgICAgIHBpbmdEZWxheTogMjAwMCxcbi8vICAgICAgIHJlZ2lzdGVyZWRFdmVudHM6IE9iamVjdC5rZXlzKHNvY2tldEhhbmRsZXJzLmV2ZW50cylcbi8vICAgICB9XG4vLyAgIH07XG4vLyAgIHRlbGxXb3JrZXIod29ya2VyLCAnY3JlYXRlJywge1xuLy8gICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbi8vICAgICBzb2NrZXRFbmRQb2ludDogd2luZG93Lm95dW5rZXlmLnNvY2tldEVuZFBvaW50LFxuLy8gICAgIHVybCxcbi8vICAgICB2ZXJzaW9uOiAwLFxuLy8gICAgIG9wdHNcbi8vICAgfSk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIGNyZWF0ZUxvYmJ5KGxvYmJ5VmVyc2lvbiwgb25PcGVuLCBoYW5kbGVycykge1xuLy8gICBzb2NrZXRIYW5kbGVycyA9IHtcbi8vICAgICBvbk9wZW4sXG4vLyAgICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0SGFuZGxlcnMsIGhhbmRsZXJzKVxuLy8gICB9O1xuLy8gICBjb25zdCBvcHRzID0ge1xuLy8gICAgIG9wdGlvbnM6IHtcbi8vICAgICAgIG5hbWU6ICdsb2JieScsXG4vLyAgICAgICBkZWJ1ZzogZmFsc2UsXG4vLyAgICAgICBwaW5nRGVsYXk6IDIwMDAsXG4vLyAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4vLyAgICAgfVxuLy8gICB9O1xuLy8gICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbi8vICAgICBjbGllbnRJZDogb3l1bmtleWZTcmksXG4vLyAgICAgc29ja2V0RW5kUG9pbnQ6IHdpbmRvdy5veXVua2V5Zi5zb2NrZXRFbmRQb2ludCxcbi8vICAgICB1cmw6ICcvbG9iYnkvc29ja2V0L3YxJyxcbi8vICAgICB2ZXJzaW9uOiBsb2JieVZlcnNpb24sXG4vLyAgICAgb3B0c1xuLy8gICB9KTtcbi8vIH1cblxuXG4vLyBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0KCkge1xuLy8gICAvLyBkZWZhdWx0IHNvY2tldCBpcyB1c2VsZXNzIHdoZW4gYW5vbi4/XG4vLyAgIGlmIChoYXNOZXR3b3JrKCkpIHtcbi8vICAgICBzb2NrZXRIYW5kbGVycyA9IHtcbi8vICAgICAgIGV2ZW50czogZGVmYXVsdEhhbmRsZXJzXG4vLyAgICAgfTtcbi8vICAgICBjb25zdCBvcHRzID0ge1xuLy8gICAgICAgb3B0aW9uczoge1xuLy8gICAgICAgICBuYW1lOiAnZGVmYXVsdCcsXG4vLyAgICAgICAgIGRlYnVnOiBmYWxzZSxcbi8vICAgICAgICAgcGluZ0RlbGF5OiAyMDAwLFxuLy8gICAgICAgICByZWdpc3RlcmVkRXZlbnRzOiBPYmplY3Qua2V5cyhzb2NrZXRIYW5kbGVycy5ldmVudHMpXG4vLyAgICAgICB9XG4vLyAgICAgfTtcbi8vICAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ2NyZWF0ZScsIHtcbi8vICAgICAgIGNsaWVudElkOiBveXVua2V5ZlNyaSxcbi8vICAgICAgIHNvY2tldEVuZFBvaW50OiB3aW5kb3cub3l1bmtleWYuc29ja2V0RW5kUG9pbnQsXG4vLyAgICAgICB1cmw6ICcvc29ja2V0Jyxcbi8vICAgICAgIHZlcnNpb246IDAsXG4vLyAgICAgICBvcHRzXG4vLyAgICAgfSk7XG4vLyAgIH1cbi8vIH1cblxuLy8gZnVuY3Rpb24gb25Db25uZWN0ZWQoKSB7XG4vLyAgIGNvbnN0IHdhc09mZiA9ICFjb25uZWN0ZWRXUztcbi8vICAgY29ubmVjdGVkV1MgPSB0cnVlO1xuLy8gICBjbGVhclRpbWVvdXQocHJveHlGYWlsVGltZW91dElEKTtcbi8vICAgY2xlYXJUaW1lb3V0KHJlZHJhd09uRGlzY29ubmVjdGVkVGltZW91dElEKTtcbi8vICAgaWYgKHdhc09mZikgbS5yZWRyYXcoKTtcbi8vIH1cblxuLy8gZnVuY3Rpb24gb25EaXNjb25uZWN0ZWQoKSB7XG4vLyAgIGNvbnN0IHdhc09uID0gY29ubmVjdGVkV1M7XG4vLyAgIGNvbm5lY3RlZFdTID0gZmFsc2U7XG4vLyAgIGlmICh3YXNPbikgcmVkcmF3T25EaXNjb25uZWN0ZWRUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuLy8gICAgIG0ucmVkcmF3KCk7XG4vLyAgIH0sIDIwMDApO1xuLy8gICBpZiAod2FzT24gJiYgIWFscmVhZHlXYXJuZWQgJiYgIXN0b3JhZ2UuZ2V0KCdkb25vdHNob3dwcm94eWZhaWx3YXJuaW5nJykpIHByb3h5RmFpbFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuLy8gICAgIC8vIGNoZWNrIGlmIGRpc2Nvbm5lY3Rpb24gbGFzdHMsIGl0IGNvdWxkIG1lYW4gYSBwcm94eSBwcmV2ZW50c1xuLy8gICAgIC8vIGVzdGFibGlzaGluZyBhIHR1bm5lbFxuLy8gICAgIGlmIChoYXNOZXR3b3JrKCkgJiYgIWNvbm5lY3RlZFdTKSB7XG4vLyAgICAgICBhbHJlYWR5V2FybmVkID0gdHJ1ZTtcbi8vICAgICAgIHdpbmRvdy5uYXZpZ2F0b3Iubm90aWZpY2F0aW9uLmFsZXJ0KHByb3h5RmFpbE1zZywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIHN0b3JhZ2Uuc2V0KCdkb25vdHNob3dwcm94eWZhaWx3YXJuaW5nJywgdHJ1ZSk7XG4vLyAgICAgICB9KTtcbi8vICAgICB9XG4vLyAgIH0sIDIwMDAwKTtcbi8vIH1cblxuLy8gd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbi8vICAgc3dpdGNoKG1zZy5kYXRhLnRvcGljKSB7XG4vLyAgIGNhc2UgJ29uT3Blbic6XG4vLyAgICAgaWYgKHNvY2tldEhhbmRsZXJzLm9uT3Blbikgc29ja2V0SGFuZGxlcnMub25PcGVuKCk7XG4vLyAgICAgYnJlYWs7XG4vLyAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4vLyAgICAgb25EaXNjb25uZWN0ZWQoKTtcbi8vICAgICBicmVhaztcbi8vICAgY2FzZSAnY29ubmVjdGVkJzpcbi8vICAgICBvbkNvbm5lY3RlZCgpO1xuLy8gICAgIGJyZWFrO1xuLy8gICBjYXNlICdvbkVycm9yJzpcbi8vICAgICBpZiAoc29ja2V0SGFuZGxlcnMub25FcnJvcikgc29ja2V0SGFuZGxlcnMub25FcnJvcigpO1xuLy8gICAgIGJyZWFrO1xuLy8gICBjYXNlICdoYW5kbGUnOlxuLy8gICAgIHZhciBoID0gc29ja2V0SGFuZGxlcnMuZXZlbnRzW21zZy5kYXRhLnBheWxvYWQudF07XG4vLyAgICAgaWYgKGgpIGgobXNnLmRhdGEucGF5bG9hZC5kIHx8IG51bGwsIG1zZy5kYXRhLnBheWxvYWQpO1xuLy8gICAgIGJyZWFrO1xuLy8gICB9XG4vLyB9KTtcblxuLy8gLy8gZXhwb3J0IGRlZmF1bHQge1xuLy8gLy8gICBjcmVhdGVEZWZhdWx0LFxuLy8gLy8gICBjcmVhdGVNYXNhLFxuLy8gLy8gICBjcmVhdGVNYXNhSG9tZSxcbi8vIC8vICAgY3JlYXRlR2FtZSxcbi8vIC8vICAgY3JlYXRlTG9iYnksXG4vLyAvLyAgIHNldFZlcnNpb24odmVyc2lvbikge1xuLy8gLy8gICAgIHRlbGxXb3JrZXIod29ya2VyLCAnc2V0VmVyc2lvbicsIHZlcnNpb24pO1xuLy8gLy8gICB9LFxuLy8gLy8gICBzZW5kKHR5cGUsIGRhdGEsIG9wdHMpIHtcbi8vIC8vICAgICB0ZWxsV29ya2VyKHdvcmtlciwgJ3NlbmQnLCBbdHlwZSwgZGF0YSwgb3B0c10pO1xuLy8gLy8gICB9LFxuLy8gLy8gICBjb25uZWN0KCkge1xuLy8gLy8gICAgIHRlbGxXb3JrZXIod29ya2VyLCAnY29ubmVjdCcpO1xuLy8gLy8gICB9LFxuLy8gLy8gICBkaXNjb25uZWN0KCkge1xuLy8gLy8gICAgIHRlbGxXb3JrZXIod29ya2VyLCAnZGlzY29ubmVjdCcpO1xuLy8gLy8gICB9LFxuLy8gLy8gICBpc0Nvbm5lY3RlZCgpIHtcbi8vIC8vICAgICByZXR1cm4gY29ubmVjdGVkV1M7XG4vLyAvLyAgIH0sXG4vLyAvLyAgIGRlc3Ryb3koKSB7XG4vLyAvLyAgICAgdGVsbFdvcmtlcih3b3JrZXIsICdkZXN0cm95Jyk7XG4vLyAvLyAgIH0sXG4vLyAvLyAgIHRlcm1pbmF0ZSgpIHtcbi8vIC8vICAgICBpZiAod29ya2VyKSB3b3JrZXIudGVybWluYXRlKCk7XG4vLyAvLyAgIH1cbi8vIC8vIH07XG4iLCJ2YXIgdGltZW91dElkO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNwaW4oKSB7XG4gICAgaWYgKHRpbWVvdXRJZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdnbG9iYWxTcGlubmVyJykubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzcGlubmVyLmNsYXNzTmFtZSA9ICdzcGlubmVyIGdsb2JhbFNwaW5uZXInO1xuICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsICcwIDAgNDAgNDAnKTtcbiAgICBjb25zdCBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ2NpcmNsZScpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N4JywgJzIwJyk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3knLCAnMjAnKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdyJywgJzE4Jyk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKGNpcmNsZSk7XG4gICAgc3Bpbm5lci5hcHBlbmRDaGlsZChzdmcpO1xuXG4gICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwaW5uZXIpLCAyMDApO1xuICB9LFxuXG4gIHN0b3AoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgdGltZW91dElkID0gbnVsbDtcbiAgICBjb25zdCBzcGlubmVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2dsb2JhbFNwaW5uZXInKTtcbiAgICBpZiAoc3Bpbm5lcnMubGVuZ3RoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAoc3Bpbm5lcnNbMF0pIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3Bpbm5lcnNbMF0pO1xuICAgICAgfSwgNTAwKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VmRvbShjbGFzc2VzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9eydzcGlubmVyICcgKyBjbGFzc2VzfT5cbiAgICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDQwIDQwXCI+XG4gICAgICAgICAgPGNpcmNsZSBjeD1cIjIwXCIgY3k9XCIyMFwiIHI9XCIxOFwiIGZpbGw9XCJub25lXCI+PC9jaXJjbGU+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiZnVuY3Rpb24gd2l0aFN0b3JhZ2UoZikge1xuICAvLyBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHN0b3JhZ2UgaXMgZnVsbFxuICB0cnkge1xuICAgIHJldHVybiAhIXdpbmRvdy5sb2NhbFN0b3JhZ2UgPyBmKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIDogbnVsbDtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuZnVuY3Rpb24gZ2V0KGspIHtcbiAgcmV0dXJuIHdpdGhTdG9yYWdlKGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzLmdldEl0ZW0oaykpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShrKSB7XG4gIHJldHVybiB3aXRoU3RvcmFnZShmdW5jdGlvbihzKSB7XG4gICAgcy5yZW1vdmVJdGVtKGspO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldChrLCB2KSB7XG4gIHJldHVybiB3aXRoU3RvcmFnZShmdW5jdGlvbihzKSB7XG4gICAgcy5yZW1vdmVJdGVtKGspO1xuICAgIHMuc2V0SXRlbShrLCBKU09OLnN0cmluZ2lmeSh2KSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcm9wKGtleSwgaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgc2V0KGtleSwgYXJndW1lbnRzWzBdKTtcbiAgICBjb25zdCByZXQgPSBnZXQoa2V5KTtcbiAgICByZXR1cm4gKHJldCAhPT0gbnVsbCAmJiByZXQgIT09IHVuZGVmaW5lZCkgPyByZXQgOiBpbml0aWFsVmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0LFxuICBzZXQsXG4gIHJlbW92ZSxcbiAgcHJvcFxufTtcbiIsImltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uL3JvdXRlcic7XG5pbXBvcnQgeyBoYXNOZXR3b3JrLCBoYW5kbGVYaHJFcnJvciB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IGdhbWUgYXMgZ2FtZVhociB9IGZyb20gJy4uLy4uL3hocic7XG5pbXBvcnQgKiBhcyBzbGVlcFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3NsZWVwJztcbmltcG9ydCBPbmxpbmVSb3VuZCBmcm9tICcuLi9zaGFyZWQvcm91bmQvT25saW5lUm91bmQnO1xuaW1wb3J0IHJvdW5kVmlldyBmcm9tICcuLi9zaGFyZWQvcm91bmQvdmlldy9yb3VuZFZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdCh7IGF0dHJzIH0pIHtcbiAgICBsZXQgZ2FtZURhdGE7XG5cbiAgICBzbGVlcFV0aWxzLmtlZXBBd2FrZSgpO1xuXG4gICAgaWYgKGhhc05ldHdvcmsoKSkge1xuICAgICAgZ2FtZVhocihhdHRycy5pZClcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgZ2FtZURhdGEgPSBkYXRhO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3VuZCA9IG5ldyBPbmxpbmVSb3VuZChhdHRycy5pZCwgZGF0YSk7XG4gICAgICAgICAgfSwgNDAwKTtcblxuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgaGFuZGxlWGhyRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJvdXRlci5zZXQoJy8nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBvbmNyZWF0ZSh2bm9kZSkge1xuICAgIGlmICh2bm9kZS5kb20pXG4gICAgICBoZWxwZXIuZWxGYWRlSW4odm5vZGUuZG9tKTtcbiAgfSxcbiAgb25yZW1vdmUoKSB7XG4gICAgc2xlZXBVdGlscy5hbGxvd1NsZWVwQWdhaW4oKTtcbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgIGlmICh0aGlzLnJvdW5kKSB7XG4gICAgICB0aGlzLnJvdW5kLnVubG9hZCgpO1xuICAgIH1cbiAgfSxcbiAgdmlldyh7YXR0cnN9KSB7XG4gICAgaWYgKHRoaXMucm91bmQpIHJldHVybiByb3VuZFZpZXcodGhpcy5yb3VuZCk7XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG4iLCJpbXBvcnQgcG9wdXBXaWRnZXQgZnJvbSAnLi9zaGFyZWQvcG9wdXAnO1xuaW1wb3J0IGZvcm1XaWRnZXRzIGZyb20gJy4vc2hhcmVkL2Zvcm0nO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi9uZXdHYW1lRm9ybSc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4vaGVscGVyJztcbmltcG9ydCBpU2Nyb2xsIGZyb20gJ2lzY3JvbGwnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uL3NldHRpbmdzJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uL3Nlc3Npb24nO1xuaW1wb3J0IGJhY2tidXR0b24gZnJvbSAnLi4vYmFja2J1dHRvbic7XG5pbXBvcnQgbG9iYnkgZnJvbSAnLi9sb2JieSc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCBWaWV3T25seUJvYXJkIGZyb20gJy4vc2hhcmVkL1ZpZXdPbmx5Qm9hcmQnO1xuXG52YXIgc2Nyb2xsZXIgPSBudWxsO1xuXG5jb25zdCBnYW1lc01lbnUgPSB7fTtcblxuZ2FtZXNNZW51LmlzT3BlbiA9IGZhbHNlO1xuXG5nYW1lc01lbnUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goZ2FtZXNNZW51LmNsb3NlKTtcbiAgZ2FtZXNNZW51LmlzT3BlbiA9IHRydWU7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWxzLmhhc05ldHdvcmsoKSAmJiBzY3JvbGxlcikgc2Nyb2xsZXIuZ29Ub1BhZ2UoMSwgMCk7XG4gIH0sIDQwMCk7XG4gIHNlc3Npb24ucmVmcmVzaCgpO1xufTtcblxuZ2FtZXNNZW51LmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBnYW1lc01lbnUuaXNPcGVuKSBiYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBnYW1lc01lbnUuaXNPcGVuID0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBqb2luR2FtZShnKSB7XG4gIGdhbWVzTWVudS5jbG9zZSgpO1xuICBtLnJvdXRlKCcvZ2FtZS8nICsgZy5mdWxsSWQpO1xufVxuXG5mdW5jdGlvbiBjYXJkRGltcygpIHtcbiAgY29uc3QgdnAgPSBoZWxwZXIudmlld3BvcnREaW0oKTtcblxuICAvLyBpZiB3ZSdyZSBoZXJlIGl0J3MgYSBwaG9uZVxuICBsZXQgd2lkdGggPSAyMDA7XG4gIGxldCBoZWlnaHQgPSB3aWR0aCAvICg0LzMpO1xuICBsZXQgbWFyZ2luID0gMTA7XG4gIHJldHVybiB7XG4gICAgdzogd2lkdGggKyBtYXJnaW4gKiAyLFxuICAgIGg6IGhlaWdodCArIDcwLFxuICAgIGlubmVyVzogd2lkdGgsXG4gICAgbWFyZ2luOiBtYXJnaW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVmlld09ubHlCb2FyZChjRGltLCBmZW4sIG9yaWVudGF0aW9uLCB2YXJpYW50KSB7XG4gIGNvbnN0IGlubmVySCA9IGNEaW0gPyBjRGltLmlubmVyVyAvICg0LzMpOiAwO1xuICBjb25zdCBpbm5lclcgPSBjRGltID8gY0RpbS5pbm5lclcgOiAwO1xuICBjb25zdCBzdHlsZSA9IGNEaW0gPyB7IGhlaWdodDogaW5uZXJIICsgJ3B4JyB9IDoge307XG4gIGNvbnN0IGJvdW5kcyA9IGNEaW0gPyB7IHdpZHRoOiBpbm5lclcsIGhlaWdodDogaW5uZXJIIH0gOiBudWxsO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9hcmRXcmFwcGVyXCIgc3R5bGU9e3N0eWxlfT5cbiAgICAgIHttLmNvbXBvbmVudChWaWV3T25seUJvYXJkLCB7IGJvdW5kcywgZmVuLCBvcmllbnRhdGlvbiwgdmFyaWFudH0pfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiB0aW1lTGVmdChnKSB7XG4gIGlmICghZy5pc015VHVybikgcmV0dXJuIGkxOG4oJ3dhaXRpbmdGb3JPcHBvbmVudCcpO1xuICByZXR1cm4gaTE4bigneW91clR1cm4nKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyR2FtZShnLCBjRGltLCBjYXJkU3R5bGUpIHtcbiAgY29uc3QgaWNvbiA9IHV0aWxzLmdhbWVJY29uKGcucGVyZik7XG4gIGNvbnN0IGNhcmRDbGFzcyA9IFtcbiAgICAnY2FyZCcsXG4gICAgJ3N0YW5kYXJkJ1xuICBdLmpvaW4oJyAnKTtcblxuICBjb25zdCB0aW1lQ2xhc3MgPSBbXG4gICAgJ3RpbWVJbmRpY2F0aW9uJyxcbiAgICBnLmlzTXlUdXJuID8gJ215VHVybic6ICdvcHBvbmVudFR1cm4nXG4gIF0uam9pbignICcpO1xuICBjb25zdCBjb25maWcgPSBoZWxwZXIub250b3VjaFgoKCkgPT4gam9pbkdhbWUoZykpO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NhcmRDbGFzc30ga2V5PXsnZ2FtZS4nICsgZy5nYW1lSWR9IHN0eWxlPXtjYXJkU3R5bGV9XG4gICAgY29uZmlnPXtjb25maWd9PlxuICAgICAge3JlbmRlclZpZXdPbmx5Qm9hcmQoY0RpbSwgZy5mZW4sIGcuc2lkZSwgZy52YXJpYW50KX1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb3NcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZXNjcmlwdGlvblwiPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidmFyaWFudFwiPntnLnZhcmlhbnQubmFtZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3RpbWVDbGFzc30+e3RpbWVMZWZ0KGcpfTwvc3Bhbj5cbiAgICAgICAgICA8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFsbEdhbWVzKGNEaW0pIHtcbiAgY29uc3Qgbm93UGxheWluZyA9IHNlc3Npb24ubm93UGxheWluZygpOyAvLyAuY29uY2F0KHNlc3Npb24ubm93UGxheWluZygpKTtcbiAgY29uc3QgY2FyZFN0eWxlID0gY0RpbSA/IHtcbiAgICB3aWR0aDogKGNEaW0udyAtIGNEaW0ubWFyZ2luICogMikgKyAncHgnLFxuICAgIGhlaWdodDogY0RpbS5oICsgJ3B4JyxcbiAgICBtYXJnaW5MZWZ0OiBjRGltLm1hcmdpbiArICdweCcsXG4gICAgbWFyZ2luUmlnaHQ6IGNEaW0ubWFyZ2luICsgJ3B4J1xuICB9IDoge307XG5cbiAgY29uc3QgbmJDYXJkcyA9IHV0aWxzLmhhc05ldHdvcmsoKSA/XG4gICAgICAgICAgICAgICAgICBub3dQbGF5aW5nLmxlbmd0aCArIDEgOlxuICAgICAgICAgICAgICAgICAgMDtcblxuICBsZXQgd3JhcHBlclN0eWxlLCB3cmFwcGVyV2lkdGg7XG4gIGlmIChjRGltKSB7XG4gICAgLy8gc2Nyb2xsZXIgd3JhcHBlciB3aWR0aFxuICAgIC8vIGNhbGN1bCBpczpcbiAgICAvLyAoKGNhcmRXaWR0aCArIHZpc2libGUgcGFydCBvZiBhZGphY2VudCBjYXJkKSAqIG5iIG9mIGNhcmRzKSArXG4gICAgLy8gd3JhcHBlcidzIG1hcmdpbkxlZnRcbiAgICB3cmFwcGVyV2lkdGggPSAoKGNEaW0udyArIGNEaW0ubWFyZ2luICogMikgKiBuYkNhcmRzKSArXG4gICAgICAgICAgICAgICAgICAgKGNEaW0ubWFyZ2luICogMik7XG4gICAgd3JhcHBlclN0eWxlID0ge1xuICAgICAgd2lkdGg6IHdyYXBwZXJXaWR0aCArICdweCcsXG4gICAgICBtYXJnaW5MZWZ0OiAoY0RpbS5tYXJnaW4gKiAzKSArICdweCdcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFsbENhcmRzID0gbm93UGxheWluZy5tYXAoZyA9PiByZW5kZXJHYW1lKGcsIGNEaW0sIGNhcmRTdHlsZSkpO1xuXG4gIGlmICghaGVscGVyLmlzV2lkZVNjcmVlbigpKSB7XG5cbiAgICBjb25zdCBuZXdHYW1lQ2FyZCA9IChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZCBzdGFuZGFyZFwiIGtleT1cImdhbWUubmV3LWdhbWVcIiBzdHlsZT17Y2FyZFN0eWxlfVxuICAgICAgICAgICBjb25maWc9e2hlbHBlci5vbnRvdWNoWCgoKSA9PiB7IGdhbWVzTWVudS5jbG9zZSgpOyBuZXdHYW1lRm9ybS5vcGVuKCk7IH0pfT5cbiAgICAgICAge3JlbmRlclZpZXdPbmx5Qm9hcmQoY0RpbSl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb3NcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGl0bGVcIj57aTE4bignY3JlYXRlQUdhbWUnKX08L2gyPlxuICAgICAgICAgICAgPHA+e2kxOG4oJ25ld09wcG9uZW50Jyl9PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gICAgaWYgKHV0aWxzLmhhc05ldHdvcmsoKSkgYWxsQ2FyZHMudW5zaGlmdChuZXdHYW1lQ2FyZCk7XG4gIH1cblxuICByZXR1cm4gbSgnZGl2I2FsbF9nYW1lcycsIHsgc3R5bGU6IHdyYXBwZXJTdHlsZSB9LCBhbGxDYXJkcyk7XG59XG5cblxuZ2FtZXNNZW51LnZpZXcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFnYW1lc01lbnUuaXNPcGVuKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCB2aCA9IGhlbHBlci52aWV3cG9ydERpbSgpLnZoXG4gIGNvbnN0IGNEaW0gPSBjYXJkRGltcygpO1xuICBjb25zdCB3cmFwcGVyU3R5bGUgPSBoZWxwZXIuaXNXaWRlU2NyZWVuKCkgPyB7fSA6IHsgdG9wOiAoKHZoIC0gY0RpbS5oKSAvIDIpICsgJ3B4JyB9O1xuICBjb25zdCB3cmFwcGVyQ29uZmlnID1cbiAgaGVscGVyLmlzV2lkZVNjcmVlbigpID8gdXRpbHMubm9vcCA6XG4gIGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuICAgIGlmICghaXNVcGRhdGUpIHtcbiAgICAgIHNjcm9sbGVyID0gbmV3IGlTY3JvbGwoZWwsIHtcbiAgICAgICAgc2Nyb2xsWDogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsWTogZmFsc2UsXG4gICAgICAgIG1vbWVudHVtOiBmYWxzZSxcbiAgICAgICAgc25hcDogJy5jYXJkJyxcbiAgICAgICAgc25hcFNwZWVkOiA0MDAsXG4gICAgICAgIHByZXZlbnREZWZhdWx0RXhjZXB0aW9uOiB7XG4gICAgICAgICAgdGFnTmFtZTogL14oSU5QVVR8VEVYVEFSRUF8QlVUVE9OfFNFTEVDVHxMQUJFTCkkL1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29udGV4dC51bm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2Nyb2xsZXIpIHtcbiAgICAgICAgICBzY3JvbGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgc2Nyb2xsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1YmlxL2lzY3JvbGwvaXNzdWVzLzQxMlxuICAgIHNjcm9sbGVyLm9wdGlvbnMuc25hcCA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJkJyk7XG4gICAgc2Nyb2xsZXIucmVmcmVzaCgpO1xuICB9O1xuXG4gIGNvbnN0IGlzV2lkZVNjcmVlbiA9IGhlbHBlci5pc1dpZGVTY3JlZW4oKTtcblxuICBjb25zdCB3cmFwcGVyQ2xhc3MgPSBpc1dpZGVTY3JlZW4gPyAnb3ZlcmxheV9wb3B1cCcgOiAnJztcblxuICByZXR1cm4gKFxuICAgIDxkaXYgaWQ9XCJnYW1lc19tZW51XCIgY2xhc3NOYW1lPVwib3ZlcmxheV9wb3B1cF93cmFwcGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIndyYXBwZXJfb3ZlcmxheV9jbG9zZVwiXG4gICAgICAgICAgIGNvbmZpZz17aGVscGVyLm9udG91Y2goaGVscGVyLmZhZGVzT3V0KGdhbWVzTWVudS5jbG9zZSwgJy5vdmVybGF5X3BvcHVwX3dyYXBwZXInKSl9Lz5cbiAgICAgIDxkaXYgaWQ9XCJ3cmFwcGVyX2dhbWVzXCIgY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3N9IHN0eWxlPXt3cmFwcGVyU3R5bGV9IGNvbmZpZz17d3JhcHBlckNvbmZpZ30+XG4gICAgICAgIHsgaXNXaWRlU2NyZWVuID8gKFxuICAgICAgICAgIDxoZWFkZXI+XG4gICAgICAgICAgICB7aTE4bignbmJHYW1lc0luUGxheScsIHNlc3Npb24ubm93UGxheWluZygpLmxlbmd0aCl9XG4gICAgICAgICAgPC9oZWFkZXI+XG4gICAgICAgICkgOiBudWxsIH1cbiAgICAgICAgeyBpc1dpZGVTY3JlZW4gPyAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cF9jb250ZW50XCI+XG4gICAgICAgICAge3JlbmRlckFsbEdhbWVzKG51bGwpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogcmVuZGVyQWxsR2FtZXMoY0RpbSkgfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnYW1lc01lbnU7XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuXG5cbnZhciBhbmltYXRpbmcgPSBmYWxzZTtcblxuLy8gQXV0aG9yIEJhcm5leSBDYXJvbGxcbi8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFybmV5Y2Fycm9sbC9jNjlmYmUwNzg2ZTM3Yzk0MWJhZlxuXG4vLyBEZWZpbmUgYW4gYW5pbWF0b3IgY29uc2lzdGluZyBvZiBvcHRpb25hbCBpbmNvbWluZyBhbmQgb3V0Z29pbmcgYW5pbWF0aW9ucy5cbi8vIGFsd2F5c0FuaW1hdGUgaXMgZmFsc2UgdW5sZXNzIHNwZWNpZmllZCBhcyB0cnVlOiBmYWxzZSBtZWFucyBhbiBpbmNvbWluZyBhbmltYXRpb24gd2lsbCBvbmx5IHRyaWdnZXIgaWYgYW4gb3V0Z29pbmcgYW5pbWF0aW9uIGlzIGFsc28gaW4gcHJvZ3Jlc3MuXG4vLyBmb3JjaW5nIGRvbnRDbG9uZSB0byB0cnVlIG1lYW5zIHRoZSBvdXR3YXJkIGFuaW1hdGlvbiB3aWxsIHVzZSB0aGUgb3JpZ2luYWwgZWxlbWVudCByYXRoZXIgdGhhbiBhIGNsb25lLiBUaGlzIGNvdWxkIGltcHJvdmUgcGVyZm9ybWFuY2UgYnkgcmVjeWNsaW5nIGVsZW1lbnRzLCBidXQgY2FuIGxlYWQgdG8gdHJvdWJsZTogY2xvbmVzIGhhdmUgdGhlIGFkdmFudGFnZSBvZiBiZWluZyBzdHJpcHBlZCBvZiBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYW5pbWF0b3IoaW5jb21pbmcsIG91dGdvaW5nLCBhbHdheXNBbmltYXRlLCBkb250Q2xvbmUpIHtcbiAgLy8gVGhlIHJlc3VsdGluZyBhbmltYXRvciBjYW4gYmUgYXBwbGllZCB0byBhbnkgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGUoIHgsIHksIHogKXtcbiAgICB2YXIgY29uZmlnO1xuICAgIHZhciBwYXJlbnQ7XG4gICAgdmFyIG5leHQ7XG5cbiAgICAvLyBXaGVuIHVzZWQgYXMgYSBjb25maWcgZnVuY3Rpb25cbiAgICBpZiAoIHgubm9kZVR5cGUgKSB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uQ29uZmlnKHgsIHksIHopO1xuICAgIH1cbiAgICAvLyBXaGVuIHBhc3NlZCBhIHZpcnR1YWwgRE9NIG5vZGUgKHRoZSBvdXRwdXQgb2YgbSlcbiAgICBlbHNlIGlmICggeC5hdHRycyApIHtcbiAgICAgIHJldHVybiBiaW5kQ29uZmlnVG8oIHggKTtcbiAgICB9XG4gICAgLy8gV2hlbiBhcHBsaWVkIHRvIGEgTWl0aHJpbCBtb2R1bGUgLyBjb21wb25lbnRcbiAgICBlbHNlIGlmICggeC52aWV3ICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udHJvbGxlcjogeC5jb250cm9sbGVyIHx8IG5vb3AsXG4gICAgICAgIHZpZXc6IGZ1bmN0aW9uIGFuaW1hdGVkVmlldyhjdHJsKXtcbiAgICAgICAgICByZXR1cm4gYmluZENvbmZpZ1RvKHgudmlldyhjdHJsKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZENvbmZpZ1RvKCBub2RlICl7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuXG4gICAgICBjb25maWcgPSBub2RlLmF0dHJzLmNvbmZpZztcblxuICAgICAgbm9kZS5hdHRycy5jb25maWcgPSBhbmltYXRpb25Db25maWc7XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFuaW1hdGlvbkNvbmZpZyhlbCwgaW5pdCwgY29udGV4dCl7XG4gICAgICB2YXIgb3V0cHV0O1xuICAgICAgdmFyIG9udW5sb2FkO1xuXG4gICAgICBpZiAoY29uZmlnKXtcbiAgICAgICAgb3V0cHV0ID0gY29uZmlnKGVsLCBpbml0LCBjb250ZXh0KTtcbiAgICAgICAgLy8gSWYgdGhlIHJvb3QgZWxlbWVudCBhbHJlYWR5IGhhcyBhIGNvbmZpZywgaXQgbWF5IGFsc28gaGF2ZSBhbiBvbnVubG9hZCB3aGljaCB3ZSBzaG91bGQgdGFrZSBjYXJlIHRvIHByZXNlcnZlXG4gICAgICAgIG9udW5sb2FkID0gY29udGV4dC5vbnVubG9hZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhaW5pdCApe1xuICAgICAgICBpZiAoaW5jb21pbmcgJiYgYWx3YXlzQW5pbWF0ZSB8fCBhbmltYXRpbmcpIHtcbiAgICAgICAgICBpbmNvbWluZyhlbCwgbm9vcCwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm9udW5sb2FkID0gb3V0Z29pbmcgPyBvbnVubG9hZCA/IGZ1bmN0aW9uIG9udW5sb2FkV3JhcHBlcigpIHtcbiAgICAgICAgICB0ZWFyZG93bigpO1xuICAgICAgICAgIG9udW5sb2FkKCk7XG4gICAgICAgIH0gOiB0ZWFyZG93biA6IG9udW5sb2FkO1xuXG4gICAgICAgIHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIG5leHQgPSBlbC5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcblxuICAgICAgZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgICAgIHZhciBpbnNlcnRpb24gPSBkb250Q2xvbmUgPyBlbCA6IGVsLmNsb25lTm9kZSggdHJ1ZSApO1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gbnVsbDtcblxuICAgICAgICBpZiAoIG5leHQgJiYgcGFyZW50ICYmIG5leHQucGFyZW50Tm9kZSA9PT0gcGFyZW50ICl7XG4gICAgICAgICAgcmVmZXJlbmNlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGluZyA9IHRydWU7XG5cbiAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24gcmVzZXRBbmltYXRpb25GbGFnKCl7XG4gICAgICAgICAgYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIH0sIDAgKTtcblxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKCBpbnNlcnRpb24sIHJlZmVyZW5jZSApO1xuXG4gICAgICAgIG91dGdvaW5nKCBpbnNlcnRpb24sIGZ1bmN0aW9uIGRlc3Ryb3koKXtcbiAgICAgICAgICBpZiAoIHBhcmVudC5jb250YWlucyggaW5zZXJ0aW9uICkgKXtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCggaW5zZXJ0aW9uICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjb250ZXh0ICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmNvbnN0IEhPTERfRFVSQVRJT04gPSA2MDA7XG5jb25zdCBSRVBFQVRfUkFURSA9IDIwO1xuY29uc3QgU0NST0xMX1RPTEVSQU5DRSA9IDg7XG5jb25zdCBBQ1RJVkVfQ0xBU1MgPSAnYWN0aXZlJztcblxuZnVuY3Rpb24gaGFzQ29udGV4dE1lbnUoKSB7XG4gIHJldHVybiB3aW5kb3cuY29yZG92YS5wbGF0Zm9ybUlkICE9PSAnaW9zJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnV0dG9uSGFuZGxlcihlbCxcbiAgdGFwSGFuZGxlcixcbiAgaG9sZEhhbmRsZXIsXG4gIHJlcGVhdEhhbmRsZXIsXG4gIHNjcm9sbFgsXG4gIHNjcm9sbFksXG4gIHRvdWNoRW5kRmVlZGJhY2spIHtcblxuICBsZXQgc3RhcnRYLCBzdGFydFksIGJvdW5kYXJpZXMsIGFjdGl2ZSwgaG9sZFRpbWVvdXRJRCwgcmVwZWF0VGltZW91dElkLCByZXBlYXRJbnRlcnZhbElEO1xuXG4gIGlmICh0eXBlb2YgdGFwSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1dHRvbkhhbmRsZXIgMm5kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbiEnKTtcblxuICBpZiAoaG9sZEhhbmRsZXIgJiYgdHlwZW9mIGhvbGRIYW5kbGVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignQnV0dG9uSGFuZGxlciAzcmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuXG4gIGlmIChyZXBlYXRIYW5kbGVyICYmIHR5cGVvZiByZXBlYXRIYW5kbGVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignQnV0dG9uSGFuZGxlciA0cmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIScpO1xuXG4gIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ob3ctamF2YXNjcmlwdC10aW1lcnMtd29yay9cbiAgZnVuY3Rpb24gb25SZXBlYXQoKSB7XG4gICAgdmFyIHJlcyA9IHJlcGVhdEhhbmRsZXIoKTtcbiAgICByZXBlYXRJbnRlcnZhbElEID0gc2V0VGltZW91dChvblJlcGVhdCwgUkVQRUFUX1JBVEUpO1xuICAgIGlmICghcmVzKSBjbGVhclRpbWVvdXQocmVwZWF0SW50ZXJ2YWxJRCk7XG4gICAgbS5yZWRyYXcoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgbGV0IHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICBsZXQgYm91bmRpbmdSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgc3RhcnRYID0gdG91Y2guY2xpZW50WDtcbiAgICBzdGFydFkgPSB0b3VjaC5jbGllbnRZO1xuICAgIGJvdW5kYXJpZXMgPSB7XG4gICAgICBtaW5YOiBib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgIG1heFg6IGJvdW5kaW5nUmVjdC5yaWdodCxcbiAgICAgIG1pblk6IGJvdW5kaW5nUmVjdC50b3AsXG4gICAgICBtYXhZOiBib3VuZGluZ1JlY3QuYm90dG9tXG4gICAgfTtcbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGFjdGl2ZSkgZWwuY2xhc3NMaXN0LmFkZChBQ1RJVkVfQ0xBU1MpO1xuICAgIH0sIDIwMCk7XG4gICAgaWYgKCFoYXNDb250ZXh0TWVudSgpKSBob2xkVGltZW91dElEID0gc2V0VGltZW91dChvbkhvbGQsIEhPTERfRFVSQVRJT04pO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRJbnRlcnZhbElEKTtcbiAgICBpZiAocmVwZWF0SGFuZGxlcikgcmVwZWF0VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXBlYXRJbnRlcnZhbElEID0gc2V0VGltZW91dChvblJlcGVhdCwgUkVQRUFUX1JBVEUpO1xuICAgIH0sIDE1MCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgLy8gaWYgZ29pbmcgb3V0IG9mIGJvdW5kcywgbm8gd2F5IHRvIHJlZW5hYmxlIHRoZSBidXR0b25cbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBsZXQgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgYWN0aXZlID0gaXNBY3RpdmUodG91Y2gpO1xuICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvbGRUaW1lb3V0SUQpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVwZWF0VGltZW91dElkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcGVhdEludGVydmFsSUQpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XG4gICAgaWYgKGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRUaW1lb3V0SWQpO1xuICAgIGNsZWFyVGltZW91dChyZXBlYXRJbnRlcnZhbElEKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaG9sZFRpbWVvdXRJRCk7XG4gICAgICBpZiAodG91Y2hFbmRGZWVkYmFjaykgZWwuY2xhc3NMaXN0LmFkZChBQ1RJVkVfQ0xBU1MpO1xuICAgICAgdGFwSGFuZGxlcihlKTtcbiAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyksIDgwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblRvdWNoQ2FuY2VsKCkge1xuICAgIGNsZWFyVGltZW91dChob2xkVGltZW91dElEKTtcbiAgICBjbGVhclRpbWVvdXQocmVwZWF0VGltZW91dElkKTtcbiAgICBjbGVhclRpbWVvdXQocmVwZWF0SW50ZXJ2YWxJRCk7XG4gICAgYWN0aXZlID0gZmFsc2U7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShBQ1RJVkVfQ0xBU1MpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Db250ZXh0TWVudShlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGhvbGRUaW1lb3V0SUQgPT09IHVuZGVmaW5lZCkgb25Ib2xkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkhvbGQoKSB7XG4gICAgaWYgKGhvbGRIYW5kbGVyKSB7XG4gICAgICBob2xkSGFuZGxlcigpO1xuICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKEFDVElWRV9DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNBY3RpdmUodG91Y2gpIHtcbiAgICBsZXQgeCA9IHRvdWNoLmNsaWVudFgsXG4gICAgICB5ID0gdG91Y2guY2xpZW50WSxcbiAgICAgIGIgPSBib3VuZGFyaWVzLFxuICAgICAgZCA9IDA7XG4gICAgaWYgKHNjcm9sbFgpIGQgPSBNYXRoLmFicyh4IC0gc3RhcnRYKTtcbiAgICBpZiAoc2Nyb2xsWSkgZCA9IE1hdGguYWJzKHkgLSBzdGFydFkpO1xuICAgIHJldHVybiB4IDwgYi5tYXhYICYmIHggPiBiLm1pblggJiYgeSA8IGIubWF4WSAmJiB5ID4gYi5taW5ZICYmIGQgPCBTQ1JPTExfVE9MRVJBTkNFO1xuICB9XG5cbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBvblRvdWNoQ2FuY2VsLCBmYWxzZSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UpO1xufVxuIiwiaW1wb3J0IFphbmltbyBmcm9tICd6YW5pbW8nO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IEJ1dHRvbkhhbmRsZXIgZnJvbSAnLi9idXR0b24nO1xuaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmNvbnN0IGFuaW1EdXJhdGlvbiA9IDI1MDtcblxuZnVuY3Rpb24gY3JlYXRlVGFwSGFuZGxlcih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgc2Nyb2xsWCwgc2Nyb2xsWSwgZ2V0RWxlbWVudCwgcHJldmVudEVuZERlZmF1bHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZub2RlKSB7XG4gICAgQnV0dG9uSGFuZGxlcih2bm9kZS5kb20sXG4gICAgICAgICAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0YXBIYW5kbGVyKGUpO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBob2xkSGFuZGxlciA/IChlKSA9PiB1dGlscy5hdXRvcmVkcmF3KCgpID0+IGhvbGRIYW5kbGVyKGUpKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIHJlcGVhdEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICBzY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgc2Nyb2xsWSxcbiAgICAgICAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICBwcmV2ZW50RW5kRGVmYXVsdCk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbnRhcCh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgZ2V0RWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlVGFwSGFuZGxlcih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgcmVwZWF0SGFuZGxlciwgZmFsc2UsIGZhbHNlLCBnZXRFbGVtZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9udGFwWFkodGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIGdldEVsZW1lbnQsIHByZXZlbnRFbmREZWZhdWx0ID0gdHJ1ZSkge1xuICByZXR1cm4gY3JlYXRlVGFwSGFuZGxlcih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgdW5kZWZpbmVkLCB0cnVlLCB0cnVlLCBnZXRFbGVtZW50LCBwcmV2ZW50RW5kRGVmYXVsdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbGlkZXNJblVwKHZub2RlKSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZG9tO1xuICBlbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgxMDAlKSc7XG4gIHZub2RlLnN0YXRlLmxvbCA9IGVsLm9mZnNldEhlaWdodDtcbiAgcmV0dXJuIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDApJywgMjUwLCAnZWFzZS1vdXQnKVxuICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsaWRlc091dERvd24oY2FsbGJhY2ssIGVsSUQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZyb21CQikge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxJRCk7XG4gICAgcmV0dXJuIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDEwMCUpJywgMjUwLCAnZWFzZS1vdXQnKVxuICAgICAgLnRoZW4oKCkgPT4gdXRpbHMuYXV0b3JlZHJhdygoKSA9PiBjYWxsYmFjayhmcm9tQkIpKSlcbiAgICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKTtcbiAgfTtcbn1cblxuXG5cbi8vIGVsIGZhZGUgaW4gdHJhbnNpdGlvbiwgY2FuIGJlIGFwcGxpZWQgdG8gYW55IGVsZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBlbEZhZGVJbihlbCwgZHVyYXRpb24gPSBhbmltRHVyYXRpb24sIG9yaWdPcGFjaXR5ID0gJzAuNScsIGVuZE9wYWNpdHkgPSAnMScpIHtcbiAgbGV0IHRJZDtcblxuICBlbC5zdHlsZS5vcGFjaXR5ID0gb3JpZ09wYWNpdHk7XG4gIGVsLnN0eWxlLnRyYW5zaXRpb24gPSBgb3BhY2l0eSAke2R1cmF0aW9ufW1zIGVhc2Utb3V0YDtcblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBlbC5zdHlsZS5vcGFjaXR5ID0gZW5kT3BhY2l0eTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRJZCk7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgYWZ0ZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgYWZ0ZXIsIGZhbHNlKTtcbiAgLy8gaW4gY2FzZSB0cmFuc2l0aW9uZW5kIGRvZXMgbm90IGZpcmVcbiAgdElkID0gc2V0VGltZW91dChhZnRlciwgZHVyYXRpb24gKyAxMCk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1dHRvbihlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICByZXR1cm4gdGFyZ2V0LnRhZ05hbWUgPT09ICdCVVRUT04nID8gdGFyZ2V0IDogZmluZFBhcmVudEJ5U2VsZWN0b3IodGFyZ2V0LCAnYnV0dG9uJyk7XG59XG5cbi8vIE9MRFxuXG4vL3N0b3JlIHRlbXBvcmFyaWx5IGxhc3Qgcm91dGUgdG8gZGlzYWJsZSBhbmltYXRpb25zIG9uIHNhbWUgcm91dGVcbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgY2F1c2UgdGhpcyBpcyB1Z2x5XG5sZXQgbGFzdFJvdXRlO1xuXG4vLyB0aGlzIG11c3QgYmUgY2FjaGVkIGJlY2F1c2Ugb2YgdGhlIGFjY2VzcyB0byBkb2N1bWVudC5ib2R5LnN0eWxlXG5sZXQgY2FjaGVkVHJhbnNmb3JtUHJvcDtcbmxldCBjYWNoZWRWaWV3cG9ydERpbSA9IG51bGw7XG5cbmZ1bmN0aW9uIHZpZXdTbGlkZUluKGVsLCBjYWxsYmFjaykge1xuICBpZiAobS5yb3V0ZSgpID09PSBsYXN0Um91dGUpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxhc3RSb3V0ZSA9IG0ucm91dGUoKTtcblxuICBmdW5jdGlvbiBhZnRlcigpIHtcbiAgICB1dGlscy5zZXRWaWV3U2xpZGVEaXJlY3Rpb24oJ2Z3ZCcpO1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgY29uc3QgZGlyZWN0aW9uID0gdXRpbHMuZ2V0Vmlld1NsaWRlRGlyZWN0aW9uKCkgPT09ICdmd2QnID8gJzEwMCUnIDogJy0xMDAlJztcbiAgZWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7ZGlyZWN0aW9ufSwwLDApYDtcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICd0cmFuc2Zvcm0gMjAwbXMgZWFzZS1vdXQnO1xuXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybT0gJ3RyYW5zbGF0ZTNkKDAlLDAsMCknO1xuICB9KTtcblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgYWZ0ZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gdmlld1NsaWRlT3V0KGVsLCBjYWxsYmFjaykge1xuICBpZiAobS5yb3V0ZSgpID09PSBsYXN0Um91dGUpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIHV0aWxzLnNldFZpZXdTbGlkZURpcmVjdGlvbignZndkJyk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGNvbnN0IGRpcmVjdGlvbiA9IHV0aWxzLmdldFZpZXdTbGlkZURpcmVjdGlvbigpID09PSAnZndkJyA/ICctMTAwJScgOiAnMTAwJSc7XG4gIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwJSwwLDApJztcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICd0cmFuc2Zvcm0gMjAwbXMgZWFzZS1vdXQnO1xuXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybT0gYHRyYW5zbGF0ZTNkKCR7ZGlyZWN0aW9ufSwwLDApYDtcbiAgfSk7XG5cbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGFmdGVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHZpZXdGYWRlc0luKGVsLCBjYWxsYmFjaykge1xuICB2YXIgdElkO1xuXG4gIGVsLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDIwMG1zIGVhc2Utb3V0JztcblxuICBzZXRUaW1lb3V0KCgpPT4ge1xuICAgIGVsLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIGNsZWFyVGltZW91dCh0SWQpO1xuICAgIGlmIChlbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVkJywgYWZ0ZXIsIGZhbHNlKTtcbiAgICB9XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lZCcsIGFmdGVyLCBmYWxzZSk7XG5cbiAgLy8gaW4gY2FzZSB0cmFuc2l0aW9uZWQgZG9lcyBub3QgZmlyZVxuICAvLyBUT0RPIGZpbmQgYSB3YXkgdG8gYXZvaWQgaXRcbiAgdElkID0gc2V0VGltZW91dChhZnRlciwgMjUwKTtcbn1cblxuZnVuY3Rpb24gdmlld0ZhZGVzT3V0KGVsLCBjYWxsYmFjaykge1xuICB2YXIgdElkO1xuXG4gIGVsLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gIGVsLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAyMDBtcyBlYXNlLW91dCwgdmlzaWJpbGl0eSAwcyBsaW5lYXIgMjAwbXMnO1xuXG4gIHNldFRpbWVvdXQoKCk9PiB7XG4gICAgZWwuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFmdGVyKCkge1xuICAgIGNsZWFyVGltZW91dCh0SWQpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZWQnLCBhZnRlciwgZmFsc2UpO1xuXG4gIC8vIGluIGNhc2UgdHJhbnNpdGlvbmVkIGRvZXMgbm90IGZpcmVcbiAgLy8gVE9ETyBmaW5kIGEgd2F5IHRvIGF2b2lkIGl0XG4gIHRJZCA9IHNldFRpbWVvdXQoYWZ0ZXIsIDI1MCk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25IYXMoY29sbCwgZWwpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoY29sbFtpXSA9PT0gZWwpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZFBhcmVudEJ5U2VsZWN0b3IoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBtYXRjaGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIHZhciBjdXIgPSBlbC5wYXJlbnROb2RlO1xuICB3aGlsZSAoY3VyICYmICFjb2xsZWN0aW9uSGFzKG1hdGNoZXMsIGN1cikpIHtcbiAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gY3VyO1xufVxuXG5mdW5jdGlvbiBvbnRvdWNoKHRhcEhhbmRsZXIsIGhvbGRIYW5kbGVyLCByZXBlYXRIYW5kbGVyLCBzY3JvbGxYLCBzY3JvbGxZLCB0b3VjaEVuZEZlZWRiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihlbCwgaXNVcGRhdGUpIHtcbiAgICBpZiAoIWlzVXBkYXRlKSB7XG4gICAgICBCdXR0b25IYW5kbGVyKGVsLFxuICAgICAgICAgICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBtLnN0YXJ0Q29tcHV0YXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFwSGFuZGxlcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5lbmRDb21wdXRhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaG9sZEhhbmRsZXIgPyAoKSA9PiB1dGlscy5hdXRvcmVkcmF3KGhvbGRIYW5kbGVyKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFksXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoRW5kRmVlZGJhY2tcbiAgICAgICAgICAgICAgICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRyYW5zZm9ybVByb3AoKSB7XG4gIHJldHVybiAndHJhbnNmb3JtJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlID9cbiAgICAndHJhbnNmb3JtJyA6ICd3ZWJraXRUcmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUgP1xuICAgICd3ZWJraXRUcmFuc2Zvcm0nIDogJ21velRyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSA/XG4gICAgJ21velRyYW5zZm9ybScgOiAnb1RyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSA/XG4gICAgJ29UcmFuc2Zvcm0nIDogJ21zVHJhbnNmb3JtJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZpZXdwb3J0RGltKCkge1xuICBpZiAoY2FjaGVkVmlld3BvcnREaW0pIHJldHVybiBjYWNoZWRWaWV3cG9ydERpbTtcblxuICBsZXQgZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgbGV0IHZwZCA9IGNhY2hlZFZpZXdwb3J0RGltID0ge1xuICAgIHZ3OiBlLmNsaWVudFdpZHRoLFxuICAgIHZoOiBlLmNsaWVudEhlaWdodFxuICB9O1xuICByZXR1cm4gdnBkO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uSGFzKGNvbGwsIGVsKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb2xsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNvbGxbaV0gPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50QnlTZWxlY3RvcihlbCwgc2VsZWN0b3IpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICBsZXQgY3VyID0gZWw7XG4gIHdoaWxlIChjdXIgJiYgIWNvbGxlY3Rpb25IYXMobWF0Y2hlcywgY3VyKSkge1xuICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBjdXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMSShlKSB7XG4gIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICByZXR1cm4gdGFyZ2V0LnRhZ05hbWUgPT09ICdMSScgPyB0YXJnZXQgOiBmaW5kUGFyZW50QnlTZWxlY3Rvcih0YXJnZXQsICdMSScpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xhc3NTZXQoY2xhc3Nlcykge1xuICBjb25zdCBhcnIgPSBbXTtcbiAgZm9yIChsZXQgaSBpbiBjbGFzc2VzKSB7XG4gICAgaWYgKGNsYXNzZXNbaV0pIGFyci5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBhcnIuam9pbignICcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYWNoZWRWaWV3cG9ydERpbSgpIHtcbiAgY2FjaGVkVmlld3BvcnREaW0gPSBudWxsO1xufVxuXG4vLyBleHBvcnQgZGVmYXVsdCB7XG4vLyAgIHNsaWRpbmdQYWdlOiBhbmltYXRvcih2aWV3U2xpZGVJbiwgdmlld1NsaWRlT3V0KSxcbi8vICAgZmFkaW5nUGFnZTogYW5pbWF0b3Iodmlld0ZhZGVzSW4sIHZpZXdGYWRlc091dCksXG4vLyAgIHZpZXdwb3J0RGltLFxuLy8gICBjbGVhckNhY2hlZFZpZXdwb3J0RGltKCkge1xuLy8gICAgIGNhY2hlZFZpZXdwb3J0RGltID0gbnVsbDtcbi8vICAgfSxcblxuLy8gICB0cmFuc2Zvcm1Qcm9wOiBmdW5jdGlvbigpIHtcbi8vICAgICBpZiAoIWNhY2hlZFRyYW5zZm9ybVByb3ApIGNhY2hlZFRyYW5zZm9ybVByb3AgPSBjb21wdXRlVHJhbnNmb3JtUHJvcCgpO1xuLy8gICAgIHJldHVybiBjYWNoZWRUcmFuc2Zvcm1Qcm9wO1xuLy8gICB9LFxuXG4vLyAgIHNsaWRlc0luVXA6IGZ1bmN0aW9uKGVsLCBpc1VwZGF0ZSwgY29udGV4dCkge1xuLy8gICAgIGlmICghaXNVcGRhdGUpIHtcbi8vICAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKDEwMCUpJztcbi8vICAgICAgIC8vIGZvcmNlIHJlZmxvdyBiYWNrXG4vLyAgICAgICBjb250ZXh0LmxvbCA9IGVsLm9mZnNldEhlaWdodDtcbi8vICAgICAgIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDApJywgMjUwLCAnZWFzZS1vdXQnKVxuLy8gICAgICAgICAuY2F0Y2goY29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7XG4vLyAgICAgfVxuLy8gICB9LFxuLy8gICBzbGlkZXNPdXREb3duOiBmdW5jdGlvbihjYWxsYmFjaywgZWxJRCkge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbigpIHtcbi8vICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxJRCk7XG4vLyAgICAgICBtLnJlZHJhdy5zdHJhdGVneSgnbm9uZScpO1xuLy8gICAgICAgcmV0dXJuIFphbmltbyhlbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVZKDEwMCUpJywgMjUwLCAnZWFzZS1vdXQnKVxuLy8gICAgICAgICAudGhlbih1dGlscy5hdXRvcmVkcmF3LmJpbmQobnVsbCwgY2FsbGJhY2spKVxuLy8gICAgICAgICAuY2F0Y2goY2FsbGJhY2spO1xuLy8gICAgIH07XG4vLyAgIH0sXG5cbi8vICAgZmFkZXNPdXQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBzZWxlY3RvciwgdGltZSA9IDE1MCkge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4vLyAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuLy8gICAgICAgdmFyIGVsID0gc2VsZWN0b3IgPyBmaW5kUGFyZW50QnlTZWxlY3RvcihlLnRhcmdldCwgc2VsZWN0b3IpIDogZS50YXJnZXQ7XG4vLyAgICAgICBtLnJlZHJhdy5zdHJhdGVneSgnbm9uZScpO1xuLy8gICAgICAgcmV0dXJuIFphbmltbyhlbCwgJ29wYWNpdHknLCAwLCB0aW1lKVxuLy8gICAgICAgICAudGhlbigoKSA9PiB1dGlscy5hdXRvcmVkcmF3KGNhbGxiYWNrKSlcbi8vICAgICAgICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO1xuLy8gICAgIH07XG4vLyAgIH0sXG5cbi8vICAgb250b3VjaDogZnVuY3Rpb24odGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIHRvdWNoRW5kRmVlZGJhY2sgPSB0cnVlKSB7XG4vLyAgICAgcmV0dXJuIG9udG91Y2godGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHJlcGVhdEhhbmRsZXIsIGZhbHNlLCBmYWxzZSwgdG91Y2hFbmRGZWVkYmFjayk7XG4vLyAgIH0sXG4vLyAgIG9udG91Y2hYOiBmdW5jdGlvbih0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgdG91Y2hFbmRGZWVkYmFjayA9IHRydWUpIHtcbi8vICAgICByZXR1cm4gb250b3VjaCh0YXBIYW5kbGVyLCBob2xkSGFuZGxlciwgbnVsbCwgdHJ1ZSwgZmFsc2UsIHRvdWNoRW5kRmVlZGJhY2spO1xuLy8gICB9LFxuLy8gICBvbnRvdWNoWTogZnVuY3Rpb24odGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIHRvdWNoRW5kRmVlZGJhY2sgPSB0cnVlKSB7XG4vLyAgICAgcmV0dXJuIG9udG91Y2godGFwSGFuZGxlciwgaG9sZEhhbmRsZXIsIG51bGwsIGZhbHNlLCB0cnVlLCB0b3VjaEVuZEZlZWRiYWNrKTtcbi8vICAgfSxcbi8vICAgY2xhc3NTZXQ6IGZ1bmN0aW9uKGNsYXNzZXMpIHtcbi8vICAgICB2YXIgYXJyID0gW107XG4vLyAgICAgZm9yICh2YXIgaSBpbiBjbGFzc2VzKSB7XG4vLyAgICAgICBpZiAoY2xhc3Nlc1tpXSkgYXJyLnB1c2goaSk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBhcnIuam9pbignICcpO1xuLy8gICB9LFxuXG4vLyAgIGlzV2lkZVNjcmVlbjogZnVuY3Rpb24oKSB7XG4vLyAgICAgcmV0dXJuIHZpZXdwb3J0RGltKCkudncgPj0gNjAwO1xuLy8gICB9LFxuLy8gICBpc0lwYWRMaWtlOiBmdW5jdGlvbigpIHtcbi8vICAgICBjb25zdCB7IHZoLCB2dyB9ID0gdmlld3BvcnREaW0oKTtcbi8vICAgICByZXR1cm4gdmggPj0gNzAwICYmIHZ3IDw9IDEwNTA7XG4vLyAgIH0sXG4vLyAgIGlzUG9ydHJhaXQ6IGZ1bmN0aW9uKCkge1xuLy8gICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYSgnKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknKS5tYXRjaGVzO1xuLy8gICB9LFxuLy8gICBpc0xhbmRzY2FwZTogZnVuY3Rpb24oKSB7XG4vLyAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKCcob3JpZW50YXRpb246IGxhbmRzY2FwZSknKS5tYXRjaGVzO1xuLy8gICB9LFxuLy8gICBwcm9ncmVzczogZnVuY3Rpb24gKHApIHtcbi8vICAgICBpZiAocCA9PT0gMCkgcmV0dXJuIG51bGw7XG4vLyAgICAgcmV0dXJuIG0oJ3NwYW4nLCB7XG4vLyAgICAgICBjbGFzc05hbWU6ICdwcm9ncmVzcyAnICsgKHAgPiAwID8gJ3Bvc2l0aXZlJyA6ICduZWdhdGl2ZScpLFxuLy8gICAgICAgJ2RhdGEtaWNvbic6IHAgPiAwID8gJ04nIDogJ00nXG4vLyAgICAgfSwgTWF0aC5hYnMocCkpO1xuLy8gICB9XG4vLyB9O1xuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgaGVscGVyIGZyb20gJy4uL2hlbHBlcic7XG5pbXBvcnQgeyByZW5kZXJRdWlja1NldHVwIH0gZnJvbSAnLi4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IG5ld0dhbWVGb3JtIGZyb20gJy4uL25ld0dhbWVGb3JtJztcbmltcG9ydCB7IGhlYWRlciBhcyBoZWFkZXJXaWRnZXQgfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gYm9keShjdHJsKSB7XG4gIGNvbnN0IG5iUGxheWVycyA9IGkxOG4oJ25iQ29ubmVjdGVkUGxheWVycycsIGN0cmwubmJDb25uZWN0ZWRQbGF5ZXJzKCkgfHwgJz8nKTtcbiAgY29uc3QgbmJHYW1lcyA9IGkxOG4oJ25iR2FtZXNJblBsYXknLCBjdHJsLm5iR2FtZXNJblBsYXkoKSB8fCAnPycpO1xuXG4gIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm5hdGl2ZV9zY3JvbGxlciBwYWdlXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaG9tZVwiPlxuICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cInN0YXRzXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm51bVBsYXllcnNcIj57bmJQbGF5ZXJzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJudW1HYW1lc1wiPntuYkdhbWVzfTwvZGl2PlxuICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgIHsgcmVuZGVyUXVpY2tHYW1lKCkgfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICApO1xuXG4gIC8vIGNvbnN0IGhlYWRlciA9IGhlYWRlcldpZGdldC5iaW5kKG51bGwsICdveXVua2V5Zi5uZXQnKTtcblxuICAvLyByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCBib2R5KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUXVpY2tHYW1lKCkge1xuICByZXR1cm4gaCgnZGl2LmhvbWVDcmVhdGUnLCBbXG4gICAgaCgnaDIuaG9tZVRpdGxlJywgJ0hlbWVuIG95bmEnKSxcbiAgICByZW5kZXJRdWlja1NldHVwKCgpID0+IG5ld0dhbWVGb3JtLm9wZW5SZWFsdGltZSgnY3VzdG9tJykpXG4gIF0pO1xufVxuIiwiaW1wb3J0IHN0cmVhbSBmcm9tICdtaXRocmlsL3N0cmVhbSc7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgeyBoYXNOZXR3b3JrLCBub29wIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHsgaXNGb3JlZ3JvdW5kLCBzZXRGb3JlZ3JvdW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXBwTW9kZSc7XG5pbXBvcnQgeyBkcm9wU2hhZG93SGVhZGVyIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgeyBib2R5IH0gZnJvbSAnLi9ob21lVmlldyc7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KCkge1xuICAgIGNvbnN0IG5iQ29ubmVjdGVkUGxheWVycyA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IG5iR2FtZXNJblBsYXkgPSBzdHJlYW0oKTtcbiAgICBcbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgaWYgKGlzRm9yZWdyb3VuZCgpKSB7XG4gICAgICAgIHNvY2tldC5jcmVhdGVMb2JieSgnaG9tZUxvYmJ5Jywgbm9vcCwge1xuICAgICAgICAgIG46IChfLCBkKSA9PiB7XG4gICAgICAgICAgICBuYkNvbm5lY3RlZFBsYXllcnMoZC5kKTtcbiAgICAgICAgICAgIG5iR2FtZXNJblBsYXkoZC5yKTtcbiAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXN1bWUoKSB7XG4gICAgICBzZXRGb3JlZ3JvdW5kKCk7XG4gICAgICBpbml0KCk7XG4gICAgfVxuXG4gICAgaWYgKGhhc05ldHdvcmsoKSkge1xuICAgICAgaW5pdCgpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIGluaXQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc3VtZScsIG9uUmVzdW1lKTtcblxuICAgIHRoaXMuY3RybCA9IHtcbiAgICAgIG5iQ29ubmVjdGVkUGxheWVycyxcbiAgICAgIG5iR2FtZXNJblBsYXksXG4gICAgICBpbml0LFxuICAgICAgb25SZXN1bWVcbiAgICB9O1xuICB9LFxuICBvbnJlbW92ZSgpIHtcbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuY3RybC5pbml0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXN1bWUnLCB0aGlzLmN0cmwub25SZXN1bWUpO1xuICB9LFxuICBcbiAgdmlldygpIHtcbiAgICBjb25zdCBoZWFkZXIgPSBkcm9wU2hhZG93SGVhZGVyKCdveXVua2V5Zi5uZXQnKTtcblxuICAgIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIsIGJvZHkodGhpcy5jdHJsKSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCAqIGFzIG1lbnUgZnJvbSAnLi9tZW51JztcbmltcG9ydCBNZW51VmlldyBmcm9tICcuL21lbnUvbWVudVZpZXcnO1xuaW1wb3J0IE1haW5Cb2FyZCBmcm9tICcuL3NoYXJlZC9sYXlvdXQvTWFpbkJvYXJkJztcbmltcG9ydCBnYW1lc01lbnUgZnJvbSAnLi9nYW1lc01lbnUnO1xuaW1wb3J0IG5ld0dhbWVGb3JtIGZyb20gJy4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IGxvZ2luTW9kYWwgZnJvbSAnLi9sb2dpbk1vZGFsJztcbmltcG9ydCBzaWdudXBNb2RhbCBmcm9tICcuL3NpZ251cE1vZGFsJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uL3NldHRpbmdzJztcblxudmFyIGJhY2tncm91bmQ7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICBib2FyZDogZnVuY3Rpb24oaGVhZGVyLCBjb250ZW50LCBvdmVybGF5KSB7XG4gICAgYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG5cbiAgICByZXR1cm4gaCgnZGl2LnZpZXctY29udGFpbmVyJywgeyBjbGFzc05hbWU6IGJnQ2xhc3MoYmFja2dyb3VuZCkgfSwgW1xuICAgICAgaChNYWluQm9hcmQsIHsgaGVhZGVyIH0sIGNvbnRlbnQpLFxuICAgICAgLy8gaChNZW51VmlldyksXG4gICAgICBvdmVybGF5XG4gICAgXSk7XG4gIH0sXG5cblxuICBmcmVlOiBmdW5jdGlvbihoZWFkZXIsIGNvbnRlbnQsIGZvb3Rlciwgb3ZlcmxheSkge1xuICAgIGJhY2tncm91bmQgPSBiYWNrZ3JvdW5kIHx8IHNldHRpbmdzLmdlbmVyYWwudGhlbWUuYmFja2dyb3VuZCgpO1xuICAgIFxuICAgIHJldHVybiAoXG4gICAgICBoKCdkaXYudmlldy1jb250YWluZXInLCB7IGNsYXNzTmFtZTogYmdDbGFzcyhiYWNrZ3JvdW5kKSB9LCBbXG4gICAgICAgIGgoJ21haW4jcGFnZScsIHsgb25jcmVhdGU6IGhhbmRsZU1lbnVPcGVuIH0sIFtcbiAgICAgICAgICBoKCdoZWFkZXIubWFpbl9oZWFkZXInLCBoZWFkZXIpLFxuICAgICAgICAgIGgoJ2RpdiNmcmVlX2NvbnRlbnQuY29udGVudC5uYXRpdmVfc2Nyb2xsZXInLCBjb250ZW50KSxcbiAgICAgICAgICBmb290ZXIgPyBoKCdmb290ZXIubWFpbl9mb290ZXInLCBmb290ZXIpIDogbnVsbCxcbiAgICAgICAgICBoKCdkaXYjbWVudS1jbG9zZS1vdmVybGF5Lm1lbnUtYmFja2Ryb3AnLCB7IG9uY3JlYXRlOiBtZW51LmJhY2tkcm9wQ2xvc2VIYW5kbGVyIH0pXG4gICAgICAgIF0pLFxuICAgICAgICBoKE1lbnVWaWV3KSxcbiAgICAgICAgbG9naW5Nb2RhbC52aWV3KCksXG4gICAgICAgIHNpZ251cE1vZGFsLnZpZXcoKSxcbiAgICAgICAgbmV3R2FtZUZvcm0udmlldygpLFxuICAgICAgICBvdmVybGF5XG4gICAgICBdKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTWVudU9wZW4oKSB7XG59XG5cbmZ1bmN0aW9uIGJnQ2xhc3MoYmdUaGVtZSkge1xuICByZXR1cm4gYmdUaGVtZSA9PT0gJ2RhcmsnIHx8IGJnVGhlbWUgPT09ICdsaWdodCcgPyBiZ1RoZW1lIDogJ3RyYW5zcCAnICsgYmdUaGVtZTtcbn1cbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuLi94aHInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN0YXJ0U2Vla2luZyhjb25mKSB7XG4gICAgZG9TdGFydFNlZWtpbmcoY29uZik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRvU3RhcnRTZWVraW5nKGNvbmYpIHtcbiAgLy8gcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaCh1c2VyQ2FuY2VsU2Vla2luZyk7XG5cbiAgc2VuZEhvb2soY29uZik7XG59XG5cbmZ1bmN0aW9uIHNlbmRIb29rKHNldHVwKSB7XG4gIHhoci5zZWVrR2FtZShzZXR1cClcbiAgICAudGhlbihkYXRhID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgcm91dGVyLnNldCgnL21hc2EvJyArIGRhdGEuaWQpO1xuICAgIH0pLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbn1cblxuLy8gaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuLy8gaW1wb3J0ICogYXMgeGhyIGZyb20gJy4uL3hocic7XG4vLyBpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuLy8gbGV0IG5iUGxheWVycyA9IDA7XG4vLyBsZXQgbmJHYW1lcyA9IDA7XG5cbi8vIGNvbnN0IGxvYmJ5ID0ge307XG4vLyBsb2JieS5pc09wZW4gPSBmYWxzZTtcblxuLy8gbG9iYnkuc3RhcnRTZWVraW5nID0gZnVuY3Rpb24oKSB7XG4vLyAgIHhoci5uZXdHYW1lKCkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4vLyAgICAgLy8gYW5hbHl0aWNzXG4vLyAgICAgbS5yb3V0ZSgnL21hc2EvJyArIGRhdGEuaWQpO1xuLy8gICB9LCBmdW5jdGlvbihlcnJvcikge1xuLy8gICAgIHV0aWxzLmhhbmRsZVhockVycm9yKGVycm9yKTtcbi8vICAgICB0aHJvdyBlcnJvcjtcbi8vICAgfSk7XG4vLyB9O1xuXG5cbi8vIGV4cG9ydCBkZWZhdWx0IGxvYmJ5O1xuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi9zZXNzaW9uJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBpMThuIGZyb20gJy4uL2kxOG4nO1xuaW1wb3J0IHNpZ25hbHMgZnJvbSAnLi4vc2lnbmFscyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgaGFuZGxlWGhyRXJyb3IgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi9iYWNrYnV0dG9uJztcbmltcG9ydCBzaWdudXBNb2RhbCBmcm9tICcuL3NpZ251cE1vZGFsJztcbmltcG9ydCB7IGNsb3NlSWNvbiB9IGZyb20gJy4vc2hhcmVkL2ljb25zJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vcm91dGVyJztcblxubGV0IGlzT3BlbiA9IGZhbHNlO1xubGV0IGZvcm1FcnJvciA9IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb3BlbixcbiAgY2xvc2UsXG4gIHZpZXcoKSB7XG4gICAgaWYgKCFpc09wZW4pIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIGgoJ2Rpdi5tb2RhbCNsb2dpbk1vZGFsJywgeyBvbmNyZWF0ZTogaGVscGVyLnNsaWRlc0luVXAgfSwgW1xuICAgICAgaCgnaGVhZGVyJywgW1xuICAgICAgICBoKCdidXR0b24ubW9kYWxfY2xvc2UnLCB7XG4gICAgICAgICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcChoZWxwZXIuc2xpZGVzT3V0RG93bihjbG9zZSwgJ2xvZ2luTW9kYWwnKSlcbiAgICAgICAgfSwgY2xvc2VJY29uKSxcbiAgICAgICAgaCgnaDInLCBpMThuKCdzaWduSW4nKSlcbiAgICAgIF0pLFxuICAgICAgaCgnZGl2Lm1vZGFsX2NvbnRlbnQnLCBbXG4gICAgICAgIGgoJ2Zvcm0ubG9naW4nLCB7XG4gICAgICAgICAgb25zdWJtaXQ6IChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzdWJtaXQoZS50YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgIGZvcm1FcnJvciA/IGgoJ2Rpdi5mb3JtLWVycm9yJywgZm9ybUVycm9yKTogbnVsbCxcbiAgICAgICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgICAgICBoKCdpbnB1dCN1c2VybmFtZScsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6IGZvcm1FcnJvciA/ICdmb3JtLWVycm9yJzonJyxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4gICAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4gICAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiAnb2ZmJyxcbiAgICAgICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgICAgICAgICBzcGVsbGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgaCgnZGl2LmZpZWxkJywgW1xuICAgICAgICAgICAgaCgnaW5wdXQjcGFzc3dvcmQnLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdwYXNzd29yZCcsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogZm9ybUVycm9yPyAnZm9ybS1lcnJvcic6JycsXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdwYXNzd29yZCcpLFxuICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBoKCdkaXYuc3VibWl0JywgW1xuICAgICAgICAgICAgaCgnYnV0dG9uLnN1Ym1pdEJ1dHRvbltkYXRhLWljb249Rl0nLCBpMThuKCdzaWduSW4nKSlcbiAgICAgICAgICBdKVxuICAgICAgICBdKSxcbiAgICAgICAgaCgnZGl2LnNpZ251cCcsIFtcbiAgICAgICAgICBpMThuKCduZXdUb095dW5rZXlmJykgKyAnICcsXG4gICAgICAgICAgaCgnYnInKSxcbiAgICAgICAgICBoKCdhJywge1xuICAgICAgICAgICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcChzaWdudXBNb2RhbC5vcGVuKVxuICAgICAgICAgIH0sIFtpMThuKCdzaWduVXAnKV0pXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvcGVuKCkge1xuICByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wdXNoKGhlbHBlci5zbGlkZXNPdXREb3duKGNsb3NlLCAnbG9naW5Nb2RhbCcpKTtcbiAgaXNPcGVuID0gdHJ1ZTtcbiAgZm9ybUVycm9yID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xvc2UoZnJvbUJCKSB7XG4gIHdpbmRvdy5LZXlib2FyZC5oaWRlKCk7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBpc09wZW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3VibWl0KGZvcm0pIHtcbiAgY29uc3QgdXNlcm5hbWUgPSBmb3JtWyd1c2VybmFtZSddLnZhbHVlO1xuICBjb25zdCBwYXNzd29yZCA9IGZvcm1bJ3Bhc3N3b3JkJ10udmFsdWU7XG4gIGlmICghdXNlcm5hbWUgfHwgIXBhc3N3b3JkKSByZXR1cm47XG5cbiAgcmVkcmF3KCk7XG4gIHdpbmRvdy5LZXlib2FyZC5oaWRlKCk7XG4gIHNlc3Npb24ubG9naW4odXNlcm5hbWUsIHBhc3N3b3JkKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGNsb3NlKCk7XG4gICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ2xvZ2luU3VjY2Vzc2Z1bCcpLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4gICAgICBzaWduYWxzLmFmdGVyTG9naW4uZGlzcGF0Y2goKTtcbiAgICAgIHJlZHJhdygpO1xuICAgICAgc29ja2V0LnJlY29ubmVjdEN1cnJlbnQoKTtcbiAgICAgIHNlc3Npb24ucmVmcmVzaCgpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIuc3RhdHVzICE9PSA0MDAgJiYgZXJyLnN0YXR1cyAhPT0gNDAxKSBoYW5kbGVYaHJFcnJvcihlcnIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChlcnIuYm9keS5nbG9iYWwpIHtcbiAgICAgICAgICBmb3JtRXJyb3IgPSBlcnIuYm9keS5nbG9iYWxbMF07XG4gICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgXG59XG5cblxuLy8gT0xEXG5cbmNvbnN0IGxvZ2luTW9kYWwgPSB7fTtcblxuZnVuY3Rpb24gc3VibWl0T0xEKGZvcm0pIHtcbiAgY29uc3QgbG9naW4gPSBmb3JtWzBdLnZhbHVlLnRyaW0oKTtcbiAgY29uc3QgcGFzcyA9IGZvcm1bMV0udmFsdWU7XG4gIGlmICghbG9naW4gfHwgIXBhc3MpIHJldHVybiBmYWxzZTtcbiAgd2luZG93LmNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5jbG9zZSgpO1xuICByZXR1cm4gc2Vzc2lvbi5sb2dpbihsb2dpbiwgcGFzcykudGhlbihmdW5jdGlvbigpIHtcbiAgICBsb2dpbk1vZGFsLmNsb3NlKCk7XG4gICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhpMThuKCdsb2dpblN1Y2Nlc3NmdWwnKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuICAgIC8vIHB1c2gucmVnaXN0ZXIoKTtcbiAgICBzZXNzaW9uLnJlZnJlc2goKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVsb2NlL2xpY2hvYmlsZS9ibG9iL21hc3Rlci9wcm9qZWN0L3NyYy9qcy91aS9sb2dpbk1vZGFsLmpzI0wyOFxuICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3Iubm90aWZpY2F0aW9uLmFsZXJ0KCdveXVua2V5ZkF1dGhlbnRpY2F0aW9uQ2Fubm90V29ya1dpdGhvdXRDb29raWVzJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KVxuICAgIC5jYXRjaCh1dGlscy5oYW5kbGVYaHJFcnJvcik7XG59XG5cbmxvZ2luTW9kYWwub3BlbiA9IGZ1bmN0aW9uKCkge1xuICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24obG9naW5Nb2RhbC5jbG9zZSwgJ2xvZ2luTW9kYWwnKSk7XG4gIGlzT3BlbiA9IHRydWU7XG59O1xuXG5sb2dpbk1vZGFsLmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4gIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuY2xvc2UoKTtcbiAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgaXNPcGVuID0gZmFsc2U7XG59O1xuXG5sb2dpbk1vZGFsLnZpZXcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFpc09wZW4pIHJldHVybiBudWxsO1xuXG4gIHJldHVybiBtKCdkaXYubW9kYWwjbG9naW5Nb2RhbCcsIHsgY29uZmlnOiBoZWxwZXIuc2xpZGVzSW5VcCB9LCBbXG4gICAgbSgnaGVhZGVyJywgW1xuICAgICAgbSgnYnV0dG9uLm1vZGFsX2Nsb3NlW2RhdGEtaWNvbj1MXScsIHtcbiAgICAgICAgY29uZmlnOiBoZWxwZXIub250b3VjaChoZWxwZXIuc2xpZGVzT3V0RG93bihsb2dpbk1vZGFsLmNsb3NlLCAnbG9naW5Nb2RhbCcpKVxuICAgICAgfSksXG4gICAgICBtKCdoMicsIGkxOG4oJ3NpZ25JbicpKVxuICAgIF0pLFxuICAgIG0oJ2Rpdi5tb2RhbF9jb250ZW50JywgW1xuICAgICAgbSgnZm9ybS5sb2dpbicsIHtcbiAgICAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHN1Ym1pdChlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtcbiAgICAgICAgbSgnaW5wdXQjcHNldWRvW3R5cGU9dGV4dF0nLCB7XG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4gICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsXG4gICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgICAgIHNwZWxsY2hlY2s6ICdmYWxzZScsXG4gICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIG0oJ2lucHV0I3Bhc3N3b3JkW3R5cGU9cGFzc3dvcmRdJywge1xuICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdwYXNzd29yZCcpLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICBtKCdidXR0b24uZmF0JywgaTE4bignc2lnbkluJykpXG4gICAgICBdKSxcbiAgICAgIG0oJ2Rpdi5zaWdudXAnLCBbXG4gICAgICAgIG0oJ2EnLCB7XG4gICAgICAgICAgY29uZmlnOiBoZWxwZXIub250b3VjaChzaWdudXBNb2RhbC5vcGVuKVxuICAgICAgICB9LCBbaTE4bignbmV3VG9PeXVua2V5ZicpLCAnICcsIGkxOG4oJ3NpZ25VcCcpXSlcbiAgICAgIF0pXG4gICAgXSlcbiAgXSk7XG59O1xuXG4vLyBleHBvcnQgZGVmYXVsdCBsb2dpbk1vZGFsO1xuIiwiaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IHsgaGFuZGxlWGhyRXJyb3IgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi9tYXNhWGhyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWFzYXNMaXN0Q3RybChkZWZhdWx0VGFiKSB7XG4gIHRoaXMuY3VycmVudFRhYiA9IGRlZmF1bHRUYWIgfHwgMDtcblxuXG4gIHRoaXMucmVmcmVzaCA9ICgpID0+IHtcbiAgICB4aHIuY3VycmVudE1hc2FzKClcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICB0aGlzLm1hc2FzID0gZGF0YTtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgICB9KS5jYXRjaChoYW5kbGVYaHJFcnJvcik7XG4gIH07XG5cbiAgdGhpcy5yZWZyZXNoKCk7XG5cbiAgdGhpcy5vblRhYkNoYW5nZSA9ICh0YWJJbmRleCkgPT4ge1xuICAgIGNvbnN0IGxvYyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gucmVwbGFjZSgvXFw/dGFiXFw9XFx3KyQvLCAnJyk7XG5cbiAgICB0cnkge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgbG9jICsgJz90YWI9JyArIHRhYkluZGV4KTtcbiAgICB9IGNhdGNoIChlKSB7IGNvbnNvbGUuZXJyb3IoZSk7IH1cbiAgICB0aGlzLmN1cnJlbnRUYWIgPSB0YWJJbmRleDtcbiAgICByZWRyYXcoKTtcbiAgfTtcblxufVxuIiwiaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi4vbWFzYVhocic7XG5pbXBvcnQgZmFxIGZyb20gJy4uL2ZhcSc7XG5pbXBvcnQgc29ja2V0SGFuZGxlciBmcm9tICcuL3NvY2tldEhhbmRsZXInO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi8uLi9yb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXNhQ3RybChpZCkge1xuXG4gIHRoaXMuaWQgPSBpZDtcblxuICB0aGlzLmZhcUN0cmwgPSBmYXEuY29udHJvbGxlcih0aGlzKTtcbiAgXG4gIHhoci5tYXNhKGlkKS50aGVuKChkYXRhKSA9PiB7XG4gICAgdGhpcy5tYXNhID0gZGF0YTtcbiAgICB0aGlzLnNlYXRJZCA9IGRhdGEuc2VhdElkO1xuXG4gICAgdGhpcy5zdGFydHNBdCA9IHdpbmRvdy5tb21lbnQoZGF0YS5zdGFydHNBdCkuY2FsZW5kYXIoKTtcbiAgICBsb2FkQ3VycmVudFBhZ2UodGhpcy5tYXNhLnN0YW5kaW5nKTtcbiAgICB0aGlzLmhhc0pvaW5lZCA9ICEhKGRhdGEubWUgJiYgIWRhdGEubWUud2l0aGRyYXcpO1xuXG4gICAgc29ja2V0LmNyZWF0ZU1hc2EoXG4gICAgICB0aGlzLmlkLFxuICAgICAgdGhpcy5tYXNhLnNvY2tldFZlcnNpb24sXG4gICAgICBzb2NrZXRIYW5kbGVyKHRoaXMpKTtcblxuICAgIHJlZHJhdygpO1xuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKGVyci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgdGhpcy5ub3RGb3VuZCA9IHRydWU7XG4gICAgICByZWRyYXcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbHMuaGFuZGxlWGhyRXJyb3IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuaW52aXRlID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgIHhoci5pbnZpdGUodGhpcy5tYXNhLmlkKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0pLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbiAgfSwgMTAwMCk7XG5cbiAgdGhpcy5qb2luID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgIHhoci5qb2luKHRoaXMubWFzYS5pZClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5oYXNKb2luZWQgPSB0cnVlO1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0pLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbiAgfSwgMTAwMCk7XG5cbiAgdGhpcy53aXRoZHJhdyA9IHRocm90dGxlKCgpID0+IHtcbiAgICB4aHIud2l0aGRyYXcodGhpcy5tYXNhLmlkKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhc0pvaW5lZCA9IGZhbHNlO1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0pLmNhdGNoKHV0aWxzLmhhbmRsZVhockVycm9yKTtcbiAgfSwgMTAwMCk7XG5cbiAgdGhpcy5yZWxvYWQgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgeGhyLnJlbG9hZCh0aGlzLmlkKVxuICAgICAgLnRoZW4ob25SZWxvYWQpXG4gICAgICAuY2F0Y2gob25YaHJFcnJvcik7XG4gIH0sIDIwMDApO1xuXG5cbiAgdGhpcy51bmxvYWQgPSAoKSA9PiB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgdGhpcy5yZWxvYWQpO1xuICB9O1xuXG4gIGNvbnN0IG9uUmVsb2FkID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCBvbGREYXRhID0gdGhpcy5tYXNhO1xuICAgIHRoaXMubWFzYSA9IGRhdGE7XG4gICAgdGhpcy5zZWF0SWQgPSBkYXRhLnNlYXRJZDtcbiAgICBsb2FkQ3VycmVudFBhZ2UoZGF0YS5zdGFuZGluZyk7XG4gICAgdGhpcy5oYXNKb2luZWQgPSAhIShkYXRhLm1lICYmICFkYXRhLm1lLndpdGhkcmF3KTtcbiAgICByZWRpcmVjdFRvTXlHYW1lKCk7XG4gICAgcmVkcmF3KCk7XG4gIH07XG5cbiAgY29uc3QgcmVkaXJlY3RUb015R2FtZSA9ICgpID0+IHtcbiAgICB2YXIgZ2FtZUlkID0gbXlDdXJyZW50R2FtZUlkKHRoaXMpO1xuICAgIGlmIChnYW1lSWQpXG4gICAgICByb3V0ZXIuc2V0KCcvbWFzYS8nICsgdGhpcy5tYXNhLmlkICsgJy9nYW1lLycgKyBnYW1lSWQsIHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IG15Q3VycmVudEdhbWVJZCA9IChjdHJsKSA9PiB7XG4gICAgdmFyIGlkcyA9IHtcbiAgICAgIGNyZWF0ZWQ6IDEwLFxuICAgICAgc3RhcnRlZDogMjAsXG4gICAgICBhYm9ydGVkOiAyNVxuICAgIH07XG5cbiAgICB2YXIgc2VhdElkID0gY3RybC5zZWF0SWQ7XG4gICAgaWYgKCFzZWF0SWQpIHJldHVybiBudWxsO1xuICAgIHZhciBwYWlyaW5nID0gY3RybC5tYXNhLnBhaXJpbmdzLmZpbHRlcihwID0+IHtcbiAgICAgIHJldHVybiBwLnMgPCBpZHMuYWJvcnRlZCAmJiAoXG4gICAgICAgIHAudS5maWx0ZXIoKGlkKSA9PiBpZC50b0xvd2VyQ2FzZSgpID09PSBzZWF0SWQudG9Mb3dlckNhc2UoKSlbMF1cbiAgICAgICk7XG4gICAgfSlbMF07XG4gICAgcmV0dXJuIHBhaXJpbmcgPyBwYWlyaW5nLmlkIDogbnVsbDtcbiAgfTtcblxuICBjb25zdCBvblhockVycm9yID0gKGVycikgPT4ge1xuICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHRoaXMubm90Rm91bmQgPSB0cnVlO1xuICAgIH1cbiAgICByZWRyYXcoKTtcbiAgfTtcblxuICBjb25zdCBsb2FkQ3VycmVudFBhZ2UgPSAoZGF0YSkgPT4ge1xuICAgIHRoaXMuY3VycmVudFBhZ2VSZXN1bHRzID0gZGF0YS5wbGF5ZXJzO1xuICB9O1xufVxuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi8uLi9pMThuJztcbmltcG9ydCB7IGRyb3BTaGFkb3dIZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uLCBjb25uZWN0aW5nRHJvcFNoYWRvd0hlYWRlciB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uLy4uL2hlbHBlcic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uLy4uL2xheW91dCc7XG5pbXBvcnQgeyBtYXNhQm9keSwgcmVuZGVyRkFRT3ZlcmxheSwgcmVuZGVyRm9vdGVyLCB0aW1lSW5mbyB9IGZyb20gJy4vbWFzYVZpZXcnO1xuXG5pbXBvcnQgTWFzYUN0cmwgZnJvbSAnLi9NYXNhQ3RybCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KHthdHRyc30pIHtcbiAgICB0aGlzLmN0cmwgPSBuZXcgTWFzYUN0cmwoYXR0cnMuaWQpO1xuICB9LFxuICBvbmNyZWF0ZTogaGVscGVyLnZpZXdTbGlkZUluLFxuICBvbnJlbW92ZSgpIHtcbiAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgIHRoaXMuY3RybC51bmxvYWQoKTtcbiAgfSxcbiAgdmlldygpIHtcbiAgICBpZiAodGhpcy5jdHJsLm5vdEZvdW5kKSB7XG4gICAgICByZXR1cm4gbGF5b3V0LmZyZWUoXG4gICAgICAgIGhlYWRlcldpZGdldChudWxsLCBiYWNrQnV0dG9uKGkxOG4oJ21hc2FOb3RGb3VuZCcpKSksXG4gICAgICAgIGgoJ2Rpdi5tYXNhTm90Rm91bmQnLCB7IGtleTogJ21hc2Etbm90LWZvdW5kJyB9LCBbXG4gICAgICAgICAgaCgncCcsIGkxOG4oJ21hc2FEb2VzTm90RXhpc3QnKSksXG4gICAgICAgICAgaCgncCcsIGkxOG4oJ21hc2FNYXlIYXZlQmVlbkNhbmNlbGVkJykpXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG1hc2EgPSB0aGlzLmN0cmwubWFzYTtcbiAgICBsZXQgaGVhZGVyO1xuXG4gICAgaWYgKG1hc2EpIHtcbiAgICAgIGhlYWRlciA9IGhlYWRlcldpZGdldChudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tCdXR0b24oaCgnZGl2Lm1haW5faGVhZGVyX3RpdGxlLndpdGhTdWInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKCdoMScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnc3Bhbi5mYS5mYS10cm9waHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdHJsLm1hc2EuZnVsbE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCgnaDIuaGVhZGVyLXN1YlRpdGxlLm1hc2Etc3ViVGl0bGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbWFzYS5pc0ZpbmlzaGVkICYmICFtYXNhLmlzU3RhcnRlZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVJbmZvKCdjcmVhdGVkJywgbWFzYS5wbGF5ZXJzVG9TdGFydCwgJ095dW5jdSBiZWtsZW5peW9yJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lSW5mbygnc3RhcnRlZCcsIG1hc2Eucm91bmRzVG9GaW5pc2gsICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlciA9IGNvbm5lY3RpbmdEcm9wU2hhZG93SGVhZGVyKCk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IG1hc2FCb2R5KHRoaXMuY3RybCk7XG4gICAgY29uc3QgZm9vdGVyID0gcmVuZGVyRm9vdGVyKHRoaXMuY3RybCk7XG4gICAgY29uc3QgZmFxT3ZlcmxheSA9IHJlbmRlckZBUU92ZXJsYXkodGhpcy5jdHJsKTtcbiAgICBjb25zdCBvdmVybGF5ID0gW1xuICAgICAgZmFxT3ZlcmxheVxuICAgIF07XG5cbiAgICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCBib2R5LCBmb290ZXIsIG92ZXJsYXkpO1xuICB9XG59O1xuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uLy4uL3JvdXRlcic7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi8uLi9zZXNzaW9uJztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uLy4uL2kxOG4nO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4uLy4uL2hlbHBlcic7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vLi4vLi4vc2V0dGluZ3MnO1xuaW1wb3J0ICogYXMgdmFyaWFudEFwaSBmcm9tICcuLi8uLi8uLi9veXVua2V5Zi92YXJpYW50JztcblxuaW1wb3J0IGZhcSBmcm9tICcuLi9mYXEnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRkFRT3ZlcmxheShjdHJsKSB7XG4gIHJldHVybiBbXG4gICAgZmFxLnZpZXcoY3RybC5mYXFDdHJsKVxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFzYUJvZHkoY3RybCkge1xuICBjb25zdCBkYXRhID0gY3RybC5tYXNhO1xuICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiBoKCdkaXYubWFzYUNvbnRhaW5lci5uYXRpdmVfc2Nyb2xsZXIucGFnZScsIFtcbiAgICBtYXNhSGVhZGVyKGRhdGEsIGN0cmwpLFxuICAgIGRhdGEucG9kaXVtID8gbWFzYVBvZGl1bShkYXRhLnBvZGl1bSk6IG51bGwsXG4gICAgbWFzYUxlYWRlcmJvYXJkKGN0cmwpXG4gIF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRm9vdGVyKGN0cmwpIHtcbiAgY29uc3QgbSA9IGN0cmwubWFzYTtcbiAgaWYgKCFtKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbVVybCA9ICdodHRwczovL295dW5rZXlmLm5ldC9tYXNhLycgKyBtLmlkO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJhY3Rpb25zX2JhclwiPlxuICAgICAgPGJ1dHRvbiBrZXk9XCJmYXFcIiBjbGFzc05hbWU9XCJhY3Rpb25fYmFyX2J1dHRvblwiIG9uY3JlYXRlPXtoZWxwZXIub250YXAoY3RybC5mYXFDdHJsLm9wZW4pfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcXVlc3Rpb24tY2lyY2xlXCIvPlxuICAgICAgICAgIFNTU1xuICAgICAgPC9idXR0b24+XG4gICAgICB7Y3RybC5oYXNKb2luZWQgPyB3aXRoZHJhd0J1dHRvbihjdHJsLCBtKSA6IGpvaW5CdXR0b24oY3RybCwgbSkgfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUluZm8oa2V5LCByb3VuZHMsIHByZWNlZWRpbmdUZXh0KSB7XG4gIGlmIChyb3VuZHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIFtcbiAgICBwcmVjZWVkaW5nVGV4dCA/IChwcmVjZWVkaW5nVGV4dCArICcgJykgOiBudWxsLFxuICAgIC8vIGgoXG4gIF07XG59XG5cbmZ1bmN0aW9uIG1hc2FIZWFkZXIoZGF0YSwgY3RybCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYga2V5PVwiaGVhZGVyXCIgY2xhc3NOYW1lPVwibWFzYUhlYWRlclwiPlxuICAgICAge21hc2FUaW1lSW5mbyhkYXRhKX1cbiAgICB7bWFzYUNyZWF0b3JJbmZvKGRhdGEsIGN0cmwuc3RhcnRzQXQpfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiBtYXNhVGltZUluZm8oZGF0YSkge1xuICBjb25zdCB2YXJpYW50ID0gdmFyaWFudEFwaS5nZXRWYXJpYW50KGRhdGEudmFyaWFudCkubmFtZTtcbiAgY29uc3QgY29udHJvbCA9IGRhdGEuc2NvcmVzID8gZGF0YS5zY29yZXMgKyAnICcgKyBpMThuKCdzY29yZXMnKSA6IGRhdGEucm91bmRzICsgJyAnICsgaTE4bigncm91bmRzJyk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhVGltZUluZm9cIj5cbiAgICAgIDxzdHJvbmcgY2xhc3NOYW1lPVwibWFzYUluZm8gd2l0aEljb25cIj5cbiAgICAgICAgeyB2YXJpYW50ICsgJyDigKIgJyArIGNvbnRyb2wgfVxuICAgICAgPC9zdHJvbmc+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hc2FDcmVhdG9ySW5mbyhkYXRhLCBzdGFydHNBdCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWFzYUNyZWF0b3JJbmZvXCI+XG4gICAgICB7aTE4bignYnknLCBkYXRhLmNyZWF0ZWRCeSl9XG4gICAgICAmbmJzcDvigKImbmJzcDt7c3RhcnRzQXR9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGpvaW5CdXR0b24oY3RybCwgbSkge1xuICBpZiAoIXNlc3Npb24uaXNDb25uZWN0ZWQoKSB8fCBtLmlzRmluaXNoZWQpIHsgcmV0dXJuIG51bGw7IH1cbiAgY29uc3QgYWN0aW9uID0gKCkgPT4gY3RybC5qb2luKCk7XG4gIHJldHVybiAoXG4gICAgICA8YnV0dG9uIGtleT1cImpvaW5cIiBjbGFzc05hbWU9XCJhY3Rpb25fYmFyX2J1dHRvblwiIG9uY3JlYXRlPXtoZWxwZXIub250YXAoYWN0aW9uKX0+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXBsYXlcIi8+XG4gICAgICAgIHtpMThuKCdqb2luJyl9XG4gICAgICA8L2J1dHRvbj5cbiAgKTsgIFxufVxuXG5mdW5jdGlvbiB3aXRoZHJhd0J1dHRvbihjdHJsLCBtKSB7XG4gIGlmIChtLmlzRmluaXNoZWQpIHsgcmV0dXJuIG51bGw7IH1cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uIGtleT1cIndpdGhkcmF3XCIgY2xhc3NOYW1lPVwiYWN0aW9uX2Jhcl9idXR0b25cIiBvbmNyZWF0ZT17aGVscGVyLm9udGFwKGN0cmwud2l0aGRyYXcpfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWZsYWdcIi8+XG4gICAgICB7aTE4bignd2l0aGRyYXcnKX1cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFzYUxlYWRlcmJvYXJkKGN0cmwpIHtcblxuICBjb25zdCBkYXRhID0gY3RybC5tYXNhO1xuICBjb25zdCBwbGF5ZXJzID0gY3RybC5jdXJyZW50UGFnZVJlc3VsdHM7XG4gIGNvbnN0IHVzZXIgPSBzZXNzaW9uLmdldCgpO1xuICBjb25zdCB1c2VyTmFtZSA9IHVzZXIgPyB1c2VyLnVzZXJuYW1lIDogJyc7XG4gIFxuICByZXR1cm4gKFxuICAgIDxkaXYga2V5PVwibGVhZGVyYm9hcmRcIiBjbGFzc05hbWU9XCJtYXNhTGVhZGVyYm9hcmRcIj5cbiAgICAgIHsgZGF0YS5uYlBsYXllcnMgPiAwID9cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwibWFzYVRpdGxlXCI+IHtpMThuKFwibGVhZGVyYm9hcmRcIil9ICh7aTE4bignbmJDb25uZWN0ZWRQbGF5ZXJzJywgZGF0YS5uYlBsYXllcnMpfSk8L3A+IDogbnVsbCB9XG4gICAgICA8dWwgY2xhc3NOYW1lPXsnbWFzYVN0YW5kaW5ncyd9PlxuICAgICAge3BsYXllcnMubWFwKHAgPT4gcmVuZGVyUGxheWVyRW50cnkoY3RybCwgdXNlck5hbWUsIHApKX1cbiAgICAgIDwvdWw+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBsYXllckVudHJ5KGN0cmwsIHVzZXJOYW1lLCBwbGF5ZXIpIHtcbiAgY29uc3QgaXNNZSA9IHBsYXllci5uYW1lID09PSB1c2VyTmFtZTtcblxuICByZXR1cm4gKFxuICAgICghcGxheWVyLmFjdGl2ZSkgPyAoXG4gICAgICA8bGkga2V5PXtwbGF5ZXIuaWR9IGNsYXNzTmFtZT17J2xpc3QtaXRlbSBtYXNhLWxpc3QtcGxheWVyJ30+XG4gICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhUGxheWVyXCI+XG4gICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGFnUmFua1wiIGRhdGEtaWNvbj17cGxheWVyLndpdGhkcmF3ID8gJ2InOicnfT4ge3BsYXllci53aXRoZHJhdyA/ICcnIDogKHBsYXllci5yYW5rICsgJy4gJyl9PC9zcGFuPlxuICAgICAgICAgPHNwYW4+IHtpMThuKCdlbXB0eVNlYXQnKX08L3NwYW4+XG4gICAgICAgICA8YnV0dG9uIG9uY3JlYXRlPXtoZWxwZXIub250YXAoY3RybC5pbnZpdGUpfT57aTE4bignaW52aXRlQm90Jyl9PC9idXR0b24+XG4gICAgICAgPC9kaXY+XG4gICAgICAgPHNwYW4gY2xhc3NOYW1lPXsnbWFzYVBvaW50cyAnfSBkYXRhLWljb249J1EnPntwbGF5ZXIuc2NvcmV9PC9zcGFuPlxuICAgICAgPC9saT5cbiAgICApIDpcbiAgICA8bGkgY2xhc3NOYW1lPXsnbGlzdC1pdGVtIG1hc2EtbGlzdC1wbGF5ZXIgJyArIChpc01lID8gJ21hc2EtbWUnIDogJycpfSA+XG4gICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhUGxheWVyXCI+XG4gICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmbGFnUmFua1wiIGRhdGEtaWNvbj17cGxheWVyLndpdGhkcmF3ID8gJ2InOicnfT4ge3BsYXllci53aXRoZHJhdyA/ICcnIDogKHBsYXllci5yYW5rICsgJy4gJyl9PC9zcGFuPlxuICAgICAgICAgPHNwYW4+IHshKHBsYXllci5uYW1lKSA/ICdBbm9ueW1vdXMnIDogcGxheWVyLm5hbWUgKyAnICgnICsgcGxheWVyLnJhdGluZyArICcpICd9PC9zcGFuPlxuICAgICAgIDwvZGl2PlxuICAgICAgIDxzcGFuIGNsYXNzTmFtZT17J21hc2FQb2ludHMgJ30gZGF0YS1pY29uPSdRJz57cGxheWVyLnNjb3JlfTwvc3Bhbj5cbiAgICA8L2xpPlxuICApO1xuXG59XG4iLCJpbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uLy4uL3JvdXRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGN0cmwpIHtcbiAgcmV0dXJuIHtcbiAgICByZWxvYWQ6IGN0cmwucmVsb2FkLFxuICAgIHJlZGlyZWN0KGdhbWVJZCkge1xuICAgICAgLy8gZG9lc24ndCBmaXJlIGZvciBuZXcgam9pblxuICAgICAgY29uc29sZS5sb2coXCJyZWRpcmVjdFwiK2dhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi8uLi9iYWNrYnV0dG9uJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi9yb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKG1hc2EpIHtcbiAgICBsZXQgaXNPcGVuID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaChjbG9zZSk7XG4gICAgICBpc09wZW4gPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZShmcm9tQkIpIHtcbiAgICAgIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICAgICAgaXNPcGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW4sXG4gICAgICBjbG9zZSxcbiAgICAgIGlzT3BlbjogZnVuY3Rpb24oKSB7IHJldHVybiBpc09wZW47IH0sXG4gICAgICBtYXNhXG4gICAgfTtcbiAgfSxcbiAgdmlldzogZnVuY3Rpb24oY3RybCkge1xuICAgIGlmICghY3RybC5pc09wZW4oKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgbWFzYSA9IGN0cmwubWFzYTtcblxuICAgIGlmICghbWFzYSkgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbFwiIGlkPVwibWFzYUZhcU1vZGFsXCIgY29uZmlnPXtoZWxwZXIuc2xpZGVzSW5VcH0+XG4gICAgICAgIDxoZWFkZXI+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJtb2RhbF9jbG9zZVwiIGRhdGEtaWNvbj1cIkxcIlxuICAgICAgICAgICAgICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcChoZWxwZXIuc2xpZGVzT3V0RG93bihjdHJsLmNsb3NlLCBcIm1hc2FGYXFNb2RhbFwiKSl9Lz5cbiAgICAgICAgICA8aDI+e2kxOG4oJ21hc2FGQVEnKX08L2gyPlxuICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbF9jb250ZW50XCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXNhRmFxXCI+XG5cbiAgICAgICAgICAgIDxoMj5QdWFubMSxIG3EsT88L2gyPlxuXG4gICAgICAgICAgICB7IG1hc2EucmF0ZWQgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAnQmF6xLEgbWFzYWxhciBwdWFubMSxZMSxciB2ZSByZXl0aW5naW5pemkgZXRraWxlci4nIDpcbiAgICAgICAgICAgIG1hc2EucmF0ZWQgP1xuICAgICAgICAgICAgICAnQnUgbWFzYSBwdWFubMSxZMSxciB2ZSByZXl0aW5naW5pemkgZXRraWxlci4nIDpcbiAgICAgICAgICAgICAgJ0J1IG1hc2EgcHVhbmzEsSAqZGXEn2lsZGlyKiB2ZSByZXl0aW5naW5pemkgKmV0a2lsZW1leiouJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICA8aDI+IFB1YW5sYXIgbmFzxLFsIGhlc2FwbGFuxLFyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNheWEga2F0xLFsxLFtZGEgaGVyIG95dW5jdSBvcnRheWEgZWwgc2F5xLFzxLEga2FkYXIgcHVhbsSxbsSxIGtveWFyLiBNYXNhIHNvbnVuZGEgb3J0YWRha2kgcHVhbmxhciDFn8O2eWxlIGRhxJ/EsXTEsWzEsXI6XG5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgPGxpPjEuICU1MCBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjIuICUyNSBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjMuICUxNSBwdWFuPC9saT5cbiAgICAgICAgICAgICAgPGxpPjQuICUxMCBwdWFuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgIMOWcm5lxJ9pbiAxMCBlbGxpayBiaXIgb3l1bmRhIG95dW5jdWxhcsSxbiBwdWFubGFyxLEgMTUwMCBvbHN1bi5cblxuICAgICAgICAgICAgTWFzYXlhIGthdMSxbGTEsWtsYXLEsW5kYSBwdWFubGFyxLEgMTQ5MCBvbHVyLiBPcnRhZGEgdG9wbGFtIDQwIHB1YW4gdmFyZMSxciwgdmUgxZ/DtnlsZSBkYcSfxLF0xLFsxLFyOlxuXG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgIDxsaT4xLiArMjAgPSAxNTEwPC9saT5cbiAgICAgICAgICAgICAgPGxpPjIuICsxMCA9IDE1MDA8L2xpPlxuICAgICAgICAgICAgICA8bGk+My4gKzYgPSAxNDk2PC9saT5cbiAgICAgICAgICAgICAgPGxpPjQuICs0ID0gMTQ5NDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuXG4gICAgICAgICAgICBNYXNhIGJpdG1lZGVuIGF5csSxbGFuIG95dW5jdSBwdWFuIGFsYW1hei5cblxuICAgICAgICAgICAgPGgyPiBLYXphbmFuIG5hc8SxbCBiZWxpcmxlbmlyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNhZGEgYsO8dMO8biBlbGxlciBveW5hbmTEsWt0YW4gc29ucmEgZW4gYXogY2V6YXPEsSBvbGFuIG95dW5jdSBnYWxpcCBpbGFuIGVkaWxpci5cblxuICAgICAgICAgICAgPGgyPiBNYXNhZGEgZXNsZXN0aXJtZSBuYXNpbCB5YXBpbGlyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNheWEgNCBveXVuY3Uga2F0aWxkaWdpbmRhIGVsIGJhc2xhci4gQmlyIGVsIGJpdHRpa3RlbiBzb25yYSB5ZW5pIGVsIGJhc2xhciwgeWVuaSBlbGUga2F0aWxtYWsgaWNpbiBveXVuY3VsYXIgbWFzYXlhIGdlcmkgZG9ubWVsaWRpci5cblxuICAgICAgICAgICAgPGgyPiBNYXNhIG5lIHphbWFuIGJpdGVyPyA8L2gyPlxuXG4gICAgICAgICAgICBNYXNhZGEgZWwgc2F5xLFzxLEga2FkYXIgb3l1biBveW5hbmTEscSfxLFuZGEgbWFzYSBiaXRlci5cblxuICAgICAgICAgICAgPGgyPiBPeXVuZGFuIGF5csSxbG1hIDwvaDI+XG5cbiAgICAgICAgICAgIE95dW4gZGV2YW0gZWRlcmtlbiBveXVuZGFuIGF5cmlsYW4gb3l1bmN1IG1hc2FkYW4gYXRpbGlyLCB2ZSBvIGVsIGlwdGFsIG9sdXIuIE1hc2EgYml0bWVkZW4gbWFzYWRhbiBheXLEsWxhbiBveXVuY3UgcHVhbiBhbGFtYXouXG5cbiAgICAgICAgICAgIDxoMj4gRGnEn2VyIMO2bmVtbGkga3VyYWxsYXIgPC9oMj5cblxuICAgICAgICAgICAgU2lyYW5peiBnZWxkaWdpbmRlLCBveWFuYW1hIHPDvHJlbml6aSBhxZ9hcnNhbsSxeiBzaXN0ZW0gc2l6aW4geWVyaW5pemUgb3luYXIuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufTtcbiIsImltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgeyBzYWZlU3RyaW5nVG9OdW0gfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCB7IGhlYWRlciB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuXG5pbXBvcnQgTWFzYXNMaXN0Q3RybCBmcm9tICcuL01hc2FzTGlzdEN0cmwnO1xuaW1wb3J0IHsgcmVuZGVyTWFzYXNMaXN0LCByZW5kZXJGb290ZXIgfSBmcm9tICcuL21hc2FzTGlzdFZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgb25jcmVhdGU6IGhlbHBlci52aWV3RmFkZUluLFxuXG4gIG9uaW5pdCh7IGF0dHJzIH0pIHtcbiAgICAvLyBzb2NrZXQuY3JlYXRlRGVmYXVsdCgpXG5cbiAgICB0aGlzLmN0cmwgPSBuZXcgTWFzYXNMaXN0Q3RybChzYWZlU3RyaW5nVG9OdW0oYXR0cnMudGFiKSk7XG4gIH0sXG5cbiAgdmlldygpIHtcbiAgICBjb25zdCBjdHJsID0gdGhpcy5jdHJsO1xuICAgIFxuICAgIGNvbnN0IGJvZHkgPSByZW5kZXJNYXNhc0xpc3QoY3RybCk7XG4gICAgY29uc3QgZm9vdGVyID0gcmVuZGVyRm9vdGVyKGN0cmwpO1xuICAgIGNvbnN0IG92ZXJsYXkgPSBudWxsO1xuICAgIFxuICAgIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIoaTE4bignbWFzYXMnKSksIGJvZHksIGZvb3Rlciwgb3ZlcmxheSk7XG4gIH1cblxufTtcbiIsImltcG9ydCB7IGZldGNoSlNPTiB9IGZyb20gJy4uLy4uL2h0dHAnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudE1hc2FzKCkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvbWFzYScsIHt9LCB0cnVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hc2EoaWQpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL21hc2EvJyArIGlkLCB7IHF1ZXJ5OiB7IHNvY2tldFZlcnNpb246IDEgfX0sIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVsb2FkKGlkLCBwYWdlKSB7XG4gIHJldHVybiBmZXRjaEpTT04oJy9tYXNhLycgKyBpZCwgeyBtZXRob2Q6ICdHRVQnLCBxdWVyeTogcGFnZSA/IHsgcGFnZSB9OiB7fX0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gam9pbihpZCkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvbWFzYS8nKyBpZCArICcvam9pbicsIHsgbWV0aG9kOiAnUE9TVCcgfSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZpdGUoaWQpIHtcbiAgcmV0dXJuIGZldGNoSlNPTignL21hc2EvJysgaWQgKyAnL2ludml0ZScsIHsgbWV0aG9kOiAnUE9TVCcgfSwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoZHJhdyhpZCkge1xuICByZXR1cm4gZmV0Y2hKU09OKCcvbWFzYS8nKyBpZCArICcvd2l0aGRyYXcnLCB7IG1ldGhvZDogJ1BPU1QnIH0sIHRydWUpO1xufVxuXG4vLyBpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi4vLi4vaHR0cCc7XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBjdXJyZW50TWFzYXMoKSB7XG4vLyAgIHJldHVybiByZXF1ZXN0KCcvbWFzYScsIHt9LCB0cnVlKTtcbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIG1hc2EoaWQpIHtcbi8vICAgcmV0dXJuIHJlcXVlc3QoJy9tYXNhLycgKyBpZCwgeyBkYXRhOiB7c29ja2V0VmVyc2lvbjogMX19LCB0cnVlKTtcbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIHJlbG9hZChpZCkge1xuLy8gICByZXR1cm4gcmVxdWVzdCgnL21hc2EvJyArIGlkLFxuLy8gICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbi8vICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbi8vICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cnVlXG4vLyAgICAgICAgICAgICAgICAgIH0pO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gam9pbihpZCwgc2lkZSkge1xuLy8gICBzaWRlID0gc2lkZSA/IGA/c2lkZT0ke3NpZGV9YDogJyc7XG4vLyAgIHJldHVybiByZXF1ZXN0KCcvbWFzYS8nICsgaWQgKyAnL2pvaW4nICsgc2lkZSwgeyBtZXRob2Q6ICdQT1NUJyB9LCB0cnVlKTtcbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIHdpdGhkcmF3KGlkKSB7XG4vLyAgIHJldHVybiByZXF1ZXN0KCcvbWFzYS8nICsgaWQgKyAnL3dpdGhkcmF3JywgeyBtZXRob2Q6ICdQT1NUJyB9LCB0cnVlKTtcbi8vIH1cbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uL3JvdXRlcic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCB7IGNhcGl0YWxpemUgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IFRhYk5hdmlnYXRpb24gZnJvbSAnLi4vc2hhcmVkL1RhYk5hdmlnYXRpb24nO1xuaW1wb3J0IFRhYlZpZXcgZnJvbSAnLi4vc2hhcmVkL1RhYlZpZXcnO1xuXG5jb25zdCBUQUJTID0gW3tcbiAgbGFiZWw6ICdBw6fEsWsnXG59LCB7XG4gIGxhYmVsOiAnT3luYW5hbidcbn0sIHtcbiAgbGFiZWw6ICdCaXRlbidcbn0gIFxuXTtcblxuZnVuY3Rpb24gb25NYXNhVGFwKGUpIHtcbiAgY29uc3QgZWwgPSBoZWxwZXIuZ2V0TEkoZSk7XG4gIGNvbnN0IGRzID0gZWwuZGF0YXNldDtcbiAgaWYgKGVsICYmIGRzLmlkKSB7XG4gICAgcm91dGVyLnNldCgnL21hc2EvJyArIGRzLmlkKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWFzYXNMaXN0KGN0cmwpIHtcbiAgaWYgKCFjdHJsLm1hc2FzKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCB0YWJzQ29udGVudCA9IFtcbiAgICBjdHJsLm1hc2FzWydjcmVhdGVkJ10sXG4gICAgY3RybC5tYXNhc1snc3RhcnRlZCddLFxuICAgIGN0cmwubWFzYXNbJ2ZpbmlzaGVkJ10sXG4gIF07XG5cbiAgcmV0dXJuIFtcbiAgICBoKCdkaXYudGFicy1uYXYtaGVhZGVyLnN1YkhlYWRlcicsXG4gICAgICBoKFRhYk5hdmlnYXRpb24sIHtcbiAgICAgICAgYnV0dG9uczogVEFCUyxcbiAgICAgICAgc2VsZWN0ZWRJbmRleDogY3RybC5jdXJyZW50VGFiLFxuICAgICAgICBvblRhYkNoYW5nZTogY3RybC5vblRhYkNoYW5nZVxuICAgICAgfSksXG4gICAgICBoKCdkaXYubWFpbl9oZWFkZXJfZHJvcF9zaGFkb3cnKVxuICAgICApLFxuICAgIGgoVGFiVmlldywge1xuICAgICAgY2xhc3NOYW1lOiAnbWFzYVRhYnNXcmFwcGVyJyxcbiAgICAgIHNlbGVjdGVkSW5kZXg6IGN0cmwuY3VycmVudFRhYixcbiAgICAgIGNvbnRlbnQ6IHRhYnNDb250ZW50LFxuICAgICAgcmVuZGVyZXI6IHJlbmRlck1hc2FMaXN0LFxuICAgICAgb25UYWJDaGFuZ2U6IGN0cmwub25UYWJDaGFuZ2VcbiAgICB9KVxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWFzYUxpc3QobGlzdCkge1xuICByZXR1cm4gaCgndWwubmF0aXZlX3Njcm9sbGVyLm1hc2FMaXN0Jywge1xuICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXBYWShvbk1hc2FUYXAsIHVuZGVmaW5lZCwgaGVscGVyLmdldExJKVxuICB9LCBsaXN0Lm1hcChyZW5kZXJNYXNhTGlzdEl0ZW0pKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWFzYUxpc3RJdGVtKG1hc2EsIGluZGV4KSB7XG4gIGNvbnN0IG1vZGUgPSBtYXNhLnJhdGVkID8gaTE4bigncmF0ZWQnKSA6IGkxOG4oJ2Nhc3VhbCcpO1xuICBjb25zdCB2YXJpYW50ID0gY2FwaXRhbGl6ZShtYXNhLnZhcmlhbnQuc2hvcnQpO1xuICBjb25zdCBldmVuT3JPZGQgPSBpbmRleCAlIDIgPT09IDAgPyAnIGV2ZW4gJyA6ICcgb2RkICc7XG4gIGNvbnN0IHNjb3JlcyA9IG1hc2Euc2NvcmVzO1xuICBjb25zdCByb3VuZHMgPSBtYXNhLnJvdW5kcztcbiAgXG4gIHJldHVybiAoXG4gICAgICA8bGkga2V5PXttYXNhLmlkfVxuICAgICAgICAgIGNsYXNzTmFtZT17J2xpc3RfaXRlbSBtYXNhX2l0ZW0nICsgZXZlbk9yT2RkfVxuICAgICAgICAgIGRhdGEtaWQ9e21hc2EuaWR9XG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWFzYUxpc3ROYW1lXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmdWxsTmFtZVwiPnttYXNhLmZ1bGxOYW1lfTwvZGl2PlxuICAgICAgPHNtYWxsIGNsYXNzTmFtZT1cImluZm9zXCI+e3ZhcmlhbnR9IHttb2RlfSDigKIge3Njb3Jlcz9zY29yZXMgKyAnICcgKyBpMThuKCdwb2ludHMnKTppMThuKCdyb3VuZHMnLCByb3VuZHMpfTwvc21hbGw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1hc2FMaXN0VGltZVwiPlxuICAgICAgICAgIDxzbWFsbCBjbGFzc05hbWU9XCJuYlVzZXJzIHdpdGhJY29uXCIgZGF0YS1pY29uPVwiclwiPnttYXNhLm5iUGxheWVyc308L3NtYWxsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbGk+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJGb290ZXIoY3RybCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiYWN0aW9uc19iYXJcIj5cbiAgICAgIDxidXR0b24ga2V5PVwiY3JlYXRlTWFzYVwiIGNsYXNzTmFtZT1cImFjdGlvbl9jcmVhdGVfYnV0dG9uXCIgb25jcmVhdGU9e2hlbHBlci5vbnRhcChuZXdHYW1lRm9ybS5vcGVuUmVhbHRpbWUpfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcGx1cy1jaXJjbGVcIi8+XG4gICAgICAgIHtpMThuKCdjcmVhdGVBTmV3TWFzYScpfVxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGtleT1cInJlZnJlc2hNYXNhXCIgY2xhc3NOYW1lPVwiYWN0aW9uX3JlZnJlc2hfYnV0dG9uXCJcbiAgICBvbmNyZWF0ZT17aGVscGVyLm9udGFwKGN0cmwucmVmcmVzaCl9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1yZWZyZXNoXCIvPlxuICAgICAgICB7aTE4bigncmVmcmVzaCcpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgc3RyZWFtIGZyb20gJ21pdGhyaWwvc3RyZWFtJztcbmltcG9ydCBaYW5pbW8gZnJvbSAnemFuaW1vJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uLy4uL2JhY2tidXR0b24nO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi8uLi9yb3V0ZXInO1xuaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5pbXBvcnQgU2lkZU1lbnVDdHJsIGZyb20gJy4uL3NoYXJlZC9zaWRlTWVudS9TaWRlTWVudUN0cmwnO1xuaW1wb3J0IHsgb250YXAgfSBmcm9tICcuLi9oZWxwZXInO1xuXG5cbmV4cG9ydCBjb25zdCBwcm9maWxlTWVudU9wZW4gPSBzdHJlYW0oZmFsc2UpO1xuXG5mdW5jdGlvbiBvbk1lbnVPcGVuKCkge1xufVxuXG5mdW5jdGlvbiBvbk1lbnVDbG9zZSgpIHtcbn1cblxuXG5leHBvcnQgY29uc3QgbWFpbk1lbnVDdHJsID0gbmV3IFNpZGVNZW51Q3RybChcbiAgJ2xlZnQnLFxuICAnc2lkZV9tZW51JyxcbiAgJ21lbnUtY2xvc2Utb3ZlcmxheScsXG4gIG9uTWVudU9wZW4sXG4gIG9uTWVudUNsb3NlXG4pO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiByb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1haW5NZW51Q3RybC5jbG9zZSgpLnRoZW4oKCkgPT4gcm91dGVyLnNldChyb3V0ZSkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wdXAoYWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWFpbk1lbnVDdHJsLmNsb3NlKCkudGhlbigoKSA9PiB7XG4gICAgICBhY3Rpb24oKTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgYmFja2Ryb3BDbG9zZUhhbmRsZXIgPSBvbnRhcCgoKSA9PiB7XG4gIG1haW5NZW51Q3RybC5jbG9zZSgpO1xufSk7XG5cbmNvbnN0IG1lbnUgPSB7fTtcblxuLyogcHJvcGVydGllcyAqL1xubWVudS5pc09wZW4gPSBmYWxzZTtcbi8vIG1lbnUuaGVhZGVyT3BlbiA9IG0ucHJvcChmYWxzZSk7XG5cbm1lbnUucm91dGUgPSBmdW5jdGlvbihyb3V0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1lbnUuY2xvc2UoKS50aGVuKG0ucm91dGUuYmluZChudWxsLCByb3V0ZSkpO1xuICB9O1xufTtcblxubWVudS5wb3B1cCA9IGZ1bmN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1lbnUuY2xvc2UoKS50aGVuKCgpID0+IHtcbiAgICAgIGFjdGlvbigpO1xuICAgICAgbS5yZWRyYXcoKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbm1lbnUudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChtZW51LmlzT3BlbikgbWVudS5jbG9zZSgpO1xuICBlbHNlIG1lbnUub3BlbigpO1xufTtcblxubWVudS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGJhY2tidXR0b24uc3RhY2sucHVzaChtZW51LmNsb3NlKTtcbiAgbWVudS5pc09wZW4gPSB0cnVlO1xufTtcblxubWVudS53aWxsQ2xvc2UgPSBmYWxzZTtcbm1lbnUuY2xvc2UgPSBmdW5jdGlvbihmcm9tQkIpIHtcbiAgY29uc3Qgc2lkZU1lbnUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2lkZV9tZW51Jyk7XG5cbiAgaWYgKG1lbnUud2lsbENsb3NlIHx8ICFzaWRlTWVudSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcblxuICBtZW51LndpbGxDbG9zZSA9IHRydWU7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBtZW51LmlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgbS5yZWRyYXcuc3RyYXRlZ3koJ25vbmUnKTtcbiAgcmV0dXJuIFphbmltbyhcbiAgICBzaWRlTWVudSxcbiAgICAndHJhbnNmb3JtJyxcbiAgICAndHJhbnNsYXRlM2QoLTEwMCUsMCwwJywgMjUwLCAnZWFzZS1vdXQnXG4gICkudGhlbigoKSA9PiB7XG4gICAgbWVudS5oZWFkZXJPcGVuKGZhbHNlKTtcbiAgICBtZW51LmlzT3BlbiA9IGZhbHNlO1xuICAgIG1lbnUud2lsbENsb3NlID0gZmFsc2U7XG4gICAgbS5yZWRyYXcoKTtcbiAgfSlcbiAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgbWVudS5oZWFkZXJPcGVuKGZhbHNlKTtcbiAgICAgIG1lbnUuaXNPcGVuID0gZmFsc2U7XG4gICAgICBtZW51LndpbGxDbG9zZSA9IGZhbHNlO1xuICAgICAgbS5yZWRyYXcoKTtcbiAgICB9KTtcbn07XG5cbm1lbnUudG9nZ2xlSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBtZW51LmhlYWRlck9wZW4oKSA/IG1lbnUuaGVhZGVyT3BlbihmYWxzZSkgOiBtZW51LmhlYWRlck9wZW4odHJ1ZSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtZW51O1xuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgc2Vzc2lvbiBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCBsb2dpbk1vZGFsIGZyb20gJy4uL2xvZ2luTW9kYWwnO1xuaW1wb3J0IG5ld0dhbWVGb3JtIGZyb20gJy4uL25ld0dhbWVGb3JtJztcbmltcG9ydCB7IGhhc05ldHdvcmssIG5vb3AgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBaYW5pbW8gZnJvbSAnemFuaW1vJztcbmltcG9ydCAqIGFzIG1lbnUgZnJvbSAnLic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25iZWZvcmV1cGRhdGUoKSB7XG4gICAgcmV0dXJuIG1lbnUubWFpbk1lbnVDdHJsLmlzT3BlbjtcbiAgfSxcblxuICB2aWV3KCkge1xuICAgIGNvbnN0IHVzZXIgPSBzZXNzaW9uLmdldCgpO1xuICAgIFxuICAgIHJldHVybiAoXG4gICAgICA8YXNpZGUgaWQ9XCJzaWRlX21lbnVcIj5cbiAgICAgICAge3JlbmRlckhlYWRlcih1c2VyKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXRpdmVfc2Nyb2xsZXIgc2lkZV9tZW51X3Njcm9sbGVyXCI+XG4gICAgICAgICAge3VzZXIgJiYgbWVudS5wcm9maWxlTWVudU9wZW4oKSA/IHJlbmRlclByb2ZpbGVBY3Rpb25zKHVzZXIpIDogcmVuZGVyTGlua3ModXNlcil9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9hc2lkZT5cblxuICAgICk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbmRlckhlYWRlcih1c2VyKSB7XG4gIGNvbnN0IHByb2ZpbGVMaW5rID0gdXNlciA/IG1lbnUucm91dGUoJy9ALycgKyB1c2VyLmlkKSA6IG5vb3A7XG5cbiAgcmV0dXJuIChcbiAgICA8aGVhZGVyIGNsYXNzTmFtZT1cInNpZGVfbWVudV9oZWFkZXJcIj5cbiAgICAgIHsgaGFzTmV0d29yaygpICYmICF1c2VyID9cbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJzaWduSW5CdXR0b25cIiBvbmNyZWF0ZT17aGVscGVyLm9udGFwWFkobG9naW5Nb2RhbC5vcGVuKX0+XG4gICAgICAgICAge2kxOG4oJ3NpZ25JbicpfVxuICAgICAgICA8L2J1dHRvbj4gOiBudWxsXG4gICAgICB9XG4gICAgICB7IHVzZXIgP1xuICAgICAgICA8aDIgY2xhc3NOYW1lPVwidXNlcm5hbWVcIiBvbmNyZWF0ZT17aGVscGVyLm9udGFwWFkocHJvZmlsZUxpbmspfT5cbiAgICAgICAgICB7dXNlci51c2VybmFtZX1cbiAgICAgICAgPC9oMj4gOiBudWxsXG4gICAgICB9XG4gICAgPC9oZWFkZXI+XG4gICk7XG59XG5cblxuZnVuY3Rpb24gc2xpZGVzSW5VcChlbCwgaXNVcGRhdGUsIGNvbnRleHQpIHtcbiAgaWYgKCFpc1VwZGF0ZSkge1xuICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknO1xuICAgIC8vIGZvcmNlIHJlZmxvdyBiYWNrXG4gICAgY29udGV4dC5sb2wgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgWmFuaW1vKGVsLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScsIDI1MCwgJ2Vhc2Utb3V0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTGlua3ModXNlcikge1xuXG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT1cInNpZGVfbGlua3NcIlxuICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcFhZKG9uTGlua1RhcCwgdW5kZWZpbmVkLCBoZWxwZXIuZ2V0TEkpfT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBkYXRhLXJvdXRlPVwiL1wiPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1ob21lXCIgLz57aTE4bignaG9tZScpfVxuICAgICAgPC9saT5cbiAgICAgIHtoYXNOZXR3b3JrKCkgPyBcbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cInNlcF9saW5rXCIga2V5PVwic2VwX2xpbmtfb25saW5lXCI+e2kxOG4oJ3BsYXlPbmxpbmUnKX08L2xpPiA6IG51bGwgXG4gICAgICB9XG4gICAgICB7aGFzTmV0d29yaygpID9cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGRhdGEtcG9wdXA9XCJjcmVhdGVBR2FtZVwiPlxuICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtcGx1cy1jaXJjbGVcIi8+e2kxOG4oJ2NyZWF0ZUFHYW1lJyl9XG4gICAgICAgIDwvbGk+IDogbnVsbCB9XG4gICAgICB7aGFzTmV0d29yaygpID8gPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGRhdGEtcm91dGU9XCIvbWFzYXNcIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXRyb3BoeVwiLz57aTE4bignbWFzYXMnKX1cbiAgICAgICA8L2xpPiA6IG51bGwgfVxuICAgICAge2hhc05ldHdvcmsoKSA/IDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBkYXRhLXJvdXRlPVwiL3RvZG9cIj5cbiAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWF0XCIvPntpMThuKCdwbGF5ZXJzJyl9XG4gICAgICAgPC9saT4gOiBudWxsIH1cbiAgICAgIHtoYXNOZXR3b3JrKCkgPyA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgZGF0YS1yb3V0ZT1cIi90b2RvXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLWN1YmVzXCIvPntpMThuKCdsZWFkZXJib2FyZCcpfVxuICAgICAgIDwvbGk+IDogbnVsbCB9XG4gICAgICAgPGxpIGNsYXNzTmFtZT1cImhyXCI+PC9saT5cbiAgICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgZGF0YS1yb3V0ZT1cIi9zZXR0aW5nc1wiPlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1jb2dcIi8+e2kxOG4oJ3NldHRpbmdzJyl9XG4gICAgICAgPC9saT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBvbmNyZWF0ZT17aGVscGVyLm9udGFwWFkoKCkgPT4ge1xuICAgICAgICAgc2Vzc2lvbi5sb2dvdXQoKTtcbiAgICAgICAgLy8gbWVudS5tYWluTWVudUN0cmwuY2xvc2UoZmFsc2UpO1xuICAgICAgIH0pfT5cbiAgICAgICAgIDxzcGFuIGRhdGEtaWNvbj1cIndcIiAvPlxuICAgICAgICAge2kxOG4oJ2xvZ091dCcpfVxuICAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUHJvZmlsZUFjdGlvbnModXNlcikge1xuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzc05hbWU9XCJzaWRlX2xpbmtzIHByb2ZpbGVBY3Rpb25zXCI+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250b3VjaChtZW51LnJvdXRlKCcvQC8nICsgdXNlci5pZCkpfT5cbiAgICAgICAgPHNwYW4gZGF0YS1pY29uPVwiclwiIC8+XG4gICAgICAgIHtpMThuKCdwcm9maWxlJyl9XG4gICAgICA8L2xpPlxuICAgICAgPGxpIGNsYXNzTmFtZT1cInNpZGVfbGlua1wiIGNvbmZpZz17aGVscGVyLm9udG91Y2gobWVudS5yb3V0ZSgnL3NldHRpbmdzL3ByZWZlcmVuY2VzJykpfT5cbiAgICAgICAgPHNwYW4gZGF0YS1pY29uPVwiJVwiIC8+XG4gICAgICAgIHtpMThuKCdwcmVmZXJlbmNlcycpfVxuICAgICAgPC9saT5cbiAgICAgIDxsaSBjbGFzc05hbWU9XCJzaWRlX2xpbmtcIiBjb25maWc9e2hlbHBlci5vbnRvdWNoKCgpID0+IHtcbiAgICAgICAgc2Vzc2lvbi5sb2dvdXQoKTtcbiAgICAgICAgbWVudS5oZWFkZXJPcGVuKGZhbHNlKTtcbiAgICAgIH0pfT5cbiAgICAgICAgPHNwYW4gZGF0YS1pY29uPVwid1wiIC8+XG4gICAgICAgIHtpMThuKCdsb2dPdXQnKX1cbiAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgKTtcbn1cblxuY29uc3QgcG9wdXBBY3Rpb25NYXAgPSB7XG4gICdjcmVhdGVBR2FtZSc6ICgpID0+IG5ld0dhbWVGb3JtLm9wZW5SZWFsdGltZSgpXG59O1xuXG5mdW5jdGlvbiBvbkxpbmtUYXAoZSkge1xuICBjb25zdCBlbCA9IGhlbHBlci5nZXRMSShlKTtcbiAgY29uc3QgZHMgPSBlbC5kYXRhc2V0O1xuICBpZiAoZWwgJiYgZHMucm91dGUpIHtcbiAgICBtZW51LnJvdXRlKGRzLnJvdXRlKSgpO1xuICB9IGVsc2UgaWYgKGVsICYmIGRzLnBvcHVwKSB7XG4gICAgbWVudS5wb3B1cChwb3B1cEFjdGlvbk1hcFtkcy5wb3B1cF0pKCk7XG4gIH1cbn1cblxuXG4vLyBPTERcblxuZnVuY3Rpb24gcmVuZGVyUHJvZmlsZUFjdGlvbnNPTEQodXNlcikge1xuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzc05hbWU9XCJzaWRlX2xpbmtzIHByb2ZpbGVBY3Rpb25zXCI+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250YXBYWShtZW51LnJvdXRlKCcvQC8nICsgdXNlci5pZCkpfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtdXNlclwiLz57aTE4bigncHJvZmlsZScpfVxuICAgIDwvbGk+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250YXBYWShtZW51LnJvdXRlKCcvc2V0dGluZ3MvcHJlZmVyZW5jZXMnKSl9PlxuICAgICAgICA8c3BhbiBkYXRhLWljb249XCIlXCIgLz57aTE4bigncHJlZmVyZW5jZXMnKX1cbiAgICAgIDwvbGk+XG4gICAgICA8bGkgY2xhc3NOYW1lPVwic2lkZV9saW5rXCIgY29uZmlnPXtoZWxwZXIub250YXBYWSgoKSA9PiB7XG4gICAgICAgIHNlc3Npb24ubG9nb3V0KCk7XG4gICAgICAgIG1lbnUucHJvZmlsZU1lbnVPcGVuKGZhbHNlKTtcbiAgICAgIH0pfT5cbiAgICAgICAgPHNwYW4gZGF0YS1pY29uPVwid1wiIC8+XG4gICAgICAgIHtpMThuKCdsb2dPdXQnKX1cbiAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVudSgpIHtcbiAgY29uc3QgdXNlciA9IHNlc3Npb24uZ2V0KCk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJuYXRpdmVfc2Nyb2xsZXJcIj5cbiAgICAgIHtyZW5kZXJIZWFkZXIodXNlcil9XG4gICAgICB7IHVzZXIgJiYgbWVudS5oZWFkZXJPcGVuKCkgPyByZW5kZXJQcm9maWxlQWN0aW9ucyh1c2VyKSA6IHJlbmRlckxpbmtzKHVzZXIpIH1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IGh1bWFuU2V0dXBGcm9tU2V0dGluZ3MgfSBmcm9tICcuLi9veXVua2V5Zi9zZXR1cCc7XG5pbXBvcnQgcG9wdXBXaWRnZXQgZnJvbSAnLi9zaGFyZWQvcG9wdXAnO1xuaW1wb3J0IGZvcm1XaWRnZXRzIGZyb20gJy4vc2hhcmVkL2Zvcm0nO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi4vc2V0dGluZ3MnO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vc2Vzc2lvbic7XG5pbXBvcnQgYmFja2J1dHRvbiBmcm9tICcuLi9iYWNrYnV0dG9uJztcbmltcG9ydCAqIGFzIHhociBmcm9tICcuLi94aHInO1xuaW1wb3J0IGxvYmJ5IGZyb20gJy4vbG9iYnknO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmxldCBpc09wZW4gPSBmYWxzZTtcblxuY29uc3QgaHVtYW5TZXR1cCA9IHNldHRpbmdzLmdhbWVTZXR1cC5odW1hbjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvcGVuLFxuICBjbG9zZSxcbiAgb3BlblJlYWx0aW1lKCkge1xuICAgIG9wZW4oKTtcbiAgfSxcbiAgdmlldygpIHtcbiAgICByZXR1cm4gcG9wdXBXaWRnZXQoXG4gICAgICAnbmV3X2dhbWVfZm9ybV9wb3B1cCBnYW1lX2Zvcm1fcG9wdXAnLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcmVuZGVyQ29udGVudCxcbiAgICAgIGlzT3BlbixcbiAgICAgIGNsb3NlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gb3BlbigpIHtcbiAgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaChjbG9zZSk7XG4gIGlzT3BlbiA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsb3NlKGZyb21CQikge1xuICBpZiAoZnJvbUJCICE9PSAnYmFja2J1dHRvbicgJiYgaXNPcGVuKSByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgaXNPcGVuID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gIGNvbnN0IGNvbmYgPSBodW1hblNldHVwO1xuXG4gIHJldHVybiBoKCdkaXYnLCBbXG4gICAgaCgnZGl2Lm5ld0dhbWUtcHJlc2V0X3N3aXRjaCcsIFtcbiAgICAgIHJlbmRlckN1c3RvbVNldHVwKFxuICAgICAgICAnaHVtYW4nLFxuICAgICAgICBjb25mLFxuICAgICAgICBjb25mLmF2YWlsYWJsZVZhcmlhbnRzXG4gICAgICApXG4gICAgXSlcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckN1c3RvbVNldHVwKGZvcm1OYW1lLCBzZXR0aW5nc09iaiwgdmFyaWFudHMpIHtcbiAgY29uc3QgZ2VuZXJhbEZpZWxkc2V0ID0gW1xuICAgIGgoJ2Rpdi5zZWxlY3RfaW5wdXQnLCB7XG4gICAgICBrZXk6IGZvcm1OYW1lICsgJ3ZhcmlhbnQnXG4gICAgfSwgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCd2YXJpYW50JywgZm9ybU5hbWUgKyAndmFyaWFudCcsIHZhcmlhbnRzLCBzZXR0aW5nc09iai52YXJpYW50KVxuICAgICApXG4gIF07XG5cbiAgY29uc3QgbW9kZXMgPSBbXG4gICAgWydjYXN1YWwnLCAnMCddLFxuICAgIFsncmF0ZWQnLCAnMSddXG4gIF07XG5cbiAgZ2VuZXJhbEZpZWxkc2V0LnB1c2goaCgnZGl2LnNlbGVjdF9pbnB1dCcsIHtcbiAgICBrZXk6IGZvcm1OYW1lICsgJ21vZGUnXG4gIH0sIGZvcm1XaWRnZXRzLnJlbmRlclNlbGVjdCgnbW9kZScsIGZvcm1OYW1lICsgJ21vZGUnLCBtb2Rlcywgc2V0dGluZ3NPYmoubW9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuXG4gIGNvbnN0IHRpbWVGaWVsZHNldCA9IFtdO1xuXG4gIHRpbWVGaWVsZHNldC5wdXNoKFxuICAgIGgoJ2Rpdi5zZWxlY3RfaW5wdXQuaW5saW5lJywge1xuICAgICAga2V5OiBmb3JtTmFtZSArICdyb3VuZCdcbiAgICB9LFxuICAgICAgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCdyb3VuZHMnLCBmb3JtTmFtZSArICdyb3VuZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmdhbWVTZXR1cC5hdmFpbGFibGVSb3VuZHMsIHNldHRpbmdzT2JqLnJvdW5kcywgZmFsc2UpXG4gICAgIClcbiAgKTtcblxuICByZXR1cm4gaCgnZm9ybS5nYW1lX2Zvcm0nLCB7XG4gICAga2V5OiAnY3VzdG9tU2V0dXAnLFxuICAgIG9uc3VibWl0KGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgICBnb1NlZWsoaHVtYW5TZXR1cEZyb21TZXR0aW5ncyhzZXR0aW5nc09iaikpO1xuICAgIH1cbiAgfSwgW1xuICAgIGgoJ2ZpZWxkc2V0JywgZ2VuZXJhbEZpZWxkc2V0KSxcbiAgICBoKCdmaWVsZHNldCcsIHRpbWVGaWVsZHNldCksXG4gICAgaCgnZGl2LnBvcHVwQWN0aW9uV3JhcHBlcicsIFtcbiAgICAgIGgoJ2J1dHRvbltkYXRhLWljb249RV1bdHlwZT1zdWJtaXRdLnBvcHVwQWN0aW9uJywgaTE4bignY3JlYXRlQUdhbWUnKSlcbiAgICBdKVxuICBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclF1aWNrU2V0dXAob25DdXN0b20pIHtcbiAgcmV0dXJuIGgoJ2Rpdi5uZXdHYW1lLXBvb2xzJywgeyBrZXk6ICdxdWlja1NldHVwJyB9LFxuICAgICAgICAgICBoKCdkaXYubmV3R2FtZS1wb29sJywge1xuICAgICAgICAgICAgIGtleTogJ3Bvb2wtY3VzdG9tJyxcbiAgICAgICAgICAgICBvbmNyZWF0ZTogaGVscGVyLm9udGFwKG9uQ3VzdG9tKVxuICAgICAgICAgICB9LCBoKCdkaXYubmV3R2FtZS1jdXN0b20nLCAnw5Z6ZWwnKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIGdvU2Vlayhjb25mKSB7XG4gIGNsb3NlKCk7XG5cbiAgbG9iYnkuc3RhcnRTZWVraW5nKGNvbmYpO1xufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gcmVuZGVyUXVpY2tTZXR1cCgpIHtcbi8vICAgcmV0dXJuIGgoJ2Rpdi5uZXdHYW1lLXBvb2xzJywgeyBrZXk6ICdxdWlja1NldHVwJyB9LFxuLy8gICAgICAgICAgICB4aHIuY2FjaGVkUG9vbHMubWFwKHAgPT4gcmVuZGVyUG9vbChwKSlcbi8vICAgICAgICAgICApO1xuLy8gfVxuXG4vLyBmdW5jdGlvbiByZW5kZXJQb29sKHApIHtcbi8vICAgcmV0dXJuIGgoJ2Rpdi5uZXdHYW1lLXBvb2wnLCB7XG4vLyAgICAga2V5OiAncG9vbC0nICsgcC5pZCxcbi8vICAgICBvbmNyZWF0ZTogaGVscGVyLm9udGFwKCgpID0+IHtcbi8vICAgICAgIGNvbnNvbGUubG9nKCdvbmNyZWF0ZScpO1xuLy8gICAgIH0pXG4vLyAgIH0sIFtoKCdkaXYubmV3R2FtZS1yb3VuZHMnLCBwLmlkKSxcbi8vICAgICAgIGgoJ2Rpdi5uZXdHYW1lLXBlcmYnLCBwLnBlcmYpXG4vLyAgICAgIF0pO1xuLy8gfVxuXG4vLyBjb25zdCBuZXdHYW1lRm9ybSA9IHt9O1xuXG4vLyBuZXdHYW1lRm9ybS5pc09wZW4gPSBmYWxzZTtcblxuLy8gbmV3R2FtZUZvcm0ub3BlbiA9IGZ1bmN0aW9uKCkge1xuLy8gICBiYWNrYnV0dG9uLnN0YWNrLnB1c2gobmV3R2FtZUZvcm0uY2xvc2UpO1xuLy8gICBuZXdHYW1lRm9ybS5pc09wZW4gPSB0cnVlO1xuLy8gfTtcblxuLy8gbmV3R2FtZUZvcm0uY2xvc2UgPSBmdW5jdGlvbihmcm9tQkIpIHtcbi8vICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIG5ld0dhbWVGb3JtLmlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbi8vICAgbmV3R2FtZUZvcm0uaXNPcGVuID0gZmFsc2U7XG4vLyB9O1xuXG4vLyBuZXdHYW1lRm9ybS5vcGVuUmVhbHRpbWUgPSBmdW5jdGlvbigpIHtcbi8vICAgbmV3R2FtZUZvcm0ub3BlbigpO1xuLy8gfTtcblxuLy8gZnVuY3Rpb24gc2Vla0h1bWFuR2FtZSgpIHtcbi8vICAgbmV3R2FtZUZvcm0uY2xvc2UoKTtcbi8vICAgbG9iYnkuc3RhcnRTZWVraW5nKCk7XG4vLyB9XG5cbi8vIGZ1bmN0aW9uIHJlbmRlckZvcm0oZm9ybU5hbWUsIGFjdGlvbiwgc2V0dGluZ3NPYmosIHZhcmlhbnRzKSB7XG4vLyAgIHZhciBnZW5lcmFsRmllbGRzZXQgPSBbXG4vLyAgICAgbSgnZGl2LnNlbGVjdF9pbnB1dCcsIHtcbi8vICAgICAgIGtleTogZm9ybU5hbWUgKyAndmFyaWFudCdcbi8vICAgICB9LCBbXG4vLyAgICAgICBmb3JtV2lkZ2V0cy5yZW5kZXJTZWxlY3QoJ3ZhcmlhbnQnLCBmb3JtTmFtZSArICcgdmFyaWFudCcsIHZhcmlhbnRzLCBzZXR0aW5nc09iai52YXJpYW50KVxuLy8gICAgIF0pXG4vLyAgIF07XG4gIFxuXG4vLyAgIC8vIEh1bWFuIG9ubHlcbi8vICAgaWYgKHNldHRpbmdzT2JqLm1vZGUpIHtcbi8vICAgICB2YXIgbW9kZXMgPSAoc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpKSA/IFtcbi8vICAgICAgIFsnY2FzdWFsJywgJzAnXSxcbi8vICAgICAgIFsncmF0ZWQnLCAnMSddXG4vLyAgICAgXSA6IFsgWydjYXN1YWwnLCAnMCddIF07XG5cbi8vICAgICBnZW5lcmFsRmllbGRzZXQucHVzaChtKCdkaXYuc2VsZWN0X2lucHV0Jywge1xuLy8gICAgICAga2V5OiBmb3JtTmFtZSArICdtb2RlJ1xuLy8gICAgIH0sIFtcbi8vICAgICAgIGZvcm1XaWRnZXRzLnJlbmRlclNlbGVjdCgnbW9kZScsIGZvcm1OYW1lICsgJ21vZGUnLCBtb2Rlcywgc2V0dGluZ3NPYmoubW9kZSlcbi8vICAgICBdKSk7XG5cbi8vICAgICBpZiAoc2Vzc2lvbi5pc0Nvbm5lY3RlZCgpICYmIHNldHRpbmdzT2JqLm1vZGUoKSA9PT0gJzAnKSB7XG4vLyAgICAgICBnZW5lcmFsRmllbGRzZXQucHVzaChcbi8vICAgICAgICAgZm9ybVdpZGdldHMucmVuZGVyQ2hlY2tib3goaTE4bignbWVtYmVyc09ubHknKSwgJ21lbWJlcnNPbmx5Jywgc2V0dGluZ3NPYmoubWVtYmVyc09ubHkpKTtcbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyBib3RoIGh1bWFuXG4vLyAgIHZhciByb3VuZEZpZWxkc2V0ID0gW1xuLy8gICAgIC8vIG0oJ2Rpdi5zZWxlY3RfaW5wdXQnLCB7XG4vLyAgICAgLy8gICBrZXk6IGZvcm1OYW1lICsgJ3JvdW5kcydcbi8vICAgICAvLyB9LCBbXG4vLyAgICAgLy8gICBmb3JtV2lkZ2V0cy5yZW5kZXJTZWxlY3QoJ3JvdW5kJywgZm9ybU5hbWUgKyAncm91bmRzJywgcm91bmRNb2Rlcywgc2V0dGluZ3NPYmoucm91bmRNb2RlKVxuLy8gICAgIC8vIF0pXG4vLyAgIF07XG5cbi8vICAgaWYgKHRydWUpIHtcbi8vICAgICByb3VuZEZpZWxkc2V0LnB1c2goXG4vLyAgICAgICBtKCdkaXYuc2VsZWN0X2lucHV0Jywge1xuLy8gICAgICAgICBrZXk6IGZvcm1OYW1lICsgJ3JvdW5kcydcbi8vICAgICAgIH0sIFtcbi8vICAgICAgICAgZm9ybVdpZGdldHMucmVuZGVyU2VsZWN0KCdyb3VuZHMnLCBmb3JtTmFtZSArICdyb3VuZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5nYW1lU2V0dXAuYXZhaWxhYmxlUm91bmRzLCBzZXR0aW5nc09iai5yb3VuZHMsIGZhbHNlKVxuLy8gICAgICAgXSlcbi8vICAgICApO1xuLy8gICB9XG5cbi8vICAgcmV0dXJuIG0oJ2Zvcm0jbmV3X2dhbWVfZm9ybS5nYW1lX2Zvcm0nLCB7XG4vLyAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbi8vICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbi8vICAgICAgIGlmICghc2V0dGluZ3MuZ2FtZVNldHVwLmlzUm91bmRWYWxpZChzZXR0aW5nc09iaikpIHJldHVybjtcbi8vICAgICAgIG5ld0dhbWVGb3JtLmNsb3NlKCk7XG4vLyAgICAgICBhY3Rpb24oKTtcbi8vICAgICB9XG4vLyAgIH0sIFtcbi8vICAgICBtKCdmaWVsZHNldCcsIFtcbi8vICAgICBdKSxcbi8vICAgICBtKCdmaWVsZHNldCcsIGdlbmVyYWxGaWVsZHNldCksXG4vLyAgICAgbSgnZmllbGRzZXQjcm91bmQnLCByb3VuZEZpZWxkc2V0KSxcbi8vICAgICBtKCdidXR0b25bZGF0YS1pY29uPUVdW3R5cGU9c3VibWl0XS5uZXdHYW1lQnV0dG9uJywgaTE4bignY3JlYXRlQUdhbWUnKSlcbi8vICAgXSk7XG4vLyB9XG5cbi8vIG5ld0dhbWVGb3JtLnZpZXcgPSBmdW5jdGlvbigpIHtcbi8vICAgZnVuY3Rpb24gZm9ybSgpIHtcbi8vICAgICByZXR1cm4gcmVuZGVyRm9ybShcbi8vICAgICAgICdodW1hbicsXG4vLyAgICAgICBzZWVrSHVtYW5HYW1lLFxuLy8gICAgICAgc2V0dGluZ3MuZ2FtZVNldHVwLmh1bWFuLFxuLy8gICAgICAgc2V0dGluZ3MuZ2FtZVNldHVwLmh1bWFuLmF2YWlsYWJsZVZhcmlhbnRzKTtcbi8vIH07XG5cbi8vICAgcmV0dXJuIHBvcHVwV2lkZ2V0KFxuLy8gICAgICduZXdfZ2FtZV9mb3JtX3BvcHVwIGdhbWVfZm9ybV9wb3B1cCcsXG4vLyAgICAgbnVsbCxcbi8vICAgICBmb3JtLFxuLy8gICAgIG5ld0dhbWVGb3JtLmlzT3Blbixcbi8vICAgICBuZXdHYW1lRm9ybS5jbG9zZVxuLy8gICApO1xuLy8gfTtcblxuLy8gZXhwb3J0IGRlZmF1bHQgbmV3R2FtZUZvcm07XG4iLCJpbXBvcnQgY29udHJvbGxlciBmcm9tICcuL3BsYXllcnNDdHJsJztcbmltcG9ydCB2aWV3IGZyb20gJy4vcGxheWVyc1ZpZXcnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbnRyb2xsZXIsXG4gIHZpZXdcbn07XG4iLCJpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi4vLi4vaHR0cCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBvbmxpbmVQbGF5ZXJzKCkge1xuICByZXR1cm4gcmVxdWVzdCgnL3BsYXllci9vbmxpbmUnLCB7fSwgdHJ1ZSk7XG59XG4iLCJpbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi9wbGF5ZXJYaHInO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRyb2xsZXIoKSB7XG4gIHNvY2tldC5jcmVhdGVEZWZhdWx0KCk7XG5cbiAgY29uc3QgcGxheWVycyA9IG0ucHJvcChbXSk7XG5cbiAgeGhyLm9ubGluZVBsYXllcnMoKS50aGVuKHBsYXllcnMsIGVyciA9PiB1dGlscy5oYW5kbGVYaHJFcnJvcihlcnIpKTtcblxuICByZXR1cm4ge1xuICAgIHBsYXllcnMsXG4gICAgZ29Ub1Byb2ZpbGUodSkge1xuICAgICAgbS5yb3V0ZSgnL0AvJyArIHUpO1xuICAgIH0sXG4gICAgb251bmxvYWQ6ICgpID0+IHtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoIGZyb20gJy4uL2hlbHBlcidcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCB7IG1lbnVCdXR0b24sIHVzZXJTdGF0dXMgfSBmcm9tICcuLi9zaGFyZWQvY29tbW9uJztcbmltcG9ydCBpMThuIGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmlldyhjdHJsKSB7XG5cbiAgY29uc3QgaGVhZGVyQ3RybCA9IGhlYWRlci5iaW5kKG51bGwsIGN0cmwpO1xuICBjb25zdCBib2R5Q3RybCA9IGJvZHkuYmluZChudWxsLCBjdHJsKTtcblxuICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyQ3RybCwgYm9keUN0cmwsIG51bGwpO1xufVxuXG5mdW5jdGlvbiBoZWFkZXIoY3RybCkge1xuICByZXR1cm4gKFxuICAgIDxuYXY+XG4gICAgICB7bWVudUJ1dHRvbigpfVxuICAgICAgPGgxPntpMThuKCdwbGF5ZXJzJyl9PC9oMT5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uc1wiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIm1haW5faGVhZGVyX2J1dHRvblwiIGtleT1cInNlYXJjaFBsYXllcnNcIiBkYXRhLWljb249XCJ5XCIvPlxuICAgICAgPC9kaXY+XG4gICAgPC9uYXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIGJvZHkoY3RybCkge1xuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzc05hbWU9XCJwbGF5ZXJzU3VnZ2VzdGlvbiBuYXRpdmVfc2Nyb2xsZXJfcGFnZVwiPlxuICAgICAge2N0cmwucGxheWVycygpLm1hcChyZW5kZXJQbGF5ZXIpfVxuICAgIDwvdWw+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBsYXllcih1c2VyKSB7XG4gIC8vIGZpbmQgYmVzdCBwZXJmXG4gIGNvbnN0IHBlcmYgPSBPYmplY3Qua2V5cyh1c2VyLnBlcmZzKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICBpZiAoIXByZXYpIHJldHVybiBjdXJyO1xuICAgIGlmICh1c2VyLnBlcmZzW3ByZXZdLnJhdGluZyA8IHVzZXIucGVyZnNbY3Vycl0ucmF0aW5nKVxuICAgICAgcmV0dXJuIGN1cnI7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHByZXY7XG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPGxpIGNsYXNzTmFtZT1cImxpc3RfaXRlbSBwbGF5ZXJTdWdnZXN0aW9uIG5hdlwiIGNvbmZpZz17aC5vbnRvdWNoWSgoKSA9PiBtLnJvdXRlKCcvQC8nICsgdXNlci5pZCkpfT5cbiAgICAgIHt1c2VyU3RhdHVzKHVzZXIpfVxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicmF0aW5nXCIgZGF0YS1pY29uPXt1dGlscy5nYW1lSWNvbihwZXJmKX0+XG4gICAgICAgIHt1c2VyLnBlcmZzW3BlcmZdLnJhdGluZ31cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2xpPlxuICApO1xufVxuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuaW1wb3J0IHsgaGVhZGVyIGFzIGhlYWRlcldpZGdldCwgYmFja0J1dHRvbiB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuaW1wb3J0IGxheW91dCBmcm9tICcuLi9sYXlvdXQnO1xuaW1wb3J0IGZvcm1XaWRnZXRzIGZyb20gJy4uL3NoYXJlZC9mb3JtJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vc29ja2V0JztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgY29udHJvbGxlcigpIHtcbiAgICBzb2NrZXQuY3JlYXRlRGVmYXVsdCgpO1xuICB9LFxuXG4gIHZpZXcoKSB7XG4gICAgY29uc3QgaGVhZGVyID0gdXRpbHMucGFydGlhbGYoaGVhZGVyV2lkZ2V0LCBudWxsLCBiYWNrQnV0dG9uKGkxOG4oJ3NldHRpbmdzJykpKTtcblxuICAgIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIsIHJlbmRlckJvZHkpO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIHJlbmRlckJvZHkoKSB7XG4gIHJldHVybiBtKCdkaXYnLCB7XG4gICAgc3R5bGU6IHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfVxuICB9LCBbXG4gICAgbSgndWwuc2V0dGluZ3NfbGlzdC5nZW5lcmFsLm5hdGl2ZV9zY3JvbGxlci5wYWdlJywgW1xuICAgICAgbSgnbGkubGlzdF9pdGVtLm5hdicsIHtcbiAgICAgICAga2V5OiAnbGFuZycsXG4gICAgICAgIGNvbmZpZzogaGVscGVyLm9udG91Y2hZKHV0aWxzLmYobS5yb3V0ZSwgJy9zZXR0aW5ncy9sYW5nJykpXG4gICAgICB9LCBpMThuKCdsYW5ndWFnZScpKSxcbiAgICAgIG0oJ2xpLmxpc3RfaXRlbS5zZXR0aW5nc0Nob2ljZXNJbmxpbmUnLCB7XG4gICAgICAgIGtleTogJ2JhY2tncm91bmRUaGVtZSdcbiAgICAgIH0sIFtcbiAgICAgICAgbSgnbGFiZWwnLCBpMThuKCdiYWNrZ3JvdW5kJykpLFxuICAgICAgICBtKCdmaWVsZHNldCcsIFtcbiAgICAgICAgICBtKCdkaXYubmljZS1yYWRpbycsIGZvcm1XaWRnZXRzLnJlbmRlclJhZGlvKFxuICAgICAgICAgICAgaTE4bignZGFyaycpLFxuICAgICAgICAgICAgJ2JnVGhlbWUnLFxuICAgICAgICAgICAgJ2RhcmsnLFxuICAgICAgICAgICAgc2V0dGluZ3MuZ2VuZXJhbC50aGVtZS5iYWNrZ3JvdW5kKCkgPT09ICdkYXJrJyxcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLnRoZW1lLmJhY2tncm91bmQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICBsYXlvdXQub25CYWNrZ3JvdW5kQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICBtKCdkaXYubmljZS1yYWRpbycsIGZvcm1XaWRnZXRzLnJlbmRlclJhZGlvKFxuICAgICAgICAgICAgaTE4bignbGlnaHQnKSxcbiAgICAgICAgICAgICdiZ1RoZW1lJyxcbiAgICAgICAgICAgICdsaWdodCcsXG4gICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLnRoZW1lLmJhY2tncm91bmQoKSA9PT0gJ2xpZ2h0JyxcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLnRoZW1lLmJhY2tncm91bmQoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICBsYXlvdXQub25CYWNrZ3JvdW5kQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgXSldKVxuICAgIF0pLFxuICAgIHdpbmRvdy5veXVua2V5Zi52ZXJzaW9uID8gbSgnc2VjdGlvbi5hcHBfdmVyc2lvbicsICd2JyArIHdpbmRvdy5veXVua2V5Zi52ZXJzaW9uKSA6IG51bGxcbiAgXSk7XG59XG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBoZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgZm9ybVdpZGdldHMgZnJvbSAnLi4vc2hhcmVkL2Zvcm0nO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4uLy4uL3NldHRpbmdzJztcbmltcG9ydCBpMThuLCB7IGxvYWRGcm9tU2V0dGluZ3MsIGdldEF2YWlsYWJsZUxhbmd1YWdlcyB9IGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHsgc2V0U2VydmVyTGFuZyB9IGZyb20gJy4uLy4uL3hocic7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBsYW5ncyA9IG0ucHJvcChbXSk7XG4gICAgZ2V0QXZhaWxhYmxlTGFuZ3VhZ2VzKCkudGhlbihsYW5ncyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3NcbiAgICB9O1xuICB9LFxuICB2aWV3OiBmdW5jdGlvbihjdHJsKSB7XG4gICAgY29uc3QgaGVhZGVyID0gdXRpbHMucGFydGlhbGYoaGVhZGVyV2lkZ2V0LCBudWxsLCBiYWNrQnV0dG9uKGkxOG4oJ2xhbmd1YWdlJykpXG4gICAgICApO1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyTGFuZyhsKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8bGkgY2xhc3NOYW1lPVwibGlzdF9pdGVtXCI+XG4gICAgICAgIHtmb3JtV2lkZ2V0cy5yZW5kZXJSYWRpbyhsWzFdLCAnbGFuZycsIGxbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLmxhbmcoKSA9PT0gbFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5nZW5lcmFsLmxhbmcoZS50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZXJ2ZXJMYW5nKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEZyb21TZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICApfVxuICAgICAgICA8L2xpPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJCb2R5KCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm5hdGl2ZV9zY3JvbGxlciBwYWdlIHNldHRpbmdzX2xpc3QgcmFkaW9fbGlzdFwiPlxuICAgICAgICAgIHtjdHJsLmxhbmdzKCkubWFwKGwgPT4gcmVuZGVyTGFuZyhsKSl9XG4gICAgICAgIDwvdWw+XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCByZW5kZXJCb2R5KTtcbiAgfVxufTtcbiIsImltcG9ydCBzZXR0aW5ncyBmcm9tICcuLi8uLi9zZXR0aW5ncyc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KHZub2RlKSB7XG4gICAgXG4gICAgY29uc3QgeyBva2V5Z3JvdW5kIH0gPSB2bm9kZS5hdHRycztcblxuICAgIHRoaXMud3JhcHBlck9uQ3JlYXRlID0gKCh7ZG9tfSkgPT4ge1xuICAgIH0pO1xuXG4gICAgdGhpcy5ib2FyZE9uQ3JlYXRlID0gKHtkb219KSA9PiB7XG4gICAgICBva2V5Z3JvdW5kLmF0dGFjaChkb20pO1xuICAgIH07XG5cbiAgICB0aGlzLmJvYXJkT25SZW1vdmUgPSAoKSA9PiB7XG4gICAgICBva2V5Z3JvdW5kLmRldGFjaCgpO1xuICAgIH07XG4gICAgXG4gIH0sXG5cbiAgdmlldyh2bm9kZSkge1xuICAgIGNvbnN0IHsgYm91bmRzIH0gPSB2bm9kZS5hdHRycztcblxuICAgIGNvbnN0IGJvYXJkQ2xhc3MgPSBbXG4gICAgICAnZGlzcGxheV9ib2FyZCcsXG4gICAgXS5qb2luKCcgJyk7XG5cbiAgICBsZXQgd3JhcHBlckNsYXNzID0gJ2dhbWVfYm9hcmRfd3JhcHBlcic7XG5cbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSBib3VuZHMgPyB7XG4gICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQgKyAncHgnLFxuICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCArICdweCdcbiAgICB9IDoge307XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8c2VjdGlvbiBvbmNyZWF0ZT17dGhpcy53cmFwcGVyT25DcmVhdGV9IGNsYXNzTmFtZT17d3JhcHBlckNsYXNzfSBzdHlsZT17d3JhcHBlclN0eWxlfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Ym9hcmRDbGFzc31cbiAgICAgICAgICAgICBvbmNyZWF0ZT17dGhpcy5ib2FyZE9uQ3JlYXRlfVxuICAgICAgICAgICAgIG9ucmVtb3ZlPXt0aGlzLmJvYXJkT25SZW1vdmV9Lz5cbiAgICAgICAgPC9zZWN0aW9uPlxuICAgICk7XG4gIH1cbiAgXG59O1xuXG5cbi8vIGZ1bmN0aW9uIHJlbmRlclRvcE1lbnUoKSB7XG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBjbGFzcz1cImRpc3BsYXlfbWVudVwiPlxuLy8gICAgICAge21lbnVCdXR0b24oKX1cbi8vICAgICA8L2Rpdj5cbi8vICAgKTtcbi8vIH1cblxuLy8gZnVuY3Rpb24gcmVuZGVyUGxheWVySW5mbyhjdHJsLCBwbGF5ZXIsIHBvc2l0aW9uKSB7XG4vLyAgIGNvbnN0IHdyYXBwZXJDbGFzcyA9IGhlbHBlci5jbGFzc1NldCh7XG4vLyAgICAgJ3BsYXllckluZm9zJzogdHJ1ZSxcbi8vICAgfSkgKyBgICR7cG9zaXRpb259YDtcblxuLy8gICBjb25zdCBwbGF5ZXJOYW1lID0gcGxheWVyLmFpID9cbi8vICAgICAgICAgICAgICAgICAgICAgIGkxOG4oJ2FpQm90JywgcGxheWVyLmFpKSA6XG4vLyAgICAgICAgICAgICAgICAgICAgICB1dGlscy5wbGF5ZXJOYW1lKHBsYXllcik7XG4vLyAgIGNvbnN0IHBsYXllck9uR2FtZSA9IChwbGF5ZXIub25HYW1lIHx8IHBsYXllci5haSA/XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJvbmdhbWUgeWVzXCIgZGF0YS1pY29uPVwiM1wiLz4gOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwib25nYW1lIG5vXCIgZGF0YS1pY29uPVwiMFwiLz5cbi8vICAgKTtcblxuLy8gICBjb25zdCB0b2dnbGVQb3B1cCA9IGN0cmwudG9nZ2xlVXNlclBvcHVwLmJpbmQoY3RybCwgcG9zaXRpb24sIHBsYXllci51c2VyKTtcbi8vICAgY29uc3QgdkNvbmYgPSBoZWxwZXIub250b3VjaCh0b2dnbGVQb3B1cCk7XG5cbi8vICAgY29uc3QgcnVubmluZ1NpZGUgPSBjdHJsLmlzQ2xvY2tSdW5uaW5nKCkgPyBjdHJsLmRhdGEuZ2FtZS5wbGF5ZXIgOiBudWxsO1xuLy8gICBjb25zdCBydW5uaW5nID0gY3RybC5kYXRhLmdhbWUucGxheWVyID09PSBwbGF5ZXIuc2lkZTtcblxuLy8gICBjb25zdCBvcGVucyA9IGN0cmwuZGF0YS5nYW1lLm9zY29yZXMgPyBjdHJsLmRhdGEuZ2FtZS5vc2NvcmVzW3BsYXllci5zaWRlXSA6IG51bGw7XG4vLyAgIGNvbnN0IG9wZW5zSGludCA9IG9wZW5zID8gKG9wZW5zLnNlcmllcyA/ICdvcGVuZWRTZXJpZXMnIDogJ29wZW5lZFBhaXJzJykgOiBudWxsO1xuLy8gICBjb25zdCBvcGVuc0NsYXNzID0gXCJvcGVuc1wiICsgKChvcGVucyAmJiBvcGVucy5uZXcpID8gXCIgbmV3XCIgOiBcIlwiKTtcblxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPXt3cmFwcGVyQ2xhc3N9IGNvbmZpZz17dkNvbmZ9PlxuLy8gICAgICAgPGRpdiBjbGFzcz1cIndyYXBfaW5mb1wiPlxuLy8gICAgICAgICB7b3BlbnMgP1xuLy8gICAgICAgICAgPGRpdiBjbGFzcz17b3BlbnNDbGFzc30+XG4vLyAgICAgICAgICAgIHsob3BlbnMuc2VyaWVzID8gb3BlbnMuc2VyaWVzIDogb3BlbnMucGFpcnMpfVxuLy8gICAgICAgICAgICB7JyAnfVxuLy8gICAgICAgICAgICB7aTE4bihvcGVuc0hpbnQpLnNwbGl0KCcgJylbMF19XG4vLyAgICAgICAgICA8L2Rpdj46IG51bGxcbi8vICAgICAgICAgfVxuLy8gICAgICAgPC9kaXY+XG4vLyAgICAgICA8ZGl2IGNsYXNzPVwid3JhcF91c2VyXCI+XG4vLyAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJwbGF5ZXJVc2VyXCI+XG4vLyAgICAgICAgICAge3BsYXllck5hbWV9XG4vLyAgICAgICAgICAge3BsYXllck9uR2FtZX1cbi8vICAgICAgICAgPC9oMj5cbi8vICAgICAgICAgeyAoY3RybC5jbG9jayAmJiBydW5uaW5nKSA/XG4vLyAgICAgICAgICAgcmVuZGVyQ2xvY2soY3RybC5jbG9jaywgcGxheWVyLnNpZGUsIHJ1bm5pbmdTaWRlLCBwb3NpdGlvbikgOiBudWxsXG4vLyAgICAgICAgIH1cbi8vICAgICAgIDwvZGl2PlxuLy8gICAgIDwvZGl2PlxuLy8gICApO1xuLy8gfVxuXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihcbi8vICAgY3RybCxcbi8vICAgb2tleWdyb3VuZEN0cmwsXG4vLyAgIGJvdW5kcyxcbi8vICAgaXNQb3J0cmFpdCxcbi8vICAgd3JhcHBlckNsYXNzZXMpIHtcbi8vICAgICBjb25zdCBkYXRhID0gY3RybC5kYXRhO1xuXG4vLyAgICAgY29uc3QgYm9hcmRDbGFzcyA9IFtcbi8vICAgICAgICdkaXNwbGF5X2JvYXJkJyxcbi8vICAgICBdLmpvaW4oJyAnKTtcblxuLy8gICAgIGNvbnN0IGtleSA9ICdib2FyZCcgKyAoaXNQb3J0cmFpdCA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJyk7XG4vLyAgICAgbGV0IHdyYXBwZXJDbGFzcyA9ICdnYW1lX2JvYXJkX3dyYXBwZXInO1xuXG4vLyAgICAgaWYgKHdyYXBwZXJDbGFzc2VzKSB7XG4vLyAgICAgICB3cmFwcGVyQ2xhc3MgKz0gJyAnICsgd3JhcHBlckNsYXNzZXM7XG4vLyAgICAgfVxuXG4vLyAgICAgY29uc3Qgd3JhcHBlclN0eWxlID0gYm91bmRzID8ge1xuLy8gICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0ICsgJ3B4Jyxcbi8vICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGggKyAncHgnXG4vLyAgICAgfSA6IHt9O1xuXG5cbi8vICAgICBmdW5jdGlvbiB3cmFwcGVyQ29uZmlnKGVsLCBpc1VwZGF0ZSkge1xuLy8gICAgICAgaWYgKCFpc1VwZGF0ZSkge1xuLy8gICAgICAgfVxuLy8gICAgIH1cblxuLy8gICAgIGZ1bmN0aW9uIGJvYXJkQ29uZmlnKGVsLCBpc1VwZGF0ZSkge1xuLy8gICAgICAgaWYgKCFpc1VwZGF0ZSkge1xuLy8gICAgICAgICBpZiAoIWJvdW5kcykge1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIG9rZXlncm91bmQucmVuZGVyKGVsLCBva2V5Z3JvdW5kQ3RybCk7XG4vLyAgICAgICB9XG4vLyAgICAgfVxuXG4vLyAgICAgb2tleWdyb3VuZEN0cmwuZGF0YS50b3BIb29rcyA9IFtcbi8vICAgICAgIC8vIHJlbmRlclRvcE1lbnUoKSxcbi8vICAgICAgIHJlbmRlclBsYXllckluZm8oY3RybCwgZGF0YS5vcHBvbmVudFVwLCAndG9wJyksXG4vLyAgICAgICByZW5kZXJQbGF5ZXJJbmZvKGN0cmwsIGRhdGEub3Bwb25lbnRMZWZ0LCAnbGVmdCcpLFxuLy8gICAgICAgcmVuZGVyUGxheWVySW5mbyhjdHJsLCBkYXRhLnBsYXllciwgJ2JvdHRvbScpLFxuLy8gICAgICAgcmVuZGVyUGxheWVySW5mbyhjdHJsLCBkYXRhLm9wcG9uZW50UmlnaHQsICdyaWdodCcpXG4vLyAgICAgXTtcblxuXG4vLyAgICAgcmV0dXJuIChcbi8vICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT17d3JhcHBlckNsYXNzfSBjb25maWc9e3dyYXBwZXJDb25maWd9XG4vLyAgICAgICAgICAgICAgICBzdHlsZT17d3JhcHBlclN0eWxlfSBrZXk9e2tleX0+XG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtib2FyZENsYXNzfSBjb25maWc9e2JvYXJkQ29uZmlnfSAvPlxuLy8gICAgICAgPC9zZWN0aW9uPlxuLy8gICAgICk7XG4vLyB9XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2aWV3KHsgYXR0cnMgfSkge1xuXG4gICAgY29uc3QgdGl0bGUgPSAnZ2FtZUFwaS50aXRsZShkYXRhKSc7XG5cbiAgICByZXR1cm4gaCgnZGl2Lm1haW5faGVhZGVyX3RpdGxlJywge1xuICAgIH0sIFtcbiAgICAgIGgoJ2gxLmhlYWRlci1nYW1lVGl0bGUnLCBbXG4gICAgICAgIGgoJ3NwYW4nLCB0aXRsZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmluaXQoe2F0dHJzfSkge1xuICAgIHRoaXMub25UYXAgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgZWwgPSBoZWxwZXIuZ2V0QnV0dG9uKGUpO1xuICAgICAgbGV0IGk7XG4gICAgICBpZiAoZWwgJiYgKGkgPSAoZWwuZGF0YXNldCkuaW5kZXgpKSB7XG4gICAgICAgIGF0dHJzLm9uVGFiQ2hhbmdlKE51bWJlcihpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICB2aWV3KHZub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnV0dG9ucyxcbiAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICBub0luZGljYXRvcixcbiAgICAgIHdyYXBwZXJDbGFzc1xuICAgIH0gPSB2bm9kZS5hdHRycztcblxuICAgIGNvbnN0IGlXaWR0aCA9IDEwMCAvIGJ1dHRvbnMubGVuZ3RoO1xuICAgIGNvbnN0IHNoaWZ0ID0gc2VsZWN0ZWRJbmRleCAqIChpV2lkdGggKiBidXR0b25zLmxlbmd0aCk7XG5cbiAgICBjb25zdCBpbmRpY2F0b3JTdHlsZSA9IHtcbiAgICAgIHdpZHRoOiBpV2lkdGggKyAnJScsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7c2hpZnR9JSlgXG4gICAgfTtcblxuICAgIGNvbnN0IGJ1dHRvblN0eWxlID0ge1xuICAgICAgd2lkdGg6IGlXaWR0aCArICclJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZW5kZXJUYWIoYiwgaSkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gW1xuICAgICAgICAndGFiLWJ1dHRvbicsXG4gICAgICAgIHNlbGVjdGVkSW5kZXggPT09IGkgPyAnc2VsZWN0ZWQnOiAnJyxcbiAgICAgICAgYi5jbGFzc05hbWVcbiAgICAgIF0uam9pbignICcpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8YnV0dG9uIGRhdGEtaW5kZXg9e2l9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzdHlsZT17YnV0dG9uU3R5bGV9PlxuICAgICAgICAgICAge2IubGFiZWx9XG4gICAgICAgICAgICB7Yi5jaGlwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNoaXBcIj57Yi5jaGlwfTwvc3Bhbj4gOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17J3RhYnMtbmF2aWdhdGlvbicgKyAod3JhcHBlckNsYXNzID8gJyAnICsgd3JhcHBlckNsYXNzIDogJycpfVxuICAgICAgICAgICBvbmNyZWF0ZT17aGVscGVyLm9udGFwKHRoaXMub25UYXApfT5cbiAgICAgICAgICB7YnV0dG9ucy5tYXAocmVuZGVyVGFiKX1cbiAgICAgICAgICB7IG5vSW5kaWNhdG9yID8gbnVsbCA6IDxkaXYgY2xhc3NOYW1lPVwidGFiSW5kaWNhdG9yXCIgc3R5bGU9XCJpbmRpY2F0b3JTdHlsZVwiLz4gfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCB7IHZpZXdwb3J0RGltIH0gZnJvbSAnLi4vaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvbmNyZWF0ZSh7YXR0cnMsIGRvbX0pIHtcbiAgfSxcblxuICB2aWV3KHthdHRyc30pIHtcbiAgICBjb25zdCBjdXJJbmRleCA9IGF0dHJzLnNlbGVjdGVkSW5kZXg7XG4gICAgY29uc3QgdncgPSB2aWV3cG9ydERpbSgpLnZ3O1xuICAgIGNvbnN0IHdpZHRoID0gYXR0cnMuY29udGVudC5sZW5ndGggKiAxMDA7XG4gICAgY29uc3Qgc2hpZnQgPSAtKGN1ckluZGV4ICogdncpO1xuXG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICB3aWR0aDogYCR7d2lkdGh9dndgLFxuICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke3NoaWZ0fXB4KWBcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBoKCdkaXYudGFicy12aWV3LXdyYXBwZXInLCBoKCdkaXYudGFicy12aWV3Jywge1xuICAgICAgc3R5bGUsXG4gICAgICBjbGFzc05hbWU6IGF0dHJzLmNsYXNzTmFtZVxuICAgIH0sIGF0dHJzLmNvbnRlbnQubWFwKChfLCBpbmRleCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICBoKCdkaXYudGFiLWNvbnRlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1pbmRleCc6aW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGN1ckluZGV4ID09PSBpbmRleCA/ICdjdXJyZW50JzonJ1xuICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGN1ckluZGV4ID09PSBpbmRleCA/IGgoVGFiLCB7IGluZGV4LCAuLi5hdHRycyB9KSA6IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgKTtcbiAgICBcbiAgfVxuXG59XG5cbmNvbnN0IFRhYiA9IHtcbiAgb25iZWZvcmV1cGRhdGUoe2F0dHJzfSwge2F0dHJzOiBvbGRhdHRycyB9KSB7XG4gICAgcmV0dXJuIGF0dHJzLmNvbnRlbnRbYXR0cnMuaW5kZXhdICE9PSBvbGRhdHRycy5jb250ZW50W29sZGF0dHJzLmluZGV4XTtcbiAgfSxcblxuICB2aWV3KHthdHRyc30pIHtcbiAgICByZXR1cm4gYXR0cnMucmVuZGVyZXIoYXR0cnMuY29udGVudFthdHRycy5pbmRleF0sIGF0dHJzLmluZGV4KTtcbiAgfVxufVxuIiwiaW1wb3J0IG9rZXlncm91bmQgZnJvbSAnb2tleWdyb3VuZC1tb2JpbGUnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZpZXcoXywgYXJncykge1xuICAgIGNvbnN0IGJvYXJkQ2xhc3MgPSBbXG4gICAgICAnZGlzcGxheV9ib2FyZCcsXG4gICAgICBhcmdzLnZhcmlhbnQgPyBhcmdzLnZhcmlhbnQua2V5IDogJydcbiAgICBdLmpvaW4oJyAnKTtcblxuICAgIGZ1bmN0aW9uIGJvYXJkQ29uZihlbCwgaXNVcGRhdGUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IG1ha2VDb25maWcoYXJncyk7XG4gICAgICBpZiAoY29udGV4dC5ncm91bmQpIHtcbiAgICAgICAgY29udGV4dC5ncm91bmQuc2V0KGNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIHRyeSB0byBhdm9pZCB0aGF0XG4gICAgICAgIGlmICghY29uZmlnLmJvdW5kcykge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdubyBib2FyZCBib3VuZHMnKTtcbiAgICAgICAgICAvLyBjb25maWcuYm91bmRzID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5ncm91bmQgPSBva2V5Z3JvdW5kKGVsLCBjb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Ym9hcmRDbGFzc30gY29uZmlnPXtib2FyZENvbmZ9Lz5cbiAgICApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYWtlQ29uZmlnKGFyZ3MpIHtcbiAgY29uc3QgeyBmZW4sIG9yaWVudGF0aW9uLCBib3VuZHMgfSA9IGFyZ3M7XG4gIGNvbnN0IGNvbmYgPSB7XG4gICAgdmlld09ubHk6IHRydWUsXG4gICAgbWluaW1hbERvbTogdHJ1ZSxcbiAgICBmZW5cbiAgfTtcblxuICAvLyBpZiAoYm91bmRzKSBjb25mLmJvdW5kcyA9IGJvdW5kcztcblxuICByZXR1cm4gY29uZjtcbn1cbiIsImltcG9ydCAqIGFzIG1lbnUgZnJvbSAnLi4vbWVudSc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgZ2FtZXNNZW51IGZyb20gJy4uL2dhbWVzTWVudSc7XG5pbXBvcnQgbmV3R2FtZUZvcm0gZnJvbSAnLi4vbmV3R2FtZUZvcm0nO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vcm91dGVyJztcbmltcG9ydCB7IGJhY2tBcnJvdyB9IGZyb20gJy4vaWNvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWVudUJ1dHRvbigpIHtcbiAgcmV0dXJuIGgoJ2J1dHRvbi5mYS5mYS1uYXZpY29uLm1haW5faGVhZGVyX2J1dHRvbi5tZW51X2J1dHRvbicsIHtcbiAgICBrZXk6ICdtYWluLW1lbnUnLFxuICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXAobWVudS5tYWluTWVudUN0cmwudG9nZ2xlKVxuICB9KTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGVhZGVyQnRucygpIHtcblxuICBpZiAodXRpbHMuaGFzTmV0d29yaygpICYmIHNlc3Npb24uaXNDb25uZWN0ZWQoKSkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT1cImJ1dHRvbnNcIiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGtleT1cImJ1dHRvbnNcIiBjbGFzc05hbWU9XCJidXR0b25zXCI+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG4gIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJvcFNoYWRvd0hlYWRlcih0aXRsZSwgbGVmdEJ1dHRvbikge1xuXG4gIHJldHVybiBbXG4gICAgaCgnbmF2JywgW1xuICAgICAgbGVmdEJ1dHRvbiA/IGxlZnRCdXR0b24gOiBtZW51QnV0dG9uKCksXG4gICAgICB0aXRsZSA/IDxkaXYgY2xhc3NOYW1lPVwibWFpbl9oZWFkZXJfdGl0bGVcIiBrZXk9XCJ0aXRsZVwiPnt0aXRsZX08L2Rpdj46IG51bGwsXG4gICAgICBoZWFkZXJCdG5zKClcbiAgICBdKSxcbiAgICBoKCdkaXYubWFpbl9oZWFkZXJfZHJvcF9zaGFkb3cnKVxuICBdO1xuICBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3RpbmdEcm9wU2hhZG93SGVhZGVyKHRpdGxlKSB7XG4gIHJldHVybiBbXG4gICAgaCgnbmF2JywgW1xuICAgICAgbWVudUJ1dHRvbigpLFxuICAgICAgaCgnZGl2Lm1haW5faGVhZGVyX3RpdGxlLnJlY29ubmVjdGluZycsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB0aXRsZSA/ICd3aXRoVGl0bGUnOicnLFxuICAgICAgICBrZXk6ICdjb25uZWN0aW5nLXRpdGxlJ1xuICAgICAgfSksXG4gICAgICB0aXRsZSA/IGgoJ2Rpdi5tYWluX2hlYWRlcl90aXRsZScsIHsga2V5OiAndGl0bGUnIH0sIHRpdGxlKSA6IG51bGwsXG4gICAgICBoZWFkZXJCdG5zKClcbiAgICBdKSxcbiAgICBoKCdkaXYubWFpbl9oZWFkZXJfZHJvcF9zaGFkb3cnKVxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja0J1dHRvbih0aXRsZSkge1xuICByZXR1cm4gaCgnZGl2LmJhY2tfYnV0dG9uJywgeyBrZXk6ICdkZWZhdWx0LWhpc3RvcnktYmFja2J1dHRvbicgfSwgW1xuICAgIGgoJ2J1dHRvbicsIHsgb25jcmVhdGU6IGhlbHBlci5vbnRhcChyb3V0ZXIuYmFja0hpc3RvcnkpIH0sIGJhY2tBcnJvdyksXG4gICAgdGl0bGUgIT09IHVuZGVmaW5lZCA/IHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycgPyBoKCdkaXYubWFpbl9oZWFkZXJfdGl0bGUnLCB0aXRsZSkgOiB0aXRsZSA6IG51bGxcbiAgXSk7XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBtZW51QnV0dG9uKCkge1xuLy8gICByZXR1cm4gKFxuLy8gICAgICAgPGJ1dHRvbiBrZXk9XCJtYWluLW1lbnVcIiBjbGFzc05hbWU9XCJmYSBmYS1uYXZpY29uIG1haW5faGVhZGVyX2J1dHRvbiBtZW51X2J1dHRvblwiIGNvbmZpZz17aGVscGVyLm9udG91Y2gobWVudS50b2dnbGUpfT5cbi8vICAgICA8L2J1dHRvbj5cbi8vICAgKTtcbi8vIH1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGJhY2tCdXR0b24odGl0bGUpIHtcbi8vICAgcmV0dXJuIChcbi8vICAgICAgIDxidXR0b24ga2V5PVwiZGVmYXVsdC1oaXN0b3J5LWJhY2tidXR0b25cIiBjbGFzc05hbWU9XCJiYWNrX2J1dHRvbiBtYWluX2hlYWRlcl9idXR0b25cIiBjb25maWc9e2hlbHBlci5vbnRvdWNoKHV0aWxzLmJhY2tIaXN0b3J5KX0+XG4vLyAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmYSBmYS1hcnJvdy1sZWZ0XCIvPlxuLy8gICAgICAge3RpdGxlID8gPGRpdiBjbGFzc05hbWU9XCJ0aXRsZVwiPnt0aXRsZX08L2Rpdj4gOiBudWxsIH1cbi8vICAgICA8L2J1dHRvbj5cbi8vICAgKTtcbi8vIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhbWVzQnV0dG9uKCkge1xuICBsZXQga2V5LCBhY3Rpb247XG5cbiAga2V5PSdnYW1lcy1tZW51JztcblxuICBpZiAoc2Vzc2lvbi5ub3dQbGF5aW5nKCkubGVuZ3RoKSB7XG4gICAga2V5ID0gJ2dhbWVzLW1lbnUnO1xuICAgIGFjdGlvbiA9IGdhbWVzTWVudS5vcGVuO1xuICB9IGVsc2Uge1xuICAgIGtleSA9ICduZXctZ2FtZS1mb3JtJztcbiAgICBhY3Rpb24gPSBuZXdHYW1lRm9ybS5vcGVuO1xuICB9XG5cbiAgY29uc3QgY2xhc3NOYW1lID0gW1xuICAgICdtYWluX2hlYWRlcl9idXR0b24nLFxuICAgICdnYW1lX21lbnVfYnV0dG9uJyxcbiAgICAhdXRpbHMuaGFzTmV0d29yaygpID8gJ2ludmlzaWJsZScgOiAnJ1xuICBdLmpvaW4oJyAnKTtcblxuICBjb25zdCBsb25nQWN0aW9uID0gKCkgPT4gd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhpMThuKCduYkdhbWVzSW5QbGF5Jywgc2Vzc2lvbi5ub3dQbGF5aW5nKCkubGVuZ3RoKSwgJ3Nob3J0JywgJ3RvcCcpO1xuXG4gIHJldHVybiAoXG4gICAgICA8YnV0dG9uIGtleT17a2V5fSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gY29uZmlnPXtoZWxwZXIub250b3VjaChhY3Rpb24sIGxvbmdBY3Rpb24pfT5cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGhlYWRlckJ0bnMoKSB7XG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBrZXk9XCJidXR0b25zXCIgY2xhc3NOYW1lPVwiYnV0dG9uc1wiPlxuLy8gICAgICAge2dhbWVzQnV0dG9uKCl9XG4vLyAgICAgPC9kaXY+XG4vLyAgICk7XG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBoZWFkZXIodGl0bGUsIGxlZnRCdXR0b24pIHtcbiAgcmV0dXJuIChcbiAgICA8bmF2PlxuICAgICAge2xlZnRCdXR0b24gPyBsZWZ0QnV0dG9uIDogbWVudUJ1dHRvbigpfVxuICAgICAge3RpdGxlID8gPGgxIGtleT1cInRpdGxlXCI+e3RpdGxlfTwvaDE+IDogbnVsbCB9XG4gICAgICB7aGVhZGVyQnRucygpfVxuICAgIDwvbmF2PlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlld09ubHlCb2FyZENvbnRlbnQoKSB7XG4gIGNvbnN0IGlzUG9ydHJhaXQgPSBmYWxzZTtcbiAgY29uc3QgeyB2dywgdmggfSA9IHsgdnc6IDEwLCB2aDogMTAgfVxuICBjb25zdCBib2FyZFN0eWxlID0gaXNQb3J0cmFpdCA/IHsgd2lkdGg6IHZ3ICsgJ3B4JywgaGVpZ2h0OiB2dyArICdweCcgfSA6IHt9O1xuICBjb25zdCBib2FyZEtleSA9ICd2aWV3b25seWJvYXJkJ1xuICBjb25zdCBjbGFzc05hbWUgPSAnYm9hcmRfd3JhcHBlcidcbiAgY29uc3QgYm9hcmQgPSAoXG4gICAgPHNlY3Rpb24ga2V5PXtib2FyZEtleX0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IHN0eWxlPXtib2FyZFN0eWxlfT5cbiAgICAgIHttLmNvbXBvbmVudChWaWV3T25seUJvYXJkKX1cbiAgICA8L3NlY3Rpb24+XG4gICk7XG4gIHJldHVybiBbXG4gICAgYm9hcmRcbiAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VyU3RhdHVzKHVzZXIpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlci5vbmxpbmUgPyAnb25saW5lJyA6ICdvZmZsaW5lJztcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInVzZXJcIj5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17J3VzZXJTdGF0dXMgJyArIHN0YXR1c30gZGF0YS1pY29uPVwiclwiIC8+XG4gICAgICB7dXNlci51c2VybmFtZX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuXG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi9oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJlbmRlclNlbGVjdChcbiAgICBsYWJlbCxcbiAgICBuYW1lLFxuICAgIG9wdGlvbnMsXG4gICAgc2V0dGluZ3NQcm9wLFxuICAgIGlzRGlzYWJsZWQsXG4gICAgb25DaGFuZ2VDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb3AgPSBzZXR0aW5nc1Byb3AoKTtcbiAgICByZXR1cm4gW1xuICAgICAgaCgnbGFiZWwnLCB7XG4gICAgICAgICdmb3InOiAnc2VsZWN0XycgKyBuYW1lXG4gICAgICB9LCBpMThuKGxhYmVsKSksXG4gICAgICBoKCdzZWxlY3QnLCB7XG4gICAgICAgIGlkOiAnc2VsZWN0XycgKyBuYW1lLFxuICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbiAgICAgICAgb25jaGFuZ2UoZSkge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIHNldHRpbmdzUHJvcCh2YWwpO1xuICAgICAgICAgIGlmIChvbkNoYW5nZUNhbGxiYWNrKSBvbkNoYW5nZUNhbGxiYWNrKHZhbCk7XG4gICAgICAgICAgc2V0VGltZW91dChyZWRyYXcsIDEwKTtcbiAgICAgICAgfVxuICAgICAgfSwgb3B0aW9ucy5tYXAoZSA9PiByZW5kZXJPcHRpb24oZVswXSwgZVsxXSwgcHJvcCwgZVsyXSwgZVszXSkpKVxuICAgIF07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlbmRlck9wdGlvbihsYWJlbCwgdmFsdWUsIHByb3AsIGxhYmVsQXJnLCBsYWJlbEFyZzIpIHtcbiAgY29uc3QgbCA9IGxhYmVsQXJnICYmIGxhYmVsQXJnMiA/IGkxOG4obGFiZWwsIGxhYmVsQXJnLCBsYWJlbEFyZzIpIDpcbiAgICAgICAgICBsYWJlbEFyZyA/IGkxOG4obGFiZWwsIGxhYmVsQXJnKSA6IGkxOG4obGFiZWwpO1xuICByZXR1cm4gaCgnb3B0aW9uJywge1xuICAgIGtleTogdmFsdWUsXG4gICAgdmFsdWUsXG4gICAgc2VsZWN0ZWQ6IHByb3AgPT09IHZhbHVlXG4gIH0sIGwpO1xufVxuXG4vLyBpbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbi8vIGltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG4vLyBmdW5jdGlvbiByZW5kZXJPcHRpb24obGFiZWwsIHZhbHVlLCBzdG9yZWRWYWx1ZSwgbGFiZWxBcmcsIGxhYmVsQXJnMikge1xuLy8gICByZXR1cm4gbSgnb3B0aW9uJywge1xuLy8gICAgIHZhbHVlOiB2YWx1ZSxcbi8vICAgICBzZWxlY3RlZDogc3RvcmVkVmFsdWUgPT09IHZhbHVlXG4vLyAgIH0sIGkxOG4obGFiZWwsIGxhYmVsQXJnLCBsYWJlbEFyZzIpKTtcbi8vIH1cblxuLy8gZXhwb3J0IGRlZmF1bHQge1xuLy8gICByZW5kZXJSYWRpbzogZnVuY3Rpb24obGFiZWwsIG5hbWUsIHZhbHVlLCBjaGVja2VkLCBvbmNoYW5nZSkge1xuLy8gICAgIHZhciBpZCA9IG5hbWUgKyAnXycgKyB2YWx1ZTtcbi8vICAgICByZXR1cm4gW1xuLy8gICAgICAgbSgnaW5wdXQucmFkaW9bdHlwZT1yYWRpb10nLCB7XG4vLyAgICAgICAgIG5hbWUsXG4vLyAgICAgICAgIGlkLFxuLy8gICAgICAgICBjbGFzc05hbWU6IHZhbHVlLFxuLy8gICAgICAgICB2YWx1ZSxcbi8vICAgICAgICAgY2hlY2tlZCxcbi8vICAgICAgICAgb25jaGFuZ2Vcbi8vICAgICAgIH0pLFxuLy8gICAgICAgbSgnbGFiZWwnLCB7XG4vLyAgICAgICAgICdmb3InOiBpZFxuLy8gICAgICAgfSwgaTE4bihsYWJlbCkpXG4vLyAgICAgXTtcbi8vICAgfSxcblxuLy8gICByZW5kZXJTZWxlY3Q6IGZ1bmN0aW9uKGxhYmVsLCBuYW1lLCBvcHRpb25zLCBzZXR0aW5nc1Byb3AsIGlzRGlzYWJsZWQsIG9uQ2hhbmdlQ2FsbGJhY2spIHtcbi8vICAgICB2YXIgc3RvcmVkVmFsdWUgPSBzZXR0aW5nc1Byb3AoKTtcbi8vICAgICByZXR1cm4gW1xuLy8gICAgICAgbSgnbGFiZWwnLCB7XG4vLyAgICAgICAgICdmb3InOiAnc2VsZWN0XycgKyBuYW1lXG4vLyAgICAgICB9LCBpMThuKGxhYmVsKSksXG4vLyAgICAgICBtKCdzZWxlY3QnLCB7XG4vLyAgICAgICAgIGlkOiAnc2VsZWN0XycgKyBuYW1lLFxuLy8gICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcbi8vICAgICAgICAgY29uZmlnOiBmdW5jdGlvbihlbCwgaXNVcGRhdGUsIGNvbnRleHQpIHtcbi8vICAgICAgICAgICBpZiAoIWlzVXBkYXRlKSB7XG4vLyAgICAgICAgICAgICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4vLyAgICAgICAgICAgICAgIHNldHRpbmdzUHJvcChlLnRhcmdldC52YWx1ZSk7XG4vLyAgICAgICAgICAgICAgIGlmIChvbkNoYW5nZUNhbGxiYWNrKSBvbkNoYW5nZUNhbGxiYWNrKGUudGFyZ2V0LnZhbHVlKTtcbi8vICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgICAgICBtLnJlZHJhdygpO1xuLy8gICAgICAgICAgICAgICB9LCAxMCk7XG4vLyAgICAgICAgICAgICB9O1xuLy8gICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbi8vICAgICAgICAgICAgIGNvbnRleHQub251bmxvYWQgPSAoKSA9PiB7XG4vLyAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4vLyAgICAgICAgICAgICB9O1xuLy8gICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgICAgfSwgb3B0aW9ucy5tYXAoZnVuY3Rpb24oZSkge1xuLy8gICAgICAgICByZXR1cm4gcmVuZGVyT3B0aW9uKGVbMF0sIGVbMV0sIHN0b3JlZFZhbHVlLCBlWzJdLCBlWzNdKTtcbi8vICAgICAgIH0pKVxuLy8gICAgIF07XG4vLyAgIH0sXG4vLyAgIHJlbmRlckNoZWNrYm94OiBmdW5jdGlvbihsYWJlbCwgbmFtZSwgc2V0dGluZ3NQcm9wLCBjYWxsYmFjaywgZGlzYWJsZWQpIHtcbi8vICAgICB2YXIgaXNPbiA9IHNldHRpbmdzUHJvcCgpO1xuLy8gICAgIHJldHVybiBtKCdkaXYuY2hlY2tfY29udGFpbmVyJywge1xuLy8gICAgICAgY2xhc3NOYW1lOiBkaXNhYmxlZCA/ICdkaXNhYmxlZCc6ICcnXG4vLyAgICAgfSwgW1xuLy8gICAgICAgbSgnbGFiZWwnLCB7XG4vLyAgICAgICAgICdmb3InOiBuYW1lXG4vLyAgICAgICB9LCBsYWJlbCksXG4vLyAgICAgICBtKCdpbnB1dFt0eXBlPWNoZWNrYm94XScsIHtcbi8vICAgICAgICAgbmFtZTogbmFtZSxcbi8vICAgICAgICAgZGlzYWJsZWQsXG4vLyAgICAgICAgIGNoZWNrZWQ6IGlzT24sXG4vLyAgICAgICAgIG9uY2hhbmdlOiBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICBjb25zdCBuZXdWYWwgPSAhaXNPbjtcbi8vICAgICAgICAgICBzZXR0aW5nc1Byb3AobmV3VmFsKTtcbi8vICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG5ld1ZhbCk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pXG4vLyAgICAgXSk7XG4vLyAgIH1cbi8vIH07XG4iLCJleHBvcnQgY29uc3QgYmFja0Fycm93ID1cbiAgPGRpdiBjbGFzc05hbWU9XCJzdmdfaWNvblwiPlxuICAgIDxkaXYgY2xhc3NOYW1lPVwic3ZnX2ljb25faW5uZXJcIj5cbiAgICAgIDxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTIwIDExSDcuODNsNS41OS01LjU5TDEyIDRsLTggOCA4IDggMS40MS0xLjQxTDcuODMgMTNIMjB2LTJ6XCI+PC9wYXRoPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIDwvZGl2PjtcblxuZXhwb3J0IGNvbnN0IGNsb3NlSWNvbiA9XG4gIDxkaXYgY2xhc3NOYW1lPVwic3ZnX2ljb25cIj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cInN2Z19pY29uX2lubmVyXCI+XG4gICAgICA8c3ZnIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgPHBhdGggZD1cIk0xOSA2LjQxTDE3LjU5IDUgMTIgMTAuNTkgNi40MSA1IDUgNi40MSAxMC41OSAxMiA1IDE3LjU5IDYuNDEgMTkgMTIgMTMuNDEgMTcuNTkgMTkgMTkgMTcuNTkgMTMuNDEgMTJ6XCIvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIDwvZGl2PjtcbiIsImltcG9ydCBoIGZyb20gJ21pdGhyaWwvaHlwZXJzY3JpcHQnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uaW5pdCgpIHtcbiAgfSxcbiAgdmlldyh7IGF0dHJzLCBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgeyBoZWFkZXIgfSA9IGF0dHJzO1xuXG4gICAgcmV0dXJuIGgoJ21haW4jcGFnZScsIHt9LCBbXG4gICAgICAvLyBoKCdoZWFkZXIubWFpbl9oZWFkZXIuYm9hcmQnLCBoZWFkZXIpLFxuICAgICAgaCgnZGl2LmNvbnRlbnRfcm91bmQnLCBjaGlsZHJlbilcbiAgICBdKTtcblxuICB9XG5cbn07XG4iLCJpbXBvcnQgeyBnYW1lSWNvbiB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihrZXksIG5hbWUsIHBlcmYsIHVzZXIpIHtcbiAgdmFyIG9wdGlvbnMgPSB7IGNsYXNzTmFtZTogJ3Byb2ZpbGVQZXJmJywgJ2RhdGEtaWNvbic6IGdhbWVJY29uKGtleSkgfTtcblxuICBpZiAodmFyaWFudFBlcmZBdmFpbGFibGUoa2V5LCBwZXJmKSkge1xuICAgIG9wdGlvbnMuY2xhc3NOYW1lICs9ICcgbmF2JztcbiAgICBvcHRpb25zLmNvbmZpZyA9IGhlbHBlci5vbnRvdWNoWShnb1RvVmFyaWFudFBlcmYodXNlciwga2V5KSk7XG4gIH1cblxuICByZXR1cm4gbSgnZGl2Jywgb3B0aW9ucywgW1xuICAgIG0oJ3NwYW4ubmFtZScsIG5hbWUpLFxuICAgIG0oJ2Rpdi5yYXRpbmcnLCBbXG4gICAgICBwZXJmLnJhdGluZyxcbiAgICAgIGhlbHBlci5wcm9ncmVzcyhwZXJmLnByb2cpLFxuICAgICAgbSgnc3Bhbi5uYicsICcvICcgKyBwZXJmLmdhbWVzKVxuICAgIF0pXG4gIF0pO1xufVxuXG5mdW5jdGlvbiBnb1RvVmFyaWFudFBlcmYodXNlciwga2V5KSB7XG4gIHJldHVybiAoKSA9PiBtLnJvdXRlKCcvQC8ke3VzZXIuaWR9LyR7a2V5fS9wZXJmJyk7XG59XG5cbmZ1bmN0aW9uIHZhcmlhbnRQZXJmQXZhaWxhYmxlKGtleSwgcGVyZikge1xuICByZXR1cm4gcGVyZi5nYW1lcyA+IDA7XG59XG4iLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG9wdXAoXG4gIGNsYXNzZXMsXG4gIGhlYWRlckYsXG4gIGNvbnRlbnRGLFxuICBpc1Nob3dpbmcsXG4gIGNsb3NlZikge1xuICBcbiAgaWYgKCFpc1Nob3dpbmcpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuICAgIG92ZXJsYXlfcG9wdXA6IHRydWUsXG4gICAgbmF0aXZlX3Njcm9sbGVyOiB0cnVlXG4gIH07XG4gIFxuICBsZXQgY2xhc3NOYW1lO1xuXG4gIGlmICh0eXBlb2YgY2xhc3NlcyA9PT0gJ29iamVjdCcpIHtcbiAgICBjbGFzc05hbWUgPSBoZWxwZXIuY2xhc3NTZXQoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENsYXNzZXMsIGNsYXNzZXMpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2xhc3NlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjbGFzc05hbWUgPSBoZWxwZXIuY2xhc3NTZXQoZGVmYXVsdENsYXNzZXMpICsgJyAnICsgY2xhc3NlcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IHBvcHVwIGFyZ3VtZW50IG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgY29uc3QgY29udGVudENsYXNzID0gaGVscGVyLmNsYXNzU2V0KHtcbiAgICAncG9wdXBfY29udGVudCc6IHRydWUsXG4gICAgJ25vaGVhZGVyJzogIWhlYWRlckZcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGtleT17U3RyaW5nKGNvbnRlbnRGKX0gY2xhc3NOYW1lPVwib3ZlcmxheV9wb3B1cF93cmFwcGVyIGZhZGUtaW5cIlxuICAgIG9uYmVmb3JlbW92ZT17KHZub2RlKSA9PiB7XG4gICAgICB2bm9kZS5kb20uY2xhc3NMaXN0LmFkZCgnZmFkaW5nX291dCcpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKTtcbiAgICAgIH0pO1xuICAgIH19PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb3B1cF9vdmVybGF5X2Nsb3NlXCJcbiAgICAgICAgb25jcmVhdGU9e2Nsb3NlZiA/IGhlbHBlci5vbnRhcChjbG9zZWYpOiB1dGlscy5ub29wIH0vPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICB7aGVhZGVyRiA/IDxoZWFkZXI+e2hlYWRlckYoKX08L2hlYWRlcj46IG51bGx9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjb250ZW50Q2xhc3N9PlxuICAgICAgICAgIHtjb250ZW50RigpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG4vLyBmdW5jdGlvbiBzdHlsZUNvbmYoZWwpIHtcbi8vICAgY29uc3QgdmggPSBoZWxwZXIudmlld3BvcnREaW0oKS52aDtcbi8vICAgY29uc3QgaCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbi8vICAgY29uc3QgdG9wID0gKHZoIC0gaCkgLyAyO1xuLy8gICAvLyBlbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuLy8gfVxuXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjbGFzc2VzLCBoZWFkZXJGLCBjb250ZW50RiwgaXNTaG93aW5nLCBjbG9zZUYpIHtcbi8vICAgaWYgKCFpc1Nob3dpbmcpIHJldHVybiBudWxsO1xuXG4vLyAgIGNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xuLy8gICAgIG92ZXJsYXlfcG9wdXA6IHRydWUsXG4vLyAgICAgbmF0aXZlX3Njcm9sbGVyOiB0cnVlXG4vLyAgIH07XG5cbi8vICAgbGV0IGNsYXNzTmFtZTtcblxuLy8gICBpZiAodHlwZW9mIGNsYXNzZXMgPT09ICdvYmplY3QnKSB7XG4vLyAgICAgY2xhc3NOYW1lID0gaGVscGVyLmNsYXNzU2V0KE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDbGFzc2VzLCBjbGFzc2VzKSk7XG4vLyAgIH0gZWxzZSBpZiAodHlwZW9mIGNsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4vLyAgICAgY2xhc3NOYW1lID0gaGVscGVyLmNsYXNzU2V0KGRlZmF1bHRDbGFzc2VzKSArICcgJyArIGNsYXNzZXM7XG4vLyAgIH0gZWxzZVxuLy8gICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcG9wdXAgYXJndW1lbnQgbXVzdCBiZSBlaXRoZXIgc3RyaW5nIG9yIGFuIG9iamVjdCcpO1xuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9XCJvdmVybGF5X3BvcHVwX3dyYXBwZXJcIj5cbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9wdXBfb3ZlcmxheV9jbG9zZVwiXG4vLyAgICAgICAgICAgIGNvbmZpZz17Y2xvc2VGID8gaGVscGVyLm9udG91Y2goaGVscGVyLmZhZGVzT3V0KGNsb3NlRiwgJy5vdmVybGF5X3BvcHVwX3dyYXBwZXInKSkgOiB1dGlscy5ub29wIH0gLz5cbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9IGNvbmZpZz17c3R5bGVDb25mfT5cbi8vICAgICAgICAge2hlYWRlckYgPyA8aGVhZGVyPntoZWFkZXJGKCl9PC9oZWFkZXI+IDogbnVsbCB9XG4vLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9wdXBfY29udGVudFwiPlxuLy8gICAgICAgICAgIHtjb250ZW50RigpfVxuLy8gICAgICAgICA8L2Rpdj5cbi8vICAgICAgIDwvZGl2PlxuLy8gICAgIDwvZGl2PlxuLy8gICApO1xuLy8gfVxuIiwiaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC90aHJvdHRsZSc7XG5pbXBvcnQgT2tleWdyb3VuZCBmcm9tICdva2V5Z3JvdW5kLW1vYmlsZSc7XG5pbXBvcnQgcm91dGVyIGZyb20gJy4uLy4uLy4uL3JvdXRlcic7XG5pbXBvcnQgc29ja2V0IGZyb20gJy4uLy4uLy4uL3NvY2tldCc7XG5pbXBvcnQgcmVkcmF3IGZyb20gJy4uLy4uLy4uL3V0aWxzL3JlZHJhdyc7XG5pbXBvcnQgZ3JvdW5kIGZyb20gJy4vZ3JvdW5kJztcbmltcG9ydCBnYW1lQXBpIGZyb20gJy4uLy4uLy4uL295dW5rZXlmL2dhbWUnO1xuaW1wb3J0IHNvY2tldEhhbmRsZXIgZnJvbSAnLi9zb2NrZXRIYW5kbGVyJztcbmltcG9ydCBDbG9ja0N0cmwgZnJvbSAnLi9jbG9jay9DbG9ja0N0cmwnO1xuaW1wb3J0ICogYXMgeGhyIGZyb20gJy4vcm91bmRYaHInO1xuaW1wb3J0ICogYXMgbWFzYVhociBmcm9tICcuLi8uLi9tYXNhL21hc2FYaHInO1xuY29uc3QgeyB1dGlsIH0gPSBPa2V5Z3JvdW5kO1xuY29uc3QgeyB3cmFwR3JvdXAsIHdyYXBQaWVjZSwgd3JhcERyb3AsIHBhcnRpYWwgfSA9IHV0aWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9ubGluZVJvdW5kKGlkLCBjZmcpIHtcbiAgY29uc3Qgc2V0RGF0YSA9IChjZmcpID0+IHtcbiAgICB0aGlzLmRhdGEgPSBjZmc7XG4gIH07XG5cbiAgY29uc3Qgb25SZXN1bWUgPSAoKSA9PiB7XG4gICAgeGhyLnJlbG9hZCh0aGlzKVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIHNvY2tldC5zZXRWZXJzaW9uKGRhdGEucGxheWVyLnZlcnNpb24pO1xuICAgICAgICB0aGlzLm9uUmVsb2FkKGRhdGEpO1xuICAgICAgfSk7XG4gIH07XG5cbiAgdGhpcy5vbk1vdmUgPSAoa2V5LCBwaWVjZSkgPT4ge1xuICAgIGlmIChrZXkgPT09IE9rZXlncm91bmQubW92ZS5kcmF3TWlkZGxlKSB7XG4gICAgICB0aGlzLnNlbmRNb3ZlKGtleSk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IE9rZXlncm91bmQubW92ZS5kaXNjYXJkKSB7XG4gICAgICB0aGlzLnZtLmhhc1BsYXllZERpc2NhcmQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgXG4gIHRoaXMub25Vc2VyTW92ZSA9IChrZXksIG1vdmUpID0+IHtcbiAgICAvLyBUT0RPOiB3aHk/XG4gICAgaWYgKGtleSA9PT0gT2tleWdyb3VuZC5tb3ZlLmxlYXZlVGFrZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZW5kTW92ZShrZXksIG1vdmUpO1xuICB9O1xuXG4gIHRoaXMuc2VuZE1vdmUgPSAoa2V5LCBhcmdzID0ge30pID0+IHtcbiAgICB2YXIgbW92ZSA9IGFyZ3M7XG4gICAgYXJncy5rZXkgPSBrZXk7XG5cbiAgICBzb2NrZXQuc2VuZCgnbW92ZScsIG1vdmUsIHtcbiAgICAgIGFja2FibGU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICB0aGlzLmFwaU1vdmUgPSAobykgPT4ge1xuICAgIHZhciBkID0gdGhpcy5kYXRhLFxuICAgICAgICBwbGF5aW5nID0gZ2FtZUFwaS5pc1BsYXllclBsYXlpbmcoZCk7XG5cbiAgICBkLmdhbWUudHVybnMgPSBvLnBseTtcbiAgICBkLmdhbWUucGxheWVyID0gZ2FtZUFwaS5zaWRlQnlQbHkoby5wbHkpO1xuICAgIGQucG9zc2libGVNb3ZlcyA9IGQucGxheWVyLnNpZGUgPT09IGQuZ2FtZS5wbGF5ZXIgPyBvLmRlc3RzIDogW107XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIGlmIChvLmlzTW92ZSkge1xuICAgICAgICBpZiAoby5kcmF3bWlkZGxlKSB7XG4gICAgICAgICAgdGhpcy5va2V5Z3JvdW5kLmFwaU1vdmUoby5rZXksIHdyYXBQaWVjZShvLmRyYXdtaWRkbGUucGllY2UpKTtcbiAgICAgICAgfSBlbHNlIGlmIChvLmRpc2NhcmQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMudm0uaGFzUGxheWVkRGlzY2FyZCkge1xuICAgICAgICAgICAgdGhpcy5va2V5Z3JvdW5kLmFwaU1vdmUoby5rZXksIHdyYXBQaWVjZShvLmRpc2NhcmQucGllY2UpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudm0uaGFzUGxheWVkRGlzY2FyZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG8ub3BlbnMpIHtcbiAgICAgICAgICB0aGlzLm9rZXlncm91bmQuYXBpTW92ZShvLmtleSwgd3JhcEdyb3VwKG8ub3BlbnMuZ3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChvLmRyb3ApIHtcbiAgICAgICAgICB0aGlzLm9rZXlncm91bmQuYXBpTW92ZShvLmtleSwgd3JhcERyb3Aoby5kcm9wLnBpZWNlLCBvLmRyb3AucG9zKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoby5rZXkgPT09IE9rZXlncm91bmQubW92ZS5jb2xsZWN0T3Blbikge1xuICAgICAgICAgIHRoaXMucmVzdG9yZUZlbihvLmZlbiwgT2tleWdyb3VuZC5tb3ZlLmNvbGxlY3RPcGVuKTtcbiAgICAgICAgfSBlbHNlIGlmIChvLmtleSA9PT0gT2tleWdyb3VuZC5tb3ZlLmxlYXZlVGFrZW4pIHtcbiAgICAgICAgICB0aGlzLm9rZXlncm91bmQuYXBpTW92ZShvLmtleSwgd3JhcFBpZWNlKG8ubGVhdmV0YWtlbi5waWVjZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub2tleWdyb3VuZC5hcGlNb3ZlKG8ua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLm9rZXlncm91bmQuc2V0KHtcbiAgICAgICAgdHVyblNpZGU6IGQuZ2FtZS5wbGF5ZXIsXG4gICAgICAgIG1vdmFibGU6IHtcbiAgICAgICAgICBkZXN0czogcGxheWluZyA/IGQucG9zc2libGVNb3ZlcyA6IFtdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvLmNsb2NrKSB7XG4gICAgICB2YXIgYyA9IG8uY2xvY2s7XG4gICAgICBpZiAodGhpcy5jbG9jaykgdGhpcy5jbG9jay5zZXRDbG9jayhkLCBvLmNsb2NrLmVhc3QsIG8uY2xvY2sud2VzdCwgby5jbG9jay5zb3V0aCwgby5jbG9jay5ub3J0aCk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgb25SZXN1bWUpO1xuXG4gICAgcmVkcmF3KCk7XG4gIH07XG5cbiAgdGhpcy5vdXRvZnRpbWUgPSB0aHJvdHRsZSgoKSA9PiB7XG4gICAgc29ja2V0LnNlbmQoJ291dG9mdGltZScsIHRoaXMuZGF0YS5nYW1lLnBsYXllcik7XG4gIH0sIDUwMCk7XG5cbiAgdGhpcy5lbmRXaXRoRGF0YSA9IChzY29yZXMpID0+IHtcbiAgICB4aHIucmVsb2FkKHRoaXMpLnRoZW4odGhpcy5vblJlbG9hZCk7XG4gIH07XG5cbiAgdGhpcy5vblJlbG9hZCA9IChyQ2ZnKSA9PiB7XG4gICAgc2V0RGF0YShyQ2ZnKTtcblxuICAgIGlmICghZ2FtZUFwaS5wbGF5YWJsZSh0aGlzLmRhdGEpKSB7XG4gICAgICB0aGlzLnNob3dBY3Rpb25zKCk7XG4gICAgfVxuICAgIHJlZHJhdygpO1xuICB9O1xuXG4gIHRoaXMuc2hvd0FjdGlvbnMgPSAoKSA9PiB7XG4gICAgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaCh0aGlzLmhpZGVBY3Rpb25zKTtcbiAgICB0aGlzLnZtLnNob3dpbmdBY3Rpb25zID0gdHJ1ZTtcbiAgfTtcblxuICB0aGlzLmhpZGVBY3Rpb25zID0gKGZyb21CQikgPT4ge1xuICAgIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiB0aGlzLnZtLnNob3dpbmdBY3Rpb25zKSByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgICB0aGlzLnZtLnNob3dpbmdBY3Rpb25zID0gZmFsc2U7XG4gIH07XG4gIFxuICB0aGlzLmlkID0gaWQ7XG4gIHNldERhdGEoY2ZnKTtcblxuICB0aGlzLnZtID0ge1xuICAgIHNjb3Jlc2hlZXRJbmZvOiB7fVxuICB9O1xuICBcbiAgdGhpcy5va2V5Z3JvdW5kID0gZ3JvdW5kLm1ha2UoXG4gICAgdGhpcy5kYXRhLFxuICAgIHRoaXMub25Vc2VyTW92ZSxcbiAgICB0aGlzLm9uTW92ZVxuICApO1xuXG4gIHRoaXMuY2xvY2sgPSB0aGlzLmRhdGEuY2xvY2sgPyBuZXcgQ2xvY2tDdHJsKHRoaXMuZGF0YSwge1xuICAgIG9uRmxhZzogdGhpcy5vdXRvZnRpbWVcbiAgfSkgOiBudWxsO1xuXG4gIGlmICh0aGlzLmNsb2NrKSB7XG4gICAgY29uc3QgdGlja05vdyA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xvY2sgJiYgdGhpcy5jbG9jay50aWNrKCk7XG4gICAgICBpZiAoZ2FtZUFwaS5wbGF5YWJsZSh0aGlzLmRhdGEpKSB0aGlzLmNsb2NrVGltZW91dElkID0gc2V0VGltZW91dCh0aWNrTm93LCAxMDApO1xuICAgIH07XG4gICAgdGhpcy5jbG9ja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGlja05vdywgMTAwKTtcbiAgfVxuXG4gIHNvY2tldC5jcmVhdGVHYW1lKFxuICAgIHRoaXMuZGF0YS51cmwuc29ja2V0LFxuICAgIHRoaXMuZGF0YS5wbGF5ZXIudmVyc2lvbixcbiAgICBzb2NrZXRIYW5kbGVyKHRoaXMpLFxuICAgIHRoaXMuZGF0YS51cmwucm91bmQpO1xuXG4gIHRoaXMudW5sb2FkID0gKCkgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb2NrVGltZW91dElkKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXN1bWUnLCBvblJlc3VtZSk7XG4gIH07XG5cbiAgdGhpcy5yZXNpZ24gPSAoKSA9PiB7XG4gICAgbWFzYVhoci53aXRoZHJhdyh0aGlzLmRhdGEuZ2FtZS5tYXNhSWQpO1xuICB9O1xuXG4gIHRoaXMubGVhdmVUYWtlbiA9ICgpID0+IHtcbiAgICB0aGlzLnNlbmRNb3ZlKE9rZXlncm91bmQubW92ZS5sZWF2ZVRha2VuKTtcbiAgfTtcbiAgXG4gIHRoaXMub3BlblNlcmllcyA9ICgpID0+IHtcbiAgICB0aGlzLm9rZXlncm91bmQucGxheU9wZW5TZXJpZXMoKTtcbiAgfTtcblxuICB0aGlzLm9wZW5QYWlycyA9ICgpID0+IHtcbiAgICB0aGlzLm9rZXlncm91bmQucGxheU9wZW5QYWlycygpO1xuICB9O1xuICBcbiAgdGhpcy5zb3J0UGFpcnMgPSAoKSA9PiB7XG4gICAgdGhpcy5va2V5Z3JvdW5kLnNvcnRQYWlycygpO1xuICB9O1xuXG4gIHRoaXMuc29ydFNlcmllcyA9ICgpID0+IHtcbiAgICB0aGlzLm9rZXlncm91bmQuc29ydFNlcmllcygpO1xuICB9O1xuXG4gIHRoaXMubGVhdmVUYWtlbiA9ICgpID0+IHtcbiAgICB0aGlzLnNlbmRNb3ZlKE9rZXlncm91bmQubW92ZS5sZWF2ZVRha2VuKTtcbiAgfTtcblxuICB0aGlzLmNvbGxlY3RPcGVuID0gKCkgPT4ge1xuICAgIHRoaXMuc2VuZE1vdmUoT2tleWdyb3VuZC5tb3ZlLmNvbGxlY3RPcGVuKTtcbiAgfTtcblxuXG4gIHRoaXMucmVzdG9yZUZlbiA9IChmZW4sIGhpbnQpID0+IHtcbiAgICB0aGlzLm9rZXlncm91bmQuc2V0KHtcbiAgICAgIGZlbjogZmVuLFxuICAgICAgYW5pbWF0aW9uSGludDogaGludFxuICAgIH0pO1xuICB9O1xuXG4gIGlmICghZ2FtZUFwaS5wbGF5YWJsZSh0aGlzLmRhdGEpKSB7XG4gICAgdGhpcy5zaG93QWN0aW9ucygpO1xuICB9XG4gIHJlZHJhdygpO1xuXG59XG4iLCJpbXBvcnQgZ2FtZUFwaSBmcm9tICcuLi8uLi8uLi8uLi9veXVua2V5Zi9nYW1lJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2xvY2tDdHJsKGQsIG9wdHMpIHtcblxuICB0aGlzLnNldENsb2NrID0gKGQsIGVhc3QsIHdlc3QsIHNvdXRoLCBub3J0aCkgPT4ge1xuICAgIGNvbnN0IGlzQ2xvY2tSdW5uaW5nID0gZ2FtZUFwaS5wbGF5YWJsZShkKSAmJlxuICAgICAgICAgICAgKGQuZ2FtZS50dXJucyA+PSA0IHx8IChkLmNsb2NrICYmIGQuY2xvY2sucnVubmluZykpO1xuXG4gICAgdGhpcy50aW1lcyA9IHtcbiAgICAgIGVhc3Q6IGVhc3QgKiAxMDAwLFxuICAgICAgd2VzdDogd2VzdCAqIDEwMDAsXG4gICAgICBub3J0aDogbm9ydGggKiAxMDAwLFxuICAgICAgc291dGg6IHNvdXRoICogMTAwMCxcbiAgICAgIGFjdGl2ZVNpZGU6IGlzQ2xvY2tSdW5uaW5nID8gZC5nYW1lLnBsYXllciA6IHVuZGVmaW5lZCxcbiAgICAgIGxhc3RVcGRhdGU6IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgfTtcbiAgfTtcblxuXG4gIHRoaXMub3B0cyA9IG9wdHM7XG5cbiAgY29uc3QgY2RhdGEgPSBkLmNsb2NrO1xuXG4gIHRoaXMuZW1lcmdNcyA9IGNkYXRhLmVtZXJnOyAvLyAxMDAwICogTWF0aC5taW4oNjAsIE1hdGgubWF4KDEwLCBjZGF0YS5lbWVyZyAqIC4xMjUpKTtcblxuICB0aGlzLnNldENsb2NrKGQsIGNkYXRhLnNpZGVzLmVhc3QsIGNkYXRhLnNpZGVzLndlc3QsIGNkYXRhLnNpZGVzLnNvdXRoLCBjZGF0YS5zaWRlcy5ub3J0aCk7XG5cbiAgdGhpcy5lbGVtZW50cyA9IHtcbiAgICBlYXN0OiBudWxsLFxuICAgIHdlc3Q6IG51bGwsXG4gICAgc291dGg6IG51bGwsXG4gICAgbm9ydGg6IG51bGxcbiAgfTtcblxuXG5cbiAgdGhpcy50aWNrID0gKCkgPT4ge1xuICAgIGNvbnN0IHNpZGUgPSB0aGlzLnRpbWVzLmFjdGl2ZVNpZGU7XG4gICAgaWYgKCFzaWRlKSByZXR1cm47XG5cbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBtaWxsaXMgPSB0aGlzLnRpbWVzW3NpZGVdIC0gdGhpcy5lbGFwc2VkKG5vdyk7XG4gICAgaWYgKG1pbGxpcyA8PSAwKSB0aGlzLm9wdHMub25GbGFnKCk7XG4gICAgZWxzZSB0aGlzLnVwZGF0ZUVsZW1lbnQoc2lkZSwgbWlsbGlzKTtcbiAgfTtcblxuICB0aGlzLnVwZGF0ZUVsZW1lbnQgPSAoc2lkZSwgbWlsbGlzKSA9PiB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzW3NpZGVdO1xuICAgIGlmIChlbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIChtaWxsaXMgLyAzMDAwMCkgKiAxMDApKSArICclJztcbiAgICAgIGVsLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICBpZiAobWlsbGlzIDwgdGhpcy5lbWVyZ01zICogNCAqIDEwMDApIGVsLmNsYXNzTGlzdC5hZGQoJ2VtZXJnJyk7XG4gICAgICBlbHNlIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2VtZXJnJyk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZWxhcHNlZCA9IChub3cgPSBwZXJmb3JtYW5jZS5ub3coKSkgPT4gTWF0aC5tYXgoMCwgbm93IC0gdGhpcy50aW1lcy5sYXN0VXBkYXRlKTtcbiAgXG4gIHRoaXMubWlsbGlzT2YgPSAoc2lkZSkgPT4ge1xuICAgIHJldHVybiB0aGlzLnRpbWVzLmFjdGl2ZVNpZGUgPT09IHNpZGUgP1xuICAgICAgTWF0aC5tYXgoMCwgdGhpcy50aW1lc1tzaWRlXSAtIHRoaXMuZWxhcHNlZCgpKSA6IHRoaXMudGltZXNbc2lkZV07XG4gIH07XG5cbiAgdGhpcy5pc1J1bm5pbmcgPSAoKSA9PiB0aGlzLnRpbWVzLmFjdGl2ZVNpZGUgIT09IHVuZGVmaW5lZDtcblxufVxuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb25pbml0KHthdHRyc30pIHtcbiAgICBjb25zdCB7IGN0cmwsIHNpZGUgfSA9IGF0dHJzO1xuXG4gICAgdGhpcy5jbG9ja09uQ3JlYXRlID0gKHtkb219KSA9PiB7XG4gICAgICBjdHJsLmVsZW1lbnRzW3NpZGVdID0gZG9tO1xuICAgICAgY3RybC51cGRhdGVFbGVtZW50KHNpZGUsIGN0cmwubWlsbGlzT2Yoc2lkZSkpO1xuICAgIH07XG4gICAgdGhpcy5jbG9ja09uVXBkYXRlID0gKHtkb219KSA9PiB7XG4gICAgICBjdHJsLmVsZW1lbnRzW3NpZGVdID0gZG9tO1xuICAgICAgY3RybC51cGRhdGVFbGVtZW50KHNpZGUsIGN0cmwubWlsbGlzT2Yoc2lkZSkpO1xuICAgIH07XG4gIH0sXG5cbiAgdmlldyh7YXR0cnN9KSB7XG5cbiAgICByZXR1cm4gaCgnZGl2JywgeyBjbGFzc05hbWU6ICdiYXInIH0sIFtcbiAgICAgIGgoJ3NwYW4nLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2JhcjInLFxuICAgICAgICBvbmNyZWF0ZTogdGhpcy5jbG9ja09uQ3JlYXRlLFxuICAgICAgICBvbnVwZGF0ZTogdGhpcy5jbG9ja09uVXBkYXRlXG4gICAgICB9KVxuICAgIF0pO1xuICB9XG59O1xuIiwiaW1wb3J0IGdhbWVBcGkgZnJvbSAnLi4vLi4vLi4vb3l1bmtleWYvZ2FtZSc7XG5pbXBvcnQgT2tleWdyb3VuZCBmcm9tICdva2V5Z3JvdW5kLW1vYmlsZSc7XG5cbmZ1bmN0aW9uIG1ha2VDb25maWcoZGF0YSkge1xuICBjb25zdCBmZW4gPSBkYXRhLmdhbWUuZmVuO1xuXG4gIHJldHVybiB7XG4gICAgZmVuLFxuICAgIHR1cm5TaWRlOiBkYXRhLmdhbWUucGxheWVyLFxuICAgIHBvdlNpZGU6IGRhdGEucGxheWVyLnNpZGUsXG4gICAgc3BlY3RhdG9yOiBkYXRhLnBsYXllci5zcGVjdGF0b3IsXG4gICAgd2l0aFRvcmU6ICEhZGF0YS5nYW1lLnZhcmlhbnQua2V5Lm1hdGNoKC9kdXpva2V5LyksXG4gICAgbW92YWJsZToge1xuICAgICAgZnJlZTogZmFsc2UsXG4gICAgICBib2FyZDogZ2FtZUFwaS5pc1BsYXllclBsYXlpbmcoZGF0YSksXG4gICAgICBkZXN0czogZ2FtZUFwaS5pc1BsYXllclBsYXlpbmcoZGF0YSkgPyBkYXRhLnBvc3NpYmxlTW92ZXMgOiBbXVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZShkYXRhLCB1c2VyTW92ZSwgb25Nb3ZlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IG1ha2VDb25maWcoZGF0YSk7XG4gIGNvbmZpZy5tb3ZhYmxlLmV2ZW50cyA9IHtcbiAgICBhZnRlcjogdXNlck1vdmVcbiAgfTtcbiAgY29uZmlnLmV2ZW50cyA9IHtcbiAgICBtb3ZlOiBvbk1vdmVcbiAgfTtcbiAgXG4gIHJldHVybiBuZXcgT2tleWdyb3VuZChjb25maWcpO1xufVxuXG5mdW5jdGlvbiBlbmQoZ3JvdW5kKSB7XG4gIGdyb3VuZC5zdG9wKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbWFrZSxcbiAgZW5kXG59O1xuIiwiaW1wb3J0IHsgZmV0Y2hKU09OIH0gZnJvbSAnLi4vLi4vLi4vaHR0cCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWxvYWQoY3RybCkge1xuICByZXR1cm4gZmV0Y2hKU09OKGN0cmwuZGF0YS51cmwucm91bmQpO1xufVxuIiwiaW1wb3J0IHJlZHJhdyBmcm9tICcuLi8uLi8uLi91dGlscy9yZWRyYXcnO1xuaW1wb3J0IGdhbWVBcGkgZnJvbSAnLi4vLi4vLi4vb3l1bmtleWYvZ2FtZSc7XG5pbXBvcnQgZ3JvdW5kIGZyb20gJy4vZ3JvdW5kJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY3RybCkge1xuICBmdW5jdGlvbiByZWxvYWQobykge1xuICB9XG5cbiAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgY3Jvd2Qobykge1xuICAgICAgWydlYXN0JywgJ3dlc3QnLCAnbm9ydGgnLCAnc291dGgnXS5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgICAgIGdhbWVBcGkuc2V0T25HYW1lKGN0cmwuZGF0YSwgc2lkZSwgb1tzaWRlXSk7XG4gICAgICB9KTtcbiAgICAgIHJlZHJhdygpO1xuICAgIH0sXG4gICAgbW92ZShvKSB7XG4gICAgICBvLmlzTW92ZSA9IHRydWU7XG4gICAgICBjdHJsLmFwaU1vdmUobyk7XG4gICAgfSxcbiAgICBlbmQoc2NvcmVzKSB7XG4gICAgICBjdHJsLmRhdGEuZ2FtZS5zY29yZXMgPSBzY29yZXMucmVzdWx0O1xuICAgICAgZ3JvdW5kLmVuZChjdHJsLm9rZXlncm91bmQpO1xuICAgICAgY3RybC5lbmRXaXRoRGF0YShzY29yZXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gaGFuZGxlcnM7XG59XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi8uLi8uLi8uLi9pMThuJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vLi4vLi4vcm91dGVyJztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi8uLi8uLi9oZWxwZXInO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHJlc2lnbihjdHJsKSB7XG4gICAgcmV0dXJuIGgoJ2J1dHRvbicsIHtcbiAgICAgIGtleTogJ3Jlc2lnbicsXG4gICAgICBjbGFzc05hbWU6ICdyZXNpZ24nLFxuICAgICAgJ2RhdGEtaWNvbic6ICdiJyxcbiAgICAgIG9uY3JlYXRlOiBoZWxwZXIub250YXAoY3RybC5yZXNpZ24pXG4gICAgfSwgaTE4bigncmVzaWduJykpO1xuICB9LFxuICByZXR1cm5Ub01hc2EoY3RybCkge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICBjdHJsLmhpZGVBY3Rpb25zKCk7XG4gICAgICBjb25zdCB1cmwgPSBgL21hc2EvJHtjdHJsLmRhdGEuZ2FtZS5tYXNhSWR9YDtcbiAgICAgIHJvdXRlci5zZXQodXJsLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuKFxuICAgICAgICA8YnV0dG9uIGtleT1cInJldHVyblRvTWFzYVwiIG9uY3JlYXRlPXtoZWxwZXIub250YXAoaGFuZGxlcil9PlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZhIGZhLXRocm9waHlcIi8+XG4gICAgICAgICAge2kxOG4oJ2JhY2tUb01hc2EnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgKTtcbiAgfSxcbiAgb3BlblNlcmllcyhjdHJsKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gXCJvcGVuLXNlcmllc1wiO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGtleT1cIm9wZW5TZXJpZXNcIlxuICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLm9wZW5TZXJpZXMpfT57aTE4bignb3BlblNlcmllcycpfTwvYnV0dG9uPlxuICAgICk7XG4gIH0sXG4gIG9wZW5QYWlycyhjdHJsKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gXCJvcGVuLXBhaXJzXCI7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2NsYXNzTmFtZX0ga2V5PVwib3BlblBhaXJzXCJcbiAgICAgIG9uY3JlYXRlPXtoZWxwZXIub250YXAoY3RybC5vcGVuUGFpcnMpfT57aTE4bignb3BlblBhaXJzJyl9PC9idXR0b24+XG4gICAgKTtcbiAgfSxcbiAgc29ydFBhaXJzKGN0cmwpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBcInNvcnQtc2VyaWVzXCI7ICAgIFxuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGtleT1cInNvcnRTZXJpZXNcIlxuICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLnNvcnRQYWlycyl9PntpMThuKCdzb3J0UGFpcnMnKX08L2J1dHRvbj5cbiAgICApO1xuICB9LFxuICBzb3J0U2VyaWVzKGN0cmwpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBcInNvcnQtcGFpcnNcIjtcbiAgICByZXR1cm4gKFxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBrZXk9XCJzb3J0U2VyaWVzXCJcbiAgICAgIG9uY3JlYXRlPXtoZWxwZXIub250YXAoY3RybC5zb3J0U2VyaWVzKX0+e2kxOG4oJ3NvcnRTZXJpZXMnKX08L2J1dHRvbj5cbiAgICApO1xuICB9LFxuICBjb2xsZWN0T3BlbihjdHJsKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gXCJjb2xsZWN0LW9wZW5cIjtcbiAgICByZXR1cm4gKFxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBrZXk9XCJjb2xsZWN0T3BlblwiXG4gICAgICBvbmNyZWF0ZT17aGVscGVyLm9udGFwKGN0cmwuY29sbGVjdE9wZW4pfT57aTE4bignY29sbGVjdE9wZW4nKX08L2J1dHRvbj5cbiAgICApOyAgICBcbiAgfSxcbiAgbGVhdmVUYWtlbihjdHJsKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gXCJsZWF2ZS10YWtlblwiO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtjbGFzc05hbWV9IGtleT1cImxlYXZlVGFrZW5cIlxuICAgICAgb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLmxlYXZlVGFrZW4pfT57aTE4bignbGVhdmVUYWtlbicpfTwvYnV0dG9uPlxuICAgICk7ICAgIFxuICB9XG59O1xuIiwiaW1wb3J0IGggZnJvbSAnbWl0aHJpbC9oeXBlcnNjcmlwdCc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi8uLi8uLi9pMThuJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vLi4vLi4vbGF5b3V0JztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vLi4vLi4vc29ja2V0JztcbmltcG9ydCAqIGFzIGhlbHBlciBmcm9tICcuLi8uLi8uLi9oZWxwZXInO1xuaW1wb3J0ICogYXMgcGxheWVyQXBpIGZyb20gJy4uLy4uLy4uLy4uL295dW5rZXlmL3BsYXllcic7XG5pbXBvcnQgZ2FtZUFwaSBmcm9tICcuLi8uLi8uLi8uLi9veXVua2V5Zi9nYW1lJztcbmltcG9ydCBnYW1lU3RhdHVzQXBpIGZyb20gJy4uLy4uLy4uLy4uL295dW5rZXlmL3N0YXR1cyc7XG5cbmltcG9ydCBwb3B1cFdpZGdldCBmcm9tICcuLi8uLi8uLi9zaGFyZWQvcG9wdXAnO1xuaW1wb3J0IEJvYXJkIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9Cb2FyZCc7XG5pbXBvcnQgR2FtZVRpdGxlIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9HYW1lVGl0bGUnO1xuaW1wb3J0IGdhbWVCdXR0b24gZnJvbSAnLi9idXR0b24nO1xuaW1wb3J0IENsb2NrIGZyb20gJy4uL2Nsb2NrL2Nsb2NrVmlldyc7XG5pbXBvcnQgeyBtZW51QnV0dG9uLCBoZWFkZXJCdG5zLCBiYWNrQnV0dG9uIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbW1vbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZpZXcoY3RybCkge1xuXG4gIHJldHVybiBsYXlvdXQuYm9hcmQoXG4gICAgcmVuZGVySGVhZGVyKGN0cmwpLFxuICAgIHJlbmRlckNvbnRlbnQoY3RybCksXG4gICAgb3ZlcmxheShjdHJsKSk7XG5cbn1cblxuZnVuY3Rpb24gb3ZlcmxheShjdHJsKSB7XG4gIHJldHVybiBbXG4gICAgcmVuZGVyR2FtZVBvcHVwKGN0cmwpXG4gIF07XG59XG5cbmZ1bmN0aW9uIHJlbmRlckdhbWVSdW5uaW5nQWN0aW9ucyhjdHJsKSB7XG4gIGNvbnN0IGdhbWVDb250cm9scyA9IGdhbWVCdXR0b24ucmVzaWduKGN0cmwpO1xuICBcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImdhbWVfY29udHJvbHNcIj5cbiAgICAgIHtnYW1lQ29udHJvbHN9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckdhbWVFbmRlZEFjdGlvbnMoY3RybCkge1xuICBmdW5jdGlvbiB1dGlsUGxheWVyKHAsIHRhZykge1xuICAgIGNvbnN0IGZ1bGxOYW1lID0gcC51c2VyID8gcC51c2VyLnVzZXJuYW1lIDogKHAuYWkgPyBpMThuKCdhaUJvdCcsIHAuYWkpIDogJ01pc2FmaXInKTtcbiAgICBcbiAgICByZXR1cm4gKDxhIGNsYXNzTmFtZT1cInVzZXJfbGlua1wiPntmdWxsTmFtZX08L2E+KTtcbiAgfTtcbiAgZnVuY3Rpb24gcGxheWVyU2NvcmVzaGVldFRyKGN0cmwsIHsgcGxheWVyLCBzY29yZXMgfSkge1xuICAgIHZhciBteVNpZGUgPSBjdHJsLmRhdGEucGxheWVyLnNpZGU7XG5cbiAgICByZXR1cm4gKDx0ciBrZXk9e3BsYXllci5zaWRlfSBjbGFzc05hbWU9e3BsYXllci5zaWRlID09PSBteVNpZGU/ICdtZSc6Jyd9PlxuICAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9XCJ1c2VyXCI+e3V0aWxQbGF5ZXIocGxheWVyKX08L3RoPlxuICAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9XCJzY29yZVwiPntzY29yZXMudG90YWx9PC90aD5cbiAgICAgICAgICAgIDwvdHI+KTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IGdhbWVBcGkucmVzdWx0KGN0cmwuZGF0YSk7XG4gIGNvbnN0IHJlc3VsdERvbSA9IGdhbWVTdGF0dXNBcGkuYWJvcnRlZChjdHJsLmRhdGEpID8gW10gOiBbXG4gICAgaCgnc3Ryb25nJywgaTE4bihyZXN1bHQpKSwgaCgnYnInKVxuICBdO1xuXG4gIGxldCBidXR0b25zO1xuICBjb25zdCBtYXNhSWQgPSBjdHJsLmRhdGEuZ2FtZS5tYXNhSWQ7XG4gIGlmIChtYXNhSWQpIHtcbiAgICBidXR0b25zID0gW1xuICAgICAgZ2FtZUJ1dHRvbi5yZXR1cm5Ub01hc2EoY3RybClcbiAgICBdO1xuICB9XG5cbiAgdmFyIHNjb3JlcyA9IFsnZWFzdCcsJ3dlc3QnLCdub3J0aCcsJ3NvdXRoJ10ubWFwKHNpZGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBwbGF5ZXI6IGdhbWVBcGkuZ2V0UGxheWVyKGN0cmwuZGF0YSwgc2lkZSksXG4gICAgICBzY29yZXM6IGN0cmwuZGF0YS5nYW1lLnNjb3JlcyA/IGN0cmwuZGF0YS5nYW1lLnNjb3Jlc1tzaWRlXSA6IHsgc2NvcmVzOiBbXSB9ICAgICAgXG4gICAgfTtcbiAgfSk7XG5cbiAgY29uc3QgZW5kU2NvcmVzID1cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNyb3NzdGFibGVcIj5cbiAgICAgICAgICAgIDx0YWJsZT5cbiAgICAgICAgICAgICAgPHRoZWFkPjx0ci8+PC90aGVhZD5cbiAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICB7c2NvcmVzLm1hcChwbGF5ZXJTY29yZXNoZWV0VHIuYmluZChudWxsLCBjdHJsKSl9XG4gICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgIDwvZGl2PjtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZ2FtZV9jb250cm9sc1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJlbmRTY29yZXNcIj57ZW5kU2NvcmVzfTwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250cm9sIGJ1dHRvbnNcIj57YnV0dG9uc308L2Rpdj4gIFxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTdGF0dXMoY3RybCkge1xuICBjb25zdCByZXN1bHQgPSBnYW1lQXBpLnJlc3VsdChjdHJsLmRhdGEpO1xuICBjb25zdCB3aW5uZXIgPSBnYW1lQXBpLmdldFBsYXllcihjdHJsLmRhdGEsIGN0cmwuZGF0YS5nYW1lLndpbm5lcik7XG4gIGNvbnN0IHN0YXR1cyA9IGdhbWVTdGF0dXNBcGkudG9MYWJlbChjdHJsLmRhdGEuZ2FtZS5zdGF0dXMubmFtZSwgY3RybC5kYXRhLmdhbWUud2lubmVyKSArXG4gICAgICAgICAgKHdpbm5lciA/ICgnLiAnICsgJ3dpbm5lcicgKyAnLicpIDogJycpO1xuXG4gIHJldHVybiAoZ2FtZVN0YXR1c0FwaS5hYm9ydGVkKGN0cmwuZGF0YSkgPyBbXSA6IFtcbiAgICBoKCdzdHJvbmcnLCByZXN1bHQpLCBoKCdicicpXG4gIF0pLmNvbmNhdChbaCgnZW0ucmVzdWx0U3RhdHVzJywgaTE4bihzdGF0dXMpKV0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHYW1lUG9wdXAoY3RybCkge1xuICBjb25zdCBoZWFkZXIgPSAhZ2FtZUFwaS5wbGF5YWJsZShjdHJsLmRhdGEpID9cbiAgICAgICAgICAoKSA9PiByZW5kZXJTdGF0dXMoY3RybCkgOiB1bmRlZmluZWQ7XG4gIFxuICAgIHJldHVybiBwb3B1cFdpZGdldChcbiAgICAgICdwbGF5ZXJfY29udHJvbHMnLFxuICAgICAgaGVhZGVyLFxuICAgICAgKCkgPT4gZ2FtZUFwaS5wbGF5YWJsZShjdHJsLmRhdGEpID9cbiAgICAgICAgcmVuZGVyR2FtZVJ1bm5pbmdBY3Rpb25zKGN0cmwpIDpcbiAgICAgICAgcmVuZGVyR2FtZUVuZGVkQWN0aW9ucyhjdHJsKSxcbiAgICAgIGN0cmwudm0uc2hvd2luZ0FjdGlvbnMsXG4gICAgICBjdHJsLmhpZGVBY3Rpb25zXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySGVhZGVyKGN0cmwpIHtcbiAgbGV0IGNoaWxkcmVuO1xuXG4gIGNoaWxkcmVuID0gW1xuICAgIG1lbnVCdXR0b24oKSxcbiAgICByZW5kZXJUaXRsZShjdHJsKVxuICBdO1xuXG4gIGNoaWxkcmVuLnB1c2goaGVhZGVyQnRucygpKTtcblxuICByZXR1cm4gaCgnbmF2Jywge1xuICAgIGNsYXNzTmFtZTogc29ja2V0LmlzQ29ubmVjdGVkKCkgPyAnJzoncmVjb25uZWN0aW5nJ1xuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRpdGxlKGN0cmwpIHtcbiAgY29uc3QgZGF0YSA9IGN0cmwuZGF0YTtcbiAgY29uc3QgbWFzYSA9IGN0cmwuZGF0YS5tYXNhO1xuXG4gIHJldHVybiBoKEdhbWVUaXRsZSwge1xuICAgIGtleTogJ3BsYXlpbmctdGl0bGUnLFxuICAgIGRhdGE6IGN0cmwuZGF0YVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29udGVudChjdHJsKSB7XG4gIGNvbnN0IHBsYXllciA9IHJlbmRlclBsYXlUYWJsZShjdHJsLCBjdHJsLmRhdGEucGxheWVyLCAncGxheWVyJyk7XG4gIGNvbnN0IG9wcG9uZW50TGVmdCA9IHJlbmRlclBsYXlUYWJsZShjdHJsLCBjdHJsLmRhdGEub3Bwb25lbnRMZWZ0LCAnb3Bwb25lbnRMZWZ0Jyk7XG4gIGNvbnN0IG9wcG9uZW50UmlnaHQgPSByZW5kZXJQbGF5VGFibGUoY3RybCwgY3RybC5kYXRhLm9wcG9uZW50UmlnaHQsICdvcHBvbmVudFJpZ2h0Jyk7XG4gIGNvbnN0IG9wcG9uZW50VXAgPSByZW5kZXJQbGF5VGFibGUoY3RybCwgY3RybC5kYXRhLm9wcG9uZW50VXAsICdvcHBvbmVudFVwJyk7XG5cbiAgLy8gIGNvbnN0IGJvdW5kcyA9IGhlbHBlci5nZXRCb2FyZEJvdW5kcyhoZWxwZXIudmlld3BvcnREaW0oKSk7XG4gIFxuICBjb25zdCBib2FyZCA9IGgoQm9hcmQsIHtcbiAgICB2YXJpYW50OiBjdHJsLmRhdGEuZ2FtZS52YXJpYW50LmtleSxcbiAgICBva2V5Z3JvdW5kOiBjdHJsLm9rZXlncm91bmQsXG4gICAgICAvLyAgICBib3VuZHNcbiAgfSk7XG4gIFxuICByZXR1cm4gaC5mcmFnbWVudCh7fSwgW1xuICAgIHJlbmRlck1lbnVBY3Rpb25zQmFyKGN0cmwpLFxuICAgIHJlbmRlckdhbWVBY3Rpb25zQmFyUmlnaHQoY3RybCksXG4gICAgcGxheWVyLFxuICAgIG9wcG9uZW50TGVmdCxcbiAgICBvcHBvbmVudFJpZ2h0LFxuICAgIG9wcG9uZW50VXAsXG4gICAgYm9hcmQsXG4gIF0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJHYW1lQWN0aW9uc0JhclJpZ2h0KGN0cmwpIHtcbiAgY29uc3QgbXlUdXJuID0gZ2FtZUFwaS5pc1BsYXllclR1cm4oY3RybC5kYXRhKTtcblxuICBjb25zdCBjYW5PcGVuU2VyaWVzID0gY3RybC5va2V5Z3JvdW5kLmNhbk9wZW5TZXJpZXMoKTtcbiAgY29uc3QgY2FuT3BlblBhaXJzID0gY3RybC5va2V5Z3JvdW5kLmNhbk9wZW5QYWlycygpO1xuICBjb25zdCBjYW5MZWF2ZVRha2VuID0gY3RybC5va2V5Z3JvdW5kLmNhbkxlYXZlVGFrZW4oKTtcblxuICBjb25zdCBjYW5Db2xsZWN0T3BlbiA9IGN0cmwub2tleWdyb3VuZC5jYW5Db2xsZWN0T3BlbigpO1xuXG4gIFxuICByZXR1cm4gKDxzZWN0aW9uIGNsYXNzTmFtZT1cImdhbWVfYWN0aW9uc19iYXIgcmlnaHRcIj5cbiAgICAgICAgICB7KGNhbkxlYXZlVGFrZW4pID8gZ2FtZUJ1dHRvbi5sZWF2ZVRha2VuKGN0cmwpIDogbnVsbCB9XG4gICAgICAgICAgeyhjYW5PcGVuUGFpcnMpID8gZ2FtZUJ1dHRvbi5vcGVuUGFpcnMoY3RybCkgOiBnYW1lQnV0dG9uLnNvcnRQYWlycyhjdHJsKSB9XG4gICAgICAgICAgeyhjYW5PcGVuU2VyaWVzKSA/IGdhbWVCdXR0b24ub3BlblNlcmllcyhjdHJsKSA6IGdhbWVCdXR0b24uc29ydFNlcmllcyhjdHJsKSB9XG4gICAgICAgICAgeyhjYW5Db2xsZWN0T3BlbikgPyBnYW1lQnV0dG9uLmNvbGxlY3RPcGVuKGN0cmwpIDogbnVsbH1cbiAgICAgICAgICA8L3NlY3Rpb24+KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWVudUFjdGlvbnNCYXIoY3RybCkge1xuICBjb25zdCBnbUNsYXNzID0gW1xuICAgICdmYScsICdmYS1lbGxpcHNpcy12J1xuICBdLmpvaW4oJyAnKTtcbiAgXG4gIGNvbnN0IGdtQnV0dG9uID0gPGJ1dHRvbiBjbGFzc05hbWU9e2dtQ2xhc3N9IGtleT1cImdhbWVNZW51XCIgb25jcmVhdGU9e2hlbHBlci5vbnRhcChjdHJsLnNob3dBY3Rpb25zKX0vPjtcblxuICByZXR1cm4gKDxzZWN0aW9uIGNsYXNzTmFtZT1cIm1lbnVfYWN0aW9uc19iYXJcIj5cbiAgICAgICAgICB7YmFja0J1dHRvbigpfVxuICAgICAgICAgIHtnbUJ1dHRvbn1cbiAgICAgICAgICA8L3NlY3Rpb24+KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUGxheVRhYmxlKGN0cmwsIHBsYXllciwgcG9zaXRpb24pIHtcbiAgXG4gIGNvbnN0IGNsYXNzTiA9ICdwbGF5VGFibGUgJyArIHBvc2l0aW9uO1xuXG4gIHJldHVybiAoXG4gICAgICA8c2VjdGlvbiBjbGFzc05hbWU9e2NsYXNzTn0+XG4gICAgICB7cmVuZGVyQW50YWdvbmlzdEluZm8oY3RybCwgcGxheWVyLCBwb3NpdGlvbil9XG4gICAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFudGFnb25pc3RJbmZvKGN0cmwsIHBsYXllciwgcG9zaXRpb24pIHtcbiAgLy8gY29uc3QgcnVubmluZ1NpZGUgPSBjdHJsLmlzQ2xvY2tSdW5uaW5nKCkgPyBjdHJsLmRhdGEuZ2FtZS5wbGF5ZXIgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHJ1bm5pbmcgPSBjdHJsLmRhdGEuZ2FtZS5wbGF5ZXIgPT09IHBsYXllci5zaWRlO1xuICBjb25zdCB1c2VyID0gcGxheWVyLnVzZXI7XG4gIGNvbnN0IHBsYXllck5hbWUgPSBwbGF5ZXJBcGkucGxheWVyTmFtZShwbGF5ZXIpO1xuXG4gIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17J2FudGFnb25pc3RJbmZvcyd9PlxuICAgICAgICA8aDIgY2xhc3NOYW1lPXsnYW50YWdvbmlzdFVzZXInfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXsnZmEgZmEtY2lyY2xlIHN0YXR1cyAnICsgKChwbGF5ZXIuYWkgfHwgcGxheWVyLm9uR2FtZSkgPyAnb25nYW1lJyA6ICdvZmZnYW1lJyl9Lz5cbiAgICAgICAgICB7cGxheWVyTmFtZX1cbiAgICAgICAgPC9oMj5cbiAgICAgIHtydW5uaW5nID8gcmVuZGVyQ2xvY2soY3RybC5jbG9jaywgcGxheWVyLnNpZGUpOm51bGx9XG4gICAgICA8L2Rpdj5cbiAgKTtcblxufVxuXG5mdW5jdGlvbiByZW5kZXJDbG9jayhjdHJsLCBzaWRlLCBydW5uaW5nU2lkZSkge1xuICByZXR1cm4gaChDbG9jaywge1xuICAgIGN0cmwsXG4gICAgc2lkZSxcbiAgICBydW5uaW5nU2lkZVxuICB9KTtcbn1cbiIsImltcG9ydCBaYW5pbW8gZnJvbSAnemFuaW1vJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vLi4vLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi4vLi4vLi4vcm91dGVyJztcblxuaW1wb3J0IHsgQkFDS0RST1BfT1BBQ0lUWSB9IGZyb20gJy4nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaWRlTWVudUN0cmwoc2lkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Ryb3BJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk9wZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZSkge1xuICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMuc2lkZSA9IHNpZGU7XG4gIHRoaXMubWVudUlEID0gbWVudUlEO1xuICB0aGlzLmJhY2tkcm9wSUQgPSBiYWNrZHJvcElEO1xuICB0aGlzLm9uT3BlbiA9IG9uT3BlbjtcbiAgdGhpcy5vbkNsb3NlID0gb25DbG9zZTtcblxuXG4gIHRoaXMub3BlbiA9ICgpID0+IHtcbiAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgcm91dGVyLmJhY2tidXR0b24uc3RhY2sucHVzaCh0aGlzLmNsb3NlKTtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMubWVudUlEKTtcbiAgICBjb25zdCBiZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuYmFja2Ryb3BJRCk7XG4gICAgaWYgKHRoaXMub25PcGVuKSB0aGlzLm9uT3BlbigpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBaYW5pbW8oYmQsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnLCAwKSxcbiAgICAgIFphbmltbyhiZCwgJ29wYWNpdHknLCBCQUNLRFJPUF9PUEFDSVRZLCAyNTAsICdsaW5lYXInKSxcbiAgICAgIFphbmltbyhlbCwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScsIDApLFxuICAgICAgWmFuaW1vKFxuICAgICAgICBlbCxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICd0cmFuc2xhdGUzZCgwLDAsMCknLCAyNTAsICdlYXNlLW91dCdcbiAgICAgIClcbiAgICAgIFxuICAgIF0pLnRoZW4ocmVkcmF3KVxuICAgICAgLmNhdGNoKGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkpO1xuICB9O1xuXG4gIHRoaXMuY2xvc2UgPSAoZnJvbUJCKSA9PiB7XG4gICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIHRoaXMuaXNPcGVuKSByb3V0ZXIuYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbiAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tZW51SUQpO1xuICAgIGNvbnN0IGJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5iYWNrZHJvcElEKTtcbiAgICBpZiAodGhpcy5vbkNsb3NlKSB0aGlzLm9uQ2xvc2UoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgWmFuaW1vKGJkLCAnb3BhY2l0eScsIDAsIDI1MCwgJ2xpbmVhcicpLFxuICAgICAgWmFuaW1vKFxuICAgICAgICBlbCxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgIHRoaXMuY2xvc2VUcmFuc2xhdGUoKSwgMjUwLCAnZWFzZS1vdXQnKVxuICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBaYW5pbW8oZWwsICd2aXNpYmlsaXR5JywgJ2hpZGRlbicsIDApLFxuICAgICAgICBaYW5pbW8oYmQsICd2aXNpYmlsaXR5JywgJ2hpZGRlbicsIDApLFxuICAgICAgXSk7XG4gICAgfSkuY2F0Y2goY29uc29sZS5sb2cuYmluZChjb25zb2xlKSk7XG4gIH07XG5cbiAgdGhpcy50b2dnbGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKSB0aGlzLmNsb3NlKCk7XG4gICAgZWxzZSB0aGlzLm9wZW4oKTtcbiAgfTtcbiAgXG4gIHRoaXMuY2xvc2VUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuc2lkZSA9PT0gJ2xlZnQnID8gJ3RyYW5zbGF0ZTNkKC0xMDAlLDAsMCknOid0cmFuc2xhdGUzZCgxMDAlLDAsMCknO1xuICB9O1xuXG59O1xuIiwiZXhwb3J0IGNvbnN0IEJBQ0tEUk9QX09QQUNJVFkgPSAwLjc7XG4iLCJpbXBvcnQgaCBmcm9tICdtaXRocmlsL2h5cGVyc2NyaXB0JztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vc29ja2V0JztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi4vdXRpbHMvcmVkcmF3JztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uL3Nlc3Npb24nO1xuaW1wb3J0IGkxOG4gZnJvbSAnLi4vaTE4bic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHJvdXRlciBmcm9tICcuLi9yb3V0ZXInO1xuaW1wb3J0IGxvZ2luTW9kYWwgZnJvbSAnLi9sb2dpbk1vZGFsJztcbmltcG9ydCBiYWNrYnV0dG9uIGZyb20gJy4uL2JhY2tidXR0b24nO1xuaW1wb3J0IHsgY2xvc2VJY29uIH0gZnJvbSAnLi9zaGFyZWQvaWNvbnMnO1xuXG5sZXQgaXNPcGVuID0gZmFsc2U7XG5sZXQgbG9hZGluZyA9IGZhbHNlO1xuXG5sZXQgZm9ybUVycm9yID0gbnVsbDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvcGVuLFxuICBjbG9zZSxcbiAgdmlldygpIHtcbiAgICBpZiAoIWlzT3BlbikgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gaCgnZGl2Lm1vZGFsI3NpZ251cE1vZGFsJywgeyBvbmNyZWF0ZTogaGVscGVyLnNsaWRlc0luVXAgfSwgW1xuICAgICAgaCgnaGVhZGVyJywgW1xuICAgICAgICBoKCdidXR0b24ubW9kYWxfY2xvc2UnLCB7XG4gICAgICAgICAgb25jcmVhdGU6IGhlbHBlci5vbnRhcChoZWxwZXIuc2xpZGVzT3V0RG93bihjbG9zZSwgJ3NpZ251cE1vZGFsJykpXG4gICAgICAgIH0sIGNsb3NlSWNvbiksXG4gICAgICAgIGgoJ2gyJywgaTE4bignc2lnblVwJykpXG4gICAgICBdKSxcbiAgICAgIGgoJ2RpdiNzaWdudXBNb2RhbENvbnRlbnQubW9kYWxfY29udGVudCcsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBsb2FkaW5nID8gJ2xvYWRpbmcnIDogJydcbiAgICAgIH0sIHJlbmRlckZvcm0oKSlcbiAgICBdKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVuZGVyRm9ybSgpIHtcbiAgcmV0dXJuIFtcbiAgICBoKCdmb3JtLmxvZ2luJywge1xuICAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gc3VibWl0KGUudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LCBbXG4gICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgIGZvcm1FcnJvciAmJiBmb3JtRXJyb3IudXNlcm5hbWUgP1xuICAgICAgICAgIGgoJ2Rpdi5mb3JtLWVycm9yJywgZm9ybUVycm9yLnVzZXJuYW1lWzBdKSA6IG51bGwsXG4gICAgICAgIGgoJ2lucHV0I3BzZXVkb1t0eXBlPXRleHRdJywge1xuICAgICAgICAgIGNsYXNzTmFtZTogZm9ybUVycm9yICYmIGZvcm1FcnJvci51c2VybmFtZSA/ICdmb3JtLWVycm9yJzogJycsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4gICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsXG4gICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuICAgICAgICAgIHNwZWxsY2hlY2s6IGZhbHNlLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgIG9uZm9jdXM6IHNjcm9sbFRvVG9wXG4gICAgICAgIH0pLFxuICAgICAgXSksXG4gICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgIGZvcm1FcnJvciAmJiBmb3JtRXJyb3IuZW1haWwgP1xuICAgICAgICAgIGgoJ2Rpdi5mb3JtLWVycm9yJywgZm9ybUVycm9yLmVtYWlsWzBdKTogbnVsbCxcbiAgICAgICAgaCgnaW5wdXQjZW1haWxbdHlwZT1lbWFpbF0nLCB7XG4gICAgICAgICAgb25mb2N1czogc2Nyb2xsVG9Ub3AsXG4gICAgICAgICAgY2xhc3NOYW1lOiBmb3JtRXJyb3IgJiYgZm9ybUVycm9yLmVtYWlsID8gJ2Zvcm0tZXJyb3InIDogJycsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ2VtYWlsJyksXG4gICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuICAgICAgICAgIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbiAgICAgICAgICBzcGVsbGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICBoKCdkaXYuZmllbGQnLCBbXG4gICAgICAgIGZvcm1FcnJvciAmJiBmb3JtRXJyb3IucGFzc3dvcmQgP1xuICAgICAgICAgIGgoJ2Rpdi5mb3JtLWVycm9yJywgZm9ybUVycm9yLnBhc3N3b3JkWzBdKSA6IG51bGwsXG4gICAgICAgIGgoJ2lucHV0I3Bhc3N3b3JkW3R5cGU9cGFzc3dvcmRdJywge1xuICAgICAgICAgIG9uZm9jdXM6IHNjcm9sbFRvVG9wLFxuICAgICAgICAgIGNsYXNzTmFtZTogZm9ybUVycm9yICYmIGZvcm1FcnJvci5wYXNzd29yZCA/ICdmb3JtLWVycm9yJyA6ICcnLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdwYXNzd29yZCcpLFxuICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICBdKSxcbiAgICAgIGgoJ2Rpdi5zdWJtaXQnLCBbXG4gICAgICAgIGgoJ2J1dHRvbi5zdWJtaXRCdXR0b25bZGF0YS1pY29uPUZdJywgaTE4bignc2lnblVwJykpXG4gICAgICBdKVxuICAgIF0pXG4gIF07XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFRvVG9wKGUpIHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBlLnRhcmdldDtcbiAgICBlbC5zY3JvbGxJbnRvVmlldyh0cnVlKTtcbiAgfSwgMzAwKTtcbn1cblxuZnVuY3Rpb24gc3VibWl0KGZvcm0pIHtcbiAgY29uc3QgbG9naW4gPSBmb3JtWzBdLnZhbHVlLnRyaW0oKTtcbiAgY29uc3QgZW1haWwgPSBmb3JtWzFdLnZhbHVlLnRyaW0oKTtcbiAgY29uc3QgcGFzcyA9IGZvcm1bMl0udmFsdWUudHJpbSgpO1xuICBpZiAoIWxvZ2luIHx8ICFlbWFpbCB8fCAhcGFzcykgcmV0dXJuO1xuICB3aW5kb3cuS2V5Ym9hcmQuaGlkZSgpO1xuICBsb2FkaW5nID0gdHJ1ZTtcbiAgZm9ybUVycm9yID0gbnVsbDtcbiAgcmVkcmF3KCk7XG4gIHNlc3Npb24uc2lnbnVwKGxvZ2luLCBlbWFpbCwgcGFzcylcbiAgICAudGhlbihkID0+IHtcbiAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bignbG9naW5TdWNjZXNzZnVsJyksICdzaG9ydCcsICdjZW50ZXInKTtcbiAgICAgIHNvY2tldC5yZWNvbm5lY3RDdXJyZW50KCk7XG4gICAgICByZWRyYXcoKTtcbiAgICAgIGxvZ2luTW9kYWwuY2xvc2UoKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBpZiAoaXNTdWJtaXRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBmb3JtRXJyb3IgPSBlcnJvci5ib2R5LmVycm9yO1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVhockVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXNTdWJtaXRFcnJvcihlcnIpIHtcbiAgcmV0dXJuIGVyci5ib2R5LmVycm9yICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG9wZW4oKSB7XG4gIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24oY2xvc2UsICdzaWdudXBNb2RhbCcpKTtcbiAgZm9ybUVycm9yID0gbnVsbDtcbiAgaXNPcGVuID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2xvc2UoZnJvbUJCKSB7XG4gIHdpbmRvdy5LZXlib2FyZC5oaWRlKCk7XG4gIGlmIChmcm9tQkIgIT09ICdiYWNrYnV0dG9uJyAmJiBpc09wZW4pIHJvdXRlci5iYWNrYnV0dG9uLnN0YWNrLnBvcCgpO1xuICBpc09wZW4gPSBmYWxzZTtcbn1cblxuLy8gY29uc3Qgc2lnbnVwTW9kYWwgPSB7fTtcblxuLy8gdmFyIGlzT3BlbiA9IGZhbHNlO1xuXG4vLyBmdW5jdGlvbiBzdWJtaXQoZm9ybSkge1xuLy8gICB2YXIgbG9naW4gPSBmb3JtWzBdLnZhbHVlLnRyaW0oKTtcbi8vICAgdmFyIGVtYWlsID0gZm9ybVsxXS52YWx1ZS50cmltKCk7XG4vLyAgIHZhciBwYXNzID0gZm9ybVsyXS52YWx1ZS50cmltKCk7XG4vLyAgIGlmICghbG9naW4gfHwgIWVtYWlsIHx8ICFwYXNzKSByZXR1cm4gZmFsc2U7XG4vLyAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuY2xvc2UoKTtcbi8vICAgcmV0dXJuIHNlc3Npb24uc2lnbnVwKGxvZ2luLCBlbWFpbCwgcGFzcykudGhlbihmdW5jdGlvbigpIHtcbi8vICAgICBzaWdudXBNb2RhbC5jbG9zZSgpO1xuLy8gICAgIGxvZ2luTW9kYWwuY2xvc2UoKTtcbi8vICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KGkxOG4oJ2xvZ2luU3VjY2Vzc2Z1bGwnKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICB9LCBmdW5jdGlvbihlcnJvcikge1xuLy8gICAgIHZhciBkYXRhID0gZXJyb3IucmVzcG9uc2U7XG4vLyAgICAgaWYgKGRhdGEuZXJyb3IudXNlcm5hbWUpIHtcbi8vICAgICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coZGF0YS5lcnJvci51c2VybmFtZVswXSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvci5wYXNzd29yZCkge1xuLy8gICAgICAgd2luZG93LnBsdWdpbnMudG9hc3Quc2hvdyhkYXRhLmVycm9yLnBhc3N3b3JkWzBdLCAnc2hvcnQnLCAnY2VudGVyJyk7XG4vLyAgICAgfVxuLy8gICB9KTtcbi8vIH1cblxuLy8gc2lnbnVwTW9kYWwub3BlbiA9IGZ1bmN0aW9uKCkge1xuLy8gICBiYWNrYnV0dG9uLnN0YWNrLnB1c2goaGVscGVyLnNsaWRlc091dERvd24oc2lnbnVwTW9kYWwuY2xvc2UsICdzaWdudXBNb2RhbCcpKTtcbi8vICAgaXNPcGVuID0gdHJ1ZTtcbi8vIH07XG5cbi8vIHNpZ251cE1vZGFsLmNsb3NlID0gZnVuY3Rpb24oZnJvbUJCKSB7XG4vLyAgIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuY2xvc2UoKTtcbi8vICAgaWYgKGZyb21CQiAhPT0gJ2JhY2tidXR0b24nICYmIGlzT3BlbikgYmFja2J1dHRvbi5zdGFjay5wb3AoKTtcbi8vICAgaXNPcGVuID0gZmFsc2U7XG4vLyB9O1xuXG4vLyBzaWdudXBNb2RhbC52aWV3ID0gZnVuY3Rpb24oKSB7XG4vLyAgIGlmICghaXNPcGVuKSByZXR1cm4gbnVsbDtcblxuLy8gICByZXR1cm4gbSgnZGl2Lm1vZGFsI3NpZ251cE1vZGFsJywgeyBjb25maWc6IGhlbHBlci5zbGlkZXNJblVwIH0sIFtcbi8vICAgICBtKCdoZWFkZXInLCBbXG4vLyAgICAgICBtKCdidXR0b24ubW9kYWxfY2xvc2VbZGF0YS1pY29uPUxdJywge1xuLy8gICAgICAgICBjb25maWc6IGhlbHBlci5vbnRvdWNoKGhlbHBlci5zbGlkZXNPdXREb3duKHNpZ251cE1vZGFsLmNsb3NlLCAnc2lnbnVwTW9kYWwnKSlcbi8vICAgICAgIH0pLFxuLy8gICAgICAgbSgnaDInLCBpMThuKCdzaWduVXAnKSlcbi8vICAgICBdKSxcbi8vICAgICBtKCdkaXYubW9kYWxfY29udGVudCcsIFtcbi8vICAgICAgIG0oJ3Auc2lnbnVwV2FybmluZy53aXRoSWNvbltkYXRhLWljb249IV0nLCBbXG4vLyAgICAgICAgIGkxOG4oJ2NvbXB1dGVyc0FyZU5vdEFsbG93ZWRUb1BsYXknKVxuLy8gICAgICAgXSksXG4vLyAgICAgICBtKCdwLnRvc1dhcm5pbmcnLCBbXG4vLyAgICAgICAgIGkxOG4oJ2J5UmVnaXN0ZXJpbmdZb3VBZ3JlZVRvQmVCb3VuZEJ5T3VyJyksXG4vLyAgICAgICAgIG0oJ2EnLCB7XG4vLyAgICAgICAgIH0sIGkxOG4oJ3Rlcm1zT2ZTZXJ2aWNlJykpLCAnLidcbi8vICAgICAgIF0pLFxuLy8gICAgICAgbSgnZm9ybS5sb2dpbicsIHtcbi8vICAgICAgICAgb25zdWJtaXQ6IGZ1bmN0aW9uKGUpIHtcbi8vICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4vLyAgICAgICAgICAgcmV0dXJuIHN1Ym1pdChlLnRhcmdldCk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0sIFtcbi8vICAgICAgICAgbSgnaW5wdXQjcHNldWRvW3R5cGU9dGV4dF0nLCB7XG4vLyAgICAgICAgICAgcGxhY2Vob2xkZXI6IGkxOG4oJ3VzZXJuYW1lJyksXG4vLyAgICAgICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbi8vICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsXG4vLyAgICAgICAgICAgYXV0b2NvcnJlY3Q6ICdvZmYnLFxuLy8gICAgICAgICAgIHNwZWxsY2hlY2s6ICdmYWxzZScsXG4vLyAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbi8vICAgICAgICAgfSksXG4vLyAgICAgICAgIG0oJ2lucHV0I2VtYWlsW3R5cGU9ZW1haWxdJywge1xuLy8gICAgICAgICAgIHBsYWNlaG9sZGVyOiBpMThuKCdlbWFpbCcpLFxuLy8gICAgICAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4vLyAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuLy8gICAgICAgICAgIGF1dG9jb3JyZWN0OiAnb2ZmJyxcbi8vICAgICAgICAgICBzcGVsbGNoZWNrOiAnZmFsc2UnLFxuLy8gICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4vLyAgICAgICAgIH0pLFxuLy8gICAgICAgICBtKCdpbnB1dCNwYXNzd29yZFt0eXBlPXBhc3N3b3JkXScsIHtcbi8vICAgICAgICAgICBwbGFjZWhvbGRlcjogaTE4bigncGFzc3dvcmQnKSxcbi8vICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuLy8gICAgICAgICB9KSxcbi8vICAgICAgICAgbSgnYnV0dG9uLmZhdCcsIGkxOG4oJ3NpZ25VcCcpKVxuLy8gICAgICAgXSlcbi8vICAgICBdKVxuLy8gICBdKTtcbi8vIH07XG5cbi8vIGV4cG9ydCBkZWZhdWx0IHNpZ251cE1vZGFsO1xuIiwiaW1wb3J0IGkxOG4gZnJvbSAnLi4vLi4vaTE4bic7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi4vbGF5b3V0JztcbmltcG9ydCB7IGhlYWRlciB9IGZyb20gJy4uL3NoYXJlZC9jb21tb24nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG9uY3JlYXRlOiBoZWxwZXIudmlld0ZhZGVJbixcbiAgb25pbml0KHthdHRyc30pIHt9LFxuICB2aWV3KCkge1xuICAgIGNvbnN0IGJvZHkgPSA8ZGl2PntpMThuKCd1bmRlckNvbnN0cnVjdGlvbicpfTwvZGl2PjtcblxuICAgIHJldHVybiBsYXlvdXQuZnJlZShoZWFkZXIoaTE4bigndG9kbycpKSwgYm9keSwgbnVsbCwgbnVsbCk7XG4gIH0gIFxufVxuIiwiaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSAnLi91c2VyQ3RybCc7XG5pbXBvcnQgdmlldyBmcm9tICcuL3VzZXJWaWV3JztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBjb250cm9sbGVyLFxuICB2aWV3XG59O1xuIiwiaW1wb3J0IHNlc3Npb24gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQgKiBhcyB4aHIgZnJvbSAnLi91c2VyWGhyJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBzb2NrZXQgZnJvbSAnLi4vLi4vc29ja2V0JztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250cm9sbGVyKCkge1xuICBzb2NrZXQuY3JlYXRlRGVmYXVsdCgpO1xuXG4gIGNvbnN0IHVzZXIgPSBtLnByb3AoKTtcblxuICB4aHIudXNlcihtLnJvdXRlLnBhcmFtKCdpZCcpKS50aGVuKHVzZXIsIGVycm9yID0+IHtcbiAgICB1dGlscy5oYW5kbGVYaHJFcnJvcihlcnJvcik7XG4gICAgbS5yb3V0ZSgnLycpO1xuICB9KS50aGVuKHNlc3Npb24ucmVmcmVzaCk7XG5cbiAgcmV0dXJuIHtcbiAgICB1c2VyLFxuICAgIGlzTWU6ICgpID0+IHNlc3Npb24uZ2V0VXNlcklkKCkgPT09IHVzZXIoKS5pZFxuICB9O1xufVxuIiwiLy8gaW1wb3J0IHVzZXJQZXJmcyBmcm9tICcuLi8uLi9veXVua2V5Zi9wZXJmcyc7XG5pbXBvcnQgcGVyZiBmcm9tICcuLi9zaGFyZWQvcGVyZic7XG5pbXBvcnQgeyBoZWFkZXIgYXMgaGVhZGVyV2lkZ2V0LCBiYWNrQnV0dG9uIH0gZnJvbSAnLi4vc2hhcmVkL2NvbW1vbic7XG5pbXBvcnQgbGF5b3V0IGZyb20gJy4uL2xheW91dCc7XG5pbXBvcnQgaTE4biBmcm9tICcuLi8uLi9pMThuJztcbmltcG9ydCBoZWxwZXIgZnJvbSAnLi4vaGVscGVyJztcbmltcG9ydCBzZXNzaW9uIGZyb20gJy4uLy4uL3Nlc3Npb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2aWV3KGN0cmwpIHtcbiAgY29uc3QgdXNlciA9IGN0cmwudXNlcigpO1xuXG4gIGlmICghdXNlcikgcmV0dXJuIG51bGw7XG5cbiAgZnVuY3Rpb24gaGVhZGVyKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdXNlci51c2VybmFtZTtcbiAgICByZXR1cm4gaGVhZGVyV2lkZ2V0KG51bGwsIGJhY2tCdXR0b24odGl0bGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2ZpbGUoKSB7XG4gICAgLy8gVE9ET1xuICAgIC8vIHN0YXRzXG4gICAgLy8gcmF0aW5nc1xuICAgIC8vIGFjdGlvbnNcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD1cInVzZXJQcm9maWxlXCIgY2xhc3NOYW1lPVwibmF0aXZlX3Njcm9sbGVyIHBhZ2VcIj5cbiAgICAgICAge3JlbmRlclN0YXR1cyh1c2VyKX1cbiAgICAgICAge3JlbmRlclByb2ZpbGUodXNlcil9XG4gICAgICAgIHtyZW5kZXJSYXRpbmdzKHVzZXIpfVxuICAgICAgICB7cmVuZGVyQWN0aW9ucyhjdHJsKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbGF5b3V0LmZyZWUoaGVhZGVyLCBwcm9maWxlKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU3RhdHVzKHVzZXIpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlci5vbmxpbmUgPyAnb25saW5lJyA6ICdvZmZsaW5lJztcbiAgcmV0dXJuIChcbiAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJvbmxpbmVTdGF0dXNcIj5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17J3VzZXJTdGF0dXMgJyArIHN0YXR1c30gZGF0YS1pY29uPSdyJyAvPlxuICAgICAge2kxOG4oc3RhdHVzKX1cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclByb2ZpbGUodXNlcikge1xuICBpZiAoIXVzZXIucHJvZmlsZSkgcmV0dXJuIG51bGw7XG4gIFxuICBsZXQgZnVsbE5hbWUgPSAnJztcbiAgaWYgKHVzZXIucHJvZmlsZS5maXJzdE5hbWUpIGZ1bGxOYW1lICs9IHVzZXIucHJvZmlsZS5maXJzdE5hbWU7XG4gIGlmICh1c2VyLnByb2ZpbGUubGFzdE5hbWUpIGZ1bGxOYW1lICs9ICh1c2VyLnByb2ZpbGUuZmlyc3ROYW1lID8gJyAnIDonJykgKyB1c2VyLnByb2ZpbGUubGFzdE5hbWU7XG4gIC8vIGNvbnN0IGNvdW50cnkgPSBjb3VudHJpZXNbdXNlci5wcm9maWxlLmNvdW50cnldO1xuICBjb25zdCBsb2NhdGlvbiA9IHVzZXIucHJvZmlsZS5sb2NhdGlvbjtcbiAgY29uc3QgbWVtYmVyU2luY2UgPSBpMThuKCdtZW1iZXJTaW5jZScpICsgJyAnICsgd2luZG93Lm1vbWVudCh1c2VyLmNyZWF0ZWRBdCkuZm9ybWF0KCdMTCcpO1xuICBjb25zdCBzZWVuQXQgPSB1c2VyLnNlZW5BdCA/IGkxOG4oJ2xhc3RMb2dpbicpICsgJyAnICsgd2luZG93Lm1vbWVudCh1c2VyLnNlZW5BdCkuY2FsZW5kYXIoKSA6IG51bGw7XG5cbiAgcmV0dXJuIChcbiAgICA8c2VjdGlvbiBjbGFzc25hbWU9XCJwcm9maWxlXCI+XG4gICAgICB7ZnVsbE5hbWUgP1xuICAgICAgIDxoMyBjbGFzc05hbWU9XCJmdWxsbmFtZVwiPntmdWxsTmFtZX08L2gzPjogbnVsbFxuICAgICAgfVxuICAgICAge3VzZXIucHJvZmlsZS5iaW8gP1xuICAgICAgIDxwIGNsYXNzTmFtZT1cInByb2ZpbGVCaW9cIj57dXNlci5wcm9maWxlLmJpb308L3A+OiBudWxsXG4gICAgICB9XG4gICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1c2VySW5mb3NcIj5cbiAgICAgICAgIHtcbiAgICAgICAgICAgdXNlci5sYW5ndWFnZSA/XG4gICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImxhbmd1YWdlIHdpdGhJY29uXCI+XG4gICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtY29tbWVudC1vXCI+XG4gICAgICAgICAgICAgICB7Z2V0TGFuZ3VhZ2VOYXRpdmVOYW1lKHVzZXIubGFuZ3VhZ2UpfVxuICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgPC9wPiA6IG51bGxcbiAgICAgICAgIH1cbiAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibG9jYXRpb25cIj57bG9jYXRpb259PC9wPlxuICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtZW1iZXJTaW5jZVwiPnttZW1iZXJTaW5jZX08L3A+XG4gICAgICAgICAgIHtzZWVuQXQgP1xuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibGFzdFNlZW5cIj57c2VlbkF0fTwvcD46IG51bGxcbiAgICAgICAgICAgfVxuICAgICAgIDwvZGl2PlxuICAgIDwvc2VjdGlvbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUmF0aW5ncyh1c2VyKSB7XG4gIGZ1bmN0aW9uIGlzU2hvd2luZyhwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICd5dXpiaXInLCAnZHV6b2tleSdcbiAgICBdLmluZGV4T2YocC5rZXkpIT09IC0xIHx8IHAucGVyZi5nYW1lcyA+IDA7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxzZWN0aW9uIGlkPVwidXNlclByb2ZpbGVSYXRpbmdzXCIgY2xhc3NOYW1lPVwicGVyZnNcIj5cbiAgICAgIC8vIHt1c2VyUGVyZnModXNlcikuZmlsdGVyKGlzU2hvd2luZykubWFwKHAgPT4gcGVyZihwLmtleSwgcC5uYW1lLCBwLnBlcmYsIHVzZXIpKX1cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFjdGlvbnMoY3RybCkge1xuICBjb25zdCB1c2VyID0gY3RybC51c2VyKCk7XG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gaWQ9XCJ1c2VyUHJvZmlsZUFjdGlvbnNcIiBjbGFzcz1cIm5vUGFkZGluZ1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJsaXN0X2l0ZW1fbmF2XCJcbiAgICAgICAgICAgY29uZmlnPXtoZWxwZXIub250b3VjaFkoY3RybC5nb1RvR2FtZXMpfVxuICAgICAgICAgICBrZXk9XCJ2aWV3X2FsbF9nYW1lc1wiPlxuICAgICAgICB7aTE4bigndmlld0FsbE5iR2FtZXMnLCB1c2VyLmNvdW50LmFsbCl9XG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG4iLCJpbXBvcnQgeyByZXF1ZXN0IH0gZnJvbSAnLi4vLi4vaHR0cCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VyKGlkKSB7XG4gIHZhciB1cmwgPSAnL2FwaS91c2VyLycgKyBpZDtcbiAgcmV0dXJuIHJlcXVlc3QodXJsLCB7fSwgdHJ1ZSk7XG59XG4iLCJsZXQgZm9yZWdyb3VuZCA9IHRydWU7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZvcmVncm91bmQoKSB7XG4gIHJldHVybiBmb3JlZ3JvdW5kO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Rm9yZWdyb3VuZCgpIHtcbiAgZm9yZWdyb3VuZCA9IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRCYWNrZ3JvdW5kKCkge1xuICBmb3JlZ3JvdW5kID0gZmFsc2U7XG59XG4iLCJsZXQgY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGJhdGNoaW5nID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXRjaFJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICBjYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgaWYgKCFiYXRjaGluZykge1xuICAgIGJhdGNoaW5nID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRzKSA9PiB7XG4gICAgICBjb25zdCBiYXRjaCA9IGNhbGxiYWNrcztcbiAgICAgIGJhdGNoaW5nID0gZmFsc2U7XG4gICAgICBjYWxsYmFja3MgPSBuZXcgU2V0KCk7XG4gICAgICBiYXRjaC5mb3JFYWNoKGYgPT4gZih0cykpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgaTE4biBmcm9tICcuLi9pMThuJztcbmltcG9ydCByZWRyYXcgZnJvbSAnLi9yZWRyYXcnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXV0b3JlZHJhdyhhY3Rpb24pIHtcbiAgY29uc3QgcmVzID0gYWN0aW9uKCk7XG4gIHJlZHJhdygpO1xuICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVYaHJFcnJvcihlcnJvcikge1xuICBjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXM7XG4gIGNvbnN0IGRhdGEgPSBlcnJvci5ib2R5O1xuICBsZXQgbWVzc2FnZTtcblxuICBpZiAoIXN0YXR1cyB8fCBzdGF0dXMgPT09IDApIHtcbiAgICBtZXNzYWdlID0gJ295dW5rZXlmSXNVbnJlYWNoYWJsZSc7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDEpIHtcbiAgICBtZXNzYWdlID0gJ3VuYXV0aG9yaXplZEVycm9yJztcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgIG1lc3NhZ2UgPSAncmVzb3VyY2VOb3RGb3VuZEVycm9yJztcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDUwMykge1xuICAgIG1lc3NhZ2UgPSAnb3l1bmtleWZJc1VuYXZhaWxhYmxlRXJyb3InO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgPSAnRXJyb3IuJztcbiAgfVxuXG4gIG1lc3NhZ2UgPSBpMThuKG1lc3NhZ2UpO1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlICs9IGAgJHtkYXRhfWA7XG4gfVxuICBlbHNlIGlmICh0eXBlb2YgZGF0YS5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlICs9IGAgJHtpMThuKGRhdGEuZ2xvYmFsWzBdKX1gO1xuICB9XG4gIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3cobWVzc2FnZSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZExvY2FsSnNvbkZpbGUodXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGlmICgoeGhyLnN0YXR1cyA9PT0gMCB8fCB4aHIuc3RhdHVzID09PSAyMDApICYmIHhoci5yZXNwb25zZVRleHQgIT09ICcnKSB7XG4gICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoeGhyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gIH0pO1xufVxuXG5sZXQgc3JpO1xuXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudFNyaSgpIHtcbiAgcmV0dXJuIHNyaSB8fCBuZXdTcmkoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld1NyaSgpIHtcbiAgc3JpID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpLnNsaWNlKDAsIDEwKTtcbiAgcmV0dXJuIHNyaTtcbn1cblxuZXhwb3J0IGNvbnN0IG95dW5rZXlmU3JpID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVsbFdvcmtlcih3b3JrZXIsIHRvcGljLCBwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0b3BpYywgcGF5bG9hZCB9KTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0b3BpYyB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNrV29ya2VyKHdvcmtlciwgbXNnLCBjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgIGZ1bmN0aW9uIGxpc3RlbihlKSB7XG4gICAgICBpZiAoZS5kYXRhLnRvcGljID09PSBtc2cudG9waWMpIHtcbiAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW4pO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhlLmRhdGEucGF5bG9hZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShlLmRhdGEucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW4pO1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9KTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaGFzTmV0d29yaygpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IuY29ubmVjdGlvbi50eXBlICE9PSBDb25uZWN0aW9uLk5PTkU7XG59XG5cblxuXG4vLyBleHBvcnQgZnVuY3Rpb24gaGFuZGxlWGhyRXJyb3IoZXJyb3IpIHtcbi8vICAgdmFyIHtyZXNwb25zZTogZGF0YSwgc3RhdHVzfSA9IGVycm9yO1xuLy8gICBpZiAoIWhhc05ldHdvcmsoKSkge1xuLy8gICAgIHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3coaTE4bignbm9JbnRlcm5ldENvbm5lY3Rpb24nKSwgJ3Nob3J0JywgJ2NlbnRlcicpO1xuLy8gICB9IGVsc2Uge1xuLy8gICAgIGxldCBtZXNzYWdlO1xuLy8gICAgIGlmICghc3RhdHVzIHx8IHN0YXR1cyA9PT0gMCkge1xuLy8gICAgICAgbWVzc2FnZSA9ICdveXVua2V5ZklzVW5yZWFjaGFibGUnO1xuLy8gICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDEpIHtcbi8vICAgICAgIG1lc3NhZ2UgPSAndW5hdXRob3JpemVkRXJyb3InO1xuLy8gICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbi8vICAgICAgIG1lc3NhZ2UgPSAncmVzb3VyY2VOb3RGb3VuZEVycm9yJztcbi8vICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNTAzKSB7XG4vLyAgICAgICBtZXNzYWdlID0gJ295dW5rZXlmSXNVbmF2YWlsYWJsZUVycm9yJztcbi8vICAgICB9IGVsc2UgaWYgKHN0YXR1cyA+PSA1MDApIHtcbi8vICAgICAgIG1lc3NhZ2UgPSAnc2VydmVyRXJyb3InO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICBtZXNzYWdlID0gJ0Vycm9yLic7XG4vLyAgICAgfVxuXG4vLyAgICAgbWVzc2FnZSA9IGkxOG4obWVzc2FnZSk7XG5cbi8vICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4vLyAgICAgICBtZXNzYWdlICs9IGAgJHtkYXRhfWA7XG4vLyAgICAgfSBlbHNlIGlmIChkYXRhLmdsb2JhbCAmJiBkYXRhLmdsb2JhbC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbi8vICAgICAgIG1lc3NhZ2UgKz0gYCAke2RhdGEuZ2xvYmFsWzBdfWA7XG4vLyAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YS5lcnJvciA9PT0gJ3N0cmluZycpIHtcbi8vICAgICAgIG1lc3NhZ2UgKz0gYCAke2RhdGEuZXJyb3J9YDtcbi8vICAgICB9XG5cbi8vICAgICB3aW5kb3cucGx1Z2lucy50b2FzdC5zaG93KG1lc3NhZ2UsICdzaG9ydCcsICdjZW50ZXInKTtcbi8vICAgfVxuLy8gfVxuXG5mdW5jdGlvbiBwYXJ0aWFsQXBwbHkoZm4sIGFyZ3MpIHtcbiAgcmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIFtudWxsXS5jb25jYXQoYXJncykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbGYoKSB7XG4gIHJldHVybiBwYXJ0aWFsQXBwbHkoYXJndW1lbnRzWzBdLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGYoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgZm4gPSBhcmd1bWVudHNbMF07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmbi5hcHBseShmbiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGxheWVyTmFtZShwbGF5ZXIsIHdpdGhSYXRpbmcpIHtcbiAgaWYgKHBsYXllci51c2VybmFtZSB8fCBwbGF5ZXIudXNlcikge1xuICAgIHZhciBuYW1lID0gcGxheWVyLnVzZXJuYW1lIHx8IHBsYXllci51c2VyLnVzZXJuYW1lO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGlmIChwbGF5ZXIuYWkpIHtcbiAgICByZXR1cm4gYWlOYW1lKHBsYXllci5haSk7XG4gIH1cblxuICBpZiAocGxheWVyLnNpZGUpIHtcbiAgICByZXR1cm4gaTE4bihwbGF5ZXIuc2lkZSk7XG4gIH1cblxuICByZXR1cm4gaTE4bignYW5vbnltb3VzJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhaU5hbWUobGV2ZWwpIHtcbiAgcmV0dXJuIGkxOG4oJ2FpQm90JywgbGV2ZWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFja0hpc3RvcnkoKSB7XG4gIHNldFZpZXdTbGlkZURpcmVjdGlvbignYndkJyk7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLmFwcCAmJiB3aW5kb3cubmF2aWdhdG9yLmFwcC5iYWNrSGlzdG9yeSkge1xuICAgIHdpbmRvdy5uYXZpZ2F0b3IuYXBwLmJhY2tIaXN0b3J5KCk7XG4gIH1cbiAgZWxzZVxuICAgIHdpbmRvdy5oaXN0b3J5LmdvKC0xKTtcbn1cblxuLy8gc2ltcGxlIHdheSB0byBkZXRlcm1pbmUgdmlld3MgYW5pbWF0aW9uIGRpcmVjdGlvblxudmFyIHZpZXdTbGlkZURpcmVjdGlvbiA9ICdmd2QnO1xuZXhwb3J0IGZ1bmN0aW9uIHNldFZpZXdTbGlkZURpcmVjdGlvbihkKSB7XG4gIHZpZXdTbGlkZURpcmVjdGlvbiA9IGQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Vmlld1NsaWRlRGlyZWN0aW9uKCkge1xuICByZXR1cm4gdmlld1NsaWRlRGlyZWN0aW9uO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb2FyZEJvdW5kcyh2aWV3cG9ydERpbSwgaXNQb3J0cmFpdCwgaXNJcGFkTGlrZSwgbW9kZSkge1xuICBjb25zdCB7IHZoLCB2dyB9ID0gdmlld3BvcnREaW07XG4gIGNvbnN0IHRvcCA9IDUwO1xuXG4gIGlmIChpc1BvcnRyYWl0KSB7XG4gICAgLy8gY29uc3QgY29udGVudEhlaWdodCA9IHZoIC0gNTA7XG4gICAgLy8gY29uc3QgcFRvcCA9IDUwICsgKG1vZGUgPT09ICdnYW1lJyA/ICgoY29udGVudEhlaWdodCAtIHZ3IC0gNDApIC8gMikgOiAwKTtcbiAgICBjb25zdCBjb250ZW50SGVpZ2h0ID0gdmg7XG4gICAgY29uc3QgcFRvcCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcFRvcCxcbiAgICAgIHJpZ2h0OiB2dyxcbiAgICAgIGJvdHRvbTogcFRvcCArIHZ3LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiB2dyxcbiAgICAgIGhlaWdodDogdndcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGNvbnN0IGxTaWRlID0gdmggLSB0b3A7XG4gICAgY29uc3QgbFNpZGUgPSB2aCAtIDU7XG4gICAgY29uc3QgbFdpZHRoID0gdncgLSA1OyAvLyBsU2lkZSAqICg0LzMpO1xuICAgIGNvbnN0IHNwYWNlQ2VudGVyID0gdncgLSBsV2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0OiBsU2lkZSxcbiAgICAgIGJvdHRvbTogdG9wICsgbFNpZGUsXG4gICAgICBsZWZ0OiBzcGFjZUNlbnRlciAvIDIsXG4gICAgICB3aWR0aDogbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBsU2lkZVxuICAgIH07XG4gIH1cbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGF1dG9yZWRyYXcoYWN0aW9uKSB7XG4vLyAgIG0uc3RhcnRDb21wdXRhdGlvbigpO1xuLy8gICB0cnkge1xuLy8gICAgIHJldHVybiBhY3Rpb24oKTtcbi8vICAgfSBmaW5hbGx5IHtcbi8vICAgICBtLmVuZENvbXB1dGF0aW9uKCk7XG4vLyAgIH1cbi8vIH1cblxuY29uc3QgcGVyZkljb25zTWFwID0ge1xuICB5dXpiaXI6ICdUJyxcbiAgZHV6b2tleTogJysnXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2FtZUljb24ocGVyZikge1xuICByZXR1cm4gcGVyZkljb25zTWFwW3BlcmZdIHx8ICc4Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE1hc2FEdXJhdGlvbihyb3VuZHMsIHNjb3Jlcykge1xuICByZXR1cm4gcm91bmRzID8gcm91bmRzICsgaTE4bignaGFuZHMnKSA6IHNjb3JlcyArIGkxOG4oJ3Njb3JlcycpWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkKG51bSwgc2l6ZSkge1xuICB2YXIgcyA9IG51bSArICcnO1xuICB3aGlsZSAocy5sZW5ndGggPCBzaXplKSBzID0gJzAnICsgcztcbiAgcmV0dXJuIHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FmZVN0cmluZ1RvTnVtKHMpIHtcbiAgY29uc3QgbiA9IE51bWJlcihzKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdW5kZWZpbmVkIDogbjtcbn1cbiIsIi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0dvemFsYS9xdWVyeXN0cmluZ1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlQcmltaXRpdmUgKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICBjYXNlICdzdHJpbmcnOlxuICAgIHJldHVybiB2O1xuXG4gIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICBjYXNlICdudW1iZXInOlxuICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICBkZWZhdWx0OlxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgbGV0IGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufVxuIiwiaW1wb3J0IHNpZ25hbHMgZnJvbSAnLi4vc2lnbmFscyc7XG5pbXBvcnQgeyBiYXRjaFJlcXVlc3RBbmltYXRpb25GcmFtZSB9IGZyb20gJy4vYmF0Y2hSQUYnO1xuXG5leHBvcnQgY29uc3QgcmVkcmF3U3luYyA9IHNpZ25hbHMucmVkcmF3LmRpc3BhdGNoO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWRyYXcoKSB7XG4gIC8vIGNvbnNvbGUudHJhY2UoKTtcbiAgYmF0Y2hSZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVkcmF3U3luYyk7XG59XG4iLCJjb25zdCBJRExFX1RJTUVSX0RFTEFZID0gMTUgKiA2MCAqIDEwMDBcbmNvbnN0IFNMRUVQX0RFTEFZID0gNjAgKiA2MCAqIDEwMDBcblxubGV0IHNsZWVwQWdhaW5UaW1lb3V0SWRcbmxldCBjYW5jZWxUaW1lclxuXG5leHBvcnQgZnVuY3Rpb24ga2VlcEF3YWtlKCkge1xuICB3aW5kb3cucGx1Z2lucy5pbnNvbW5pYS5rZWVwQXdha2UoKVxuICBpZiAoY2FuY2VsVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNhbmNlbFRpbWVyKClcbiAgfVxuICBjYW5jZWxUaW1lciA9IGlkbGVUaW1lcihcbiAgICBJRExFX1RJTUVSX0RFTEFZLFxuICAgICgpID0+IHtcbiAgICAgIHNsZWVwQWdhaW5UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgd2luZG93LnBsdWdpbnMuaW5zb21uaWEuYWxsb3dTbGVlcEFnYWluKClcbiAgICAgIH0sIFNMRUVQX0RFTEFZKVxuICAgIH0sXG4gICAgKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNsZWVwQWdhaW5UaW1lb3V0SWQpXG4gICAgfVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxvd1NsZWVwQWdhaW4oKSB7XG4gIGlmIChjYW5jZWxUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2FuY2VsVGltZXIoKVxuICAgIGNhbmNlbFRpbWVyID0gdW5kZWZpbmVkXG4gIH1cbiAgd2luZG93LnBsdWdpbnMuaW5zb21uaWEuYWxsb3dTbGVlcEFnYWluKClcbn1cblxuZnVuY3Rpb24gaWRsZVRpbWVyKGRlbGF5LCBvbklkbGUsIG9uV2FrZVVwKSB7XG4gIGNvbnN0IGV2ZW50cyA9IFsndG91Y2hzdGFydCddXG4gIGxldCBsaXN0ZW5pbmcgPSBmYWxzZVxuICBsZXQgYWN0aXZlID0gdHJ1ZVxuICBsZXQgbGFzdFNlZW5BY3RpdmUgPSBEYXRlLm5vdygpXG4gIGxldCBpbnRlcnZhbElEXG4gIGNvbnN0IG9uQWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdXYWtlIHVwJylcbiAgICAgIG9uV2FrZVVwKClcbiAgICB9XG4gICAgYWN0aXZlID0gdHJ1ZVxuICAgIGxhc3RTZWVuQWN0aXZlID0gRGF0ZS5ub3coKVxuICAgIHN0b3BMaXN0ZW5pbmcoKVxuICB9XG4gIGNvbnN0IHN0YXJ0TGlzdGVuaW5nID0gKCkgPT4ge1xuICAgIGlmICghbGlzdGVuaW5nKSB7XG4gICAgICBldmVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGUsIG9uQWN0aXZpdHkpXG4gICAgICB9KVxuICAgICAgbGlzdGVuaW5nID0gdHJ1ZVxuICAgIH1cbiAgfVxuICBjb25zdCBzdG9wTGlzdGVuaW5nID0gKCkgPT4ge1xuICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgb25BY3Rpdml0eSlcbiAgICAgIH0pXG4gICAgICBsaXN0ZW5pbmcgPSBmYWxzZVxuICAgIH1cbiAgfVxuICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElEKVxuICAgIHN0b3BMaXN0ZW5pbmcoKVxuICB9XG4gIGludGVydmFsSUQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZSAmJiBEYXRlLm5vdygpIC0gbGFzdFNlZW5BY3RpdmUgPiBkZWxheSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ0lkbGUgbW9kZScpXG4gICAgICBvbklkbGUoKVxuICAgICAgYWN0aXZlID0gZmFsc2VcbiAgICB9XG4gICAgc3RhcnRMaXN0ZW5pbmcoKVxuICB9LCAzMCAqIDEwMDApXG5cbiAgcmV0dXJuIGNhbmNlbFxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHRlbGxXb3JrZXIod29ya2VyLCB0b3BpYywgcGF5bG9hZCkge1xuICBpZiAocGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdG9waWMsIHBheWxvYWQgfSk7XG4gIH0gZWxzZSB7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdG9waWMgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFza1dvcmtlcih3b3JrZXIsIG1zZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZ1bmN0aW9uIGxpc3RlbihlKSB7XG4gICAgICBpZiAoZS5kYXRhLnRvcGljID09PSBtc2cudG9waWMgJiYgKG1zZy5yZXFpZCA9PT0gdW5kZWZpbmVkIHx8IGUuZGF0YS5yZXFpZCA9PT0gbXNnLnJlcWlkKSkge1xuICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3Rlbik7XG4gICAgICAgIHJlc29sdmUoZS5kYXRhLnBheWxvYWQpO1xuICAgICAgfSBlbHNlIGlmIChlLmRhdGEudG9waWMgPT09ICdlcnJvcicgJiYgZS5kYXRhLnBheWxvYWQuY2FsbGVyVG9waWMgPT09IG1zZy50b3BpYyAmJiAoXG4gICAgICAgIG1zZy5yZXFpZCA9PT0gdW5kZWZpbmVkIHx8IGUuZGF0YS5yZXFpZCA9PT0gbXNnLnJlcWlkKSkge1xuICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3Rlbik7XG4gICAgICAgIHJlamVjdChlLmRhdGEucGF5bG9hZC5lcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuKTtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBmZXRjaEpTT04gfSBmcm9tICcuL2h0dHAnO1xuaW1wb3J0IHsgY3VycmVudFNyaSwgbm9vcCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHNlc3Npb24gZnJvbSAnLi9zZXNzaW9uJztcblxuLy8gZXhwb3J0IGxldCBjYWNoZWRQb29scyA9IFtdO1xuXG4vLyBleHBvcnQgZnVuY3Rpb24gbmV3R2FtZSgpIHtcbi8vICAgY29uc3QgY29uZmlnID0gc2V0dGluZ3MuZ2FtZVNldHVwLmh1bWFuO1xuXG4vLyAgIGNvbnN0IGRhdGEgPSB7XG4vLyAgICAgdmFyaWFudDogY29uZmlnLnZhcmlhbnQoKSxcbi8vICAgICByb3VuZHM6IGNvbmZpZy5yb3VuZHMoKSxcbi8vICAgICBtb2RlOiBzZXNzaW9uLmlzQ29ubmVjdGVkKCkgPyBjb25maWcubW9kZSgpIDogJzAnLFxuLy8gICAgIG1lbWJlcnNPbmx5OiBzZXNzaW9uLmlzQ29ubmVjdGVkKCkgPyBjb25maWcubWVtYmVyc09ubHkoKSA6IGZhbHNlXG4vLyAgIH07XG5cbi8vICAgcmV0dXJuIHJlcXVlc3QoJy9tYXNhL25ldycsIHtcbi8vICAgICBtZXRob2Q6ICdQT1NUJyxcbi8vICAgICBkYXRhXG4vLyAgIH0sIHRydWUpO1xuLy8gfVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gbG9iYnkoZmVlZGJhY2spIHtcbi8vICAgcmV0dXJuIHJlcXVlc3QoJy8nLCBudWxsLCBmZWVkYmFjayk7XG4vLyB9XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBnYW1lKGlkLCBiYWNrZ3JvdW5kKSB7XG4vLyAgIHZhciB1cmwgPSAnLycgKyBpZDtcbi8vICAgcmV0dXJuIHJlcXVlc3QodXJsLCB7IGJhY2tncm91bmQgfSwgdHJ1ZSk7XG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBnYW1lKGlkKSB7XG4gIGxldCB1cmwgPSAnLycgKyBpZDtcbiAgcmV0dXJuIGZldGNoSlNPTih1cmwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vla0dhbWUoc2V0dXApIHtcbiAgY29uc3QgeyAuLi5yZXN0IH0gPSBzZXR1cDtcblxuICBsZXQgYm9keTtcblxuICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoeyAuLi5yZXN0IH0pO1xuXG4gIHJldHVybiBmZXRjaEpTT04oJy9tYXNhL25ldycsIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5XG4gIH0sIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2VydmVyTGFuZyhsYW5nKSB7XG4gIGlmIChzZXNzaW9uLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAvLyByZXR1cm4gcmVxdWVzdCgnL3RyYW5zbGF0aW9uL3NlbGVjdCcsIHtcbiAgICAvLyAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIC8vICAgZGF0YTogeyBsYW5nIH1cbiAgICAvLyB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG4iXX0=
